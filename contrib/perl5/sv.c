begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    sv.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "I wonder what the Entish is for 'yes' and 'no'," he thought.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_SV_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_define
define|#
directive|define
name|FCALL
value|*f
end_define

begin_define
define|#
directive|define
name|SV_CHECK_THINKFIRST
parameter_list|(
name|sv
parameter_list|)
value|if (SvTHINKFIRST(sv)) sv_force_normal(sv)
end_define

begin_function_decl
specifier|static
name|void
name|do_report_used
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_clean_objs
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|DISABLE_DESTRUCTOR_KLUDGE
end_ifndef

begin_function_decl
specifier|static
name|void
name|do_clean_named_objs
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|do_clean_all
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * "A time to plant, and a time to uproot what was planted..."  */
end_comment

begin_define
define|#
directive|define
name|plant_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|STMT_START {					\ 	SvANY(p) = (void *)PL_sv_root;			\ 	SvFLAGS(p) = SVTYPEMASK;			\ 	PL_sv_root = (p);				\ 	--PL_sv_count;					\     } STMT_END
end_define

begin_comment
comment|/* sv_mutex must be held while calling uproot_SV() */
end_comment

begin_define
define|#
directive|define
name|uproot_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|STMT_START {					\ 	(p) = PL_sv_root;				\ 	PL_sv_root = (SV*)SvANY(p);			\ 	++PL_sv_count;					\     } STMT_END
end_define

begin_define
define|#
directive|define
name|new_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|STMT_START {					\ 	LOCK_SV_MUTEX;					\ 	if (PL_sv_root)					\ 	    uproot_SV(p);				\ 	else						\ 	    (p) = more_sv();				\ 	UNLOCK_SV_MUTEX;				\ 	SvANY(p) = 0;					\ 	SvREFCNT(p) = 1;				\ 	SvFLAGS(p) = 0;					\     } STMT_END
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_define
define|#
directive|define
name|del_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|STMT_START {					\ 	LOCK_SV_MUTEX;					\ 	if (PL_debug& 32768)				\ 	    del_sv(p);					\ 	else						\ 	    plant_SV(p);				\ 	UNLOCK_SV_MUTEX;				\     } STMT_END
end_define

begin_function
name|STATIC
name|void
name|S_del_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|PL_debug
operator|&
literal|32768
condition|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
name|svend
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
control|)
block|{
name|sv
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|sv
operator|&&
name|p
operator|<
name|svend
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Attempt to free non-arena SV: 0x%"
argument|UVxf
argument_list|,
argument|PTR2UV(p)
argument_list|)
empty_stmt|;
return|return;
block|}
block|}
name|plant_SV
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! DEBUGGING */
end_comment

begin_define
define|#
directive|define
name|del_SV
parameter_list|(
name|p
parameter_list|)
value|plant_SV(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUGGING */
end_comment

begin_function
name|void
name|Perl_sv_add_arena
parameter_list|(
name|pTHX_
name|char
modifier|*
name|ptr
parameter_list|,
name|U32
name|size
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sva
init|=
operator|(
name|SV
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|svend
decl_stmt|;
name|Zero
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* The first SV in an arena isn't an SV. */
name|SvANY
argument_list|(
name|sva
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|PL_sv_arenaroot
expr_stmt|;
comment|/* ptr to next arena */
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
operator|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|SV
argument_list|)
expr_stmt|;
comment|/* number of SV slots */
name|SvFLAGS
argument_list|(
name|sva
argument_list|)
operator|=
name|flags
expr_stmt|;
comment|/* FAKE if not to be freed */
name|PL_sv_arenaroot
operator|=
name|sva
expr_stmt|;
name|PL_sv_root
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|sv
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|sv
operator|<
name|svend
condition|)
block|{
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|SV
operator|*
operator|)
operator|(
name|sv
operator|+
literal|1
operator|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVTYPEMASK
expr_stmt|;
name|sv
operator|++
expr_stmt|;
block|}
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVTYPEMASK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sv_mutex must be held while calling more_sv() */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|S_more_sv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_nice_chunk
condition|)
block|{
name|sv_add_arena
argument_list|(
name|PL_nice_chunk
argument_list|,
name|PL_nice_chunk_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_nice_chunk
operator|=
name|Nullch
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|chunk
decl_stmt|;
comment|/* must use New here to match call to */
name|New
argument_list|(
literal|704
argument_list|,
name|chunk
argument_list|,
literal|1008
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* Safefree() in sv_free_arenas()     */
name|sv_add_arena
argument_list|(
name|chunk
argument_list|,
literal|1008
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|uproot_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_visit
parameter_list|(
name|pTHX_
name|SVFUNC_t
name|f
parameter_list|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|svend
decl_stmt|;
name|I32
name|visited
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
control|)
block|{
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sv
operator|=
name|sva
operator|+
literal|1
init|;
name|sv
operator|<
name|svend
condition|;
operator|++
name|sv
control|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVTYPEMASK
operator|&&
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|FCALL
operator|)
operator|(
name|aTHXo_
name|sv
operator|)
expr_stmt|;
operator|++
name|visited
expr_stmt|;
block|}
block|}
block|}
return|return
name|visited
return|;
block|}
end_function

begin_function
name|void
name|Perl_sv_report_used
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|visit
argument_list|(
name|do_report_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_clean_objs
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|PL_in_clean_objs
operator|=
name|TRUE
expr_stmt|;
name|visit
argument_list|(
name|do_clean_objs
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_DESTRUCTOR_KLUDGE
comment|/* some barnacles may yet remain, clinging to typeglobs */
name|visit
argument_list|(
name|do_clean_named_objs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_in_clean_objs
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|I32
name|Perl_sv_clean_all
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|I32
name|cleaned
decl_stmt|;
name|PL_in_clean_all
operator|=
name|TRUE
expr_stmt|;
name|cleaned
operator|=
name|visit
argument_list|(
name|do_clean_all
argument_list|)
expr_stmt|;
name|PL_in_clean_all
operator|=
name|FALSE
expr_stmt|;
return|return
name|cleaned
return|;
block|}
end_function

begin_function
name|void
name|Perl_sv_free_arenas
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|svanext
decl_stmt|;
name|XPV
modifier|*
name|arena
decl_stmt|,
modifier|*
name|arenanext
decl_stmt|;
comment|/* Free arenas here, but be careful about fake ones.  (We assume        contiguity of the fake ones with the corresponding real ones.) */
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
name|svanext
control|)
block|{
name|svanext
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
expr_stmt|;
while|while
condition|(
name|svanext
operator|&&
name|SvFAKE
argument_list|(
name|svanext
argument_list|)
condition|)
name|svanext
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|svanext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvFAKE
argument_list|(
name|sva
argument_list|)
condition|)
name|Safefree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sva
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|arena
operator|=
name|PL_xiv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xiv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
name|PL_xnv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xnv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
name|PL_xrv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xrv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
name|PL_xpv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpviv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpviv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvnv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvnv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvcv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvcv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvav_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvav_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvhv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvhv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvmg_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvmg_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvlv_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvlv_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_xpvbm_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_xpvbm_arenaroot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arena
operator|=
operator|(
name|XPV
operator|*
operator|)
name|PL_he_arenaroot
init|;
name|arena
condition|;
name|arena
operator|=
name|arenanext
control|)
block|{
name|arenanext
operator|=
operator|(
name|XPV
operator|*
operator|)
name|arena
operator|->
name|xpv_pv
expr_stmt|;
name|Safefree
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|PL_he_arenaroot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_nice_chunk
condition|)
name|Safefree
argument_list|(
name|PL_nice_chunk
argument_list|)
expr_stmt|;
name|PL_nice_chunk
operator|=
name|Nullch
expr_stmt|;
name|PL_nice_chunk_size
operator|=
literal|0
expr_stmt|;
name|PL_sv_arenaroot
operator|=
literal|0
expr_stmt|;
name|PL_sv_root
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_report_uninit
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|if
condition|(
name|PL_op
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_UNINITIALIZED
argument_list|,
argument|PL_warn_uninit
argument_list|,
literal|" in "
argument_list|,
argument|PL_op_desc[PL_op->op_type]
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_UNINITIALIZED
argument_list|,
argument|PL_warn_uninit
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVIV
modifier|*
name|S_new_xiv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|IV
modifier|*
name|xiv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xiv_root
condition|)
name|more_xiv
argument_list|()
expr_stmt|;
name|xiv
operator|=
name|PL_xiv_root
expr_stmt|;
comment|/*      * See comment in more_xiv() -- RAM.      */
name|PL_xiv_root
operator|=
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
operator|(
name|XPVIV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|xiv
operator|-
name|STRUCT_OFFSET
argument_list|(
name|XPVIV
argument_list|,
name|xiv_iv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xiv
parameter_list|(
name|pTHX_
name|XPVIV
modifier|*
name|p
parameter_list|)
block|{
name|IV
modifier|*
name|xiv
init|=
operator|(
name|IV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|STRUCT_OFFSET
argument_list|(
name|XPVIV
argument_list|,
name|xiv_iv
argument_list|)
operator|)
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
name|PL_xiv_root
expr_stmt|;
name|PL_xiv_root
operator|=
name|xiv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xiv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|IV
modifier|*
name|xiv
decl_stmt|;
specifier|register
name|IV
modifier|*
name|xivend
decl_stmt|;
name|XPV
modifier|*
name|ptr
decl_stmt|;
name|New
argument_list|(
literal|705
argument_list|,
name|ptr
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xiv_arenaroot
expr_stmt|;
comment|/* linked list of xiv arenas */
name|PL_xiv_arenaroot
operator|=
name|ptr
expr_stmt|;
comment|/* to keep Purify happy */
name|xiv
operator|=
operator|(
name|IV
operator|*
operator|)
name|ptr
expr_stmt|;
name|xivend
operator|=
operator|&
name|xiv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|IV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|xiv
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|IV
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* fudge by size of XPV */
name|PL_xiv_root
operator|=
name|xiv
expr_stmt|;
while|while
condition|(
name|xiv
operator|<
name|xivend
condition|)
block|{
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
operator|(
name|IV
operator|*
operator|)
operator|(
name|xiv
operator|+
literal|1
operator|)
expr_stmt|;
name|xiv
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVNV
modifier|*
name|S_new_xnv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|NV
modifier|*
name|xnv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xnv_root
condition|)
name|more_xnv
argument_list|()
expr_stmt|;
name|xnv
operator|=
name|PL_xnv_root
expr_stmt|;
name|PL_xnv_root
operator|=
operator|*
operator|(
name|NV
operator|*
operator|*
operator|)
name|xnv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
operator|(
name|XPVNV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|xnv
operator|-
name|STRUCT_OFFSET
argument_list|(
name|XPVNV
argument_list|,
name|xnv_nv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xnv
parameter_list|(
name|pTHX_
name|XPVNV
modifier|*
name|p
parameter_list|)
block|{
name|NV
modifier|*
name|xnv
init|=
operator|(
name|NV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|STRUCT_OFFSET
argument_list|(
name|XPVNV
argument_list|,
name|xnv_nv
argument_list|)
operator|)
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
operator|*
operator|(
name|NV
operator|*
operator|*
operator|)
name|xnv
operator|=
name|PL_xnv_root
expr_stmt|;
name|PL_xnv_root
operator|=
name|xnv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xnv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|NV
modifier|*
name|xnv
decl_stmt|;
specifier|register
name|NV
modifier|*
name|xnvend
decl_stmt|;
name|XPV
modifier|*
name|ptr
decl_stmt|;
name|New
argument_list|(
literal|711
argument_list|,
name|ptr
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xnv_arenaroot
expr_stmt|;
name|PL_xnv_arenaroot
operator|=
name|ptr
expr_stmt|;
name|xnv
operator|=
operator|(
name|NV
operator|*
operator|)
name|ptr
expr_stmt|;
name|xnvend
operator|=
operator|&
name|xnv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|NV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|xnv
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|XPVIV
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|NV
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* fudge by sizeof XPVIV */
name|PL_xnv_root
operator|=
name|xnv
expr_stmt|;
while|while
condition|(
name|xnv
operator|<
name|xnvend
condition|)
block|{
operator|*
operator|(
name|NV
operator|*
operator|*
operator|)
name|xnv
operator|=
operator|(
name|NV
operator|*
operator|)
operator|(
name|xnv
operator|+
literal|1
operator|)
expr_stmt|;
name|xnv
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|NV
operator|*
operator|*
operator|)
name|xnv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XRV
modifier|*
name|S_new_xrv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XRV
modifier|*
name|xrv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xrv_root
condition|)
name|more_xrv
argument_list|()
expr_stmt|;
name|xrv
operator|=
name|PL_xrv_root
expr_stmt|;
name|PL_xrv_root
operator|=
operator|(
name|XRV
operator|*
operator|)
name|xrv
operator|->
name|xrv_rv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xrv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xrv
parameter_list|(
name|pTHX_
name|XRV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xrv_rv
operator|=
operator|(
name|SV
operator|*
operator|)
name|PL_xrv_root
expr_stmt|;
name|PL_xrv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xrv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XRV
modifier|*
name|xrv
decl_stmt|;
specifier|register
name|XRV
modifier|*
name|xrvend
decl_stmt|;
name|XPV
modifier|*
name|ptr
decl_stmt|;
name|New
argument_list|(
literal|712
argument_list|,
name|ptr
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xrv_arenaroot
expr_stmt|;
name|PL_xrv_arenaroot
operator|=
name|ptr
expr_stmt|;
name|xrv
operator|=
operator|(
name|XRV
operator|*
operator|)
name|ptr
expr_stmt|;
name|xrvend
operator|=
operator|&
name|xrv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XRV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|xrv
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|XRV
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PL_xrv_root
operator|=
name|xrv
expr_stmt|;
while|while
condition|(
name|xrv
operator|<
name|xrvend
condition|)
block|{
name|xrv
operator|->
name|xrv_rv
operator|=
operator|(
name|SV
operator|*
operator|)
operator|(
name|xrv
operator|+
literal|1
operator|)
expr_stmt|;
name|xrv
operator|++
expr_stmt|;
block|}
name|xrv
operator|->
name|xrv_rv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPV
modifier|*
name|S_new_xpv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPV
modifier|*
name|xpv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpv_root
condition|)
name|more_xpv
argument_list|()
expr_stmt|;
name|xpv
operator|=
name|PL_xpv_root
expr_stmt|;
name|PL_xpv_root
operator|=
operator|(
name|XPV
operator|*
operator|)
name|xpv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpv
parameter_list|(
name|pTHX_
name|XPV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpv_root
expr_stmt|;
name|PL_xpv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPV
modifier|*
name|xpv
decl_stmt|;
specifier|register
name|XPV
modifier|*
name|xpvend
decl_stmt|;
name|New
argument_list|(
literal|713
argument_list|,
name|xpv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|xpv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpv_arenaroot
expr_stmt|;
name|PL_xpv_arenaroot
operator|=
name|xpv
expr_stmt|;
name|xpvend
operator|=
operator|&
name|xpv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpv_root
operator|=
operator|++
name|xpv
expr_stmt|;
while|while
condition|(
name|xpv
operator|<
name|xpvend
condition|)
block|{
name|xpv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpv
operator|++
expr_stmt|;
block|}
name|xpv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVIV
modifier|*
name|S_new_xpviv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVIV
modifier|*
name|xpviv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpviv_root
condition|)
name|more_xpviv
argument_list|()
expr_stmt|;
name|xpviv
operator|=
name|PL_xpviv_root
expr_stmt|;
name|PL_xpviv_root
operator|=
operator|(
name|XPVIV
operator|*
operator|)
name|xpviv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpviv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpviv
parameter_list|(
name|pTHX_
name|XPVIV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpviv_root
expr_stmt|;
name|PL_xpviv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpviv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVIV
modifier|*
name|xpviv
decl_stmt|;
specifier|register
name|XPVIV
modifier|*
name|xpvivend
decl_stmt|;
name|New
argument_list|(
literal|714
argument_list|,
name|xpviv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVIV
argument_list|)
argument_list|,
name|XPVIV
argument_list|)
expr_stmt|;
name|xpviv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpviv_arenaroot
expr_stmt|;
name|PL_xpviv_arenaroot
operator|=
name|xpviv
expr_stmt|;
name|xpvivend
operator|=
operator|&
name|xpviv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVIV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpviv_root
operator|=
operator|++
name|xpviv
expr_stmt|;
while|while
condition|(
name|xpviv
operator|<
name|xpvivend
condition|)
block|{
name|xpviv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpviv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpviv
operator|++
expr_stmt|;
block|}
name|xpviv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVNV
modifier|*
name|S_new_xpvnv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVNV
modifier|*
name|xpvnv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvnv_root
condition|)
name|more_xpvnv
argument_list|()
expr_stmt|;
name|xpvnv
operator|=
name|PL_xpvnv_root
expr_stmt|;
name|PL_xpvnv_root
operator|=
operator|(
name|XPVNV
operator|*
operator|)
name|xpvnv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvnv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvnv
parameter_list|(
name|pTHX_
name|XPVNV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvnv_root
expr_stmt|;
name|PL_xpvnv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvnv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVNV
modifier|*
name|xpvnv
decl_stmt|;
specifier|register
name|XPVNV
modifier|*
name|xpvnvend
decl_stmt|;
name|New
argument_list|(
literal|715
argument_list|,
name|xpvnv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVNV
argument_list|)
argument_list|,
name|XPVNV
argument_list|)
expr_stmt|;
name|xpvnv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvnv_arenaroot
expr_stmt|;
name|PL_xpvnv_arenaroot
operator|=
name|xpvnv
expr_stmt|;
name|xpvnvend
operator|=
operator|&
name|xpvnv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVNV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvnv_root
operator|=
operator|++
name|xpvnv
expr_stmt|;
while|while
condition|(
name|xpvnv
operator|<
name|xpvnvend
condition|)
block|{
name|xpvnv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvnv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvnv
operator|++
expr_stmt|;
block|}
name|xpvnv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVCV
modifier|*
name|S_new_xpvcv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVCV
modifier|*
name|xpvcv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvcv_root
condition|)
name|more_xpvcv
argument_list|()
expr_stmt|;
name|xpvcv
operator|=
name|PL_xpvcv_root
expr_stmt|;
name|PL_xpvcv_root
operator|=
operator|(
name|XPVCV
operator|*
operator|)
name|xpvcv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvcv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvcv
parameter_list|(
name|pTHX_
name|XPVCV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvcv_root
expr_stmt|;
name|PL_xpvcv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvcv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVCV
modifier|*
name|xpvcv
decl_stmt|;
specifier|register
name|XPVCV
modifier|*
name|xpvcvend
decl_stmt|;
name|New
argument_list|(
literal|716
argument_list|,
name|xpvcv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVCV
argument_list|)
argument_list|,
name|XPVCV
argument_list|)
expr_stmt|;
name|xpvcv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvcv_arenaroot
expr_stmt|;
name|PL_xpvcv_arenaroot
operator|=
name|xpvcv
expr_stmt|;
name|xpvcvend
operator|=
operator|&
name|xpvcv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVCV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvcv_root
operator|=
operator|++
name|xpvcv
expr_stmt|;
while|while
condition|(
name|xpvcv
operator|<
name|xpvcvend
condition|)
block|{
name|xpvcv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvcv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvcv
operator|++
expr_stmt|;
block|}
name|xpvcv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVAV
modifier|*
name|S_new_xpvav
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVAV
modifier|*
name|xpvav
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvav_root
condition|)
name|more_xpvav
argument_list|()
expr_stmt|;
name|xpvav
operator|=
name|PL_xpvav_root
expr_stmt|;
name|PL_xpvav_root
operator|=
operator|(
name|XPVAV
operator|*
operator|)
name|xpvav
operator|->
name|xav_array
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvav
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvav
parameter_list|(
name|pTHX_
name|XPVAV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xav_array
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvav_root
expr_stmt|;
name|PL_xpvav_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvav
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVAV
modifier|*
name|xpvav
decl_stmt|;
specifier|register
name|XPVAV
modifier|*
name|xpvavend
decl_stmt|;
name|New
argument_list|(
literal|717
argument_list|,
name|xpvav
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVAV
argument_list|)
argument_list|,
name|XPVAV
argument_list|)
expr_stmt|;
name|xpvav
operator|->
name|xav_array
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvav_arenaroot
expr_stmt|;
name|PL_xpvav_arenaroot
operator|=
name|xpvav
expr_stmt|;
name|xpvavend
operator|=
operator|&
name|xpvav
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVAV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvav_root
operator|=
operator|++
name|xpvav
expr_stmt|;
while|while
condition|(
name|xpvav
operator|<
name|xpvavend
condition|)
block|{
name|xpvav
operator|->
name|xav_array
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvav
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvav
operator|++
expr_stmt|;
block|}
name|xpvav
operator|->
name|xav_array
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVHV
modifier|*
name|S_new_xpvhv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVHV
modifier|*
name|xpvhv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvhv_root
condition|)
name|more_xpvhv
argument_list|()
expr_stmt|;
name|xpvhv
operator|=
name|PL_xpvhv_root
expr_stmt|;
name|PL_xpvhv_root
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|xpvhv
operator|->
name|xhv_array
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvhv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvhv
parameter_list|(
name|pTHX_
name|XPVHV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xhv_array
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvhv_root
expr_stmt|;
name|PL_xpvhv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvhv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xpvhv
decl_stmt|;
specifier|register
name|XPVHV
modifier|*
name|xpvhvend
decl_stmt|;
name|New
argument_list|(
literal|718
argument_list|,
name|xpvhv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVHV
argument_list|)
argument_list|,
name|XPVHV
argument_list|)
expr_stmt|;
name|xpvhv
operator|->
name|xhv_array
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvhv_arenaroot
expr_stmt|;
name|PL_xpvhv_arenaroot
operator|=
name|xpvhv
expr_stmt|;
name|xpvhvend
operator|=
operator|&
name|xpvhv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVHV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvhv_root
operator|=
operator|++
name|xpvhv
expr_stmt|;
while|while
condition|(
name|xpvhv
operator|<
name|xpvhvend
condition|)
block|{
name|xpvhv
operator|->
name|xhv_array
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvhv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvhv
operator|++
expr_stmt|;
block|}
name|xpvhv
operator|->
name|xhv_array
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVMG
modifier|*
name|S_new_xpvmg
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVMG
modifier|*
name|xpvmg
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvmg_root
condition|)
name|more_xpvmg
argument_list|()
expr_stmt|;
name|xpvmg
operator|=
name|PL_xpvmg_root
expr_stmt|;
name|PL_xpvmg_root
operator|=
operator|(
name|XPVMG
operator|*
operator|)
name|xpvmg
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvmg
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvmg
parameter_list|(
name|pTHX_
name|XPVMG
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvmg_root
expr_stmt|;
name|PL_xpvmg_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvmg
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVMG
modifier|*
name|xpvmg
decl_stmt|;
specifier|register
name|XPVMG
modifier|*
name|xpvmgend
decl_stmt|;
name|New
argument_list|(
literal|719
argument_list|,
name|xpvmg
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVMG
argument_list|)
argument_list|,
name|XPVMG
argument_list|)
expr_stmt|;
name|xpvmg
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvmg_arenaroot
expr_stmt|;
name|PL_xpvmg_arenaroot
operator|=
name|xpvmg
expr_stmt|;
name|xpvmgend
operator|=
operator|&
name|xpvmg
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVMG
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvmg_root
operator|=
operator|++
name|xpvmg
expr_stmt|;
while|while
condition|(
name|xpvmg
operator|<
name|xpvmgend
condition|)
block|{
name|xpvmg
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvmg
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvmg
operator|++
expr_stmt|;
block|}
name|xpvmg
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVLV
modifier|*
name|S_new_xpvlv
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVLV
modifier|*
name|xpvlv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvlv_root
condition|)
name|more_xpvlv
argument_list|()
expr_stmt|;
name|xpvlv
operator|=
name|PL_xpvlv_root
expr_stmt|;
name|PL_xpvlv_root
operator|=
operator|(
name|XPVLV
operator|*
operator|)
name|xpvlv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvlv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvlv
parameter_list|(
name|pTHX_
name|XPVLV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvlv_root
expr_stmt|;
name|PL_xpvlv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvlv
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVLV
modifier|*
name|xpvlv
decl_stmt|;
specifier|register
name|XPVLV
modifier|*
name|xpvlvend
decl_stmt|;
name|New
argument_list|(
literal|720
argument_list|,
name|xpvlv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVLV
argument_list|)
argument_list|,
name|XPVLV
argument_list|)
expr_stmt|;
name|xpvlv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvlv_arenaroot
expr_stmt|;
name|PL_xpvlv_arenaroot
operator|=
name|xpvlv
expr_stmt|;
name|xpvlvend
operator|=
operator|&
name|xpvlv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVLV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvlv_root
operator|=
operator|++
name|xpvlv
expr_stmt|;
while|while
condition|(
name|xpvlv
operator|<
name|xpvlvend
condition|)
block|{
name|xpvlv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvlv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvlv
operator|++
expr_stmt|;
block|}
name|xpvlv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVBM
modifier|*
name|S_new_xpvbm
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|XPVBM
modifier|*
name|xpvbm
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpvbm_root
condition|)
name|more_xpvbm
argument_list|()
expr_stmt|;
name|xpvbm
operator|=
name|PL_xpvbm_root
expr_stmt|;
name|PL_xpvbm_root
operator|=
operator|(
name|XPVBM
operator|*
operator|)
name|xpvbm
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpvbm
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_xpvbm
parameter_list|(
name|pTHX_
name|XPVBM
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvbm_root
expr_stmt|;
name|PL_xpvbm_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_xpvbm
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|XPVBM
modifier|*
name|xpvbm
decl_stmt|;
specifier|register
name|XPVBM
modifier|*
name|xpvbmend
decl_stmt|;
name|New
argument_list|(
literal|721
argument_list|,
name|xpvbm
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVBM
argument_list|)
argument_list|,
name|XPVBM
argument_list|)
expr_stmt|;
name|xpvbm
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpvbm_arenaroot
expr_stmt|;
name|PL_xpvbm_arenaroot
operator|=
name|xpvbm
expr_stmt|;
name|xpvbmend
operator|=
operator|&
name|xpvbm
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPVBM
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|PL_xpvbm_root
operator|=
operator|++
name|xpvbm
expr_stmt|;
while|while
condition|(
name|xpvbm
operator|<
name|xpvbmend
condition|)
block|{
name|xpvbm
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpvbm
operator|+
literal|1
operator|)
expr_stmt|;
name|xpvbm
operator|++
expr_stmt|;
block|}
name|xpvbm
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_define
define|#
directive|define
name|my_safemalloc
parameter_list|(
name|s
parameter_list|)
value|(void*)safexmalloc(717,s)
end_define

begin_define
define|#
directive|define
name|my_safefree
parameter_list|(
name|p
parameter_list|)
value|safexfree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|my_safemalloc
parameter_list|(
name|s
parameter_list|)
value|(void*)safemalloc(s)
end_define

begin_define
define|#
directive|define
name|my_safefree
parameter_list|(
name|p
parameter_list|)
value|safefree((char*)p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_XIV
parameter_list|()
value|my_safemalloc(sizeof(XPVIV))
end_define

begin_define
define|#
directive|define
name|del_XIV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XNV
parameter_list|()
value|my_safemalloc(sizeof(XPVNV))
end_define

begin_define
define|#
directive|define
name|del_XNV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XRV
parameter_list|()
value|my_safemalloc(sizeof(XRV))
end_define

begin_define
define|#
directive|define
name|del_XRV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPV
parameter_list|()
value|my_safemalloc(sizeof(XPV))
end_define

begin_define
define|#
directive|define
name|del_XPV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVIV
parameter_list|()
value|my_safemalloc(sizeof(XPVIV))
end_define

begin_define
define|#
directive|define
name|del_XPVIV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVNV
parameter_list|()
value|my_safemalloc(sizeof(XPVNV))
end_define

begin_define
define|#
directive|define
name|del_XPVNV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVCV
parameter_list|()
value|my_safemalloc(sizeof(XPVCV))
end_define

begin_define
define|#
directive|define
name|del_XPVCV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVAV
parameter_list|()
value|my_safemalloc(sizeof(XPVAV))
end_define

begin_define
define|#
directive|define
name|del_XPVAV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVHV
parameter_list|()
value|my_safemalloc(sizeof(XPVHV))
end_define

begin_define
define|#
directive|define
name|del_XPVHV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVMG
parameter_list|()
value|my_safemalloc(sizeof(XPVMG))
end_define

begin_define
define|#
directive|define
name|del_XPVMG
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVLV
parameter_list|()
value|my_safemalloc(sizeof(XPVLV))
end_define

begin_define
define|#
directive|define
name|del_XPVLV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVBM
parameter_list|()
value|my_safemalloc(sizeof(XPVBM))
end_define

begin_define
define|#
directive|define
name|del_XPVBM
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PURIFY */
end_comment

begin_define
define|#
directive|define
name|new_XIV
parameter_list|()
value|(void*)new_xiv()
end_define

begin_define
define|#
directive|define
name|del_XIV
parameter_list|(
name|p
parameter_list|)
value|del_xiv((XPVIV*) p)
end_define

begin_define
define|#
directive|define
name|new_XNV
parameter_list|()
value|(void*)new_xnv()
end_define

begin_define
define|#
directive|define
name|del_XNV
parameter_list|(
name|p
parameter_list|)
value|del_xnv((XPVNV*) p)
end_define

begin_define
define|#
directive|define
name|new_XRV
parameter_list|()
value|(void*)new_xrv()
end_define

begin_define
define|#
directive|define
name|del_XRV
parameter_list|(
name|p
parameter_list|)
value|del_xrv((XRV*) p)
end_define

begin_define
define|#
directive|define
name|new_XPV
parameter_list|()
value|(void*)new_xpv()
end_define

begin_define
define|#
directive|define
name|del_XPV
parameter_list|(
name|p
parameter_list|)
value|del_xpv((XPV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVIV
parameter_list|()
value|(void*)new_xpviv()
end_define

begin_define
define|#
directive|define
name|del_XPVIV
parameter_list|(
name|p
parameter_list|)
value|del_xpviv((XPVIV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVNV
parameter_list|()
value|(void*)new_xpvnv()
end_define

begin_define
define|#
directive|define
name|del_XPVNV
parameter_list|(
name|p
parameter_list|)
value|del_xpvnv((XPVNV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVCV
parameter_list|()
value|(void*)new_xpvcv()
end_define

begin_define
define|#
directive|define
name|del_XPVCV
parameter_list|(
name|p
parameter_list|)
value|del_xpvcv((XPVCV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVAV
parameter_list|()
value|(void*)new_xpvav()
end_define

begin_define
define|#
directive|define
name|del_XPVAV
parameter_list|(
name|p
parameter_list|)
value|del_xpvav((XPVAV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVHV
parameter_list|()
value|(void*)new_xpvhv()
end_define

begin_define
define|#
directive|define
name|del_XPVHV
parameter_list|(
name|p
parameter_list|)
value|del_xpvhv((XPVHV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVMG
parameter_list|()
value|(void*)new_xpvmg()
end_define

begin_define
define|#
directive|define
name|del_XPVMG
parameter_list|(
name|p
parameter_list|)
value|del_xpvmg((XPVMG *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVLV
parameter_list|()
value|(void*)new_xpvlv()
end_define

begin_define
define|#
directive|define
name|del_XPVLV
parameter_list|(
name|p
parameter_list|)
value|del_xpvlv((XPVLV *)p)
end_define

begin_define
define|#
directive|define
name|new_XPVBM
parameter_list|()
value|(void*)new_xpvbm()
end_define

begin_define
define|#
directive|define
name|del_XPVBM
parameter_list|(
name|p
parameter_list|)
value|del_xpvbm((XPVBM *)p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PURIFY */
end_comment

begin_define
define|#
directive|define
name|new_XPVGV
parameter_list|()
value|my_safemalloc(sizeof(XPVGV))
end_define

begin_define
define|#
directive|define
name|del_XPVGV
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVFM
parameter_list|()
value|my_safemalloc(sizeof(XPVFM))
end_define

begin_define
define|#
directive|define
name|del_XPVFM
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_define
define|#
directive|define
name|new_XPVIO
parameter_list|()
value|my_safemalloc(sizeof(XPVIO))
end_define

begin_define
define|#
directive|define
name|del_XPVIO
parameter_list|(
name|p
parameter_list|)
value|my_safefree(p)
end_define

begin_comment
comment|/* =for apidoc sv_upgrade  Upgrade an SV to a more complex form.  Use C<SvUPGRADE>.  See C<svtype>.  =cut */
end_comment

begin_function
name|bool
name|Perl_sv_upgrade
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|U32
name|mt
parameter_list|)
block|{
name|char
modifier|*
name|pv
decl_stmt|;
name|U32
name|cur
decl_stmt|;
name|U32
name|len
decl_stmt|;
name|IV
name|iv
decl_stmt|;
name|NV
name|nv
decl_stmt|;
name|MAGIC
modifier|*
name|magic
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|mt
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mt
operator|<
name|SVt_PVIV
condition|)
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_IV
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
operator|(
name|NV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|del_XIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mt
operator|==
name|SVt_NV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
elseif|else
if|if
condition|(
name|mt
operator|<
name|SVt_PVIV
condition|)
name|mt
operator|=
name|SVt_PVIV
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|I_V
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mt
operator|<
name|SVt_PVNV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|pv
operator|=
operator|(
name|char
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
name|PTR2IV
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|nv
operator|=
name|PTR2NV
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|<=
name|SVt_IV
condition|)
name|mt
operator|=
name|SVt_PVIV
expr_stmt|;
elseif|else
if|if
condition|(
name|mt
operator|==
name|SVt_NV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPVIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPVNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|magic
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|stash
operator|=
name|SvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|del_XPVMG
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't upgrade that kind of scalar"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mt
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't upgrade to undef"
argument_list|)
expr_stmt|;
case|case
name|SVt_IV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XIV
argument_list|()
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XNV
argument_list|()
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XRV
argument_list|()
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|SV
operator|*
operator|)
name|pv
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVIV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
if|if
condition|(
name|SvNIOK
argument_list|(
name|sv
argument_list|)
condition|)
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvNOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVNV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVMG
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVLV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|LvTARGOFF
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTARG
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTYPE
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVAV
argument_list|()
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|Safefree
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvMAX
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|AvFILLp
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0.0
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|AvALLOC
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvARYLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVHV
argument_list|()
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|Safefree
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvFILL
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvMAX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvKEYS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0.0
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|HvRITER
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvEITER
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvPMROOT
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvNAME
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVCV
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVCV
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVGV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|GvGP
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvNAME
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvNAMELEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVBM
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVBM
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|BmRARE
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVFM
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVFM
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVIO
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVIO
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|IoPAGE_LEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|60
expr_stmt|;
break|break;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|mt
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|Perl_sv_backoff
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|assert
argument_list|(
name|SvOOK
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|-=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIV_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVf_OOK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_grow  Expands the character buffer in the SV.  This will use C<sv_unref> and will upgrade the SV to C<SVt_PV>.  Returns a pointer to the character buffer. Use C<SvGROW>.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_grow
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|STRLEN
name|newlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|newlen
operator|>=
literal|0x10000
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Allocation too large: %"
name|UVxf
literal|"\n"
argument_list|,
operator|(
name|UV
operator|)
name|newlen
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvOOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* pv is offset? */
name|sv_backoff
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|newlen
operator|+=
literal|10
operator|*
operator|(
name|newlen
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|)
expr_stmt|;
comment|/* avoid copy each time */
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|newlen
operator|>=
literal|0x10000
condition|)
name|newlen
operator|=
literal|0xFFFF
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* need more room? */
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|&&
name|s
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LEAKTEST
argument_list|)
name|STRLEN
name|l
init|=
name|malloced_size
argument_list|(
operator|(
name|void
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlen
operator|<=
name|l
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
endif|#
directive|endif
name|Renew
argument_list|(
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
name|New
argument_list|(
literal|703
argument_list|,
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|sv
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setiv  Copies an integer into the given SV.  Does not handle 'set' magic.  See C<sv_setiv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setiv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|i
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
case|case
name|SVt_PVIO
case|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't coerce %s to integer in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PL_op_desc
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate number */
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|i
expr_stmt|;
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setiv_mg  Like C<sv_setiv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setiv_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|i
parameter_list|)
block|{
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setuv  Copies an unsigned integer into the given SV.  Does not handle 'set' magic. See C<sv_setuv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setuv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|UV
name|u
parameter_list|)
block|{
name|sv_setiv
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|u
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setuv_mg  Like C<sv_setuv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setuv_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|UV
name|u
parameter_list|)
block|{
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setnv  Copies a double into the given SV.  Does not handle 'set' magic.  See C<sv_setnv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setnv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|NV
name|num
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
case|case
name|SVt_PVIO
case|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't coerce %s to number in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PL_op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate number */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setnv_mg  Like C<sv_setnv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setnv_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|NV
name|num
parameter_list|)
block|{
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_not_a_number
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|tmpbuf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|tmpbuf
operator|+
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|8
decl_stmt|;
comment|/* each *s can expand to 4 chars + "...\0",                      i.e. need room for 8 chars */
for|for
control|(
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
init|;
operator|*
name|s
operator|&&
name|d
operator|<
name|limit
condition|;
name|s
operator|++
control|)
block|{
name|int
name|ch
init|=
operator|*
name|s
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|ch
operator|&
literal|128
operator|&&
operator|!
name|isPRINT_LC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'-'
expr_stmt|;
name|ch
operator|&=
literal|127
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\f'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'f'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPRINT_LC
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|ch
expr_stmt|;
else|else
block|{
operator|*
name|d
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|toCTRL
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|PL_op
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NUMERIC
argument_list|,
literal|"Argument \"%s\" isn't numeric in %s"
argument_list|,
argument|tmpbuf
argument_list|,
argument|PL_op_desc[PL_op->op_type]
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NUMERIC
argument_list|,
literal|"Argument \"%s\" isn't numeric"
argument_list|,
argument|tmpbuf
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* the number can be converted to integer with atol() or atoll() */
end_comment

begin_define
define|#
directive|define
name|IS_NUMBER_TO_INT_BY_ATOL
value|0x01
end_define

begin_define
define|#
directive|define
name|IS_NUMBER_TO_INT_BY_ATOF
value|0x02
end_define

begin_comment
comment|/* atol() may be != atof() */
end_comment

begin_define
define|#
directive|define
name|IS_NUMBER_NOT_IV
value|0x04
end_define

begin_comment
comment|/* (IV)atof() may be != atof() */
end_comment

begin_define
define|#
directive|define
name|IS_NUMBER_NEG
value|0x08
end_define

begin_comment
comment|/* not good to cache UV */
end_comment

begin_define
define|#
directive|define
name|IS_NUMBER_INFINITY
value|0x10
end_define

begin_comment
comment|/* this is big */
end_comment

begin_comment
comment|/* Actually, ISO C leaves conversion of UV to IV undefined, but    until proven guilty, assume that things are not that bad... */
end_comment

begin_function
name|IV
name|Perl_sv_2iv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
return|return
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asIV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
operator|&&
operator|(
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
operator|!=
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
return|return
name|SvIV
argument_list|(
name|tmpstr
argument_list|)
return|;
return|return
name|PTR2IV
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
return|return
call|(
name|IV
call|)
argument_list|(
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* We can cache the IV/UV value even if it not good enough 	 * to reconstruct NV, since the conversion to PV will prefer 	 * NV over IV/UV. 	 */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_NV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
operator|(
name|NV
operator|)
name|IV_MAX
operator|+
literal|0.5
condition|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|ret_iv_max
label|:
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2iv(%"
name|UVuf
literal|" => %"
name|IVdf
literal|") (as unsigned)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|IV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* We want to avoid a possible problem when we cache an IV which 	   may be later translated to an NV, and the resulting NV is not 	   the translation of the initial data. 	   	   This means that if we cache such an IV, we need to cache the 	   NV as well.  Moreover, we trade speed for space, and do not 	   cache the NV if not needed. 	 */
if|if
condition|(
name|numtype
operator|&
name|IS_NUMBER_NOT_IV
condition|)
block|{
comment|/* May be not an integer.  Need to cache NV if we cache IV 	     * - otherwise future conversion to NV will be wrong.  */
name|NV
name|d
decl_stmt|;
name|d
operator|=
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|d
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2nv(%"
name|PERL_PRIgldbl
literal|")\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2nv(%g)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
operator|(
name|NV
operator|)
name|IV_MAX
operator|+
literal|0.5
condition|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|ret_iv_max
goto|;
block|}
block|}
else|else
block|{
comment|/* The NV may be reconstructed from IV - safe to cache IV, 		   which may be calculated by atol(). */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|Atol
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numtype
operator|&&
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_IV
condition|)
comment|/* Typically the caller expects that sv_any is not NULL now.  */
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2iv(%"
name|IVdf
literal|")\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|?
operator|(
name|IV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
else|:
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|UV
name|Perl_sv_2uv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asUV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
operator|&&
operator|(
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
operator|!=
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
return|return
name|SvUV
argument_list|(
name|tmpstr
argument_list|)
return|;
return|return
name|PTR2UV
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|UV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* We can cache the IV/UV value even if it not good enough 	 * to reconstruct NV, since the conversion to PV will prefer 	 * NV over IV/UV. 	 */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_NV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|>=
operator|-
literal|0.5
condition|)
block|{
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|ret_zero
label|:
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2uv(%"
name|IVdf
literal|" => %"
name|IVdf
literal|") (as signed)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
operator|(
name|UV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|UV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* We want to avoid a possible problem when we cache a UV which 	   may be later translated to an NV, and the resulting NV is not 	   the translation of the initial data. 	   	   This means that if we cache such a UV, we need to cache the 	   NV as well.  Moreover, we trade speed for space, and do not 	   cache the NV if not needed. 	 */
if|if
condition|(
name|numtype
operator|&
name|IS_NUMBER_NOT_IV
condition|)
block|{
comment|/* May be not an integer.  Need to cache NV if we cache IV 	     * - otherwise future conversion to NV will be wrong.  */
name|NV
name|d
decl_stmt|;
name|d
operator|=
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|d
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2nv(%"
name|PERL_PRIgldbl
literal|")\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2nv(%g)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
operator|-
literal|0.5
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret_zero
goto|;
block|}
else|else
block|{
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|numtype
operator|&
name|IS_NUMBER_NEG
condition|)
block|{
comment|/* The NV may be reconstructed from IV - safe to cache IV, 	       which may be calculated by atol(). */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|IV
operator|)
name|Atol
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numtype
condition|)
block|{
comment|/* Non-negative */
comment|/* The NV may be reconstructed from UV - safe to cache UV, 	       which may be calculated by strtoul()/atol. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_STRTOUL
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|Strtoul
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no atou(), but we know the number fits into IV... */
comment|/* The only problem may be if it is negative... */
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|UV
operator|)
name|Atol
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Not a number.  Cache 0. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We assume that 0s have the 					   same bitmap in IV and UV. */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_IV
condition|)
comment|/* Typically the caller expects that sv_any is not NULL now.  */
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2uv(%"
name|UVuf
literal|")\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|?
name|SvUVX
argument_list|(
name|sv
argument_list|)
else|:
operator|(
name|UV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|NV
name|Perl_sv_2nv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
operator|&&
operator|!
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
return|return
operator|(
name|NV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
else|else
return|return
operator|(
name|NV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
operator|&&
operator|(
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
operator|!=
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
return|return
name|SvNV
argument_list|(
name|tmpstr
argument_list|)
return|;
return|return
name|PTR2NV
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
return|return
literal|0.0
return|;
block|}
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_NV
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_IV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|else
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
name|DEBUG_c
argument_list|(
argument|{ 	    STORE_NUMERIC_LOCAL_SET_STANDARD(); 	    PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|" num(%"
argument|PERL_PRIgldbl
literal|")\n"
argument|, 			  PTR2UV(sv), SvNVX(sv)); 	    RESTORE_NUMERIC_LOCAL(); 	}
argument_list|)
empty_stmt|;
else|#
directive|else
name|DEBUG_c
argument_list|(
argument|{ 	    STORE_NUMERIC_LOCAL_SET_STANDARD(); 	    PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|" num(%g)\n"
argument|, 			  PTR2UV(sv), SvNVX(sv)); 	    RESTORE_NUMERIC_LOCAL(); 	}
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|||
operator|!
name|strchr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|'.'
argument_list|)
operator|||
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
block|{
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|?
operator|(
name|NV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
else|:
operator|(
name|NV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
operator|&&
operator|!
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_NV
condition|)
comment|/* Typically the caller expects that sv_any is not NULL now.  */
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
name|SvNOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
name|DEBUG_c
argument_list|(
argument|{ 	STORE_NUMERIC_LOCAL_SET_STANDARD(); 	PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|" 2nv(%"
argument|PERL_PRIgldbl
literal|")\n"
argument|, 		      PTR2UV(sv), SvNVX(sv)); 	RESTORE_NUMERIC_LOCAL();     }
argument_list|)
empty_stmt|;
else|#
directive|else
name|DEBUG_c
argument_list|(
argument|{ 	STORE_NUMERIC_LOCAL_SET_STANDARD(); 	PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|" 1nv(%g)\n"
argument|, 		      PTR2UV(sv), SvNVX(sv)); 	RESTORE_NUMERIC_LOCAL();     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|IV
name|S_asIV
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|NV
name|d
decl_stmt|;
if|if
condition|(
name|numtype
operator|&
name|IS_NUMBER_TO_INT_BY_ATOL
condition|)
return|return
name|Atol
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|numtype
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|I_V
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|UV
name|S_asUV
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_STRTOUL
if|if
condition|(
name|numtype
operator|&
name|IS_NUMBER_TO_INT_BY_ATOL
condition|)
return|return
name|Strtoul
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
literal|10
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|numtype
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NUMERIC
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
return|return
name|U_V
argument_list|(
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a combination of (advisory only - can get false negatives)  * 	IS_NUMBER_TO_INT_BY_ATOL, IS_NUMBER_TO_INT_BY_ATOF, IS_NUMBER_NOT_IV,  *	IS_NUMBER_NEG  * 0 if does not look like number.  *  * In fact possible values are 0 and  * IS_NUMBER_TO_INT_BY_ATOL				123  * IS_NUMBER_TO_INT_BY_ATOL | IS_NUMBER_NOT_IV		123.1  * IS_NUMBER_TO_INT_BY_ATOF | IS_NUMBER_NOT_IV		123e0  * IS_NUMBER_INFINITY  * with a possible addition of IS_NUMBER_NEG.  */
end_comment

begin_comment
comment|/* =for apidoc looks_like_number  Test if an the content of an SV looks like a number (or is a number).  =cut */
end_comment

begin_function
name|I32
name|Perl_looks_like_number
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbegin
decl_stmt|;
specifier|register
name|char
modifier|*
name|nbegin
decl_stmt|;
name|I32
name|numtype
init|=
literal|0
decl_stmt|;
name|I32
name|sawinf
init|=
literal|0
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|bool
name|specialradix
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sbegin
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
name|sbegin
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
name|send
operator|=
name|sbegin
operator|+
name|len
expr_stmt|;
name|s
operator|=
name|sbegin
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|numtype
operator|=
name|IS_NUMBER_NEG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
name|nbegin
operator|=
name|s
expr_stmt|;
comment|/*      * we return IS_NUMBER_TO_INT_BY_ATOL if the number can be converted      * to _integer_ with atol() and IS_NUMBER_TO_INT_BY_ATOF if you need      * (int)atof().      */
comment|/* next must be digit or the radix separator or beginning of infinity */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|-
name|nbegin
operator|>=
name|TYPE_DIGITS
argument_list|(
name|IV
argument_list|)
condition|)
comment|/* Cannot cache ato[ul]() */
name|numtype
operator||=
name|IS_NUMBER_TO_INT_BY_ATOF
operator||
name|IS_NUMBER_NOT_IV
expr_stmt|;
else|else
name|numtype
operator||=
name|IS_NUMBER_TO_INT_BY_ATOL
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
operator|||
operator|(
name|specialradix
operator|=
name|IS_NUMERIC_RADIX
argument_list|(
name|s
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
name|specialradix
condition|)
name|s
operator|+=
name|SvCUR
argument_list|(
name|PL_numeric_radix_sv
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|s
operator|++
expr_stmt|;
name|numtype
operator||=
name|IS_NUMBER_NOT_IV
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* optional digits after the radix */
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
operator|||
operator|(
name|specialradix
operator|=
name|IS_NUMERIC_RADIX
argument_list|(
name|s
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
name|specialradix
condition|)
name|s
operator|+=
name|SvCUR
argument_list|(
name|PL_numeric_radix_sv
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|s
operator|++
expr_stmt|;
name|numtype
operator||=
name|IS_NUMBER_TO_INT_BY_ATOL
operator||
name|IS_NUMBER_NOT_IV
expr_stmt|;
comment|/* no digits before the radix means we need digits after it */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'I'
operator|||
operator|*
name|s
operator|==
literal|'i'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'N'
operator|&&
operator|*
name|s
operator|!=
literal|'n'
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'F'
operator|&&
operator|*
name|s
operator|!=
literal|'f'
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'I'
operator|||
operator|*
name|s
operator|==
literal|'i'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'N'
operator|&&
operator|*
name|s
operator|!=
literal|'n'
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'I'
operator|&&
operator|*
name|s
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'T'
operator|&&
operator|*
name|s
operator|!=
literal|'t'
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'Y'
operator|&&
operator|*
name|s
operator|!=
literal|'y'
condition|)
return|return
literal|0
return|;
block|}
name|sawinf
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|sawinf
condition|)
name|numtype
operator|=
name|IS_NUMBER_INFINITY
expr_stmt|;
else|else
block|{
comment|/* we can have an optional exponent part */
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'E'
condition|)
block|{
name|numtype
operator|&=
operator|~
name|IS_NUMBER_NEG
expr_stmt|;
name|numtype
operator||=
name|IS_NUMBER_TO_INT_BY_ATOF
operator||
name|IS_NUMBER_NOT_IV
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
return|return
name|numtype
return|;
if|if
condition|(
name|len
operator|==
literal|10
operator|&&
name|memEQ
argument_list|(
name|sbegin
argument_list|,
literal|"0 but true"
argument_list|,
literal|10
argument_list|)
condition|)
return|return
name|IS_NUMBER_TO_INT_BY_ATOL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pv_nolen
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We assume that buf is at least TYPE_CHARS(UV) long. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|uiv_2buf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|IV
name|iv
parameter_list|,
name|UV
name|uv
parameter_list|,
name|int
name|is_uv
parameter_list|,
name|char
modifier|*
modifier|*
name|peob
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
name|buf
operator|+
name|TYPE_CHARS
argument_list|(
name|UV
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ebuf
init|=
name|ptr
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|is_uv
condition|)
name|sign
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|iv
operator|>=
literal|0
condition|)
block|{
name|uv
operator|=
name|iv
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uv
operator|=
operator|-
name|iv
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
operator|*
operator|--
name|ptr
operator|=
literal|'0'
operator|+
operator|(
name|uv
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|/=
literal|10
condition|)
do|;
if|if
condition|(
name|sign
condition|)
operator|*
operator|--
name|ptr
operator|=
literal|'-'
expr_stmt|;
operator|*
name|peob
operator|=
name|ebuf
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|olderrno
decl_stmt|;
name|SV
modifier|*
name|tsv
decl_stmt|;
name|char
name|tbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* Must fit sprintf/Gconvert of longest IV/NV */
name|char
modifier|*
name|tmpbuf
init|=
name|tbuf
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
block|{
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%"
name|UVuf
argument_list|,
operator|(
name|UV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|Gconvert
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|NV_DIG
argument_list|,
literal|0
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
block|}
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|string
argument_list|)
operator|)
operator|&&
operator|(
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
operator|!=
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
return|return
name|SvPV
argument_list|(
name|tmpstr
argument_list|,
operator|*
name|lp
argument_list|)
return|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|s
operator|=
literal|"NULLREF"
expr_stmt|;
else|else
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVMG
case|:
if|if
condition|(
operator|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVs_OBJECT
operator||
name|SVf_OK
operator||
name|SVs_GMG
operator||
name|SVs_SMG
operator||
name|SVs_RMG
operator|)
operator|)
operator|==
operator|(
name|SVs_OBJECT
operator||
name|SVs_RMG
operator|)
operator|)
operator|&&
name|strEQ
argument_list|(
name|s
operator|=
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|,
literal|"Regexp"
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'r'
argument_list|)
operator|)
condition|)
block|{
name|regexp
modifier|*
name|re
init|=
operator|(
name|regexp
operator|*
operator|)
name|mg
operator|->
name|mg_obj
decl_stmt|;
if|if
condition|(
operator|!
name|mg
operator|->
name|mg_ptr
condition|)
block|{
name|char
modifier|*
name|fptr
init|=
literal|"msix"
decl_stmt|;
name|char
name|reflags
index|[
literal|6
index|]
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
literal|4
decl_stmt|;
name|U16
name|reganch
init|=
operator|(
name|re
operator|->
name|reganch
operator|&
name|PMf_COMPILETIME
operator|)
operator|>>
literal|12
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fptr
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|reganch
operator|&
literal|1
condition|)
block|{
name|reflags
index|[
name|left
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|reflags
index|[
name|right
operator|--
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|reganch
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|!=
literal|4
condition|)
block|{
name|reflags
index|[
name|left
index|]
operator|=
literal|'-'
expr_stmt|;
name|left
operator|=
literal|5
expr_stmt|;
block|}
name|mg
operator|->
name|mg_len
operator|=
name|re
operator|->
name|prelen
operator|+
literal|4
operator|+
name|left
expr_stmt|;
name|New
argument_list|(
literal|616
argument_list|,
name|mg
operator|->
name|mg_ptr
argument_list|,
name|mg
operator|->
name|mg_len
operator|+
literal|1
operator|+
name|left
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
literal|"(?"
argument_list|,
name|mg
operator|->
name|mg_ptr
argument_list|,
literal|2
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|reflags
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
literal|2
argument_list|,
name|left
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
literal|":"
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
name|left
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|re
operator|->
name|precomp
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
literal|3
operator|+
name|left
argument_list|,
name|re
operator|->
name|prelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_ptr
index|[
name|mg
operator|->
name|mg_len
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|mg
operator|->
name|mg_ptr
index|[
name|mg
operator|->
name|mg_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PL_reginterp_cnt
operator|+=
name|re
operator|->
name|program
index|[
literal|0
index|]
operator|.
name|next_off
expr_stmt|;
operator|*
name|lp
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
return|return
name|mg
operator|->
name|mg_ptr
return|;
block|}
comment|/* Fall through */
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
case|case
name|SVt_NV
case|:
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVBM
case|:
name|s
operator|=
literal|"SCALAR"
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|s
operator|=
literal|"LVALUE"
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|s
operator|=
literal|"ARRAY"
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|s
operator|=
literal|"HASH"
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|s
operator|=
literal|"CODE"
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|s
operator|=
literal|"GLOB"
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|s
operator|=
literal|"FORMAT"
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|s
operator|=
literal|"IO"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"UNKNOWN"
expr_stmt|;
break|break;
block|}
name|tsv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ tsv
argument_list|,
literal|"%s=%s"
argument_list|,
argument|HvNAME(SvSTASH(sv))
argument_list|,
argument|s
argument_list|)
empty_stmt|;
else|else
name|sv_setpv
argument_list|(
name|tsv
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ tsv
argument_list|,
literal|"(0x%"
argument|UVxf
literal|")"
argument_list|,
argument|PTR2UV(sv)
argument_list|)
empty_stmt|;
goto|goto
name|tokensaveref
goto|;
block|}
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* See note in sv_2uv() */
comment|/* XXXX 64-bit?  IV may have better precision... */
comment|/* I tried changing this to be 64-bit-aware and 	 * the t/op/numconvert.t became very, very, angry. 	 * --jhi Sep 1999 */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
comment|/* The +20 is pure guesswork.  Configure test needed. --jhi */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|NV_DIG
operator|+
literal|20
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
comment|/* some Xenix systems wipe out errno here */
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0.0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/*apollo*/
block|{
name|Gconvert
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|NV_DIG
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|olderrno
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXNEGATIVEZERO
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
operator|!
name|s
index|[
literal|2
index|]
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|hcx
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|U32
name|isIOK
init|=
name|SvIOK
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|U32
name|isUIOK
init|=
name|SvIsUV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|TYPE_CHARS
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|ebuf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUIOK
condition|)
name|ptr
operator|=
name|uiv_2buf
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ebuf
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|uiv_2buf
argument_list|(
name|buf
argument_list|,
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ebuf
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|ebuf
operator|-
name|ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* inlined from sv_setpvn */
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|ebuf
operator|-
name|ptr
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|ebuf
operator|-
name|ptr
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isIOK
condition|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|SvIOKp_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUIOK
condition|)
name|SvIsUV_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PV
condition|)
comment|/* Typically the caller expects that sv_any is not NULL now.  */
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
operator|*
name|lp
operator|=
name|s
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
operator|*
name|lp
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2pv(%s)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
name|tokensave
label|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* XXX Skip this when sv_pvn_force calls */
comment|/* Sneaky stuff here */
name|tokensaveref
label|:
if|if
condition|(
operator|!
name|tsv
condition|)
name|tsv
operator|=
name|newSVpv
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_2mortal
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|tsv
argument_list|)
return|;
block|}
else|else
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|tsv
condition|)
block|{
name|sv_2mortal
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvPVX
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvCUR
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|tmpbuf
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FIXNEGATIVEZERO
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|t
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
block|{
name|t
operator|=
literal|"0"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SvPOKp_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pvbyte_nolen
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
return|return
name|sv_2pvbyte
argument_list|(
name|sv
argument_list|,
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pvbyte
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pvutf8_nolen
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
return|return
name|sv_2pvutf8
argument_list|(
name|sv
argument_list|,
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_2pvutf8
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|SvPV
argument_list|(
name|sv
argument_list|,
operator|*
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is only called on magical items */
end_comment

begin_function
name|bool
name|Perl_sv_2bool
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpsv
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|bool_
argument_list|)
operator|)
operator|&&
operator|(
name|SvRV
argument_list|(
name|tmpsv
argument_list|)
operator|!=
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
return|return
name|SvTRUE
argument_list|(
name|tmpsv
argument_list|)
return|;
return|return
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
specifier|register
name|XPV
modifier|*
name|Xpvtmp
decl_stmt|;
if|if
condition|(
operator|(
name|Xpvtmp
operator|=
operator|(
name|XPV
operator|*
operator|)
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|Xpvtmp
operator|->
name|xpv_pv
operator|>
literal|'0'
operator|||
name|Xpvtmp
operator|->
name|xpv_cur
operator|>
literal|1
operator|||
operator|(
name|Xpvtmp
operator|->
name|xpv_cur
operator|&&
operator|*
name|Xpvtmp
operator|->
name|xpv_pv
operator|!=
literal|'0'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
else|else
block|{
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
return|;
else|else
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_utf8_upgrade  Convert the PV of an SV to its UTF8-encoded form.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_utf8_upgrade
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|hibit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
operator|||
name|SvUTF8
argument_list|(
name|sv
argument_list|)
condition|)
return|return;
comment|/* This function could be much more efficient if we had a FLAG in SVs      * to signal if there are any hibit chars in the PV.      * Given that there isn't make loop fast as possible      */
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|e
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|(
name|hibit
operator|=
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|t
operator|++
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|hibit
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_force_normal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Plus the \0 */
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|bytes_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
condition|)
name|Safefree
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* No longer using what was there before. */
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
comment|/* No longer know the real size. */
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_utf8_downgrade  Attempt to convert the PV of an SV from UTF8-encoded to byte encoding. This may not be possible if the PV contains non-byte encoding characters; if this is the case, either returns false or, if C<fail_ok> is not true, croaks.  =cut */
end_comment

begin_function
name|bool
name|Perl_sv_utf8_downgrade
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|bool
name|fail_ok
parameter_list|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvUTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_force_normal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|utf8_to_bytes
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail_ok
condition|)
return|return
name|FALSE
return|;
else|else
block|{
if|if
condition|(
name|PL_op
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Wide character in %s"
argument_list|,
name|PL_op_desc
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Wide character"
argument_list|)
expr_stmt|;
block|}
block|}
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
block|}
name|SvUTF8_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_utf8_encode  Convert the PV of an SV to UTF8-encoded, but then turn off the C<SvUTF8> flag so that it looks like bytes again. Nothing calls this.   =cut */
end_comment

begin_function
name|void
name|Perl_sv_utf8_encode
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|Perl_sv_utf8_decode
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|bool
name|has_utf
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|sv_utf8_downgrade
argument_list|(
name|sv
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* it is actually just a matter of turning the utf8 flag on, but          * we want to make sure everything inside is valid utf8 first.          */
name|c
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|c
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|e
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|c
operator|++
argument_list|)
condition|)
block|{
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Note: sv_setsv() should not be called with a source string that needs  * to be reused, since it may destroy the source string if it is marked  * as temporary.  */
end_comment

begin_comment
comment|/* =for apidoc sv_setsv  Copies the contents of the source SV C<ssv> into the destination SV C<dsv>. The source SV may be destroyed if it is mortal.  Does not handle 'set' magic.  See the macro forms C<SvSetSV>, C<SvSetSV_nosteal> and C<sv_setsv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setsv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
specifier|register
name|U32
name|sflags
decl_stmt|;
specifier|register
name|int
name|dtype
decl_stmt|;
specifier|register
name|int
name|stype
decl_stmt|;
if|if
condition|(
name|sstr
operator|==
name|dstr
condition|)
return|return;
name|SV_CHECK_THINKFIRST
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sstr
condition|)
name|sstr
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|stype
operator|=
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|SvTYPE
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvAMAGIC_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* There's a lot of redundancy below but we're going for speed here */
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|undef_sstr
label|:
if|if
condition|(
name|dtype
operator|!=
name|SVt_PVGV
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SVt_IV
case|:
if|if
condition|(
name|SvIOK
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIsUV
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvIsUV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAINTED
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|undef_sstr
goto|;
case|case
name|SVt_NV
case|:
if|if
condition|(
name|SvNOK
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
block|}
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAINTED
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|undef_sstr
goto|;
case|case
name|SVt_RV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_RV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|sstr
operator|=
name|SvRV
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstr
operator|==
name|dstr
condition|)
block|{
if|if
condition|(
name|GvIMPORTED
argument_list|(
name|dstr
argument_list|)
operator|!=
name|GVf_IMPORTED
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|glob_assign
goto|;
block|}
break|break;
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVFM
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|PL_op
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bizarre copy of %s in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PL_op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bizarre copy of %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|dtype
operator|<=
name|SVt_PVGV
condition|)
block|{
name|glob_assign
label|:
if|if
condition|(
name|dtype
operator|!=
name|SVt_PVGV
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|GvNAME
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|STRLEN
name|len
init|=
name|GvNAMELEN
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|dstr
argument_list|,
name|dstr
argument_list|,
literal|'*'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|GvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvNAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|GvNAMELEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvFAKE_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* can coerce to non-glob */
block|}
comment|/* ahem, death to those who redefine active sort subs */
elseif|else
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|GvNAME
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvINTRO_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* one-shot flag */
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|GvGP
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAINTED
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED
argument_list|(
name|dstr
argument_list|)
operator|!=
name|GVf_IMPORTED
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
operator|!=
name|stype
condition|)
block|{
name|stype
operator|=
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stype
operator|==
name|SVt_PVGV
operator|&&
name|dtype
operator|<=
name|SVt_PVGV
condition|)
goto|goto
name|glob_assign
goto|;
block|}
block|}
if|if
condition|(
name|stype
operator|==
name|SVt_PVLV
condition|)
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|dstr
argument_list|,
name|stype
argument_list|)
expr_stmt|;
block|}
name|sflags
operator|=
name|SvFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_ROK
condition|)
block|{
if|if
condition|(
name|dtype
operator|>=
name|SVt_PV
condition|)
block|{
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
condition|)
block|{
name|SV
modifier|*
name|sref
init|=
name|SvREFCNT_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|dref
init|=
literal|0
decl_stmt|;
name|int
name|intro
init|=
name|GvINTRO
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|intro
condition|)
block|{
name|GP
modifier|*
name|gp
decl_stmt|;
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
expr_stmt|;
name|GvINTRO_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* one-shot flag */
name|Newz
argument_list|(
literal|602
argument_list|,
name|gp
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|dstr
argument_list|)
operator|=
name|NEWSV
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvLINE
argument_list|(
name|dstr
argument_list|)
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|GvEGV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|dstr
expr_stmt|;
block|}
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sref
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvAV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvAV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|sref
expr_stmt|;
if|if
condition|(
operator|!
name|GvIMPORTED_AV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_AV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SVt_PVHV
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvHV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvHV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|sref
expr_stmt|;
if|if
condition|(
operator|!
name|GvIMPORTED_HV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_HV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|intro
condition|)
block|{
if|if
condition|(
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|&&
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|!=
operator|(
name|CV
operator|*
operator|)
name|sref
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Switch off cacheness. */
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|!=
operator|(
name|CV
operator|*
operator|)
name|sref
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|GvCV
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
if|if
condition|(
operator|!
name|GvCVGEN
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|const_sv
init|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|bool
name|const_changed
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|const_sv
condition|)
name|const_changed
operator|=
name|sv_cmp
argument_list|(
name|const_sv
argument_list|,
name|op_const_sv
argument_list|(
name|CvSTART
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sref
argument_list|)
argument_list|,
name|Nullcv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ahem, death to those who redefine 				 * active sort subs */
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|cv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|GvENAME
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|const_changed
operator|||
name|const_sv
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_REDEFINE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REDEFINE
argument_list|,
argument|const_sv ?
literal|"Constant subroutine %s redefined"
argument|:
literal|"Subroutine %s redefined"
argument_list|,
argument|GvENAME((GV*)dstr)
argument_list|)
empty_stmt|;
block|}
name|cv_ckproto
argument_list|(
name|cv
argument_list|,
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|,
name|SvPOK
argument_list|(
name|sref
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|sref
argument_list|)
else|:
name|Nullch
argument_list|)
expr_stmt|;
block|}
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|sref
expr_stmt|;
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Switch off cacheness. */
name|GvASSUMECV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|GvIMPORTED_CV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_CV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvIOp
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvIOp
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|IO
operator|*
operator|)
name|sref
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvSV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sref
expr_stmt|;
if|if
condition|(
operator|!
name|GvIMPORTED_SV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
block|{
name|GvIMPORTED_SV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|dref
condition|)
name|SvREFCNT_dec
argument_list|(
name|dref
argument_list|)
expr_stmt|;
if|if
condition|(
name|intro
condition|)
name|SAVEFREESV
argument_list|(
name|sref
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAINTED
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* backoff */
if|if
condition|(
name|SvLEN
argument_list|(
name|dstr
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvROK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_IVisUV
condition|)
name|SvIsUV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
name|SvAMAGIC_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_POK
condition|)
block|{
comment|/* 	 * Check to see if we can just swipe the string.  If so, it's a 	 * possible small lose on short strings, but a big win on long ones. 	 * It might even be a win on short strings if SvPVX(dstr) 	 * has to be allocated and SvPVX(sstr) has to be freed. 	 */
if|if
condition|(
name|SvTEMP
argument_list|(
name|sstr
argument_list|)
operator|&&
comment|/* slated for free anyway? */
name|SvREFCNT
argument_list|(
name|sstr
argument_list|)
operator|==
literal|1
operator|&&
comment|/* and no other references to it? */
operator|!
operator|(
name|sflags
operator|&
name|SVf_OOK
operator|)
condition|)
comment|/* and not involved in OOK hack? */
block|{
if|if
condition|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
comment|/* we know that dtype>= SVt_PV */
if|if
condition|(
name|SvOOK
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
name|SvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|&=
operator|~
name|SVf_OOK
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|-
name|SvIVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvLEN
argument_list|(
name|dstr
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|dstr
argument_list|,
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|dstr
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|dstr
argument_list|,
name|SvCUR
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* NOTE: nukes most SvFLAGS on sstr */
name|SvPV_set
argument_list|(
name|sstr
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* have to copy actual string */
name|STRLEN
name|len
init|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|SvGROW
argument_list|(
name|dstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* inlined from sv_setpvn */
name|Move
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|dstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|dstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflags
operator|&
name|SVf_UTF8
condition|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_IVisUV
condition|)
name|SvIsUV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */
if|if
condition|(
name|sflags
operator|&
name|SVf_IVisUV
condition|)
name|SvIsUV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_IVisUV
condition|)
name|SvIsUV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Undefined value assigned to typeglob"
argument_list|)
empty_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvTAINTED
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setsv_mg  Like C<sv_setsv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setsv_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|sv_setsv
argument_list|(
name|dstr
argument_list|,
name|sstr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpvn  Copies a string into an SV.  The C<len> parameter indicates the number of bytes to be copied.  Does not handle 'set' magic.  See C<sv_setpvn_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpvn
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|dptr
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* len is STRLEN which is unsigned, need to copy to signed */
name|IV
name|iv
init|=
name|len
decl_stmt|;
name|assert
argument_list|(
name|iv
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|dptr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|dptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpvn_mg  Like C<sv_setpvn>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpvn_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpv  Copies a string into an SV.  The string must be null-terminated.  Does not handle 'set' magic.  See C<sv_setpv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpv_mg  Like C<sv_setpv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpv_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_usepvn  Tells an SV to use C<ptr> to find its string value.  Normally the string is stored inside the SV but sv_usepvn allows the SV to use an outside string.  The C<ptr> should point to memory that was allocated by C<malloc>.  The string length, C<len>, must be supplied.  This function will realloc the memory pointed to by C<ptr>, so that pointer should not be freed or used by the programmer after giving it to sv_usepvn.  Does not handle 'set' magic. See C<sv_usepvn_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_usepvn
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|ptr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|ptr
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_usepvn_mg  Like C<sv_usepvn>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_usepvn_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_usepvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_force_normal
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_chop  Efficient removal of characters from the beginning of the string buffer.  SvPOK(sv) must be true and the C<ptr> must be a pointer to somewhere inside the string buffer.  The C<ptr> becomes the first character of the adjusted string.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_chop
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|)
comment|/* like set but assuming ptr is in sv */
block|{
specifier|register
name|STRLEN
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* make copy of shared string */
name|char
modifier|*
name|pvx
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|STRLEN
name|len
init|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|pvx
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVf_OOK
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVp_IOK
operator||
name|SVp_NOK
operator||
name|SVf_IVisUV
operator|)
expr_stmt|;
name|delta
operator|=
name|ptr
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|-=
name|delta
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-=
name|delta
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+=
name|delta
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catpvn  Concatenates the string onto the end of the string which is in the SV.  The C<len> indicates number of bytes to copy.  Handles 'get' magic, but not 'set' magic.  See C<sv_catpvn_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpvn
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|STRLEN
name|tlen
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
name|junk
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|tlen
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|junk
condition|)
name|ptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|tlen
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+=
name|len
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catpvn_mg  Like C<sv_catpvn>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpvn_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catsv  Concatenates the string from SV C<ssv> onto the end of the string in SV C<dsv>.  Modifies C<dsv> but not C<ssv>.  Handles 'get' magic, but not 'set' magic.  See C<sv_catsv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catsv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|char
modifier|*
name|spv
decl_stmt|;
name|STRLEN
name|slen
decl_stmt|;
if|if
condition|(
operator|!
name|sstr
condition|)
return|return;
if|if
condition|(
operator|(
name|spv
operator|=
name|SvPV
argument_list|(
name|sstr
argument_list|,
name|slen
argument_list|)
operator|)
condition|)
block|{
name|bool
name|dutf8
init|=
name|DO_UTF8
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
name|bool
name|sutf8
init|=
name|DO_UTF8
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dutf8
operator|==
name|sutf8
condition|)
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|spv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dutf8
condition|)
block|{
name|SV
modifier|*
name|cstr
init|=
name|newSVsv
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cpv
decl_stmt|;
name|STRLEN
name|clen
decl_stmt|;
name|sv_utf8_upgrade
argument_list|(
name|cstr
argument_list|)
expr_stmt|;
name|cpv
operator|=
name|SvPV
argument_list|(
name|cstr
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|cpv
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|sv_2mortal
argument_list|(
name|cstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_utf8_upgrade
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|spv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catsv_mg  Like C<sv_catsv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catsv_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|sv_catsv
argument_list|(
name|dstr
argument_list|,
name|sstr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catpv  Concatenates the string onto the end of the string which is in the SV. Handles 'get' magic, but not 'set' magic.  See C<sv_catpv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
name|STRLEN
name|tlen
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
name|junk
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|tlen
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|junk
condition|)
name|ptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|tlen
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catpv_mg  Like C<sv_catpv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpv_mg
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_newSV
parameter_list|(
name|pTHX_
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* name is assumed to contain an SV* if (name&& namelen == HEf_SVKEY) */
end_comment

begin_comment
comment|/* =for apidoc sv_magic  Adds magic to an SV.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_magic
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|SV
modifier|*
name|obj
parameter_list|,
name|int
name|how
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|namlen
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
operator|&&
operator|!
name|strchr
argument_list|(
literal|"gBf"
argument_list|,
name|how
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|how
operator|==
literal|'t'
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|)
condition|)
block|{
if|if
condition|(
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|how
operator|==
literal|'t'
condition|)
name|mg
operator|->
name|mg_len
operator||=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|702
argument_list|,
name|mg
argument_list|,
literal|1
argument_list|,
name|MAGIC
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_moremagic
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|mg
expr_stmt|;
comment|/* Some magic sontains a reference loop, where the sv and object refer to        each other.  To prevent a avoid a reference loop that would prevent such        objects being freed, we look for such loops and if we find one we avoid        incrementing the object refcount. */
if|if
condition|(
operator|!
name|obj
operator|||
name|obj
operator|==
name|sv
operator|||
name|how
operator|==
literal|'#'
operator|||
name|how
operator|==
literal|'r'
operator|||
operator|(
name|SvTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|SVt_PVGV
operator|&&
operator|(
name|GvSV
argument_list|(
name|obj
argument_list|)
operator|==
name|sv
operator|||
name|GvHV
argument_list|(
name|obj
argument_list|)
operator|==
operator|(
name|HV
operator|*
operator|)
name|sv
operator|||
name|GvAV
argument_list|(
name|obj
argument_list|)
operator|==
operator|(
name|AV
operator|*
operator|)
name|sv
operator|||
name|GvCV
argument_list|(
name|obj
argument_list|)
operator|==
operator|(
name|CV
operator|*
operator|)
name|sv
operator|||
name|GvIOp
argument_list|(
name|obj
argument_list|)
operator|==
operator|(
name|IO
operator|*
operator|)
name|sv
operator|||
name|GvFORM
argument_list|(
name|obj
argument_list|)
operator|==
operator|(
name|CV
operator|*
operator|)
name|sv
operator|)
operator|)
condition|)
block|{
name|mg
operator|->
name|mg_obj
operator|=
name|obj
expr_stmt|;
block|}
else|else
block|{
name|mg
operator|->
name|mg_obj
operator|=
name|SvREFCNT_inc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_flags
operator||=
name|MGf_REFCOUNTED
expr_stmt|;
block|}
name|mg
operator|->
name|mg_type
operator|=
name|how
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
name|namlen
expr_stmt|;
if|if
condition|(
name|name
condition|)
if|if
condition|(
name|namlen
operator|>=
literal|0
condition|)
name|mg
operator|->
name|mg_ptr
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|namlen
operator|==
name|HEf_SVKEY
condition|)
name|mg
operator|->
name|mg_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
literal|0
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_sv
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_amagic
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_amagicelem
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_bm
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_regdata
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_regdatum
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_env
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_fm
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_envelem
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_mglob
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_isa
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_isaelem
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_nkeys
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|SvRMAGICAL_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_virtual
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_dbline
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
literal|'m'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_mutex
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
case|case
literal|'o'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_collxfrm
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
case|case
literal|'P'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_pack
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_packelem
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_regexp
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_sig
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_sigelem
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_taint
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_uvar
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_vec
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_substr
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_defelem
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_glob
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_arylen
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_pos
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|PL_vtbl_backref
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* Reserved for use by extensions not perl internals.	*/
comment|/* Useful for attaching extension internal data to perl vars.	*/
comment|/* Note that multiple extensions may clash if magical scalars	*/
comment|/* etc holding private data from one are passed to another.	*/
name|SvRMAGICAL_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Don't know how to handle magic of type '%c'"
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
name|mg_magical
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVf_POK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_unmagic  Removes magic from an SV.  =cut */
end_comment

begin_function
name|int
name|Perl_sv_unmagic
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|MAGIC
modifier|*
modifier|*
name|mgp
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVMG
operator|||
operator|!
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|mgp
operator|=
operator|&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
name|mg
operator|=
operator|*
name|mgp
init|;
name|mg
condition|;
name|mg
operator|=
operator|*
name|mgp
control|)
block|{
if|if
condition|(
name|mg
operator|->
name|mg_type
operator|==
name|type
condition|)
block|{
name|MGVTBL
modifier|*
name|vtbl
init|=
name|mg
operator|->
name|mg_virtual
decl_stmt|;
operator|*
name|mgp
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
if|if
condition|(
name|vtbl
operator|&&
name|vtbl
operator|->
name|svt_free
condition|)
name|CALL_FPTR
function_decl|(
name|vtbl
operator|->
name|svt_free
function_decl|)
parameter_list|(
name|aTHX_
name|sv
parameter_list|,
name|mg
parameter_list|)
function_decl|;
if|if
condition|(
name|mg
operator|->
name|mg_ptr
operator|&&
name|mg
operator|->
name|mg_type
operator|!=
literal|'g'
condition|)
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|==
name|HEf_SVKEY
condition|)
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_flags
operator|&
name|MGf_REFCOUNTED
condition|)
name|SvREFCNT_dec
argument_list|(
name|mg
operator|->
name|mg_obj
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
else|else
name|mgp
operator|=
operator|&
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvMAGICAL_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVp_IOK
operator||
name|SVp_NOK
operator||
name|SVp_POK
operator|)
operator|)
operator|>>
name|PRIVSHIFT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_rvweaken  Weaken a reference.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_rvweaken
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|tsv
decl_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* let undefs pass */
return|return
name|sv
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't weaken a nonreference"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvWEAKREF
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Reference is already weak"
argument_list|)
empty_stmt|;
return|return
name|sv
return|;
block|}
name|tsv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_add_backref
argument_list|(
name|tsv
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvWEAKREF_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|void
name|Perl_sv_add_backref
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|tsv
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|tsv
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|tsv
argument_list|,
literal|'<'
argument_list|)
operator|)
condition|)
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|mg
operator|->
name|mg_obj
expr_stmt|;
else|else
block|{
name|av
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|sv_magic
argument_list|(
name|tsv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'<'
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* for sv_magic */
block|}
name|av_push
argument_list|(
name|av
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_del_backref
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|SV
modifier|*
name|tsv
init|=
name|SvRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|SvMAGICAL
argument_list|(
name|tsv
argument_list|)
operator|||
operator|!
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|tsv
argument_list|,
literal|'<'
argument_list|)
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: del_backref"
argument_list|)
expr_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|mg
operator|->
name|mg_obj
expr_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|i
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|svp
index|[
name|i
index|]
operator|==
name|sv
condition|)
block|{
name|svp
index|[
name|i
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
comment|/* XXX */
block|}
name|i
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_insert  Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_insert
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|bigstr
parameter_list|,
name|STRLEN
name|offset
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|char
modifier|*
name|little
parameter_list|,
name|STRLEN
name|littlelen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|char
modifier|*
name|mid
decl_stmt|;
specifier|register
name|char
modifier|*
name|midend
decl_stmt|;
specifier|register
name|char
modifier|*
name|bigend
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
name|STRLEN
name|curlen
decl_stmt|;
if|if
condition|(
operator|!
name|bigstr
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't modify non-existent substring"
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|bigstr
argument_list|,
name|curlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|len
operator|>
name|curlen
condition|)
block|{
name|SvGROW
argument_list|(
name|bigstr
argument_list|,
name|offset
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|+
name|curlen
argument_list|,
name|offset
operator|+
name|len
operator|-
name|curlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|bigstr
argument_list|,
name|offset
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|SvTAINT
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
name|i
operator|=
name|littlelen
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* string might grow */
name|big
operator|=
name|SvGROW
argument_list|(
name|bigstr
argument_list|,
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
operator|+
name|len
expr_stmt|;
name|midend
operator|=
name|bigend
operator|=
name|big
operator|+
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
name|bigend
operator|+=
name|i
expr_stmt|;
operator|*
name|bigend
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|midend
operator|>
name|mid
condition|)
comment|/* shove everything down */
operator|*
operator|--
name|bigend
operator|=
operator|*
operator|--
name|midend
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|big
operator|+
name|offset
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|+=
name|i
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|+
name|offset
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|big
operator|=
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
expr_stmt|;
name|midend
operator|=
name|mid
operator|+
name|len
expr_stmt|;
name|bigend
operator|=
name|big
operator|+
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|midend
operator|>
name|bigend
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: sv_insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|-
name|big
operator|>
name|bigend
operator|-
name|midend
condition|)
block|{
comment|/* faster to shorten from end */
if|if
condition|(
name|littlelen
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|littlelen
expr_stmt|;
block|}
name|i
operator|=
name|bigend
operator|-
name|midend
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|Move
argument_list|(
name|midend
argument_list|,
name|mid
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|i
expr_stmt|;
block|}
operator|*
name|mid
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|bigstr
argument_list|,
name|mid
operator|-
name|big
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|mid
operator|-
name|big
operator|)
condition|)
block|{
comment|/* faster from front */
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|mid
operator|=
name|midend
expr_stmt|;
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
operator|-
name|i
argument_list|)
expr_stmt|;
name|big
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|--
name|midend
operator|=
operator|*
operator|--
name|big
expr_stmt|;
if|if
condition|(
name|littlelen
condition|)
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|littlelen
condition|)
block|{
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|midend
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
block|}
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_replace  Make the first argument a copy of the second, then delete the original.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_replace
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|SV
modifier|*
name|nsv
parameter_list|)
block|{
name|U32
name|refcnt
init|=
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|nsv
argument_list|)
operator|!=
literal|1
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Reference miscount in sv_replace()"
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|nsv
argument_list|)
condition|)
name|mg_free
argument_list|(
name|nsv
argument_list|)
expr_stmt|;
else|else
name|sv_upgrade
argument_list|(
name|nsv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|nsv
argument_list|)
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|nsv
argument_list|)
operator||=
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGICAL_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|nsv
argument_list|,
name|sv
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
name|refcnt
expr_stmt|;
name|SvFLAGS
argument_list|(
name|nsv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* Mark as freed */
name|del_SV
argument_list|(
name|nsv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_clear  Clear an SV, making it empty. Does not free the memory used by the SV itself.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_clear
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|HV
modifier|*
name|stash
decl_stmt|;
name|assert
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_defstash
condition|)
block|{
comment|/* Still have a symbol table? */
name|dSP
expr_stmt|;
name|GV
modifier|*
name|destructor
decl_stmt|;
name|SV
name|tmpref
decl_stmt|;
name|Zero
argument_list|(
operator|&
name|tmpref
argument_list|,
literal|1
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|&
name|tmpref
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvROK_on
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
comment|/* DESTROY() could be naughty */
name|SvREFCNT
argument_list|(
operator|&
name|tmpref
argument_list|)
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|stash
operator|=
name|SvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|destructor
operator|=
name|gv_fetchmethod
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"DESTROY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor
condition|)
block|{
name|ENTER
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_DESTROY
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
operator|&
name|tmpref
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|destructor
argument_list|)
argument_list|,
name|G_DISCARD
operator||
name|G_EVAL
operator||
name|G_KEEPERR
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|--
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|!=
name|stash
condition|)
do|;
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
operator|&
name|tmpref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_in_clean_objs
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"DESTROY created new reference to dead object '%s'"
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DESTROY gave object new lease on life */
return|return;
block|}
block|}
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* possibly of changed persuasion */
name|SvOBJECT_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Curse the object. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|--
name|PL_sv_objcount
expr_stmt|;
comment|/* XXX Might want something more general */
block|}
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|stash
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stdin
argument_list|()
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stdout
argument_list|()
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stderr
argument_list|()
condition|)
block|{
name|io_close
argument_list|(
operator|(
name|IO
operator|*
operator|)
name|sv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IoDIRP
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|IOf_FAKE_DIRP
operator|)
condition|)
name|PerlDir_close
argument_list|(
name|IoDIRP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|IoDIRP
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
name|Safefree
argument_list|(
name|IoTOP_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|IoFMT_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|IoBOTTOM_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVBM
case|:
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
name|cv_undef
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVHV
case|:
name|hv_undef
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|av_undef
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVGV
case|:
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|GvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cannot decrease stash refcount yet, as we might recursively delete 	   ourselves when the refcnt drops to zero. Delay SvREFCNT_dec 	   of stash until current sv is completely gone. 	   -- JohnPC, 27 Mar 1998 */
name|stash
operator|=
name|GvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVMG
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVIV
case|:
name|freescalar
label|:
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PV
case|:
case|case
name|SVt_RV
case|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvWEAKREF
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_del_backref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|SvREFCNT_dec
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*     case SVt_NV:     case SVt_IV:     case SVt_NULL: 	break; */
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
break|break;
case|case
name|SVt_IV
case|:
name|del_XIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|del_XNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|del_XPV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|del_XPVIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|del_XPVNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|del_XPVMG
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|del_XPVLV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|del_XPVAV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|del_XPVHV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|del_XPVCV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|del_XPVGV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* code duplication for increased performance. */
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
name|SVf_BREAK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* decrease refcount of the stash that owns this GV, if any */
if|if
condition|(
name|stash
condition|)
name|SvREFCNT_dec
argument_list|(
name|stash
argument_list|)
expr_stmt|;
return|return;
comment|/* not break, SvFLAGS reset already happened */
case|case
name|SVt_PVBM
case|:
name|del_XPVBM
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|del_XPVFM
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|del_XPVIO
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
name|SVf_BREAK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_sv_newref
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|sv
condition|)
name|ATOMIC_INC
argument_list|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_free  Free the memory used by an SV.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_free
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|int
name|refcount_is_zero
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVf_BREAK
condition|)
return|return;
if|if
condition|(
name|PL_in_clean_all
condition|)
comment|/* All is fair */
return|return;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* make sure SvREFCNT(sv)==0 happens very seldom */
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Attempt to free unreferenced scalar"
argument_list|)
empty_stmt|;
return|return;
block|}
name|ATOMIC_DEC_AND_TEST
argument_list|(
name|refcount_is_zero
argument_list|,
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refcount_is_zero
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|SvTEMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_DEBUGGING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEBUGGING
argument_list|,
literal|"Attempt to free temp prematurely: SV 0x%"
argument|UVxf
argument_list|,
argument|PTR2UV(sv)
argument_list|)
empty_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* make sure SvREFCNT(sv)==0 happens very seldom */
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
return|return;
block|}
name|sv_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
condition|)
name|del_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_len  Returns the length of the string in the SV.  See also C<SvCUR>.  =cut */
end_comment

begin_function
name|STRLEN
name|Perl_sv_len
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|char
modifier|*
name|junk
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|len
operator|=
name|mg_length
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|junk
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_len_utf8  Returns the number of characters in the string in an SV, counting wide UTF8 bytes as a single character.  =cut */
end_comment

begin_function
name|STRLEN
name|Perl_sv_len_utf8
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|mg_length
argument_list|(
name|sv
argument_list|)
return|;
else|else
endif|#
directive|endif
block|{
name|STRLEN
name|len
decl_stmt|;
name|U8
modifier|*
name|s
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
name|Perl_utf8_length
argument_list|(
argument|aTHX_ s
argument_list|,
argument|s + len
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_sv_pos_u2b
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
modifier|*
name|offsetp
parameter_list|,
name|I32
modifier|*
name|lenp
parameter_list|)
block|{
name|U8
modifier|*
name|start
decl_stmt|;
name|U8
modifier|*
name|s
decl_stmt|;
name|U8
modifier|*
name|send
decl_stmt|;
name|I32
name|uoffset
init|=
operator|*
name|offsetp
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
name|start
operator|=
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|uoffset
operator|--
condition|)
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
name|s
operator|=
name|send
expr_stmt|;
operator|*
name|offsetp
operator|=
name|s
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
block|{
name|I32
name|ulen
init|=
operator|*
name|lenp
decl_stmt|;
name|start
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|ulen
operator|--
condition|)
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
name|s
operator|=
name|send
expr_stmt|;
operator|*
name|lenp
operator|=
name|s
operator|-
name|start
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|Perl_sv_pos_b2u
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
modifier|*
name|offsetp
parameter_list|)
block|{
name|U8
modifier|*
name|s
decl_stmt|;
name|U8
modifier|*
name|send
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|*
name|offsetp
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: sv_pos_b2u: bad byte offset"
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
operator|*
name|offsetp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|STRLEN
name|n
decl_stmt|;
if|if
condition|(
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|*
name|offsetp
operator|=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_eq  Returns a boolean indicating whether the strings in the two SVs are identical.  =cut */
end_comment

begin_function
name|I32
name|Perl_sv_eq
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv1
parameter_list|,
specifier|register
name|SV
modifier|*
name|sv2
parameter_list|)
block|{
name|char
modifier|*
name|pv1
decl_stmt|;
name|STRLEN
name|cur1
decl_stmt|;
name|char
modifier|*
name|pv2
decl_stmt|;
name|STRLEN
name|cur2
decl_stmt|;
name|I32
name|eq
init|=
literal|0
decl_stmt|;
name|bool
name|pv1tmp
init|=
name|FALSE
decl_stmt|;
name|bool
name|pv2tmp
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|sv1
condition|)
block|{
name|pv1
operator|=
literal|""
expr_stmt|;
name|cur1
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pv1
operator|=
name|SvPV
argument_list|(
name|sv1
argument_list|,
name|cur1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv2
condition|)
block|{
name|pv2
operator|=
literal|""
expr_stmt|;
name|cur2
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pv2
operator|=
name|SvPV
argument_list|(
name|sv2
argument_list|,
name|cur2
argument_list|)
expr_stmt|;
comment|/* do not utf8ize the comparands as a side-effect */
if|if
condition|(
name|cur1
operator|&&
name|cur2
operator|&&
name|SvUTF8
argument_list|(
name|sv1
argument_list|)
operator|!=
name|SvUTF8
argument_list|(
name|sv2
argument_list|)
operator|&&
operator|!
name|IN_BYTE
condition|)
block|{
name|bool
name|is_utf8
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|sv1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pv
init|=
operator|(
name|char
operator|*
operator|)
name|bytes_from_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv1
argument_list|,
operator|&
name|cur1
argument_list|,
operator|&
name|is_utf8
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pv1tmp
operator|=
operator|(
name|pv
operator|!=
name|pv1
operator|)
operator|)
condition|)
name|pv1
operator|=
name|pv
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|pv
init|=
operator|(
name|char
operator|*
operator|)
name|bytes_from_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv2
argument_list|,
operator|&
name|cur2
argument_list|,
operator|&
name|is_utf8
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pv2tmp
operator|=
operator|(
name|pv
operator|!=
name|pv2
operator|)
operator|)
condition|)
name|pv2
operator|=
name|pv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur1
operator|==
name|cur2
condition|)
name|eq
operator|=
name|memEQ
argument_list|(
name|pv1
argument_list|,
name|pv2
argument_list|,
name|cur1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv1tmp
condition|)
name|Safefree
argument_list|(
name|pv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv2tmp
condition|)
name|Safefree
argument_list|(
name|pv2
argument_list|)
expr_stmt|;
return|return
name|eq
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_cmp  Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the string in C<sv1> is less than, equal to, or greater than the string in C<sv2>.  =cut */
end_comment

begin_function
name|I32
name|Perl_sv_cmp
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv1
parameter_list|,
specifier|register
name|SV
modifier|*
name|sv2
parameter_list|)
block|{
name|STRLEN
name|cur1
decl_stmt|,
name|cur2
decl_stmt|;
name|char
modifier|*
name|pv1
decl_stmt|,
modifier|*
name|pv2
decl_stmt|;
name|I32
name|cmp
decl_stmt|;
name|bool
name|pv1tmp
init|=
name|FALSE
decl_stmt|;
name|bool
name|pv2tmp
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|sv1
condition|)
block|{
name|pv1
operator|=
literal|""
expr_stmt|;
name|cur1
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pv1
operator|=
name|SvPV
argument_list|(
name|sv1
argument_list|,
name|cur1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv2
condition|)
block|{
name|pv2
operator|=
literal|""
expr_stmt|;
name|cur2
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pv2
operator|=
name|SvPV
argument_list|(
name|sv2
argument_list|,
name|cur2
argument_list|)
expr_stmt|;
comment|/* do not utf8ize the comparands as a side-effect */
if|if
condition|(
name|cur1
operator|&&
name|cur2
operator|&&
name|SvUTF8
argument_list|(
name|sv1
argument_list|)
operator|!=
name|SvUTF8
argument_list|(
name|sv2
argument_list|)
operator|&&
operator|!
name|IN_BYTE
condition|)
block|{
if|if
condition|(
name|SvUTF8
argument_list|(
name|sv1
argument_list|)
condition|)
block|{
name|pv2
operator|=
operator|(
name|char
operator|*
operator|)
name|bytes_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv2
argument_list|,
operator|&
name|cur2
argument_list|)
expr_stmt|;
name|pv2tmp
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|pv1
operator|=
operator|(
name|char
operator|*
operator|)
name|bytes_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv1
argument_list|,
operator|&
name|cur1
argument_list|)
expr_stmt|;
name|pv1tmp
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cur1
condition|)
block|{
name|cmp
operator|=
name|cur2
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cur2
condition|)
block|{
name|cmp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|I32
name|retval
init|=
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pv1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pv2
argument_list|,
name|cur1
operator|<
name|cur2
condition|?
name|cur1
else|:
name|cur2
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|cmp
operator|=
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur1
operator|==
name|cur2
condition|)
block|{
name|cmp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|cur1
operator|<
name|cur2
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pv1tmp
condition|)
name|Safefree
argument_list|(
name|pv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv2tmp
condition|)
name|Safefree
argument_list|(
name|pv2
argument_list|)
expr_stmt|;
return|return
name|cmp
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_cmp_locale  Compares the strings in two SVs in a locale-aware manner. See L</sv_cmp_locale>  =cut */
end_comment

begin_function
name|I32
name|Perl_sv_cmp_locale
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv1
parameter_list|,
specifier|register
name|SV
modifier|*
name|sv2
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|char
modifier|*
name|pv1
decl_stmt|,
modifier|*
name|pv2
decl_stmt|;
name|STRLEN
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|I32
name|retval
decl_stmt|;
if|if
condition|(
name|PL_collation_standard
condition|)
goto|goto
name|raw_compare
goto|;
name|len1
operator|=
literal|0
expr_stmt|;
name|pv1
operator|=
name|sv1
condition|?
name|sv_collxfrm
argument_list|(
name|sv1
argument_list|,
operator|&
name|len1
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|len2
operator|=
literal|0
expr_stmt|;
name|pv2
operator|=
name|sv2
condition|?
name|sv_collxfrm
argument_list|(
name|sv2
argument_list|,
operator|&
name|len2
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pv1
operator|||
operator|!
name|len1
condition|)
block|{
if|if
condition|(
name|pv2
operator|&&
name|len2
condition|)
return|return
operator|-
literal|1
return|;
else|else
goto|goto
name|raw_compare
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pv2
operator|||
operator|!
name|len2
condition|)
return|return
literal|1
return|;
block|}
name|retval
operator|=
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pv1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pv2
argument_list|,
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
comment|/*      * When the result of collation is equality, that doesn't mean      * that there are no differences -- some locales exclude some      * characters from consideration.  So to avoid false equalities,      * we use the raw string as a tiebreaker.      */
name|raw_compare
label|:
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
return|return
name|sv_cmp
argument_list|(
name|sv1
argument_list|,
name|sv2
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
end_ifdef

begin_comment
comment|/*  * Any scalar variable may carry an 'o' magic that contains the  * scalar data of the variable transformed to such a format that  * a normal memory comparison can be used to compare the data  * according to the locale settings.  */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_collxfrm
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|nxp
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|mg
operator|=
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|?
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'o'
argument_list|)
else|:
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mg
operator|||
operator|!
name|mg
operator|->
name|mg_ptr
operator|||
operator|*
operator|(
name|U32
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
operator|!=
name|PL_collation_ix
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|xf
decl_stmt|;
name|STRLEN
name|len
decl_stmt|,
name|xlen
decl_stmt|;
if|if
condition|(
name|mg
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xf
operator|=
name|mem_collxfrm
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|xlen
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|xf
argument_list|)
expr_stmt|;
operator|*
name|nxp
operator|=
name|xlen
expr_stmt|;
return|return
name|xf
operator|+
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|'o'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
name|mg
operator|->
name|mg_ptr
operator|=
name|xf
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
name|xlen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mg
condition|)
block|{
name|mg
operator|->
name|mg_ptr
operator|=
name|NULL
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mg
operator|&&
name|mg
operator|->
name|mg_ptr
condition|)
block|{
operator|*
name|nxp
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
return|return
name|mg
operator|->
name|mg_ptr
operator|+
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|nxp
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOCALE_COLLATE */
end_comment

begin_comment
comment|/* =for apidoc sv_gets  Get a line from the filehandle and store it into the SV, optionally appending to the currently-stored string.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_gets
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|I32
name|append
parameter_list|)
block|{
name|char
modifier|*
name|rsptr
decl_stmt|;
name|STRLEN
name|rslen
decl_stmt|;
specifier|register
name|STDCHAR
name|rslast
decl_stmt|;
specifier|register
name|STDCHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|I32
name|cnt
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvSCREAM_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|RsSNARF
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|rsptr
operator|=
name|NULL
expr_stmt|;
name|rslen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RsRECORD
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|I32
name|recsize
decl_stmt|,
name|bytesread
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Grab the size of the record we're getting */
name|recsize
operator|=
name|SvIV
argument_list|(
name|SvRV
argument_list|(
name|PL_rs
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Validate pointer */
name|buffer
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|recsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Go yank in */
ifdef|#
directive|ifdef
name|VMS
comment|/* VMS wants read instead of fread, because fread doesn't respect */
comment|/* RMS record boundaries. This is not necessarily a good thing to be */
comment|/* doing, but we've got no other real choice */
name|bytesread
operator|=
name|PerlLIO_read
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|bytesread
operator|=
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
name|buffer
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bytesread
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bytesread
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
operator|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|sv
argument_list|)
else|:
name|Nullch
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|rsptr
operator|=
literal|"\n\n"
expr_stmt|;
name|rslen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Get $/ i.e. PL_rs into same encoding as stream wants */
if|if
condition|(
name|SvUTF8
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sv_utf8_downgrade
argument_list|(
name|PL_rs
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Wide character in $/"
argument_list|)
expr_stmt|;
block|}
block|}
name|rsptr
operator|=
name|SvPV
argument_list|(
name|PL_rs
argument_list|,
name|rslen
argument_list|)
expr_stmt|;
block|}
name|rslast
operator|=
name|rslen
condition|?
name|rsptr
index|[
name|rslen
operator|-
literal|1
index|]
else|:
literal|'\0'
expr_stmt|;
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
comment|/* have to do this both before and after */
do|do
block|{
comment|/* to make sure file boundaries work right */
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|PerlIO_ungetc
argument_list|(
name|fp
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|EOF
condition|)
do|;
block|}
comment|/* See if we know enough about I/O mechanism to cheat it ! */
comment|/* This used to be #ifdef test - it is made run-time test for ease        of abstracting out stdio interface. One call should be cheap         enough here - and may even be a macro allowing compile        time optimization.      */
if|if
condition|(
name|PerlIO_fast_gets
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/*      * We're going to steal some values from the stdio struct      * and put EVERYTHING in the innermost loop into registers.      */
specifier|register
name|STDCHAR
modifier|*
name|ptr
decl_stmt|;
name|STRLEN
name|bpx
decl_stmt|;
name|I32
name|shortbuffered
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERLIO_IS_STDIO
argument_list|)
comment|/* An ungetc()d char is handled separately from the regular      * buffer, so we getc() it back out and stuff it in the buffer.      */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
operator|*
operator|(
operator|--
operator|(
operator|(
operator|*
name|fp
operator|)
operator|->
name|_ptr
operator|)
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|i
expr_stmt|;
operator|(
operator|*
name|fp
operator|)
operator|->
name|_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Here is some breathtakingly efficient cheating */
name|cnt
operator|=
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* get count into register */
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|-
name|append
operator|<=
name|cnt
operator|+
literal|1
condition|)
block|{
comment|/* make sure we have the room */
if|if
condition|(
name|cnt
operator|>
literal|80
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|>
name|append
condition|)
block|{
name|shortbuffered
operator|=
name|cnt
operator|-
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
name|append
operator|+
literal|1
expr_stmt|;
name|cnt
operator|-=
name|shortbuffered
expr_stmt|;
block|}
else|else
block|{
name|shortbuffered
operator|=
literal|0
expr_stmt|;
comment|/* remember that cnt can be negative */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|append
operator|+
operator|(
name|cnt
operator|<=
literal|0
condition|?
literal|2
else|:
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|append
expr_stmt|;
comment|/* move these two too to registers */
name|ptr
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: entering, ptr=%"
name|UVuf
literal|", cnt=%ld\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: entering: FILE * thinks ptr=%"
name|UVuf
literal|", cnt=%ld, base=%"
name|UVuf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|screamer
label|:
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rslen
condition|)
block|{
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* this     |  eat */
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|ptr
operator|++
operator|)
operator|==
name|rslast
condition|)
comment|/* really   |  dust */
goto|goto
name|thats_all_folks
goto|;
comment|/* screams  |  sed :-) */
block|}
block|}
else|else
block|{
name|Copy
argument_list|(
name|ptr
argument_list|,
name|bp
argument_list|,
name|cnt
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* this     |  eat */
name|bp
operator|+=
name|cnt
expr_stmt|;
comment|/* screams  |  dust */
name|ptr
operator|+=
name|cnt
expr_stmt|;
comment|/* louder   |  sed :-) */
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shortbuffered
condition|)
block|{
comment|/* oh well, must extend */
name|cnt
operator|=
name|shortbuffered
expr_stmt|;
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bpx
operator|=
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* box up before relocation */
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bpx
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
name|append
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|bpx
expr_stmt|;
comment|/* unbox after relocation */
continue|continue;
block|}
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: going to getc, ptr=%"
name|UVuf
literal|", cnt=%ld\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_set_ptrcnt
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* deregisterize cnt and ptr */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: pre: FILE * thinks ptr=%"
name|UVuf
literal|", cnt=%ld, base=%"
name|UVuf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This used to call 'filbuf' in stdio form, but as that behaves like  	   getc when cnt<= 0 we use PerlIO_getc here to avoid introducing 	   another abstraction.  */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* get more characters */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: post: FILE * thinks ptr=%"
name|UVuf
literal|", cnt=%ld, base=%"
name|UVuf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* reregisterize cnt and ptr */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: after getc, ptr=%"
name|UVuf
literal|", cnt=%ld\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
comment|/* all done for ever? */
goto|goto
name|thats_really_all_folks
goto|;
name|bpx
operator|=
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* box up before relocation */
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bpx
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|bpx
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|bpx
expr_stmt|;
comment|/* unbox after relocation */
operator|*
name|bp
operator|++
operator|=
name|i
expr_stmt|;
comment|/* store character from PerlIO_getc */
if|if
condition|(
name|rslen
operator|&&
operator|(
name|STDCHAR
operator|)
name|i
operator|==
name|rslast
condition|)
comment|/* all done for now? */
goto|goto
name|thats_all_folks
goto|;
block|}
name|thats_all_folks
label|:
if|if
condition|(
operator|(
name|rslen
operator|>
literal|1
operator|&&
operator|(
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|<
name|rslen
operator|)
operator|)
operator|||
name|memNE
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|-
name|rslen
argument_list|,
name|rsptr
argument_list|,
name|rslen
argument_list|)
condition|)
goto|goto
name|screamer
goto|;
comment|/* go back to the fray */
name|thats_really_all_folks
label|:
if|if
condition|(
name|shortbuffered
condition|)
name|cnt
operator|+=
name|shortbuffered
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: quitting, ptr=%"
name|UVuf
literal|", cnt=%ld\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_set_ptrcnt
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* put these back or we're in trouble */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: end: FILE * thinks ptr=%"
name|UVuf
literal|", cnt=%ld, base=%"
name|UVuf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set length */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: done, len=%ld, string=|%.*s|\n"
argument_list|,
operator|(
name|long
operator|)
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|EPOC
comment|/*The big, slow, and stupid way */
name|STDCHAR
name|buf
index|[
literal|8192
index|]
decl_stmt|;
else|#
directive|else
comment|/* Need to work around EPOC SDK features          */
comment|/* On WINS: MS VC5 generates calls to _chkstk,    */
comment|/* if a `large' stack frame is allocated          */
comment|/* gcc on MARM does not generate calls like these */
name|STDCHAR
name|buf
index|[
literal|1024
index|]
decl_stmt|;
endif|#
directive|endif
name|screamer2
label|:
if|if
condition|(
name|rslen
condition|)
block|{
specifier|register
name|STDCHAR
modifier|*
name|bpe
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
operator|*
name|bp
operator|++
operator|=
name|i
operator|)
operator|!=
name|rslast
operator|&&
name|bp
operator|<
name|bpe
condition|)
empty_stmt|;
comment|/* keep reading */
name|cnt
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Accomodate broken VAXC compiler, which applies U8 cast to 	     * both args of ?: operator, causing EOF to change into 255 	     */
if|if
condition|(
name|cnt
condition|)
block|{
name|i
operator|=
operator|(
name|U8
operator|)
name|buf
index|[
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|EOF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|append
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
operator|&&
comment|/* joy */
operator|(
operator|!
name|rslen
operator|||
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|<
name|rslen
operator|||
name|memNE
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|rslen
argument_list|,
name|rsptr
argument_list|,
name|rslen
argument_list|)
operator|)
condition|)
block|{
name|append
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	     * If we're reading from a TTY and we get a short read, 	     * indicating that the user hit his EOF character, we need 	     * to notice it now, because if we try to read from the TTY 	     * again, the EOF condition will disappear. 	     * 	     * The comparison of cnt to sizeof(buf) is an optimization 	     * that prevents unnecessary calls to feof(). 	     * 	     * - jik 9/25/96 	     */
if|if
condition|(
operator|!
operator|(
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|&&
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
goto|goto
name|screamer2
goto|;
block|}
block|}
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
comment|/* have to do this both before and after */
while|while
condition|(
name|i
operator|!=
name|EOF
condition|)
block|{
comment|/* to make sure file boundaries work right */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
name|PerlIO_ungetc
argument_list|(
name|fp
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|SvUTF8_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
operator|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|append
operator|)
condition|?
name|SvPVX
argument_list|(
name|sv
argument_list|)
else|:
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_inc  Auto-increment of the value in the SV.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_inc
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|IV
name|i
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|inc
argument_list|)
condition|)
return|return;
name|i
operator|=
name|PTR2IV
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|flags
operator|=
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_NOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|+=
literal|1.0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|SVp_IOK
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|==
name|UV_MAX
condition|)
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|UV_MAX
operator|+
literal|1.0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|SvIOK_only_UV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|++
name|SvUVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|IV_MAX
condition|)
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|IV_MAX
operator|+
literal|1.0
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|++
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SVp_POK
operator|)
operator|||
operator|!
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SVTYPEMASK
operator|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|+
literal|1.0
argument_list|)
expr_stmt|;
comment|/* punt */
return|return;
block|}
name|d
operator|--
expr_stmt|;
while|while
condition|(
name|d
operator|>=
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
operator|*
name|d
operator|<=
literal|'9'
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EBCDIC
comment|/* MKS: The original code here died if letters weren't consecutive. 	     * at least it didn't have to worry about non-C locales.  The 	     * new code assumes that ('z'-'a')==('Z'-'A'), letters are 	     * arranged in order (although not consecutively) and that only  	     * [A-Za-z] are accepted by isALPHA in the C locale. 	     */
if|if
condition|(
operator|*
name|d
operator|!=
literal|'z'
operator|&&
operator|*
name|d
operator|!=
literal|'Z'
condition|)
block|{
do|do
block|{
operator|++
operator|*
name|d
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
do|;
return|return;
block|}
operator|*
operator|(
name|d
operator|--
operator|)
operator|-=
literal|'z'
operator|-
literal|'a'
expr_stmt|;
else|#
directive|else
operator|++
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|-=
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* oh,oh, the number grew */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
init|;
name|d
operator|>
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|;
name|d
operator|--
control|)
operator|*
name|d
operator|=
name|d
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|d
operator|=
literal|'1'
expr_stmt|;
else|else
operator|*
name|d
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_dec  Auto-decrement of the value in the SV.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_dec
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|IV
name|i
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|dec
argument_list|)
condition|)
return|return;
name|i
operator|=
name|PTR2IV
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|flags
operator|=
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|-=
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|SVp_IOK
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SvIOK_only_UV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|--
name|SvUVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|IV_MIN
condition|)
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|IV_MIN
operator|-
literal|1.0
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|--
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SVp_POK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SVTYPEMASK
operator|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|Atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
comment|/* punt */
block|}
end_function

begin_comment
comment|/* =for apidoc sv_mortalcopy  Creates a new SV which is a copy of the original SV.  The new SV is marked as mortal.  =cut */
end_comment

begin_comment
comment|/* Make a string that will exist for the duration of the expression  * evaluation.  Actually, it may have to last longer than that, but  * hopefully we won't free it until it has been assigned to a  * permanent location. */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_mortalcopy
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|oldstr
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|oldstr
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PL_tmps_stack
index|[
operator|++
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_newmortal  Creates a new SV which is mortal.  The reference count of the SV is set to 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_newmortal
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVs_TEMP
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PL_tmps_stack
index|[
operator|++
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_2mortal  Marks an SV as mortal.  The SV will be destroyed when the current context ends.  =cut */
end_comment

begin_comment
comment|/* same thing without the copying */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_2mortal
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
name|sv
return|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|sv
return|;
name|EXTEND_MORTAL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PL_tmps_stack
index|[
operator|++
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVpv  Creates a new SV and copies a string into it.  The reference count for the SV is set to 1.  If C<len> is zero, Perl will compute the length using strlen().  For efficiency, consider using C<newSVpvn> instead.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVpv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVpvn  Creates a new SV and copies a string into it.  The reference count for the SV is set to 1.  Note that if C<len> is zero, Perl will create a zero length  string.  You are responsible for ensuring that the source string is at least C<len> bytes long.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVpvn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|Perl_newSVpvf_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv
operator|=
name|vnewSVpvf
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =for apidoc newSVpvf  Creates a new SV an initialize it with the string formatted like C<sprintf>.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVpvf
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv
operator|=
name|vnewSVpvf
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_vnewSVpvf
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVnv  Creates a new SV and copies a floating point value into it. The reference count for the SV is set to 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVnv
parameter_list|(
name|pTHX_
name|NV
name|n
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSViv  Creates a new SV and copies an integer into it.  The reference count for the SV is set to 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSViv
parameter_list|(
name|pTHX_
name|IV
name|i
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVuv  Creates a new SV and copies an unsigned integer into it. The reference count for the SV is set to 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVuv
parameter_list|(
name|pTHX_
name|UV
name|u
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newRV_noinc  Creates an RV wrapper for an SV.  The reference count for the original SV is B<not> incremented.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newRV_noinc
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|tmpRef
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
name|tmpRef
expr_stmt|;
name|SvROK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* newRV_inc is #defined to newRV in sv.h */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newRV
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|tmpRef
parameter_list|)
block|{
return|return
name|newRV_noinc
argument_list|(
name|SvREFCNT_inc
argument_list|(
name|tmpRef
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVsv  Creates a new SV which is an exact duplicate of the original SV.  =cut */
end_comment

begin_comment
comment|/* make an exact duplicate of old */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVsv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|old
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|old
argument_list|)
operator|==
name|SVTYPEMASK
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"semi-panic: attempt to dup freed string"
argument_list|)
empty_stmt|;
return|return
name|Nullsv
return|;
block|}
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTEMP
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|SvTEMP_off
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|old
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|void
name|Perl_sv_reset
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|HV
modifier|*
name|stash
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
specifier|register
name|I32
name|max
decl_stmt|;
name|char
name|todo
index|[
name|PERL_UCHAR_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
comment|/* reset ?? searches */
for|for
control|(
name|pm
operator|=
name|HvPMROOT
argument_list|(
name|stash
argument_list|)
init|;
name|pm
condition|;
name|pm
operator|=
name|pm
operator|->
name|op_pmnext
control|)
block|{
name|pm
operator|->
name|op_pmdynflags
operator|&=
operator|~
name|PMdf_USED
expr_stmt|;
block|}
return|return;
block|}
comment|/* reset variables */
if|if
condition|(
operator|!
name|HvARRAY
argument_list|(
name|stash
argument_list|)
condition|)
return|return;
name|Zero
argument_list|(
name|todo
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|i
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|max
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|todo
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|I32
operator|)
name|HvMAX
argument_list|(
name|stash
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|HvARRAY
argument_list|(
name|stash
argument_list|)
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|todo
index|[
operator|(
name|U8
operator|)
operator|*
name|HeKEY
argument_list|(
name|entry
argument_list|)
index|]
condition|)
continue|continue;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|sv
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
condition|)
block|{
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|!=
name|Nullch
condition|)
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GvAV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|av_clear
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|!
name|HvNAME
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
block|{
name|hv_clear
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ENVIRON_ARRAY
if|if
condition|(
name|gv
operator|==
name|PL_envgv
condition|)
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|IO
modifier|*
name|Perl_sv_2io
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVIO
case|:
name|io
operator|=
operator|(
name|IO
operator|*
operator|)
name|sv
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad filehandle: %s"
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"filehandle"
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|sv_2io
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
else|else
name|io
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad filehandle: %s"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|io
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|Perl_sv_2cv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|HV
modifier|*
modifier|*
name|st
parameter_list|,
name|GV
modifier|*
modifier|*
name|gvp
parameter_list|,
name|I32
name|lref
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
operator|*
name|gvp
operator|=
name|Nullgv
operator|,
name|Nullcv
return|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVCV
case|:
operator|*
name|st
operator|=
name|CvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
return|return
operator|(
name|CV
operator|*
operator|)
name|sv
return|;
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVAV
case|:
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
return|return
name|Nullcv
return|;
case|case
name|SVt_PVGV
case|:
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
operator|*
name|gvp
operator|=
name|gv
expr_stmt|;
operator|*
name|st
operator|=
name|GvESTASH
argument_list|(
name|gv
argument_list|)
expr_stmt|;
goto|goto
name|fix_gv
goto|;
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|sp
init|=
operator|&
name|sv
decl_stmt|;
comment|/* Used in tryAMAGICunDEREF macro. */
name|tryAMAGICunDEREF
argument_list|(
name|to_cv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv
expr_stmt|;
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
operator|*
name|st
operator|=
name|CvSTASH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|sv
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Not a subroutine reference"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|sv
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
else|else
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|lref
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
operator|*
name|gvp
operator|=
name|gv
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
return|return
name|Nullcv
return|;
operator|*
name|st
operator|=
name|GvESTASH
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|fix_gv
label|:
if|if
condition|(
name|lref
operator|&&
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|ENTER
expr_stmt|;
name|tmpsv
operator|=
name|NEWSV
argument_list|(
literal|704
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|tmpsv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
comment|/* XXX this is probably not what they think they're getting. 	     * It has the same effect as "sub name;", i.e. just a forward 	     * declaration! */
name|newSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|tmpsv
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unable to create sub named \"%s\""
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|GvCVu
argument_list|(
name|gv
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_true  Returns true if the SV has a true value by Perl's rules.  =cut */
end_comment

begin_function
name|I32
name|Perl_sv_true
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
specifier|register
name|XPV
modifier|*
name|tXpv
decl_stmt|;
if|if
condition|(
operator|(
name|tXpv
operator|=
operator|(
name|XPV
operator|*
operator|)
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|)
operator|&&
operator|(
name|tXpv
operator|->
name|xpv_cur
operator|>
literal|1
operator|||
operator|(
name|tXpv
operator|->
name|xpv_cur
operator|&&
operator|*
name|tXpv
operator|->
name|xpv_pv
operator|!=
literal|'0'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
else|else
block|{
if|if
condition|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
return|;
else|else
return|return
name|sv_2bool
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|IV
name|Perl_sv_iv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
return|return
operator|(
name|IV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
return|return
name|sv_2iv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|UV
name|Perl_sv_uv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
operator|(
name|UV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
return|return
name|sv_2uv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|NV
name|Perl_sv_nv
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|sv_2nv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvn
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_pvn_force  Get a sensible string out of the SV somehow.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_pvn_force
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_force_normal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>
name|SVt_PVLV
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVFM
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't coerce %s to string in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PL_op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* Almost, but not quite, sv_setpvn() */
name|STRLEN
name|len
init|=
operator|*
name|lp
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* Never FALSE */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" 2pv(%s)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvbyte
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
return|return
name|sv_pv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvbyten
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
return|return
name|sv_pvn
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvbyten_force
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
return|return
name|sv_pvn_force
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvutf8
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv_pv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sv_pvutf8n
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv_pvn
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_pvutf8n_force  Get a sensible UTF8-encoded string out of the SV somehow. See L</sv_pvn_force>.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_pvutf8n_force
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv_pvn_force
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_reftype  Returns a string describing what the SV is a reference to.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_sv_reftype
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|ob
parameter_list|)
block|{
if|if
condition|(
name|ob
operator|&&
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
else|else
block|{
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
case|case
name|SVt_NV
case|:
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVMG
case|:
case|case
name|SVt_PVBM
case|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|"REF"
return|;
else|else
return|return
literal|"SCALAR"
return|;
case|case
name|SVt_PVLV
case|:
return|return
literal|"LVALUE"
return|;
case|case
name|SVt_PVAV
case|:
return|return
literal|"ARRAY"
return|;
case|case
name|SVt_PVHV
case|:
return|return
literal|"HASH"
return|;
case|case
name|SVt_PVCV
case|:
return|return
literal|"CODE"
return|;
case|case
name|SVt_PVGV
case|:
return|return
literal|"GLOB"
return|;
case|case
name|SVt_PVFM
case|:
return|return
literal|"FORMAT"
return|;
case|case
name|SVt_PVIO
case|:
return|return
literal|"IO"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc sv_isobject  Returns a boolean indicating whether the SV is an RV pointing to a blessed object.  If the SV is not an RV, or if the object is not blessed, then this will return false.  =cut */
end_comment

begin_function
name|int
name|Perl_sv_isobject
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_isa  Returns a boolean indicating whether the SV is blessed into the specified class.  This does not check for subtypes; use C<sv_derived_from> to verify an inheritance relationship.  =cut */
end_comment

begin_function
name|int
name|Perl_sv_isa
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newSVrv  Creates a new SV for the RV, C<rv>, to point to.  If C<rv> is not an RV then it will be upgraded to one.  If C<classname> is non-null then the new SV will be blessed in the specified package.  The new SV is returned and its reference count is 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_newSVrv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|rv
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|SvAMAGIC_off
argument_list|(
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|rv
argument_list|)
operator|>=
name|SVt_PVMG
condition|)
block|{
name|U32
name|refcnt
init|=
name|SvREFCNT
argument_list|(
name|rv
argument_list|)
decl_stmt|;
name|SvREFCNT
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|rv
argument_list|)
operator|=
name|refcnt
expr_stmt|;
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|rv
argument_list|)
operator|<
name|SVt_RV
condition|)
name|sv_upgrade
argument_list|(
name|rv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|rv
argument_list|)
operator|>
name|SVt_RV
condition|)
block|{
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPVX
argument_list|(
name|rv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|rv
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|rv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|rv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|rv
argument_list|)
operator|=
name|sv
expr_stmt|;
name|SvROK_on
argument_list|(
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|HV
modifier|*
name|stash
init|=
name|gv_stashpv
argument_list|(
name|classname
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sv_bless
argument_list|(
name|rv
argument_list|,
name|stash
argument_list|)
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setref_pv  Copies a pointer into a new SV, optionally blessing the SV.  The C<rv> argument will be upgraded to an RV.  That RV will be modified to point to the new SV.  If the C<pv> argument is NULL then C<PL_sv_undef> will be placed into the SV.  The C<classname> argument indicates the package for the blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV will be returned and will have a reference count of 1.  Do not use with other Perl types such as HV, AV, SV, CV, because those objects will become corrupted by the pointer copy process.  Note that C<sv_setref_pvn> copies the string while this copies the pointer.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_setref_pv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|rv
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|void
modifier|*
name|pv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pv
condition|)
block|{
name|sv_setsv
argument_list|(
name|rv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setiv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|PTR2IV
argument_list|(
name|pv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setref_iv  Copies an integer into a new SV, optionally blessing the SV.  The C<rv> argument will be upgraded to an RV.  That RV will be modified to point to the new SV.  The C<classname> argument indicates the package for the blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV will be returned and will have a reference count of 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_setref_iv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|rv
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|sv_setiv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|iv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setref_nv  Copies a double into a new SV, optionally blessing the SV.  The C<rv> argument will be upgraded to an RV.  That RV will be modified to point to the new SV.  The C<classname> argument indicates the package for the blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV will be returned and will have a reference count of 1.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_setref_nv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|rv
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|NV
name|nv
parameter_list|)
block|{
name|sv_setnv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|nv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setref_pvn  Copies a string into a new SV, optionally blessing the SV.  The length of the string must be specified with C<n>.  The C<rv> argument will be upgraded to an RV.  That RV will be modified to point to the new SV.  The C<classname> argument indicates the package for the blessing.  Set C<classname> to C<Nullch> to avoid the blessing.  The new SV will be returned and will have a reference count of 1.  Note that C<sv_setref_pv> copies the pointer while this copies the string.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_setref_pvn
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|rv
parameter_list|,
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|n
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|pv
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_bless  Blesses an SV into a specified package.  The SV must be an RV.  The package must be designated by its stash (see C<gv_stashpv()>).  The reference count of the SV is unaffected.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_sv_bless
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|HV
modifier|*
name|stash
parameter_list|)
block|{
name|SV
modifier|*
name|tmpRef
decl_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't bless non-reference value"
argument_list|)
expr_stmt|;
name|tmpRef
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvFLAGS
argument_list|(
name|tmpRef
argument_list|)
operator|&
operator|(
name|SVs_OBJECT
operator||
name|SVf_READONLY
operator|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|tmpRef
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|tmpRef
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|tmpRef
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|--
name|PL_sv_objcount
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|SvSTASH
argument_list|(
name|tmpRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SvOBJECT_on
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|tmpRef
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|++
name|PL_sv_objcount
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|tmpRef
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|tmpRef
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gv_AMG
argument_list|(
name|stash
argument_list|)
condition|)
name|SvAMAGIC_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|SvAMAGIC_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_sv_unglob
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|void
modifier|*
name|xpvmg
decl_stmt|;
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|SvFAKE_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvGP
argument_list|(
name|sv
argument_list|)
condition|)
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|Nullhv
expr_stmt|;
block|}
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|GvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* need to keep SvANY(sv) in the right arena */
name|xpvmg
operator|=
name|new_XPVMG
argument_list|()
expr_stmt|;
name|StructCopy
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
name|xpvmg
argument_list|,
name|XPVMG
argument_list|)
expr_stmt|;
name|del_XPVGV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|xpvmg
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVt_PVMG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_unref  Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV.  This can almost be thought of as a reversal of C<newSVrv>.  See C<SvROK_off>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_unref
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
init|=
name|SvRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvWEAKREF
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_del_backref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvWEAKREF_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvROK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|rv
argument_list|)
operator|!=
literal|1
operator|||
name|SvREADONLY
argument_list|(
name|rv
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|rv
argument_list|)
expr_stmt|;
else|else
name|sv_2mortal
argument_list|(
name|rv
argument_list|)
expr_stmt|;
comment|/* Schedule for freeing later */
block|}
end_function

begin_function
name|void
name|Perl_sv_taint
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|sv_magic
argument_list|(
operator|(
name|sv
operator|)
argument_list|,
name|Nullsv
argument_list|,
literal|'t'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_untaint
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|mg
condition|)
name|mg
operator|->
name|mg_len
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|Perl_sv_tainted
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|mg
operator|&&
operator|(
operator|(
name|mg
operator|->
name|mg_len
operator|&
literal|1
operator|)
operator|||
operator|(
operator|(
name|mg
operator|->
name|mg_len
operator|&
literal|2
operator|)
operator|&&
name|mg
operator|->
name|mg_obj
operator|==
name|sv
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpviv  Copies an integer into the given SV, also updating its string value. Does not handle 'set' magic.  See C<sv_setpviv_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpviv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|char
name|buf
index|[
name|TYPE_CHARS
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|ebuf
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|uiv_2buf
argument_list|(
name|buf
argument_list|,
name|iv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ebuf
argument_list|)
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|ebuf
operator|-
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpviv_mg  Like C<sv_setpviv>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpviv_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|char
name|buf
index|[
name|TYPE_CHARS
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|ebuf
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|uiv_2buf
argument_list|(
name|buf
argument_list|,
name|iv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ebuf
argument_list|)
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|ebuf
operator|-
name|ptr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|void
name|Perl_sv_setpvf_nocontext
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvf
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_setpvf_mg_nocontext
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvf_mg
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =for apidoc sv_setpvf  Processes its arguments like C<sprintf> and sets an SV to the formatted output.  Does not handle 'set' magic.  See C<sv_setpvf_mg>.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpvf
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvf
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_vsetpvf
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_setpvf_mg  Like C<sv_setpvf>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_setpvf_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvf_mg
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_vsetpvf_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|void
name|Perl_sv_catpvf_nocontext
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvf
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_catpvf_mg_nocontext
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvf_mg
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =for apidoc sv_catpvf  Processes its arguments like C<sprintf> and appends the formatted output to an SV.  Handles 'get' magic, but not 'set' magic.  C<SvSETMAGIC()> must typically be called after calling this function to handle 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpvf
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvf
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_vcatpvf
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_catpvf_mg  Like C<sv_catpvf>, but also handles 'set' magic.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_catpvf_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvf_mg
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_sv_vcatpvf_mg
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_vsetpvfn  Works like C<vcatpvfn> but copies the text into the SV instead of appending it.  =cut */
end_comment

begin_function
name|void
name|Perl_sv_vsetpvfn
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|STRLEN
name|patlen
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|SV
modifier|*
modifier|*
name|svargs
parameter_list|,
name|I32
name|svmax
parameter_list|,
name|bool
modifier|*
name|maybe_tainted
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|patlen
argument_list|,
name|args
argument_list|,
name|svargs
argument_list|,
name|svmax
argument_list|,
name|maybe_tainted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc sv_vcatpvfn  Processes its arguments like C<vsprintf> and appends the formatted output to an SV.  Uses an array of SVs if the C style variable argument list is missing (NULL).  When running with taint checks enabled, indicates via C<maybe_tainted> if results are untrustworthy (often due to the use of locales).  =cut */
end_comment

begin_function
name|void
name|Perl_sv_vcatpvfn
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|STRLEN
name|patlen
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|SV
modifier|*
modifier|*
name|svargs
parameter_list|,
name|I32
name|svmax
parameter_list|,
name|bool
modifier|*
name|maybe_tainted
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|patend
decl_stmt|;
name|STRLEN
name|origlen
decl_stmt|;
name|I32
name|svix
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|nullstr
index|[]
init|=
literal|"(null)"
decl_stmt|;
name|SV
modifier|*
name|argsv
decl_stmt|;
comment|/* no matter what, this is a string now */
operator|(
name|void
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|origlen
argument_list|)
expr_stmt|;
comment|/* special-case "", "%s", and "%_" */
if|if
condition|(
name|patlen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|patlen
operator|==
literal|2
operator|&&
name|pat
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
name|pat
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|s
condition|?
name|s
else|:
name|nullstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
block|{
name|sv_catsv
argument_list|(
name|sv
argument_list|,
operator|*
name|svargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
operator|*
name|svargs
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'_'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|argsv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|sv
argument_list|,
name|argsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|argsv
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See comment on '_' below */
break|break;
block|}
block|}
name|patend
operator|=
operator|(
name|char
operator|*
operator|)
name|pat
operator|+
name|patlen
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pat
init|;
name|p
operator|<
name|patend
condition|;
name|p
operator|=
name|q
control|)
block|{
name|bool
name|alt
init|=
name|FALSE
decl_stmt|;
name|bool
name|left
init|=
name|FALSE
decl_stmt|;
name|bool
name|vectorize
init|=
name|FALSE
decl_stmt|;
name|bool
name|utf
init|=
name|FALSE
decl_stmt|;
name|char
name|fill
init|=
literal|' '
decl_stmt|;
name|char
name|plus
init|=
literal|0
decl_stmt|;
name|char
name|intsize
init|=
literal|0
decl_stmt|;
name|STRLEN
name|width
init|=
literal|0
decl_stmt|;
name|STRLEN
name|zeros
init|=
literal|0
decl_stmt|;
name|bool
name|has_precis
init|=
name|FALSE
decl_stmt|;
name|STRLEN
name|precis
init|=
literal|0
decl_stmt|;
name|bool
name|is_utf
init|=
name|FALSE
decl_stmt|;
name|char
name|esignbuf
index|[
literal|4
index|]
decl_stmt|;
name|U8
name|utf8buf
index|[
name|UTF8_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|STRLEN
name|esignlen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|eptr
init|=
name|Nullch
decl_stmt|;
name|STRLEN
name|elen
init|=
literal|0
decl_stmt|;
comment|/* Times 4: a decimal digit takes more than 3 binary digits. 	 * NV_DIG: mantissa takes than many decimal digits. 	 * Plus 32: Playing safe. */
name|char
name|ebuf
index|[
name|IV_DIG
operator|*
literal|4
operator|+
name|NV_DIG
operator|+
literal|32
index|]
decl_stmt|;
comment|/* large enough for "%#.#f" --chip */
comment|/* what about long double NVs? --jhi */
name|SV
modifier|*
name|vecsv
decl_stmt|;
name|U8
modifier|*
name|vecstr
init|=
name|Null
argument_list|(
name|U8
operator|*
argument_list|)
decl_stmt|;
name|STRLEN
name|veclen
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|base
decl_stmt|;
name|IV
name|iv
decl_stmt|;
name|UV
name|uv
decl_stmt|;
name|NV
name|nv
decl_stmt|;
name|STRLEN
name|have
decl_stmt|;
name|STRLEN
name|need
decl_stmt|;
name|STRLEN
name|gap
decl_stmt|;
name|char
modifier|*
name|dotstr
init|=
literal|"."
decl_stmt|;
name|STRLEN
name|dotstrlen
init|=
literal|1
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|<
name|patend
operator|&&
operator|*
name|q
operator|!=
literal|'%'
condition|;
operator|++
name|q
control|)
empty_stmt|;
if|if
condition|(
name|q
operator|>
name|p
condition|)
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|++
operator|>=
name|patend
condition|)
break|break;
comment|/* FLAGS */
while|while
condition|(
operator|*
name|q
condition|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'+'
case|:
name|plus
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
name|left
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|fill
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|alt
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* printf("%*vX",":",$ipv6addr) */
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|!=
literal|'v'
condition|)
break|break;
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|vecsv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
name|vecsv
operator|=
name|svargs
index|[
name|svix
operator|++
index|]
expr_stmt|;
else|else
continue|continue;
name|dotstr
operator|=
name|SvPVx
argument_list|(
name|vecsv
argument_list|,
name|dotstrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|vecsv
argument_list|)
condition|)
name|is_utf
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'v'
case|:
name|vectorize
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* WIDTH */
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
operator|*
name|q
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|args
condition|)
name|i
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|left
operator||=
operator|(
name|i
operator|<
literal|0
operator|)
expr_stmt|;
name|width
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
name|q
operator|++
expr_stmt|;
break|break;
block|}
comment|/* PRECISION */
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
block|{
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|args
condition|)
name|i
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|precis
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|i
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
else|else
block|{
name|precis
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|precis
operator|=
name|precis
operator|*
literal|10
operator|+
operator|(
operator|*
name|q
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
name|has_precis
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vectorize
condition|)
block|{
if|if
condition|(
name|args
condition|)
block|{
name|vecsv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|vecstr
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVx
argument_list|(
name|vecsv
argument_list|,
name|veclen
argument_list|)
expr_stmt|;
name|utf
operator|=
name|DO_UTF8
argument_list|(
name|vecsv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
block|{
name|vecsv
operator|=
name|svargs
index|[
name|svix
operator|++
index|]
expr_stmt|;
name|vecstr
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVx
argument_list|(
name|vecsv
argument_list|,
name|veclen
argument_list|)
expr_stmt|;
name|utf
operator|=
name|DO_UTF8
argument_list|(
name|vecsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vecstr
operator|=
operator|(
name|U8
operator|*
operator|)
literal|""
expr_stmt|;
name|veclen
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* SIZE */
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_QUAD
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAS_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|)
case|case
literal|'L'
case|:
comment|/* Ld */
comment|/* FALL THROUGH */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
comment|/* qd */
name|intsize
operator|=
literal|'q'
expr_stmt|;
name|q
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'l'
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAS_QUAD
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAS_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|)
if|if
condition|(
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|==
literal|'l'
condition|)
block|{
comment|/* lld, llf */
name|intsize
operator|=
literal|'q'
expr_stmt|;
name|q
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|'h'
case|:
comment|/* FALL THROUGH */
case|case
literal|'V'
case|:
name|intsize
operator|=
operator|*
name|q
operator|++
expr_stmt|;
break|break;
block|}
comment|/* CONVERSION */
switch|switch
condition|(
name|c
operator|=
operator|*
name|q
operator|++
condition|)
block|{
comment|/* STRINGS */
case|case
literal|'%'
case|:
name|eptr
operator|=
name|q
operator|-
literal|1
expr_stmt|;
name|elen
operator|=
literal|1
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'c'
case|:
if|if
condition|(
name|args
condition|)
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|uv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|uv
operator|>
literal|255
operator|||
operator|(
name|uv
operator|>
literal|127
operator|&&
name|SvUTF8
argument_list|(
name|sv
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|IN_BYTE
condition|)
block|{
name|eptr
operator|=
operator|(
name|char
operator|*
operator|)
name|utf8buf
expr_stmt|;
name|elen
operator|=
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|eptr
argument_list|,
name|uv
argument_list|)
operator|-
name|utf8buf
expr_stmt|;
name|is_utf
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|(
name|char
operator|)
name|uv
expr_stmt|;
name|eptr
operator|=
operator|&
name|c
expr_stmt|;
name|elen
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|string
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|eptr
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
condition|)
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
comment|/* On MacOS, %#s format is used for Pascal strings */
if|if
condition|(
name|alt
condition|)
name|elen
operator|=
operator|*
name|eptr
operator|++
expr_stmt|;
else|else
endif|#
directive|endif
name|elen
operator|=
name|strlen
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
else|else
block|{
name|eptr
operator|=
name|nullstr
expr_stmt|;
name|elen
operator|=
sizeof|sizeof
name|nullstr
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
block|{
name|argsv
operator|=
name|svargs
index|[
name|svix
operator|++
index|]
expr_stmt|;
name|eptr
operator|=
name|SvPVx
argument_list|(
name|argsv
argument_list|,
name|elen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|argsv
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_precis
operator|&&
name|precis
operator|<
name|elen
condition|)
block|{
name|I32
name|p
init|=
name|precis
decl_stmt|;
name|sv_pos_u2b
argument_list|(
name|argsv
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* sticks at end */
name|precis
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|width
condition|)
block|{
comment|/* fudge width (can't fudge elen) */
name|width
operator|+=
name|elen
operator|-
name|sv_len_utf8
argument_list|(
name|argsv
argument_list|)
expr_stmt|;
block|}
name|is_utf
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
goto|goto
name|string
goto|;
case|case
literal|'_'
case|:
comment|/* 	     * The "%_" hack might have to be changed someday, 	     * if ISO or ANSI decide to use '_' for something. 	     * So we keep it hidden from users' code. 	     */
if|if
condition|(
operator|!
name|args
condition|)
goto|goto
name|unknown
goto|;
name|argsv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|eptr
operator|=
name|SvPVx
argument_list|(
name|argsv
argument_list|,
name|elen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|argsv
argument_list|)
condition|)
name|is_utf
operator|=
name|TRUE
expr_stmt|;
name|string
label|:
name|vectorize
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|has_precis
operator|&&
name|elen
operator|>
name|precis
condition|)
name|elen
operator|=
name|precis
expr_stmt|;
break|break;
comment|/* INTEGERS */
case|case
literal|'p'
case|:
if|if
condition|(
name|alt
condition|)
goto|goto
name|unknown
goto|;
if|if
condition|(
name|args
condition|)
name|uv
operator|=
name|PTR2UV
argument_list|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|uv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|PTR2UV
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|IV_IS_QUAD
name|intsize
operator|=
literal|'q'
expr_stmt|;
else|#
directive|else
name|intsize
operator|=
literal|'l'
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|vectorize
condition|)
block|{
name|STRLEN
name|ulen
decl_stmt|;
if|if
condition|(
operator|!
name|veclen
condition|)
block|{
name|vectorize
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|utf
condition|)
name|iv
operator|=
operator|(
name|IV
operator|)
name|utf8_to_uv
argument_list|(
name|vecstr
argument_list|,
name|veclen
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|iv
operator|=
operator|*
name|vecstr
expr_stmt|;
name|ulen
operator|=
literal|1
expr_stmt|;
block|}
name|vecstr
operator|+=
name|ulen
expr_stmt|;
name|veclen
operator|-=
name|ulen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|iv
operator|=
operator|(
name|short
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
default|default:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|IV
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|Quad_t
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|iv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|iv
operator|=
operator|(
name|short
operator|)
name|iv
expr_stmt|;
break|break;
default|default:
break|break;
case|case
literal|'l'
case|:
name|iv
operator|=
operator|(
name|long
operator|)
name|iv
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|iv
operator|=
operator|(
name|Quad_t
operator|)
name|iv
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|iv
operator|>=
literal|0
condition|)
block|{
name|uv
operator|=
name|iv
expr_stmt|;
if|if
condition|(
name|plus
condition|)
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
name|plus
expr_stmt|;
block|}
else|else
block|{
name|uv
operator|=
operator|-
name|iv
expr_stmt|;
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
literal|'U'
case|:
ifdef|#
directive|ifdef
name|IV_IS_QUAD
name|intsize
operator|=
literal|'q'
expr_stmt|;
else|#
directive|else
name|intsize
operator|=
literal|'l'
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|'u'
case|:
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|uns_integer
goto|;
case|case
literal|'b'
case|:
name|base
operator|=
literal|2
expr_stmt|;
goto|goto
name|uns_integer
goto|;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|IV_IS_QUAD
name|intsize
operator|=
literal|'q'
expr_stmt|;
else|#
directive|else
name|intsize
operator|=
literal|'l'
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|'o'
case|:
name|base
operator|=
literal|8
expr_stmt|;
goto|goto
name|uns_integer
goto|;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
name|uns_integer
label|:
if|if
condition|(
name|vectorize
condition|)
block|{
name|STRLEN
name|ulen
decl_stmt|;
name|vector
label|:
if|if
condition|(
operator|!
name|veclen
condition|)
block|{
name|vectorize
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|utf
condition|)
name|uv
operator|=
name|utf8_to_uv
argument_list|(
name|vecstr
argument_list|,
name|veclen
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|uv
operator|=
operator|*
name|vecstr
expr_stmt|;
name|ulen
operator|=
literal|1
expr_stmt|;
block|}
name|vecstr
operator|+=
name|ulen
expr_stmt|;
name|veclen
operator|-=
name|ulen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|short
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
break|break;
default|default:
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|uv
operator|=
name|va_arg
argument_list|(
argument|*args
argument_list|,
argument|unsigned long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|UV
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|Quad_t
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|uv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvUVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|short
operator|)
name|uv
expr_stmt|;
break|break;
default|default:
break|break;
case|case
literal|'l'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|long
operator|)
name|uv
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|uv
operator|=
operator|(
name|Quad_t
operator|)
name|uv
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
name|integer
label|:
name|eptr
operator|=
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
name|unsigned
name|dig
decl_stmt|;
case|case
literal|16
case|:
if|if
condition|(
operator|!
name|uv
condition|)
name|alt
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
expr_stmt|;
do|do
block|{
name|dig
operator|=
name|uv
operator|&
literal|15
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
name|p
index|[
name|dig
index|]
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|>>=
literal|4
condition|)
do|;
if|if
condition|(
name|alt
condition|)
block|{
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
comment|/* 'x' or 'X' */
block|}
break|break;
case|case
literal|8
case|:
do|do
block|{
name|dig
operator|=
name|uv
operator|&
literal|7
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
name|dig
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|>>=
literal|3
condition|)
do|;
if|if
condition|(
name|alt
operator|&&
operator|*
name|eptr
operator|!=
literal|'0'
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|2
case|:
do|do
block|{
name|dig
operator|=
name|uv
operator|&
literal|1
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
name|dig
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|>>=
literal|1
condition|)
do|;
if|if
condition|(
name|alt
condition|)
block|{
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'b'
expr_stmt|;
block|}
break|break;
default|default:
comment|/* it had better be ten or less */
if|#
directive|if
name|defined
argument_list|(
name|PERL_Y2KWARN
argument_list|)
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_Y2K
argument_list|)
condition|)
block|{
name|STRLEN
name|n
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|2
operator|&&
name|s
index|[
name|n
operator|-
literal|2
index|]
operator|==
literal|'1'
operator|&&
name|s
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'9'
operator|&&
operator|(
name|n
operator|==
literal|2
operator|||
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
name|n
operator|-
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_Y2K
argument_list|,
literal|"Possible Y2K bug: %%%c %s"
argument_list|,
argument|c
argument_list|,
literal|"format string following '19'"
argument_list|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
do|do
block|{
name|dig
operator|=
name|uv
operator|%
name|base
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
name|dig
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|/=
name|base
condition|)
do|;
break|break;
block|}
name|elen
operator|=
operator|(
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
operator|)
operator|-
name|eptr
expr_stmt|;
if|if
condition|(
name|has_precis
condition|)
block|{
if|if
condition|(
name|precis
operator|>
name|elen
condition|)
name|zeros
operator|=
name|precis
operator|-
name|elen
expr_stmt|;
elseif|else
if|if
condition|(
name|precis
operator|==
literal|0
operator|&&
name|elen
operator|==
literal|1
operator|&&
operator|*
name|eptr
operator|==
literal|'0'
condition|)
name|elen
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|/* FLOATING POINT */
case|case
literal|'F'
case|:
name|c
operator|=
literal|'f'
expr_stmt|;
comment|/* maybe %F isn't supported here */
comment|/* FALL THROUGH */
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
comment|/* This is evil, but floating point is even more evil */
name|vectorize
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|nv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|NV
argument_list|)
expr_stmt|;
else|else
name|nv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvNVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0.0
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
operator|&&
name|c
operator|!=
literal|'E'
condition|)
block|{
name|i
operator|=
name|PERL_INT_MIN
expr_stmt|;
operator|(
name|void
operator|)
name|Perl_frexp
argument_list|(
name|nv
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|PERL_INT_MIN
condition|)
name|Perl_die
argument_list|(
name|aTHX_
literal|"panic: frexp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|need
operator|=
name|BIT_DIGITS
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|need
operator|+=
name|has_precis
condition|?
name|precis
else|:
literal|6
expr_stmt|;
comment|/* known default */
if|if
condition|(
name|need
operator|<
name|width
condition|)
name|need
operator|=
name|width
expr_stmt|;
name|need
operator|+=
literal|20
expr_stmt|;
comment|/* fudge factor */
if|if
condition|(
name|PL_efloatsize
operator|<
name|need
condition|)
block|{
name|Safefree
argument_list|(
name|PL_efloatbuf
argument_list|)
expr_stmt|;
name|PL_efloatsize
operator|=
name|need
operator|+
literal|20
expr_stmt|;
comment|/* more fudge */
name|New
argument_list|(
literal|906
argument_list|,
name|PL_efloatbuf
argument_list|,
name|PL_efloatsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|PL_efloatbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|eptr
operator|=
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
name|c
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_PRIfldbl
argument_list|)
block|{
comment|/* Copy the one or more characters in a long double 		 * format before the 'base' ([efgEFG]) character to 		 * the format string. */
specifier|static
name|char
specifier|const
name|prifldbl
index|[]
init|=
name|PERL_PRIfldbl
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|prifldbl
operator|+
sizeof|sizeof
argument_list|(
name|prifldbl
argument_list|)
operator|-
literal|3
decl_stmt|;
while|while
condition|(
name|p
operator|>=
name|prifldbl
condition|)
block|{
operator|*
operator|--
name|eptr
operator|=
operator|*
name|p
operator|--
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|has_precis
condition|)
block|{
name|base
operator|=
name|precis
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
operator|(
name|base
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|/=
literal|10
condition|)
do|;
operator|*
operator|--
name|eptr
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|width
condition|)
block|{
name|base
operator|=
name|width
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
operator|(
name|base
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|/=
literal|10
condition|)
do|;
block|}
if|if
condition|(
name|fill
operator|==
literal|'0'
condition|)
operator|*
operator|--
name|eptr
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|plus
condition|)
operator|*
operator|--
name|eptr
operator|=
name|plus
expr_stmt|;
if|if
condition|(
name|alt
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'#'
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'%'
expr_stmt|;
comment|/* No taint.  Otherwise we are in the strange situation 	     * where printf() taints but print($float) doesn't. 	     * --jhi */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PL_efloatbuf
argument_list|,
name|eptr
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|eptr
operator|=
name|PL_efloatbuf
expr_stmt|;
name|elen
operator|=
name|strlen
argument_list|(
name|PL_efloatbuf
argument_list|)
expr_stmt|;
break|break;
comment|/* SPECIAL */
case|case
literal|'n'
case|:
name|vectorize
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|origlen
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|short
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
default|default:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|long
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|IV
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|Quad_t
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
name|sv_setuv_mg
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|,
operator|(
name|UV
operator|)
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not "break" */
comment|/* UNKNOWN */
default|default:
name|unknown
label|:
name|vectorize
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|&&
name|ckWARN
argument_list|(
name|WARN_PRINTF
argument_list|)
operator|&&
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_PRTF
operator|||
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SPRINTF
operator|)
condition|)
block|{
name|SV
modifier|*
name|msg
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"Invalid conversion in %s: "
argument_list|,
argument|(PL_op->op_type == OP_PRTF) ?
literal|"printf"
argument|:
literal|"sprintf"
argument_list|)
empty_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|isPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"\"%%%c\""
argument_list|,
argument|c&
literal|0xFF
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"\"%%\\%03"
argument|UVof
literal|"\""
argument_list|,
argument|(UV)c&
literal|0xFF
argument_list|)
empty_stmt|;
block|}
else|else
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|"end of string"
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PRINTF
argument_list|,
literal|"%"
argument|SVf
argument_list|,
argument|msg
argument_list|)
empty_stmt|;
comment|/* yes, this is reentrant */
block|}
comment|/* output mangled stuff ... */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
operator|--
name|q
expr_stmt|;
name|eptr
operator|=
name|p
expr_stmt|;
name|elen
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* ... right here, because formatting flags should not apply */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|elen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|eptr
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elen
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|p
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not "break" */
block|}
name|have
operator|=
name|esignlen
operator|+
name|zeros
operator|+
name|elen
expr_stmt|;
name|need
operator|=
operator|(
name|have
operator|>
name|width
condition|?
name|have
else|:
name|width
operator|)
expr_stmt|;
name|gap
operator|=
name|need
operator|-
name|have
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|need
operator|+
name|dotstrlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|esignlen
operator|&&
name|fill
operator|==
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|esignlen
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|esignbuf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|&&
operator|!
name|left
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
name|fill
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|p
operator|+=
name|gap
expr_stmt|;
block|}
if|if
condition|(
name|esignlen
operator|&&
name|fill
operator|!=
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|esignlen
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|esignbuf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|zeros
condition|)
block|{
for|for
control|(
name|i
operator|=
name|zeros
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|elen
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|eptr
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elen
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|&&
name|left
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|p
operator|+=
name|gap
expr_stmt|;
block|}
if|if
condition|(
name|vectorize
condition|)
block|{
if|if
condition|(
name|veclen
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|dotstr
argument_list|,
name|dotstrlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|dotstrlen
expr_stmt|;
block|}
else|else
name|vectorize
operator|=
name|FALSE
expr_stmt|;
comment|/* done iterating over vecstr */
block|}
if|if
condition|(
name|is_utf
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|p
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorize
condition|)
block|{
name|esignlen
operator|=
literal|0
expr_stmt|;
goto|goto
name|vector
goto|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"error: USE_THREADS and USE_ITHREADS are incompatible"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GpREFCNT_inc
end_ifndef

begin_define
define|#
directive|define
name|GpREFCNT_inc
parameter_list|(
name|gp
parameter_list|)
value|((gp) ? (++(gp)->gp_refcnt, (gp)) : (GP*)NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_dup_inc
parameter_list|(
name|s
parameter_list|)
value|SvREFCNT_inc(sv_dup(s))
end_define

begin_define
define|#
directive|define
name|av_dup
parameter_list|(
name|s
parameter_list|)
value|(AV*)sv_dup((SV*)s)
end_define

begin_define
define|#
directive|define
name|av_dup_inc
parameter_list|(
name|s
parameter_list|)
value|(AV*)SvREFCNT_inc(sv_dup((SV*)s))
end_define

begin_define
define|#
directive|define
name|hv_dup
parameter_list|(
name|s
parameter_list|)
value|(HV*)sv_dup((SV*)s)
end_define

begin_define
define|#
directive|define
name|hv_dup_inc
parameter_list|(
name|s
parameter_list|)
value|(HV*)SvREFCNT_inc(sv_dup((SV*)s))
end_define

begin_define
define|#
directive|define
name|cv_dup
parameter_list|(
name|s
parameter_list|)
value|(CV*)sv_dup((SV*)s)
end_define

begin_define
define|#
directive|define
name|cv_dup_inc
parameter_list|(
name|s
parameter_list|)
value|(CV*)SvREFCNT_inc(sv_dup((SV*)s))
end_define

begin_define
define|#
directive|define
name|io_dup
parameter_list|(
name|s
parameter_list|)
value|(IO*)sv_dup((SV*)s)
end_define

begin_define
define|#
directive|define
name|io_dup_inc
parameter_list|(
name|s
parameter_list|)
value|(IO*)SvREFCNT_inc(sv_dup((SV*)s))
end_define

begin_define
define|#
directive|define
name|gv_dup
parameter_list|(
name|s
parameter_list|)
value|(GV*)sv_dup((SV*)s)
end_define

begin_define
define|#
directive|define
name|gv_dup_inc
parameter_list|(
name|s
parameter_list|)
value|(GV*)SvREFCNT_inc(sv_dup((SV*)s))
end_define

begin_define
define|#
directive|define
name|SAVEPV
parameter_list|(
name|p
parameter_list|)
value|(p ? savepv(p) : Nullch)
end_define

begin_define
define|#
directive|define
name|SAVEPVN
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(p ? savepvn(p,n) : Nullch)
end_define

begin_function
name|REGEXP
modifier|*
name|Perl_re_dup
parameter_list|(
name|pTHX_
name|REGEXP
modifier|*
name|r
parameter_list|)
block|{
comment|/* XXX fix when pmop->op_pmregexp becomes shared */
return|return
name|ReREFCNT_inc
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function

begin_function
name|PerlIO
modifier|*
name|Perl_fp_dup
parameter_list|(
name|pTHX_
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|char
name|type
parameter_list|)
block|{
name|PerlIO
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|(
name|PerlIO
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|ret
operator|=
operator|(
name|PerlIO
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* create anew and remember what it is */
name|ret
operator|=
name|PerlIO_fdupopen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|fp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|DIR
modifier|*
name|Perl_dirp_dup
parameter_list|(
name|pTHX_
name|DIR
modifier|*
name|dp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|DIR
operator|*
operator|)
name|NULL
return|;
comment|/* XXX TODO */
return|return
name|dp
return|;
block|}
end_function

begin_function
name|GP
modifier|*
name|Perl_gp_dup
parameter_list|(
name|pTHX_
name|GP
modifier|*
name|gp
parameter_list|)
block|{
name|GP
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|gp
condition|)
return|return
operator|(
name|GP
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|ret
operator|=
operator|(
name|GP
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* create anew and remember what it is */
name|Newz
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|gp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* clone */
name|ret
operator|->
name|gp_refcnt
operator|=
literal|0
expr_stmt|;
comment|/* must be before any other dups! */
name|ret
operator|->
name|gp_sv
operator|=
name|sv_dup_inc
argument_list|(
name|gp
operator|->
name|gp_sv
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_io
operator|=
name|io_dup_inc
argument_list|(
name|gp
operator|->
name|gp_io
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_form
operator|=
name|cv_dup_inc
argument_list|(
name|gp
operator|->
name|gp_form
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_av
operator|=
name|av_dup_inc
argument_list|(
name|gp
operator|->
name|gp_av
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_hv
operator|=
name|hv_dup_inc
argument_list|(
name|gp
operator|->
name|gp_hv
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_egv
operator|=
name|gv_dup
argument_list|(
name|gp
operator|->
name|gp_egv
argument_list|)
expr_stmt|;
comment|/* GvEGV is not refcounted */
name|ret
operator|->
name|gp_cv
operator|=
name|cv_dup_inc
argument_list|(
name|gp
operator|->
name|gp_cv
argument_list|)
expr_stmt|;
name|ret
operator|->
name|gp_cvgen
operator|=
name|gp
operator|->
name|gp_cvgen
expr_stmt|;
name|ret
operator|->
name|gp_flags
operator|=
name|gp
operator|->
name|gp_flags
expr_stmt|;
name|ret
operator|->
name|gp_line
operator|=
name|gp
operator|->
name|gp_line
expr_stmt|;
name|ret
operator|->
name|gp_file
operator|=
name|gp
operator|->
name|gp_file
expr_stmt|;
comment|/* points to COP.cop_file */
return|return
name|ret
return|;
block|}
end_function

begin_function
name|MAGIC
modifier|*
name|Perl_mg_dup
parameter_list|(
name|pTHX_
name|MAGIC
modifier|*
name|mg
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mgprev
init|=
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
decl_stmt|;
name|MAGIC
modifier|*
name|mgret
decl_stmt|;
if|if
condition|(
operator|!
name|mg
condition|)
return|return
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|mgret
operator|=
operator|(
name|MAGIC
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|mg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgret
condition|)
return|return
name|mgret
return|;
for|for
control|(
init|;
name|mg
condition|;
name|mg
operator|=
name|mg
operator|->
name|mg_moremagic
control|)
block|{
name|MAGIC
modifier|*
name|nmg
decl_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|nmg
argument_list|,
literal|1
argument_list|,
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgprev
condition|)
name|mgprev
operator|->
name|mg_moremagic
operator|=
name|nmg
expr_stmt|;
else|else
name|mgret
operator|=
name|nmg
expr_stmt|;
name|nmg
operator|->
name|mg_virtual
operator|=
name|mg
operator|->
name|mg_virtual
expr_stmt|;
comment|/* XXX copy dynamic vtable? */
name|nmg
operator|->
name|mg_private
operator|=
name|mg
operator|->
name|mg_private
expr_stmt|;
name|nmg
operator|->
name|mg_type
operator|=
name|mg
operator|->
name|mg_type
expr_stmt|;
name|nmg
operator|->
name|mg_flags
operator|=
name|mg
operator|->
name|mg_flags
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_type
operator|==
literal|'r'
condition|)
block|{
name|nmg
operator|->
name|mg_obj
operator|=
operator|(
name|SV
operator|*
operator|)
name|re_dup
argument_list|(
operator|(
name|REGEXP
operator|*
operator|)
name|mg
operator|->
name|mg_obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nmg
operator|->
name|mg_obj
operator|=
operator|(
name|mg
operator|->
name|mg_flags
operator|&
name|MGf_REFCOUNTED
operator|)
condition|?
name|sv_dup_inc
argument_list|(
name|mg
operator|->
name|mg_obj
argument_list|)
else|:
name|sv_dup
argument_list|(
name|mg
operator|->
name|mg_obj
argument_list|)
expr_stmt|;
block|}
name|nmg
operator|->
name|mg_len
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
name|nmg
operator|->
name|mg_ptr
operator|=
name|mg
operator|->
name|mg_ptr
expr_stmt|;
comment|/* XXX random ptr? */
if|if
condition|(
name|mg
operator|->
name|mg_ptr
operator|&&
name|mg
operator|->
name|mg_type
operator|!=
literal|'g'
condition|)
block|{
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
block|{
name|nmg
operator|->
name|mg_ptr
operator|=
name|SAVEPVN
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|,
name|mg
operator|->
name|mg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_type
operator|==
literal|'c'
operator|&&
name|AMT_AMAGIC
argument_list|(
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
condition|)
block|{
name|AMT
modifier|*
name|amtp
init|=
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
decl_stmt|;
name|AMT
modifier|*
name|namtp
init|=
operator|(
name|AMT
operator|*
operator|)
name|nmg
operator|->
name|mg_ptr
decl_stmt|;
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NofAMmeth
condition|;
name|i
operator|++
control|)
block|{
name|namtp
operator|->
name|table
index|[
name|i
index|]
operator|=
name|cv_dup_inc
argument_list|(
name|amtp
operator|->
name|table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|==
name|HEf_SVKEY
condition|)
name|nmg
operator|->
name|mg_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|sv_dup_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
block|}
name|mgprev
operator|=
name|nmg
expr_stmt|;
block|}
return|return
name|mgret
return|;
block|}
end_function

begin_function
name|PTR_TBL_t
modifier|*
name|Perl_ptr_table_new
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|PTR_TBL_t
modifier|*
name|tbl
decl_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|tbl
argument_list|,
literal|1
argument_list|,
name|PTR_TBL_t
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|tbl_max
operator|=
literal|511
expr_stmt|;
name|tbl
operator|->
name|tbl_items
operator|=
literal|0
expr_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|tbl
operator|->
name|tbl_ary
argument_list|,
name|tbl
operator|->
name|tbl_max
operator|+
literal|1
argument_list|,
name|PTR_TBL_ENT_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|tbl
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|Perl_ptr_table_fetch
parameter_list|(
name|pTHX_
name|PTR_TBL_t
modifier|*
name|tbl
parameter_list|,
name|void
modifier|*
name|sv
parameter_list|)
block|{
name|PTR_TBL_ENT_t
modifier|*
name|tblent
decl_stmt|;
name|UV
name|hash
init|=
name|PTR2UV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|tblent
operator|=
name|tbl
operator|->
name|tbl_ary
index|[
name|hash
operator|&
name|tbl
operator|->
name|tbl_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|tblent
condition|;
name|tblent
operator|=
name|tblent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tblent
operator|->
name|oldval
operator|==
name|sv
condition|)
return|return
name|tblent
operator|->
name|newval
return|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|Perl_ptr_table_store
parameter_list|(
name|pTHX_
name|PTR_TBL_t
modifier|*
name|tbl
parameter_list|,
name|void
modifier|*
name|oldv
parameter_list|,
name|void
modifier|*
name|newv
parameter_list|)
block|{
name|PTR_TBL_ENT_t
modifier|*
name|tblent
decl_stmt|,
modifier|*
modifier|*
name|otblent
decl_stmt|;
comment|/* XXX this may be pessimal on platforms where pointers aren't good      * hash values e.g. if they grow faster in the most significant      * bits */
name|UV
name|hash
init|=
name|PTR2UV
argument_list|(
name|oldv
argument_list|)
decl_stmt|;
name|bool
name|i
init|=
literal|1
decl_stmt|;
name|assert
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|otblent
operator|=
operator|&
name|tbl
operator|->
name|tbl_ary
index|[
name|hash
operator|&
name|tbl
operator|->
name|tbl_max
index|]
expr_stmt|;
for|for
control|(
name|tblent
operator|=
operator|*
name|otblent
init|;
name|tblent
condition|;
name|i
operator|=
literal|0
operator|,
name|tblent
operator|=
name|tblent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tblent
operator|->
name|oldval
operator|==
name|oldv
condition|)
block|{
name|tblent
operator|->
name|newval
operator|=
name|newv
expr_stmt|;
name|tbl
operator|->
name|tbl_items
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|Newz
argument_list|(
literal|0
argument_list|,
name|tblent
argument_list|,
literal|1
argument_list|,
name|PTR_TBL_ENT_t
argument_list|)
expr_stmt|;
name|tblent
operator|->
name|oldval
operator|=
name|oldv
expr_stmt|;
name|tblent
operator|->
name|newval
operator|=
name|newv
expr_stmt|;
name|tblent
operator|->
name|next
operator|=
operator|*
name|otblent
expr_stmt|;
operator|*
name|otblent
operator|=
name|tblent
expr_stmt|;
name|tbl
operator|->
name|tbl_items
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|tbl
operator|->
name|tbl_items
operator|>
name|tbl
operator|->
name|tbl_max
condition|)
name|ptr_table_split
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_ptr_table_split
parameter_list|(
name|pTHX_
name|PTR_TBL_t
modifier|*
name|tbl
parameter_list|)
block|{
name|PTR_TBL_ENT_t
modifier|*
modifier|*
name|ary
init|=
name|tbl
operator|->
name|tbl_ary
decl_stmt|;
name|UV
name|oldsize
init|=
name|tbl
operator|->
name|tbl_max
operator|+
literal|1
decl_stmt|;
name|UV
name|newsize
init|=
name|oldsize
operator|*
literal|2
decl_stmt|;
name|UV
name|i
decl_stmt|;
name|Renew
argument_list|(
name|ary
argument_list|,
name|newsize
argument_list|,
name|PTR_TBL_ENT_t
operator|*
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|ary
index|[
name|oldsize
index|]
argument_list|,
name|newsize
operator|-
name|oldsize
argument_list|,
name|PTR_TBL_ENT_t
operator|*
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|tbl_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|tbl
operator|->
name|tbl_ary
operator|=
name|ary
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|ary
operator|++
control|)
block|{
name|PTR_TBL_ENT_t
modifier|*
modifier|*
name|curentp
decl_stmt|,
modifier|*
modifier|*
name|entp
decl_stmt|,
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|ary
condition|)
continue|continue;
name|curentp
operator|=
name|ary
operator|+
name|oldsize
expr_stmt|;
for|for
control|(
name|entp
operator|=
name|ary
operator|,
name|ent
operator|=
operator|*
name|ary
init|;
name|ent
condition|;
name|ent
operator|=
operator|*
name|entp
control|)
block|{
if|if
condition|(
operator|(
name|newsize
operator|&
name|PTR2UV
argument_list|(
name|ent
operator|->
name|oldval
argument_list|)
operator|)
operator|!=
name|i
condition|)
block|{
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
name|ent
operator|->
name|next
operator|=
operator|*
name|curentp
expr_stmt|;
operator|*
name|curentp
operator|=
name|ent
expr_stmt|;
continue|continue;
block|}
else|else
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|Perl_ptr_table_clear
parameter_list|(
name|pTHX_
name|PTR_TBL_t
modifier|*
name|tbl
parameter_list|)
block|{
specifier|register
name|PTR_TBL_ENT_t
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|PTR_TBL_ENT_t
modifier|*
name|entry
decl_stmt|;
specifier|register
name|PTR_TBL_ENT_t
modifier|*
name|oentry
init|=
name|Null
argument_list|(
name|PTR_TBL_ENT_t
operator|*
argument_list|)
decl_stmt|;
name|UV
name|riter
init|=
literal|0
decl_stmt|;
name|UV
name|max
decl_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|||
operator|!
name|tbl
operator|->
name|tbl_items
condition|)
block|{
return|return;
block|}
name|array
operator|=
name|tbl
operator|->
name|tbl_ary
expr_stmt|;
name|entry
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
name|max
operator|=
name|tbl
operator|->
name|tbl_max
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|entry
condition|)
block|{
name|oentry
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|Safefree
argument_list|(
name|oentry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
operator|++
name|riter
operator|>
name|max
condition|)
block|{
break|break;
block|}
name|entry
operator|=
name|array
index|[
name|riter
index|]
expr_stmt|;
block|}
block|}
name|tbl
operator|->
name|tbl_items
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_ptr_table_free
parameter_list|(
name|pTHX_
name|PTR_TBL_t
modifier|*
name|tbl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tbl
condition|)
block|{
return|return;
block|}
name|ptr_table_clear
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tbl
operator|->
name|tbl_ary
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|PL_watch_pvx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|SV
modifier|*
name|Perl_sv_dup
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|SV
modifier|*
name|dstr
decl_stmt|;
if|if
condition|(
operator|!
name|sstr
operator|||
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
operator|==
name|SVTYPEMASK
condition|)
return|return
name|Nullsv
return|;
comment|/* look for it in the table first */
name|dstr
operator|=
operator|(
name|SV
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstr
condition|)
return|return
name|dstr
return|;
comment|/* create anew and remember what it is */
name|new_SV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|sstr
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
comment|/* clone */
name|SvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|&=
operator|~
name|SVf_OOK
expr_stmt|;
comment|/* don't propagate OOK hack */
name|SvREFCNT
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* must be before any other dups! */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|SvANY
argument_list|(
name|sstr
argument_list|)
operator|&&
name|PL_watch_pvx
operator|&&
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|==
name|PL_watch_pvx
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"watch at %p hit, found string \"%s\"\n"
argument_list|,
name|PL_watch_pvx
argument_list|,
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SVt_IV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XIV
argument_list|()
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XNV
argument_list|()
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XRV
argument_list|()
expr_stmt|;
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
break|break;
case|case
name|SVt_PVIV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVIV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
break|break;
case|case
name|SVt_PVNV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVNV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
break|break;
case|case
name|SVt_PVMG
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVMG
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
break|break;
case|case
name|SVt_PVBM
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVBM
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
name|BmRARE
argument_list|(
name|dstr
argument_list|)
operator|=
name|BmRARE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|dstr
argument_list|)
operator|=
name|BmUSEFUL
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|BmPREVIOUS
argument_list|(
name|dstr
argument_list|)
operator|=
name|BmPREVIOUS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVLV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
name|LvTARGOFF
argument_list|(
name|dstr
argument_list|)
operator|=
name|LvTARGOFF
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX sometimes holds PMOP* when DEBUGGING */
name|LvTARGLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|LvTARGLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|LvTARG
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|LvTYPE
argument_list|(
name|dstr
argument_list|)
operator|=
name|LvTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVGV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
name|GvNAMELEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|GvNAMELEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|GvNAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|GvNAME
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|GvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|=
name|GvFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|=
name|gp_dup
argument_list|(
name|GvGP
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|GpREFCNT_inc
argument_list|(
name|GvGP
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVIO
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
name|IoIFP
argument_list|(
name|dstr
argument_list|)
operator|=
name|fp_dup
argument_list|(
name|IoIFP
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|IoTYPE
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|sstr
argument_list|)
operator|==
name|IoIFP
argument_list|(
name|sstr
argument_list|)
condition|)
name|IoOFP
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoIFP
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
else|else
name|IoOFP
argument_list|(
name|dstr
argument_list|)
operator|=
name|fp_dup
argument_list|(
name|IoOFP
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|IoTYPE
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PL_rsfp_filters entries have fake IoDIRP() */
if|if
condition|(
name|IoDIRP
argument_list|(
name|sstr
argument_list|)
operator|&&
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|sstr
argument_list|)
operator|&
name|IOf_FAKE_DIRP
operator|)
condition|)
name|IoDIRP
argument_list|(
name|dstr
argument_list|)
operator|=
name|dirp_dup
argument_list|(
name|IoDIRP
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|IoDIRP
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoDIRP
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoLINES
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoLINES
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoPAGE
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoPAGE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoPAGE_LEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoPAGE_LEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoLINES_LEFT
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoLINES_LEFT
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoTOP_NAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPV
argument_list|(
name|IoTOP_NAME
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoTOP_GV
argument_list|(
name|dstr
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|IoTOP_GV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoFMT_NAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPV
argument_list|(
name|IoFMT_NAME
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoFMT_GV
argument_list|(
name|dstr
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|IoFMT_GV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoBOTTOM_NAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPV
argument_list|(
name|IoBOTTOM_NAME
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoBOTTOM_GV
argument_list|(
name|dstr
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|IoBOTTOM_GV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|IoSUBPROCESS
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoSUBPROCESS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|IoFLAGS
argument_list|(
name|dstr
argument_list|)
operator|=
name|IoFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVAV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|AvARYLEN
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|AvARYLEN
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|AvFLAGS
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|dst_ary
decl_stmt|,
modifier|*
modifier|*
name|src_ary
decl_stmt|;
name|SSize_t
name|items
init|=
name|AvFILLp
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
operator|+
literal|1
decl_stmt|;
name|src_ary
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|dst_ary
argument_list|,
name|AvMAX
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|src_ary
argument_list|,
name|dst_ary
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|dst_ary
expr_stmt|;
name|AvALLOC
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|dst_ary
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
condition|)
block|{
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
operator|*
name|dst_ary
operator|++
operator|=
name|sv_dup_inc
argument_list|(
operator|*
name|src_ary
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
operator|*
name|dst_ary
operator|++
operator|=
name|sv_dup
argument_list|(
operator|*
name|src_ary
operator|++
argument_list|)
expr_stmt|;
block|}
name|items
operator|=
name|AvMAX
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
operator|-
name|AvFILLp
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sstr
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|dst_ary
operator|++
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|Nullch
expr_stmt|;
name|AvALLOC
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|SVt_PVHV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVHV
argument_list|()
expr_stmt|;
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|HvRITER
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|HvRITER
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvARRAY
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sstr
argument_list|)
condition|)
block|{
name|STRLEN
name|i
init|=
literal|0
decl_stmt|;
name|XPVHV
modifier|*
name|dxhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
name|XPVHV
modifier|*
name|sxhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|dxhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|dxhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|sxhv
operator|->
name|xhv_max
condition|)
block|{
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|dxhv
operator|->
name|xhv_array
operator|)
index|[
name|i
index|]
operator|=
name|he_dup
argument_list|(
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|sxhv
operator|->
name|xhv_array
operator|)
index|[
name|i
index|]
argument_list|,
operator|!
operator|!
name|HvSHAREKEYS
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|dxhv
operator|->
name|xhv_eiter
operator|=
name|he_dup
argument_list|(
name|sxhv
operator|->
name|xhv_eiter
argument_list|,
operator|!
operator|!
name|HvSHAREKEYS
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|Nullch
expr_stmt|;
name|HvEITER
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
operator|(
name|HE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|HvPMROOT
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|HvPMROOT
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX */
name|HvNAME
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|dstr
argument_list|)
operator|=
name|SAVEPV
argument_list|(
name|HvNAME
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVFM
argument_list|()
expr_stmt|;
name|FmLINES
argument_list|(
name|dstr
argument_list|)
operator|=
name|FmLINES
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
goto|goto
name|dup_pvcv
goto|;
comment|/* NOTREACHED */
case|case
name|SVt_PVCV
case|:
name|SvANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|new_XPVCV
argument_list|()
expr_stmt|;
name|dup_pvcv
label|:
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|dstr
argument_list|)
operator|=
name|mg_dup
argument_list|(
name|SvMAGIC
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|SvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sstr
argument_list|)
condition|)
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
comment|/* XXX shared string/random ptr? */
name|CvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
name|hv_dup
argument_list|(
name|CvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: not refcounted */
name|CvSTART
argument_list|(
name|dstr
argument_list|)
operator|=
name|CvSTART
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|dstr
argument_list|)
operator|=
name|OpREFCNT_inc
argument_list|(
name|CvROOT
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|CvXSUB
argument_list|(
name|dstr
argument_list|)
operator|=
name|CvXSUB
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|CvXSUBANY
argument_list|(
name|dstr
argument_list|)
operator|=
name|CvXSUBANY
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
name|dstr
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|CvGV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|CvDEPTH
argument_list|(
name|dstr
argument_list|)
operator|=
name|CvDEPTH
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
operator|&&
operator|!
name|AvREAL
argument_list|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* XXX padlists are real, but pretend to be not */
name|AvREAL_on
argument_list|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|dstr
argument_list|)
operator|=
name|av_dup_inc
argument_list|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|AvREAL_off
argument_list|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|AvREAL_off
argument_list|(
name|CvPADLIST
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|CvPADLIST
argument_list|(
name|dstr
argument_list|)
operator|=
name|av_dup_inc
argument_list|(
name|CvPADLIST
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CvANON
argument_list|(
name|sstr
argument_list|)
operator|||
name|CvCLONED
argument_list|(
name|sstr
argument_list|)
condition|)
name|CvOUTSIDE
argument_list|(
name|dstr
argument_list|)
operator|=
name|cv_dup_inc
argument_list|(
name|CvOUTSIDE
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CvOUTSIDE
argument_list|(
name|dstr
argument_list|)
operator|=
name|cv_dup
argument_list|(
name|CvOUTSIDE
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|=
name|CvFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bizarre SvTYPE [%d]"
argument_list|,
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SvOBJECT
argument_list|(
name|dstr
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|dstr
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|++
name|PL_sv_objcount
expr_stmt|;
return|return
name|dstr
return|;
block|}
end_function

begin_function
name|PERL_CONTEXT
modifier|*
name|Perl_cx_dup
parameter_list|(
name|pTHX_
name|PERL_CONTEXT
modifier|*
name|cxs
parameter_list|,
name|I32
name|ix
parameter_list|,
name|I32
name|max
parameter_list|)
block|{
name|PERL_CONTEXT
modifier|*
name|ncxs
decl_stmt|;
if|if
condition|(
operator|!
name|cxs
condition|)
return|return
operator|(
name|PERL_CONTEXT
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|ncxs
operator|=
operator|(
name|PERL_CONTEXT
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|cxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncxs
condition|)
return|return
name|ncxs
return|;
comment|/* create anew and remember what it is */
name|Newz
argument_list|(
literal|56
argument_list|,
name|ncxs
argument_list|,
name|max
operator|+
literal|1
argument_list|,
name|PERL_CONTEXT
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|cxs
argument_list|,
name|ncxs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|PERL_CONTEXT
modifier|*
name|cx
init|=
operator|&
name|cxs
index|[
name|ix
index|]
decl_stmt|;
name|PERL_CONTEXT
modifier|*
name|ncx
init|=
operator|&
name|ncxs
index|[
name|ix
index|]
decl_stmt|;
name|ncx
operator|->
name|cx_type
operator|=
name|cx
operator|->
name|cx_type
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUBST
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Cloning substitution context is unimplemented"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ncx
operator|->
name|blk_oldsp
operator|=
name|cx
operator|->
name|blk_oldsp
expr_stmt|;
name|ncx
operator|->
name|blk_oldcop
operator|=
name|cx
operator|->
name|blk_oldcop
expr_stmt|;
name|ncx
operator|->
name|blk_oldretsp
operator|=
name|cx
operator|->
name|blk_oldretsp
expr_stmt|;
name|ncx
operator|->
name|blk_oldmarksp
operator|=
name|cx
operator|->
name|blk_oldmarksp
expr_stmt|;
name|ncx
operator|->
name|blk_oldscopesp
operator|=
name|cx
operator|->
name|blk_oldscopesp
expr_stmt|;
name|ncx
operator|->
name|blk_oldpm
operator|=
name|cx
operator|->
name|blk_oldpm
expr_stmt|;
name|ncx
operator|->
name|blk_gimme
operator|=
name|cx
operator|->
name|blk_gimme
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUB
case|:
name|ncx
operator|->
name|blk_sub
operator|.
name|cv
operator|=
operator|(
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|==
literal|0
condition|?
name|cv_dup_inc
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
else|:
name|cv_dup
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
operator|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|argarray
operator|=
operator|(
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|?
name|av_dup_inc
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
argument_list|)
else|:
name|Nullav
operator|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|savearray
operator|=
name|av_dup_inc
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|lval
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|lval
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|ncx
operator|->
name|blk_eval
operator|.
name|old_in_eval
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_in_eval
expr_stmt|;
name|ncx
operator|->
name|blk_eval
operator|.
name|old_op_type
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
expr_stmt|;
name|ncx
operator|->
name|blk_eval
operator|.
name|old_namesv
operator|=
name|sv_dup_inc
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_namesv
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_eval
operator|.
name|old_eval_root
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_eval_root
expr_stmt|;
name|ncx
operator|->
name|blk_eval
operator|.
name|cur_text
operator|=
name|sv_dup
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|cur_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_LOOP
case|:
name|ncx
operator|->
name|blk_loop
operator|.
name|label
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|label
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|resetsp
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|resetsp
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|redo_op
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|redo_op
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|next_op
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|next_op
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|last_op
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|last_op
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|iterdata
operator|=
operator|(
name|CxPADLOOP
argument_list|(
name|cx
argument_list|)
condition|?
name|cx
operator|->
name|blk_loop
operator|.
name|iterdata
else|:
name|gv_dup
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterdata
argument_list|)
operator|)
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|oldcurpad
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|cx
operator|->
name|blk_loop
operator|.
name|oldcurpad
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|itersave
operator|=
name|sv_dup_inc
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|itersave
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|iterlval
operator|=
name|sv_dup_inc
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterlval
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|iterary
operator|=
name|av_dup_inc
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|iterix
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|iterix
expr_stmt|;
name|ncx
operator|->
name|blk_loop
operator|.
name|itermax
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|itermax
expr_stmt|;
break|break;
case|case
name|CXt_FORMAT
case|:
name|ncx
operator|->
name|blk_sub
operator|.
name|cv
operator|=
name|cv_dup
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|gv
operator|=
name|gv_dup
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|gv
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|dfoutgv
operator|=
name|gv_dup_inc
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|dfoutgv
argument_list|)
expr_stmt|;
name|ncx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
expr_stmt|;
break|break;
case|case
name|CXt_BLOCK
case|:
case|case
name|CXt_NULL
case|:
break|break;
block|}
block|}
operator|--
name|ix
expr_stmt|;
block|}
return|return
name|ncxs
return|;
block|}
end_function

begin_function
name|PERL_SI
modifier|*
name|Perl_si_dup
parameter_list|(
name|pTHX_
name|PERL_SI
modifier|*
name|si
parameter_list|)
block|{
name|PERL_SI
modifier|*
name|nsi
decl_stmt|;
if|if
condition|(
operator|!
name|si
condition|)
return|return
operator|(
name|PERL_SI
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|nsi
operator|=
operator|(
name|PERL_SI
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsi
condition|)
return|return
name|nsi
return|;
comment|/* create anew and remember what it is */
name|Newz
argument_list|(
literal|56
argument_list|,
name|nsi
argument_list|,
literal|1
argument_list|,
name|PERL_SI
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|si
argument_list|,
name|nsi
argument_list|)
expr_stmt|;
name|nsi
operator|->
name|si_stack
operator|=
name|av_dup_inc
argument_list|(
name|si
operator|->
name|si_stack
argument_list|)
expr_stmt|;
name|nsi
operator|->
name|si_cxix
operator|=
name|si
operator|->
name|si_cxix
expr_stmt|;
name|nsi
operator|->
name|si_cxmax
operator|=
name|si
operator|->
name|si_cxmax
expr_stmt|;
name|nsi
operator|->
name|si_cxstack
operator|=
name|cx_dup
argument_list|(
name|si
operator|->
name|si_cxstack
argument_list|,
name|si
operator|->
name|si_cxix
argument_list|,
name|si
operator|->
name|si_cxmax
argument_list|)
expr_stmt|;
name|nsi
operator|->
name|si_type
operator|=
name|si
operator|->
name|si_type
expr_stmt|;
name|nsi
operator|->
name|si_prev
operator|=
name|si_dup
argument_list|(
name|si
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|nsi
operator|->
name|si_next
operator|=
name|si_dup
argument_list|(
name|si
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|nsi
operator|->
name|si_markoff
operator|=
name|si
operator|->
name|si_markoff
expr_stmt|;
return|return
name|nsi
return|;
block|}
end_function

begin_define
define|#
directive|define
name|POPINT
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_i32)
end_define

begin_define
define|#
directive|define
name|TOPINT
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_i32)
end_define

begin_define
define|#
directive|define
name|POPLONG
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_long)
end_define

begin_define
define|#
directive|define
name|TOPLONG
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_long)
end_define

begin_define
define|#
directive|define
name|POPIV
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_iv)
end_define

begin_define
define|#
directive|define
name|TOPIV
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_iv)
end_define

begin_define
define|#
directive|define
name|POPPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_ptr)
end_define

begin_define
define|#
directive|define
name|TOPPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_ptr)
end_define

begin_define
define|#
directive|define
name|POPDPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_dptr)
end_define

begin_define
define|#
directive|define
name|TOPDPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_dptr)
end_define

begin_define
define|#
directive|define
name|POPDXPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[--(ix)].any_dxptr)
end_define

begin_define
define|#
directive|define
name|TOPDXPTR
parameter_list|(
name|ss
parameter_list|,
name|ix
parameter_list|)
value|((ss)[ix].any_dxptr)
end_define

begin_comment
comment|/* XXXXX todo */
end_comment

begin_define
define|#
directive|define
name|pv_dup_inc
parameter_list|(
name|p
parameter_list|)
value|SAVEPV(p)
end_define

begin_define
define|#
directive|define
name|pv_dup
parameter_list|(
name|p
parameter_list|)
value|SAVEPV(p)
end_define

begin_define
define|#
directive|define
name|svp_dup_inc
parameter_list|(
name|p
parameter_list|,
name|pp
parameter_list|)
value|any_dup(p,pp)
end_define

begin_function
name|void
modifier|*
name|Perl_any_dup
parameter_list|(
name|pTHX_
name|void
modifier|*
name|v
parameter_list|,
name|PerlInterpreter
modifier|*
name|proto_perl
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|NULL
return|;
comment|/* look for it in the table first */
name|ret
operator|=
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* see if it is part of the interpreter structure */
if|if
condition|(
name|v
operator|>=
operator|(
name|void
operator|*
operator|)
name|proto_perl
operator|&&
name|v
operator|<
operator|(
name|void
operator|*
operator|)
operator|(
name|proto_perl
operator|+
literal|1
operator|)
condition|)
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|aTHXo
operator|)
operator|+
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|v
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|proto_perl
operator|)
operator|)
expr_stmt|;
else|else
name|ret
operator|=
name|v
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ANY
modifier|*
name|Perl_ss_dup
parameter_list|(
name|pTHX_
name|PerlInterpreter
modifier|*
name|proto_perl
parameter_list|)
block|{
name|ANY
modifier|*
name|ss
init|=
name|proto_perl
operator|->
name|Tsavestack
decl_stmt|;
name|I32
name|ix
init|=
name|proto_perl
operator|->
name|Tsavestack_ix
decl_stmt|;
name|I32
name|max
init|=
name|proto_perl
operator|->
name|Tsavestack_max
decl_stmt|;
name|ANY
modifier|*
name|nss
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|AV
modifier|*
name|av
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|intval
decl_stmt|;
name|long
name|longval
decl_stmt|;
name|GP
modifier|*
name|gp
decl_stmt|;
name|IV
name|iv
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|void
function_decl|(
modifier|*
name|dptr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|dxptr
function_decl|)
parameter_list|(
name|pTHXo_
name|void
modifier|*
parameter_list|)
function_decl|;
name|OP
modifier|*
name|o
decl_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|nss
argument_list|,
name|max
argument_list|,
name|ANY
argument_list|)
expr_stmt|;
while|while
condition|(
name|ix
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|SAVEt_ITEM
case|:
comment|/* normal string */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_SV
case|:
comment|/* scalar reference */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gv_dup_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_GENERIC_PVREF
case|:
comment|/* generic char* */
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|pv_dup
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_GENERIC_SVREF
case|:
comment|/* generic sv */
case|case
name|SAVEt_SVREF
case|:
comment|/* scalar reference */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|svp_dup_inc
argument_list|(
operator|(
name|SV
operator|*
operator|*
operator|)
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
comment|/* XXXXX */
break|break;
case|case
name|SAVEt_AV
case|:
comment|/* array reference */
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|av_dup_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_HV
case|:
comment|/* hash reference */
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_INT
case|:
comment|/* int reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|intval
operator|=
operator|(
name|int
operator|)
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|SAVEt_LONG
case|:
comment|/* long reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|longval
operator|=
operator|(
name|long
operator|)
name|POPLONG
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPLONG
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|longval
expr_stmt|;
break|break;
case|case
name|SAVEt_I32
case|:
comment|/* I32 reference */
case|case
name|SAVEt_I16
case|:
comment|/* I16 reference */
case|case
name|SAVEt_I8
case|:
comment|/* I8 reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|SAVEt_IV
case|:
comment|/* IV reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|iv
operator|=
name|POPIV
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPIV
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|iv
expr_stmt|;
break|break;
case|case
name|SAVEt_SPTR
case|:
comment|/* SV* reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_VPTR
case|:
comment|/* random* reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_PPTR
case|:
comment|/* char* reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|pv_dup
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_HPTR
case|:
comment|/* HV* reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|hv_dup
argument_list|(
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_APTR
case|:
comment|/* AV* reference */
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|av_dup
argument_list|(
name|av
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_NSTAB
case|:
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gv_dup
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_GP
case|:
comment|/* scalar reference */
name|gp
operator|=
operator|(
name|GP
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gp
operator|=
name|gp_dup
argument_list|(
name|gp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|GpREFCNT_inc
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|gv_dup_inc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|pv_dup
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|iv
operator|=
name|POPIV
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPIV
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|iv
expr_stmt|;
name|iv
operator|=
name|POPIV
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPIV
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|iv
expr_stmt|;
break|break;
case|case
name|SAVEt_FREESV
case|:
case|case
name|SAVEt_MORTALIZESV
case|:
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_FREEOP
case|:
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&&
operator|(
operator|(
operator|(
name|OP
operator|*
operator|)
name|ptr
operator|)
operator|->
name|op_private
operator|&
name|OPpREFCOUNTED
operator|)
condition|)
block|{
comment|/* these are assumed to be refcounted properly */
switch|switch
condition|(
operator|(
operator|(
name|OP
operator|*
operator|)
name|ptr
operator|)
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_LEAVESUB
case|:
case|case
name|OP_LEAVESUBLV
case|:
case|case
name|OP_LEAVEEVAL
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVEWRITE
case|:
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|ptr
expr_stmt|;
name|o
operator|=
operator|(
name|OP
operator|*
operator|)
name|ptr
expr_stmt|;
name|OpREFCNT_inc
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|Nullop
expr_stmt|;
break|break;
block|}
block|}
else|else
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|Nullop
expr_stmt|;
break|break;
case|case
name|SAVEt_FREEPV
case|:
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|pv_dup_inc
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_CLEARSV
case|:
name|longval
operator|=
name|POPLONG
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPLONG
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|longval
expr_stmt|;
break|break;
case|case
name|SAVEt_DELETE
case|:
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|pv_dup_inc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|SAVEt_DESTRUCTOR
case|:
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
comment|/* XXX quite arbitrary */
name|dptr
operator|=
name|POPDPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPDPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|any_dup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_DESTRUCTOR_X
case|:
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
comment|/* XXX quite arbitrary */
name|dxptr
operator|=
name|POPDXPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPDXPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|pTHXo_
name|void
operator|*
operator|)
operator|)
name|any_dup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dxptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_REGCONTEXT
case|:
case|case
name|SAVEt_ALLOC
case|:
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
name|ix
operator|-=
name|i
expr_stmt|;
break|break;
case|case
name|SAVEt_STACK_POS
case|:
comment|/* Position on Perl stack */
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|SAVEt_AELEM
case|:
comment|/* array element */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|av_dup_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_HELEM
case|:
comment|/* hash element */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|hv_dup_inc
argument_list|(
name|hv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_OP
case|:
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|ptr
expr_stmt|;
break|break;
case|case
name|SAVEt_HINTS
case|:
name|i
operator|=
name|POPINT
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPINT
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|SAVEt_COMPPAD
case|:
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|av_dup
argument_list|(
name|av
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVEt_PADSV
case|:
name|longval
operator|=
operator|(
name|long
operator|)
name|POPLONG
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPLONG
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|longval
expr_stmt|;
name|ptr
operator|=
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|any_dup
argument_list|(
name|ptr
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|POPPTR
argument_list|(
name|ss
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|TOPPTR
argument_list|(
name|nss
argument_list|,
name|ix
argument_list|)
operator|=
name|sv_dup
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: ss_dup inconsistency"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nss
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|PerlInterpreter
modifier|*
name|perl_clone
parameter_list|(
name|PerlInterpreter
modifier|*
name|proto_perl
parameter_list|,
name|UV
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|CPerlObj
modifier|*
name|pPerl
init|=
operator|(
name|CPerlObj
operator|*
operator|)
name|proto_perl
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
return|return
name|perl_clone_using
argument_list|(
name|proto_perl
argument_list|,
name|flags
argument_list|,
name|proto_perl
operator|->
name|IMem
argument_list|,
name|proto_perl
operator|->
name|IMemShared
argument_list|,
name|proto_perl
operator|->
name|IMemParse
argument_list|,
name|proto_perl
operator|->
name|IEnv
argument_list|,
name|proto_perl
operator|->
name|IStdIO
argument_list|,
name|proto_perl
operator|->
name|ILIO
argument_list|,
name|proto_perl
operator|->
name|IDir
argument_list|,
name|proto_perl
operator|->
name|ISock
argument_list|,
name|proto_perl
operator|->
name|IProc
argument_list|)
return|;
block|}
end_function

begin_function
name|PerlInterpreter
modifier|*
name|perl_clone_using
parameter_list|(
name|PerlInterpreter
modifier|*
name|proto_perl
parameter_list|,
name|UV
name|flags
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipM
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMS
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMP
parameter_list|,
name|struct
name|IPerlEnv
modifier|*
name|ipE
parameter_list|,
name|struct
name|IPerlStdIO
modifier|*
name|ipStd
parameter_list|,
name|struct
name|IPerlLIO
modifier|*
name|ipLIO
parameter_list|,
name|struct
name|IPerlDir
modifier|*
name|ipD
parameter_list|,
name|struct
name|IPerlSock
modifier|*
name|ipS
parameter_list|,
name|struct
name|IPerlProc
modifier|*
name|ipP
parameter_list|)
block|{
comment|/* XXX many of the string copies here can be optimized if they're      * constants; they need to be allocated as common memory and just      * their pointers copied. */
name|IV
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|CPerlObj
modifier|*
name|pPerl
init|=
name|new
argument_list|(
argument|ipM
argument_list|)
name|CPerlObj
argument_list|(
name|ipM
argument_list|,
name|ipMS
argument_list|,
name|ipMP
argument_list|,
name|ipE
argument_list|,
name|ipStd
argument_list|,
name|ipLIO
argument_list|,
name|ipD
argument_list|,
name|ipS
argument_list|,
name|ipP
argument_list|)
decl_stmt|;
name|PERL_SET_THX
argument_list|(
name|pPerl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !PERL_OBJECT */
name|PerlInterpreter
modifier|*
name|my_perl
init|=
operator|(
name|PerlInterpreter
operator|*
operator|)
call|(
modifier|*
name|ipM
operator|->
name|pMalloc
call|)
argument_list|(
name|ipM
argument_list|,
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
decl_stmt|;
name|PERL_SET_THX
argument_list|(
name|my_perl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|memset
argument_list|(
name|my_perl
argument_list|,
literal|0xab
argument_list|,
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|PL_markstack
operator|=
literal|0
expr_stmt|;
name|PL_scopestack
operator|=
literal|0
expr_stmt|;
name|PL_savestack
operator|=
literal|0
expr_stmt|;
name|PL_retstack
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* !DEBUGGING */
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
comment|/* host pointers */
name|PL_Mem
operator|=
name|ipM
expr_stmt|;
name|PL_MemShared
operator|=
name|ipMS
expr_stmt|;
name|PL_MemParse
operator|=
name|ipMP
expr_stmt|;
name|PL_Env
operator|=
name|ipE
expr_stmt|;
name|PL_StdIO
operator|=
name|ipStd
expr_stmt|;
name|PL_LIO
operator|=
name|ipLIO
expr_stmt|;
name|PL_Dir
operator|=
name|ipD
expr_stmt|;
name|PL_Sock
operator|=
name|ipS
expr_stmt|;
name|PL_Proc
operator|=
name|ipP
expr_stmt|;
endif|#
directive|endif
comment|/* PERL_OBJECT */
else|#
directive|else
comment|/* !PERL_IMPLICIT_SYS */
name|IV
name|i
decl_stmt|;
name|PerlInterpreter
modifier|*
name|my_perl
init|=
operator|(
name|PerlInterpreter
operator|*
operator|)
name|PerlMem_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
decl_stmt|;
name|PERL_SET_THX
argument_list|(
name|my_perl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|memset
argument_list|(
name|my_perl
argument_list|,
literal|0xab
argument_list|,
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|PL_markstack
operator|=
literal|0
expr_stmt|;
name|PL_scopestack
operator|=
literal|0
expr_stmt|;
name|PL_savestack
operator|=
literal|0
expr_stmt|;
name|PL_retstack
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* !DEBUGGING */
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
endif|#
directive|endif
comment|/* PERL_IMPLICIT_SYS */
comment|/* arena roots */
name|PL_xiv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xiv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xnv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xnv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xrv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xrv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpviv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpviv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvnv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvnv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvcv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvcv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvav_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvav_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvhv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvhv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvmg_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvmg_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvlv_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvlv_root
operator|=
name|NULL
expr_stmt|;
name|PL_xpvbm_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_xpvbm_root
operator|=
name|NULL
expr_stmt|;
name|PL_he_arenaroot
operator|=
name|NULL
expr_stmt|;
name|PL_he_root
operator|=
name|NULL
expr_stmt|;
name|PL_nice_chunk
operator|=
name|NULL
expr_stmt|;
name|PL_nice_chunk_size
operator|=
literal|0
expr_stmt|;
name|PL_sv_count
operator|=
literal|0
expr_stmt|;
name|PL_sv_objcount
operator|=
literal|0
expr_stmt|;
name|PL_sv_root
operator|=
name|Nullsv
expr_stmt|;
name|PL_sv_arenaroot
operator|=
name|Nullsv
expr_stmt|;
name|PL_debug
operator|=
name|proto_perl
operator|->
name|Idebug
expr_stmt|;
comment|/* create SV map for pointer relocation */
name|PL_ptr_table
operator|=
name|ptr_table_new
argument_list|()
expr_stmt|;
comment|/* initialize these special pointers as early as possible */
name|SvANY
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
name|SVf_READONLY
operator||
name|SVt_NULL
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
operator|&
name|proto_perl
operator|->
name|Isv_undef
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|SvUPGRADE
argument_list|(
operator|&
name|PL_sv_no
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|#
directive|else
name|SvANY
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
name|new_XPVNV
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
name|SVp_NOK
operator||
name|SVf_NOK
operator||
name|SVp_POK
operator||
name|SVf_POK
operator||
name|SVf_READONLY
operator||
name|SVt_PVNV
expr_stmt|;
name|SvPVX
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|PL_No
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvLEN
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvNVX
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
operator|&
name|proto_perl
operator|->
name|Isv_no
argument_list|,
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|SvUPGRADE
argument_list|(
operator|&
name|PL_sv_yes
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|#
directive|else
name|SvANY
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
name|new_XPVNV
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
name|SVp_NOK
operator||
name|SVf_NOK
operator||
name|SVp_POK
operator||
name|SVf_POK
operator||
name|SVf_READONLY
operator||
name|SVt_PVNV
expr_stmt|;
name|SvPVX
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
name|SAVEPVN
argument_list|(
name|PL_Yes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvLEN
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|2
expr_stmt|;
name|SvNVX
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
operator|&
name|proto_perl
operator|->
name|Isv_yes
argument_list|,
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
comment|/* create shared string table */
name|PL_strtab
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|HvSHAREKEYS_off
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
name|hv_ksplit
argument_list|(
name|PL_strtab
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|proto_perl
operator|->
name|Istrtab
argument_list|,
name|PL_strtab
argument_list|)
expr_stmt|;
name|PL_compiling
operator|=
name|proto_perl
operator|->
name|Icompiling
expr_stmt|;
name|PL_compiling
operator|.
name|cop_stashpv
operator|=
name|SAVEPV
argument_list|(
name|PL_compiling
operator|.
name|cop_stashpv
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_file
operator|=
name|SAVEPV
argument_list|(
name|PL_compiling
operator|.
name|cop_file
argument_list|)
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
operator|&
name|proto_perl
operator|->
name|Icompiling
argument_list|,
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|specialWARN
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
condition|)
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|sv_dup_inc
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|(
name|COP
operator|*
operator|)
name|any_dup
argument_list|(
name|proto_perl
operator|->
name|Tcurcop
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
comment|/* pseudo environmental stuff */
name|PL_origargc
operator|=
name|proto_perl
operator|->
name|Iorigargc
expr_stmt|;
name|i
operator|=
name|PL_origargc
expr_stmt|;
name|New
argument_list|(
literal|0
argument_list|,
name|PL_origargv
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|PL_origargv
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|PL_origargv
index|[
name|i
index|]
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Iorigargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|PL_envgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Ienvgv
argument_list|)
expr_stmt|;
name|PL_incgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Iincgv
argument_list|)
expr_stmt|;
name|PL_hintgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Ihintgv
argument_list|)
expr_stmt|;
name|PL_origfilename
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Iorigfilename
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Idiehook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iwarnhook
argument_list|)
expr_stmt|;
comment|/* switches */
name|PL_minus_c
operator|=
name|proto_perl
operator|->
name|Iminus_c
expr_stmt|;
name|PL_patchlevel
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ipatchlevel
argument_list|)
expr_stmt|;
name|PL_localpatches
operator|=
name|proto_perl
operator|->
name|Ilocalpatches
expr_stmt|;
name|PL_splitstr
operator|=
name|proto_perl
operator|->
name|Isplitstr
expr_stmt|;
name|PL_preprocess
operator|=
name|proto_perl
operator|->
name|Ipreprocess
expr_stmt|;
name|PL_minus_n
operator|=
name|proto_perl
operator|->
name|Iminus_n
expr_stmt|;
name|PL_minus_p
operator|=
name|proto_perl
operator|->
name|Iminus_p
expr_stmt|;
name|PL_minus_l
operator|=
name|proto_perl
operator|->
name|Iminus_l
expr_stmt|;
name|PL_minus_a
operator|=
name|proto_perl
operator|->
name|Iminus_a
expr_stmt|;
name|PL_minus_F
operator|=
name|proto_perl
operator|->
name|Iminus_F
expr_stmt|;
name|PL_doswitches
operator|=
name|proto_perl
operator|->
name|Idoswitches
expr_stmt|;
name|PL_dowarn
operator|=
name|proto_perl
operator|->
name|Idowarn
expr_stmt|;
name|PL_doextract
operator|=
name|proto_perl
operator|->
name|Idoextract
expr_stmt|;
name|PL_sawampersand
operator|=
name|proto_perl
operator|->
name|Isawampersand
expr_stmt|;
name|PL_unsafe
operator|=
name|proto_perl
operator|->
name|Iunsafe
expr_stmt|;
name|PL_inplace
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Iinplace
argument_list|)
expr_stmt|;
name|PL_e_script
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ie_script
argument_list|)
expr_stmt|;
name|PL_perldb
operator|=
name|proto_perl
operator|->
name|Iperldb
expr_stmt|;
name|PL_perl_destruct_level
operator|=
name|proto_perl
operator|->
name|Iperl_destruct_level
expr_stmt|;
comment|/* magical thingies */
comment|/* XXX time(&PL_basetime) when asked for? */
name|PL_basetime
operator|=
name|proto_perl
operator|->
name|Ibasetime
expr_stmt|;
name|PL_formfeed
operator|=
name|sv_dup
argument_list|(
name|proto_perl
operator|->
name|Iformfeed
argument_list|)
expr_stmt|;
name|PL_maxsysfd
operator|=
name|proto_perl
operator|->
name|Imaxsysfd
expr_stmt|;
name|PL_multiline
operator|=
name|proto_perl
operator|->
name|Imultiline
expr_stmt|;
name|PL_statusvalue
operator|=
name|proto_perl
operator|->
name|Istatusvalue
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|PL_statusvalue_vms
operator|=
name|proto_perl
operator|->
name|Istatusvalue_vms
expr_stmt|;
endif|#
directive|endif
comment|/* shortcuts to various I/O objects */
name|PL_stdingv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Istdingv
argument_list|)
expr_stmt|;
name|PL_stderrgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Istderrgv
argument_list|)
expr_stmt|;
name|PL_defgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Idefgv
argument_list|)
expr_stmt|;
name|PL_argvgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Iargvgv
argument_list|)
expr_stmt|;
name|PL_argvoutgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Iargvoutgv
argument_list|)
expr_stmt|;
name|PL_argvout_stack
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iargvout_stack
argument_list|)
expr_stmt|;
comment|/* shortcuts to regexp stuff */
name|PL_replgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Ireplgv
argument_list|)
expr_stmt|;
comment|/* shortcuts to misc objects */
name|PL_errgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Ierrgv
argument_list|)
expr_stmt|;
comment|/* shortcuts to debugging objects */
name|PL_DBgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBgv
argument_list|)
expr_stmt|;
name|PL_DBline
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBline
argument_list|)
expr_stmt|;
name|PL_DBsub
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBsub
argument_list|)
expr_stmt|;
name|PL_DBsingle
operator|=
name|sv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBsingle
argument_list|)
expr_stmt|;
name|PL_DBtrace
operator|=
name|sv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBtrace
argument_list|)
expr_stmt|;
name|PL_DBsignal
operator|=
name|sv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBsignal
argument_list|)
expr_stmt|;
name|PL_lineary
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Ilineary
argument_list|)
expr_stmt|;
name|PL_dbargs
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Idbargs
argument_list|)
expr_stmt|;
comment|/* symbol tables */
name|PL_defstash
operator|=
name|hv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Tdefstash
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|hv_dup
argument_list|(
name|proto_perl
operator|->
name|Tcurstash
argument_list|)
expr_stmt|;
name|PL_debstash
operator|=
name|hv_dup
argument_list|(
name|proto_perl
operator|->
name|Idebstash
argument_list|)
expr_stmt|;
name|PL_globalstash
operator|=
name|hv_dup
argument_list|(
name|proto_perl
operator|->
name|Iglobalstash
argument_list|)
expr_stmt|;
name|PL_curstname
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Icurstname
argument_list|)
expr_stmt|;
name|PL_beginav
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ibeginav
argument_list|)
expr_stmt|;
name|PL_endav
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iendav
argument_list|)
expr_stmt|;
name|PL_checkav
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Icheckav
argument_list|)
expr_stmt|;
name|PL_initav
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iinitav
argument_list|)
expr_stmt|;
name|PL_sub_generation
operator|=
name|proto_perl
operator|->
name|Isub_generation
expr_stmt|;
comment|/* funky return mechanisms */
name|PL_forkprocess
operator|=
name|proto_perl
operator|->
name|Iforkprocess
expr_stmt|;
comment|/* subprocess state */
name|PL_fdpid
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ifdpid
argument_list|)
expr_stmt|;
comment|/* internal state */
name|PL_tainting
operator|=
name|proto_perl
operator|->
name|Itainting
expr_stmt|;
name|PL_maxo
operator|=
name|proto_perl
operator|->
name|Imaxo
expr_stmt|;
if|if
condition|(
name|proto_perl
operator|->
name|Iop_mask
condition|)
name|PL_op_mask
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Iop_mask
argument_list|,
name|PL_maxo
argument_list|)
expr_stmt|;
else|else
name|PL_op_mask
operator|=
name|Nullch
expr_stmt|;
comment|/* current interpreter roots */
name|PL_main_cv
operator|=
name|cv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Imain_cv
argument_list|)
expr_stmt|;
name|PL_main_root
operator|=
name|OpREFCNT_inc
argument_list|(
name|proto_perl
operator|->
name|Imain_root
argument_list|)
expr_stmt|;
name|PL_main_start
operator|=
name|proto_perl
operator|->
name|Imain_start
expr_stmt|;
name|PL_eval_root
operator|=
name|proto_perl
operator|->
name|Ieval_root
expr_stmt|;
name|PL_eval_start
operator|=
name|proto_perl
operator|->
name|Ieval_start
expr_stmt|;
comment|/* runtime control stuff */
name|PL_curcopdb
operator|=
operator|(
name|COP
operator|*
operator|)
name|any_dup
argument_list|(
name|proto_perl
operator|->
name|Icurcopdb
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|proto_perl
operator|->
name|Icopline
expr_stmt|;
name|PL_filemode
operator|=
name|proto_perl
operator|->
name|Ifilemode
expr_stmt|;
name|PL_lastfd
operator|=
name|proto_perl
operator|->
name|Ilastfd
expr_stmt|;
name|PL_oldname
operator|=
name|proto_perl
operator|->
name|Ioldname
expr_stmt|;
comment|/* XXX not quite right */
name|PL_Argv
operator|=
name|NULL
expr_stmt|;
name|PL_Cmd
operator|=
name|Nullch
expr_stmt|;
name|PL_gensym
operator|=
name|proto_perl
operator|->
name|Igensym
expr_stmt|;
name|PL_preambled
operator|=
name|proto_perl
operator|->
name|Ipreambled
expr_stmt|;
name|PL_preambleav
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ipreambleav
argument_list|)
expr_stmt|;
name|PL_laststatval
operator|=
name|proto_perl
operator|->
name|Ilaststatval
expr_stmt|;
name|PL_laststype
operator|=
name|proto_perl
operator|->
name|Ilaststype
expr_stmt|;
name|PL_mess_sv
operator|=
name|Nullsv
expr_stmt|;
name|PL_orslen
operator|=
name|proto_perl
operator|->
name|Iorslen
expr_stmt|;
name|PL_ors
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Iors
argument_list|,
name|PL_orslen
argument_list|)
expr_stmt|;
name|PL_ofmt
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Iofmt
argument_list|)
expr_stmt|;
comment|/* interpreter atexit processing */
name|PL_exitlistlen
operator|=
name|proto_perl
operator|->
name|Iexitlistlen
expr_stmt|;
if|if
condition|(
name|PL_exitlistlen
condition|)
block|{
name|New
argument_list|(
literal|0
argument_list|,
name|PL_exitlist
argument_list|,
name|PL_exitlistlen
argument_list|,
name|PerlExitListEntry
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Iexitlist
argument_list|,
name|PL_exitlist
argument_list|,
name|PL_exitlistlen
argument_list|,
name|PerlExitListEntry
argument_list|)
expr_stmt|;
block|}
else|else
name|PL_exitlist
operator|=
operator|(
name|PerlExitListEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_modglobal
operator|=
name|hv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Imodglobal
argument_list|)
expr_stmt|;
name|PL_profiledata
operator|=
name|NULL
expr_stmt|;
name|PL_rsfp
operator|=
name|fp_dup
argument_list|(
name|proto_perl
operator|->
name|Irsfp
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
comment|/* PL_rsfp_filters entries have fake IoDIRP() */
name|PL_rsfp_filters
operator|=
name|av_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Irsfp_filters
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
name|cv_dup
argument_list|(
name|proto_perl
operator|->
name|Icompcv
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Icomppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Icomppad_name
argument_list|)
expr_stmt|;
name|PL_comppad_name_fill
operator|=
name|proto_perl
operator|->
name|Icomppad_name_fill
expr_stmt|;
name|PL_comppad_name_floor
operator|=
name|proto_perl
operator|->
name|Icomppad_name_floor
expr_stmt|;
name|PL_curpad
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|proto_perl
operator|->
name|Tcurpad
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INTERP_INTERN
name|sys_intern_dup
argument_list|(
operator|&
name|proto_perl
operator|->
name|Isys_intern
argument_list|,
operator|&
name|PL_sys_intern
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* more statics moved here */
name|PL_generation
operator|=
name|proto_perl
operator|->
name|Igeneration
expr_stmt|;
name|PL_DBcv
operator|=
name|cv_dup
argument_list|(
name|proto_perl
operator|->
name|IDBcv
argument_list|)
expr_stmt|;
name|PL_in_clean_objs
operator|=
name|proto_perl
operator|->
name|Iin_clean_objs
expr_stmt|;
name|PL_in_clean_all
operator|=
name|proto_perl
operator|->
name|Iin_clean_all
expr_stmt|;
name|PL_uid
operator|=
name|proto_perl
operator|->
name|Iuid
expr_stmt|;
name|PL_euid
operator|=
name|proto_perl
operator|->
name|Ieuid
expr_stmt|;
name|PL_gid
operator|=
name|proto_perl
operator|->
name|Igid
expr_stmt|;
name|PL_egid
operator|=
name|proto_perl
operator|->
name|Iegid
expr_stmt|;
name|PL_nomemok
operator|=
name|proto_perl
operator|->
name|Inomemok
expr_stmt|;
name|PL_an
operator|=
name|proto_perl
operator|->
name|Ian
expr_stmt|;
name|PL_cop_seqmax
operator|=
name|proto_perl
operator|->
name|Icop_seqmax
expr_stmt|;
name|PL_op_seqmax
operator|=
name|proto_perl
operator|->
name|Iop_seqmax
expr_stmt|;
name|PL_evalseq
operator|=
name|proto_perl
operator|->
name|Ievalseq
expr_stmt|;
name|PL_origenviron
operator|=
name|proto_perl
operator|->
name|Iorigenviron
expr_stmt|;
comment|/* XXX not quite right */
name|PL_origalen
operator|=
name|proto_perl
operator|->
name|Iorigalen
expr_stmt|;
name|PL_pidstatus
operator|=
name|newHV
argument_list|()
expr_stmt|;
comment|/* XXX flag for cloning? */
name|PL_osname
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Iosname
argument_list|)
expr_stmt|;
name|PL_sh_path
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Ish_path
argument_list|)
expr_stmt|;
name|PL_sighandlerp
operator|=
name|proto_perl
operator|->
name|Isighandlerp
expr_stmt|;
name|PL_runops
operator|=
name|proto_perl
operator|->
name|Irunops
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Itokenbuf
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CSH
name|PL_cshlen
operator|=
name|proto_perl
operator|->
name|Icshlen
expr_stmt|;
name|PL_cshname
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Icshname
argument_list|,
name|PL_cshlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_lex_state
operator|=
name|proto_perl
operator|->
name|Ilex_state
expr_stmt|;
name|PL_lex_defer
operator|=
name|proto_perl
operator|->
name|Ilex_defer
expr_stmt|;
name|PL_lex_expect
operator|=
name|proto_perl
operator|->
name|Ilex_expect
expr_stmt|;
name|PL_lex_formbrack
operator|=
name|proto_perl
operator|->
name|Ilex_formbrack
expr_stmt|;
name|PL_lex_dojoin
operator|=
name|proto_perl
operator|->
name|Ilex_dojoin
expr_stmt|;
name|PL_lex_starts
operator|=
name|proto_perl
operator|->
name|Ilex_starts
expr_stmt|;
name|PL_lex_stuff
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ilex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ilex_repl
argument_list|)
expr_stmt|;
name|PL_lex_op
operator|=
name|proto_perl
operator|->
name|Ilex_op
expr_stmt|;
name|PL_lex_inpat
operator|=
name|proto_perl
operator|->
name|Ilex_inpat
expr_stmt|;
name|PL_lex_inwhat
operator|=
name|proto_perl
operator|->
name|Ilex_inwhat
expr_stmt|;
name|PL_lex_brackets
operator|=
name|proto_perl
operator|->
name|Ilex_brackets
expr_stmt|;
name|i
operator|=
operator|(
name|PL_lex_brackets
operator|<
literal|120
condition|?
literal|120
else|:
name|PL_lex_brackets
operator|)
expr_stmt|;
name|PL_lex_brackstack
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Ilex_brackstack
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PL_lex_casemods
operator|=
name|proto_perl
operator|->
name|Ilex_casemods
expr_stmt|;
name|i
operator|=
operator|(
name|PL_lex_casemods
operator|<
literal|12
condition|?
literal|12
else|:
name|PL_lex_casemods
operator|)
expr_stmt|;
name|PL_lex_casestack
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Ilex_casestack
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Inextval
argument_list|,
name|PL_nextval
argument_list|,
literal|5
argument_list|,
name|YYSTYPE
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Inexttype
argument_list|,
name|PL_nexttype
argument_list|,
literal|5
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|PL_nexttoke
operator|=
name|proto_perl
operator|->
name|Inexttoke
expr_stmt|;
name|PL_linestr
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ibufptr
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ioldbufptr
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_oldbufptr
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ioldoldbufptr
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ilinestart
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|PL_pending_ident
operator|=
name|proto_perl
operator|->
name|Ipending_ident
expr_stmt|;
name|PL_sublex_info
operator|=
name|proto_perl
operator|->
name|Isublex_info
expr_stmt|;
comment|/* XXX not quite right */
name|PL_expect
operator|=
name|proto_perl
operator|->
name|Iexpect
expr_stmt|;
name|PL_multi_start
operator|=
name|proto_perl
operator|->
name|Imulti_start
expr_stmt|;
name|PL_multi_end
operator|=
name|proto_perl
operator|->
name|Imulti_end
expr_stmt|;
name|PL_multi_open
operator|=
name|proto_perl
operator|->
name|Imulti_open
expr_stmt|;
name|PL_multi_close
operator|=
name|proto_perl
operator|->
name|Imulti_close
expr_stmt|;
name|PL_error_count
operator|=
name|proto_perl
operator|->
name|Ierror_count
expr_stmt|;
name|PL_subline
operator|=
name|proto_perl
operator|->
name|Isubline
expr_stmt|;
name|PL_subname
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Isubname
argument_list|)
expr_stmt|;
name|PL_min_intro_pending
operator|=
name|proto_perl
operator|->
name|Imin_intro_pending
expr_stmt|;
name|PL_max_intro_pending
operator|=
name|proto_perl
operator|->
name|Imax_intro_pending
expr_stmt|;
name|PL_padix
operator|=
name|proto_perl
operator|->
name|Ipadix
expr_stmt|;
name|PL_padix_floor
operator|=
name|proto_perl
operator|->
name|Ipadix_floor
expr_stmt|;
name|PL_pad_reset_pending
operator|=
name|proto_perl
operator|->
name|Ipad_reset_pending
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ilast_uni
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_last_uni
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|i
operator|=
name|proto_perl
operator|->
name|Ilast_lop
operator|-
name|SvPVX
argument_list|(
name|proto_perl
operator|->
name|Ilinestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
operator|(
name|i
operator|<
literal|0
condition|?
literal|0
else|:
name|i
operator|)
expr_stmt|;
name|PL_last_lop_op
operator|=
name|proto_perl
operator|->
name|Ilast_lop_op
expr_stmt|;
name|PL_in_my
operator|=
name|proto_perl
operator|->
name|Iin_my
expr_stmt|;
name|PL_in_my_stash
operator|=
name|hv_dup
argument_list|(
name|proto_perl
operator|->
name|Iin_my_stash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FCRYPT
name|PL_cryptseen
operator|=
name|proto_perl
operator|->
name|Icryptseen
expr_stmt|;
endif|#
directive|endif
name|PL_hints
operator|=
name|proto_perl
operator|->
name|Ihints
expr_stmt|;
name|PL_amagic_generation
operator|=
name|proto_perl
operator|->
name|Iamagic_generation
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|PL_collation_ix
operator|=
name|proto_perl
operator|->
name|Icollation_ix
expr_stmt|;
name|PL_collation_name
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Icollation_name
argument_list|)
expr_stmt|;
name|PL_collation_standard
operator|=
name|proto_perl
operator|->
name|Icollation_standard
expr_stmt|;
name|PL_collxfrm_base
operator|=
name|proto_perl
operator|->
name|Icollxfrm_base
expr_stmt|;
name|PL_collxfrm_mult
operator|=
name|proto_perl
operator|->
name|Icollxfrm_mult
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|PL_numeric_name
operator|=
name|SAVEPV
argument_list|(
name|proto_perl
operator|->
name|Inumeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
name|proto_perl
operator|->
name|Inumeric_standard
expr_stmt|;
name|PL_numeric_local
operator|=
name|proto_perl
operator|->
name|Inumeric_local
expr_stmt|;
name|PL_numeric_radix_sv
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Inumeric_radix_sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !USE_LOCALE_NUMERIC */
comment|/* utf8 character classes */
name|PL_utf8_alnum
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_alnum
argument_list|)
expr_stmt|;
name|PL_utf8_alnumc
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_alnumc
argument_list|)
expr_stmt|;
name|PL_utf8_ascii
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_ascii
argument_list|)
expr_stmt|;
name|PL_utf8_alpha
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_alpha
argument_list|)
expr_stmt|;
name|PL_utf8_space
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_space
argument_list|)
expr_stmt|;
name|PL_utf8_cntrl
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_cntrl
argument_list|)
expr_stmt|;
name|PL_utf8_graph
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_graph
argument_list|)
expr_stmt|;
name|PL_utf8_digit
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_digit
argument_list|)
expr_stmt|;
name|PL_utf8_upper
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_upper
argument_list|)
expr_stmt|;
name|PL_utf8_lower
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_lower
argument_list|)
expr_stmt|;
name|PL_utf8_print
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_print
argument_list|)
expr_stmt|;
name|PL_utf8_punct
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_punct
argument_list|)
expr_stmt|;
name|PL_utf8_xdigit
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_xdigit
argument_list|)
expr_stmt|;
name|PL_utf8_mark
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_mark
argument_list|)
expr_stmt|;
name|PL_utf8_toupper
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_toupper
argument_list|)
expr_stmt|;
name|PL_utf8_totitle
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_totitle
argument_list|)
expr_stmt|;
name|PL_utf8_tolower
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Iutf8_tolower
argument_list|)
expr_stmt|;
comment|/* swatch cache */
name|PL_last_swash_hv
operator|=
name|Nullhv
expr_stmt|;
comment|/* reinits on demand */
name|PL_last_swash_klen
operator|=
literal|0
expr_stmt|;
name|PL_last_swash_key
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PL_last_swash_tmps
operator|=
operator|(
name|U8
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_last_swash_slen
operator|=
literal|0
expr_stmt|;
comment|/* perly.c globals */
name|PL_yydebug
operator|=
name|proto_perl
operator|->
name|Iyydebug
expr_stmt|;
name|PL_yynerrs
operator|=
name|proto_perl
operator|->
name|Iyynerrs
expr_stmt|;
name|PL_yyerrflag
operator|=
name|proto_perl
operator|->
name|Iyyerrflag
expr_stmt|;
name|PL_yychar
operator|=
name|proto_perl
operator|->
name|Iyychar
expr_stmt|;
name|PL_yyval
operator|=
name|proto_perl
operator|->
name|Iyyval
expr_stmt|;
name|PL_yylval
operator|=
name|proto_perl
operator|->
name|Iyylval
expr_stmt|;
name|PL_glob_index
operator|=
name|proto_perl
operator|->
name|Iglob_index
expr_stmt|;
name|PL_srand_called
operator|=
name|proto_perl
operator|->
name|Isrand_called
expr_stmt|;
name|PL_uudmap
index|[
literal|'M'
index|]
operator|=
literal|0
expr_stmt|;
comment|/* reinits on demand */
name|PL_bitcount
operator|=
name|Nullch
expr_stmt|;
comment|/* reinits on demand */
if|if
condition|(
name|proto_perl
operator|->
name|Ipsig_ptr
condition|)
block|{
name|int
name|sig_num
index|[]
init|=
block|{
name|SIG_NUM
block|}
decl_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|PL_psig_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sig_num
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sig_num
argument_list|)
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|0
argument_list|,
name|PL_psig_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sig_num
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sig_num
argument_list|)
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|PL_sig_name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|PL_psig_ptr
index|[
name|i
index|]
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ipsig_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PL_psig_name
index|[
name|i
index|]
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ipsig_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PL_psig_ptr
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_psig_name
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* thrdvar.h stuff */
if|if
condition|(
name|flags
operator|&
name|CLONEf_COPY_STACKS
condition|)
block|{
comment|/* next allocation will be PL_tmps_stack[PL_tmps_ix+1] */
name|PL_tmps_ix
operator|=
name|proto_perl
operator|->
name|Ttmps_ix
expr_stmt|;
name|PL_tmps_max
operator|=
name|proto_perl
operator|->
name|Ttmps_max
expr_stmt|;
name|PL_tmps_floor
operator|=
name|proto_perl
operator|->
name|Ttmps_floor
expr_stmt|;
name|Newz
argument_list|(
literal|50
argument_list|,
name|PL_tmps_stack
argument_list|,
name|PL_tmps_max
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|PL_tmps_ix
condition|)
block|{
name|PL_tmps_stack
index|[
name|i
index|]
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ttmps_stack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* next PUSHMARK() sets *(PL_markstack_ptr+1) */
name|i
operator|=
name|proto_perl
operator|->
name|Tmarkstack_max
operator|-
name|proto_perl
operator|->
name|Tmarkstack
expr_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|PL_markstack
argument_list|,
name|i
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|PL_markstack_max
operator|=
name|PL_markstack
operator|+
operator|(
name|proto_perl
operator|->
name|Tmarkstack_max
operator|-
name|proto_perl
operator|->
name|Tmarkstack
operator|)
expr_stmt|;
name|PL_markstack_ptr
operator|=
name|PL_markstack
operator|+
operator|(
name|proto_perl
operator|->
name|Tmarkstack_ptr
operator|-
name|proto_perl
operator|->
name|Tmarkstack
operator|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Tmarkstack
argument_list|,
name|PL_markstack
argument_list|,
name|PL_markstack_ptr
operator|-
name|PL_markstack
operator|+
literal|1
argument_list|,
name|I32
argument_list|)
expr_stmt|;
comment|/* next push_scope()/ENTER sets PL_scopestack[PL_scopestack_ix] 	 * NOTE: unlike the others! */
name|PL_scopestack_ix
operator|=
name|proto_perl
operator|->
name|Tscopestack_ix
expr_stmt|;
name|PL_scopestack_max
operator|=
name|proto_perl
operator|->
name|Tscopestack_max
expr_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|PL_scopestack
argument_list|,
name|PL_scopestack_max
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Tscopestack
argument_list|,
name|PL_scopestack
argument_list|,
name|PL_scopestack_ix
argument_list|,
name|I32
argument_list|)
expr_stmt|;
comment|/* next push_return() sets PL_retstack[PL_retstack_ix] 	 * NOTE: unlike the others! */
name|PL_retstack_ix
operator|=
name|proto_perl
operator|->
name|Tretstack_ix
expr_stmt|;
name|PL_retstack_max
operator|=
name|proto_perl
operator|->
name|Tretstack_max
expr_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|PL_retstack
argument_list|,
name|PL_retstack_max
argument_list|,
name|OP
operator|*
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|proto_perl
operator|->
name|Tretstack
argument_list|,
name|PL_retstack
argument_list|,
name|PL_retstack_ix
argument_list|,
name|I32
argument_list|)
expr_stmt|;
comment|/* NOTE: si_dup() looks at PL_markstack */
name|PL_curstackinfo
operator|=
name|si_dup
argument_list|(
name|proto_perl
operator|->
name|Tcurstackinfo
argument_list|)
expr_stmt|;
comment|/* PL_curstack		= PL_curstackinfo->si_stack; */
name|PL_curstack
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Tcurstack
argument_list|)
expr_stmt|;
name|PL_mainstack
operator|=
name|av_dup
argument_list|(
name|proto_perl
operator|->
name|Tmainstack
argument_list|)
expr_stmt|;
comment|/* next PUSHs() etc. set *(PL_stack_sp+1) */
name|PL_stack_base
operator|=
name|AvARRAY
argument_list|(
name|PL_curstack
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
operator|(
name|proto_perl
operator|->
name|Tstack_sp
operator|-
name|proto_perl
operator|->
name|Tstack_base
operator|)
expr_stmt|;
name|PL_stack_max
operator|=
name|PL_stack_base
operator|+
name|AvMAX
argument_list|(
name|PL_curstack
argument_list|)
expr_stmt|;
comment|/* next SSPUSHFOO() sets PL_savestack[PL_savestack_ix] 	 * NOTE: unlike the others! */
name|PL_savestack_ix
operator|=
name|proto_perl
operator|->
name|Tsavestack_ix
expr_stmt|;
name|PL_savestack_max
operator|=
name|proto_perl
operator|->
name|Tsavestack_max
expr_stmt|;
comment|/*Newz(54, PL_savestack, PL_savestack_max, ANY);*/
name|PL_savestack
operator|=
name|ss_dup
argument_list|(
name|proto_perl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_stacks
argument_list|()
expr_stmt|;
name|ENTER
expr_stmt|;
comment|/* perl_destruct() wants to LEAVE; */
block|}
name|PL_start_env
operator|=
name|proto_perl
operator|->
name|Tstart_env
expr_stmt|;
comment|/* XXXXXX */
name|PL_top_env
operator|=
operator|&
name|PL_start_env
expr_stmt|;
name|PL_op
operator|=
name|proto_perl
operator|->
name|Top
expr_stmt|;
name|PL_Sv
operator|=
name|Nullsv
expr_stmt|;
name|PL_Xpv
operator|=
operator|(
name|XPV
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_na
operator|=
name|proto_perl
operator|->
name|Tna
expr_stmt|;
name|PL_statbuf
operator|=
name|proto_perl
operator|->
name|Tstatbuf
expr_stmt|;
name|PL_statcache
operator|=
name|proto_perl
operator|->
name|Tstatcache
expr_stmt|;
name|PL_statgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Tstatgv
argument_list|)
expr_stmt|;
name|PL_statname
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Tstatname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TIMES
name|PL_timesbuf
operator|=
name|proto_perl
operator|->
name|Ttimesbuf
expr_stmt|;
endif|#
directive|endif
name|PL_tainted
operator|=
name|proto_perl
operator|->
name|Ttainted
expr_stmt|;
name|PL_curpm
operator|=
name|proto_perl
operator|->
name|Tcurpm
expr_stmt|;
comment|/* XXX No PMOP ref count */
name|PL_nrs
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Tnrs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Trs
argument_list|)
expr_stmt|;
name|PL_last_in_gv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Tlast_in_gv
argument_list|)
expr_stmt|;
name|PL_ofslen
operator|=
name|proto_perl
operator|->
name|Tofslen
expr_stmt|;
name|PL_ofs
operator|=
name|SAVEPVN
argument_list|(
name|proto_perl
operator|->
name|Tofs
argument_list|,
name|PL_ofslen
argument_list|)
expr_stmt|;
name|PL_defoutgv
operator|=
name|gv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Tdefoutgv
argument_list|)
expr_stmt|;
name|PL_chopset
operator|=
name|proto_perl
operator|->
name|Tchopset
expr_stmt|;
comment|/* XXX never deallocated */
name|PL_toptarget
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Ttoptarget
argument_list|)
expr_stmt|;
name|PL_bodytarget
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Tbodytarget
argument_list|)
expr_stmt|;
name|PL_formtarget
operator|=
name|sv_dup
argument_list|(
name|proto_perl
operator|->
name|Tformtarget
argument_list|)
expr_stmt|;
name|PL_restartop
operator|=
name|proto_perl
operator|->
name|Trestartop
expr_stmt|;
name|PL_in_eval
operator|=
name|proto_perl
operator|->
name|Tin_eval
expr_stmt|;
name|PL_delaymagic
operator|=
name|proto_perl
operator|->
name|Tdelaymagic
expr_stmt|;
name|PL_dirty
operator|=
name|proto_perl
operator|->
name|Tdirty
expr_stmt|;
name|PL_localizing
operator|=
name|proto_perl
operator|->
name|Tlocalizing
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|PL_protect
operator|=
name|proto_perl
operator|->
name|Tprotect
expr_stmt|;
endif|#
directive|endif
name|PL_errors
operator|=
name|sv_dup_inc
argument_list|(
name|proto_perl
operator|->
name|Terrors
argument_list|)
expr_stmt|;
name|PL_av_fetch_sv
operator|=
name|Nullsv
expr_stmt|;
name|PL_hv_fetch_sv
operator|=
name|Nullsv
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|,
literal|1
argument_list|,
name|HE
argument_list|)
expr_stmt|;
comment|/* XXX */
name|PL_modcount
operator|=
name|proto_perl
operator|->
name|Tmodcount
expr_stmt|;
name|PL_lastgotoprobe
operator|=
name|Nullop
expr_stmt|;
name|PL_dumpindent
operator|=
name|proto_perl
operator|->
name|Tdumpindent
expr_stmt|;
name|PL_sortcop
operator|=
operator|(
name|OP
operator|*
operator|)
name|any_dup
argument_list|(
name|proto_perl
operator|->
name|Tsortcop
argument_list|,
name|proto_perl
argument_list|)
expr_stmt|;
name|PL_sortstash
operator|=
name|hv_dup
argument_list|(
name|proto_perl
operator|->
name|Tsortstash
argument_list|)
expr_stmt|;
name|PL_firstgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Tfirstgv
argument_list|)
expr_stmt|;
name|PL_secondgv
operator|=
name|gv_dup
argument_list|(
name|proto_perl
operator|->
name|Tsecondgv
argument_list|)
expr_stmt|;
name|PL_sortcxix
operator|=
name|proto_perl
operator|->
name|Tsortcxix
expr_stmt|;
name|PL_efloatbuf
operator|=
name|Nullch
expr_stmt|;
comment|/* reinits on demand */
name|PL_efloatsize
operator|=
literal|0
expr_stmt|;
comment|/* reinits on demand */
comment|/* regex stuff */
name|PL_screamfirst
operator|=
name|NULL
expr_stmt|;
name|PL_screamnext
operator|=
name|NULL
expr_stmt|;
name|PL_maxscream
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reinits on demand */
name|PL_lastscream
operator|=
name|Nullsv
expr_stmt|;
name|PL_watchaddr
operator|=
name|NULL
expr_stmt|;
name|PL_watchok
operator|=
name|Nullch
expr_stmt|;
name|PL_regdummy
operator|=
name|proto_perl
operator|->
name|Tregdummy
expr_stmt|;
name|PL_regcomp_parse
operator|=
name|Nullch
expr_stmt|;
name|PL_regxend
operator|=
name|Nullch
expr_stmt|;
name|PL_regcode
operator|=
operator|(
name|regnode
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_regnaughty
operator|=
literal|0
expr_stmt|;
name|PL_regsawback
operator|=
literal|0
expr_stmt|;
name|PL_regprecomp
operator|=
name|Nullch
expr_stmt|;
name|PL_regnpar
operator|=
literal|0
expr_stmt|;
name|PL_regsize
operator|=
literal|0
expr_stmt|;
name|PL_regflags
operator|=
literal|0
expr_stmt|;
name|PL_regseen
operator|=
literal|0
expr_stmt|;
name|PL_seen_zerolen
operator|=
literal|0
expr_stmt|;
name|PL_seen_evals
operator|=
literal|0
expr_stmt|;
name|PL_regcomp_rx
operator|=
operator|(
name|regexp
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_extralen
operator|=
literal|0
expr_stmt|;
name|PL_colorset
operator|=
literal|0
expr_stmt|;
comment|/* reinits PL_colors[] */
comment|/*PL_colors[6]	= {0,0,0,0,0,0};*/
name|PL_reg_whilem_seen
operator|=
literal|0
expr_stmt|;
name|PL_reginput
operator|=
name|Nullch
expr_stmt|;
name|PL_regbol
operator|=
name|Nullch
expr_stmt|;
name|PL_regeol
operator|=
name|Nullch
expr_stmt|;
name|PL_regstartp
operator|=
operator|(
name|I32
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_regendp
operator|=
operator|(
name|I32
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reglastparen
operator|=
operator|(
name|U32
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_regtill
operator|=
name|Nullch
expr_stmt|;
name|PL_regprev
operator|=
literal|'\n'
expr_stmt|;
name|PL_reg_start_tmp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_start_tmpl
operator|=
literal|0
expr_stmt|;
name|PL_regdata
operator|=
operator|(
expr|struct
name|reg_data
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_bostr
operator|=
name|Nullch
expr_stmt|;
name|PL_reg_flags
operator|=
literal|0
expr_stmt|;
name|PL_reg_eval_set
operator|=
literal|0
expr_stmt|;
name|PL_regnarrate
operator|=
literal|0
expr_stmt|;
name|PL_regprogram
operator|=
operator|(
name|regnode
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_regindent
operator|=
literal|0
expr_stmt|;
name|PL_regcc
operator|=
operator|(
name|CURCUR
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_call_cc
operator|=
operator|(
expr|struct
name|re_cc_state
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_re
operator|=
operator|(
name|regexp
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_ganch
operator|=
name|Nullch
expr_stmt|;
name|PL_reg_sv
operator|=
name|Nullsv
expr_stmt|;
name|PL_reg_magic
operator|=
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_oldpos
operator|=
literal|0
expr_stmt|;
name|PL_reg_oldcurpm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_curpm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_reg_oldsaved
operator|=
name|Nullch
expr_stmt|;
name|PL_reg_oldsavedlen
operator|=
literal|0
expr_stmt|;
name|PL_reg_maxiter
operator|=
literal|0
expr_stmt|;
name|PL_reg_leftiter
operator|=
literal|0
expr_stmt|;
name|PL_reg_poscache
operator|=
name|Nullch
expr_stmt|;
name|PL_reg_poscache_size
operator|=
literal|0
expr_stmt|;
comment|/* RE engine - function pointers */
name|PL_regcompp
operator|=
name|proto_perl
operator|->
name|Tregcompp
expr_stmt|;
name|PL_regexecp
operator|=
name|proto_perl
operator|->
name|Tregexecp
expr_stmt|;
name|PL_regint_start
operator|=
name|proto_perl
operator|->
name|Tregint_start
expr_stmt|;
name|PL_regint_string
operator|=
name|proto_perl
operator|->
name|Tregint_string
expr_stmt|;
name|PL_regfree
operator|=
name|proto_perl
operator|->
name|Tregfree
expr_stmt|;
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
name|PL_reg_starttry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CLONEf_KEEP_PTR_TABLE
operator|)
condition|)
block|{
name|ptr_table_free
argument_list|(
name|PL_ptr_table
argument_list|)
expr_stmt|;
name|PL_ptr_table
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
return|return
operator|(
name|PerlInterpreter
operator|*
operator|)
name|pPerl
return|;
else|#
directive|else
return|return
name|my_perl
return|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_ITHREADS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ITHREADS */
end_comment

begin_function
specifier|static
name|void
name|do_report_used
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVTYPEMASK
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"****\n"
argument_list|)
expr_stmt|;
name|sv_dump
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_clean_objs
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|rv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning object ref:\n "
argument|), sv_dump(sv));
argument_list|)
if|if
condition|(
name|SvWEAKREF
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_del_backref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvWEAKREF_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SvROK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX Might want to check arrays, etc. */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DISABLE_DESTRUCTOR_KLUDGE
end_ifndef

begin_function
specifier|static
name|void
name|do_clean_named_objs
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
operator|&&
name|GvGP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvOBJECT
argument_list|(
name|GvSV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|||
operator|(
name|GvAV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvAV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GvHV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvHV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GvIO
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvIO
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GvCV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvCV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning named glob object:\n "
argument|), sv_dump(sv));
argument_list|)
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|do_clean_all
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning loops: SV at 0x%"
argument|UVxf
literal|"\n"
argument|, PTR2UV(sv)) );
argument_list|)
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVf_BREAK
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

