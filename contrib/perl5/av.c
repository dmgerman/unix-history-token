begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    av.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "...for the Entwives desired order, and plenty, and peace (by which they  * meant that things should remain where they had set them)." --Treebeard  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_AV_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_function
name|void
name|Perl_av_reify
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|)
block|{
name|I32
name|key
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_DEBUGGING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEBUGGING
argument_list|,
literal|"av_reify called on tied array"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|key
operator|=
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|key
operator|>
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
condition|)
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
operator|--
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
while|while
condition|(
name|key
condition|)
block|{
name|sv
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
operator|--
name|key
index|]
expr_stmt|;
name|assert
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
operator|&
name|PL_sv_undef
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
while|while
condition|(
name|key
condition|)
name|AvALLOC
argument_list|(
name|av
argument_list|)
index|[
operator|--
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|AvREIFY_off
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|AvREAL_on
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_extend  Pre-extend an array.  The C<key> is the index to which the array should be extended.  =cut */
end_comment

begin_function
name|void
name|Perl_av_extend
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|key
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|key
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_method
argument_list|(
literal|"EXTEND"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|key
operator|>
name|AvMAX
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
name|I32
name|tmp
decl_stmt|;
name|I32
name|newmax
decl_stmt|;
if|if
condition|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|!=
name|AvARRAY
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|ary
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|+
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|,
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|tmp
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
while|while
condition|(
name|tmp
condition|)
name|ary
index|[
operator|--
name|tmp
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|>
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|-
literal|10
condition|)
block|{
name|newmax
operator|=
name|key
operator|+
name|AvMAX
argument_list|(
name|av
argument_list|)
expr_stmt|;
goto|goto
name|resize
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|STRANGE_MALLOC
name|MEM_SIZE
name|bytes
decl_stmt|;
name|IV
name|itmp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LEAKTEST
argument_list|)
name|newmax
operator|=
name|malloced_size
argument_list|(
operator|(
name|void
operator|*
operator|)
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|<=
name|newmax
condition|)
goto|goto
name|resized
goto|;
endif|#
directive|endif
name|newmax
operator|=
name|key
operator|+
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|/
literal|5
expr_stmt|;
name|resize
label|:
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
name|Renew
argument_list|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|,
name|newmax
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|bytes
operator|=
operator|(
name|newmax
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
expr_stmt|;
define|#
directive|define
name|MALLOC_OVERHEAD
value|16
name|itmp
operator|=
name|MALLOC_OVERHEAD
expr_stmt|;
while|while
condition|(
name|itmp
operator|-
name|MALLOC_OVERHEAD
operator|<
name|bytes
condition|)
name|itmp
operator|+=
name|itmp
expr_stmt|;
name|itmp
operator|-=
name|MALLOC_OVERHEAD
expr_stmt|;
name|itmp
operator|/=
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|itmp
operator|>
name|newmax
argument_list|)
expr_stmt|;
name|newmax
operator|=
name|itmp
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|newmax
operator|>=
name|AvMAX
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|2
argument_list|,
name|ary
argument_list|,
name|newmax
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|,
name|ary
argument_list|,
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|>
literal|64
condition|)
name|offer_nice_chunk
argument_list|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|,
operator|(
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Safefree
argument_list|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
name|ary
expr_stmt|;
endif|#
directive|endif
name|resized
label|:
name|ary
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|+
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
name|newmax
operator|-
name|AvMAX
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|==
name|PL_curstack
condition|)
block|{
comment|/* Oops, grew stack (via av_store()?) */
name|PL_stack_sp
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|+
operator|(
name|PL_stack_sp
operator|-
name|PL_stack_base
operator|)
expr_stmt|;
name|PL_stack_base
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|PL_stack_max
operator|=
name|PL_stack_base
operator|+
name|newmax
expr_stmt|;
block|}
block|}
else|else
block|{
name|newmax
operator|=
name|key
operator|<
literal|3
condition|?
literal|3
else|:
name|key
expr_stmt|;
name|New
argument_list|(
literal|2
argument_list|,
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|,
name|newmax
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|ary
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
name|newmax
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
index|[
literal|0
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
comment|/* For the stacks */
block|}
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
while|while
condition|(
name|tmp
condition|)
name|ary
index|[
operator|--
name|tmp
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|newmax
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc av_fetch  Returns the SV at the specified index in the array.  The C<key> is the index.  If C<lval> is set then the fetch will be part of a store.  Check that the return value is non-null before dereferencing it to a C<SV*>.  See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied arrays.   =cut */
end_comment

begin_function
name|SV
modifier|*
modifier|*
name|Perl_av_fetch
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|key
parameter_list|,
name|I32
name|lval
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
block|{
name|key
operator|+=
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|||
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'D'
argument_list|)
condition|)
block|{
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|PL_av_fetch_sv
operator|=
name|sv
expr_stmt|;
return|return
operator|&
name|PL_av_fetch_sv
return|;
block|}
block|}
if|if
condition|(
name|key
operator|>
name|AvFILLp
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lval
condition|)
return|return
literal|0
return|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|av_store
argument_list|(
name|av
argument_list|,
name|key
argument_list|,
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
name|emptyness
label|:
if|if
condition|(
name|lval
condition|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|av_store
argument_list|(
name|av
argument_list|,
name|key
argument_list|,
name|sv
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|AvREIFY
argument_list|(
name|av
argument_list|)
operator|&&
operator|(
operator|!
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
comment|/* eg. @_ could have freed elts */
operator|||
name|SvTYPE
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
argument_list|)
operator|==
name|SVTYPEMASK
operator|)
condition|)
block|{
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
comment|/* 1/2 reify */
goto|goto
name|emptyness
goto|;
block|}
return|return
operator|&
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_store  Stores an SV in an array.  The array index is specified as C<key>.  The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise it can be dereferenced to get the original C<SV*>.  Note that the caller is responsible for suitably incrementing the reference count of C<val> before the call, and decrementing it if the function returned NULL.  See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied arrays.  =cut */
end_comment

begin_function
name|SV
modifier|*
modifier|*
name|Perl_av_store
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|key
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|)
block|{
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
block|{
name|key
operator|+=
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
operator|&&
name|key
operator|>=
name|AvFILL
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
name|av
argument_list|)
operator|&&
name|AvREIFY
argument_list|(
name|av
argument_list|)
condition|)
name|av_reify
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|AvMAX
argument_list|(
name|av
argument_list|)
condition|)
name|av_extend
argument_list|(
name|av
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ary
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|<
name|key
condition|)
block|{
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
name|av
operator|==
name|PL_curstack
operator|&&
name|key
operator|>
name|PL_stack_sp
operator|-
name|PL_stack_base
condition|)
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|key
expr_stmt|;
comment|/* XPUSH in disguise */
do|do
name|ary
index|[
operator|++
name|AvFILLp
argument_list|(
name|av
argument_list|)
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
do|while
condition|(
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|<
name|key
condition|)
do|;
block|}
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|key
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|ary
index|[
name|key
index|]
argument_list|)
expr_stmt|;
name|ary
index|[
name|key
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|SvMAGIC
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|sv_magic
argument_list|(
name|val
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|toLOWER
argument_list|(
name|mg
operator|->
name|mg_type
argument_list|)
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|ary
index|[
name|key
index|]
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc newAV  Creates a new AV.  The reference count is set to 1.  =cut */
end_comment

begin_function
name|AV
modifier|*
name|Perl_newAV
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|AV
modifier|*
name|av
decl_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|AvREAL_on
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_make  Creates a new AV and populates it with a list of SVs.  The SVs are copied into the array, so they may be freed after the call to av_make.  The new AV will have a reference count of 1.  =cut */
end_comment

begin_function
name|AV
modifier|*
name|Perl_av_make
parameter_list|(
name|pTHX_
specifier|register
name|I32
name|size
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|strp
parameter_list|)
block|{
specifier|register
name|AV
modifier|*
name|av
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REAL
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
comment|/* `defined' was returning undef for size==0 anyway. */
name|New
argument_list|(
literal|4
argument_list|,
name|ary
argument_list|,
name|size
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
name|ary
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|size
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
operator|*
name|strp
argument_list|)
expr_stmt|;
name|ary
index|[
name|i
index|]
operator|=
name|NEWSV
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|ary
index|[
name|i
index|]
argument_list|,
operator|*
name|strp
argument_list|)
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
block|}
return|return
name|av
return|;
block|}
end_function

begin_function
name|AV
modifier|*
name|Perl_av_fake
parameter_list|(
name|pTHX_
specifier|register
name|I32
name|size
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|strp
parameter_list|)
block|{
specifier|register
name|AV
modifier|*
name|av
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|4
argument_list|,
name|ary
argument_list|,
name|size
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
name|ary
expr_stmt|;
name|Copy
argument_list|(
name|strp
argument_list|,
name|ary
argument_list|,
name|size
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|assert
argument_list|(
operator|*
name|strp
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
operator|*
name|strp
argument_list|)
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_clear  Clears an array, making it empty.  Does not free the memory used by the array itself.  =cut */
end_comment

begin_function
name|void
name|Perl_av_clear
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|)
block|{
specifier|register
name|I32
name|key
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|SvREFCNT
argument_list|(
name|av
argument_list|)
operator|==
literal|0
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_DEBUGGING
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEBUGGING
argument_list|,
literal|"Attempt to clear deleted array"
argument_list|)
empty_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|av
condition|)
return|return;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
comment|/* Give any tie a chance to cleanup first */
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
name|mg_clear
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|ary
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|key
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|key
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|ary
index|[
operator|--
name|key
index|]
argument_list|)
expr_stmt|;
name|ary
index|[
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|key
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|)
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|key
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_undef  Undefines the array.  Frees the memory used by the array itself.  =cut */
end_comment

begin_function
name|void
name|Perl_av_undef
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|)
block|{
specifier|register
name|I32
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
return|return;
comment|/*SUPPRESS 560*/
comment|/* Give any tie a chance to cleanup first */
if|if
condition|(
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
condition|)
name|av_fill
argument_list|(
name|av
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* mg_clear() ? */
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|key
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|key
condition|)
name|SvREFCNT_dec
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
operator|--
name|key
index|]
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|AvALLOC
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|AvARYLEN
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|AvARYLEN
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|AvARYLEN
argument_list|(
name|av
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc av_push  Pushes an SV onto the end of the array.  The array will grow automatically to accommodate the addition.  =cut */
end_comment

begin_function
name|void
name|Perl_av_push
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
return|return;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"PUSH"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|POPSTACK
expr_stmt|;
return|return;
block|}
name|av_store
argument_list|(
name|av
argument_list|,
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_pop  Pops an SV off the end of the array.  Returns C<&PL_sv_undef> if the array is empty.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_av_pop
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|)
block|{
name|SV
modifier|*
name|retval
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|av
operator|||
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|&
name|PL_sv_undef
return|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
name|call_method
argument_list|(
literal|"POP"
argument_list|,
name|G_SCALAR
argument_list|)
condition|)
block|{
name|retval
operator|=
name|newSVsv
argument_list|(
operator|*
name|PL_stack_sp
operator|--
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|POPSTACK
expr_stmt|;
return|return
name|retval
return|;
block|}
name|retval
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|AvFILLp
argument_list|(
name|av
argument_list|)
index|]
expr_stmt|;
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|--
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_unshift  Unshift the given number of C<undef> values onto the beginning of the array.  The array will grow automatically to accommodate the addition.  You must then use C<av_store> to assign values to these new elements.  =cut */
end_comment

begin_function
name|void
name|Perl_av_unshift
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|,
specifier|register
name|I32
name|num
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|I32
name|slide
decl_stmt|;
if|if
condition|(
operator|!
name|av
operator|||
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
operator|+
name|num
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
operator|>
literal|0
condition|)
block|{
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"UNSHIFT"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|POPSTACK
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
name|av
argument_list|)
operator|&&
name|AvREIFY
argument_list|(
name|av
argument_list|)
condition|)
name|av_reify
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|i
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|num
condition|)
name|i
operator|=
name|num
expr_stmt|;
name|num
operator|-=
name|i
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|i
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+=
name|i
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|num
condition|)
block|{
name|i
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* Create extra elements */
name|slide
operator|=
name|i
operator|>
literal|0
condition|?
name|i
else|:
literal|0
expr_stmt|;
name|num
operator|+=
name|slide
expr_stmt|;
name|av_extend
argument_list|(
name|av
argument_list|,
name|i
operator|+
name|num
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+=
name|num
expr_stmt|;
name|ary
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ary
argument_list|,
name|ary
operator|+
name|num
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
do|do
block|{
name|ary
index|[
operator|--
name|num
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
do|while
condition|(
name|num
condition|)
do|;
comment|/* Make extra elements into a buffer */
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|-=
name|slide
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|-=
name|slide
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|+
name|slide
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc av_shift  Shifts an SV off the beginning of the array.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_av_shift
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|)
block|{
name|SV
modifier|*
name|retval
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|av
operator|||
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|&
name|PL_sv_undef
return|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
name|call_method
argument_list|(
literal|"SHIFT"
argument_list|,
name|G_SCALAR
argument_list|)
condition|)
block|{
name|retval
operator|=
name|newSVsv
argument_list|(
operator|*
name|PL_stack_sp
operator|--
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|POPSTACK
expr_stmt|;
return|return
name|retval
return|;
block|}
name|retval
operator|=
operator|*
name|AvARRAY
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
operator|*
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|--
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|--
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_len  Returns the highest index in the array.  Returns -1 if the array is empty.  =cut */
end_comment

begin_function
name|I32
name|Perl_av_len
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|)
block|{
return|return
name|AvFILL
argument_list|(
name|av
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_fill  Ensure than an array has a given number of elements, equivalent to Perl's C<$#array = $fill;>.  =cut */
end_comment

begin_function
name|void
name|Perl_av_fill
parameter_list|(
name|pTHX_
specifier|register
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|fill
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: null array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
operator|<
literal|0
condition|)
name|fill
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|fill
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_method
argument_list|(
literal|"STORESIZE"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fill
operator|<=
name|AvMAX
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|I32
name|key
init|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ary
init|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
while|while
condition|(
name|key
operator|>
name|fill
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|ary
index|[
name|key
index|]
argument_list|)
expr_stmt|;
name|ary
index|[
name|key
operator|--
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|key
operator|<
name|fill
condition|)
name|ary
index|[
operator|++
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|av_store
argument_list|(
name|av
argument_list|,
name|fill
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_delete  Deletes the element indexed by C<key> from the array.  Returns the deleted element. C<flags> is currently ignored.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_av_delete
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|key
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|av
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|av
argument_list|)
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
block|{
name|key
operator|+=
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
name|Nullsv
return|;
block|}
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
if|if
condition|(
operator|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|||
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'D'
argument_list|)
operator|)
operator|&&
operator|(
name|svp
operator|=
name|av_fetch
argument_list|(
name|av
argument_list|,
name|key
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
name|sv
operator|=
operator|*
name|svp
expr_stmt|;
name|mg_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
comment|/* No longer an element */
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
comment|/* element cannot be deleted */
block|}
block|}
if|if
condition|(
name|key
operator|>
name|AvFILLp
argument_list|(
name|av
argument_list|)
condition|)
return|return
name|Nullsv
return|;
else|else
block|{
name|sv
operator|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|AvFILLp
argument_list|(
name|av
argument_list|)
condition|)
block|{
do|do
block|{
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|key
operator|>=
literal|0
operator|&&
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
operator|==
operator|&
name|PL_sv_undef
condition|)
do|;
block|}
else|else
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Nullsv
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc av_exists  Returns true if the element indexed by C<key> has been initialized.  This relies on the fact that uninitialized array elements are set to C<&PL_sv_undef>.  =cut */
end_comment

begin_function
name|bool
name|Perl_av_exists
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|I32
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|av
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
block|{
name|key
operator|+=
name|AvFILL
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'P'
argument_list|)
operator|||
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'D'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
condition|)
block|{
name|magic_existspack
argument_list|(
name|sv
argument_list|,
name|mg
argument_list|)
expr_stmt|;
return|return
name|SvTRUE
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|key
operator|<=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|&&
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
name|key
index|]
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* AVHV: Support for treating arrays as if they were hashes.  The  * first element of the array should be a hash reference that maps  * hash keys to array indices.  */
end_comment

begin_function
name|STATIC
name|I32
name|S_avhv_index_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|I32
name|index
init|=
name|SvIV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad index while coercing array into hash"
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_avhv_index
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|HV
modifier|*
name|keys
decl_stmt|;
name|HE
modifier|*
name|he
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|keys
operator|=
name|avhv_keys
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|he
operator|=
name|hv_fetch_ent
argument_list|(
name|keys
argument_list|,
name|keysv
argument_list|,
name|FALSE
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No such pseudo-hash field \"%s\""
argument_list|,
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|avhv_index_sv
argument_list|(
name|HeVAL
argument_list|(
name|he
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|HV
modifier|*
name|Perl_avhv_keys
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|)
block|{
name|SV
modifier|*
modifier|*
name|keysp
init|=
name|av_fetch
argument_list|(
name|av
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|keysp
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
operator|*
name|keysp
decl_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVHV
condition|)
return|return
operator|(
name|HV
operator|*
operator|)
name|sv
return|;
block|}
block|}
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't coerce array into hash"
argument_list|)
expr_stmt|;
return|return
name|Nullhv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
modifier|*
name|Perl_avhv_store_ent
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
return|return
name|av_store
argument_list|(
name|av
argument_list|,
name|avhv_index
argument_list|(
name|av
argument_list|,
name|keysv
argument_list|,
name|hash
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
modifier|*
name|Perl_avhv_fetch_ent
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|lval
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
return|return
name|av_fetch
argument_list|(
name|av
argument_list|,
name|avhv_index
argument_list|(
name|av
argument_list|,
name|keysv
argument_list|,
name|hash
argument_list|)
argument_list|,
name|lval
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_avhv_delete_ent
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|flags
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|HV
modifier|*
name|keys
init|=
name|avhv_keys
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|HE
modifier|*
name|he
decl_stmt|;
name|he
operator|=
name|hv_fetch_ent
argument_list|(
name|keys
argument_list|,
name|keysv
argument_list|,
name|FALSE
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
operator|||
operator|!
name|SvOK
argument_list|(
name|HeVAL
argument_list|(
name|he
argument_list|)
argument_list|)
condition|)
return|return
name|Nullsv
return|;
return|return
name|av_delete
argument_list|(
name|av
argument_list|,
name|avhv_index_sv
argument_list|(
name|HeVAL
argument_list|(
name|he
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check for the existence of an element named by a given key.  *  */
end_comment

begin_function
name|bool
name|Perl_avhv_exists_ent
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|HV
modifier|*
name|keys
init|=
name|avhv_keys
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|HE
modifier|*
name|he
decl_stmt|;
name|he
operator|=
name|hv_fetch_ent
argument_list|(
name|keys
argument_list|,
name|keysv
argument_list|,
name|FALSE
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
operator|||
operator|!
name|SvOK
argument_list|(
name|HeVAL
argument_list|(
name|he
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|av_exists
argument_list|(
name|av
argument_list|,
name|avhv_index_sv
argument_list|(
name|HeVAL
argument_list|(
name|he
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|HE
modifier|*
name|Perl_avhv_iternext
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|)
block|{
name|HV
modifier|*
name|keys
init|=
name|avhv_keys
argument_list|(
name|av
argument_list|)
decl_stmt|;
return|return
name|hv_iternext
argument_list|(
name|keys
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_avhv_iterval
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|av
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|hv_iterval
argument_list|(
name|avhv_keys
argument_list|(
name|av
argument_list|)
argument_list|,
name|entry
argument_list|)
decl_stmt|;
return|return
operator|*
name|av_fetch
argument_list|(
name|av
argument_list|,
name|avhv_index_sv
argument_list|(
name|sv
argument_list|)
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

end_unit

