begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sdbm - ndbm work-alike hashed database library  * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).  * author: oz@nexus.yorku.ca  * status: public domain.  *  * core routines  */
end_comment

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"sdbm.h"
end_include

begin_include
include|#
directive|include
file|"tune.h"
end_include

begin_include
include|#
directive|include
file|"pair.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_STRING
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * externals  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|Malloc_t
name|malloc
name|proto
argument_list|(
operator|(
name|MEM_SIZE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Free_t
name|free
name|proto
argument_list|(
operator|(
name|Malloc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Off_t
name|lseek
parameter_list|(
name|int
parameter_list|,
name|Off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * forward  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|getdbit
name|proto
argument_list|(
operator|(
name|DBM
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdbit
name|proto
argument_list|(
operator|(
name|DBM
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getpage
name|proto
argument_list|(
operator|(
name|DBM
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|datum
name|getnext
name|proto
argument_list|(
operator|(
name|DBM
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|makroom
name|proto
argument_list|(
operator|(
name|DBM
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * useful macros  */
end_comment

begin_define
define|#
directive|define
name|bad
parameter_list|(
name|x
parameter_list|)
value|((x).dptr == NULL || (x).dsize< 0)
end_define

begin_define
define|#
directive|define
name|exhash
parameter_list|(
name|item
parameter_list|)
value|sdbm_hash((item).dptr, (item).dsize)
end_define

begin_define
define|#
directive|define
name|ioerr
parameter_list|(
name|db
parameter_list|)
value|((db)->flags |= DBM_IOERR)
end_define

begin_define
define|#
directive|define
name|OFF_PAG
parameter_list|(
name|off
parameter_list|)
value|(long) (off) * PBLKSIZ
end_define

begin_define
define|#
directive|define
name|OFF_DIR
parameter_list|(
name|off
parameter_list|)
value|(long) (off) * DBLKSIZ
end_define

begin_decl_stmt
specifier|static
name|long
name|masks
index|[]
init|=
block|{
literal|000000000000
block|,
literal|000000000001
block|,
literal|000000000003
block|,
literal|000000000007
block|,
literal|000000000017
block|,
literal|000000000037
block|,
literal|000000000077
block|,
literal|000000000177
block|,
literal|000000000377
block|,
literal|000000000777
block|,
literal|000000001777
block|,
literal|000000003777
block|,
literal|000000007777
block|,
literal|000000017777
block|,
literal|000000037777
block|,
literal|000000077777
block|,
literal|000000177777
block|,
literal|000000377777
block|,
literal|000000777777
block|,
literal|000001777777
block|,
literal|000003777777
block|,
literal|000007777777
block|,
literal|000017777777
block|,
literal|000037777777
block|,
literal|000077777777
block|,
literal|000177777777
block|,
literal|000377777777
block|,
literal|000777777777
block|,
literal|001777777777
block|,
literal|003777777777
block|,
literal|007777777777
block|,
literal|017777777777
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|DBM
modifier|*
name|sdbm_open
parameter_list|(
specifier|register
name|char
modifier|*
name|file
parameter_list|,
specifier|register
name|int
name|flags
parameter_list|,
specifier|register
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|DBM
modifier|*
name|db
decl_stmt|;
specifier|register
name|char
modifier|*
name|dirname
decl_stmt|;
specifier|register
name|char
modifier|*
name|pagname
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
operator|!
operator|*
name|file
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
operator|(
name|DBM
operator|*
operator|)
name|NULL
return|;
comment|/*  * need space for two seperate filenames  */
name|n
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|*
literal|2
operator|+
name|strlen
argument_list|(
name|DIRFEXT
argument_list|)
operator|+
name|strlen
argument_list|(
name|PAGFEXT
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
operator|=
name|ENOMEM
operator|,
operator|(
name|DBM
operator|*
operator|)
name|NULL
return|;
comment|/*  * build the file names  */
name|dirname
operator|=
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|file
argument_list|)
argument_list|,
name|DIRFEXT
argument_list|)
expr_stmt|;
name|pagname
operator|=
name|strcpy
argument_list|(
name|dirname
operator|+
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|pagname
operator|=
name|strcat
argument_list|(
name|pagname
argument_list|,
name|PAGFEXT
argument_list|)
expr_stmt|;
name|db
operator|=
name|sdbm_prep
argument_list|(
name|dirname
argument_list|,
name|pagname
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirname
argument_list|)
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_function
name|DBM
modifier|*
name|sdbm_prep
parameter_list|(
name|char
modifier|*
name|dirname
parameter_list|,
name|char
modifier|*
name|pagname
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|DBM
modifier|*
name|db
decl_stmt|;
name|struct
name|stat
name|dstat
decl_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
operator|(
name|DBM
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DBM
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
operator|=
name|ENOMEM
operator|,
operator|(
name|DBM
operator|*
operator|)
name|NULL
return|;
name|db
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|hmask
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|blkptr
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|keyptr
operator|=
literal|0
expr_stmt|;
comment|/*  * adjust user flags so that WRONLY becomes RDWR,   * as required by this package. Also set our internal  * flag for RDONLY if needed.  */
if|if
condition|(
name|flags
operator|&
name|O_WRONLY
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|O_WRONLY
operator|)
operator||
name|O_RDWR
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
literal|03
operator|)
operator|==
name|O_RDONLY
condition|)
name|db
operator|->
name|flags
operator|=
name|DBM_RDONLY
expr_stmt|;
comment|/*  * open the files in sequence, and stat the dirfile.  * If we fail anywhere, undo everything, return NULL.  */
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
name|flags
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|db
operator|->
name|pagf
operator|=
name|open
argument_list|(
name|pagname
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|db
operator|->
name|dirf
operator|=
name|open
argument_list|(
name|dirname
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
comment|/*  * need the dirfile size to establish max bit number.  */
if|if
condition|(
name|fstat
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
operator|&
name|dstat
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*  * zero size: either a fresh database, or one with a single,  * unsplit data page: dirpage is all zeros.  */
name|db
operator|->
name|dirbno
operator|=
operator|(
operator|!
name|dstat
operator|.
name|st_size
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|db
operator|->
name|pagbno
operator|=
operator|-
literal|1
expr_stmt|;
name|db
operator|->
name|maxbno
operator|=
name|dstat
operator|.
name|st_size
operator|*
name|BYTESIZ
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
literal|0
argument_list|,
name|PBLKSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|db
operator|->
name|dirbuf
argument_list|,
literal|0
argument_list|,
name|DBLKSIZ
argument_list|)
expr_stmt|;
comment|/* 			 * success 			 */
return|return
name|db
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|db
operator|->
name|dirf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|db
operator|->
name|pagf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|DBM
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|sdbm_close
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|db
operator|->
name|dirf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|db
operator|->
name|pagf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|datum
name|sdbm_fetch
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
name|datum
name|key
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
name|nullitem
return|;
if|if
condition|(
name|getpage
argument_list|(
name|db
argument_list|,
name|exhash
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
return|return
name|getpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
return|;
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
name|nullitem
return|;
block|}
end_function

begin_function
name|int
name|sdbm_delete
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
name|datum
name|key
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
operator|-
literal|1
return|;
if|if
condition|(
name|sdbm_rdonly
argument_list|(
name|db
argument_list|)
condition|)
return|return
name|errno
operator|=
name|EPERM
operator|,
operator|-
literal|1
return|;
if|if
condition|(
name|getpage
argument_list|(
name|db
argument_list|,
name|exhash
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|delpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*  * update the page file  */
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|db
operator|->
name|pagbno
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sdbm_store
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
name|datum
name|key
parameter_list|,
name|datum
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|need
decl_stmt|;
specifier|register
name|long
name|hash
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bad
argument_list|(
name|key
argument_list|)
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
operator|-
literal|1
return|;
if|if
condition|(
name|sdbm_rdonly
argument_list|(
name|db
argument_list|)
condition|)
return|return
name|errno
operator|=
name|EPERM
operator|,
operator|-
literal|1
return|;
name|need
operator|=
name|key
operator|.
name|dsize
operator|+
name|val
operator|.
name|dsize
expr_stmt|;
comment|/*  * is the pair too big (or too small) for this database ??  */
if|if
condition|(
name|need
operator|<
literal|0
operator|||
name|need
operator|>
name|PAIRMAX
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
operator|-
literal|1
return|;
if|if
condition|(
name|getpage
argument_list|(
name|db
argument_list|,
operator|(
name|hash
operator|=
name|exhash
argument_list|(
name|key
argument_list|)
operator|)
argument_list|)
condition|)
block|{
comment|/*  * if we need to replace, delete the key/data pair  * first. If it is not there, ignore.  */
if|if
condition|(
name|flags
operator|==
name|DBM_REPLACE
condition|)
operator|(
name|void
operator|)
name|delpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEEDUPS
elseif|else
if|if
condition|(
name|duppair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/*  * if we do not have enough room, we have to split.  */
if|if
condition|(
operator|!
name|fitpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|need
argument_list|)
condition|)
if|if
condition|(
operator|!
name|makroom
argument_list|(
name|db
argument_list|,
name|hash
argument_list|,
name|need
argument_list|)
condition|)
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
operator|-
literal|1
return|;
comment|/*  * we have enough room or split is successful. insert the key,  * and update the page file.  */
operator|(
name|void
operator|)
name|putpair
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|db
operator|->
name|pagbno
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
operator|-
literal|1
return|;
comment|/* 	 * success 	 */
return|return
literal|0
return|;
block|}
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * makroom - make room by splitting the overfull page  * this routine will attempt to make room for SPLTMAX times before  * giving up.  */
end_comment

begin_function
specifier|static
name|int
name|makroom
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
name|long
name|int
name|hash
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|long
name|newp
decl_stmt|;
name|char
name|twin
index|[
name|PBLKSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|pag
init|=
name|db
operator|->
name|pagbuf
decl_stmt|;
name|char
modifier|*
name|New
init|=
name|twin
decl_stmt|;
specifier|register
name|int
name|smax
init|=
name|SPLTMAX
decl_stmt|;
do|do
block|{
comment|/*  * split the current page  */
operator|(
name|void
operator|)
name|splpage
argument_list|(
name|pag
argument_list|,
name|New
argument_list|,
name|db
operator|->
name|hmask
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*  * address of the new page  */
name|newp
operator|=
operator|(
name|hash
operator|&
name|db
operator|->
name|hmask
operator|)
operator||
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*  * write delay, read avoidence/cache shuffle:  * select the page for incoming pair: if key is to go to the new page,  * write out the previous one, and copy the new one over, thus making  * it the current page. If not, simply write the new page, and we are  * still looking at the page of interest. current page is not updated  * here, as sdbm_store will do so, after it inserts the incoming pair.  */
if|if
condition|(
name|hash
operator|&
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|db
operator|->
name|pagbno
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|db
operator|->
name|pagbno
operator|=
name|newp
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|pag
argument_list|,
name|New
argument_list|,
name|PBLKSIZ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|newp
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|New
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|setdbit
argument_list|(
name|db
argument_list|,
name|db
operator|->
name|curbit
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*  * see if we have enough room now  */
if|if
condition|(
name|fitpair
argument_list|(
name|pag
argument_list|,
name|need
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/*  * try again... update curbit and hmask as getpage would have  * done. because of our update of the current page, we do not  * need to read in anything. BUT we have to write the current  * [deferred] page out, as the window of failure is too great.  */
name|db
operator|->
name|curbit
operator|=
literal|2
operator|*
name|db
operator|->
name|curbit
operator|+
operator|(
operator|(
name|hash
operator|&
operator|(
name|db
operator|->
name|hmask
operator|+
literal|1
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|db
operator|->
name|hmask
operator||=
name|db
operator|->
name|hmask
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|db
operator|->
name|pagbno
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|--
name|smax
condition|)
do|;
comment|/*  * if we are here, this is real bad news. After SPLTMAX splits,  * we still cannot fit the key. say goodnight.  */
ifdef|#
directive|ifdef
name|BADMESS
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"sdbm: cannot insert after SPLTMAX attempts.\n"
argument_list|,
literal|44
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * the following two routines will break if  * deletions aren't taken into account. (ndbm bug)  */
end_comment

begin_function
name|datum
name|sdbm_firstkey
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
name|nullitem
return|;
comment|/*  * start at page 0  */
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
name|nullitem
return|;
name|db
operator|->
name|pagbno
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|blkptr
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|keyptr
operator|=
literal|0
expr_stmt|;
return|return
name|getnext
argument_list|(
name|db
argument_list|)
return|;
block|}
end_function

begin_function
name|datum
name|sdbm_nextkey
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|)
block|{
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|errno
operator|=
name|EINVAL
operator|,
name|nullitem
return|;
return|return
name|getnext
argument_list|(
name|db
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * all important binary trie traversal  */
end_comment

begin_function
specifier|static
name|int
name|getpage
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
specifier|register
name|long
name|int
name|hash
parameter_list|)
block|{
specifier|register
name|int
name|hbit
decl_stmt|;
specifier|register
name|long
name|dbit
decl_stmt|;
specifier|register
name|long
name|pagb
decl_stmt|;
name|dbit
operator|=
literal|0
expr_stmt|;
name|hbit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dbit
operator|<
name|db
operator|->
name|maxbno
operator|&&
name|getdbit
argument_list|(
name|db
argument_list|,
name|dbit
argument_list|)
condition|)
name|dbit
operator|=
literal|2
operator|*
name|dbit
operator|+
operator|(
operator|(
name|hash
operator|&
operator|(
literal|1
operator|<<
name|hbit
operator|++
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dbit: %d..."
operator|,
name|dbit
operator|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|curbit
operator|=
name|dbit
expr_stmt|;
name|db
operator|->
name|hmask
operator|=
name|masks
index|[
name|hbit
index|]
expr_stmt|;
name|pagb
operator|=
name|hash
operator|&
name|db
operator|->
name|hmask
expr_stmt|;
comment|/*  * see if the block we need is already in memory.  * note: this lookaside cache has about 10% hit rate.  */
if|if
condition|(
name|pagb
operator|!=
name|db
operator|->
name|pagbno
condition|)
block|{
comment|/*  * note: here, we assume a "hole" is read as 0s.  * if not, must zero pagbuf first.  */
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|pagb
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|chkpage
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|db
operator|->
name|pagbno
operator|=
name|pagb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"pag read: %d\n"
operator|,
name|pagb
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdbit
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
specifier|register
name|long
name|int
name|dbit
parameter_list|)
block|{
specifier|register
name|long
name|c
decl_stmt|;
specifier|register
name|long
name|dirb
decl_stmt|;
name|c
operator|=
name|dbit
operator|/
name|BYTESIZ
expr_stmt|;
name|dirb
operator|=
name|c
operator|/
name|DBLKSIZ
expr_stmt|;
if|if
condition|(
name|dirb
operator|!=
name|db
operator|->
name|dirbno
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|DBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|db
operator|->
name|dirbno
operator|=
name|dirb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dir read: %d\n"
operator|,
name|dirb
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|db
operator|->
name|dirbuf
index|[
name|c
operator|%
name|DBLKSIZ
index|]
operator|&
operator|(
literal|1
operator|<<
name|dbit
operator|%
name|BYTESIZ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdbit
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|,
specifier|register
name|long
name|int
name|dbit
parameter_list|)
block|{
specifier|register
name|long
name|c
decl_stmt|;
specifier|register
name|long
name|dirb
decl_stmt|;
name|c
operator|=
name|dbit
operator|/
name|BYTESIZ
expr_stmt|;
name|dirb
operator|=
name|c
operator|/
name|DBLKSIZ
expr_stmt|;
if|if
condition|(
name|dirb
operator|!=
name|db
operator|->
name|dirbno
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|db
operator|->
name|dirbuf
argument_list|,
literal|0
argument_list|,
name|DBLKSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|DBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|db
operator|->
name|dirbno
operator|=
name|dirb
expr_stmt|;
name|debug
argument_list|(
operator|(
literal|"dir read: %d\n"
operator|,
name|dirb
operator|)
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|dirbuf
index|[
name|c
operator|%
name|DBLKSIZ
index|]
operator||=
operator|(
literal|1
operator|<<
name|dbit
operator|%
name|BYTESIZ
operator|)
expr_stmt|;
if|if
condition|(
name|dbit
operator|>=
name|db
operator|->
name|maxbno
condition|)
name|db
operator|->
name|maxbno
operator|+=
name|DBLKSIZ
operator|*
name|BYTESIZ
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|OFF_DIR
argument_list|(
name|dirb
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|db
operator|->
name|dirf
argument_list|,
name|db
operator|->
name|dirbuf
argument_list|,
name|DBLKSIZ
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * getnext - get the next key in the page, and if done with  * the page, try the next page in sequence  */
end_comment

begin_function
specifier|static
name|datum
name|getnext
parameter_list|(
specifier|register
name|DBM
modifier|*
name|db
parameter_list|)
block|{
name|datum
name|key
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|db
operator|->
name|keyptr
operator|++
expr_stmt|;
name|key
operator|=
name|getnkey
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|,
name|db
operator|->
name|keyptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|)
return|return
name|key
return|;
comment|/*  * we either run out, or there is nothing on this page..  * try the next one... If we lost our position on the  * file, we will have to seek.  */
name|db
operator|->
name|keyptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|pagbno
operator|!=
name|db
operator|->
name|blkptr
operator|++
condition|)
if|if
condition|(
name|lseek
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|OFF_PAG
argument_list|(
name|db
operator|->
name|blkptr
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|db
operator|->
name|pagbno
operator|=
name|db
operator|->
name|blkptr
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|db
operator|->
name|pagf
argument_list|,
name|db
operator|->
name|pagbuf
argument_list|,
name|PBLKSIZ
argument_list|)
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|chkpage
argument_list|(
name|db
operator|->
name|pagbuf
argument_list|)
condition|)
break|break;
block|}
return|return
name|ioerr
argument_list|(
name|db
argument_list|)
operator|,
name|nullitem
return|;
block|}
end_function

end_unit

