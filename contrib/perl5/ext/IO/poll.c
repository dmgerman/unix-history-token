begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * poll.c  *  * Copyright (c) 1997-8 Graham Barr<gbarr@pobox.com>. All rights reserved.  * This program is free software; you can redistribute it and/or  * modify it under the same terms as Perl itself.  *  * For systems that do not have the poll() system call (for example Linux  * kernels< v2.1.23) try to emulate it as closely as possible using select()  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"poll.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_TIME
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_SOCKET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_comment
comment|/* VMS handles sockets via vmsish.h */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SELECT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_SELECT
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EMULATE_POLL_WITH_SELECT
end_ifdef

begin_define
define|#
directive|define
name|POLL_CAN_READ
value|(POLLIN | POLLRDNORM )
end_define

begin_define
define|#
directive|define
name|POLL_CAN_WRITE
value|(POLLOUT | POLLWRNORM | POLLWRBAND )
end_define

begin_define
define|#
directive|define
name|POLL_HAS_EXCP
value|(POLLRDBAND | POLLPRI )
end_define

begin_define
define|#
directive|define
name|POLL_EVENTS_MASK
value|(POLL_CAN_READ | POLL_CAN_WRITE | POLL_HAS_EXCP)
end_define

begin_function
name|int
name|poll
parameter_list|(
name|struct
name|pollfd
modifier|*
name|fds
parameter_list|,
name|unsigned
name|long
name|nfds
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|fd_set
name|rfd
decl_stmt|,
name|wfd
decl_stmt|,
name|efd
decl_stmt|,
name|ifd
decl_stmt|;
name|struct
name|timeval
name|timebuf
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tbuf
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifd
argument_list|)
expr_stmt|;
name|again
label|:
name|FD_ZERO
argument_list|(
operator|&
name|rfd
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wfd
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|efd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|int
name|events
init|=
name|fds
index|[
name|i
index|]
operator|.
name|events
decl_stmt|;
name|int
name|fd
init|=
name|fds
index|[
name|i
index|]
operator|.
name|fd
decl_stmt|;
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifd
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fd
operator|>
name|n
condition|)
name|n
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|POLL_CAN_READ
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|POLL_CAN_WRITE
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|wfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|POLL_HAS_EXCP
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|efd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|0
condition|)
block|{
name|timebuf
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|timebuf
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|tbuf
operator|=
operator|&
name|timebuf
expr_stmt|;
block|}
name|err
operator|=
name|select
argument_list|(
name|n
operator|+
literal|1
argument_list|,
operator|&
name|rfd
argument_list|,
operator|&
name|wfd
argument_list|,
operator|&
name|efd
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_FSTAT
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|fstat
argument_list|(
name|fds
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBADF
operator|)
condition|)
block|{
name|FD_SET
argument_list|(
name|fds
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|ifd
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAS_FSTAT */
return|return
name|err
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|int
name|revents
init|=
operator|(
name|fds
index|[
name|i
index|]
operator|.
name|events
operator|&
name|POLL_EVENTS_MASK
operator|)
decl_stmt|;
name|int
name|fd
init|=
name|fds
index|[
name|i
index|]
operator|.
name|fd
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifd
argument_list|)
condition|)
name|revents
operator|=
name|POLLNVAL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|rfd
argument_list|)
condition|)
name|revents
operator|&=
operator|~
name|POLL_CAN_READ
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|wfd
argument_list|)
condition|)
name|revents
operator|&=
operator|~
name|POLL_CAN_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|efd
argument_list|)
condition|)
name|revents
operator|&=
operator|~
name|POLL_HAS_EXCP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|=
name|revents
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMULATE_POLL_WITH_SELECT */
end_comment

end_unit

