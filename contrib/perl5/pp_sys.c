begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    pp_sys.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * But only a short way ahead its floor and the walls on either side were  * cloven by a great fissure, out of which the red glare came, now leaping  * up, now dying down into darkness; and all the while far below there was  * a rumour and a trouble as of great engines throbbing and labouring.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_PP_SYS_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I_SHADOW
end_ifdef

begin_comment
comment|/* Shadow password support for solaris - pdo@cs.umd.edu  * Not just Solaris: at least HP-UX, IRIX, Linux.  * The API is from SysV.  *  * There are at least two more shadow interfaces,  * see the comments in pp_gpwent().  *  * --jhi */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux__
end_ifdef

begin_comment
comment|/* There is a MAXINT coming from<shadow.h><-<hpsecurity.h><-<values.h>  * and another MAXINT from "perl.h"<-<sys/param.h>. */
end_comment

begin_undef
undef|#
directive|undef
name|MAXINT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SYSCALL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
name|int
name|syscall
parameter_list|(
name|unsigned
name|long
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_WAIT
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_RESOURCE
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SELECT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_SELECT
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX Configure test needed.    h_errno might not be a simple 'int', especially for multi-threaded    applications, see "extern int errno in perl.h".  Creating such    a test requires taking into account the differences between    compiling multithreaded and singlethreaded ($ccflags et al).    HOST_NOT_FOUND is typically defined in<netdb.h>. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_NOT_FOUND
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|h_errno
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_PASSWD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_PWD
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|(
name|Uid_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_GETPWENT
end_ifdef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_GROUP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_GRP
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|(
name|Gid_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_GETGRENT
end_ifdef

begin_function_decl
name|struct
name|group
modifier|*
name|getgrent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_UTIME
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put this after #includes because fork and vfork prototypes may conflict. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VFORK
end_ifndef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_CHSIZE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|my_chsize
end_ifdef

begin_comment
comment|/* Probably #defined to Perl_my_chsize in embed.h */
end_comment

begin_undef
undef|#
directive|undef
name|my_chsize
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|my_chsize
value|PerlLIO_chsize
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_FLOCK
end_ifdef

begin_define
define|#
directive|define
name|FLOCK
value|flock
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no flock() */
end_comment

begin_comment
comment|/* fcntl.h might not have been included, even if it exists, because       the current Configure only sets I_FCNTL if it's needed to pick up       the *_OK constants.  Make sure it has been included before testing       the fcntl() locking constants. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I_FCNTL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|FCNTL_CAN_LOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|FLOCK
value|fcntl_emulate_flock
end_define

begin_define
define|#
directive|define
name|FCNTL_EMULATE_FLOCK
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no flock() or fcntl(F_SETLK,...) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_LOCKF
end_ifdef

begin_define
define|#
directive|define
name|FLOCK
value|lockf_emulate_flock
end_define

begin_define
define|#
directive|define
name|LOCKF_EMULATE_FLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lockf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no flock() or fcntl(F_SETLK,...) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOCK
end_ifdef

begin_function_decl
specifier|static
name|int
name|FLOCK
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*      * These are the flock() constants.  Since this sytems doesn't have      * flock(), the values of the constants are probably not available.      */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LOCK_SH
end_ifndef

begin_define
define|#
directive|define
name|LOCK_SH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCK_EX
end_ifndef

begin_define
define|#
directive|define
name|LOCK_EX
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCK_NB
end_ifndef

begin_define
define|#
directive|define
name|LOCK_NB
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCK_UN
end_ifndef

begin_define
define|#
directive|define
name|LOCK_UN
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emulating flock() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no flock() */
end_comment

begin_define
define|#
directive|define
name|ZBTLEN
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|zero_but_true
index|[
name|ZBTLEN
operator|+
literal|1
index|]
init|=
literal|"0 but true"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I_SYS_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|R_OK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/access.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FD_CLOEXEC
argument_list|)
end_if

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_comment
comment|/* NeXT needs this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PERL_EFF_ACCESS_R_OK
end_undef

begin_comment
comment|/* EFFective uid/gid ACCESS R_OK */
end_comment

begin_undef
undef|#
directive|undef
name|PERL_EFF_ACCESS_W_OK
end_undef

begin_undef
undef|#
directive|undef
name|PERL_EFF_ACCESS_X_OK
end_undef

begin_comment
comment|/* F_OK unused: if stat() cannot find it... */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EFF_ACCESS_R_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|EFF_ONLY_OK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_EFF_ONLY_OK
argument_list|)
end_if

begin_comment
comment|/* Digital UNIX (when the EFF_ONLY_OK gets fixed), UnixWare */
end_comment

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_R_OK
parameter_list|(
name|p
parameter_list|)
value|(access((p), R_OK | EFF_ONLY_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_W_OK
parameter_list|(
name|p
parameter_list|)
value|(access((p), W_OK | EFF_ONLY_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_X_OK
parameter_list|(
name|p
parameter_list|)
value|(access((p), X_OK | EFF_ONLY_OK))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EFF_ACCESS_R_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_EACCESS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_SECURITY
end_ifdef

begin_include
include|#
directive|include
file|<sys/security.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ACC_SELF
end_ifdef

begin_comment
comment|/* HP SecureWare */
end_comment

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_R_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), R_OK, ACC_SELF))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_W_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), W_OK, ACC_SELF))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_X_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), X_OK, ACC_SELF))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SCO */
end_comment

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_R_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), R_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_W_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), W_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_X_OK
parameter_list|(
name|p
parameter_list|)
value|(eaccess((p), X_OK))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EFF_ACCESS_R_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ACCESSX
argument_list|)
operator|&&
name|defined
argument_list|(
name|ACC_SELF
argument_list|)
end_if

begin_comment
comment|/* AIX */
end_comment

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_R_OK
parameter_list|(
name|p
parameter_list|)
value|(accessx((p), R_OK, ACC_SELF))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_W_OK
parameter_list|(
name|p
parameter_list|)
value|(accessx((p), W_OK, ACC_SELF))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_X_OK
parameter_list|(
name|p
parameter_list|)
value|(accessx((p), X_OK, ACC_SELF))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EFF_ACCESS_R_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ACCESS
argument_list|)
expr|\
operator|&&
operator|(
name|defined
argument_list|(
name|HAS_SETREUID
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SETRESUID
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|HAS_SETREGID
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SETRESGID
argument_list|)
operator|)
end_if

begin_comment
comment|/* The Hard Way. */
end_comment

begin_function
name|STATIC
name|int
name|S_emulate_eaccess
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|Mode_t
name|mode
parameter_list|)
block|{
name|Uid_t
name|ruid
init|=
name|getuid
argument_list|()
decl_stmt|;
name|Uid_t
name|euid
init|=
name|geteuid
argument_list|()
decl_stmt|;
name|Gid_t
name|rgid
init|=
name|getgid
argument_list|()
decl_stmt|;
name|Gid_t
name|egid
init|=
name|getegid
argument_list|()
decl_stmt|;
name|int
name|res
decl_stmt|;
name|LOCK_CRED_MUTEX
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_SETREUID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_SETRESUID
argument_list|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"switching effective uid is not implemented"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
if|if
condition|(
name|setreuid
argument_list|(
name|euid
argument_list|,
name|ruid
argument_list|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
if|if
condition|(
name|setresuid
argument_list|(
name|euid
argument_list|,
name|ruid
argument_list|,
operator|(
name|Uid_t
operator|)
operator|-
literal|1
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
name|Perl_croak
argument_list|(
name|aTHX_
literal|"entering effective uid failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_SETREGID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_SETRESGID
argument_list|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"switching effective gid is not implemented"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
if|if
condition|(
name|setregid
argument_list|(
name|egid
argument_list|,
name|rgid
argument_list|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESGID
if|if
condition|(
name|setresgid
argument_list|(
name|egid
argument_list|,
name|rgid
argument_list|,
operator|(
name|Gid_t
operator|)
operator|-
literal|1
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
name|Perl_croak
argument_list|(
name|aTHX_
literal|"entering effective gid failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res
operator|=
name|access
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETREUID
if|if
condition|(
name|setreuid
argument_list|(
name|ruid
argument_list|,
name|euid
argument_list|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
if|if
condition|(
name|setresuid
argument_list|(
name|ruid
argument_list|,
name|euid
argument_list|,
operator|(
name|Uid_t
operator|)
operator|-
literal|1
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
name|Perl_croak
argument_list|(
name|aTHX_
literal|"leaving effective uid failed"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETREGID
if|if
condition|(
name|setregid
argument_list|(
name|rgid
argument_list|,
name|egid
argument_list|)
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESGID
if|if
condition|(
name|setresgid
argument_list|(
name|rgid
argument_list|,
name|egid
argument_list|,
operator|(
name|Gid_t
operator|)
operator|-
literal|1
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
name|Perl_croak
argument_list|(
name|aTHX_
literal|"leaving effective gid failed"
argument_list|)
expr_stmt|;
name|UNLOCK_CRED_MUTEX
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_R_OK
parameter_list|(
name|p
parameter_list|)
value|(emulate_eaccess((p), R_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_W_OK
parameter_list|(
name|p
parameter_list|)
value|(emulate_eaccess((p), W_OK))
end_define

begin_define
define|#
directive|define
name|PERL_EFF_ACCESS_X_OK
parameter_list|(
name|p
parameter_list|)
value|(emulate_eaccess((p), X_OK))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EFF_ACCESS_R_OK
argument_list|)
end_if

begin_function
name|STATIC
name|int
name|S_emulate_eaccess
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|Mode_t
name|mode
parameter_list|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"switching effective uid is not implemented"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_backtick
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|POPpx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|char
modifier|*
name|mode
init|=
literal|"r"
decl_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"``"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpOPEN_IN_RAW
condition|)
name|mode
operator|=
literal|"rb"
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpOPEN_IN_CRLF
condition|)
name|mode
operator|=
literal|"rt"
expr_stmt|;
name|fp
operator|=
name|PerlProc_popen
argument_list|(
name|tmps
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
while|while
condition|(
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|)
operator|>
literal|0
condition|)
comment|/*SUPPRESS 530*/
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* note that this preserves previous buffer */
while|while
condition|(
name|sv_gets
argument_list|(
name|TARG
argument_list|,
name|fp
argument_list|,
name|SvCUR
argument_list|(
name|TARG
argument_list|)
argument_list|)
operator|!=
name|Nullch
condition|)
comment|/*SUPPRESS 530*/
empty_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|56
argument_list|,
literal|79
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv_gets
argument_list|(
name|sv
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|==
name|Nullch
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|>
literal|20
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|STATUS_NATIVE_SET
argument_list|(
name|PerlProc_pclose
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|TAINT
expr_stmt|;
comment|/* "I believe that this is not gratuitous!" */
block|}
else|else
block|{
name|STATUS_NATIVE_SET
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_glob
argument_list|)
end_macro

begin_block
block|{
name|OP
modifier|*
name|result
decl_stmt|;
name|tryAMAGICunTARGET
argument_list|(
name|iter
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we only ever get here if File::Glob fails to load      * without at the same time croaking, for some reason, or if      * perl was built with PERL_EXTERNAL_GLOB */
name|ENTER
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|PL_tainting
condition|)
block|{
comment|/* 	 * The external globbing program may use things we can't control, 	 * so for security reasons we must assume the worst. 	 */
name|TAINT
expr_stmt|;
name|taint_proper
argument_list|(
name|PL_no_security
argument_list|,
literal|"glob"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !VMS */
name|SAVESPTR
argument_list|(
name|PL_last_in_gv
argument_list|)
expr_stmt|;
comment|/* We don't want this to be permanent. */
name|PL_last_in_gv
operator|=
operator|(
name|GV
operator|*
operator|)
operator|*
name|PL_stack_sp
operator|--
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
comment|/* This is not permanent, either. */
name|PL_rs
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|"\000"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DOSISH
ifndef|#
directive|ifndef
name|CSH
operator|*
name|SvPVX
argument_list|(
name|PL_rs
argument_list|)
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
comment|/* !CSH */
endif|#
directive|endif
comment|/* !DOSISH */
name|result
operator|=
name|do_readline
argument_list|()
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX never used! */
end_comment

begin_endif
unit|PP(pp_indread) {     STRLEN n_a;     PL_last_in_gv = gv_fetchpv(SvPVx(GvSV((GV*)(*PL_stack_sp--)), n_a), TRUE,SVt_PVIO);     return do_readline(); }
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_rcatline
argument_list|)
end_macro

begin_block
block|{
name|PL_last_in_gv
operator|=
name|cGVOP_gv
expr_stmt|;
return|return
name|do_readline
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_warn
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SP
operator|-
name|MARK
operator|!=
literal|1
condition|)
block|{
name|dTARGET
expr_stmt|;
name|do_join
argument_list|(
name|TARG
argument_list|,
operator|&
name|PL_sv_no
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|tmpsv
operator|=
name|TARG
expr_stmt|;
name|SP
operator|=
name|MARK
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmpsv
operator|=
name|TOPs
expr_stmt|;
block|}
name|tmps
operator|=
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
name|len
condition|)
block|{
name|SV
modifier|*
name|error
init|=
name|ERRSV
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|error
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|error
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|error
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|error
argument_list|,
literal|"\t...caught"
argument_list|)
expr_stmt|;
name|tmpsv
operator|=
name|error
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
name|len
condition|)
name|tmpsv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|"Warning: something's wrong"
argument_list|,
literal|26
argument_list|)
argument_list|)
expr_stmt|;
name|Perl_warn
argument_list|(
name|aTHX_
literal|"%"
name|SVf
argument_list|,
name|tmpsv
argument_list|)
expr_stmt|;
name|RETSETYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_die
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|bool
name|multiarg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SP
operator|-
name|MARK
operator|!=
literal|1
condition|)
block|{
name|dTARGET
expr_stmt|;
name|do_join
argument_list|(
name|TARG
argument_list|,
operator|&
name|PL_sv_no
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|tmpsv
operator|=
name|TARG
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|multiarg
operator|=
literal|1
expr_stmt|;
name|SP
operator|=
name|MARK
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmpsv
operator|=
name|TOPs
expr_stmt|;
name|tmps
operator|=
name|SvROK
argument_list|(
name|tmpsv
argument_list|)
condition|?
name|Nullch
else|:
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
name|len
condition|)
block|{
name|SV
modifier|*
name|error
init|=
name|ERRSV
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|error
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiarg
condition|?
name|SvROK
argument_list|(
name|error
argument_list|)
else|:
name|SvROK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|multiarg
condition|)
name|SvSetSV
argument_list|(
name|error
argument_list|,
name|tmpsv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sv_isobject
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|HV
modifier|*
name|stash
init|=
name|SvSTASH
argument_list|(
name|SvRV
argument_list|(
name|error
argument_list|)
argument_list|)
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
literal|"PROPAGATE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|SV
modifier|*
name|file
init|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|line
init|=
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|G_SCALAR
operator||
name|G_EVAL
operator||
name|G_KEEPERR
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|error
argument_list|,
operator|*
name|PL_stack_sp
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
name|DIE
argument_list|(
argument|aTHX_ Nullch
argument_list|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|error
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|error
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|error
argument_list|,
literal|"\t...propagated"
argument_list|)
expr_stmt|;
name|tmpsv
operator|=
name|error
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
name|len
condition|)
name|tmpsv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|"Died"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"%"
name|SVf
argument_list|,
name|tmpsv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* I/O. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_open
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
name|name
init|=
name|Nullsv
decl_stmt|;
name|I32
name|have_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|>
literal|2
condition|)
block|{
name|name
operator|=
name|POPs
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|MAXARG
operator|>
literal|1
condition|)
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|isGV
argument_list|(
name|TOPs
argument_list|)
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"filehandle"
argument_list|)
empty_stmt|;
if|if
condition|(
name|MAXARG
operator|<=
literal|1
condition|)
name|sv
operator|=
name|GvSV
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"filehandle"
argument_list|)
empty_stmt|;
if|if
condition|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
condition|)
name|IoFLAGS
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|&=
operator|~
name|IOf_UNTAINT
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_name
condition|)
name|XPUSHs
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"OPEN"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open9
argument_list|(
name|gv
argument_list|,
name|tmps
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|,
name|name
argument_list|,
name|have_name
argument_list|)
condition|)
name|PUSHi
argument_list|(
operator|(
name|I32
operator|)
name|PL_forkprocess
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_forkprocess
operator|==
literal|0
condition|)
comment|/* we are a new child */
name|PUSHi
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_close
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
name|gv
operator|=
name|PL_defoutgv
expr_stmt|;
else|else
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"CLOSE"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|boolSV
argument_list|(
name|do_close
argument_list|(
name|gv
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_pipe_op
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_PIPE
name|GV
modifier|*
name|rgv
decl_stmt|;
name|GV
modifier|*
name|wgv
decl_stmt|;
specifier|register
name|IO
modifier|*
name|rstio
decl_stmt|;
specifier|register
name|IO
modifier|*
name|wstio
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|wgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
name|rgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|rgv
operator|||
operator|!
name|wgv
condition|)
goto|goto
name|badexit
goto|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|rgv
argument_list|)
operator|!=
name|SVt_PVGV
operator|||
name|SvTYPE
argument_list|(
name|wgv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"filehandle"
argument_list|)
empty_stmt|;
name|rstio
operator|=
name|GvIOn
argument_list|(
name|rgv
argument_list|)
expr_stmt|;
name|wstio
operator|=
name|GvIOn
argument_list|(
name|wgv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|rgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|wgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoIFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|IoOFP
argument_list|(
name|wstio
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|rstio
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
name|IoTYPE
argument_list|(
name|wstio
argument_list|)
operator|=
name|IoTYPE_WRONLY
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fcntl
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fd
index|[
literal|0
index|]
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
name|fcntl
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fd
index|[
literal|1
index|]
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
endif|#
directive|endif
name|RETPUSHYES
expr_stmt|;
name|badexit
label|:
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"pipe"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fileno
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"FILENO"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gv
operator|||
operator|!
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHi
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_umask
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Mode_t
name|anum
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_UMASK
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
block|{
name|anum
operator|=
name|PerlLIO_umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_umask
argument_list|(
name|anum
argument_list|)
expr_stmt|;
block|}
else|else
name|anum
operator|=
name|PerlLIO_umask
argument_list|(
name|POPi
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"umask"
argument_list|)
expr_stmt|;
name|XPUSHi
argument_list|(
name|anum
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Only DIE if trying to restrict permissions on `user' (self).      * Otherwise it's harmless and more useful to just return undef      * since 'group' and 'other' concepts probably don't exist here. */
if|if
condition|(
name|MAXARG
operator|>=
literal|1
operator|&&
operator|(
name|POPi
operator|&
literal|0700
operator|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"umask not implemented"
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_binmode
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|SV
modifier|*
name|discp
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|>
literal|1
condition|)
name|discp
operator|=
name|POPs
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|discp
condition|)
name|XPUSHs
argument_list|(
name|discp
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"BINMODE"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|do_binmode
argument_list|(
name|fp
argument_list|,
name|IoTYPE
argument_list|(
name|io
argument_list|)
argument_list|,
name|mode_from_discipline
argument_list|(
name|discp
argument_list|)
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_tie
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|SV
modifier|*
name|varsv
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|markoff
init|=
name|MARK
operator|-
name|PL_stack_base
decl_stmt|;
name|char
modifier|*
name|methname
decl_stmt|;
name|int
name|how
init|=
literal|'P'
decl_stmt|;
name|U32
name|items
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|varsv
operator|=
operator|*
operator|++
name|MARK
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|varsv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVHV
case|:
name|methname
operator|=
literal|"TIEHASH"
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|methname
operator|=
literal|"TIEARRAY"
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|methname
operator|=
literal|"TIEHANDLE"
expr_stmt|;
name|how
operator|=
literal|'q'
expr_stmt|;
break|break;
default|default:
name|methname
operator|=
literal|"TIESCALAR"
expr_stmt|;
name|how
operator|=
literal|'q'
expr_stmt|;
break|break;
block|}
name|items
operator|=
name|SP
operator|-
name|MARK
operator|++
expr_stmt|;
if|if
condition|(
name|sv_isobject
argument_list|(
operator|*
name|MARK
argument_list|)
condition|)
block|{
name|ENTER
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|items
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
name|PUSHs
argument_list|(
operator|*
name|MARK
operator|++
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_method
argument_list|(
name|methname
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not clear why we don't call call_method here too. 	 * perhaps to get different error message ? 	 */
name|stash
operator|=
name|gv_stashsv
argument_list|(
operator|*
name|MARK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
operator|!
operator|(
name|gv
operator|=
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
name|methname
argument_list|)
operator|)
condition|)
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Can't locate object method \"%s\" via package \"%s\""
argument_list|,
name|methname
argument_list|,
name|SvPV
argument_list|(
operator|*
name|MARK
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ENTER
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_MAGIC
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|items
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
name|PUSHs
argument_list|(
operator|*
name|MARK
operator|++
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
block|}
name|SPAGAIN
expr_stmt|;
name|sv
operator|=
name|TOPs
expr_stmt|;
name|POPSTACK
expr_stmt|;
if|if
condition|(
name|sv_isobject
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|varsv
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|varsv
argument_list|,
operator|(
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|==
name|varsv
condition|?
name|Nullsv
else|:
name|sv
operator|)
argument_list|,
name|how
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|SP
operator|=
name|PL_stack_base
operator|+
name|markoff
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_untie
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|char
name|how
init|=
operator|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVHV
operator|||
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVAV
operator|)
condition|?
literal|'P'
else|:
literal|'q'
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
name|sv
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|obj
init|=
name|SvRV
argument_list|(
name|mg
operator|->
name|mg_obj
argument_list|)
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchmethod_autoload
argument_list|(
name|SvSTASH
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"UNTIE"
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
name|isGV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|SvREFCNT
argument_list|(
name|obj
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_VOID
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNTIE
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg
operator|&&
name|SvREFCNT
argument_list|(
name|obj
argument_list|)
operator|>
literal|1
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_UNTIE
argument_list|,
literal|"untie attempted while %"
argument|UVuf
literal|" inner references still exist"
argument_list|,
argument|(UV)SvREFCNT(obj) -
literal|1
argument_list|)
empty_stmt|;
block|}
block|}
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_tied
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|char
name|how
init|=
operator|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVHV
operator|||
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVAV
operator|)
condition|?
literal|'P'
else|:
literal|'q'
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
name|sv
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|osv
init|=
name|SvTIED_obj
argument_list|(
name|sv
argument_list|,
name|mg
argument_list|)
decl_stmt|;
if|if
condition|(
name|osv
operator|==
name|mg
operator|->
name|mg_obj
condition|)
name|osv
operator|=
name|sv_mortalcopy
argument_list|(
name|osv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|osv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_dbmopen
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|dPOPPOPssrl
expr_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
literal|"AnyDBM_File"
argument_list|)
expr_stmt|;
name|stash
operator|=
name|gv_stashsv
argument_list|(
name|sv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
operator|!
operator|(
name|gv
operator|=
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
literal|"TIEHASH"
argument_list|)
operator|)
condition|)
block|{
name|PUTBACK
expr_stmt|;
name|require_pv
argument_list|(
literal|"AnyDBM_File.pm"
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gv
operator|=
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
literal|"TIEHASH"
argument_list|)
operator|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"No dbm on this machine"
argument_list|)
expr_stmt|;
block|}
name|ENTER
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIV
argument_list|(
name|right
argument_list|)
condition|)
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|O_RDWR
operator||
name|O_CREAT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|O_RDWR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
operator|!
name|sv_isobject
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|SP
operator|--
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|O_RDONLY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
if|if
condition|(
name|sv_isobject
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|TOPs
argument_list|,
literal|'P'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_dbmclose
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_untie
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sselect
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SELECT
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|NV
name|value
decl_stmt|;
name|I32
name|maxlen
init|=
literal|0
decl_stmt|;
name|I32
name|nfound
decl_stmt|;
name|struct
name|timeval
name|timebuf
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tbuf
init|=
operator|&
name|timebuf
decl_stmt|;
name|I32
name|growsize
decl_stmt|;
name|char
modifier|*
name|fd_sets
index|[
literal|4
index|]
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x1234
operator|&&
name|BYTEORDER
operator|!=
literal|0x12345678
name|I32
name|masksize
decl_stmt|;
name|I32
name|offset
decl_stmt|;
name|I32
name|k
decl_stmt|;
if|#
directive|if
name|BYTEORDER
operator|&
literal|0xf0000
define|#
directive|define
name|ORDERBYTE
value|(0x88888888 - BYTEORDER)
else|#
directive|else
define|#
directive|define
name|ORDERBYTE
value|(0x4444 - BYTEORDER)
endif|#
directive|endif
endif|#
directive|endif
name|SP
operator|-=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|SP
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|j
operator|=
name|SvCUR
argument_list|(
name|SP
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<
name|j
condition|)
name|maxlen
operator|=
name|j
expr_stmt|;
block|}
comment|/* little endians can use vecs directly */
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
operator|||
name|BYTEORDER
operator|==
literal|0x12345678
if|#
directive|if
name|SELECT_MIN_BITS
operator|>
literal|1
comment|/* If SELECT_MIN_BITS is greater than one we most probably will want      * to align the sizes with SELECT_MIN_BITS/8 because for example      * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital      * UNIX, Solaris, NeXT, Darwin) the smallest quantum select() operates      * on (sets/tests/clears bits) is 32 bits.  */
name|growsize
operator|=
name|maxlen
operator|+
operator|(
name|SELECT_MIN_BITS
operator|/
literal|8
operator|-
operator|(
name|maxlen
operator|%
operator|(
name|SELECT_MIN_BITS
operator|/
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|growsize
operator|=
sizeof|sizeof
argument_list|(
name|fd_set
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|NFDBITS
ifndef|#
directive|ifndef
name|NBBY
define|#
directive|define
name|NBBY
value|8
endif|#
directive|endif
name|masksize
operator|=
name|NFDBITS
operator|/
name|NBBY
expr_stmt|;
else|#
directive|else
name|masksize
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* documented int, everyone seems to use long */
endif|#
directive|endif
name|growsize
operator|=
name|maxlen
operator|+
operator|(
name|masksize
operator|-
operator|(
name|maxlen
operator|%
name|masksize
operator|)
operator|)
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|fd_sets
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv
operator|=
name|SP
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|value
operator|=
name|SvNV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
literal|0.0
expr_stmt|;
name|timebuf
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|value
expr_stmt|;
name|value
operator|-=
operator|(
name|NV
operator|)
name|timebuf
operator|.
name|tv_sec
expr_stmt|;
name|timebuf
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|value
operator|*
literal|1000000.0
argument_list|)
expr_stmt|;
block|}
else|else
name|tbuf
operator|=
name|Null
argument_list|(
expr|struct
name|timeval
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|sv
operator|=
name|SP
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|fd_sets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
comment|/* force string conversion */
name|j
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|growsize
condition|)
block|{
name|Sv_Grow
argument_list|(
name|sv
argument_list|,
name|growsize
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|j
expr_stmt|;
while|while
condition|(
operator|++
name|j
operator|<=
name|growsize
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x1234
operator|&&
name|BYTEORDER
operator|!=
literal|0x12345678
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|403
argument_list|,
name|fd_sets
index|[
name|i
index|]
argument_list|,
name|growsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|growsize
condition|;
name|offset
operator|+=
name|masksize
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|ORDERBYTE
init|;
name|j
operator|<
name|masksize
condition|;
name|j
operator|++
operator|,
operator|(
name|k
operator|>>=
literal|4
operator|)
control|)
name|fd_sets
index|[
name|i
index|]
index|[
name|j
operator|+
name|offset
index|]
operator|=
name|s
index|[
operator|(
name|k
operator|%
name|masksize
operator|)
operator|+
name|offset
index|]
expr_stmt|;
block|}
else|#
directive|else
name|fd_sets
index|[
name|i
index|]
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|nfound
operator|=
name|PerlSock_select
argument_list|(
name|maxlen
operator|*
literal|8
argument_list|,
operator|(
name|Select_fd_set_t
operator|)
name|fd_sets
index|[
literal|1
index|]
argument_list|,
operator|(
name|Select_fd_set_t
operator|)
name|fd_sets
index|[
literal|2
index|]
argument_list|,
operator|(
name|Select_fd_set_t
operator|)
name|fd_sets
index|[
literal|3
index|]
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fd_sets
index|[
name|i
index|]
condition|)
block|{
name|sv
operator|=
name|SP
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x1234
operator|&&
name|BYTEORDER
operator|!=
literal|0x12345678
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|growsize
condition|;
name|offset
operator|+=
name|masksize
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|ORDERBYTE
init|;
name|j
operator|<
name|masksize
condition|;
name|j
operator|++
operator|,
operator|(
name|k
operator|>>=
literal|4
operator|)
control|)
name|s
index|[
operator|(
name|k
operator|%
name|masksize
operator|)
operator|+
name|offset
index|]
operator|=
name|fd_sets
index|[
name|i
index|]
index|[
name|j
operator|+
name|offset
index|]
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|fd_sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|PUSHi
argument_list|(
name|nfound
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
operator|&&
name|tbuf
condition|)
block|{
name|value
operator|=
call|(
name|NV
call|)
argument_list|(
name|timebuf
operator|.
name|tv_sec
argument_list|)
operator|+
call|(
name|NV
call|)
argument_list|(
name|timebuf
operator|.
name|tv_usec
argument_list|)
operator|/
literal|1000000.0
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"select not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|void
name|Perl_setdefout
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|)
block|{
if|if
condition|(
name|gv
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_defoutgv
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_defoutgv
argument_list|)
expr_stmt|;
name|PL_defoutgv
operator|=
name|gv
expr_stmt|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_select
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|newdefout
decl_stmt|,
modifier|*
name|egv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|newdefout
operator|=
operator|(
name|PL_op
operator|->
name|op_private
operator|>
literal|0
operator|)
condition|?
operator|(
operator|(
name|GV
operator|*
operator|)
name|POPs
operator|)
else|:
operator|(
name|GV
operator|*
operator|)
name|NULL
expr_stmt|;
name|egv
operator|=
name|GvEGV
argument_list|(
name|PL_defoutgv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|egv
condition|)
name|egv
operator|=
name|PL_defoutgv
expr_stmt|;
name|hv
operator|=
name|GvSTASH
argument_list|(
name|egv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|XPUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|GV
modifier|*
modifier|*
name|gvp
init|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|GvNAME
argument_list|(
name|egv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|egv
argument_list|)
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|gvp
operator|&&
operator|*
name|gvp
operator|==
name|egv
condition|)
block|{
name|gv_efullname4
argument_list|(
name|TARG
argument_list|,
name|PL_defoutgv
argument_list|,
name|Nullch
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|XPUSHTARG
expr_stmt|;
block|}
else|else
block|{
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newRV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|egv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newdefout
condition|)
block|{
if|if
condition|(
operator|!
name|GvIO
argument_list|(
name|newdefout
argument_list|)
condition|)
name|gv_IOadd
argument_list|(
name|newdefout
argument_list|)
expr_stmt|;
name|setdefout
argument_list|(
name|newdefout
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_getc
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
name|gv
operator|=
name|PL_stdingv
expr_stmt|;
else|else
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"GETC"
argument_list|,
name|gimme
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
name|SvSetMagicSV_nosteal
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gv
operator|||
name|do_eof
argument_list|(
name|gv
argument_list|)
condition|)
comment|/* make sure we have fp with something */
name|RETPUSHUNDEF
expr_stmt|;
name|TAINT
expr_stmt|;
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|SvPVX
argument_list|(
name|TARG
argument_list|)
operator|=
name|PerlIO_getc
argument_list|(
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should never be EOF */
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_read
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_sysread
argument_list|()
return|;
block|}
end_block

begin_function
name|STATIC
name|OP
modifier|*
name|S_doform
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|cv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
name|OP
modifier|*
name|retop
parameter_list|)
block|{
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|push_return
argument_list|(
name|retop
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_FORMAT
argument_list|,
name|PL_stack_sp
argument_list|)
expr_stmt|;
name|PUSHFORMAT
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|setdefout
argument_list|(
name|gv
argument_list|)
expr_stmt|;
comment|/* locally select filehandle so $% et al work */
return|return
name|CvSTART
argument_list|(
name|cv
argument_list|)
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_enterwrite
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|fgv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
name|gv
operator|=
name|PL_defoutgv
expr_stmt|;
else|else
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
name|gv
operator|=
name|PL_defoutgv
expr_stmt|;
block|}
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
block|{
name|RETPUSHNO
expr_stmt|;
block|}
if|if
condition|(
name|IoFMT_GV
argument_list|(
name|io
argument_list|)
condition|)
name|fgv
operator|=
name|IoFMT_GV
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
name|fgv
operator|=
name|gv
expr_stmt|;
name|cv
operator|=
name|GvFORM
argument_list|(
name|fgv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fgv
condition|)
block|{
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|tmpsv
argument_list|,
name|fgv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Undefined format \"%s\" called"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"Not a format reference"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&=
operator|~
name|IOf_DIDTOP
expr_stmt|;
return|return
name|doform
argument_list|(
name|cv
argument_list|,
name|gv
argument_list|,
name|PL_op
operator|->
name|op_next
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_leavewrite
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
init|=
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_sub
operator|.
name|gv
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOp
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|PerlIO
modifier|*
name|ofp
init|=
name|IoOFP
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|DEBUG_f
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"left=%ld, todo=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|<
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|&&
name|PL_formtarget
operator|!=
name|PL_toptarget
condition|)
block|{
name|GV
modifier|*
name|fgv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|!
name|IoTOP_GV
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|GV
modifier|*
name|topgv
decl_stmt|;
name|SV
modifier|*
name|topname
decl_stmt|;
if|if
condition|(
operator|!
name|IoTOP_NAME
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IoFMT_NAME
argument_list|(
name|io
argument_list|)
condition|)
name|IoFMT_NAME
argument_list|(
name|io
argument_list|)
operator|=
name|savepv
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|topname
operator|=
name|sv_2mortal
argument_list|(
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%s_TOP"
argument_list|,
name|IoFMT_NAME
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|topgv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPVX
argument_list|(
name|topname
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVFM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|topgv
operator|&&
name|GvFORM
argument_list|(
name|topgv
argument_list|)
operator|)
operator|||
operator|!
name|gv_fetchpv
argument_list|(
literal|"top"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVFM
argument_list|)
condition|)
name|IoTOP_NAME
argument_list|(
name|io
argument_list|)
operator|=
name|savepv
argument_list|(
name|SvPVX
argument_list|(
name|topname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|IoTOP_NAME
argument_list|(
name|io
argument_list|)
operator|=
name|savepv
argument_list|(
literal|"top"
argument_list|)
expr_stmt|;
block|}
name|topgv
operator|=
name|gv_fetchpv
argument_list|(
name|IoTOP_NAME
argument_list|(
name|io
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVFM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|topgv
operator|||
operator|!
name|GvFORM
argument_list|(
name|topgv
argument_list|)
condition|)
block|{
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|=
literal|100000000
expr_stmt|;
goto|goto
name|forget_top
goto|;
block|}
name|IoTOP_GV
argument_list|(
name|io
argument_list|)
operator|=
name|topgv
expr_stmt|;
block|}
if|if
condition|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_DIDTOP
condition|)
block|{
comment|/* Oh dear.  It still doesn't fit. */
name|I32
name|lines
init|=
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|lines
operator|<=
literal|0
condition|)
comment|/* Yow, header didn't even fit!!! */
goto|goto
name|forget_top
goto|;
while|while
condition|(
name|lines
operator|--
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
block|{
name|PerlIO_write
argument_list|(
name|ofp
argument_list|,
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|,
name|s
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|sv_chop
argument_list|(
name|PL_formtarget
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|-=
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|>=
literal|0
operator|&&
name|IoPAGE
argument_list|(
name|io
argument_list|)
operator|>
literal|0
condition|)
name|PerlIO_write
argument_list|(
name|ofp
argument_list|,
name|SvPVX
argument_list|(
name|PL_formfeed
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|PL_formfeed
argument_list|)
argument_list|)
expr_stmt|;
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|=
name|IoPAGE_LEN
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|IoPAGE
argument_list|(
name|io
argument_list|)
operator|++
expr_stmt|;
name|PL_formtarget
operator|=
name|PL_toptarget
expr_stmt|;
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator||=
name|IOf_DIDTOP
expr_stmt|;
name|fgv
operator|=
name|IoTOP_GV
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgv
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"bad top format reference"
argument_list|)
expr_stmt|;
name|cv
operator|=
name|GvFORM
argument_list|(
name|fgv
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|fgv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Undefined top format \"%s\" called"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* why no: 	    else 	        DIE(aTHX_ "Undefined top format called"); 	    ?*/
block|}
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|doform
argument_list|(
name|cv
argument_list|,
name|gv
argument_list|,
name|PL_op
argument_list|)
return|;
block|}
name|forget_top
label|:
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPFORMAT
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|fp
operator|=
name|IoOFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_CLOSED
argument_list|,
name|WARN_IO
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
comment|/* integrate with report_evil_fh()? */
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle %s opened only for input"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle opened only for input"
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|-=
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_IO
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"page overflow"
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|PerlIO_write
argument_list|(
name|ofp
argument_list|,
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
operator|||
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
else|else
block|{
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|PL_formtarget
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_FLUSH
condition|)
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_formtarget
operator|=
name|PL_bodytarget
expr_stmt|;
name|PUTBACK
expr_stmt|;
return|return
name|pop_return
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_prtf
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
operator|*
operator|++
name|MARK
expr_stmt|;
else|else
name|gv
operator|=
name|PL_defoutgv
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|MARK
operator|==
name|ORIGMARK
condition|)
block|{
name|MEXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|MARK
expr_stmt|;
name|Move
argument_list|(
name|MARK
argument_list|,
name|MARK
operator|+
literal|1
argument_list|,
operator|(
name|SP
operator|-
name|MARK
operator|)
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
operator|++
name|SP
expr_stmt|;
block|}
name|PUSHMARK
argument_list|(
name|MARK
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"PRINTF"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|MARK
operator|=
name|ORIGMARK
operator|+
literal|1
expr_stmt|;
operator|*
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
goto|goto
name|just_say_no
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_CLOSED
argument_list|,
name|WARN_IO
argument_list|)
condition|)
block|{
comment|/* integrate with report_evil_fh()? */
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle %s opened only for input"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle opened only for input"
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
block|}
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|?
name|RMS$_FAC
else|:
name|RMS$_IFI
argument_list|)
expr_stmt|;
goto|goto
name|just_say_no
goto|;
block|}
else|else
block|{
name|do_sprintf
argument_list|(
name|sv
argument_list|,
name|SP
operator|-
name|MARK
argument_list|,
name|MARK
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_print
argument_list|(
name|sv
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|just_say_no
goto|;
if|if
condition|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_FLUSH
condition|)
if|if
condition|(
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|just_say_no
goto|;
block|}
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
name|just_say_no
label|:
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sysopen
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|perm
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|>
literal|3
condition|)
name|perm
operator|=
name|POPi
expr_stmt|;
else|else
name|perm
operator|=
literal|0666
expr_stmt|;
name|mode
operator|=
name|POPi
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
comment|/* Need TIEHANDLE method ? */
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open
argument_list|(
name|gv
argument_list|,
name|tmps
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|,
name|mode
argument_list|,
name|perm
argument_list|,
name|Nullfp
argument_list|)
condition|)
block|{
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sysread
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|offset
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|SSize_t
name|length
decl_stmt|;
name|Sock_size_t
name|bufsize
decl_stmt|;
name|SV
modifier|*
name|bufsv
decl_stmt|;
name|STRLEN
name|blen
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
operator|*
operator|++
name|MARK
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_READ
operator|||
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SYSREAD
operator|)
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"READ"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gv
condition|)
goto|goto
name|say_undef
goto|;
name|bufsv
operator|=
operator|*
operator|++
name|MARK
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|bufsv
argument_list|)
condition|)
name|sv_setpvn
argument_list|(
name|bufsv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|SvPV_force
argument_list|(
name|bufsv
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|length
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Negative length"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
name|offset
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|say_undef
goto|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_RECV
condition|)
block|{
name|char
name|namebuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|VMS_DO_SOCKETS
argument_list|)
operator|&&
name|defined
argument_list|(
name|DECCRTL_SOCKETS
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|MPE
argument_list|)
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
else|#
directive|else
name|bufsize
operator|=
sizeof|sizeof
name|namebuf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS2
comment|/* At least Warp3+IAK: only the first byte of bufsize set */
if|if
condition|(
name|bufsize
operator|>=
literal|256
condition|)
name|bufsize
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|SvGROW
argument_list|(
name|bufsv
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 'offset' means 'flags' here */
name|length
operator|=
name|PerlSock_recvfrom
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|namebuf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
ifdef|#
directive|ifdef
name|EPOC
comment|/* Bogus return without padding */
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SvCUR_set
argument_list|(
name|bufsv
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|bufsv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
comment|/* This should not be marked tainted if the fp is marked clean */
if|if
condition|(
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_UNTAINT
operator|)
condition|)
name|SvTAINTED_on
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
name|namebuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_RECV
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"recv"
argument_list|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|offset
operator|>
name|blen
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Offset outside string"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|blen
expr_stmt|;
block|}
name|bufsize
operator|=
name|SvCUR
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|SvGROW
argument_list|(
name|bufsv
argument_list|,
name|length
operator|+
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|bufsize
condition|)
block|{
comment|/* Zero any newly allocated space */
name|Zero
argument_list|(
name|buffer
operator|+
name|bufsize
argument_list|,
name|offset
operator|-
name|bufsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SYSREAD
condition|)
block|{
ifdef|#
directive|ifdef
name|PERL_SOCK_SYSREAD_IS_RECV
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_SOCKET
condition|)
block|{
name|length
operator|=
name|PerlSock_recv
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|length
operator|=
name|PerlLIO_read
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|HAS_SOCKET__bad_code_maybe
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_SOCKET
condition|)
block|{
name|char
name|namebuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VMS_DO_SOCKETS
argument_list|)
operator|&&
name|defined
argument_list|(
name|DECCRTL_SOCKETS
argument_list|)
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
else|#
directive|else
name|bufsize
operator|=
sizeof|sizeof
name|namebuf
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
name|PerlSock_recvfrom
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|namebuf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|length
operator|=
name|PerlIO_read
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* fread() returns 0 on both error and EOF */
if|if
condition|(
name|length
operator|==
literal|0
operator|&&
name|PerlIO_error
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
name|length
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_WRONLY
operator|||
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|==
name|PerlIO_stdout
argument_list|()
operator|||
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|==
name|PerlIO_stderr
argument_list|()
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_IO
argument_list|)
condition|)
block|{
comment|/* integrate with report_evil_fh()? */
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle %s opened only for output"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle opened only for output"
argument_list|)
empty_stmt|;
block|}
goto|goto
name|say_undef
goto|;
block|}
name|SvCUR_set
argument_list|(
name|bufsv
argument_list|,
name|length
operator|+
name|offset
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|bufsv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
comment|/* This should not be marked tainted if the fp is marked clean */
if|if
condition|(
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_UNTAINT
operator|)
condition|)
name|SvTAINTED_on
argument_list|(
name|bufsv
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
name|say_undef
label|:
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_syswrite
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|int
name|items
init|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
name|TOPMARK
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|2
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|sv_len
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
block|}
return|return
name|pp_send
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_send
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|SV
modifier|*
name|bufsv
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|Size_t
name|length
decl_stmt|;
name|SSize_t
name|retval
decl_stmt|;
name|IV
name|offset
decl_stmt|;
name|STRLEN
name|blen
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
operator|*
operator|++
name|MARK
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SYSWRITE
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"WRITE"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gv
condition|)
goto|goto
name|say_undef
goto|;
name|bufsv
operator|=
operator|*
operator|++
name|MARK
expr_stmt|;
name|buffer
operator|=
name|SvPV
argument_list|(
name|bufsv
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|#
directive|if
name|Size_t_size
operator|>
name|IVSIZE
name|length
operator|=
operator|(
name|Size_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
else|#
directive|else
name|length
operator|=
operator|(
name|Size_t
operator|)
name|SvIVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|SSize_t
operator|)
name|length
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Negative length"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SYSWRITE
condition|)
block|{
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|offset
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|offset
operator|>
name|blen
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Offset outside string"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|blen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>=
name|blen
operator|&&
name|blen
operator|>
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Offset outside string"
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|blen
operator|-
name|offset
condition|)
name|length
operator|=
name|blen
operator|-
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_SOCK_SYSWRITE_IS_SEND
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_SOCKET
condition|)
block|{
name|retval
operator|=
name|PerlSock_send
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* See the note at doio.c:do_print about filesize limits. --jhi */
name|retval
operator|=
name|PerlLIO_write
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAS_SOCKET
elseif|else
if|if
condition|(
name|SP
operator|>
name|MARK
condition|)
block|{
name|char
modifier|*
name|sockbuf
decl_stmt|;
name|STRLEN
name|mlen
decl_stmt|;
name|sockbuf
operator|=
name|SvPVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PerlSock_sendto
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|blen
argument_list|,
name|length
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sockbuf
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|PerlSock_send
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|blen
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
else|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"send"
argument_list|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
if|#
directive|if
name|Size_t_size
operator|>
name|IVSIZE
name|PUSHn
argument_list|(
name|retval
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHi
argument_list|(
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
name|say_undef
label|:
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_recv
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_sysread
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_eof
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
comment|/* eof() */
name|IO
modifier|*
name|io
decl_stmt|;
name|gv
operator|=
name|PL_last_in_gv
operator|=
name|PL_argvgv
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|&&
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_START
operator|)
operator|&&
name|av_len
argument_list|(
name|GvAVn
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IoLINES
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&=
operator|~
name|IOf_START
expr_stmt|;
name|do_open
argument_list|(
name|gv
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nextargv
argument_list|(
name|gv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
block|}
else|else
name|gv
operator|=
name|PL_last_in_gv
expr_stmt|;
comment|/* eof */
block|}
else|else
name|gv
operator|=
name|PL_last_in_gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
comment|/* eof(FH) */
if|if
condition|(
name|gv
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"EOF"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|boolSV
argument_list|(
operator|!
name|gv
operator|||
name|do_eof
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_tell
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
name|gv
operator|=
name|PL_last_in_gv
expr_stmt|;
else|else
name|gv
operator|=
name|PL_last_in_gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"TELL"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|#
directive|if
name|LSEEKSIZE
operator|>
name|IVSIZE
name|PUSHn
argument_list|(
name|do_tell
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHi
argument_list|(
name|do_tell
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_seek
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_sysseek
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sysseek
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|int
name|whence
init|=
name|POPi
decl_stmt|;
if|#
directive|if
name|LSEEKSIZE
operator|>
name|IVSIZE
name|Off_t
name|offset
init|=
operator|(
name|Off_t
operator|)
name|SvNVx
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
else|#
directive|else
name|Off_t
name|offset
init|=
operator|(
name|Off_t
operator|)
name|SvIVx
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|gv
operator|=
name|PL_last_in_gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'q'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|LSEEKSIZE
operator|>
name|IVSIZE
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
operator|(
name|NV
operator|)
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|whence
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"SEEK"
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SEEK
condition|)
name|PUSHs
argument_list|(
name|boolSV
argument_list|(
name|do_seek
argument_list|(
name|gv
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Off_t
name|sought
init|=
name|do_sysseek
argument_list|(
name|gv
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
decl_stmt|;
if|if
condition|(
name|sought
operator|<
literal|0
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|sought
condition|?
if|#
directive|if
name|LSEEKSIZE
operator|>
name|IVSIZE
name|newSVnv
argument_list|(
argument|(NV)sought
argument_list|)
else|#
directive|else
name|newSViv
argument_list|(
name|sought
argument_list|)
endif|#
directive|endif
else|:
name|newSVpvn
argument_list|(
name|zero_but_true
argument_list|,
name|ZBTLEN
argument_list|)
decl_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_truncate
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
comment|/* There seems to be no consensus on the length type of truncate()      * and ftruncate(), both off_t and size_t have supporters. In      * general one would think that when using large files, off_t is      * at least as wide as size_t, so using an off_t should be okay. */
comment|/* XXX Configure probe for the length type of *truncate() needed XXX */
name|Off_t
name|len
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|GV
modifier|*
name|tmpgv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|#
directive|if
name|Size_t_size
operator|>
name|IVSIZE
name|len
operator|=
operator|(
name|Off_t
operator|)
name|POPn
expr_stmt|;
else|#
directive|else
name|len
operator|=
operator|(
name|Off_t
operator|)
name|POPi
expr_stmt|;
endif|#
directive|endif
comment|/* Checking for length< 0 is problematic as the type might or      * might not be signed: if it is not, clever compilers will moan. */
comment|/* XXX Configure probe for the signedness of the length type of *truncate() needed? XXX */
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_TRUNCATE
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_CHSIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|F_FREESP
argument_list|)
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
name|POPpx
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|do_ftruncate
label|:
name|TAINT_PROPER
argument_list|(
literal|"truncate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvIO
argument_list|(
name|tmpgv
argument_list|)
operator|||
operator|!
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|tmpgv
argument_list|)
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|PerlIO_flush
argument_list|(
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|tmpgv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TRUNCATE
if|if
condition|(
name|ftruncate
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOn
argument_list|(
name|tmpgv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|my_chsize
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOn
argument_list|(
name|tmpgv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|tmpgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
comment|/* *main::FRED for example */
goto|goto
name|do_ftruncate
goto|;
block|}
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|tmpgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* \*main::FRED for example */
goto|goto
name|do_ftruncate
goto|;
block|}
name|name
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"truncate"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TRUNCATE
if|if
condition|(
name|truncate
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|#
directive|else
block|{
name|int
name|tmpfd
decl_stmt|;
if|if
condition|(
operator|(
name|tmpfd
operator|=
name|PerlLIO_open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|my_chsize
argument_list|(
name|tmpfd
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|result
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"truncate not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fcntl
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_ioctl
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ioctl
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|argsv
init|=
name|POPs
decl_stmt|;
name|unsigned
name|int
name|func
init|=
name|U_I
argument_list|(
name|POPn
argument_list|)
decl_stmt|;
name|int
name|optype
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|IV
name|retval
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|argsv
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
comment|/* well, sort of... */
name|RETPUSHUNDEF
expr_stmt|;
block|}
if|if
condition|(
name|SvPOK
argument_list|(
name|argsv
argument_list|)
operator|||
operator|!
name|SvNIOK
argument_list|(
name|argsv
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|STRLEN
name|need
decl_stmt|;
name|s
operator|=
name|SvPV_force
argument_list|(
name|argsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|need
operator|=
name|IOCPARM_LEN
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|need
condition|)
block|{
name|s
operator|=
name|Sv_Grow
argument_list|(
name|argsv
argument_list|,
name|need
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|argsv
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
name|s
index|[
name|SvCUR
argument_list|(
name|argsv
argument_list|)
index|]
operator|=
literal|17
expr_stmt|;
comment|/* a little sanity check here */
block|}
else|else
block|{
name|retval
operator|=
name|SvIV
argument_list|(
name|argsv
argument_list|)
expr_stmt|;
name|s
operator|=
name|INT2PTR
argument_list|(
name|char
operator|*
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* ouch */
block|}
name|TAINT_PROPER
argument_list|(
name|optype
operator|==
name|OP_IOCTL
condition|?
literal|"ioctl"
else|:
literal|"fcntl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_IOCTL
condition|)
ifdef|#
directive|ifdef
name|HAS_IOCTL
name|retval
operator|=
name|PerlLIO_ioctl
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"ioctl is not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|HAS_FCNTL
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
name|defined
argument_list|(
name|__EMX__
argument_list|)
name|retval
operator|=
name|fcntl
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|fcntl
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"fcntl is not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SvPOK
argument_list|(
name|argsv
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
index|[
name|SvCUR
argument_list|(
name|argsv
argument_list|)
index|]
operator|!=
literal|17
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Possible memory corruption: %s overflowed 3rd argument"
argument_list|,
name|PL_op_name
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
name|s
index|[
name|SvCUR
argument_list|(
name|argsv
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
comment|/* put our null back */
name|SvSETMAGIC
argument_list|(
name|argsv
argument_list|)
expr_stmt|;
comment|/* Assume it has changed */
block|}
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|PUSHi
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHp
argument_list|(
name|zero_but_true
argument_list|,
name|ZBTLEN
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_flock
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|int
name|argtype
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|IO
modifier|*
name|io
init|=
name|NULL
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOCK
name|argtype
operator|=
name|POPi
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|0
condition|)
name|gv
operator|=
name|PL_last_in_gv
expr_stmt|;
else|else
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
else|else
block|{
name|fp
operator|=
name|Nullfp
expr_stmt|;
name|io
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|I32
call|)
argument_list|(
name|PerlLIO_flock
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|argtype
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
block|}
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"flock()"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Sockets. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_socket
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|GV
modifier|*
name|gv
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
name|int
name|protocol
init|=
name|POPi
decl_stmt|;
name|int
name|type
init|=
name|POPi
decl_stmt|;
name|int
name|domain
init|=
name|POPi
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
block|{
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|LIB$_INVARG
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|PerlSock_socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* stdio gets confused about sockets */
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|&&
operator|!
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPOC
name|setbuf
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* EPOC gets confused about sockets */
endif|#
directive|endif
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"socket"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sockpair
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SOCKETPAIR
name|GV
modifier|*
name|gv1
decl_stmt|;
name|GV
modifier|*
name|gv2
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io1
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io2
decl_stmt|;
name|int
name|protocol
init|=
name|POPi
decl_stmt|;
name|int
name|type
init|=
name|POPi
decl_stmt|;
name|int
name|domain
init|=
name|POPi
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|gv2
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
name|gv1
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|gv1
operator|||
operator|!
name|gv2
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|io1
operator|=
name|GvIOn
argument_list|(
name|gv1
argument_list|)
expr_stmt|;
name|io2
operator|=
name|GvIOn
argument_list|(
name|gv2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io1
argument_list|)
condition|)
name|do_close
argument_list|(
name|gv1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io2
argument_list|)
condition|)
name|do_close
argument_list|(
name|gv2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"socketpair"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlSock_socketpair
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|IoIFP
argument_list|(
name|io1
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|io1
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|io1
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
name|IoIFP
argument_list|(
name|io2
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|io2
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|io2
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|io1
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|io1
argument_list|)
operator|||
operator|!
name|IoIFP
argument_list|(
name|io2
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|io2
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|io1
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|io1
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|io1
argument_list|)
operator|&&
operator|!
name|IoOFP
argument_list|(
name|io1
argument_list|)
condition|)
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io2
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|io2
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|io2
argument_list|)
operator|&&
operator|!
name|IoOFP
argument_list|(
name|io2
argument_list|)
condition|)
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fcntl
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fd
index|[
literal|0
index|]
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
name|fcntl
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fd
index|[
literal|1
index|]
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
endif|#
directive|endif
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"socketpair"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bind
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
ifdef|#
directive|ifdef
name|MPE
comment|/* Requires PRIV mode to bind() to ports< 1024 */
extern|extern GETPRIVMODE(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GETUSERMODE(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|SV
modifier|*
name|addrsv
init|=
name|POPs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRLEN
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bind_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MPE
end_ifdef

begin_decl_stmt
name|int
name|mpeprivmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
end_if

begin_expr_stmt
name|addr
operator|=
name|SvPV
argument_list|(
name|addrsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TAINT_PROPER
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MPE
end_ifdef

begin_comment
comment|/* Deal with MPE bind() peculiarities */
end_comment

begin_if
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* The address *MUST* stupidly be zero. */
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* PRIV mode is required to bind() to ports< 1024. */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
operator|<
literal|1024
operator|&&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
operator|>
literal|0
condition|)
block|{
name|GETPRIVMODE
argument_list|()
expr_stmt|;
comment|/* If this fails, we are aborted by MPE/iX. */
name|mpeprivmode
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPE */
end_comment

begin_if
if|if
condition|(
name|PerlSock_bind
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|len
argument_list|)
operator|>=
literal|0
condition|)
name|bind_ok
operator|=
literal|1
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|MPE
end_ifdef

begin_comment
comment|/* Switch back to USER mode */
end_comment

begin_if
if|if
condition|(
name|mpeprivmode
condition|)
name|GETUSERMODE
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPE */
end_comment

begin_if
if|if
condition|(
name|bind_ok
condition|)
name|RETPUSHYES
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
end_if

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"bind"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_connect
operator|)
block|{
name|dSP
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|SV
operator|*
name|addrsv
operator|=
name|POPs
block|;
name|char
operator|*
name|addr
block|;
name|GV
operator|*
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
specifier|register
name|IO
operator|*
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
block|;
name|STRLEN
name|len
block|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
name|addr
operator|=
name|SvPV
argument_list|(
name|addrsv
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TAINT_PROPER
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|PerlSock_connect
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|len
argument_list|)
operator|>=
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
end_if

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"connect"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_listen
operator|)
block|{
name|dSP
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|int
name|backlog
operator|=
name|POPi
block|;
name|GV
operator|*
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
specifier|register
name|IO
operator|*
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
block|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
end_expr_stmt

begin_if
if|if
condition|(
name|PerlSock_listen
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|backlog
argument_list|)
operator|>=
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
end_if

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"listen"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_accept
operator|)
block|{
name|dSP
block|;
name|dTARGET
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|GV
operator|*
name|ngv
block|;
name|GV
operator|*
name|ggv
block|;
specifier|register
name|IO
operator|*
name|nstio
block|;
specifier|register
name|IO
operator|*
name|gstio
block|;     struct
name|sockaddr
name|saddr
block|;
comment|/* use a struct to avoid alignment problems */
name|Sock_size_t
name|len
operator|=
sizeof|sizeof
name|saddr
block|;
name|int
name|fd
block|;
name|ggv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
name|ngv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
if|if
condition|(
operator|!
name|ngv
condition|)
goto|goto
name|badexit
goto|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|ggv
condition|)
goto|goto
name|nuts
goto|;
end_if

begin_expr_stmt
name|gstio
operator|=
name|GvIO
argument_list|(
name|ggv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|gstio
operator|||
operator|!
name|IoIFP
argument_list|(
name|gstio
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
end_if

begin_expr_stmt
name|nstio
operator|=
name|GvIOn
argument_list|(
name|ngv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|IoIFP
argument_list|(
name|nstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|ngv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|fd
operator|=
name|PerlSock_accept
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|gstio
argument_list|)
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
end_if

begin_expr_stmt
name|IoIFP
argument_list|(
name|nstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IoOFP
argument_list|(
name|nstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IoTYPE
argument_list|(
name|nstio
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|nstio
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|nstio
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|nstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|nstio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|nstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|nstio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|nstio
argument_list|)
operator|&&
operator|!
name|IoOFP
argument_list|(
name|nstio
argument_list|)
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
end_if

begin_expr_stmt
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ensure close-on-exec */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EPOC
end_ifdef

begin_expr_stmt
name|len
operator|=
sizeof|sizeof
name|saddr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* EPOC somehow truncates info */
end_comment

begin_expr_stmt
name|setbuf
argument_list|(
name|IoIFP
argument_list|(
name|nstio
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* EPOC gets confused about sockets */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|PUSHp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETURN
expr_stmt|;
end_expr_stmt

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|ggv
argument_list|,
name|ggv
condition|?
name|GvIO
argument_list|(
name|ggv
argument_list|)
else|:
literal|0
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|badexit
label|:
end_label

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"accept"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_shutdown
operator|)
block|{
name|dSP
block|;
name|dTARGET
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|int
name|how
operator|=
name|POPi
block|;
name|GV
operator|*
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
specifier|register
name|IO
operator|*
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
block|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
name|PUSHi
argument_list|(
name|PerlSock_shutdown
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
name|how
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETURN
expr_stmt|;
end_expr_stmt

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"shutdown"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_gsockopt
operator|)
block|{
ifdef|#
directive|ifdef
name|HAS_SOCKET
return|return
name|pp_ssockopt
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getsockopt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_ssockopt
operator|)
block|{
name|dSP
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|int
name|optype
operator|=
name|PL_op
operator|->
name|op_type
block|;
name|SV
operator|*
name|sv
block|;
name|int
name|fd
block|;
name|unsigned
name|int
name|optname
block|;
name|unsigned
name|int
name|lvl
block|;
name|GV
operator|*
name|gv
block|;
specifier|register
name|IO
operator|*
name|io
block|;
name|Sock_size_t
name|len
block|;
if|if
condition|(
name|optype
operator|==
name|OP_GSOCKOPT
condition|)
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|NEWSV
argument_list|(
literal|22
argument_list|,
literal|257
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
name|POPs
expr_stmt|;
name|optname
operator|=
operator|(
name|unsigned
name|int
operator|)
name|POPi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lvl
operator|=
operator|(
name|unsigned
name|int
operator|)
name|POPi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
end_if

begin_expr_stmt
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_GSOCKOPT
case|:
name|SvGROW
argument_list|(
name|sv
argument_list|,
literal|257
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
literal|256
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlSock_getsockopt
argument_list|(
name|fd
argument_list|,
name|lvl
argument_list|,
name|optname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SSOCKOPT
case|:
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|aint
decl_stmt|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|l
decl_stmt|;
name|buf
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|aint
operator|=
operator|(
name|int
operator|)
name|SvIV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|aint
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PerlSock_setsockopt
argument_list|(
name|fd
argument_list|,
name|lvl
argument_list|,
name|optname
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
end_switch

begin_expr_stmt
name|RETURN
expr_stmt|;
end_expr_stmt

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|optype
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|nuts2
label|:
end_label

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"setsockopt"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_getsockname
operator|)
block|{
ifdef|#
directive|ifdef
name|HAS_SOCKET
return|return
name|pp_getpeername
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}  PP
operator|(
name|pp_getpeername
operator|)
block|{
name|dSP
block|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
name|int
name|optype
operator|=
name|PL_op
operator|->
name|op_type
block|;
name|SV
operator|*
name|sv
block|;
name|int
name|fd
block|;
name|GV
operator|*
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
block|;
specifier|register
name|IO
operator|*
name|io
operator|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
block|;
name|Sock_size_t
name|len
block|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nuts
goto|;
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|NEWSV
argument_list|(
literal|22
argument_list|,
literal|257
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|len
operator|=
literal|256
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|OP_GETSOCKNAME
case|:
if|if
condition|(
name|PerlSock_getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
break|break;
case|case
name|OP_GETPEERNAME
case|:
if|if
condition|(
name|PerlSock_getpeername
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
if|#
directive|if
name|defined
argument_list|(
name|VMS_DO_SOCKETS
argument_list|)
operator|&&
name|defined
argument_list|(
name|DECCRTL_SOCKETS
argument_list|)
block|{
specifier|static
specifier|const
name|char
name|nowhere
index|[]
init|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
comment|/* If the call succeeded, make sure we don't have a zeroed port/addr */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|nowhere
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|nuts2
goto|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
end_switch

begin_ifdef
ifdef|#
directive|ifdef
name|BOGUS_GETNAME_RETURN
end_ifdef

begin_comment
comment|/* Interactive Unix, getpeername() and getsockname()       does not return valid namelen */
end_comment

begin_if
if|if
condition|(
name|len
operator|==
name|BOGUS_GETNAME_RETURN
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RETURN
expr_stmt|;
end_expr_stmt

begin_label
name|nuts
label|:
end_label

begin_if
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|optype
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|nuts2
label|:
end_label

begin_expr_stmt
name|RETPUSHUNDEF
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getpeername"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/* Stat calls. */
end_comment

begin_expr_stmt
unit|PP
operator|(
name|pp_lstat
operator|)
block|{
return|return
name|pp_stat
argument_list|()
return|;
block|}
end_expr_stmt

begin_macro
name|PP
argument_list|(
argument|pp_stat
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|I32
name|max
init|=
literal|13
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|gv
operator|=
name|cGVOP_gv
expr_stmt|;
name|do_fstat
label|:
if|if
condition|(
name|gv
operator|!=
name|PL_defgv
condition|)
block|{
name|PL_laststype
operator|=
name|OP_STAT
expr_stmt|;
name|PL_statgv
operator|=
name|gv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_laststatval
operator|=
operator|(
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|&&
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|?
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOn
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|GvIO
argument_list|(
name|gv
argument_list|)
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_LSTAT
name|PL_laststype
operator|=
name|PL_op
operator|->
name|op_type
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_LSTAT
condition|)
name|PL_laststatval
operator|=
name|PerlLIO_lstat
argument_list|(
name|SvPV
argument_list|(
name|PL_statname
argument_list|,
name|n_a
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|PL_laststatval
operator|=
name|PerlLIO_stat
argument_list|(
name|SvPV
argument_list|(
name|PL_statname
argument_list|,
name|n_a
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NEWLINE
argument_list|)
operator|&&
name|strchr
argument_list|(
name|SvPV
argument_list|(
name|PL_statname
argument_list|,
name|n_a
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NEWLINE
argument_list|,
argument|PL_warn_nl
argument_list|,
literal|"stat"
argument_list|)
empty_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|gimme
operator|=
name|GIMME_V
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
name|gimme
operator|!=
name|G_VOID
condition|)
name|XPUSHs
argument_list|(
name|boolSV
argument_list|(
name|max
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|max
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_ino
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_nlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|Uid_t_size
operator|>
name|IVSIZE
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|Uid_t_sign
operator|<=
literal|0
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|Gid_t_size
operator|>
name|IVSIZE
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|Gid_t_sign
operator|<=
literal|0
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_STAT_RDEV
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_rdev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|Off_t_size
operator|>
name|IVSIZE
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIG_TIME
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_atime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_mtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
name|PL_statcache
operator|.
name|st_ctime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_atime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_mtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|PL_statcache
operator|.
name|st_ctime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_STAT_BLOCKS
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_blksize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVuv
argument_list|(
name|PL_statcache
operator|.
name|st_blocks
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftrread
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_OK
argument_list|)
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|access
argument_list|(
name|TOPpx
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IRUSR
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftrwrite
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|W_OK
argument_list|)
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|access
argument_list|(
name|TOPpx
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IWUSR
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftrexec
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|X_OK
argument_list|)
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|access
argument_list|(
name|TOPpx
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fteread
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_EFF_ACCESS_R_OK
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|PERL_EFF_ACCESS_R_OK
argument_list|(
name|TOPpx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IRUSR
argument_list|,
literal|1
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftewrite
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_EFF_ACCESS_W_OK
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|PERL_EFF_ACCESS_W_OK
argument_list|(
name|TOPpx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IWUSR
argument_list|,
literal|1
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fteexec
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
decl_stmt|;
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_EFF_ACCESS_X_OK
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_FILETEST_ACCESS
operator|)
operator|&&
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|result
operator|=
name|PERL_EFF_ACCESS_X_OK
argument_list|(
name|TOPpx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
else|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|my_stat
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
literal|1
argument_list|,
operator|&
name|PL_statcache
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftis
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fteowned
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_ftrowned
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftrowned
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PL_statcache
operator|.
name|st_uid
operator|==
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_FTEOWNED
condition|?
name|PL_euid
else|:
name|PL_uid
operator|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftzero
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PL_statcache
operator|.
name|st_size
operator|==
literal|0
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftsize
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|#
directive|if
name|Off_t_size
operator|>
name|IVSIZE
name|PUSHn
argument_list|(
name|PL_statcache
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHi
argument_list|(
name|PL_statcache
operator|.
name|st_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftmtime
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHn
argument_list|(
operator|(
name|PL_basetime
operator|-
name|PL_statcache
operator|.
name|st_mtime
operator|)
operator|/
literal|86400.0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftatime
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHn
argument_list|(
operator|(
name|PL_basetime
operator|-
name|PL_statcache
operator|.
name|st_atime
operator|)
operator|/
literal|86400.0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftctime
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHn
argument_list|(
operator|(
name|PL_basetime
operator|-
name|PL_statcache
operator|.
name|st_ctime
operator|)
operator|/
literal|86400.0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftsock
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftchr
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftblk
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISBLK
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftfile
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftdir
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftpipe
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftlink
argument_list|)
end_macro

begin_block
block|{
name|I32
name|result
init|=
name|my_lstat
argument_list|()
decl_stmt|;
name|dSP
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftsuid
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISUID
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PL_statcache
operator|.
name|st_mode
operator|&
name|S_ISUID
condition|)
name|RETPUSHYES
expr_stmt|;
endif|#
directive|endif
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftsgid
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISGID
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PL_statcache
operator|.
name|st_mode
operator|&
name|S_ISGID
condition|)
name|RETPUSHYES
expr_stmt|;
endif|#
directive|endif
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftsvtx
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISVTX
name|I32
name|result
init|=
name|my_stat
argument_list|()
decl_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PL_statcache
operator|.
name|st_mode
operator|&
name|S_ISVTX
condition|)
name|RETPUSHYES
expr_stmt|;
endif|#
directive|endif
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_fttty
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|int
name|fd
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|Nullch
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
name|gv
operator|=
name|cGVOP_gv
expr_stmt|;
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|TOPs
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|isGV
argument_list|(
name|SvRV
argument_list|(
name|TOPs
argument_list|)
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
else|else
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|tmps
operator|=
name|POPpx
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|&&
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmps
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|tmps
argument_list|)
condition|)
name|fd
operator|=
name|atoi
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|PerlLIO_isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
end_if

begin_comment
comment|/* this will work with atariST. Configure will 			make guesses for other systems. */
end_comment

begin_define
define|#
directive|define
name|FILE_base
parameter_list|(
name|f
parameter_list|)
value|((f)->_base)
end_define

begin_define
define|#
directive|define
name|FILE_ptr
parameter_list|(
name|f
parameter_list|)
value|((f)->_ptr)
end_define

begin_define
define|#
directive|define
name|FILE_cnt
parameter_list|(
name|f
parameter_list|)
value|((f)->_cnt)
end_define

begin_define
define|#
directive|define
name|FILE_bufsiz
parameter_list|(
name|f
parameter_list|)
value|((f)->_cnt + ((f)->_ptr - (f)->_base))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_fttext
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|i
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|I32
name|odd
init|=
literal|0
decl_stmt|;
name|STDCHAR
name|tbuf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|STDCHAR
modifier|*
name|s
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
name|gv
operator|=
name|cGVOP_gv
expr_stmt|;
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|TOPs
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|isGV
argument_list|(
name|SvRV
argument_list|(
name|TOPs
argument_list|)
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
else|else
name|gv
operator|=
name|Nullgv
expr_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
operator|==
name|PL_defgv
condition|)
block|{
if|if
condition|(
name|PL_statgv
condition|)
name|io
operator|=
name|GvIO
argument_list|(
name|PL_statgv
argument_list|)
expr_stmt|;
else|else
block|{
name|sv
operator|=
name|PL_statname
expr_stmt|;
goto|goto
name|really_filename
goto|;
block|}
block|}
else|else
block|{
name|PL_statgv
operator|=
name|gv
expr_stmt|;
name|PL_laststatval
operator|=
operator|-
literal|1
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|PL_statgv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|&&
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PerlIO_has_base
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"-T and -B not implemented on filehandles"
argument_list|)
expr_stmt|;
name|PL_laststatval
operator|=
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* handle NFS glitch */
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_FTTEXT
condition|)
name|RETPUSHNO
expr_stmt|;
else|else
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|PerlIO_ungetc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
comment|/* null file is anything */
name|RETPUSHYES
expr_stmt|;
name|len
operator|=
name|PerlIO_get_bufsiz
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|PerlIO_get_base
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sfio can have large buffers - limit to 512 */
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
block|{
name|gv
operator|=
name|cGVOP_gv
expr_stmt|;
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|GvIO
argument_list|(
name|gv
argument_list|)
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
block|}
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
block|}
else|else
block|{
name|sv
operator|=
name|POPs
expr_stmt|;
name|really_filename
label|:
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_laststatval
operator|=
operator|-
literal|1
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|SvPVX
argument_list|(
name|PL_statname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NEWLINE
argument_list|)
operator|&&
name|strchr
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NEWLINE
argument_list|,
argument|PL_warn_nl
argument_list|,
literal|"open"
argument_list|)
empty_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|PL_laststatval
operator|=
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|do_binmode
argument_list|(
name|fp
argument_list|,
literal|'<'
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|len
operator|=
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|PL_statcache
operator|.
name|st_mode
argument_list|)
operator|&&
name|PL_op
operator|->
name|op_type
operator|==
name|OP_FTTEXT
condition|)
name|RETPUSHNO
expr_stmt|;
comment|/* special case NFS directories */
name|RETPUSHYES
expr_stmt|;
comment|/* null file is anything */
block|}
name|s
operator|=
name|tbuf
expr_stmt|;
block|}
comment|/* now scan s to look for textiness */
comment|/*   XXX ASCII dependent code */
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|USEMYBINMODE
argument_list|)
comment|/* ignore trailing ^Z on short files */
if|if
condition|(
name|len
operator|&&
name|len
operator|<
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
operator|&&
name|tbuf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|26
condition|)
operator|--
name|len
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
comment|/* null never allowed in text */
name|odd
operator|+=
name|len
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|EBCDIC
elseif|else
if|if
condition|(
operator|!
operator|(
name|isPRINT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
name|odd
operator|++
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
operator|*
name|s
operator|&
literal|128
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
operator|&&
name|isALPHA_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* utf8 characters don't count as odd */
if|if
condition|(
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|int
name|ulen
init|=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ulen
operator|<
name|len
operator|-
name|i
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|ulen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|UTF8_IS_CONTINUATION
argument_list|(
name|s
index|[
name|j
index|]
argument_list|)
condition|)
goto|goto
name|not_utf8
goto|;
block|}
operator|--
name|ulen
expr_stmt|;
comment|/* loop does extra increment */
name|s
operator|+=
name|ulen
expr_stmt|;
name|i
operator|+=
name|ulen
expr_stmt|;
continue|continue;
block|}
block|}
name|not_utf8
label|:
name|odd
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|<
literal|32
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
operator|&&
operator|*
name|s
operator|!=
literal|'\b'
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\f'
operator|&&
operator|*
name|s
operator|!=
literal|27
condition|)
name|odd
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|odd
operator|*
literal|3
operator|>
name|len
operator|)
operator|==
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_FTTEXT
operator|)
condition|)
comment|/* allow 1/3 odd */
name|RETPUSHNO
expr_stmt|;
else|else
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ftbinary
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_fttext
argument_list|()
return|;
block|}
end_block

begin_comment
comment|/* File calls. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_chdir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|tmps
operator|=
name|Nullch
expr_stmt|;
else|else
name|tmps
operator|=
name|POPpx
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
block|{
name|svp
operator|=
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_envgv
argument_list|)
argument_list|,
literal|"HOME"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
name|tmps
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
block|{
name|svp
operator|=
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_envgv
argument_list|)
argument_list|,
literal|"LOGDIR"
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
name|tmps
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
block|{
name|svp
operator|=
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_envgv
argument_list|)
argument_list|,
literal|"SYS$LOGIN"
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
name|tmps
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TAINT_PROPER
argument_list|(
literal|"chdir"
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|PerlDir_chdir
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Clear the DEFAULT element of ENV so we'll get the new value      * in the future. */
name|hv_delete
argument_list|(
name|GvHVn
argument_list|(
name|PL_envgv
argument_list|)
argument_list|,
literal|"DEFAULT"
argument_list|,
literal|7
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chown
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_CHOWN
name|value
operator|=
operator|(
name|I32
operator|)
name|apply
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function chown"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chroot
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_CHROOT
name|STRLEN
name|n_a
decl_stmt|;
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"chroot"
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|chroot
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"chroot"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_unlink
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|apply
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chmod
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|apply
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_utime
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|apply
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rename
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|anum
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps2
init|=
name|POPpx
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|TOPs
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_RENAME
name|anum
operator|=
name|PerlLIO_rename
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|anum
operator|=
name|PerlLIO_stat
argument_list|(
name|tmps
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|same_dirent
argument_list|(
name|tmps2
argument_list|,
name|tmps
argument_list|)
condition|)
comment|/* can always rename to same name */
name|anum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PL_euid
operator|||
name|PerlLIO_stat
argument_list|(
name|tmps2
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|tmps2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|anum
operator|=
name|link
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|)
condition|)
name|anum
operator|=
name|UNLINK
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SETi
argument_list|(
name|anum
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_link
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_LINK
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps2
init|=
name|POPpx
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|TOPs
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"link"
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|PerlLIO_link
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function link"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_symlink
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SYMLINK
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps2
init|=
name|POPpx
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|TOPs
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"symlink"
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|symlink
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"symlink"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_readlink
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SYMLINK
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
name|TAINT
expr_stmt|;
endif|#
directive|endif
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|len
operator|=
name|readlink
argument_list|(
name|tmps
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHp
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETSETUNDEF
expr_stmt|;
comment|/* just pretend it's a normal file */
endif|#
directive|endif
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MKDIR
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_RMDIR
argument_list|)
end_if

begin_function
name|STATIC
name|int
name|S_dooneliner
parameter_list|(
name|pTHX_
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|save_filename
init|=
name|filename
decl_stmt|;
name|char
modifier|*
name|cmdline
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|PerlIO
modifier|*
name|myfp
decl_stmt|;
name|int
name|anum
init|=
literal|1
decl_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|cmdline
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
operator|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|*
literal|2
operator|)
operator|+
literal|10
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdline
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmdline
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|cmdline
operator|+
name|strlen
argument_list|(
name|cmdline
argument_list|)
init|;
operator|*
name|filename
condition|;
control|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|*
name|filename
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|s
argument_list|,
literal|" 2>&1"
argument_list|)
expr_stmt|;
name|myfp
operator|=
name|PerlProc_popen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|myfp
condition|)
block|{
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
comment|/* Need to save/restore 'PL_rs' ?? */
name|s
operator|=
name|sv_gets
argument_list|(
name|tmpsv
argument_list|,
name|myfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlProc_pclose
argument_list|(
name|myfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|Nullch
condition|)
block|{
name|int
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
literal|1
init|;
ifdef|#
directive|ifdef
name|HAS_SYS_ERRLIST
name|e
operator|<=
name|sys_nerr
endif|#
directive|endif
condition|;
name|e
operator|++
control|)
block|{
comment|/* you don't see this */
name|char
modifier|*
name|errmsg
init|=
ifdef|#
directive|ifdef
name|HAS_SYS_ERRLIST
name|sys_errlist
index|[
name|e
index|]
else|#
directive|else
name|strerror
argument_list|(
name|e
argument_list|)
endif|#
directive|endif
decl_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
break|break;
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
name|errmsg
argument_list|)
condition|)
block|{
name|SETERRNO
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EACCES
define|#
directive|define
name|EACCES
value|EPERM
endif|#
directive|endif
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"cannot make"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|EEXIST
argument_list|,
name|RMS$_FEX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"existing file"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|EEXIST
argument_list|,
name|RMS$_FEX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"ile exists"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|EEXIST
argument_list|,
name|RMS$_FEX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"non-exist"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|ENOENT
argument_list|,
name|RMS$_FNF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"does not exist"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|ENOENT
argument_list|,
name|RMS$_FNF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"not empty"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|EBUSY
argument_list|,
name|SS$_DEVOFFLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|s
argument_list|,
literal|"cannot access"
argument_list|)
condition|)
name|SETERRNO
argument_list|(
name|EACCES
argument_list|,
name|RMS$_PRV
argument_list|)
expr_stmt|;
else|else
name|SETERRNO
argument_list|(
name|EPERM
argument_list|,
name|RMS$_PRV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* some mkdirs return no failure indication */
name|anum
operator|=
operator|(
name|PerlLIO_stat
argument_list|(
name|save_filename
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_RMDIR
condition|)
name|anum
operator|=
operator|!
name|anum
expr_stmt|;
if|if
condition|(
name|anum
condition|)
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SETERRNO
argument_list|(
name|EACCES
argument_list|,
name|RMS$_PRV
argument_list|)
expr_stmt|;
comment|/* a guess */
block|}
return|return
name|anum
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_mkdir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|mode
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_MKDIR
name|int
name|oldumask
decl_stmt|;
endif|#
directive|endif
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|>
literal|1
condition|)
name|mode
operator|=
name|POPi
expr_stmt|;
else|else
name|mode
operator|=
literal|0777
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|TOPs
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_MKDIR
name|SETi
argument_list|(
name|PerlDir_mkdir
argument_list|(
name|tmps
argument_list|,
name|mode
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|SETi
argument_list|(
name|dooneliner
argument_list|(
literal|"mkdir"
argument_list|,
name|tmps
argument_list|)
argument_list|)
expr_stmt|;
name|oldumask
operator|=
name|PerlLIO_umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PerlLIO_umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
name|PerlLIO_chmod
argument_list|(
name|tmps
argument_list|,
operator|(
name|mode
operator|&
operator|~
name|oldumask
operator|)
operator|&
literal|0777
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rmdir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"rmdir"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_RMDIR
name|XPUSHi
argument_list|(
name|PerlDir_rmdir
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|XPUSHi
argument_list|(
name|dooneliner
argument_list|(
literal|"rmdir"
argument_list|,
name|tmps
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Directory calls. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_open_dir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Direntry_t
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_READDIR
argument_list|)
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|dirname
init|=
name|POPpx
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
goto|goto
name|nope
goto|;
if|if
condition|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
name|PerlDir_close
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
operator|=
name|PerlDir_open
argument_list|(
name|dirname
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
name|RETPUSHYES
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_DIR
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"opendir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_readdir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Direntry_t
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_READDIR
argument_list|)
ifndef|#
directive|ifndef
name|I_DIRENT
name|Direntry_t
modifier|*
name|readdir
parameter_list|(
name|DIR
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|register
name|Direntry_t
modifier|*
name|dp
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nope
goto|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
comment|/*SUPPRESS 560*/
while|while
condition|(
operator|(
name|dp
operator|=
operator|(
name|Direntry_t
operator|*
operator|)
name|PerlDir_read
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIRNAMLEN
name|sv
operator|=
name|newSVpvn
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv
operator|=
name|newSVpv
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
if|if
condition|(
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_UNTAINT
operator|)
condition|)
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
operator|(
name|Direntry_t
operator|*
operator|)
name|PerlDir_read
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
ifdef|#
directive|ifdef
name|DIRNAMLEN
name|sv
operator|=
name|newSVpvn
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv
operator|=
name|newSVpv
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
if|if
condition|(
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_UNTAINT
operator|)
condition|)
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_ISI
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
name|RETURN
expr_stmt|;
else|else
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"readdir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_telldir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_TELLDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|telldir
argument_list|)
comment|/* XXX does _anyone_ need this? --AD 2/20/1998 */
comment|/* XXX netbsd still seemed to.     XXX HAS_TELLDIR_PROTO is new style, NEED_TELLDIR_PROTO is old style.     --JHI 1999-Feb-02 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_TELLDIR_PROTO
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_TELLDIR_PROTO
argument_list|)
name|long
name|telldir
parameter_list|(
name|DIR
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nope
goto|;
name|PUSHi
argument_list|(
name|PerlDir_tell
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_ISI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"telldir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_seekdir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_SEEKDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|seekdir
argument_list|)
name|long
name|along
init|=
name|POPl
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nope
goto|;
operator|(
name|void
operator|)
name|PerlDir_seek
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|,
name|along
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_ISI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"seekdir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rewinddir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_REWINDDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|rewinddir
argument_list|)
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nope
goto|;
operator|(
name|void
operator|)
name|PerlDir_rewind
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_ISI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"rewinddir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_closedir
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Direntry_t
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_READDIR
argument_list|)
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|io
operator|||
operator|!
name|IoDIRP
argument_list|(
name|io
argument_list|)
condition|)
goto|goto
name|nope
goto|;
ifdef|#
directive|ifdef
name|VOID_CLOSEDIR
name|PerlDir_close
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|PerlDir_close
argument_list|(
name|IoDIRP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IoDIRP
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Don't try to close again--coredumps on SysV */
goto|goto
name|nope
goto|;
block|}
endif|#
directive|endif
name|IoDIRP
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|errno
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_dir_func
argument_list|,
literal|"closedir"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Process control. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_fork
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_FORK
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|childpid
decl_stmt|;
name|GV
modifier|*
name|tmpgv
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
name|childpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|<
literal|0
condition|)
name|RETSETUNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|childpid
condition|)
block|{
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|(
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"$"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
operator|)
condition|)
name|sv_setiv
argument_list|(
name|GvSV
argument_list|(
name|tmpgv
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|PerlProc_getpid
argument_list|()
argument_list|)
expr_stmt|;
name|hv_clear
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
comment|/* no kids, so don't wait for 'em */
block|}
name|PUSHi
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|childpid
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
name|childpid
operator|=
name|PerlProc_fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|==
operator|-
literal|1
condition|)
name|RETSETUNDEF
expr_stmt|;
name|PUSHi
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function fork"
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_wait
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|childpid
decl_stmt|;
name|int
name|argflags
decl_stmt|;
name|childpid
operator|=
name|wait4pid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|argflags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
comment|/* 0 and -1 are both error returns (the former applies to WNOHANG case) */
name|STATUS_NATIVE_SET
argument_list|(
operator|(
name|childpid
operator|&&
name|childpid
operator|!=
operator|-
literal|1
operator|)
condition|?
name|argflags
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|STATUS_NATIVE_SET
argument_list|(
operator|(
name|childpid
operator|>
literal|0
operator|)
condition|?
name|argflags
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XPUSHi
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function wait"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_waitpid
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|childpid
decl_stmt|;
name|int
name|optype
decl_stmt|;
name|int
name|argflags
decl_stmt|;
name|optype
operator|=
name|POPi
expr_stmt|;
name|childpid
operator|=
name|TOPi
expr_stmt|;
name|childpid
operator|=
name|wait4pid
argument_list|(
name|childpid
argument_list|,
operator|&
name|argflags
argument_list|,
name|optype
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
comment|/* 0 and -1 are both error returns (the former applies to WNOHANG case) */
name|STATUS_NATIVE_SET
argument_list|(
operator|(
name|childpid
operator|&&
name|childpid
operator|!=
operator|-
literal|1
operator|)
condition|?
name|argflags
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|STATUS_NATIVE_SET
argument_list|(
operator|(
name|childpid
operator|>
literal|0
operator|)
condition|?
name|argflags
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SETi
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function waitpid"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_system
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|Pid_t
name|childpid
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|status
decl_stmt|;
name|Sigsave_t
name|ihand
decl_stmt|,
name|qhand
decl_stmt|;
comment|/* place to save signals during system() */
name|STRLEN
name|n_a
decl_stmt|;
name|I32
name|did_pipes
init|=
literal|0
decl_stmt|;
name|int
name|pp
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SP
operator|-
name|MARK
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|PL_tainting
condition|)
block|{
name|char
modifier|*
name|junk
init|=
name|SvPV
argument_list|(
name|TOPs
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"system"
argument_list|)
expr_stmt|;
block|}
block|}
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|pp
argument_list|)
operator|>=
literal|0
condition|)
name|did_pipes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|childpid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|value
operator|=
operator|-
literal|1
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_pipes
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childpid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|did_pipes
condition|)
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|ihand
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|qhand
argument_list|)
expr_stmt|;
do|do
block|{
name|result
operator|=
name|wait4pid
argument_list|(
name|childpid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
operator|(
name|void
operator|)
name|rsignal_restore
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|ihand
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rsignal_restore
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qhand
argument_list|)
expr_stmt|;
name|STATUS_NATIVE_SET
argument_list|(
name|result
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|status
argument_list|)
expr_stmt|;
name|do_execfree
argument_list|()
expr_stmt|;
comment|/* free any memory child malloced on vfork */
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
if|if
condition|(
name|did_pipes
condition|)
block|{
name|int
name|errkid
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|n1
decl_stmt|;
while|while
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|n1
operator|=
name|PerlLIO_read
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|errkid
operator|)
operator|+
name|n
operator|)
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|<=
literal|0
condition|)
break|break;
name|n
operator|+=
name|n1
expr_stmt|;
block|}
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* Error */
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"panic: kid popen errno read"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|errkid
expr_stmt|;
comment|/* Propagate errno from kid */
name|STATUS_CURRENT
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|PUSHi
argument_list|(
name|STATUS_CURRENT
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|did_pipes
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fcntl
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|SV
modifier|*
name|really
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aexec5
argument_list|(
name|really
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|,
name|did_pipes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP
operator|-
name|MARK
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aexec5
argument_list|(
name|Nullsv
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|,
name|did_pipes
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|I32
operator|)
name|do_exec3
argument_list|(
name|SvPVx
argument_list|(
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|,
name|did_pipes
argument_list|)
expr_stmt|;
block|}
name|PerlProc__exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! FORK or VMS or OS/2 */
name|PL_statusvalue
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|SV
modifier|*
name|really
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aspawn
argument_list|(
name|really
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|MARK
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|SP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP
operator|-
name|MARK
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aspawn
argument_list|(
name|Nullsv
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|MARK
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|SP
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|I32
operator|)
name|do_spawn
argument_list|(
name|SvPVx
argument_list|(
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_statusvalue
operator|==
operator|-
literal|1
condition|)
comment|/* hint that value must be returned as is */
name|result
operator|=
literal|1
expr_stmt|;
name|STATUS_NATIVE_SET
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|do_execfree
argument_list|()
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|result
condition|?
name|value
else|:
name|STATUS_CURRENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !FORK or VMS */
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_exec
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|SV
modifier|*
name|really
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aexec
argument_list|(
name|really
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP
operator|-
name|MARK
operator|!=
literal|1
condition|)
ifdef|#
directive|ifdef
name|VMS
name|value
operator|=
operator|(
name|I32
operator|)
name|vms_do_aexec
argument_list|(
name|Nullsv
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|__OPEN_VM
block|{
operator|(
name|void
operator|)
name|do_aspawn
argument_list|(
name|Nullsv
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|value
operator|=
operator|(
name|I32
operator|)
name|do_aexec
argument_list|(
name|Nullsv
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|PL_tainting
condition|)
block|{
name|char
modifier|*
name|junk
init|=
name|SvPV
argument_list|(
operator|*
name|SP
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"exec"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
name|value
operator|=
operator|(
name|I32
operator|)
name|vms_do_exec
argument_list|(
name|SvPVx
argument_list|(
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|__OPEN_VM
operator|(
name|void
operator|)
name|do_spawn
argument_list|(
name|SvPVx
argument_list|(
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|value
operator|=
operator|(
name|I32
operator|)
name|do_exec
argument_list|(
name|SvPVx
argument_list|(
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|my_exit
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_kill
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_KILL
name|value
operator|=
operator|(
name|I32
operator|)
name|apply
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function kill"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_getppid
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETPPID
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|XPUSHi
argument_list|(
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getppid"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_getpgrp
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETPGRP
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|pid
decl_stmt|;
name|Pid_t
name|pgrp
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|pid
operator|=
literal|0
expr_stmt|;
else|else
name|pid
operator|=
name|SvIVx
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_GETPGRP
name|pgrp
operator|=
operator|(
name|I32
operator|)
name|BSD_GETPGRP
argument_list|(
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pid
operator|!=
literal|0
operator|&&
name|pid
operator|!=
name|PerlProc_getpid
argument_list|()
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"POSIX getpgrp can't take an argument"
argument_list|)
expr_stmt|;
name|pgrp
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|XPUSHi
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpgrp()"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_setpgrp
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_SETPGRP
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|Pid_t
name|pgrp
decl_stmt|;
name|Pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|2
condition|)
block|{
name|pgrp
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pgrp
operator|=
name|POPi
expr_stmt|;
name|pid
operator|=
name|TOPi
expr_stmt|;
block|}
name|TAINT_PROPER
argument_list|(
literal|"setpgrp"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_SETPGRP
name|SETi
argument_list|(
name|BSD_SETPGRP
argument_list|(
name|pid
argument_list|,
name|pgrp
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|pgrp
operator|!=
literal|0
operator|&&
name|pgrp
operator|!=
name|PerlProc_getpid
argument_list|()
operator|)
operator|||
operator|(
name|pid
operator|!=
literal|0
operator|&&
name|pid
operator|!=
name|PerlProc_getpid
argument_list|()
operator|)
condition|)
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"setpgrp can't take arguments"
argument_list|)
expr_stmt|;
block|}
name|SETi
argument_list|(
name|setpgrp
argument_list|()
operator|>=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_BSDPGRP */
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"setpgrp()"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_getpriority
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|who
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_GETPRIORITY
name|who
operator|=
name|POPi
expr_stmt|;
name|which
operator|=
name|TOPi
expr_stmt|;
name|SETi
argument_list|(
name|getpriority
argument_list|(
name|which
argument_list|,
name|who
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpriority()"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_setpriority
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|who
decl_stmt|;
name|int
name|niceval
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETPRIORITY
name|niceval
operator|=
name|POPi
expr_stmt|;
name|who
operator|=
name|POPi
expr_stmt|;
name|which
operator|=
name|TOPi
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"setpriority"
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|setpriority
argument_list|(
name|which
argument_list|,
name|who
argument_list|,
name|niceval
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"setpriority()"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Time calls. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_time
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_TIME
name|XPUSHn
argument_list|(
name|time
argument_list|(
name|Null
argument_list|(
name|Time_t
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|XPUSHi
argument_list|(
name|time
argument_list|(
name|Null
argument_list|(
name|Time_t
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* XXX The POSIX name is CLK_TCK; it is to be preferred    to HZ.  Probably.  For now, assume that if the system    defines HZ, it does so correctly.  (Will this break    on VMS?)    Probably we ought to use _sysconf(_SC_CLK_TCK), if    it's supported.    --AD  9/96. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HZ
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CLK_TCK
end_ifdef

begin_define
define|#
directive|define
name|HZ
value|CLK_TCK
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HZ
value|60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_tms
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifndef|#
directive|ifndef
name|HAS_TIMES
name|DIE
argument_list|(
name|aTHX_
literal|"times not implemented"
argument_list|)
expr_stmt|;
else|#
directive|else
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
operator|(
name|void
operator|)
name|PerlProc_times
argument_list|(
operator|&
name|PL_timesbuf
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|PerlProc_times
argument_list|(
operator|(
name|tbuffer_t
operator|*
operator|)
operator|&
name|PL_timesbuf
argument_list|)
expr_stmt|;
comment|/* time.h uses different name for */
comment|/* struct tms, though same data   */
comment|/* is returned.                   */
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
operator|(
operator|(
name|NV
operator|)
name|PL_timesbuf
operator|.
name|tms_utime
operator|)
operator|/
name|HZ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
operator|(
operator|(
name|NV
operator|)
name|PL_timesbuf
operator|.
name|tms_stime
operator|)
operator|/
name|HZ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
operator|(
operator|(
name|NV
operator|)
name|PL_timesbuf
operator|.
name|tms_cutime
operator|)
operator|/
name|HZ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVnv
argument_list|(
operator|(
operator|(
name|NV
operator|)
name|PL_timesbuf
operator|.
name|tms_cstime
operator|)
operator|/
name|HZ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
endif|#
directive|endif
comment|/* HAS_TIMES */
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_localtime
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_gmtime
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gmtime
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|Time_t
name|when
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmbuf
decl_stmt|;
specifier|static
name|char
modifier|*
name|dayname
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|monname
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|BIG_TIME
name|when
operator|=
operator|(
name|Time_t
operator|)
name|SvNVx
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
else|#
directive|else
name|when
operator|=
operator|(
name|Time_t
operator|)
name|SvIVx
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_LOCALTIME
condition|)
name|tmbuf
operator|=
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
else|else
name|tmbuf
operator|=
name|gmtime
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|SV
modifier|*
name|tsv
decl_stmt|;
if|if
condition|(
operator|!
name|tmbuf
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|tsv
operator|=
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%s %s %2d %02d:%02d:%02d %d"
argument_list|,
name|dayname
index|[
name|tmbuf
operator|->
name|tm_wday
index|]
argument_list|,
name|monname
index|[
name|tmbuf
operator|->
name|tm_mon
index|]
argument_list|,
name|tmbuf
operator|->
name|tm_mday
argument_list|,
name|tmbuf
operator|->
name|tm_hour
argument_list|,
name|tmbuf
operator|->
name|tm_min
argument_list|,
name|tmbuf
operator|->
name|tm_sec
argument_list|,
name|tmbuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|tsv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmbuf
condition|)
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_sec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_min
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_hour
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_mday
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_mon
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_year
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_wday
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_yday
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|tmbuf
operator|->
name|tm_isdst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_alarm
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|anum
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_ALARM
name|anum
operator|=
name|POPi
expr_stmt|;
name|anum
operator|=
name|alarm
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|anum
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHi
argument_list|(
name|anum
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"Unsupported function alarm"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sleep
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|duration
decl_stmt|;
name|Time_t
name|lasttime
decl_stmt|;
name|Time_t
name|when
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|lasttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|PerlProc_pause
argument_list|()
expr_stmt|;
else|else
block|{
name|duration
operator|=
name|POPi
expr_stmt|;
name|PerlProc_sleep
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|duration
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|XPUSHi
argument_list|(
name|when
operator|-
name|lasttime
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Shared memory. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_shmget
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_semget
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shmctl
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_semctl
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shmread
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_shmwrite
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shmwrite
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
init|=
call|(
name|I32
call|)
argument_list|(
name|do_shmio
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
operator|>=
literal|0
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
return|return
name|pp_semget
argument_list|()
return|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Message passing. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_msgget
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_semget
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_msgctl
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_semctl
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_msgsnd
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
init|=
call|(
name|I32
call|)
argument_list|(
name|do_msgsnd
argument_list|(
name|MARK
argument_list|,
name|SP
argument_list|)
operator|>=
literal|0
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
return|return
name|pp_semget
argument_list|()
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_msgrcv
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
init|=
call|(
name|I32
call|)
argument_list|(
name|do_msgrcv
argument_list|(
name|MARK
argument_list|,
name|SP
argument_list|)
operator|>=
literal|0
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
return|return
name|pp_semget
argument_list|()
return|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Semaphores. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_semget
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|anum
init|=
name|do_ipcget
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
if|if
condition|(
name|anum
operator|==
operator|-
literal|1
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHi
argument_list|(
name|anum
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"System V IPC is not implemented on this machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_semctl
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|int
name|anum
init|=
name|do_ipcctl
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
if|if
condition|(
name|anum
operator|==
operator|-
literal|1
condition|)
name|RETSETUNDEF
expr_stmt|;
if|if
condition|(
name|anum
operator|!=
literal|0
condition|)
block|{
name|PUSHi
argument_list|(
name|anum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHp
argument_list|(
name|zero_but_true
argument_list|,
name|ZBTLEN
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
return|return
name|pp_semget
argument_list|()
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_semop
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
init|=
call|(
name|I32
call|)
argument_list|(
name|do_semop
argument_list|(
name|MARK
argument_list|,
name|SP
argument_list|)
operator|>=
literal|0
argument_list|)
decl_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
return|return
name|pp_semget
argument_list|()
return|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Get system info. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_ghbyname
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETHOSTBYNAME
return|return
name|pp_ghostent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ghbyaddr
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETHOSTBYADDR
return|return
name|pp_ghostent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostbyaddr"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ghostent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GETHOSTBYNAME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETHOSTBYADDR
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETHOSTENT
argument_list|)
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_GETHOST_PROTOS
comment|/* XXX Do we need individual probes? */
name|struct
name|hostent
modifier|*
name|PerlSock_gethostbyaddr
parameter_list|(
name|Netdb_host_t
parameter_list|,
name|Netdb_hlen_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|struct
name|hostent
modifier|*
name|PerlSock_gethostbyname
parameter_list|(
name|Netdb_name_t
parameter_list|)
function_decl|;
name|struct
name|hostent
modifier|*
name|PerlSock_gethostent
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|struct
name|hostent
modifier|*
name|hent
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|OP_GHBYNAME
condition|)
ifdef|#
directive|ifdef
name|HAS_GETHOSTBYNAME
name|hent
operator|=
name|PerlSock_gethostbyname
argument_list|(
name|POPpx
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|which
operator|==
name|OP_GHBYADDR
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GETHOSTBYADDR
name|int
name|addrtype
init|=
name|POPi
decl_stmt|;
name|SV
modifier|*
name|addrsv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|addrlen
decl_stmt|;
name|Netdb_host_t
name|addr
init|=
operator|(
name|Netdb_host_t
operator|)
name|SvPV
argument_list|(
name|addrsv
argument_list|,
name|addrlen
argument_list|)
decl_stmt|;
name|hent
operator|=
name|PerlSock_gethostbyaddr
argument_list|(
name|addr
argument_list|,
operator|(
name|Netdb_hlen_t
operator|)
name|addrlen
argument_list|,
name|addrtype
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostbyaddr"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
else|else
ifdef|#
directive|ifdef
name|HAS_GETHOSTENT
name|hent
operator|=
name|PerlSock_gethostent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HOST_NOT_FOUND
if|if
condition|(
operator|!
name|hent
condition|)
name|STATUS_NATIVE_SET
argument_list|(
name|h_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GHBYNAME
condition|)
block|{
if|if
condition|(
name|hent
operator|->
name|h_addr
condition|)
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|hent
operator|->
name|h_addr
argument_list|,
name|hent
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|hent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|hent
operator|->
name|h_aliases
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|hent
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|hent
operator|->
name|h_length
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|h_addr
for|for
control|(
name|elem
operator|=
name|hent
operator|->
name|h_addr_list
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|XPUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hent
operator|->
name|h_addr
condition|)
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|hent
operator|->
name|h_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* h_addr */
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"gethostent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gnbyname
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETNETBYNAME
return|return
name|pp_gnetent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gnbyaddr
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETNETBYADDR
return|return
name|pp_gnetent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetbyaddr"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gnetent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GETNETBYNAME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETNETBYADDR
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETNETENT
argument_list|)
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_GETNET_PROTOS
comment|/* XXX Do we need individual probes? */
name|struct
name|netent
modifier|*
name|PerlSock_getnetbyaddr
parameter_list|(
name|Netdb_net_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|struct
name|netent
modifier|*
name|PerlSock_getnetbyname
parameter_list|(
name|Netdb_name_t
parameter_list|)
function_decl|;
name|struct
name|netent
modifier|*
name|PerlSock_getnetent
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|struct
name|netent
modifier|*
name|nent
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|OP_GNBYNAME
condition|)
ifdef|#
directive|ifdef
name|HAS_GETNETBYNAME
name|nent
operator|=
name|PerlSock_getnetbyname
argument_list|(
name|POPpx
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|which
operator|==
name|OP_GNBYADDR
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GETNETBYADDR
name|int
name|addrtype
init|=
name|POPi
decl_stmt|;
name|Netdb_net_t
name|addr
init|=
operator|(
name|Netdb_net_t
operator|)
name|U_L
argument_list|(
name|POPn
argument_list|)
decl_stmt|;
name|nent
operator|=
name|PerlSock_getnetbyaddr
argument_list|(
name|addr
argument_list|,
name|addrtype
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetbyaddr"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
else|else
ifdef|#
directive|ifdef
name|HAS_GETNETENT
name|nent
operator|=
name|PerlSock_getnetent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GNBYNAME
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|nent
operator|->
name|n_net
argument_list|)
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|nent
operator|->
name|n_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|nent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|nent
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|nent
operator|->
name|n_aliases
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|nent
operator|->
name|n_addrtype
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|nent
operator|->
name|n_net
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getnetent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gpbyname
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETPROTOBYNAME
return|return
name|pp_gprotoent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotobyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gpbynumber
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETPROTOBYNUMBER
return|return
name|pp_gprotoent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotobynumber"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gprotoent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GETPROTOBYNAME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETPROTOBYNUMBER
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETPROTOENT
argument_list|)
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_GETPROTO_PROTOS
comment|/* XXX Do we need individual probes? */
name|struct
name|protoent
modifier|*
name|PerlSock_getprotobyname
parameter_list|(
name|Netdb_name_t
parameter_list|)
function_decl|;
name|struct
name|protoent
modifier|*
name|PerlSock_getprotobynumber
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|struct
name|protoent
modifier|*
name|PerlSock_getprotoent
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|struct
name|protoent
modifier|*
name|pent
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|OP_GPBYNAME
condition|)
ifdef|#
directive|ifdef
name|HAS_GETPROTOBYNAME
name|pent
operator|=
name|PerlSock_getprotobyname
argument_list|(
name|POPpx
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotobyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|which
operator|==
name|OP_GPBYNUMBER
condition|)
ifdef|#
directive|ifdef
name|HAS_GETPROTOBYNUMBER
name|pent
operator|=
name|PerlSock_getprotobynumber
argument_list|(
name|POPi
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotobynumber"
argument_list|)
empty_stmt|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|HAS_GETPROTOENT
name|pent
operator|=
name|PerlSock_getprotoent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotoent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GPBYNAME
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pent
operator|->
name|p_proto
argument_list|)
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pent
operator|->
name|p_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|pent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pent
operator|->
name|p_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|pent
operator|->
name|p_aliases
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pent
operator|->
name|p_proto
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getprotoent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gsbyname
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETSERVBYNAME
return|return
name|pp_gservent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gsbyport
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GETSERVBYPORT
return|return
name|pp_gservent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservbyport"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gservent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GETSERVBYNAME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETSERVBYPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_GETSERVENT
argument_list|)
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_GETSERV_PROTOS
comment|/* XXX Do we need individual probes? */
name|struct
name|servent
modifier|*
name|PerlSock_getservbyname
parameter_list|(
name|Netdb_name_t
parameter_list|,
name|Netdb_name_t
parameter_list|)
function_decl|;
name|struct
name|servent
modifier|*
name|PerlSock_getservbyport
parameter_list|(
name|int
parameter_list|,
name|Netdb_name_t
parameter_list|)
function_decl|;
name|struct
name|servent
modifier|*
name|PerlSock_getservent
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
name|struct
name|servent
modifier|*
name|sent
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|OP_GSBYNAME
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GETSERVBYNAME
name|char
modifier|*
name|proto
init|=
name|POPpx
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|POPpx
decl_stmt|;
if|if
condition|(
name|proto
operator|&&
operator|!
operator|*
name|proto
condition|)
name|proto
operator|=
name|Nullch
expr_stmt|;
name|sent
operator|=
name|PerlSock_getservbyname
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservbyname"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|OP_GSBYPORT
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GETSERVBYPORT
name|char
modifier|*
name|proto
init|=
name|POPpx
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|POPu
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONS
name|port
operator|=
name|PerlSock_htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sent
operator|=
name|PerlSock_getservbyport
argument_list|(
name|port
argument_list|,
name|proto
argument_list|)
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservbyport"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
else|else
ifdef|#
directive|ifdef
name|HAS_GETSERVENT
name|sent
operator|=
name|PerlSock_getservent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GSBYNAME
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_NTOHS
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|PerlSock_ntohs
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setiv
argument_list|(
name|sv
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|sent
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|sent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|sent
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|sent
operator|->
name|s_aliases
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|PerlSock_ntohs
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setiv
argument_list|(
name|sv
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|sent
operator|->
name|s_proto
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"getservent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shostent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETHOSTENT
name|PerlSock_sethostent
argument_list|(
name|TOPi
argument_list|)
expr_stmt|;
name|RETSETYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"sethostent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_snetent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETNETENT
name|PerlSock_setnetent
argument_list|(
name|TOPi
argument_list|)
expr_stmt|;
name|RETSETYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"setnetent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sprotoent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETPROTOENT
name|PerlSock_setprotoent
argument_list|(
name|TOPi
argument_list|)
expr_stmt|;
name|RETSETYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"setprotoent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sservent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SETSERVENT
name|PerlSock_setservent
argument_list|(
name|TOPi
argument_list|)
expr_stmt|;
name|RETSETYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"setservent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ehostent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_ENDHOSTENT
name|PerlSock_endhostent
argument_list|()
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"endhostent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_enetent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_ENDNETENT
name|PerlSock_endnetent
argument_list|()
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"endnetent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_eprotoent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_ENDPROTOENT
name|PerlSock_endprotoent
argument_list|()
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"endprotoent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_eservent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_ENDSERVENT
name|PerlSock_endservent
argument_list|()
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_sock_func
argument_list|,
literal|"endservent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gpwnam
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_PASSWD
return|return
name|pp_gpwent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpwnam"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gpwuid
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_PASSWD
return|return
name|pp_gpwent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpwuid"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gpwent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_PASSWD
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwent
init|=
name|NULL
decl_stmt|;
comment|/*      * We currently support only the SysV getsp* shadow password interface.      * The interface is declared in<shadow.h> and often one needs to link      * with -lsecurity or some such.      * This interface is used at least by Solaris, HP-UX, IRIX, and Linux.      * (and SCO?)      *      * AIX getpwnam() is clever enough to return the encrypted password      * only if the caller (euid?) is root.      *      * There are at least two other shadow password APIs.  Many platforms      * seem to contain more than one interface for accessing the shadow      * password databases, possibly for compatibility reasons.      * The getsp*() is by far he simplest one, the other two interfaces      * are much more complicated, but also very similar to each other.      *      *<sys/types.h>      *<sys/security.h>      *<prot.h>      * struct pr_passwd *getprpw*();      * The password is in      * char getprpw*(...).ufld.fd_encrypt[]      * Mention HAS_GETPRPWNAM here so that Configure probes for it.      *      *<sys/types.h>      *<sys/security.h>      *<prot.h>      * struct es_passwd *getespw*();      * The password is in      * char *(getespw*(...).ufld.fd_encrypt)      * Mention HAS_GETESPWNAM here so that Configure probes for it.      *      * Mention I_PROT here so that Configure probes for it.      *      * In HP-UX for getprpw*() the manual page claims that one should include      *<hpsecurity.h> instead of<sys/security.h>, but that is not needed      * if one includes<shadow.h> as that includes<hpsecurity.h>,      * and pp_sys.c already includes<shadow.h> if there is such.      *      * Note that<sys/security.h> is already probed for, but currently      * it is only included in special cases.      *      * In Digital UNIX/Tru64 if using the getespw*() (which seems to be      * be preferred interface, even though also the getprpw*() interface      * is available) one needs to link with -lsecurity -ldb -laud -lm.      * One also needs to call set_auth_parameters() in main() before      * doing anything else, whether one is using getespw*() or getprpw*().      *      * Note that accessing the shadow databases can be magnitudes      * slower than accessing the standard databases.      *      * --jhi      */
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|OP_GPWNAM
case|:
name|pwent
operator|=
name|getpwnam
argument_list|(
name|POPpx
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_GPWUID
case|:
name|pwent
operator|=
name|getpwuid
argument_list|(
operator|(
name|Uid_t
operator|)
name|POPi
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_GPWENT
case|:
ifdef|#
directive|ifdef
name|HAS_GETPWENT
name|pwent
operator|=
name|getpwent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpwent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
break|break;
block|}
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GPWNAM
condition|)
if|#
directive|if
name|Uid_t_sign
operator|<=
literal|0
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|pwent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|SvPOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* If we have getspnam(), we try to dig up the shadow 	 * password.  If we are underprivileged, the shadow 	 * interface will set the errno to EACCES or similar, 	 * and return a null pointer.  If this happens, we will 	 * use the dummy password (usually "*" or "x") from the 	 * standard password database. 	 * 	 * In theory we could skip the shadow call completely 	 * if euid != 0 but in practice we cannot know which 	 * security measures are guarding the shadow databases 	 * on a random platform. 	 * 	 * Resist the urge to use additional shadow interfaces. 	 * Divert the urge to writing an extension instead. 	 * 	 * --jhi */
ifdef|#
directive|ifdef
name|HAS_GETSPNAM
block|{
name|struct
name|spwd
modifier|*
name|spwent
decl_stmt|;
name|int
name|saverrno
decl_stmt|;
comment|/* Save and restore errno so that 			   * underprivileged attempts seem 			   * to have never made the unsccessful 			   * attempt to retrieve the shadow password. */
name|saverrno
operator|=
name|errno
expr_stmt|;
name|spwent
operator|=
name|getspnam
argument_list|(
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saverrno
expr_stmt|;
if|if
condition|(
name|spwent
operator|&&
name|spwent
operator|->
name|sp_pwdp
condition|)
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|spwent
operator|->
name|sp_pwdp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PWPASSWD
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* Use the standard password, then. */
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
comment|/* passwd is tainted because user himself can diddle with it. 	 * admittedly not much and in a very limited way, but nevertheless. */
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|Uid_t_sign
operator|<=
literal|0
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|Uid_t_sign
operator|<=
literal|0
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|pwent
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* pw_change, pw_quota, and pw_age are mutually exclusive-- 	 * because of the poor interface of the Perl getpw*(), 	 * not because there's some standard/convention saying so. 	 * A better interface would have been to return a hash, 	 * but we are accursed by our history, alas. --jhi.  */
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWCHANGE
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_change
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWQUOTA
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_quota
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWAGE
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_age
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* pw_class and pw_comment are mutually exclusive--. 	 * see the above note for pw_change, pw_quota, and pw_age. */
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWCLASS
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_class
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWCOMMENT
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_comment
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWGECOS
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
comment|/* pw_gecos is tainted because user himself can diddle with it. */
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|pwent
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
comment|/* pw_shell is tainted because user himself can diddle with it. */
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PWEXPIRE
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|pwent
operator|->
name|pw_expire
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getpwent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_spwent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_PASSWD
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_SETPWENT
argument_list|)
name|setpwent
argument_list|()
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"setpwent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_epwent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_PASSWD
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ENDPWENT
argument_list|)
name|endpwent
argument_list|()
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"endpwent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ggrnam
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GROUP
return|return
name|pp_ggrent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getgrnam"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ggrgid
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_GROUP
return|return
name|pp_ggrent
argument_list|()
return|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getgrgid"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ggrent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GROUP
name|I32
name|which
init|=
name|PL_op
operator|->
name|op_type
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|struct
name|group
modifier|*
name|grent
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|OP_GGRNAM
condition|)
name|grent
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
name|getgrnam
argument_list|(
name|POPpx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|which
operator|==
name|OP_GGRGID
condition|)
name|grent
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
name|getgrgid
argument_list|(
name|POPi
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|HAS_GETGRENT
name|grent
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
name|getgrent
argument_list|()
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getgrent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|grent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|OP_GGRNAM
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|grent
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|grent
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|grent
condition|)
block|{
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|grent
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GRPASSWD
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|grent
operator|->
name|gr_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|grent
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|grent
operator|->
name|gr_mem
init|;
name|elem
operator|&&
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getgrent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sgrent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GROUP
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_SETGRENT
argument_list|)
name|setgrent
argument_list|()
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"setgrent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_egrent
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_GROUP
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_ENDGRENT
argument_list|)
name|endgrent
argument_list|()
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"endgrent"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_getlogin
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GETLOGIN
name|char
modifier|*
name|tmps
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps
operator|=
name|PerlProc_getlogin
argument_list|()
operator|)
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|PUSHp
argument_list|(
name|tmps
argument_list|,
name|strlen
argument_list|(
name|tmps
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"getlogin"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Miscellaneous. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_syscall
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAS_SYSCALL
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|I32
name|items
init|=
name|SP
operator|-
name|MARK
decl_stmt|;
name|unsigned
name|long
name|a
index|[
literal|20
index|]
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|0
decl_stmt|;
name|I32
name|retval
init|=
operator|-
literal|1
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_tainting
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvTAINTED
argument_list|(
operator|*
name|MARK
argument_list|)
condition|)
block|{
name|TAINT
expr_stmt|;
break|break;
block|}
block|}
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
block|}
comment|/* This probably won't work on machines where sizeof(long) != sizeof(int)      * or where sizeof(long) != sizeof(char*).  But such machines will      * not likely have syscall implemented either, so who cares?      */
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvNIOK
argument_list|(
operator|*
name|MARK
argument_list|)
operator|||
operator|!
name|i
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
name|SvIV
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|MARK
operator|==
operator|&
name|PL_sv_undef
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|a
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|SvPV_force
argument_list|(
operator|*
name|MARK
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|15
condition|)
break|break;
block|}
switch|switch
condition|(
name|items
condition|)
block|{
default|default:
name|DIE
argument_list|(
name|aTHX_
literal|"Too many args to syscall"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|DIE
argument_list|(
name|aTHX_
literal|"Too few args to syscall"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|atarist
case|case
literal|9
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|,
name|a
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|,
name|a
index|[
literal|12
index|]
argument_list|,
name|a
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* atarist */
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
argument|aTHX_ PL_no_func
argument_list|,
literal|"syscall"
argument_list|)
empty_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|FCNTL_EMULATE_FLOCK
end_ifdef

begin_comment
comment|/*  XXX Emulate flock() with fcntl().     What's really needed is a good file locking module. */
end_comment

begin_function
specifier|static
name|int
name|fcntl_emulate_flock
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|operation
parameter_list|)
block|{
name|struct
name|flock
name|flock
decl_stmt|;
switch|switch
condition|(
name|operation
operator|&
operator|~
name|LOCK_NB
condition|)
block|{
case|case
name|LOCK_SH
case|:
name|flock
operator|.
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
break|break;
case|case
name|LOCK_EX
case|:
name|flock
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
break|break;
case|case
name|LOCK_UN
case|:
name|flock
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|flock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|flock
operator|.
name|l_start
operator|=
name|flock
operator|.
name|l_len
operator|=
operator|(
name|Off_t
operator|)
literal|0
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|fd
argument_list|,
operator|(
name|operation
operator|&
name|LOCK_NB
operator|)
condition|?
name|F_SETLK
else|:
name|F_SETLKW
argument_list|,
operator|&
name|flock
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FCNTL_EMULATE_FLOCK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_EMULATE_FLOCK
end_ifdef

begin_comment
comment|/*  XXX Emulate flock() with lockf().  This is just to increase     portability of scripts.  The calls are not completely     interchangeable.  What's really needed is a good file     locking module. */
end_comment

begin_comment
comment|/*  The lockf() constants might have been defined in<unistd.h>.     Unfortunately,<unistd.h> causes troubles on some mixed     (BSD/POSIX) systems, such as SunOS 4.1.3.     Further, the lockf() constants aren't POSIX, so they might not be    visible if we're compiling with _POSIX_SOURCE defined.  Thus, we'll    just stick in the SVID values and be done with it.  Sigh. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|F_ULOCK
end_ifndef

begin_define
define|#
directive|define
name|F_ULOCK
value|0
end_define

begin_comment
comment|/* Unlock a previously locked region */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_LOCK
end_ifndef

begin_define
define|#
directive|define
name|F_LOCK
value|1
end_define

begin_comment
comment|/* Lock a region for exclusive use */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_TLOCK
end_ifndef

begin_define
define|#
directive|define
name|F_TLOCK
value|2
end_define

begin_comment
comment|/* Test and lock a region for exclusive use */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|F_TEST
end_ifndef

begin_define
define|#
directive|define
name|F_TEST
value|3
end_define

begin_comment
comment|/* Test a region for other processes locks */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|lockf_emulate_flock
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|operation
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|Off_t
name|pos
decl_stmt|;
comment|/* flock locks entire file so for lockf we need to do the same	*/
name|save_errno
operator|=
name|errno
expr_stmt|;
name|pos
operator|=
name|PerlLIO_lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|Off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* get pos to restore later */
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
comment|/* is seekable and needs to be repositioned	*/
if|if
condition|(
name|PerlLIO_lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|Off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* seek failed, so don't seek back afterwards	*/
name|errno
operator|=
name|save_errno
expr_stmt|;
switch|switch
condition|(
name|operation
condition|)
block|{
comment|/* LOCK_SH - get a shared lock */
case|case
name|LOCK_SH
case|:
comment|/* LOCK_EX - get an exclusive lock */
case|case
name|LOCK_EX
case|:
name|i
operator|=
name|lockf
argument_list|(
name|fd
argument_list|,
name|F_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* LOCK_SH|LOCK_NB - get a non-blocking shared lock */
case|case
name|LOCK_SH
operator||
name|LOCK_NB
case|:
comment|/* LOCK_EX|LOCK_NB - get a non-blocking exclusive lock */
case|case
name|LOCK_EX
operator||
name|LOCK_NB
case|:
name|i
operator|=
name|lockf
argument_list|(
name|fd
argument_list|,
name|F_TLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
operator|||
operator|(
name|errno
operator|==
name|EACCES
operator|)
condition|)
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
comment|/* LOCK_UN - unlock (non-blocking is a no-op) */
case|case
name|LOCK_UN
case|:
case|case
name|LOCK_UN
operator||
name|LOCK_NB
case|:
name|i
operator|=
name|lockf
argument_list|(
name|fd
argument_list|,
name|F_ULOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* Default - can't decipher operation */
default|default:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
comment|/* need to restore position of the handle	*/
name|PerlLIO_lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* ignore error here	*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOCKF_EMULATE_FLOCK */
end_comment

end_unit

