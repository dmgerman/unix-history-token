begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    pp.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "It's a big house this, and very peculiar.  Always a bit more to discover,  * and no knowing what you'll find around a corner.  And Elves, sir!" --Samwise  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_PP_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_comment
comment|/*  * The compiler on Concurrent CX/UX systems has a subtle bug which only  * seems to show up when compiling pp.c - it generates the wrong double  * precision constant value for (double)UV_MAX when used inline in the body  * of the code below, so this makes a static variable up front (which the  * compiler seems to get correct) and uses it in place of UV_MAX below.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CXUX_BROKEN_CONSTANT_CONVERT
end_ifdef

begin_decl_stmt
specifier|static
name|double
name|UV_MAX_cxux
init|=
operator|(
operator|(
name|double
operator|)
name|UV_MAX
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Offset for integer pack/unpack.  *  * On architectures where I16 and I32 aren't really 16 and 32 bits,  * which for now are all Crays, pack and unpack have to play games.  */
end_comment

begin_comment
comment|/*  * These values are required for portability of pack() output.  * If they're not right on your machine, then pack() and unpack()  * wouldn't work right anyway; you'll need to apply the Cray hack.  * (I'd like to check them with #if, but you can't use sizeof() in  * the preprocessor.)  --???  */
end_comment

begin_comment
comment|/*     The appropriate SHORTSIZE, INTSIZE, LONGSIZE, and LONGLONGSIZE     defines are now in config.h.  --Andy Dougherty  April 1998  */
end_comment

begin_define
define|#
directive|define
name|SIZE16
value|2
end_define

begin_define
define|#
directive|define
name|SIZE32
value|4
end_define

begin_comment
comment|/* CROSSCOMPILE and MULTIARCH are going to affect pp_pack() and pp_unpack().    --jhi Feb 1999 */
end_comment

begin_if
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
operator|||
name|LONGSIZE
operator|!=
name|SIZE32
end_if

begin_define
define|#
directive|define
name|PERL_NATINT_PACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LONGSIZE
operator|>
literal|4
operator|&&
name|defined
argument_list|(
name|_CRAY
argument_list|)
end_if

begin_if
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x12345678
end_if

begin_define
define|#
directive|define
name|OFF16
parameter_list|(
name|p
parameter_list|)
value|(char*)(p)
end_define

begin_define
define|#
directive|define
name|OFF32
parameter_list|(
name|p
parameter_list|)
value|(char*)(p)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x87654321
end_if

begin_define
define|#
directive|define
name|OFF16
parameter_list|(
name|p
parameter_list|)
value|((char*)(p) + (sizeof(U16) - SIZE16))
end_define

begin_define
define|#
directive|define
name|OFF32
parameter_list|(
name|p
parameter_list|)
value|((char*)(p) + (sizeof(U32) - SIZE32))
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
unit|}}}}
name|bad
name|cray
name|byte
name|order
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|COPY16
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*(p) = 0, Copy(s, OFF16(p), SIZE16, char))
define|#
directive|define
name|COPY32
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*(p) = 0, Copy(s, OFF32(p), SIZE32, char))
define|#
directive|define
name|COPYNN
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|(*(p) = 0, Copy(s, (char *)(p), n, char))
define|#
directive|define
name|CAT16
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, OFF16(p), SIZE16)
define|#
directive|define
name|CAT32
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, OFF32(p), SIZE32)
else|#
directive|else
define|#
directive|define
name|COPY16
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|Copy(s, p, SIZE16, char)
define|#
directive|define
name|COPY32
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|Copy(s, p, SIZE32, char)
define|#
directive|define
name|COPYNN
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|Copy(s, (char *)(p), n, char)
define|#
directive|define
name|CAT16
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, (char*)(p), SIZE16)
define|#
directive|define
name|CAT32
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, (char*)(p), SIZE32)
endif|#
directive|endif
comment|/* variations on pp_null */
comment|/* XXX I can't imagine anyone who doesn't have this actually _needs_    it, since pid_t is an integral type.    --AD  2/20/1998 */
ifdef|#
directive|ifdef
name|NEED_GETPID_PROTO
specifier|extern
name|Pid_t
name|getpid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_stub
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
name|GIMME_V
operator|==
name|G_SCALAR
condition|)
name|XPUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scalar
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_comment
comment|/* Pushy stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_padav
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|SAVECLEARSV
argument_list|(
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LVRET
condition|)
block|{
if|if
condition|(
name|GIMME
operator|==
name|G_SCALAR
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't return array to lvalue scalar context"
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|I32
name|maxarg
init|=
name|AvFILL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
operator|+
literal|1
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|maxarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|TARG
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxarg
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SP
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|svp
operator|)
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|maxarg
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|SP
operator|+=
name|maxarg
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|I32
name|maxarg
init|=
name|AvFILL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
operator|+
literal|1
decl_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|maxarg
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_padhv
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|gimme
decl_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|SAVECLEARSV
argument_list|(
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
name|RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|LVRET
condition|)
block|{
if|if
condition|(
name|GIMME
operator|==
name|G_SCALAR
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't return hash to lvalue scalar context"
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|gimme
operator|=
name|GIMME_V
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|RETURNOP
argument_list|(
name|do_kv
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|HvFILL
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|TARG
argument_list|)
condition|)
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"%ld/%ld"
argument_list|,
argument|(long)HvFILL((HV*)TARG)
argument_list|,
argument|(long)HvMAX((HV*)TARG) +
literal|1
argument_list|)
empty_stmt|;
else|else
name|sv_setiv
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_padany
argument_list|)
end_macro

begin_block
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"NOT IMPL LINE %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Translations. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_rv2gv
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|wasref
label|:
name|tryAMAGICunDEREF
argument_list|(
name|to_gv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVIO
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_init
argument_list|(
name|gv
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvIOp
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|IO
operator|*
operator|)
name|sv
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Not a GLOB reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|wasref
goto|;
block|}
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
comment|/* If this is a 'my' scalar and flag is set then vivify  		 * NI-S 1999/05/07 		 */
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpDEREF
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
name|cUNOP
operator|->
name|op_targ
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|SV
modifier|*
name|namesv
init|=
name|PL_curpad
index|[
name|cUNOP
operator|->
name|op_targ
index|]
decl_stmt|;
name|name
operator|=
name|SvPV
argument_list|(
name|namesv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gv_init
argument_list|(
name|gv
argument_list|,
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|CopSTASHPV
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|gv
operator|=
name|newGVgen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv
expr_stmt|;
name|SvROK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|wasref
goto|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|||
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"a symbol"
argument_list|)
empty_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
name|RETSETUNDEF
expr_stmt|;
block|}
name|sym
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
operator|&&
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|)
condition|)
block|{
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|&&
operator|(
operator|!
name|is_gv_magical
argument_list|(
name|sym
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
operator|(
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVGV
argument_list|)
operator|)
operator|)
condition|)
block|{
name|RETSETUNDEF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_symref
argument_list|,
argument|sym
argument_list|,
literal|"a symbol"
argument_list|)
empty_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_gp
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|,
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rv2sv
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|wasref
label|:
name|tryAMAGICunDEREF
argument_list|(
name|to_sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
name|DIE
argument_list|(
name|aTHX_
literal|"Not a SCALAR reference"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|sv
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|wasref
goto|;
block|}
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|||
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_usym
argument_list|,
literal|"a SCALAR"
argument_list|)
empty_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
name|RETSETUNDEF
expr_stmt|;
block|}
name|sym
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
operator|&&
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|)
condition|)
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|FALSE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gv
operator|&&
operator|(
operator|!
name|is_gv_magical
argument_list|(
name|sym
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
operator|(
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
operator|)
operator|)
condition|)
block|{
name|RETSETUNDEF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_symref
argument_list|,
argument|sym
argument_list|,
literal|"a SCALAR"
argument_list|)
empty_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
block|}
block|}
name|sv
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|sv
operator|=
name|save_scalar
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|TOPs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpDEREF
condition|)
name|vivify_ref
argument_list|(
name|sv
argument_list|,
name|PL_op
operator|->
name|op_private
operator|&
name|OPpDEREF
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_av2arylen
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|TOPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|AvARYLEN
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
block|{
name|AvARYLEN
argument_list|(
name|av
argument_list|)
operator|=
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'#'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_pos
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|dPOPss
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|||
name|LVRET
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'.'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|sv
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* no SvSETMAGIC */
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|&&
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
block|{
name|I32
name|i
init|=
name|mg
operator|->
name|mg_len
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_pos_b2u
argument_list|(
name|sv
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|i
operator|+
name|PL_curcop
operator|->
name|cop_arybase
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rv2cv
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
comment|/* We usually try to add a non-existent subroutine in case of AUTOLOAD. */
comment|/* (But not in defined().) */
name|CV
modifier|*
name|cv
init|=
name|sv_2cv
argument_list|(
name|TOPs
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
condition|)
block|{
if|if
condition|(
name|gv
operator|&&
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|==
name|cv
operator|&&
operator|(
name|gv
operator|=
name|gv_autoload4
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CvLVALUE
argument_list|(
name|cv
argument_list|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't modify non-lvalue subroutine call"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
operator|&
name|PL_sv_undef
expr_stmt|;
name|SETs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_prototype
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|>=
literal|7
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|TOPs
argument_list|)
decl_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"CORE::"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|keyword
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
comment|/* Overridable. */
define|#
directive|define
name|MAX_ARGS_OP
value|((sizeof(I32) - 1) * 2)
name|int
name|i
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|seen_question
init|=
literal|0
decl_stmt|;
name|I32
name|oa
decl_stmt|;
name|char
name|str
index|[
name|MAX_ARGS_OP
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
comment|/* One ';', one '\0' */
while|while
condition|(
name|i
operator|<
name|MAXO
condition|)
block|{
comment|/* The slow way. */
if|if
condition|(
name|strEQ
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|PL_op_name
index|[
name|i
index|]
argument_list|)
operator|||
name|strEQ
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|PL_op_desc
index|[
name|i
index|]
argument_list|)
condition|)
block|{
goto|goto
name|found
goto|;
block|}
name|i
operator|++
expr_stmt|;
block|}
goto|goto
name|nonesuch
goto|;
comment|/* Should not happen... */
name|found
label|:
name|oa
operator|=
name|PL_opargs
index|[
name|i
index|]
operator|>>
name|OASHIFT
expr_stmt|;
while|while
condition|(
name|oa
condition|)
block|{
if|if
condition|(
name|oa
operator|&
name|OA_OPTIONAL
condition|)
block|{
name|seen_question
operator|=
literal|1
expr_stmt|;
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|';'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|';'
operator|&&
name|seen_question
condition|)
goto|goto
name|set
goto|;
comment|/* XXXX system, exec */
if|if
condition|(
operator|(
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
operator|)
operator|>=
name|OA_AVREF
operator|&&
operator|(
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
operator|)
operator|<=
name|OA_HVREF
condition|)
block|{
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
comment|/* What to do with R ((un)tie, tied, (sys)read, recv)? */
name|str
index|[
name|n
operator|++
index|]
operator|=
operator|(
literal|"?$@@%&*$"
operator|)
index|[
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|oa
operator|=
name|oa
operator|>>
literal|4
expr_stmt|;
block|}
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|str
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
condition|)
comment|/* Non-Overridable */
goto|goto
name|set
goto|;
else|else
block|{
comment|/* None such */
name|nonesuch
label|:
name|DIE
argument_list|(
name|aTHX_
literal|"Can't find an opnumber for \"%s\""
argument_list|,
name|s
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cv
operator|=
name|sv_2cv
argument_list|(
name|TOPs
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
name|ret
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|SvPVX
argument_list|(
name|cv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set
label|:
name|SETs
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anoncode
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|CV
modifier|*
name|cv
init|=
operator|(
name|CV
operator|*
operator|)
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
decl_stmt|;
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_srefgen
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
operator|*
name|SP
operator|=
name|refto
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_refgen
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
operator|*
name|MARK
operator|=
name|refto
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|EXTEND_MORTAL
argument_list|(
name|SP
operator|-
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
name|refto
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|SV
modifier|*
name|S_refto
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVLV
operator|&&
name|LvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|LvTARGLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|vivify_defelem
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sv
operator|=
name|LvTARG
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
operator|&&
name|AvREIFY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
condition|)
name|av_reify
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
name|sv
operator|=
name|newSVsv
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
block|{
name|SvTEMP_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|sv_upgrade
argument_list|(
name|rv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|rv
argument_list|)
operator|=
name|sv
expr_stmt|;
name|SvROK_on
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_ref
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|pv
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|sv
operator|&&
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHNO
expr_stmt|;
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|pv
operator|=
name|sv_reftype
argument_list|(
name|sv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|PUSHp
argument_list|(
name|pv
argument_list|,
name|strlen
argument_list|(
name|pv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bless
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|1
condition|)
name|stash
operator|=
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
else|else
block|{
name|SV
modifier|*
name|ssv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|SvPV
argument_list|(
name|ssv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
name|len
operator|==
literal|0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Explicit blessing to '' (assuming package main)"
argument_list|)
empty_stmt|;
name|stash
operator|=
name|gv_stashpvn
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sv_bless
argument_list|(
name|TOPs
argument_list|,
name|stash
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gelem
argument_list|)
end_macro

begin_block
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
name|tmpRef
decl_stmt|;
name|char
modifier|*
name|elem
decl_stmt|;
name|dSP
expr_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|elem
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
name|tmpRef
operator|=
name|Nullsv
expr_stmt|;
name|sv
operator|=
name|Nullsv
expr_stmt|;
switch|switch
condition|(
name|elem
condition|?
operator|*
name|elem
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"ARRAY"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvAV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"CODE"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvCVu
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"FILEHANDLE"
argument_list|)
condition|)
comment|/* XXX deprecate in 5.005 */
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"GLOB"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"HASH"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvHV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"IO"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"NAME"
argument_list|)
condition|)
name|sv
operator|=
name|newSVpvn
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"PACKAGE"
argument_list|)
condition|)
name|sv
operator|=
name|newSVpv
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"SCALAR"
argument_list|)
condition|)
name|tmpRef
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmpRef
condition|)
name|sv
operator|=
name|newRV
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
condition|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pattern matching */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_study
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dPOPss
expr_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|I32
name|pos
decl_stmt|;
specifier|register
name|I32
name|ch
decl_stmt|;
specifier|register
name|I32
modifier|*
name|sfirst
decl_stmt|;
specifier|register
name|I32
modifier|*
name|snext
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|sv
operator|==
name|PL_lastscream
condition|)
block|{
if|if
condition|(
name|SvSCREAM
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_lastscream
condition|)
block|{
name|SvSCREAM_off
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
block|}
name|PL_lastscream
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
name|RETPUSHNO
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|PL_maxscream
condition|)
block|{
if|if
condition|(
name|PL_maxscream
operator|<
literal|0
condition|)
block|{
name|PL_maxscream
operator|=
name|pos
operator|+
literal|80
expr_stmt|;
name|New
argument_list|(
literal|301
argument_list|,
name|PL_screamfirst
argument_list|,
literal|256
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|302
argument_list|,
name|PL_screamnext
argument_list|,
name|PL_maxscream
argument_list|,
name|I32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_maxscream
operator|=
name|pos
operator|+
name|pos
operator|/
literal|4
expr_stmt|;
name|Renew
argument_list|(
name|PL_screamnext
argument_list|,
name|PL_maxscream
argument_list|,
name|I32
argument_list|)
expr_stmt|;
block|}
block|}
name|sfirst
operator|=
name|PL_screamfirst
expr_stmt|;
name|snext
operator|=
name|PL_screamnext
expr_stmt|;
if|if
condition|(
operator|!
name|sfirst
operator|||
operator|!
name|snext
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"do_study: out of memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|256
init|;
name|ch
condition|;
operator|--
name|ch
control|)
operator|*
name|sfirst
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|sfirst
operator|-=
literal|256
expr_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|ch
operator|=
name|s
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|sfirst
index|[
name|ch
index|]
operator|>=
literal|0
condition|)
name|snext
index|[
name|pos
index|]
operator|=
name|sfirst
index|[
name|ch
index|]
operator|-
name|pos
expr_stmt|;
else|else
name|snext
index|[
name|pos
index|]
operator|=
operator|-
name|pos
expr_stmt|;
name|sfirst
index|[
name|ch
index|]
operator|=
name|pos
expr_stmt|;
block|}
name|SvSCREAM_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'g'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* piggyback on m//g magic */
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_trans
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARG
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|sv
operator|=
name|POPs
expr_stmt|;
else|else
block|{
name|sv
operator|=
name|DEFSV
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|TARG
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|PUSHi
argument_list|(
name|do_trans
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Lvalue operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_schop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|do_chop
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|dORIGMARK
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
name|do_chop
argument_list|(
name|TARG
argument_list|,
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_schomp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SETi
argument_list|(
name|do_chomp
argument_list|(
name|TOPs
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chomp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|I32
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|SP
operator|>
name|MARK
condition|)
name|count
operator|+=
name|do_chomp
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_defined
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|!
name|SvANY
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHNO
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
if|if
condition|(
name|AvMAX
argument_list|(
name|sv
argument_list|)
operator|>=
literal|0
operator|||
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvRMAGICAL
argument_list|(
name|sv
argument_list|)
operator|&&
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
if|if
condition|(
name|HvARRAY
argument_list|(
name|sv
argument_list|)
operator|||
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvRMAGICAL
argument_list|(
name|sv
argument_list|)
operator|&&
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|CvROOT
argument_list|(
name|sv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_undef
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|PL_op
operator|->
name|op_private
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_force_normal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
break|break;
case|case
name|SVt_PVAV
case|:
name|av_undef
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|hv_undef
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
name|cv_const_sv
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Constant subroutine %s undefined"
argument_list|,
argument|CvANON((CV*)sv) ?
literal|"(anonymous)"
argument|: GvENAME(CvGV((CV*)sv))
argument_list|)
empty_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVFM
case|:
block|{
comment|/* let user-undef'd sub keep its identity */
name|GV
modifier|*
name|gv
init|=
name|CvGV
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
decl_stmt|;
name|cv_undef
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
operator|=
name|gv
expr_stmt|;
block|}
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
name|SvSetMagicSV
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|GP
modifier|*
name|gp
decl_stmt|;
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|602
argument_list|,
name|gp
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|sv
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|sv
argument_list|)
operator|=
name|NEWSV
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvLINE
argument_list|(
name|sv
argument_list|)
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|GvEGV
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
operator|&&
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|sv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_predec
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvIOK_notUV
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MIN
condition|)
block|{
operator|--
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_dec
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_postinc
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK_notUV
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MAX
condition|)
block|{
operator|++
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_inc
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|TARG
argument_list|)
condition|)
name|sv_setiv
argument_list|(
name|TARG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_postdec
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_modify
argument_list|)
empty_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK_notUV
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MIN
condition|)
block|{
operator|--
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_dec
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_comment
comment|/* Ordinary operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_pow
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|pow
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|Perl_pow
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_multiply
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|mult
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|left
operator|*
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_divide
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|div
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPPOPnnrl
expr_stmt|;
name|NV
name|value
decl_stmt|;
if|if
condition|(
name|right
operator|==
literal|0.0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Illegal division by zero"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SLOPPYDIVIDE
comment|/* insure that 20./5. == 4. */
block|{
name|IV
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|NV
operator|)
name|I_V
argument_list|(
name|left
argument_list|)
operator|==
name|left
operator|&&
operator|(
name|NV
operator|)
name|I_V
argument_list|(
name|right
argument_list|)
operator|==
name|right
operator|&&
operator|(
name|k
operator|=
name|I_V
argument_list|(
name|left
argument_list|)
operator|/
name|I_V
argument_list|(
name|right
argument_list|)
operator|)
operator|*
name|I_V
argument_list|(
name|right
argument_list|)
operator|==
name|I_V
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|value
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|left
operator|/
name|right
expr_stmt|;
block|}
block|}
else|#
directive|else
name|value
operator|=
name|left
operator|/
name|right
expr_stmt|;
endif|#
directive|endif
name|PUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_modulo
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|modulo
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|UV
name|left
decl_stmt|;
name|UV
name|right
decl_stmt|;
name|bool
name|left_neg
decl_stmt|;
name|bool
name|right_neg
decl_stmt|;
name|bool
name|use_double
init|=
literal|0
decl_stmt|;
name|NV
name|dright
decl_stmt|;
name|NV
name|dleft
decl_stmt|;
if|if
condition|(
name|SvIOK_notUV
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|IV
name|i
init|=
name|SvIVX
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
name|right
operator|=
operator|(
name|right_neg
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
block|}
else|else
block|{
name|dright
operator|=
name|POPn
expr_stmt|;
name|use_double
operator|=
literal|1
expr_stmt|;
name|right_neg
operator|=
name|dright
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|right_neg
condition|)
name|dright
operator|=
operator|-
name|dright
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_double
operator|&&
name|SvIOK_notUV
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|IV
name|i
init|=
name|SvIVX
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
name|left
operator|=
operator|(
name|left_neg
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
block|}
else|else
block|{
name|dleft
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
operator|!
name|use_double
condition|)
block|{
name|use_double
operator|=
literal|1
expr_stmt|;
name|dright
operator|=
name|right
expr_stmt|;
block|}
name|left_neg
operator|=
name|dleft
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|left_neg
condition|)
name|dleft
operator|=
operator|-
name|dleft
expr_stmt|;
block|}
if|if
condition|(
name|use_double
condition|)
block|{
name|NV
name|dans
decl_stmt|;
if|#
directive|if
literal|1
comment|/* Somehow U_V is pessimized even if CASTFLAGS is 0 */
if|#
directive|if
name|CASTFLAGS
operator|&
literal|2
define|#
directive|define
name|CAST_D2UV
parameter_list|(
name|d
parameter_list|)
value|U_V(d)
else|#
directive|else
define|#
directive|define
name|CAST_D2UV
parameter_list|(
name|d
parameter_list|)
value|((UV)(d))
endif|#
directive|endif
comment|/* Tried to do this only in the case DOUBLESIZE<= UV_SIZE, 	     * or, in other words, precision of UV more than of NV. 	     * But in fact the approach below turned out to be an 	     * optimization - floor() may be slow */
if|if
condition|(
name|dright
operator|<=
name|UV_MAX
operator|&&
name|dleft
operator|<=
name|UV_MAX
condition|)
block|{
name|right
operator|=
name|CAST_D2UV
argument_list|(
name|dright
argument_list|)
expr_stmt|;
name|left
operator|=
name|CAST_D2UV
argument_list|(
name|dleft
argument_list|)
expr_stmt|;
goto|goto
name|do_uv
goto|;
block|}
endif|#
directive|endif
comment|/* Backward-compatibility clause: */
name|dright
operator|=
name|Perl_floor
argument_list|(
name|dright
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|dleft
operator|=
name|Perl_floor
argument_list|(
name|dleft
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dright
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
name|dans
operator|=
name|Perl_fmod
argument_list|(
name|dleft
argument_list|,
name|dright
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|left_neg
operator|!=
name|right_neg
operator|)
operator|&&
name|dans
condition|)
name|dans
operator|=
name|dright
operator|-
name|dans
expr_stmt|;
if|if
condition|(
name|right_neg
condition|)
name|dans
operator|=
operator|-
name|dans
expr_stmt|;
name|sv_setnv
argument_list|(
name|TARG
argument_list|,
name|dans
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|ans
decl_stmt|;
name|do_uv
label|:
if|if
condition|(
operator|!
name|right
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
name|ans
operator|=
name|left
operator|%
name|right
expr_stmt|;
if|if
condition|(
operator|(
name|left_neg
operator|!=
name|right_neg
operator|)
operator|&&
name|ans
condition|)
name|ans
operator|=
name|right
operator|-
name|ans
expr_stmt|;
if|if
condition|(
name|right_neg
condition|)
block|{
comment|/* XXX may warn: unary minus operator applied to unsigned type */
comment|/* could change -foo to be (~foo)+1 instead	*/
if|if
condition|(
name|ans
operator|<=
operator|~
operator|(
operator|(
name|UV
operator|)
name|IV_MAX
operator|)
operator|+
literal|1
condition|)
name|sv_setiv
argument_list|(
name|TARG
argument_list|,
operator|~
name|ans
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|TARG
argument_list|,
operator|-
operator|(
name|NV
operator|)
name|ans
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setuv
argument_list|(
name|TARG
argument_list|,
name|ans
argument_list|)
expr_stmt|;
block|}
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_repeat
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|repeat
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
specifier|register
name|IV
name|count
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpREPEAT_DOLIST
condition|)
block|{
name|dMARK
expr_stmt|;
name|I32
name|items
init|=
name|SP
operator|-
name|MARK
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|max
operator|=
name|items
operator|*
name|count
expr_stmt|;
name|MEXTEND
argument_list|(
name|MARK
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|SP
operator|>
name|MARK
condition|)
block|{
if|if
condition|(
operator|*
name|SP
condition|)
name|SvTEMP_off
argument_list|(
operator|(
operator|*
name|SP
operator|)
argument_list|)
expr_stmt|;
name|SP
operator|--
expr_stmt|;
block|}
name|MARK
operator|++
expr_stmt|;
name|repeatcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|MARK
operator|+
name|items
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MARK
argument_list|,
name|items
operator|*
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|SP
operator|-=
name|items
expr_stmt|;
block|}
else|else
block|{
comment|/* Note: mark already snarfed by pp_list */
name|SV
modifier|*
name|tmpstr
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|bool
name|isutf
decl_stmt|;
name|SvSetSV
argument_list|(
name|TARG
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isutf
operator|=
name|DO_UTF8
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|1
condition|)
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|count
operator|*
name|len
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|SvPVX
argument_list|(
name|TARG
argument_list|)
operator|+
name|len
argument_list|,
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|,
name|len
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|TARG
argument_list|)
operator|*=
name|count
expr_stmt|;
block|}
operator|*
name|SvEND
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|isutf
condition|)
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|PUSHTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_subtract
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|subtr
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl_ul
expr_stmt|;
name|SETn
argument_list|(
name|left
operator|-
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_left_shift
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|lshift
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|IV
name|shift
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
name|TOPi
decl_stmt|;
name|SETi
argument_list|(
name|i
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
name|TOPu
decl_stmt|;
name|SETu
argument_list|(
name|u
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_right_shift
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|rshift
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|IV
name|shift
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
name|TOPi
decl_stmt|;
name|SETi
argument_list|(
name|i
operator|>>
name|shift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
name|TOPu
decl_stmt|;
name|SETu
argument_list|(
name|u
operator|>>
name|shift
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|lt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|<
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|>
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_le
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|le
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|<=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ge
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|>=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ne
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|!=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ncmp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|ncmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|I32
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|Perl_isnan
if|if
condition|(
name|Perl_isnan
argument_list|(
name|left
argument_list|)
operator|||
name|Perl_isnan
argument_list|(
name|right
argument_list|)
condition|)
block|{
name|SETs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|left
operator|>
name|right
operator|)
operator|-
operator|(
name|left
operator|<
name|right
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|left
operator|==
name|right
condition|)
name|value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|<
name|right
condition|)
name|value
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|>
name|right
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SETs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
endif|#
directive|endif
name|SETi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_slt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|slt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sgt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sgt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sle
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|<=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sge
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|>=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_seq
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|sv_eq
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sne
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
operator|!
name|sv_eq
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scmp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|scmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETi
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_and
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|band
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
name|SvIV
argument_list|(
name|left
argument_list|)
operator|&
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
name|SvUV
argument_list|(
name|left
argument_list|)
operator|&
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_xor
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|bxor
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvIV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator|^
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvUV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator|^
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_or
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|bor
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvIV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator||
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvUV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator||
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_negate
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|neg
argument_list|)
expr_stmt|;
block|{
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|IV_MIN
condition|)
block|{
name|SETi
argument_list|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* special case: -((UV)IV_MAX+1) == IV_MIN */
name|RETURN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|<=
name|IV_MAX
condition|)
block|{
name|SETi
argument_list|(
operator|-
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
name|IV_MIN
condition|)
block|{
name|SETi
argument_list|(
operator|-
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
condition|)
name|SETn
argument_list|(
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
operator|*
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|?
literal|'+'
else|:
literal|'-'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
operator|&&
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isIDFIRST_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setnv
argument_list|(
name|TARG
argument_list|,
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
else|else
name|SETn
argument_list|(
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_not
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICunSET
argument_list|(
name|not
argument_list|)
expr_stmt|;
operator|*
name|PL_stack_sp
operator|=
name|boolSV
argument_list|(
operator|!
name|SvTRUE
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_complement
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|compl
argument_list|)
expr_stmt|;
block|{
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IV
name|i
init|=
operator|~
name|SvIV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UV
name|u
init|=
operator|~
name|SvUV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|U8
modifier|*
name|tmps
decl_stmt|;
specifier|register
name|I32
name|anum
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|SvSetSV
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|tmps
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|anum
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|TARG
argument_list|)
condition|)
block|{
comment|/* Calculate exact length, let's not estimate. */
name|STRLEN
name|targlen
init|=
literal|0
decl_stmt|;
name|U8
modifier|*
name|result
decl_stmt|;
name|U8
modifier|*
name|send
decl_stmt|;
name|STRLEN
name|l
decl_stmt|;
name|UV
name|nchar
init|=
literal|0
decl_stmt|;
name|UV
name|nwide
init|=
literal|0
decl_stmt|;
name|send
operator|=
name|tmps
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|tmps
operator|<
name|send
condition|)
block|{
name|UV
name|c
init|=
name|utf8_to_uv
argument_list|(
name|tmps
argument_list|,
name|send
operator|-
name|tmps
argument_list|,
operator|&
name|l
argument_list|,
name|UTF8_ALLOW_ANYUV
argument_list|)
decl_stmt|;
name|tmps
operator|+=
name|UTF8SKIP
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
name|targlen
operator|+=
name|UNISKIP
argument_list|(
operator|~
name|c
argument_list|)
expr_stmt|;
name|nchar
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0xff
condition|)
name|nwide
operator|++
expr_stmt|;
block|}
comment|/* Now rewind strings and write them. */
name|tmps
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|nwide
condition|)
block|{
name|Newz
argument_list|(
literal|0
argument_list|,
name|result
argument_list|,
name|targlen
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmps
operator|<
name|send
condition|)
block|{
name|UV
name|c
init|=
name|utf8_to_uv
argument_list|(
name|tmps
argument_list|,
name|send
operator|-
name|tmps
argument_list|,
operator|&
name|l
argument_list|,
name|UTF8_ALLOW_ANYUV
argument_list|)
decl_stmt|;
name|tmps
operator|+=
name|UTF8SKIP
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
name|result
operator|=
name|uv_to_utf8
argument_list|(
name|result
argument_list|,
operator|~
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|-=
name|targlen
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
name|targlen
argument_list|)
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Newz
argument_list|(
literal|0
argument_list|,
name|result
argument_list|,
name|nchar
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmps
operator|<
name|send
condition|)
block|{
name|U8
name|c
init|=
operator|(
name|U8
operator|)
name|utf8_to_uv
argument_list|(
name|tmps
argument_list|,
literal|0
argument_list|,
operator|&
name|l
argument_list|,
name|UTF8_ALLOW_ANY
argument_list|)
decl_stmt|;
name|tmps
operator|+=
name|UTF8SKIP
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
operator|*
name|result
operator|++
operator|=
operator|~
name|c
expr_stmt|;
block|}
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|-=
name|nchar
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
name|nchar
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBERAL
block|{
specifier|register
name|long
modifier|*
name|tmpl
decl_stmt|;
for|for
control|(
init|;
name|anum
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|tmps
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|anum
operator|--
operator|,
name|tmps
operator|++
control|)
operator|*
name|tmps
operator|=
operator|~
operator|*
name|tmps
expr_stmt|;
name|tmpl
operator|=
operator|(
name|long
operator|*
operator|)
name|tmps
expr_stmt|;
for|for
control|(
init|;
name|anum
operator|>=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|anum
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|,
name|tmpl
operator|++
control|)
operator|*
name|tmpl
operator|=
operator|~
operator|*
name|tmpl
expr_stmt|;
name|tmps
operator|=
operator|(
name|U8
operator|*
operator|)
name|tmpl
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|anum
operator|>
literal|0
condition|;
name|anum
operator|--
operator|,
name|tmps
operator|++
control|)
operator|*
name|tmps
operator|=
operator|~
operator|*
name|tmps
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* integer versions of some of the above */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_i_multiply
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|mult
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|*
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_divide
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|div
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPiv
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Illegal division by zero"
argument_list|)
expr_stmt|;
name|value
operator|=
name|POPi
operator|/
name|value
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_modulo
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|modulo
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
if|if
condition|(
operator|!
name|right
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|%
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_add
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|add
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl_ul
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|+
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_subtract
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|subtr
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl_ul
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|-
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_lt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|lt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|<
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_gt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|>
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_le
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|le
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|<=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ge
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|>=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_eq
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|==
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ne
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|!=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ncmp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|ncmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|I32
name|value
decl_stmt|;
if|if
condition|(
name|left
operator|>
name|right
condition|)
name|value
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|<
name|right
condition|)
name|value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|SETi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_negate
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|neg
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
operator|-
name|TOPi
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* High falutin' math. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_atan2
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|atan2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|Perl_atan2
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sin
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|sin
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|Perl_sin
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_cos
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|cos
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|Perl_cos
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Support Configure command-line overrides for rand() functions.    After 5.005, perhaps we should replace this by Configure support    for drand48(), random(), or rand().  For 5.005, though, maintain    compatibility by calling rand() but allow the user to override it.    See INSTALL for details.  --Andy Dougherty  15 July 1998 */
end_comment

begin_comment
comment|/* Now it's after 5.005, and Configure supports drand48() and random(),    in addition to rand().  So the overrides should not be needed any more.    --Jarkko Hietaniemi	27 September 1998  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_DRAND48_PROTO
end_ifndef

begin_function_decl
specifier|extern
name|double
name|drand48
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_rand
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|NV
name|value
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
else|else
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
operator|!
name|PL_srand_called
condition|)
block|{
operator|(
name|void
operator|)
name|seedDrand01
argument_list|(
operator|(
name|Rand_seed_t
operator|)
name|seed
argument_list|()
argument_list|)
expr_stmt|;
name|PL_srand_called
operator|=
name|TRUE
expr_stmt|;
block|}
name|value
operator|*=
name|Drand01
argument_list|()
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_srand
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|UV
name|anum
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|anum
operator|=
name|seed
argument_list|()
expr_stmt|;
else|else
name|anum
operator|=
name|POPu
expr_stmt|;
operator|(
name|void
operator|)
name|seedDrand01
argument_list|(
operator|(
name|Rand_seed_t
operator|)
name|anum
argument_list|)
expr_stmt|;
name|PL_srand_called
operator|=
name|TRUE
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|U32
name|S_seed
parameter_list|(
name|pTHX
parameter_list|)
block|{
comment|/*      * This is really just a quick hack which grabs various garbage      * values.  It really should be a real hash algorithm which      * spreads the effect of every input bit onto every output bit,      * if someone who knows about such things would bother to write it.      * Might be a good idea to add that function to CORE as well.      * No numbers below come from careful analysis or anything here,      * except they are primes and SEED_C1> 1E6 to get a full-width      * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should      * probably be bigger too.      */
if|#
directive|if
name|RANDBITS
operator|>
literal|16
define|#
directive|define
name|SEED_C1
value|1000003
define|#
directive|define
name|SEED_C4
value|73819
else|#
directive|else
define|#
directive|define
name|SEED_C1
value|25747
define|#
directive|define
name|SEED_C4
value|20639
endif|#
directive|endif
define|#
directive|define
name|SEED_C2
value|3
define|#
directive|define
name|SEED_C3
value|269
define|#
directive|define
name|SEED_C5
value|26107
ifndef|#
directive|ifndef
name|PERL_NO_DEV_RANDOM
name|int
name|fd
decl_stmt|;
endif|#
directive|endif
name|U32
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
include|#
directive|include
file|<starlet.h>
comment|/* when[] = (low 32 bits, high 32 bits) of time since epoch      * in 100-ns units, typically incremented ever 10 ms.        */
name|unsigned
name|int
name|when
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_GETTIMEOFDAY
name|struct
name|timeval
name|when
decl_stmt|;
else|#
directive|else
name|Time_t
name|when
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* This test is an escape hatch, this symbol isn't set by Configure. */
ifndef|#
directive|ifndef
name|PERL_NO_DEV_RANDOM
ifndef|#
directive|ifndef
name|PERL_RANDOM_DEVICE
comment|/* /dev/random isn't used by default because reads from it will block     * if there isn't enough entropy available.  You can compile with     * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there     * is enough real entropy to fill the seed. */
define|#
directive|define
name|PERL_RANDOM_DEVICE
value|"/dev/urandom"
endif|#
directive|endif
name|fd
operator|=
name|PerlLIO_open
argument_list|(
name|PERL_RANDOM_DEVICE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|PerlLIO_read
argument_list|(
name|fd
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|!=
sizeof|sizeof
name|u
condition|)
name|u
operator|=
literal|0
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
return|return
name|u
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
name|_ckvmssts
argument_list|(
name|sys$gettim
argument_list|(
name|when
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
index|[
literal|0
index|]
operator|+
operator|(
name|U32
operator|)
name|SEED_C2
operator|*
name|when
index|[
literal|1
index|]
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_GETTIMEOFDAY
name|gettimeofday
argument_list|(
operator|&
name|when
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
operator|.
name|tv_sec
operator|+
operator|(
name|U32
operator|)
name|SEED_C2
operator|*
name|when
operator|.
name|tv_usec
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|u
operator|+=
name|SEED_C3
operator|*
operator|(
name|U32
operator|)
name|PerlProc_getpid
argument_list|()
expr_stmt|;
name|u
operator|+=
name|SEED_C4
operator|*
operator|(
name|U32
operator|)
name|PTR2UV
argument_list|(
name|PL_stack_sp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PLAN9
comment|/* XXX Plan9 assembler chokes on this; fix needed  */
name|u
operator|+=
name|SEED_C5
operator|*
operator|(
name|U32
operator|)
name|PTR2UV
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|u
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_exp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|Perl_exp
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_log
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0.0
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"Can't take log of %g"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|Perl_log
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sqrt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|sqrt
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"Can't take sqrt of %g"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|Perl_sqrt
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_int
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
block|{
name|NV
name|value
init|=
name|TOPn
decl_stmt|;
name|IV
name|iv
decl_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|iv
operator|=
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MODFL
argument_list|)
operator|||
name|defined
argument_list|(
name|LONG_DOUBLE_EQUALS_DOUBLE
argument_list|)
operator|(
name|void
operator|)
name|Perl_modf
argument_list|(
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|double
name|tmp
init|=
operator|(
name|double
operator|)
name|value
decl_stmt|;
operator|(
name|void
operator|)
name|Perl_modf
argument_list|(
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|NV
operator|)
name|tmp
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_MODFL
argument_list|)
operator|||
name|defined
argument_list|(
name|LONG_DOUBLE_EQUALS_DOUBLE
argument_list|)
operator|(
name|void
operator|)
name|Perl_modf
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
else|#
directive|else
name|double
name|tmp
init|=
operator|(
name|double
operator|)
name|value
decl_stmt|;
operator|(
name|void
operator|)
name|Perl_modf
argument_list|(
operator|-
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
operator|(
name|NV
operator|)
name|tmp
expr_stmt|;
endif|#
directive|endif
block|}
name|iv
operator|=
name|I_V
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|==
name|value
condition|)
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
else|else
name|SETn
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_abs
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|abs
argument_list|)
expr_stmt|;
block|{
name|NV
name|value
init|=
name|TOPn
decl_stmt|;
name|IV
name|iv
decl_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|(
name|iv
operator|=
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|)
operator|!=
name|IV_MIN
condition|)
block|{
if|if
condition|(
name|iv
operator|<
literal|0
condition|)
name|iv
operator|=
operator|-
name|iv
expr_stmt|;
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|SETn
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_hex
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|argtype
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|tmps
operator|=
operator|(
name|SvPVx
argument_list|(
name|POPs
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
name|argtype
operator|=
literal|1
expr_stmt|;
comment|/* allow underscores */
name|XPUSHn
argument_list|(
name|scan_hex
argument_list|(
name|tmps
argument_list|,
name|len
argument_list|,
operator|&
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_oct
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|NV
name|value
decl_stmt|;
name|STRLEN
name|argtype
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|tmps
operator|=
operator|(
name|SvPVx
argument_list|(
name|POPs
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|tmps
operator|&&
name|len
operator|&&
name|isSPACE
argument_list|(
operator|*
name|tmps
argument_list|)
condition|)
name|tmps
operator|++
operator|,
name|len
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'0'
condition|)
name|tmps
operator|++
operator|,
name|len
operator|--
expr_stmt|;
name|argtype
operator|=
literal|1
expr_stmt|;
comment|/* allow underscores */
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'x'
condition|)
name|value
operator|=
name|scan_hex
argument_list|(
operator|++
name|tmps
argument_list|,
operator|--
name|len
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'b'
condition|)
name|value
operator|=
name|scan_bin
argument_list|(
operator|++
name|tmps
argument_list|,
operator|--
name|len
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|scan_oct
argument_list|(
name|tmps
argument_list|,
name|len
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* String stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_length
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|SETi
argument_list|(
name|sv_len_utf8
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SETi
argument_list|(
name|sv_len
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_substr
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|STRLEN
name|curlen
decl_stmt|;
name|STRLEN
name|utf8_curlen
decl_stmt|;
name|I32
name|pos
decl_stmt|;
name|I32
name|rem
decl_stmt|;
name|I32
name|fail
decl_stmt|;
name|I32
name|lvalue
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|||
name|LVRET
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|SV
modifier|*
name|repl_sv
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|repl
init|=
literal|0
decl_stmt|;
name|STRLEN
name|repl_len
decl_stmt|;
name|int
name|num_args
init|=
name|PL_op
operator|->
name|op_private
operator|&
literal|7
decl_stmt|;
name|bool
name|repl_need_utf8_upgrade
init|=
name|FALSE
decl_stmt|;
name|bool
name|repl_is_utf8
init|=
name|FALSE
decl_stmt|;
name|SvTAINTED_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
if|if
condition|(
name|num_args
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|num_args
operator|>
literal|3
condition|)
block|{
name|repl_sv
operator|=
name|POPs
expr_stmt|;
name|repl
operator|=
name|SvPV
argument_list|(
name|repl_sv
argument_list|,
name|repl_len
argument_list|)
expr_stmt|;
name|repl_is_utf8
operator|=
name|DO_UTF8
argument_list|(
name|repl_sv
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|repl_sv
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|POPi
expr_stmt|;
block|}
name|pos
operator|=
name|POPi
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|repl_sv
condition|)
block|{
if|if
condition|(
name|repl_is_utf8
condition|)
block|{
if|if
condition|(
operator|!
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|repl_need_utf8_upgrade
operator|=
name|TRUE
expr_stmt|;
block|}
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|utf8_curlen
operator|=
name|sv_len_utf8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_curlen
operator|==
name|curlen
condition|)
name|utf8_curlen
operator|=
literal|0
expr_stmt|;
else|else
name|curlen
operator|=
name|utf8_curlen
expr_stmt|;
block|}
else|else
name|utf8_curlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|arybase
condition|)
block|{
name|pos
operator|-=
name|arybase
expr_stmt|;
name|rem
operator|=
name|curlen
operator|-
name|pos
expr_stmt|;
name|fail
operator|=
name|rem
expr_stmt|;
if|if
condition|(
name|num_args
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|rem
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
name|rem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rem
operator|>
name|len
condition|)
name|rem
operator|=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|pos
operator|+=
name|curlen
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|3
condition|)
name|rem
operator|=
name|curlen
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|rem
operator|=
name|pos
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|>
operator|(
name|I32
operator|)
name|curlen
condition|)
name|rem
operator|=
name|curlen
expr_stmt|;
block|}
else|else
block|{
name|rem
operator|=
name|curlen
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|<
name|pos
condition|)
name|rem
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|fail
operator|=
name|rem
expr_stmt|;
name|rem
operator|-=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|fail
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lvalue
operator|||
name|repl
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"substr outside of string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SUBSTR
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SUBSTR
argument_list|,
literal|"substr outside of string"
argument_list|)
empty_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
else|else
block|{
name|I32
name|upos
init|=
name|pos
decl_stmt|;
name|I32
name|urem
init|=
name|rem
decl_stmt|;
if|if
condition|(
name|utf8_curlen
condition|)
name|sv_pos_u2b
argument_list|(
name|sv
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
name|tmps
operator|+=
name|pos
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
name|tmps
argument_list|,
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_curlen
condition|)
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl
condition|)
block|{
name|SV
modifier|*
name|repl_sv_copy
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|repl_need_utf8_upgrade
condition|)
block|{
name|repl_sv_copy
operator|=
name|newSVsv
argument_list|(
name|repl_sv
argument_list|)
expr_stmt|;
name|sv_utf8_upgrade
argument_list|(
name|repl_sv_copy
argument_list|)
expr_stmt|;
name|repl
operator|=
name|SvPV
argument_list|(
name|repl_sv_copy
argument_list|,
name|repl_len
argument_list|)
expr_stmt|;
name|repl_is_utf8
operator|=
name|DO_UTF8
argument_list|(
name|repl_sv_copy
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|sv_insert
argument_list|(
name|sv
argument_list|,
name|pos
argument_list|,
name|rem
argument_list|,
name|repl
argument_list|,
name|repl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_is_utf8
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_sv_copy
condition|)
name|SvREFCNT_dec
argument_list|(
name|repl_sv_copy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue
condition|)
block|{
comment|/* it's an lvalue! */
if|if
condition|(
operator|!
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SUBSTR
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SUBSTR
argument_list|,
literal|"Attempt to use reference as lvalue in substr"
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* is it defined ? */
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* avoid lexical reincarnation */
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'x'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|sv
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|LvTARGOFF
argument_list|(
name|TARG
argument_list|)
operator|=
name|upos
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|TARG
argument_list|)
operator|=
name|urem
expr_stmt|;
block|}
block|}
name|SPAGAIN
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* avoid SvSETMAGIC here */
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_vec
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|IV
name|size
init|=
name|POPi
decl_stmt|;
specifier|register
name|IV
name|offset
init|=
name|POPi
decl_stmt|;
specifier|register
name|SV
modifier|*
name|src
init|=
name|POPs
decl_stmt|;
name|I32
name|lvalue
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|||
name|LVRET
decl_stmt|;
name|SvTAINTED_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
if|if
condition|(
name|lvalue
condition|)
block|{
comment|/* it's an lvalue! */
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'v'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'v'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|src
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|LvTARGOFF
argument_list|(
name|TARG
argument_list|)
operator|=
name|offset
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|TARG
argument_list|)
operator|=
name|size
expr_stmt|;
block|}
name|sv_setuv
argument_list|(
name|TARG
argument_list|,
name|do_vecget
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_index
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|big
decl_stmt|;
name|SV
modifier|*
name|little
decl_stmt|;
name|I32
name|offset
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|tmps2
decl_stmt|;
name|STRLEN
name|biglen
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|3
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
name|POPi
operator|-
name|arybase
expr_stmt|;
name|little
operator|=
name|POPs
expr_stmt|;
name|big
operator|=
name|POPs
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|big
argument_list|,
name|biglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|DO_UTF8
argument_list|(
name|big
argument_list|)
condition|)
name|sv_pos_u2b
argument_list|(
name|big
argument_list|,
operator|&
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
name|biglen
condition|)
name|offset
operator|=
name|biglen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|offset
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|biglen
argument_list|,
name|little
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|tmps2
operator|-
name|tmps
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
operator|&&
name|DO_UTF8
argument_list|(
name|big
argument_list|)
condition|)
name|sv_pos_b2u
argument_list|(
name|big
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|retval
operator|+
name|arybase
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rindex
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|big
decl_stmt|;
name|SV
modifier|*
name|little
decl_stmt|;
name|STRLEN
name|blen
decl_stmt|;
name|STRLEN
name|llen
decl_stmt|;
name|I32
name|offset
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|tmps2
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|>=
literal|3
condition|)
name|offset
operator|=
name|POPi
expr_stmt|;
name|little
operator|=
name|POPs
expr_stmt|;
name|big
operator|=
name|POPs
expr_stmt|;
name|tmps2
operator|=
name|SvPV
argument_list|(
name|little
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|big
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|3
condition|)
name|offset
operator|=
name|blen
expr_stmt|;
else|else
block|{
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|DO_UTF8
argument_list|(
name|big
argument_list|)
condition|)
name|sv_pos_u2b
argument_list|(
name|big
argument_list|,
operator|&
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offset
operator|-
name|arybase
operator|+
name|llen
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
name|blen
condition|)
name|offset
operator|=
name|blen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|rninstr
argument_list|(
name|tmps
argument_list|,
name|tmps
operator|+
name|offset
argument_list|,
name|tmps2
argument_list|,
name|tmps2
operator|+
name|llen
argument_list|)
operator|)
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|tmps2
operator|-
name|tmps
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
operator|&&
name|DO_UTF8
argument_list|(
name|big
argument_list|)
condition|)
name|sv_pos_b2u
argument_list|(
name|big
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|retval
operator|+
name|arybase
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sprintf
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
name|do_sprintf
argument_list|(
name|TARG
argument_list|,
name|SP
operator|-
name|MARK
argument_list|,
name|MARK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|SvTAINTED
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ord
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|argsv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|U8
modifier|*
name|s
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPVx
argument_list|(
name|argsv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|XPUSHu
argument_list|(
name|DO_UTF8
argument_list|(
name|argsv
argument_list|)
condition|?
name|utf8_to_uv_simple
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
else|:
operator|(
operator|*
name|s
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chr
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|UV
name|value
init|=
name|POPu
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|255
operator|&&
operator|!
name|IN_BYTE
condition|)
block|{
name|SvGROW
argument_list|(
name|TARG
argument_list|,
name|UTF8_MAXLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|tmps
operator|=
operator|(
name|char
operator|*
operator|)
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|tmps
argument_list|,
operator|(
name|UV
operator|)
name|value
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
name|tmps
operator|-
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmps
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|SvGROW
argument_list|(
name|TARG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
operator|*
name|tmps
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|tmps
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_crypt
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|dPOPTOPssrl
expr_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_CRYPT
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|left
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FCRYPT
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|fcrypt
argument_list|(
name|tmps
argument_list|,
name|SvPV
argument_list|(
name|right
argument_list|,
name|n_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|PerlProc_crypt
argument_list|(
name|tmps
argument_list|,
name|SvPV
argument_list|(
name|right
argument_list|,
name|n_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"The crypt() function is unimplemented due to excessive paranoia."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ucfirst
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|slen
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
operator|)
operator|&&
name|slen
operator|&&
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|STRLEN
name|ulen
decl_stmt|;
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|U8
modifier|*
name|tend
decl_stmt|;
name|UV
name|uv
init|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|uv
operator|=
name|toTITLE_LC_uni
argument_list|(
name|uv
argument_list|)
expr_stmt|;
block|}
else|else
name|uv
operator|=
name|toTITLE_utf8
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tend
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|uv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|tend
operator|-
name|tmpbuf
operator|!=
name|ulen
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|tend
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|+
name|ulen
operator|)
argument_list|,
name|slen
operator|-
name|ulen
argument_list|)
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|,
name|ulen
argument_list|,
name|U8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|toUPPER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|=
name|toUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lcfirst
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|slen
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
operator|)
operator|&&
name|slen
operator|&&
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|STRLEN
name|ulen
decl_stmt|;
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|U8
modifier|*
name|tend
decl_stmt|;
name|UV
name|uv
init|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|uv
operator|=
name|toLOWER_LC_uni
argument_list|(
name|uv
argument_list|)
expr_stmt|;
block|}
else|else
name|uv
operator|=
name|toLOWER_utf8
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tend
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|uv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|tend
operator|-
name|tmpbuf
operator|!=
name|ulen
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|tend
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|TARG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|+
name|ulen
operator|)
argument_list|,
name|slen
operator|-
name|ulen
argument_list|)
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|,
name|ulen
argument_list|,
name|U8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|toLOWER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|=
name|toLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_uc
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|STRLEN
name|ulen
decl_stmt|;
specifier|register
name|U8
modifier|*
name|d
decl_stmt|;
name|U8
modifier|*
name|send
decl_stmt|;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|len
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|d
operator|=
name|uv_to_utf8
argument_list|(
name|d
argument_list|,
name|toUPPER_LC_uni
argument_list|(
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|ulen
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|d
operator|=
name|uv_to_utf8
argument_list|(
name|d
argument_list|,
name|toUPPER_utf8
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
name|d
operator|-
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
specifier|register
name|U8
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toUPPER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lc
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|STRLEN
name|ulen
decl_stmt|;
specifier|register
name|U8
modifier|*
name|d
decl_stmt|;
name|U8
modifier|*
name|send
decl_stmt|;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|len
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|d
operator|=
name|uv_to_utf8
argument_list|(
name|d
argument_list|,
name|toLOWER_LC_uni
argument_list|(
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|ulen
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|d
operator|=
name|uv_to_utf8
argument_list|(
name|d
argument_list|,
name|toLOWER_utf8
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
name|d
operator|-
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
operator|||
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
specifier|register
name|U8
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toLOWER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_quotemeta
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
if|if
condition|(
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|len
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|STRLEN
name|ulen
init|=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ulen
operator|>
name|len
condition|)
name|ulen
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|ulen
expr_stmt|;
while|while
condition|(
name|ulen
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
name|SvUTF8_on
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|TARG
argument_list|)
condition|)
name|mg_set
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Arrays. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_aslice
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
specifier|register
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|I32
name|lval
init|=
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|||
name|LVRET
operator|)
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|I32
name|elem
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|av
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|lval
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
block|{
name|I32
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|svp
operator|=
name|MARK
operator|+
literal|1
init|;
name|svp
operator|<=
name|SP
condition|;
name|svp
operator|++
control|)
block|{
name|elem
operator|=
name|SvIVx
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|>
name|max
condition|)
name|max
operator|=
name|elem
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|>
name|AvMAX
argument_list|(
name|av
argument_list|)
condition|)
name|av_extend
argument_list|(
name|av
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|elem
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|>
literal|0
condition|)
name|elem
operator|-=
name|arybase
expr_stmt|;
name|svp
operator|=
name|av_fetch
argument_list|(
name|av
argument_list|,
name|elem
argument_list|,
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
block|{
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_aelem
argument_list|,
argument|elem
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_aelem
argument_list|(
name|av
argument_list|,
name|elem
argument_list|,
name|svp
argument_list|)
expr_stmt|;
block|}
operator|*
name|MARK
operator|=
name|svp
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Associative arrays. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_each
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|HV
modifier|*
name|hash
init|=
operator|(
name|HV
operator|*
operator|)
name|POPs
decl_stmt|;
name|HE
modifier|*
name|entry
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|realhv
init|=
operator|(
name|SvTYPE
argument_list|(
name|hash
argument_list|)
operator|==
name|SVt_PVHV
operator|)
decl_stmt|;
name|PUTBACK
expr_stmt|;
comment|/* might clobber stack_sp */
name|entry
operator|=
name|realhv
condition|?
name|hv_iternext
argument_list|(
name|hash
argument_list|)
else|:
name|avhv_iternext
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hash
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|PUSHs
argument_list|(
name|hv_iterkeysv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* won't clobber stack_sp */
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|SV
modifier|*
name|val
decl_stmt|;
name|PUTBACK
expr_stmt|;
comment|/* might clobber stack_sp */
name|val
operator|=
name|realhv
condition|?
name|hv_iterval
argument_list|(
name|hash
argument_list|,
name|entry
argument_list|)
else|:
name|avhv_iterval
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hash
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|PUSHs
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_values
argument_list|)
end_macro

begin_block
block|{
return|return
name|do_kv
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_keys
argument_list|)
end_macro

begin_block
block|{
return|return
name|do_kv
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_delete
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|discard
init|=
operator|(
name|gimme
operator|==
name|G_VOID
operator|)
condition|?
name|G_DISCARD
else|:
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpSLICE
condition|)
block|{
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|U32
name|hvtype
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
name|hvtype
operator|=
name|SvTYPE
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvtype
operator|==
name|SVt_PVHV
condition|)
block|{
comment|/* hash element */
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|sv
operator|=
name|hv_delete_ent
argument_list|(
name|hv
argument_list|,
operator|*
name|MARK
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|sv
condition|?
name|sv
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hvtype
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
comment|/* array element */
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|sv
operator|=
name|av_delete
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|SvIV
argument_list|(
operator|*
name|MARK
argument_list|)
argument_list|,
name|discard
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|sv
condition|?
name|sv
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* pseudo-hash element */
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|sv
operator|=
name|avhv_delete_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
operator|*
name|MARK
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|sv
condition|?
name|sv
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
block|}
else|else
name|DIE
argument_list|(
name|aTHX_
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard
condition|)
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|keysv
init|=
name|POPs
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
condition|)
name|sv
operator|=
name|hv_delete_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
name|sv
operator|=
name|av_delete
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|SvIV
argument_list|(
name|keysv
argument_list|)
argument_list|,
name|discard
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
name|avhv_delete_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|keysv
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|DIE
argument_list|(
name|aTHX_
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
operator|!
name|discard
condition|)
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_exists
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpEXISTS_SUB
condition|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|sv
argument_list|,
operator|&
name|hv
argument_list|,
operator|&
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
condition|)
name|RETPUSHYES
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|isGV
argument_list|(
name|gv
argument_list|)
operator|&&
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|!
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
name|RETPUSHNO
expr_stmt|;
block|}
name|tmpsv
operator|=
name|POPs
expr_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
condition|)
block|{
if|if
condition|(
name|hv_exists_ent
argument_list|(
name|hv
argument_list|,
name|tmpsv
argument_list|,
literal|0
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
comment|/* array element */
if|if
condition|(
name|av_exists
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|SvIV
argument_list|(
name|tmpsv
argument_list|)
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|avhv_exists_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|tmpsv
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* pseudo-hash element */
name|RETPUSHYES
expr_stmt|;
block|}
else|else
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
block|}
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_hslice
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|HV
modifier|*
name|hv
init|=
operator|(
name|HV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|I32
name|lval
init|=
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
operator|||
name|LVRET
operator|)
decl_stmt|;
name|I32
name|realhv
init|=
operator|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|realhv
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't localize pseudo-hash element"
argument_list|)
expr_stmt|;
if|if
condition|(
name|realhv
operator|||
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|SV
modifier|*
name|keysv
init|=
operator|*
name|MARK
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
if|if
condition|(
name|realhv
condition|)
block|{
name|HE
modifier|*
name|he
init|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|lval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|svp
operator|=
name|he
condition|?
operator|&
name|HeVAL
argument_list|(
name|he
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|svp
operator|=
name|avhv_fetch_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|keysv
argument_list|,
name|lval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lval
condition|)
block|{
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|DIE
argument_list|(
argument|aTHX_ PL_no_helem
argument_list|,
argument|SvPV(keysv, n_a)
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_helem
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|svp
argument_list|)
expr_stmt|;
block|}
operator|*
name|MARK
operator|=
name|svp
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* List operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_list
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
comment|/* unwanted list, return last item */
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lslice
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
modifier|*
name|lastrelem
init|=
name|PL_stack_sp
decl_stmt|;
name|SV
modifier|*
modifier|*
name|lastlelem
init|=
name|PL_stack_base
operator|+
name|POPMARK
decl_stmt|;
name|SV
modifier|*
modifier|*
name|firstlelem
init|=
name|PL_stack_base
operator|+
name|POPMARK
operator|+
literal|1
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|firstrelem
init|=
name|lastlelem
operator|+
literal|1
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|I32
name|lval
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|I32
name|is_something_there
init|=
name|lval
decl_stmt|;
specifier|register
name|I32
name|max
init|=
name|lastrelem
operator|-
name|lastlelem
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|lelem
decl_stmt|;
specifier|register
name|I32
name|ix
decl_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|ix
operator|=
name|SvIVx
argument_list|(
operator|*
name|lastlelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
name|ix
operator|+=
name|max
expr_stmt|;
else|else
name|ix
operator|-=
name|arybase
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
operator|||
name|ix
operator|>=
name|max
condition|)
operator|*
name|firstlelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
else|else
operator|*
name|firstlelem
operator|=
name|firstrelem
index|[
name|ix
index|]
expr_stmt|;
name|SP
operator|=
name|firstlelem
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
name|SP
operator|=
name|firstlelem
operator|-
literal|1
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
for|for
control|(
name|lelem
operator|=
name|firstlelem
init|;
name|lelem
operator|<=
name|lastlelem
condition|;
name|lelem
operator|++
control|)
block|{
name|ix
operator|=
name|SvIVx
argument_list|(
operator|*
name|lelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
name|ix
operator|+=
name|max
expr_stmt|;
else|else
name|ix
operator|-=
name|arybase
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
operator|||
name|ix
operator|>=
name|max
condition|)
operator|*
name|lelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
else|else
block|{
name|is_something_there
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|lelem
operator|=
name|firstrelem
index|[
name|ix
index|]
operator|)
condition|)
operator|*
name|lelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_something_there
condition|)
name|SP
operator|=
name|lastlelem
expr_stmt|;
else|else
name|SP
operator|=
name|firstlelem
operator|-
literal|1
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anonlist
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|I32
name|items
init|=
name|SP
operator|-
name|MARK
decl_stmt|;
name|SV
modifier|*
name|av
init|=
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av_make
argument_list|(
name|items
argument_list|,
name|MARK
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
comment|/* av_make() might realloc stack_sp */
name|XPUSHs
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anonhash
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|HV
modifier|*
name|hv
init|=
operator|(
name|HV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|SV
modifier|*
name|key
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
name|SV
modifier|*
name|val
init|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
name|sv_setsv
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Odd number of elements in hash assignment"
argument_list|)
empty_stmt|;
operator|(
name|void
operator|)
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_splice
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|src
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|dst
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|offset
decl_stmt|;
specifier|register
name|I32
name|length
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
name|I32
name|after
decl_stmt|;
name|I32
name|diff
decl_stmt|;
name|SV
modifier|*
modifier|*
name|tmparyval
init|=
literal|0
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"SPLICE"
argument_list|,
name|GIMME_V
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|SP
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|MARK
operator|<
name|SP
condition|)
block|{
name|offset
operator|=
name|i
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|offset
operator|-=
name|PL_curcop
operator|->
name|cop_arybase
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|DIE
argument_list|(
argument|aTHX_ PL_no_aelem
argument_list|,
argument|i
argument_list|)
empty_stmt|;
if|if
condition|(
operator|++
name|MARK
operator|<
name|SP
condition|)
block|{
name|length
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|+=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|-
name|offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|length
operator|=
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* close enough to infinity */
block|}
else|else
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
condition|)
name|offset
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
name|after
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
operator|-
operator|(
name|offset
operator|+
name|length
operator|)
expr_stmt|;
if|if
condition|(
name|after
operator|<
literal|0
condition|)
block|{
comment|/* not that much array */
name|length
operator|+=
name|after
expr_stmt|;
comment|/* offset+length now in array */
name|after
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|AvALLOC
argument_list|(
name|ary
argument_list|)
condition|)
name|av_extend
argument_list|(
name|ary
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, MARK .. SP-1 is our new LIST */
name|newlen
operator|=
name|SP
operator|-
name|MARK
expr_stmt|;
name|diff
operator|=
name|newlen
operator|-
name|length
expr_stmt|;
if|if
condition|(
name|newlen
operator|&&
operator|!
name|AvREAL
argument_list|(
name|ary
argument_list|)
operator|&&
name|AvREIFY
argument_list|(
name|ary
argument_list|)
condition|)
name|av_reify
argument_list|(
name|ary
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
comment|/* shrinking the area */
if|if
condition|(
name|newlen
condition|)
block|{
name|New
argument_list|(
literal|451
argument_list|,
name|tmparyval
argument_list|,
name|newlen
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
comment|/* so remember insertion */
name|Copy
argument_list|(
name|MARK
argument_list|,
name|tmparyval
argument_list|,
name|newlen
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|=
name|ORIGMARK
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* copy return vals to stack */
name|MEXTEND
argument_list|(
name|MARK
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
argument_list|,
name|MARK
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|EXTEND_MORTAL
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|,
name|dst
operator|=
name|MARK
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
comment|/* free them eventualy */
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|MARK
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|MARK
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
operator|+
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|-
literal|1
operator|,
name|dst
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|SvREFCNT_dec
argument_list|(
operator|*
name|dst
operator|++
argument_list|)
expr_stmt|;
comment|/* free them now */
block|}
block|}
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
comment|/* pull up or down? */
if|if
condition|(
name|offset
operator|<
name|after
condition|)
block|{
comment|/* easier to pull up */
if|if
condition|(
name|offset
condition|)
block|{
comment|/* esp. if nothing to pull */
name|src
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
operator|-
literal|1
index|]
expr_stmt|;
name|dst
operator|=
name|src
operator|-
name|diff
expr_stmt|;
comment|/* diff is negative */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
comment|/* can't trust Copy */
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|ary
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|diff
operator|)
expr_stmt|;
comment|/* diff is negative */
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|after
condition|)
block|{
comment|/* anything to pull down? */
name|src
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
operator|+
name|length
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|diff
expr_stmt|;
comment|/* diff is negative */
name|Move
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|after
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
comment|/* avoid later double free */
block|}
name|i
operator|=
operator|-
name|diff
expr_stmt|;
while|while
condition|(
name|i
condition|)
name|dst
index|[
operator|--
name|i
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|newlen
condition|)
block|{
for|for
control|(
name|src
operator|=
name|tmparyval
operator|,
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
init|;
name|newlen
condition|;
name|newlen
operator|--
control|)
block|{
operator|*
name|dst
operator|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
operator|*
name|dst
operator|++
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no, expanding (or same) */
if|if
condition|(
name|length
condition|)
block|{
name|New
argument_list|(
literal|452
argument_list|,
name|tmparyval
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
comment|/* so remember deletion */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
argument_list|,
name|tmparyval
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
comment|/* expanding */
comment|/* push up or down? */
if|if
condition|(
name|offset
operator|<
name|after
operator|&&
name|diff
operator|<=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|ary
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
condition|)
block|{
name|src
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|dst
operator|=
name|src
operator|-
name|diff
expr_stmt|;
name|Move
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|offset
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|SvPVX
argument_list|(
name|ary
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|diff
operator|)
expr_stmt|;
comment|/* diff is positive */
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|diff
operator|>=
name|AvMAX
argument_list|(
name|ary
argument_list|)
condition|)
comment|/* oh, well */
name|av_extend
argument_list|(
name|ary
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|diff
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|AvFILLp
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|-
name|diff
expr_stmt|;
for|for
control|(
name|i
operator|=
name|after
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|src
operator|=
name|MARK
operator|,
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
init|;
name|newlen
condition|;
name|newlen
operator|--
control|)
block|{
operator|*
name|dst
operator|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
operator|*
name|dst
operator|++
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|=
name|ORIGMARK
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* copy return vals to stack */
if|if
condition|(
name|length
condition|)
block|{
name|Copy
argument_list|(
name|tmparyval
argument_list|,
name|MARK
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|EXTEND_MORTAL
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|,
name|dst
operator|=
name|MARK
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
comment|/* free them eventualy */
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|MARK
operator|=
name|tmparyval
index|[
name|length
index|]
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
name|SvREFCNT_dec
argument_list|(
name|tmparyval
index|[
name|length
index|]
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_push
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
init|=
operator|&
name|PL_sv_undef
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"PUSH"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
else|else
block|{
comment|/* Why no pre-extend of ary here ? */
for|for
control|(
operator|++
name|MARK
init|;
name|MARK
operator|<=
name|SP
condition|;
name|MARK
operator|++
control|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|51
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|MARK
condition|)
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|ary
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|AvFILL
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_pop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|av_pop
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shift
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|av_shift
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_unshift
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|0
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"UNSHIFT"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
else|else
block|{
name|av_unshift
argument_list|(
name|ary
argument_list|,
name|SP
operator|-
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|27
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|av_store
argument_list|(
name|ary
argument_list|,
name|i
operator|++
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|AvFILL
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_reverse
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
name|tmp
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldsp
init|=
name|SP
decl_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|MARK
operator|++
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|tmp
operator|=
operator|*
name|MARK
expr_stmt|;
operator|*
name|MARK
operator|++
operator|=
operator|*
name|SP
expr_stmt|;
operator|*
name|SP
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* safe as long as stack cannot get extended in the above */
name|SP
operator|=
name|oldsp
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|up
decl_stmt|;
specifier|register
name|char
modifier|*
name|down
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
name|dTARGET
expr_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|SvUTF8_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
if|if
condition|(
name|SP
operator|-
name|MARK
operator|>
literal|1
condition|)
name|do_join
argument_list|(
name|TARG
argument_list|,
operator|&
name|PL_sv_no
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
else|else
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
operator|(
name|SP
operator|>
name|MARK
operator|)
condition|?
operator|*
name|SP
else|:
name|DEFSV
argument_list|)
expr_stmt|;
name|up
operator|=
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|DO_UTF8
argument_list|(
name|TARG
argument_list|)
condition|)
block|{
comment|/* first reverse each character */
name|U8
modifier|*
name|s
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|TARG
argument_list|)
decl_stmt|;
name|U8
modifier|*
name|send
init|=
operator|(
name|U8
operator|*
operator|)
operator|(
name|s
operator|+
name|len
operator|)
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|UTF8_IS_ASCII
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|utf8_to_uv_simple
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|up
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|down
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* reverse this character */
while|while
condition|(
name|down
operator|>
name|up
condition|)
block|{
name|tmp
operator|=
operator|*
name|up
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|*
name|down
expr_stmt|;
operator|*
name|down
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
name|up
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|down
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|down
operator|>
name|up
condition|)
block|{
name|tmp
operator|=
operator|*
name|up
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|*
name|down
expr_stmt|;
operator|*
name|down
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvPOK_only_UTF8
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
operator|+
literal|1
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|SV
modifier|*
name|S_mul128
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|U8
name|m
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|U32
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0000"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* need to grow sv */
name|SV
modifier|*
name|tmpNew
init|=
name|newSVpvn
argument_list|(
literal|"0000000000"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|sv_catsv
argument_list|(
name|tmpNew
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* free old sv */
name|sv
operator|=
name|tmpNew
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|s
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|*
name|t
condition|)
comment|/* trailing '\0'? */
name|t
operator|--
expr_stmt|;
while|while
condition|(
name|t
operator|>
name|s
condition|)
block|{
name|i
operator|=
operator|(
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
operator|<<
literal|7
operator|)
operator|+
name|m
expr_stmt|;
operator|*
operator|(
name|t
operator|--
operator|)
operator|=
literal|'0'
operator|+
operator|(
name|i
operator|%
literal|10
operator|)
expr_stmt|;
name|m
operator|=
name|i
operator|/
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|sv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Explosives and implosives. */
end_comment

begin_if
if|#
directive|if
literal|'I'
operator|==
literal|73
operator|&&
literal|'J'
operator|==
literal|74
end_if

begin_comment
comment|/* On an ASCII/ISO kind of system */
end_comment

begin_define
define|#
directive|define
name|ISUUCHAR
parameter_list|(
name|ch
parameter_list|)
value|((ch)>= ' '&& (ch)< 'a')
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*   Some other sort of character set - use memchr() so we don't match   the null byte.  */
end_comment

begin_define
define|#
directive|define
name|ISUUCHAR
parameter_list|(
name|ch
parameter_list|)
value|(memchr(PL_uuemap, (ch), sizeof(PL_uuemap)-1) || (ch) == ' ')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_unpack
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dPOPPOPssrl
expr_stmt|;
name|I32
name|start_sp_offset
init|=
name|SP
operator|-
name|PL_stack_base
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|STRLEN
name|llen
decl_stmt|;
name|STRLEN
name|rlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
init|=
name|SvPV
argument_list|(
name|left
argument_list|,
name|llen
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strend
init|=
name|s
operator|+
name|rlen
decl_stmt|;
name|char
modifier|*
name|strbeg
init|=
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|patend
init|=
name|pat
operator|+
name|llen
decl_stmt|;
name|I32
name|datumtype
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
specifier|register
name|I32
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* These must not be in registers: */
name|short
name|ashort
decl_stmt|;
name|int
name|aint
decl_stmt|;
name|long
name|along
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|Quad_t
name|aquad
decl_stmt|;
endif|#
directive|endif
name|U16
name|aushort
decl_stmt|;
name|unsigned
name|int
name|auint
decl_stmt|;
name|U32
name|aulong
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|Uquad_t
name|auquad
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|aptr
decl_stmt|;
name|float
name|afloat
decl_stmt|;
name|double
name|adouble
decl_stmt|;
name|I32
name|checksum
init|=
literal|0
decl_stmt|;
specifier|register
name|U32
name|culong
decl_stmt|;
name|NV
name|cdouble
decl_stmt|;
name|int
name|commas
init|=
literal|0
decl_stmt|;
name|int
name|star
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|int
name|natint
decl_stmt|;
comment|/* native integer */
name|int
name|unatint
decl_stmt|;
comment|/* unsigned native integer */
endif|#
directive|endif
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
comment|/* arrange to do first one only */
comment|/*SUPPRESS 530*/
for|for
control|(
name|patend
operator|=
name|pat
init|;
operator|!
name|isALPHA
argument_list|(
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|patend
operator|==
literal|'x'
condition|;
name|patend
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"aAZbBhHP"
argument_list|,
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|pat
operator|==
literal|'%'
condition|)
block|{
name|patend
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|patend
operator|==
literal|'*'
condition|)
name|patend
operator|++
expr_stmt|;
block|}
else|else
name|patend
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|pat
operator|<
name|patend
condition|)
block|{
name|reparse
label|:
name|datumtype
operator|=
operator|*
name|pat
operator|++
operator|&
literal|0xFF
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|natint
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isSPACE
argument_list|(
name|datumtype
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|datumtype
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|pat
operator|<
name|patend
operator|&&
operator|*
name|pat
operator|!=
literal|'\n'
condition|)
name|pat
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|pat
operator|==
literal|'!'
condition|)
block|{
name|char
modifier|*
name|natstr
init|=
literal|"sSiIlL"
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|natstr
argument_list|,
name|datumtype
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|natint
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pat
operator|++
expr_stmt|;
block|}
else|else
name|DIE
argument_list|(
name|aTHX_
literal|"'!' allowed only after types %s"
argument_list|,
name|natstr
argument_list|)
expr_stmt|;
block|}
name|star
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pat
operator|>=
name|patend
condition|)
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|strend
operator|-
name|strbeg
expr_stmt|;
comment|/* long enough */
name|pat
operator|++
expr_stmt|;
name|star
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|*
name|pat
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|(
name|len
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|pat
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Repeat count in unpack overflows"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|len
operator|=
operator|(
name|datumtype
operator|!=
literal|'@'
operator|)
expr_stmt|;
name|redo_switch
label|:
switch|switch
condition|(
name|datumtype
condition|)
block|{
default|default:
name|DIE
argument_list|(
name|aTHX_
literal|"Invalid type in unpack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
case|case
literal|','
case|:
comment|/* grandfather in commas but with a warning */
if|if
condition|(
name|commas
operator|++
operator|==
literal|0
operator|&&
name|ckWARN
argument_list|(
name|WARN_UNPACK
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_UNPACK
argument_list|,
literal|"Invalid type in unpack: '%c'"
argument_list|,
argument|(int)datumtype
argument_list|)
empty_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|pat
index|[
operator|-
literal|1
index|]
operator|!=
literal|'1'
condition|)
name|len
operator|=
literal|16
expr_stmt|;
name|checksum
operator|=
name|len
expr_stmt|;
name|culong
operator|=
literal|0
expr_stmt|;
name|cdouble
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pat
operator|<
name|patend
condition|)
goto|goto
name|reparse
goto|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|strbeg
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"@ outside of string"
argument_list|)
expr_stmt|;
name|s
operator|=
name|strbeg
operator|+
name|len
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|len
operator|>
name|s
operator|-
name|strbeg
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"X outside of string"
argument_list|)
expr_stmt|;
name|s
operator|-=
name|len
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"x outside of string"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|start_sp_offset
operator|>=
name|SP
operator|-
name|PL_stack_base
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"/ must follow a numeric type"
argument_list|)
expr_stmt|;
name|datumtype
operator|=
operator|*
name|pat
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
name|pat
operator|++
expr_stmt|;
comment|/* ignore '*' for compatibility with pack */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"/ cannot take a count"
argument_list|)
expr_stmt|;
name|len
operator|=
name|POPi
expr_stmt|;
name|star
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_switch
goto|;
case|case
literal|'A'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
goto|goto
name|uchar_checksum
goto|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'A'
operator|||
name|datumtype
operator|==
literal|'Z'
condition|)
block|{
name|aptr
operator|=
name|s
expr_stmt|;
comment|/* borrow register */
if|if
condition|(
name|datumtype
operator|==
literal|'Z'
condition|)
block|{
comment|/* 'Z' strips stuff after first null */
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 'A' strips both nulls and spaces */
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
operator|!
operator|*
name|s
operator|||
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
name|s
operator|--
expr_stmt|;
operator|*
operator|++
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|s
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|aptr
expr_stmt|;
comment|/* unborrow register */
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
if|if
condition|(
name|star
operator|||
name|len
operator|>
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|8
condition|)
name|len
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|if
condition|(
operator|!
name|PL_bitcount
condition|)
block|{
name|Newz
argument_list|(
literal|601
argument_list|,
name|PL_bitcount
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
for|for
control|(
name|bits
operator|=
literal|1
init|;
name|bits
operator|<
literal|256
condition|;
name|bits
operator|++
control|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|4
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|8
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|16
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|32
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|64
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|128
condition|)
name|PL_bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|culong
operator|+=
name|PL_bitcount
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|++
index|]
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|bits
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'b'
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|culong
operator|++
expr_stmt|;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|128
condition|)
name|culong
operator|++
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|str
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'b'
condition|)
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|7
condition|)
comment|/*SUPPRESS 595*/
name|bits
operator|>>=
literal|1
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|str
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|bits
operator|&
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|bits
operator|<<=
literal|1
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|str
operator|++
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|bits
operator|&
literal|128
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|star
operator|||
name|len
operator|>
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|2
condition|)
name|len
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|2
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|str
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'h'
condition|)
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|bits
operator|>>=
literal|4
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|str
operator|++
operator|=
name|PL_hexdigit
index|[
name|bits
operator|&
literal|15
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|bits
operator|<<=
literal|4
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|str
operator|++
operator|=
name|PL_hexdigit
index|[
operator|(
name|bits
operator|>>
literal|4
operator|)
operator|&
literal|15
index|]
expr_stmt|;
block|}
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|aint
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|aint
operator|>=
literal|128
condition|)
comment|/* fake up signed chars */
name|aint
operator|-=
literal|256
expr_stmt|;
name|culong
operator|+=
name|aint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|aint
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|aint
operator|>=
literal|128
condition|)
comment|/* fake up signed chars */
name|aint
operator|-=
literal|256
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|36
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
name|uchar_checksum
label|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|auint
operator|=
operator|*
name|s
operator|++
operator|&
literal|255
expr_stmt|;
name|culong
operator|+=
name|auint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|auint
operator|=
operator|*
name|s
operator|++
operator|&
literal|255
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|37
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|auint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
operator|&&
name|s
operator|<
name|strend
condition|)
block|{
name|STRLEN
name|alen
decl_stmt|;
name|auint
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
name|strend
operator|-
name|s
argument_list|,
operator|&
name|alen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|along
operator|=
name|alen
expr_stmt|;
name|s
operator|+=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|auint
expr_stmt|;
else|else
name|culong
operator|+=
name|auint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
operator|&&
name|s
operator|<
name|strend
condition|)
block|{
name|STRLEN
name|alen
decl_stmt|;
name|auint
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
name|strend
operator|-
name|s
argument_list|,
operator|&
name|alen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|along
operator|=
name|alen
expr_stmt|;
name|s
operator|+=
name|along
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|37
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
if|#
directive|if
name|SHORTSIZE
operator|==
name|SIZE16
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE16
expr_stmt|;
else|#
directive|else
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
operator|(
name|natint
condition|?
sizeof|sizeof
argument_list|(
name|short
argument_list|)
else|:
name|SIZE16
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|natint
condition|)
block|{
name|short
name|ashort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|culong
operator|+=
name|ashort
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|>
name|SIZE16
if|if
condition|(
name|ashort
operator|>
literal|32767
condition|)
name|ashort
operator|-=
literal|65536
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|culong
operator|+=
name|ashort
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|natint
condition|)
block|{
name|short
name|ashort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|38
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|ashort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|>
name|SIZE16
if|if
condition|(
name|ashort
operator|>
literal|32767
condition|)
name|ashort
operator|-=
literal|65536
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|38
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|ashort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'v'
case|:
case|case
literal|'n'
case|:
case|case
literal|'S'
case|:
if|#
directive|if
name|SHORTSIZE
operator|==
name|SIZE16
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE16
expr_stmt|;
else|#
directive|else
name|unatint
operator|=
name|natint
operator|&&
name|datumtype
operator|==
literal|'S'
expr_stmt|;
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
operator|(
name|unatint
condition|?
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
else|:
name|SIZE16
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|unatint
condition|)
block|{
name|unsigned
name|short
name|aushort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr_stmt|;
name|culong
operator|+=
name|aushort
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE16
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'n'
condition|)
name|aushort
operator|=
name|PerlSock_ntohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'v'
condition|)
name|aushort
operator|=
name|vtohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|culong
operator|+=
name|aushort
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|unatint
condition|)
block|{
name|unsigned
name|short
name|aushort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|39
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|aushort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|39
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'n'
condition|)
name|aushort
operator|=
name|PerlSock_ntohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'v'
condition|)
name|aushort
operator|=
name|vtohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|aushort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'i'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aint
argument_list|,
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|aint
expr_stmt|;
else|else
name|culong
operator|+=
name|aint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aint
argument_list|,
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__osf__
comment|/* Without the dummy below unpack("i", pack("i",-1))                      * return 0xFFffFFff instead of -1 for Digital Unix V4.0                      * cc with optimization turned on. 		     * 		     * The bug was detected in 		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (V4.0E) 		     * with optimization (-O4) turned on. 		     * DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (V4.0B) 		     * does not have this problem even with -O4. 		     * 		     * This bug was reported as DECC_BUGS 1431 		     * and tracked internally as GEM_BUGS 7775. 		     * 		     * The bug is fixed in 		     * Tru64 UNIX V5.0:      Compaq C V6.1-006 or later 		     * UNIX V4.0F support:   DEC C V5.9-006 or later 		     * UNIX V4.0E support:   DEC C V5.8-011 or later 		     * and also in DTK. 		     * 		     * See also few lines later for the same bug. 		     */
operator|(
name|aint
operator|)
condition|?
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
else|:
endif|#
directive|endif
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'I'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
argument|s
argument_list|,
argument|&auint
argument_list|,
literal|1
argument_list|,
argument|unsigned int
argument_list|)
empty_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|auint
expr_stmt|;
else|else
name|culong
operator|+=
name|auint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
argument|s
argument_list|,
argument|&auint
argument_list|,
literal|1
argument_list|,
argument|unsigned int
argument_list|)
empty_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__osf__
comment|/* Without the dummy below unpack("I", pack("I",0xFFFFFFFF))                      * returns 1.84467440737096e+19 instead of 0xFFFFFFFF. 		     * See details few lines earlier. */
operator|(
name|auint
operator|)
condition|?
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auint
argument_list|)
else|:
endif|#
directive|endif
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
if|#
directive|if
name|LONGSIZE
operator|==
name|SIZE32
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE32
expr_stmt|;
else|#
directive|else
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
operator|(
name|natint
condition|?
sizeof|sizeof
argument_list|(
name|long
argument_list|)
else|:
name|SIZE32
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|natint
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|along
expr_stmt|;
else|else
name|culong
operator|+=
name|along
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
operator|&&
name|INTSIZE
operator|==
name|SIZE32
name|I32
name|along
decl_stmt|;
endif|#
directive|endif
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
if|if
condition|(
name|along
operator|>
literal|2147483647
condition|)
name|along
operator|-=
literal|4294967296
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE32
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|along
expr_stmt|;
else|else
name|culong
operator|+=
name|along
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|natint
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|along
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
operator|&&
name|INTSIZE
operator|==
name|SIZE32
name|I32
name|along
decl_stmt|;
endif|#
directive|endif
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
if|if
condition|(
name|along
operator|>
literal|2147483647
condition|)
name|along
operator|-=
literal|4294967296
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE32
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|along
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'N'
case|:
case|case
literal|'L'
case|:
if|#
directive|if
name|LONGSIZE
operator|==
name|SIZE32
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE32
expr_stmt|;
else|#
directive|else
name|unatint
operator|=
name|natint
operator|&&
name|datumtype
operator|==
literal|'L'
expr_stmt|;
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
operator|(
name|unatint
condition|?
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
else|:
name|SIZE32
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|unatint
condition|)
block|{
name|unsigned
name|long
name|aulong
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|aulong
expr_stmt|;
else|else
name|culong
operator|+=
name|aulong
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE32
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'N'
condition|)
name|aulong
operator|=
name|PerlSock_ntohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'V'
condition|)
name|aulong
operator|=
name|vtohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|NV
operator|)
name|aulong
expr_stmt|;
else|else
name|culong
operator|+=
name|aulong
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|unatint
condition|)
block|{
name|unsigned
name|long
name|aulong
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPYNN
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|aulong
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE32
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'N'
condition|)
name|aulong
operator|=
name|PerlSock_ntohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'V'
condition|)
name|aulong
operator|=
name|vtohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv
operator|=
name|NEWSV
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|aulong
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'p'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
name|strend
operator|-
name|s
condition|)
break|break;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aptr
argument_list|,
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|44
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|aptr
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|{
name|UV
name|auv
init|=
literal|0
decl_stmt|;
name|U32
name|bytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|<
name|strend
operator|)
condition|)
block|{
name|auv
operator|=
operator|(
name|auv
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
name|s
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|UTF8_IS_ASCII
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|auv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|auv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|bytes
operator|>=
sizeof|sizeof
argument_list|(
name|UV
argument_list|)
condition|)
block|{
comment|/* promote to string */
name|char
modifier|*
name|t
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|sv
operator|=
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%.*"
name|UVf
argument_list|,
operator|(
name|int
operator|)
name|TYPE_DIGITS
argument_list|(
name|UV
argument_list|)
argument_list|,
name|auv
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|sv
operator|=
name|mul128
argument_list|(
name|sv
argument_list|,
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|++
operator|&
literal|0x80
operator|)
condition|)
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|t
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|'0'
condition|)
name|t
operator|++
expr_stmt|;
name|sv_chop
argument_list|(
name|sv
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|auv
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|>=
name|strend
operator|)
operator|&&
name|bytes
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Unterminated compressed integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
name|strend
operator|-
name|s
condition|)
break|break;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aptr
argument_list|,
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|44
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|aptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|+
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
operator|>
name|strend
condition|)
name|aquad
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aquad
argument_list|,
literal|1
argument_list|,
name|Quad_t
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aquad
operator|>=
name|IV_MIN
operator|&&
name|aquad
operator|<=
name|IV_MAX
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aquad
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|aquad
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|+
sizeof|sizeof
argument_list|(
name|Uquad_t
argument_list|)
operator|>
name|strend
condition|)
name|auquad
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|auquad
argument_list|,
literal|1
argument_list|,
name|Uquad_t
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|Uquad_t
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|auquad
operator|<=
name|UV_MAX
condition|)
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auquad
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|auquad
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* float and double added gnb@melba.bby.oz.au 22/11/89 */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|afloat
argument_list|,
literal|1
argument_list|,
name|float
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
name|cdouble
operator|+=
name|afloat
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|afloat
argument_list|,
literal|1
argument_list|,
name|float
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|47
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|afloat
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|adouble
argument_list|,
literal|1
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|cdouble
operator|+=
name|adouble
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|adouble
argument_list|,
literal|1
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|48
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|NV
operator|)
name|adouble
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'u'
case|:
comment|/* MKS: 	     * Initialise the decode mapping.  By using a table driven              * algorithm, the code will be character-set independent              * (and just as fast as doing character arithmetic)              */
if|if
condition|(
name|PL_uudmap
index|[
literal|'M'
index|]
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|PL_uuemap
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
name|PL_uudmap
index|[
operator|(
name|U8
operator|)
name|PL_uuemap
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/*                  * Because ' ' and '`' map to the same value,                  * we need to decode them both the same.                  */
name|PL_uudmap
index|[
literal|' '
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
name|along
argument_list|)
expr_stmt|;
if|if
condition|(
name|along
condition|)
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|>
literal|' '
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|I32
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|char
name|hunk
index|[
literal|4
index|]
decl_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|PL_uudmap
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|a
operator|=
name|PL_uudmap
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|b
operator|=
name|PL_uudmap
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|c
operator|=
name|PL_uudmap
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|d
operator|=
name|PL_uudmap
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|d
operator|=
literal|0
expr_stmt|;
name|hunk
index|[
literal|0
index|]
operator|=
operator|(
name|a
operator|<<
literal|2
operator|)
operator||
operator|(
name|b
operator|>>
literal|4
operator|)
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
operator|(
name|c
operator|<<
literal|6
operator|)
operator||
name|d
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
operator|(
name|len
operator|>
literal|3
operator|)
condition|?
literal|3
else|:
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* possible checksum byte */
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checksum
condition|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"fFdD"
argument_list|,
name|datumtype
argument_list|)
operator|||
operator|(
name|checksum
operator|>
literal|32
operator|&&
name|strchr
argument_list|(
literal|"iIlLNU"
argument_list|,
name|datumtype
argument_list|)
operator|)
condition|)
block|{
name|NV
name|trouble
decl_stmt|;
name|adouble
operator|=
literal|1.0
expr_stmt|;
while|while
condition|(
name|checksum
operator|>=
literal|16
condition|)
block|{
name|checksum
operator|-=
literal|16
expr_stmt|;
name|adouble
operator|*=
literal|65536.0
expr_stmt|;
block|}
while|while
condition|(
name|checksum
operator|>=
literal|4
condition|)
block|{
name|checksum
operator|-=
literal|4
expr_stmt|;
name|adouble
operator|*=
literal|16.0
expr_stmt|;
block|}
while|while
condition|(
name|checksum
operator|--
condition|)
name|adouble
operator|*=
literal|2.0
expr_stmt|;
name|along
operator|=
operator|(
literal|1
operator|<<
name|checksum
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cdouble
operator|<
literal|0.0
condition|)
name|cdouble
operator|+=
name|adouble
expr_stmt|;
name|cdouble
operator|=
name|Perl_modf
argument_list|(
name|cdouble
operator|/
name|adouble
argument_list|,
operator|&
name|trouble
argument_list|)
operator|*
name|adouble
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|cdouble
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|checksum
operator|<
literal|32
condition|)
block|{
name|aulong
operator|=
operator|(
literal|1
operator|<<
name|checksum
operator|)
operator|-
literal|1
expr_stmt|;
name|culong
operator|&=
name|aulong
expr_stmt|;
block|}
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|culong
argument_list|)
expr_stmt|;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SP
operator|-
name|PL_stack_base
operator|==
name|start_sp_offset
operator|&&
name|gimme
operator|==
name|G_SCALAR
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|void
name|S_doencodes
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
name|hunk
index|[
literal|5
index|]
decl_stmt|;
operator|*
name|hunk
operator|=
name|PL_uuemap
index|[
name|len
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hunk
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|2
condition|)
block|{
name|hunk
index|[
literal|0
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|*
name|s
operator|>>
literal|2
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
operator|*
name|s
operator|<<
literal|4
operator|)
operator|&
literal|060
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|017
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
operator|&
literal|074
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|077
operator|)
operator|)
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|r
init|=
operator|(
name|len
operator|>
literal|1
condition|?
name|s
index|[
literal|1
index|]
else|:
literal|'\0'
operator|)
decl_stmt|;
name|hunk
index|[
literal|0
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|*
name|s
operator|>>
literal|2
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
operator|*
name|s
operator|<<
literal|4
operator|)
operator|&
literal|060
operator|)
operator||
operator|(
operator|(
name|r
operator|>>
literal|4
operator|)
operator|&
literal|017
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
name|PL_uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
name|r
operator|<<
literal|2
operator|)
operator|&
literal|074
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
name|PL_uuemap
index|[
literal|0
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|SV
modifier|*
name|S_is_an_int
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|l
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|SV
modifier|*
name|result
init|=
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result_c
init|=
name|SvPV
argument_list|(
name|result
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
comment|/* convenience */
name|char
modifier|*
name|out
init|=
name|result_c
decl_stmt|;
name|bool
name|skip
init|=
literal|1
decl_stmt|;
name|bool
name|ignore
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
block|{
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
operator|*
name|s
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|ignore
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|SvREFCNT_dec
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|result
argument_list|,
name|out
operator|-
name|result_c
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* pnum must be '\0' terminated */
end_comment

begin_function
name|STATIC
name|int
name|S_div128
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|pnum
parameter_list|,
name|bool
modifier|*
name|done
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|pnum
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
operator|*
name|done
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|m
operator|*
literal|10
operator|+
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
name|m
operator|=
name|i
operator|&
literal|0x7F
expr_stmt|;
name|r
operator|=
operator|(
name|i
operator|>>
literal|7
operator|)
expr_stmt|;
comment|/* r< 10 */
if|if
condition|(
name|r
condition|)
block|{
operator|*
name|done
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|t
operator|++
operator|)
operator|=
literal|'0'
operator|+
name|r
expr_stmt|;
block|}
operator|*
operator|(
name|t
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|pnum
argument_list|,
call|(
name|STRLEN
call|)
argument_list|(
name|t
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_pack
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|SV
modifier|*
name|cat
init|=
name|TARG
decl_stmt|;
specifier|register
name|I32
name|items
decl_stmt|;
name|STRLEN
name|fromlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
init|=
name|SvPVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|,
name|fromlen
argument_list|)
decl_stmt|;
name|char
modifier|*
name|patcopy
decl_stmt|;
specifier|register
name|char
modifier|*
name|patend
init|=
name|pat
operator|+
name|fromlen
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
name|I32
name|datumtype
decl_stmt|;
name|SV
modifier|*
name|fromstr
decl_stmt|;
comment|/*SUPPRESS 442*/
specifier|static
name|char
name|null10
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|space10
init|=
literal|"          "
decl_stmt|;
comment|/* These must not be in registers: */
name|char
name|achar
decl_stmt|;
name|I16
name|ashort
decl_stmt|;
name|int
name|aint
decl_stmt|;
name|unsigned
name|int
name|auint
decl_stmt|;
name|I32
name|along
decl_stmt|;
name|U32
name|aulong
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|Quad_t
name|aquad
decl_stmt|;
name|Uquad_t
name|auquad
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|aptr
decl_stmt|;
name|float
name|afloat
decl_stmt|;
name|double
name|adouble
decl_stmt|;
name|int
name|commas
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|int
name|natint
decl_stmt|;
comment|/* native integer */
endif|#
directive|endif
name|items
operator|=
name|SP
operator|-
name|MARK
expr_stmt|;
name|MARK
operator|++
expr_stmt|;
name|sv_setpvn
argument_list|(
name|cat
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patcopy
operator|=
name|pat
expr_stmt|;
while|while
condition|(
name|pat
operator|<
name|patend
condition|)
block|{
name|SV
modifier|*
name|lengthcode
init|=
name|Nullsv
decl_stmt|;
define|#
directive|define
name|NEXTFROM
value|( lengthcode ? lengthcode : items--> 0 ? *MARK++ :&PL_sv_no)
name|datumtype
operator|=
operator|*
name|pat
operator|++
operator|&
literal|0xFF
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|natint
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isSPACE
argument_list|(
name|datumtype
argument_list|)
condition|)
block|{
name|patcopy
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|datumtype
operator|==
literal|'U'
operator|&&
name|pat
operator|==
name|patcopy
operator|+
literal|1
condition|)
name|SvUTF8_on
argument_list|(
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|pat
operator|<
name|patend
operator|&&
operator|*
name|pat
operator|!=
literal|'\n'
condition|)
name|pat
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|pat
operator|==
literal|'!'
condition|)
block|{
name|char
modifier|*
name|natstr
init|=
literal|"sSiIlL"
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|natstr
argument_list|,
name|datumtype
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PERL_NATINT_PACK
name|natint
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pat
operator|++
expr_stmt|;
block|}
else|else
name|DIE
argument_list|(
name|aTHX_
literal|"'!' allowed only after types %s"
argument_list|,
name|natstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|strchr
argument_list|(
literal|"@Xxu"
argument_list|,
name|datumtype
argument_list|)
condition|?
literal|0
else|:
name|items
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|*
name|pat
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|(
name|len
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|pat
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Repeat count in pack overflows"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pat
operator|==
literal|'/'
condition|)
block|{
operator|++
name|pat
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pat
operator|!=
literal|'a'
operator|&&
operator|*
name|pat
operator|!=
literal|'A'
operator|&&
operator|*
name|pat
operator|!=
literal|'Z'
operator|)
operator|||
name|pat
index|[
literal|1
index|]
operator|!=
literal|'*'
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"/ must be followed by a*, A* or Z*"
argument_list|)
expr_stmt|;
name|lengthcode
operator|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|sv_len
argument_list|(
name|items
operator|>
literal|0
condition|?
operator|*
name|MARK
else|:
operator|&
name|PL_sv_no
argument_list|)
operator|+
operator|(
operator|*
name|pat
operator|==
literal|'Z'
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|datumtype
condition|)
block|{
default|default:
name|DIE
argument_list|(
name|aTHX_
literal|"Invalid type in pack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
case|case
literal|','
case|:
comment|/* grandfather in commas but with a warning */
if|if
condition|(
name|commas
operator|++
operator|==
literal|0
operator|&&
name|ckWARN
argument_list|(
name|WARN_PACK
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PACK
argument_list|,
literal|"Invalid type in pack: '%c'"
argument_list|,
argument|(int)datumtype
argument_list|)
empty_stmt|;
break|break;
case|case
literal|'%'
case|:
name|DIE
argument_list|(
name|aTHX_
literal|"%% may only be used in unpack"
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
name|len
operator|-=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|grow
goto|;
name|len
operator|=
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|shrink
goto|;
break|break;
case|case
literal|'X'
case|:
name|shrink
label|:
if|if
condition|(
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|<
name|len
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"X outside of string"
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|-=
name|len
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|cat
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|grow
label|:
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|fromlen
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'Z'
condition|)
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|fromlen
operator|>=
name|len
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'Z'
condition|)
operator|*
operator|(
name|SvEND
argument_list|(
name|cat
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|fromlen
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'A'
condition|)
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|space10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|space10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|I32
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|str
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+=
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromlen
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
name|items
operator||=
operator|*
name|str
operator|++
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|&
literal|1
condition|)
name|items
operator||=
literal|128
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|>>=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
name|items
operator|<<=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
else|else
name|items
operator|>>=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
block|}
name|str
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|str
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|I32
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|str
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromlen
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'H'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|*
name|str
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
expr_stmt|;
else|else
name|items
operator||=
operator|*
name|str
operator|++
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|<<=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|(
operator|*
name|str
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
name|items
operator||=
operator|(
operator|*
name|str
operator|++
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|>>=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|1
condition|)
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|str
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|str
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|achar
operator|=
name|aint
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|&
name|achar
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auint
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+
name|UTF8_MAXLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|SvEND
argument_list|(
name|cat
argument_list|)
argument_list|,
name|auint
argument_list|)
operator|-
name|SvPVX
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|SvEND
argument_list|(
name|cat
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* Float and double added by gnb@melba.bby.oz.au  22/11/89 */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|afloat
operator|=
operator|(
name|float
operator|)
name|SvNV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|afloat
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|adouble
operator|=
operator|(
name|double
operator|)
name|SvNV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|adouble
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONS
name|ashort
operator|=
name|PerlSock_htons
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVS
name|ashort
operator|=
name|htovs
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|natint
condition|)
block|{
name|unsigned
name|short
name|aushort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aushort
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aushort
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|U16
name|aushort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aushort
operator|=
operator|(
name|U16
operator|)
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|aushort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
if|#
directive|if
name|SHORTSIZE
operator|!=
name|SIZE16
if|if
condition|(
name|natint
condition|)
block|{
name|short
name|ashort
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'I'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auint
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auint
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|adouble
operator|=
name|Perl_floor
argument_list|(
name|SvNV
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adouble
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Cannot compress negative numbers"
argument_list|)
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|&&
name|UVSIZE
operator|>=
name|NVSIZE
name|adouble
operator|<=
literal|0xffffffff
else|#
directive|else
ifdef|#
directive|ifdef
name|CXUX_BROKEN_CONSTANT_CONVERT
name|adouble
operator|<=
name|UV_MAX_cxux
else|#
directive|else
name|adouble
operator|<=
name|UV_MAX
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
name|char
name|buf
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|in
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|UV
name|auv
init|=
name|U_V
argument_list|(
name|adouble
argument_list|)
decl_stmt|;
do|do
block|{
operator|*
operator|--
name|in
operator|=
operator|(
name|auv
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
name|auv
operator|>>=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|auv
condition|)
do|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|fromstr
argument_list|)
condition|)
block|{
comment|/* decimal string arithmetics */
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|SV
modifier|*
name|norm
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|bool
name|done
decl_stmt|;
comment|/* Copy string and check for compliance */
name|from
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|norm
operator|=
name|is_an_int
argument_list|(
name|from
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"can compress only unsigned integer"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|'w'
argument_list|,
name|result
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|in
operator|=
name|result
operator|+
name|len
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
operator|*
operator|--
name|in
operator|=
name|div128
argument_list|(
name|norm
argument_list|,
operator|&
name|done
argument_list|)
operator||
literal|0x80
expr_stmt|;
name|result
index|[
name|len
operator|-
literal|1
index|]
operator|&=
literal|0x7F
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|result
operator|+
name|len
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|norm
argument_list|)
expr_stmt|;
comment|/* free norm */
block|}
elseif|else
if|if
condition|(
name|SvNOKp
argument_list|(
name|fromstr
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
literal|2
index|]
decl_stmt|;
comment|/* 8/7<= 2 */
name|char
modifier|*
name|in
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
do|do
block|{
name|double
name|next
init|=
name|floor
argument_list|(
name|adouble
operator|/
literal|128
argument_list|)
decl_stmt|;
operator|*
operator|--
name|in
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|adouble
operator|-
operator|(
name|next
operator|*
literal|128
operator|)
argument_list|)
operator||
literal|0x80
expr_stmt|;
if|if
condition|(
name|in
operator|<=
name|buf
condition|)
comment|/* this cannot happen ;-) */
name|DIE
argument_list|(
name|aTHX_
literal|"Cannot compress integer"
argument_list|)
expr_stmt|;
name|in
operator|--
expr_stmt|;
name|adouble
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|adouble
operator|>
literal|0
condition|)
do|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
block|}
else|else
name|DIE
argument_list|(
name|aTHX_
literal|"Cannot compress non integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aint
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONL
name|aulong
operator|=
name|PerlSock_htonl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVL
name|aulong
operator|=
name|htovl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|natint
condition|)
block|{
name|unsigned
name|long
name|aulong
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
if|#
directive|if
name|LONGSIZE
operator|!=
name|SIZE32
if|if
condition|(
name|natint
condition|)
block|{
name|long
name|along
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|along
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|along
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|along
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'Q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auquad
operator|=
operator|(
name|Uquad_t
operator|)
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auquad
argument_list|,
sizeof|sizeof
argument_list|(
name|Uquad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aquad
operator|=
operator|(
name|Quad_t
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aquad
argument_list|,
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'P'
case|:
name|len
operator|=
literal|1
expr_stmt|;
comment|/* assume SV is correct length */
comment|/* FALL THROUGH */
case|case
literal|'p'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
if|if
condition|(
name|fromstr
operator|==
operator|&
name|PL_sv_undef
condition|)
name|aptr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|STRLEN
name|n_a
decl_stmt|;
comment|/* XXX better yet, could spirit away the string to 		     * a safe spot and hang on to it until the result 		     * of pack() (and all copies of the result) are 		     * gone. 		     */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PACK
argument_list|)
operator|&&
operator|(
name|SvTEMP
argument_list|(
name|fromstr
argument_list|)
operator|||
operator|(
name|SvPADTMP
argument_list|(
name|fromstr
argument_list|)
operator|&&
operator|!
name|SvREADONLY
argument_list|(
name|fromstr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PACK
argument_list|,
literal|"Attempt to pack pointer to temporary value"
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|SvPOK
argument_list|(
name|fromstr
argument_list|)
operator|||
name|SvNIOK
argument_list|(
name|fromstr
argument_list|)
condition|)
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
else|else
name|aptr
operator|=
name|SvPV_force
argument_list|(
name|fromstr
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|fromlen
operator|*
literal|4
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|len
operator|=
literal|45
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|/
literal|3
operator|*
literal|3
expr_stmt|;
while|while
condition|(
name|fromlen
operator|>
literal|0
condition|)
block|{
name|I32
name|todo
decl_stmt|;
if|if
condition|(
name|fromlen
operator|>
name|len
condition|)
name|todo
operator|=
name|len
expr_stmt|;
else|else
name|todo
operator|=
name|fromlen
expr_stmt|;
name|doencodes
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|fromlen
operator|-=
name|todo
expr_stmt|;
name|aptr
operator|+=
name|todo
expr_stmt|;
block|}
break|break;
block|}
block|}
name|SvSETMAGIC
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|NEXTFROM
end_undef

begin_macro
name|PP
argument_list|(
argument|pp_split
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTARG
expr_stmt|;
name|AV
modifier|*
name|ary
decl_stmt|;
specifier|register
name|IV
name|limit
init|=
name|POPi
decl_stmt|;
comment|/* note, negative is forever */
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|bool
name|do_utf8
init|=
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strend
init|=
name|s
operator|+
name|len
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
specifier|register
name|REGEXP
modifier|*
name|rx
decl_stmt|;
specifier|register
name|SV
modifier|*
name|dstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
name|I32
name|iters
init|=
literal|0
decl_stmt|;
name|STRLEN
name|slen
init|=
name|do_utf8
condition|?
name|utf8_length
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|strend
argument_list|)
else|:
operator|(
name|strend
operator|-
name|s
operator|)
decl_stmt|;
name|I32
name|maxiters
init|=
name|slen
operator|+
literal|10
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|char
modifier|*
name|orig
decl_stmt|;
name|I32
name|origlimit
init|=
name|limit
decl_stmt|;
name|I32
name|realarray
init|=
literal|0
decl_stmt|;
name|I32
name|base
decl_stmt|;
name|AV
modifier|*
name|oldstack
init|=
name|PL_curstack
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|oldsave
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|make_mortal
init|=
literal|1
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|Copy
argument_list|(
operator|&
name|LvTARGOFF
argument_list|(
name|POPs
argument_list|)
argument_list|,
operator|&
name|pm
argument_list|,
literal|1
argument_list|,
name|PMOP
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|POPs
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pm
operator|||
operator|!
name|s
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"panic: pp_split"
argument_list|)
expr_stmt|;
name|rx
operator|=
name|pm
operator|->
name|op_pmregexp
expr_stmt|;
name|TAINT_IF
argument_list|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
operator|&&
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
operator|(
name|PMf_WHITE
operator||
name|PMf_SKIPWHITE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmreplroot
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|ary
operator|=
name|GvAVn
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|PL_curpad
index|[
operator|(
name|PADOFFSET
operator|)
name|pm
operator|->
name|op_pmreplroot
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|ary
operator|=
name|GvAVn
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|pm
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
ifdef|#
directive|ifdef
name|USE_THREADS
name|ary
operator|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|ary
operator|=
name|GvAVn
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
else|else
name|ary
operator|=
name|Nullav
expr_stmt|;
if|if
condition|(
name|ary
operator|&&
operator|(
name|gimme
operator|!=
name|G_ARRAY
operator|||
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_ONCE
operator|)
operator|)
condition|)
block|{
name|realarray
operator|=
literal|1
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|av_extend
argument_list|(
name|ary
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_clear
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|AvREAL_on
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|AvREIFY_off
argument_list|(
name|ary
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|i
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
comment|/* don't free mere refs */
block|}
comment|/* temporarily switch stacks */
name|SWITCHSTACK
argument_list|(
name|PL_curstack
argument_list|,
name|ary
argument_list|)
expr_stmt|;
name|make_mortal
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|base
operator|=
name|SP
operator|-
name|PL_stack_base
expr_stmt|;
name|orig
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_SKIPWHITE
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
condition|)
block|{
while|while
condition|(
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
operator|(
name|PMf_MULTILINE
operator||
name|PMf_SINGLELINE
operator|)
condition|)
block|{
name|SAVEINT
argument_list|(
name|PL_multiline
argument_list|)
expr_stmt|;
name|PL_multiline
operator|=
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_MULTILINE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|limit
condition|)
name|limit
operator|=
name|maxiters
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_WHITE
condition|)
block|{
while|while
condition|(
operator|--
name|limit
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|m
operator|<
name|strend
operator|&&
operator|!
operator|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|isSPACE_LC
argument_list|(
operator|*
name|m
argument_list|)
else|:
name|isSPACE
argument_list|(
operator|*
name|m
argument_list|)
operator|)
condition|)
operator|++
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
operator|++
name|s
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
literal|"^"
argument_list|,
name|rx
operator|->
name|precomp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|limit
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|m
operator|=
name|s
init|;
name|m
operator|<
name|strend
operator|&&
operator|*
name|m
operator|!=
literal|'\n'
condition|;
name|m
operator|++
control|)
empty_stmt|;
name|m
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rx
operator|->
name|reganch
operator|&
name|RE_USE_INTUIT
operator|)
operator|&&
operator|!
name|rx
operator|->
name|nparens
operator|&&
operator|(
name|rx
operator|->
name|reganch
operator|&
name|ROPT_CHECK_ALL
operator|)
operator|&&
operator|!
operator|(
name|rx
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
name|int
name|tail
init|=
operator|(
name|rx
operator|->
name|reganch
operator|&
name|RE_INTUIT_TAIL
operator|)
decl_stmt|;
name|SV
modifier|*
name|csv
init|=
name|CALLREG_INTUIT_STRING
argument_list|(
argument|aTHX_ rx
argument_list|)
decl_stmt|;
name|len
operator|=
name|rx
operator|->
name|minlen
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
operator|!
operator|(
name|rx
operator|->
name|reganch
operator|&
name|ROPT_UTF8
operator|)
operator|&&
operator|!
name|tail
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|char
name|c
init|=
operator|*
name|SvPV
argument_list|(
name|csv
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|limit
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|m
operator|=
name|s
init|;
name|m
operator|<
name|strend
operator|&&
operator|*
name|m
operator|!=
name|c
condition|;
name|m
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* The rx->minlen is in characters but we want to step 		 * s ahead by bytes. */
if|if
condition|(
name|do_utf8
condition|)
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|utf8_hop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|m
operator|+
name|len
expr_stmt|;
comment|/* Fake \n at the end */
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|lint
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|--
name|limit
operator|&&
operator|(
name|m
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|csv
argument_list|,
name|PL_multiline
condition|?
name|FBMrf_MULTILINE
else|:
literal|0
argument_list|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|31
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* The rx->minlen is in characters but we want to step 		 * s ahead by bytes. */
if|if
condition|(
name|do_utf8
condition|)
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|utf8_hop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|m
operator|+
name|len
expr_stmt|;
comment|/* Fake \n at the end */
block|}
block|}
block|}
else|else
block|{
name|maxiters
operator|+=
name|slen
operator|*
name|rx
operator|->
name|nparens
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|--
name|limit
comment|/*&& (!rx->check_substr  		   || ((s = CALLREG_INTUIT_START(aTHX_ rx, sv, s, strend, 						 0, NULL)))) */
operator|&&
name|CALLREGEXEC
argument_list|(
argument|aTHX_ rx
argument_list|,
argument|s
argument_list|,
argument|strend
argument_list|,
argument|orig
argument_list|,
literal|1
comment|/* minend */
argument_list|,
argument|sv
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TAINT_IF
argument_list|(
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|rx
argument_list|)
operator|&&
name|rx
operator|->
name|subbeg
operator|!=
name|orig
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
name|orig
operator|=
name|rx
operator|->
name|subbeg
expr_stmt|;
name|s
operator|=
name|orig
operator|+
operator|(
name|m
operator|-
name|s
operator|)
expr_stmt|;
name|strend
operator|=
name|s
operator|+
operator|(
name|strend
operator|-
name|m
operator|)
expr_stmt|;
block|}
name|m
operator|=
name|rx
operator|->
name|startp
index|[
literal|0
index|]
operator|+
name|orig
expr_stmt|;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|32
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|nparens
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|rx
operator|->
name|startp
index|[
name|i
index|]
operator|+
name|orig
expr_stmt|;
name|m
operator|=
name|rx
operator|->
name|endp
index|[
name|i
index|]
operator|+
name|orig
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|s
condition|)
block|{
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|33
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|33
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|rx
operator|->
name|endp
index|[
literal|0
index|]
operator|+
name|orig
expr_stmt|;
block|}
block|}
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
name|iters
operator|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|iters
operator|>
name|maxiters
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Split loop"
argument_list|)
expr_stmt|;
comment|/* keep field after final delim? */
if|if
condition|(
name|s
operator|<
name|strend
operator|||
operator|(
name|iters
operator|&&
name|origlimit
operator|)
condition|)
block|{
name|STRLEN
name|l
init|=
name|strend
operator|-
name|s
decl_stmt|;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|34
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_utf8
condition|)
operator|(
name|void
operator|)
name|SvUTF8_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|iters
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|origlimit
condition|)
block|{
while|while
condition|(
name|iters
operator|>
literal|0
operator|&&
operator|(
operator|!
name|TOPs
operator|||
operator|!
name|SvANY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|iters
operator|--
operator|,
name|SP
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|realarray
condition|)
block|{
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|SWITCHSTACK
argument_list|(
name|ary
argument_list|,
name|oldstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|PUTBACK
expr_stmt|;
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|iters
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|iters
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|iters
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
else|else
block|{
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|call_method
argument_list|(
literal|"PUSH"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* EXTEND should not be needed - we just popped them */
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|iters
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|ary
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|PUSHs
argument_list|(
operator|(
name|svp
operator|)
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|iters
operator|||
operator|!
name|pm
operator|->
name|op_pmreplroot
condition|)
block|{
name|GETTARGET
expr_stmt|;
name|PUSHi
argument_list|(
name|iters
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_THREADS
end_ifdef

begin_function
name|void
name|Perl_unlock_condpair
parameter_list|(
name|pTHX_
name|void
modifier|*
name|svv
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|svv
argument_list|,
literal|'m'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mg
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: unlock_condpair unlocking non-mutex"
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|!=
name|thr
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: unlock_condpair unlocking mutex that we don't own"
argument_list|)
expr_stmt|;
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
name|MgOWNERCONDP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
argument|PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|": unlock 0x%"
argument|UVxf
literal|"\n"
argument|, 			  PTR2UV(thr), PTR2UV(svv));
argument_list|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_THREADS */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_lock
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|retsv
init|=
name|sv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_lock
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVAV
operator|||
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVHV
operator|||
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|retsv
operator|=
name|refto
argument_list|(
name|retsv
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|retsv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_threadsv
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|dSP
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|PUSHs
argument_list|(
operator|*
name|save_threadsv
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|THREADSV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
name|aTHX_
literal|"tried to access per-thread data in non-threaded perl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
block|}
end_block

end_unit

