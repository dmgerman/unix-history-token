begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    pp.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * "It's a big house this, and very peculiar.  Always a bit more to discover,  * and no knowing what you'll find around a corner.  And Elves, sir!" --Samwise  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_comment
comment|/*  * The compiler on Concurrent CX/UX systems has a subtle bug which only  * seems to show up when compiling pp.c - it generates the wrong double  * precision constant value for (double)UV_MAX when used inline in the body  * of the code below, so this makes a static variable up front (which the  * compiler seems to get correct) and uses it in place of UV_MAX below.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CXUX_BROKEN_CONSTANT_CONVERT
end_ifdef

begin_decl_stmt
specifier|static
name|double
name|UV_MAX_cxux
init|=
operator|(
operator|(
name|double
operator|)
name|UV_MAX
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Types used in bitwise operations.  *  * Normally we'd just use IV and UV.  However, some hardware and  * software combinations (e.g. Alpha and current OSF/1) don't have a  * floating-point type to use for NV that has adequate bits to fully  * hold an IV/UV.  (In other words, sizeof(long) == sizeof(double).)  *  * It just so happens that "int" is the right size almost everywhere.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|IBW
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|UBW
typedef|;
end_typedef

begin_comment
comment|/*  * Mask used after bitwise operations.  *  * There is at least one realm (Cray word machines) that doesn't  * have an integral type (except char) small enough to be represented  * in a double without loss; that is, it has no 32-bit type.  */
end_comment

begin_if
if|#
directive|if
name|LONGSIZE
operator|>
literal|4
operator|&&
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_CRAYMPP
argument_list|)
end_if

begin_define
define|#
directive|define
name|BW_BITS
value|32
end_define

begin_define
define|#
directive|define
name|BW_MASK
value|((1<< BW_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|BW_SIGN
value|(1<< (BW_BITS - 1))
end_define

begin_define
define|#
directive|define
name|BWi
parameter_list|(
name|i
parameter_list|)
value|(((i)& BW_SIGN) ? ((i) | ~BW_MASK) : ((i)& BW_MASK))
end_define

begin_define
define|#
directive|define
name|BWu
parameter_list|(
name|u
parameter_list|)
value|((u)& BW_MASK)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BWi
parameter_list|(
name|i
parameter_list|)
value|(i)
end_define

begin_define
define|#
directive|define
name|BWu
parameter_list|(
name|u
parameter_list|)
value|(u)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Offset for integer pack/unpack.  *  * On architectures where I16 and I32 aren't really 16 and 32 bits,  * which for now are all Crays, pack and unpack have to play games.  */
end_comment

begin_comment
comment|/*  * These values are required for portability of pack() output.  * If they're not right on your machine, then pack() and unpack()  * wouldn't work right anyway; you'll need to apply the Cray hack.  * (I'd like to check them with #if, but you can't use sizeof() in  * the preprocessor.)  --???  */
end_comment

begin_comment
comment|/*     The appropriate SHORTSIZE, INTSIZE, LONGSIZE, and LONGLONGSIZE     defines are now in config.h.  --Andy Dougherty  April 1998  */
end_comment

begin_define
define|#
directive|define
name|SIZE16
value|2
end_define

begin_define
define|#
directive|define
name|SIZE32
value|4
end_define

begin_if
if|#
directive|if
name|BYTEORDER
operator|>
literal|0xFFFF
operator|&&
name|defined
argument_list|(
name|_CRAY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_CRAYMPP
argument_list|)
end_if

begin_if
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x12345678
end_if

begin_define
define|#
directive|define
name|OFF16
parameter_list|(
name|p
parameter_list|)
value|(char*)(p)
end_define

begin_define
define|#
directive|define
name|OFF32
parameter_list|(
name|p
parameter_list|)
value|(char*)(p)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x87654321
end_if

begin_define
define|#
directive|define
name|OFF16
parameter_list|(
name|p
parameter_list|)
value|((char*)(p) + (sizeof(U16) - SIZE16))
end_define

begin_define
define|#
directive|define
name|OFF32
parameter_list|(
name|p
parameter_list|)
value|((char*)(p) + (sizeof(U32) - SIZE32))
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
unit|}}}}
name|bad
name|cray
name|byte
name|order
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|COPY16
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*(p) = 0, Copy(s, OFF16(p), SIZE16, char))
define|#
directive|define
name|COPY32
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*(p) = 0, Copy(s, OFF32(p), SIZE32, char))
define|#
directive|define
name|CAT16
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, OFF16(p), SIZE16)
define|#
directive|define
name|CAT32
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, OFF32(p), SIZE32)
else|#
directive|else
define|#
directive|define
name|COPY16
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|Copy(s, p, SIZE16, char)
define|#
directive|define
name|COPY32
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|Copy(s, p, SIZE32, char)
define|#
directive|define
name|CAT16
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, (char*)(p), SIZE16)
define|#
directive|define
name|CAT32
parameter_list|(
name|sv
parameter_list|,
name|p
parameter_list|)
value|sv_catpvn(sv, (char*)(p), SIZE32)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_OBJECT
specifier|static
name|void
name|doencodes
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|,
name|char
operator|*
name|s
operator|,
name|I32
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SV
modifier|*
name|refto
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U32
name|seed
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|srand_called
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* variations on pp_null */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX I can't imagine anyone who doesn't have this actually _needs_    it, since pid_t is an integral type.    --AD  2/20/1998 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_GETPID_PROTO
end_ifdef

begin_function_decl
specifier|extern
name|Pid_t
name|getpid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_stub
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
name|GIMME_V
operator|==
name|G_SCALAR
condition|)
name|XPUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scalar
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_comment
comment|/* Pushy stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_padav
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|SAVECLEARSV
argument_list|(
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|I32
name|maxarg
init|=
name|AvFILL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
operator|+
literal|1
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|maxarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|TARG
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxarg
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SP
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|svp
operator|)
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|maxarg
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|SP
operator|+=
name|maxarg
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|I32
name|maxarg
init|=
name|AvFILL
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|TARG
argument_list|)
operator|+
literal|1
decl_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|maxarg
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_padhv
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|gimme
decl_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|SAVECLEARSV
argument_list|(
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
name|RETURN
expr_stmt|;
name|gimme
operator|=
name|GIMME_V
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|RETURNOP
argument_list|(
name|do_kv
argument_list|(
name|ARGS
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|HvFILL
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|TARG
argument_list|)
condition|)
name|sv_setpvf
argument_list|(
name|sv
argument_list|,
literal|"%ld/%ld"
argument_list|,
operator|(
name|long
operator|)
name|HvFILL
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|TARG
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|HvMAX
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|TARG
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sv_setiv
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_padany
argument_list|)
end_macro

begin_block
block|{
name|DIE
argument_list|(
literal|"NOT IMPL LINE %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Translations. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_rv2gv
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|wasref
label|:
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVIO
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_init
argument_list|(
name|gv
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvIOp
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|IO
operator|*
operator|)
name|sv
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|DIE
argument_list|(
literal|"Not a GLOB reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|wasref
goto|;
block|}
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|||
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
name|no_usym
argument_list|,
literal|"a symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
name|RETSETUNDEF
expr_stmt|;
block|}
name|sym
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
name|no_symref
argument_list|,
name|sym
argument_list|,
literal|"a symbol"
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_gp
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|,
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rv2sv
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|wasref
label|:
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
name|DIE
argument_list|(
literal|"Not a SCALAR reference"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|sv
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|wasref
goto|;
block|}
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|||
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
name|no_usym
argument_list|,
literal|"a SCALAR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
name|RETSETUNDEF
expr_stmt|;
block|}
name|sym
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_STRICT_REFS
condition|)
name|DIE
argument_list|(
name|no_symref
argument_list|,
name|sym
argument_list|,
literal|"a SCALAR"
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|sv
operator|=
name|save_scalar
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|TOPs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpDEREF
condition|)
name|vivify_ref
argument_list|(
name|sv
argument_list|,
name|PL_op
operator|->
name|op_private
operator|&
name|OPpDEREF
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_av2arylen
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|TOPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|AvARYLEN
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
block|{
name|AvARYLEN
argument_list|(
name|av
argument_list|)
operator|=
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'#'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_pos
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|dPOPss
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'.'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|sv
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* no SvSETMAGIC */
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|&&
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
block|{
name|PUSHi
argument_list|(
name|mg
operator|->
name|mg_len
operator|+
name|PL_curcop
operator|->
name|cop_arybase
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rv2cv
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
comment|/* We usually try to add a non-existent subroutine in case of AUTOLOAD. */
comment|/* (But not in defined().) */
name|CV
modifier|*
name|cv
init|=
name|sv_2cv
argument_list|(
name|TOPs
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
operator|&
name|PL_sv_undef
expr_stmt|;
name|SETs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_prototype
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|>=
literal|7
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|TOPs
argument_list|)
decl_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"CORE::"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|keyword
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
comment|/* Overridable. */
define|#
directive|define
name|MAX_ARGS_OP
value|((sizeof(I32) - 1) * 2)
name|int
name|i
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|seen_question
init|=
literal|0
decl_stmt|;
name|I32
name|oa
decl_stmt|;
name|char
name|str
index|[
name|MAX_ARGS_OP
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
comment|/* One ';', one '\0' */
while|while
condition|(
name|i
operator|<
name|MAXO
condition|)
block|{
comment|/* The slow way. */
if|if
condition|(
name|strEQ
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|op_name
index|[
name|i
index|]
argument_list|)
operator|||
name|strEQ
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|op_desc
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|i
operator|++
expr_stmt|;
block|}
goto|goto
name|nonesuch
goto|;
comment|/* Should not happen... */
name|found
label|:
name|oa
operator|=
name|opargs
index|[
name|i
index|]
operator|>>
name|OASHIFT
expr_stmt|;
while|while
condition|(
name|oa
condition|)
block|{
if|if
condition|(
name|oa
operator|&
name|OA_OPTIONAL
condition|)
block|{
name|seen_question
operator|=
literal|1
expr_stmt|;
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|';'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_question
condition|)
goto|goto
name|set
goto|;
comment|/* XXXX system, exec */
if|if
condition|(
operator|(
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
operator|)
operator|>=
name|OA_AVREF
operator|&&
operator|(
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
operator|)
operator|<=
name|OA_HVREF
condition|)
block|{
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
comment|/* What to do with R ((un)tie, tied, (sys)read, recv)? */
name|str
index|[
name|n
operator|++
index|]
operator|=
operator|(
literal|"?$@@%&*$"
operator|)
index|[
name|oa
operator|&
operator|(
name|OA_OPTIONAL
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|oa
operator|=
name|oa
operator|>>
literal|4
expr_stmt|;
block|}
name|str
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|str
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
condition|)
comment|/* Non-Overridable */
goto|goto
name|set
goto|;
else|else
block|{
comment|/* None such */
name|nonesuch
label|:
name|croak
argument_list|(
literal|"Cannot find an opnumber for \"%s\""
argument_list|,
name|s
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cv
operator|=
name|sv_2cv
argument_list|(
name|TOPs
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
name|ret
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|SvPVX
argument_list|(
name|cv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set
label|:
name|SETs
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anoncode
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|CV
modifier|*
name|cv
init|=
operator|(
name|CV
operator|*
operator|)
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
decl_stmt|;
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv_clone
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_srefgen
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
operator|*
name|SP
operator|=
name|refto
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_refgen
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
operator|*
name|MARK
operator|=
name|refto
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|EXTEND_MORTAL
argument_list|(
name|SP
operator|-
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
name|refto
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|SV
modifier|*
name|refto
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVLV
operator|&&
name|LvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|LvTARGLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|vivify_defelem
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sv
operator|=
name|LvTARG
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
name|sv
operator|=
name|newSVsv
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
block|{
name|SvTEMP_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|sv_upgrade
argument_list|(
name|rv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|rv
argument_list|)
operator|=
name|sv
expr_stmt|;
name|SvROK_on
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_ref
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|pv
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|sv
operator|&&
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHNO
expr_stmt|;
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|pv
operator|=
name|sv_reftype
argument_list|(
name|sv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|PUSHp
argument_list|(
name|pv
argument_list|,
name|strlen
argument_list|(
name|pv
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bless
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|==
literal|1
condition|)
name|stash
operator|=
name|PL_curcop
operator|->
name|cop_stash
expr_stmt|;
else|else
block|{
name|SV
modifier|*
name|ssv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|SvPV
argument_list|(
name|ssv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|len
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"Explicit blessing to '' (assuming package main)"
argument_list|)
expr_stmt|;
name|stash
operator|=
name|gv_stashpvn
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sv_bless
argument_list|(
name|TOPs
argument_list|,
name|stash
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gelem
argument_list|)
end_macro

begin_block
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
name|tmpRef
decl_stmt|;
name|char
modifier|*
name|elem
decl_stmt|;
name|djSP
expr_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|elem
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|POPs
expr_stmt|;
name|tmpRef
operator|=
name|Nullsv
expr_stmt|;
name|sv
operator|=
name|Nullsv
expr_stmt|;
switch|switch
condition|(
name|elem
condition|?
operator|*
name|elem
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"ARRAY"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvAV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"CODE"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvCVu
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"FILEHANDLE"
argument_list|)
condition|)
comment|/* XXX deprecate in 5.005 */
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"GLOB"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|gv
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"HASH"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvHV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"IO"
argument_list|)
condition|)
name|tmpRef
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"NAME"
argument_list|)
condition|)
name|sv
operator|=
name|newSVpv
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"PACKAGE"
argument_list|)
condition|)
name|sv
operator|=
name|newSVpv
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|elem
argument_list|,
literal|"SCALAR"
argument_list|)
condition|)
name|tmpRef
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmpRef
condition|)
name|sv
operator|=
name|newRV
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
condition|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|XPUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pattern matching */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_study
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dPOPss
expr_stmt|;
specifier|register
name|UNOP
modifier|*
name|unop
init|=
name|cUNOP
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|I32
name|pos
decl_stmt|;
specifier|register
name|I32
name|ch
decl_stmt|;
specifier|register
name|I32
modifier|*
name|sfirst
decl_stmt|;
specifier|register
name|I32
modifier|*
name|snext
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|sv
operator|==
name|PL_lastscream
condition|)
block|{
if|if
condition|(
name|SvSCREAM
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_lastscream
condition|)
block|{
name|SvSCREAM_off
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
block|}
name|PL_lastscream
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
name|RETPUSHNO
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|PL_maxscream
condition|)
block|{
if|if
condition|(
name|PL_maxscream
operator|<
literal|0
condition|)
block|{
name|PL_maxscream
operator|=
name|pos
operator|+
literal|80
expr_stmt|;
name|New
argument_list|(
literal|301
argument_list|,
name|PL_screamfirst
argument_list|,
literal|256
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|302
argument_list|,
name|PL_screamnext
argument_list|,
name|PL_maxscream
argument_list|,
name|I32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_maxscream
operator|=
name|pos
operator|+
name|pos
operator|/
literal|4
expr_stmt|;
name|Renew
argument_list|(
name|PL_screamnext
argument_list|,
name|PL_maxscream
argument_list|,
name|I32
argument_list|)
expr_stmt|;
block|}
block|}
name|sfirst
operator|=
name|PL_screamfirst
expr_stmt|;
name|snext
operator|=
name|PL_screamnext
expr_stmt|;
if|if
condition|(
operator|!
name|sfirst
operator|||
operator|!
name|snext
condition|)
name|DIE
argument_list|(
literal|"do_study: out of memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|256
init|;
name|ch
condition|;
operator|--
name|ch
control|)
operator|*
name|sfirst
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|sfirst
operator|-=
literal|256
expr_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|ch
operator|=
name|s
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|sfirst
index|[
name|ch
index|]
operator|>=
literal|0
condition|)
name|snext
index|[
name|pos
index|]
operator|=
name|sfirst
index|[
name|ch
index|]
operator|-
name|pos
expr_stmt|;
else|else
name|snext
index|[
name|pos
index|]
operator|=
operator|-
name|pos
expr_stmt|;
name|sfirst
index|[
name|ch
index|]
operator|=
name|pos
expr_stmt|;
block|}
name|SvSCREAM_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'g'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* piggyback on m//g magic */
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_trans
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARG
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|sv
operator|=
name|POPs
expr_stmt|;
else|else
block|{
name|sv
operator|=
name|DEFSV
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|TARG
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|PUSHi
argument_list|(
name|do_trans
argument_list|(
name|sv
argument_list|,
name|PL_op
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Lvalue operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_schop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|do_chop
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
while|while
condition|(
name|SP
operator|>
name|MARK
condition|)
name|do_chop
argument_list|(
name|TARG
argument_list|,
name|POPs
argument_list|)
expr_stmt|;
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_schomp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SETi
argument_list|(
name|do_chomp
argument_list|(
name|TOPs
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chomp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|I32
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|SP
operator|>
name|MARK
condition|)
name|count
operator|+=
name|do_chomp
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
name|PUSHi
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_defined
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|!
name|SvANY
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHNO
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
if|if
condition|(
name|AvMAX
argument_list|(
name|sv
argument_list|)
operator|>=
literal|0
operator|||
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvRMAGICAL
argument_list|(
name|sv
argument_list|)
operator|&&
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
if|if
condition|(
name|HvARRAY
argument_list|(
name|sv
argument_list|)
operator|||
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvRMAGICAL
argument_list|(
name|sv
argument_list|)
operator|&&
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|CvROOT
argument_list|(
name|sv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_undef
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|PL_op
operator|->
name|op_private
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
break|break;
case|case
name|SVt_PVAV
case|:
name|av_undef
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|hv_undef
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|PL_dowarn
operator|&&
name|cv_const_sv
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Constant subroutine %s undefined"
argument_list|,
name|CvANON
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
condition|?
literal|"(anonymous)"
else|:
name|GvENAME
argument_list|(
name|CvGV
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVFM
case|:
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|CvGV
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
argument_list|)
decl_stmt|;
name|cv_undef
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
operator|=
name|gv
expr_stmt|;
block|}
comment|/* let user-undef'd sub keep its identity */
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
name|SvSetMagicSV
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|GP
modifier|*
name|gp
decl_stmt|;
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|602
argument_list|,
name|gp
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|sv
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|sv
argument_list|)
operator|=
name|NEWSV
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvLINE
argument_list|(
name|sv
argument_list|)
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|GvEGV
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
operator|&&
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|sv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_predec
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MIN
condition|)
block|{
operator|--
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_dec
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_postinc
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MAX
condition|)
block|{
operator|++
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_inc
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|TARG
argument_list|)
condition|)
name|sv_setiv
argument_list|(
name|TARG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_postdec
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|TOPs
argument_list|)
operator|>
name|SVt_PVLV
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|TOPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|!=
name|IV_MIN
condition|)
block|{
operator|--
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&=
operator|~
operator|(
name|SVp_NOK
operator||
name|SVp_POK
operator|)
expr_stmt|;
block|}
else|else
name|sv_dec
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_comment
comment|/* Ordinary operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_pow
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|pow
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|pow
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_multiply
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|mult
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|left
operator|*
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_divide
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|div
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPPOPnnrl
expr_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
name|right
operator|==
literal|0.0
condition|)
name|DIE
argument_list|(
literal|"Illegal division by zero"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SLOPPYDIVIDE
comment|/* insure that 20./5. == 4. */
block|{
name|IV
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
name|I_V
argument_list|(
name|left
argument_list|)
operator|==
name|left
operator|&&
operator|(
name|double
operator|)
name|I_V
argument_list|(
name|right
argument_list|)
operator|==
name|right
operator|&&
operator|(
name|k
operator|=
name|I_V
argument_list|(
name|left
argument_list|)
operator|/
name|I_V
argument_list|(
name|right
argument_list|)
operator|)
operator|*
name|I_V
argument_list|(
name|right
argument_list|)
operator|==
name|I_V
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|value
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|left
operator|/
name|right
expr_stmt|;
block|}
block|}
else|#
directive|else
name|value
operator|=
name|left
operator|/
name|right
expr_stmt|;
endif|#
directive|endif
name|PUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_modulo
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|modulo
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|UV
name|left
decl_stmt|;
name|UV
name|right
decl_stmt|;
name|bool
name|left_neg
decl_stmt|;
name|bool
name|right_neg
decl_stmt|;
name|UV
name|ans
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|IV
name|i
init|=
name|SvIVX
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
name|right
operator|=
operator|(
name|right_neg
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
block|}
else|else
block|{
name|double
name|n
init|=
name|POPn
decl_stmt|;
name|right
operator|=
name|U_V
argument_list|(
operator|(
name|right_neg
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|n
else|:
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvIOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOK
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOK
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|IV
name|i
init|=
name|SvIVX
argument_list|(
name|POPs
argument_list|)
decl_stmt|;
name|left
operator|=
operator|(
name|left_neg
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
block|}
else|else
block|{
name|double
name|n
init|=
name|POPn
decl_stmt|;
name|left
operator|=
name|U_V
argument_list|(
operator|(
name|left_neg
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
operator|)
condition|?
operator|-
name|n
else|:
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|right
condition|)
name|DIE
argument_list|(
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
name|ans
operator|=
name|left
operator|%
name|right
expr_stmt|;
if|if
condition|(
operator|(
name|left_neg
operator|!=
name|right_neg
operator|)
operator|&&
name|ans
condition|)
name|ans
operator|=
name|right
operator|-
name|ans
expr_stmt|;
if|if
condition|(
name|right_neg
condition|)
block|{
comment|/* XXX may warn: unary minus operator applied to unsigned type */
comment|/* could change -foo to be (~foo)+1 instead	*/
if|if
condition|(
name|ans
operator|<=
operator|~
operator|(
operator|(
name|UV
operator|)
name|IV_MAX
operator|)
operator|+
literal|1
condition|)
name|sv_setiv
argument_list|(
name|TARG
argument_list|,
operator|~
name|ans
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|TARG
argument_list|,
operator|-
operator|(
name|double
operator|)
name|ans
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setuv
argument_list|(
name|TARG
argument_list|,
name|ans
argument_list|)
expr_stmt|;
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_repeat
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|repeat
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
specifier|register
name|I32
name|count
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpREPEAT_DOLIST
condition|)
block|{
name|dMARK
expr_stmt|;
name|I32
name|items
init|=
name|SP
operator|-
name|MARK
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|max
operator|=
name|items
operator|*
name|count
expr_stmt|;
name|MEXTEND
argument_list|(
name|MARK
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|SP
operator|>
name|MARK
condition|)
block|{
if|if
condition|(
operator|*
name|SP
condition|)
name|SvTEMP_off
argument_list|(
operator|(
operator|*
name|SP
operator|)
argument_list|)
expr_stmt|;
name|SP
operator|--
expr_stmt|;
block|}
name|MARK
operator|++
expr_stmt|;
name|repeatcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|MARK
operator|+
name|items
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MARK
argument_list|,
name|items
operator|*
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|SP
operator|-=
name|items
expr_stmt|;
block|}
else|else
block|{
comment|/* Note: mark already snarfed by pp_list */
name|SV
modifier|*
name|tmpstr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|tmpstr
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|TARG
operator|==
name|tmpstr
operator|&&
name|SvTHINKFIRST
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|tmpstr
argument_list|)
operator|&&
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|DIE
argument_list|(
literal|"Can't x= to readonly value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|tmpstr
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|SvSetSV
argument_list|(
name|TARG
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|1
condition|)
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|count
operator|*
name|len
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|SvPVX
argument_list|(
name|TARG
argument_list|)
operator|+
name|len
argument_list|,
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|,
name|len
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|TARG
argument_list|)
operator|*=
name|count
expr_stmt|;
block|}
operator|*
name|SvEND
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|PUSHTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_subtract
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|subtr
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl_ul
expr_stmt|;
name|SETn
argument_list|(
name|left
operator|-
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_left_shift
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|lshift
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|IBW
name|shift
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|i
init|=
name|TOPi
decl_stmt|;
name|i
operator|=
name|BWi
argument_list|(
name|i
argument_list|)
operator|<<
name|shift
expr_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|u
init|=
name|TOPu
decl_stmt|;
name|u
operator|<<=
name|shift
expr_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_right_shift
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|rshift
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|IBW
name|shift
init|=
name|POPi
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|i
init|=
name|TOPi
decl_stmt|;
name|i
operator|=
name|BWi
argument_list|(
name|i
argument_list|)
operator|>>
name|shift
expr_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|u
init|=
name|TOPu
decl_stmt|;
name|u
operator|>>=
name|shift
expr_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|lt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|<
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_gt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|>
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_le
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|le
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|<=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ge
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|>=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ne
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPnv
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|TOPn
operator|!=
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ncmp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|ncmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|I32
name|value
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|right
condition|)
name|value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|<
name|right
condition|)
name|value
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|>
name|right
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SETs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|SETi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_slt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|slt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sgt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sgt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sle
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|<=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sge
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|cmp
operator|>=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_seq
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|sv_eq
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sne
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|sne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
operator|!
name|sv_eq
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scmp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|scmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
name|int
name|cmp
init|=
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
name|sv_cmp_locale
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
else|:
name|sv_cmp
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|)
decl_stmt|;
name|SETi
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_and
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|band
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|value
init|=
name|SvIV
argument_list|(
name|left
argument_list|)
operator|&
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|value
init|=
name|SvUV
argument_list|(
name|left
argument_list|)
operator|&
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_xor
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|bxor
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|value
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvIV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator|^
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|value
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvUV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator|^
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_bit_or
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|bor
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|value
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvIV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator||
name|SvIV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|value
init|=
operator|(
name|USE_LEFT
argument_list|(
name|left
argument_list|)
condition|?
name|SvUV
argument_list|(
name|left
argument_list|)
else|:
literal|0
operator|)
operator||
name|SvUV
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vop
argument_list|(
name|PL_op
operator|->
name|op_type
argument_list|,
name|TARG
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_negate
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|neg
argument_list|)
expr_stmt|;
block|{
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
name|IV_MIN
condition|)
name|SETi
argument_list|(
operator|-
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
condition|)
name|SETn
argument_list|(
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
operator|*
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|?
literal|'+'
else|:
literal|'-'
expr_stmt|;
block|}
else|else
name|sv_setnv
argument_list|(
name|TARG
argument_list|,
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
else|else
name|SETn
argument_list|(
operator|-
name|SvNV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_not
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
name|djSP
expr_stmt|;
name|tryAMAGICunSET
argument_list|(
name|not
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OVERLOAD */
operator|*
name|PL_stack_sp
operator|=
name|boolSV
argument_list|(
operator|!
name|SvTRUE
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_complement
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|compl
argument_list|)
expr_stmt|;
block|{
name|dTOPss
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|HINT_INTEGER
condition|)
block|{
name|IBW
name|value
init|=
operator|~
name|SvIV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SETi
argument_list|(
name|BWi
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UBW
name|value
init|=
operator|~
name|SvUV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SETu
argument_list|(
name|BWu
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
specifier|register
name|long
modifier|*
name|tmpl
decl_stmt|;
specifier|register
name|I32
name|anum
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|SvSetSV
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|anum
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBERAL
for|for
control|(
init|;
name|anum
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|tmps
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|anum
operator|--
operator|,
name|tmps
operator|++
control|)
operator|*
name|tmps
operator|=
operator|~
operator|*
name|tmps
expr_stmt|;
name|tmpl
operator|=
operator|(
name|long
operator|*
operator|)
name|tmps
expr_stmt|;
for|for
control|(
init|;
name|anum
operator|>=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|anum
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|,
name|tmpl
operator|++
control|)
operator|*
name|tmpl
operator|=
operator|~
operator|*
name|tmpl
expr_stmt|;
name|tmps
operator|=
operator|(
name|char
operator|*
operator|)
name|tmpl
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|anum
operator|>
literal|0
condition|;
name|anum
operator|--
operator|,
name|tmps
operator|++
control|)
operator|*
name|tmps
operator|=
operator|~
operator|*
name|tmps
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* integer versions of some of the above */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_i_multiply
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|mult
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|*
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_divide
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|div
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPiv
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|DIE
argument_list|(
literal|"Illegal division by zero"
argument_list|)
expr_stmt|;
name|value
operator|=
name|POPi
operator|/
name|value
expr_stmt|;
name|PUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_modulo
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|modulo
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
if|if
condition|(
operator|!
name|right
condition|)
name|DIE
argument_list|(
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|%
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_add
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|add
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|+
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_subtract
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dATARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|subtr
argument_list|,
name|opASSIGN
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETi
argument_list|(
name|left
operator|-
name|right
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_lt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|lt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|<
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_gt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|gt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|>
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_le
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|le
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|<=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ge
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|>=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_eq
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|==
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ne
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|tryAMAGICbinSET
argument_list|(
name|ne
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|SETs
argument_list|(
name|boolSV
argument_list|(
name|left
operator|!=
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_ncmp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|ncmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPiirl
expr_stmt|;
name|I32
name|value
decl_stmt|;
if|if
condition|(
name|left
operator|>
name|right
condition|)
name|value
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|<
name|right
condition|)
name|value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|SETi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_i_negate
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|neg
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
operator|-
name|TOPi
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* High falutin' math. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_atan2
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICbin
argument_list|(
name|atan2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|dPOPTOPnnrl
expr_stmt|;
name|SETn
argument_list|(
name|atan2
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sin
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|sin
argument_list|)
expr_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|sin
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_cos
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|cos
argument_list|)
expr_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|cos
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Support Configure command-line overrides for rand() functions.    After 5.005, perhaps we should replace this by Configure support    for drand48(), random(), or rand().  For 5.005, though, maintain    compatibility by calling rand() but allow the user to override it.    See INSTALL for details.  --Andy Dougherty  15 July 1998 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|my_rand
end_ifndef

begin_define
define|#
directive|define
name|my_rand
value|rand
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|my_srand
end_ifndef

begin_define
define|#
directive|define
name|my_srand
value|srand
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_rand
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
else|else
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
operator|!
name|srand_called
condition|)
block|{
operator|(
name|void
operator|)
name|my_srand
argument_list|(
operator|(
name|unsigned
operator|)
name|seed
argument_list|()
argument_list|)
expr_stmt|;
name|srand_called
operator|=
name|TRUE
expr_stmt|;
block|}
if|#
directive|if
name|RANDBITS
operator|==
literal|31
name|value
operator|=
name|my_rand
argument_list|()
operator|*
name|value
operator|/
literal|2147483648.0
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|RANDBITS
operator|==
literal|16
name|value
operator|=
name|my_rand
argument_list|()
operator|*
name|value
operator|/
literal|65536.0
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|RANDBITS
operator|==
literal|15
name|value
operator|=
name|my_rand
argument_list|()
operator|*
name|value
operator|/
literal|32768.0
expr_stmt|;
else|#
directive|else
name|value
operator|=
name|my_rand
argument_list|()
operator|*
name|value
operator|/
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
name|RANDBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_srand
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|UV
name|anum
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|anum
operator|=
name|seed
argument_list|()
expr_stmt|;
else|else
name|anum
operator|=
name|POPu
expr_stmt|;
operator|(
name|void
operator|)
name|my_srand
argument_list|(
operator|(
name|unsigned
operator|)
name|anum
argument_list|)
expr_stmt|;
name|srand_called
operator|=
name|TRUE
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|U32
name|seed
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * This is really just a quick hack which grabs various garbage      * values.  It really should be a real hash algorithm which      * spreads the effect of every input bit onto every output bit,      * if someone who knows about such tings would bother to write it.      * Might be a good idea to add that function to CORE as well.      * No numbers below come from careful analysis or anyting here,      * except they are primes and SEED_C1> 1E6 to get a full-width      * value from (tv_sec * SEED_C1 + tv_usec).  The multipliers should      * probably be bigger too.      */
if|#
directive|if
name|RANDBITS
operator|>
literal|16
define|#
directive|define
name|SEED_C1
value|1000003
define|#
directive|define
name|SEED_C4
value|73819
else|#
directive|else
define|#
directive|define
name|SEED_C1
value|25747
define|#
directive|define
name|SEED_C4
value|20639
endif|#
directive|endif
define|#
directive|define
name|SEED_C2
value|3
define|#
directive|define
name|SEED_C3
value|269
define|#
directive|define
name|SEED_C5
value|26107
name|dTHR
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_NO_DEV_RANDOM
name|int
name|fd
decl_stmt|;
endif|#
directive|endif
name|U32
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
include|#
directive|include
file|<starlet.h>
comment|/* when[] = (low 32 bits, high 32 bits) of time since epoch      * in 100-ns units, typically incremented ever 10 ms.        */
name|unsigned
name|int
name|when
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_GETTIMEOFDAY
name|struct
name|timeval
name|when
decl_stmt|;
else|#
directive|else
name|Time_t
name|when
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* This test is an escape hatch, this symbol isn't set by Configure. */
ifndef|#
directive|ifndef
name|PERL_NO_DEV_RANDOM
ifndef|#
directive|ifndef
name|PERL_RANDOM_DEVICE
comment|/* /dev/random isn't used by default because reads from it will block     * if there isn't enough entropy available.  You can compile with     * PERL_RANDOM_DEVICE to it if you'd prefer Perl to block until there     * is enough real entropy to fill the seed. */
define|#
directive|define
name|PERL_RANDOM_DEVICE
value|"/dev/urandom"
endif|#
directive|endif
name|fd
operator|=
name|PerlLIO_open
argument_list|(
name|PERL_RANDOM_DEVICE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|PerlLIO_read
argument_list|(
name|fd
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|!=
sizeof|sizeof
name|u
condition|)
name|u
operator|=
literal|0
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
return|return
name|u
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
name|_ckvmssts
argument_list|(
name|sys$gettim
argument_list|(
name|when
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
index|[
literal|0
index|]
operator|+
operator|(
name|U32
operator|)
name|SEED_C2
operator|*
name|when
index|[
literal|1
index|]
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_GETTIMEOFDAY
name|gettimeofday
argument_list|(
operator|&
name|when
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
operator|.
name|tv_sec
operator|+
operator|(
name|U32
operator|)
name|SEED_C2
operator|*
name|when
operator|.
name|tv_usec
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|U32
operator|)
name|SEED_C1
operator|*
name|when
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|u
operator|+=
name|SEED_C3
operator|*
operator|(
name|U32
operator|)
name|getpid
argument_list|()
expr_stmt|;
name|u
operator|+=
name|SEED_C4
operator|*
operator|(
name|U32
operator|)
operator|(
name|UV
operator|)
name|PL_stack_sp
expr_stmt|;
ifndef|#
directive|ifndef
name|PLAN9
comment|/* XXX Plan9 assembler chokes on this; fix needed  */
name|u
operator|+=
name|SEED_C5
operator|*
call|(
name|U32
call|)
argument_list|(
name|UV
argument_list|)
operator|&
name|when
expr_stmt|;
endif|#
directive|endif
return|return
name|u
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_exp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
name|value
operator|=
name|exp
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_log
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0.0
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|DIE
argument_list|(
literal|"Can't take log of %g"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|log
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sqrt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|sqrt
argument_list|)
expr_stmt|;
block|{
name|double
name|value
decl_stmt|;
name|value
operator|=
name|POPn
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|DIE
argument_list|(
literal|"Can't take sqrt of %g"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|sqrt
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|XPUSHn
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_int
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
block|{
name|double
name|value
init|=
name|TOPn
decl_stmt|;
name|IV
name|iv
decl_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
name|iv
operator|=
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
operator|(
name|void
operator|)
name|modf
argument_list|(
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|modf
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
name|iv
operator|=
name|I_V
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|==
name|value
condition|)
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
else|else
name|SETn
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_abs
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|tryAMAGICun
argument_list|(
name|abs
argument_list|)
expr_stmt|;
block|{
name|double
name|value
init|=
name|TOPn
decl_stmt|;
name|IV
name|iv
decl_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvNOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|TOPs
argument_list|)
operator|&&
operator|(
name|iv
operator|=
name|SvIVX
argument_list|(
name|TOPs
argument_list|)
operator|)
operator|!=
name|IV_MIN
condition|)
block|{
if|if
condition|(
name|iv
operator|<
literal|0
condition|)
name|iv
operator|=
operator|-
name|iv
expr_stmt|;
name|SETi
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|SETn
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_hex
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|I32
name|argtype
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|XPUSHu
argument_list|(
name|scan_hex
argument_list|(
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_oct
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|UV
name|value
decl_stmt|;
name|I32
name|argtype
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|tmps
operator|=
name|POPpx
expr_stmt|;
while|while
condition|(
operator|*
name|tmps
operator|&&
name|isSPACE
argument_list|(
operator|*
name|tmps
argument_list|)
condition|)
name|tmps
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'0'
condition|)
name|tmps
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'x'
condition|)
name|value
operator|=
name|scan_hex
argument_list|(
operator|++
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|scan_oct
argument_list|(
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
name|XPUSHu
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* String stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_length
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SETi
argument_list|(
name|sv_len
argument_list|(
name|TOPs
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_substr
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|STRLEN
name|curlen
decl_stmt|;
name|I32
name|pos
decl_stmt|;
name|I32
name|rem
decl_stmt|;
name|I32
name|fail
decl_stmt|;
name|I32
name|lvalue
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|char
modifier|*
name|repl
init|=
literal|0
decl_stmt|;
name|STRLEN
name|repl_len
decl_stmt|;
name|SvTAINTED_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
if|if
condition|(
name|MAXARG
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|MAXARG
operator|>
literal|3
condition|)
block|{
name|sv
operator|=
name|POPs
expr_stmt|;
name|repl
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|repl_len
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|POPi
expr_stmt|;
block|}
name|pos
operator|=
name|POPi
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|arybase
condition|)
block|{
name|pos
operator|-=
name|arybase
expr_stmt|;
name|rem
operator|=
name|curlen
operator|-
name|pos
expr_stmt|;
name|fail
operator|=
name|rem
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|rem
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|<
literal|0
condition|)
name|rem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rem
operator|>
name|len
condition|)
name|rem
operator|=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|pos
operator|+=
name|curlen
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|3
condition|)
name|rem
operator|=
name|curlen
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|rem
operator|=
name|pos
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|>
operator|(
name|I32
operator|)
name|curlen
condition|)
name|rem
operator|=
name|curlen
expr_stmt|;
block|}
else|else
block|{
name|rem
operator|=
name|curlen
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|<
name|pos
condition|)
name|rem
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|fail
operator|=
name|rem
expr_stmt|;
name|rem
operator|-=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|fail
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|||
name|lvalue
operator|||
name|repl
condition|)
name|warn
argument_list|(
literal|"substr outside of string"
argument_list|)
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
else|else
block|{
name|tmps
operator|+=
name|pos
expr_stmt|;
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
name|tmps
argument_list|,
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalue
condition|)
block|{
comment|/* it's an lvalue! */
if|if
condition|(
operator|!
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Attempt to use reference as lvalue in substr"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* is it defined ? */
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* avoid lexical reincarnation */
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'x'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|sv
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|LvTARGOFF
argument_list|(
name|TARG
argument_list|)
operator|=
name|pos
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|TARG
argument_list|)
operator|=
name|rem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repl
condition|)
name|sv_insert
argument_list|(
name|sv
argument_list|,
name|pos
argument_list|,
name|rem
argument_list|,
name|repl
argument_list|,
name|repl_len
argument_list|)
expr_stmt|;
block|}
name|SPAGAIN
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* avoid SvSETMAGIC here */
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_vec
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|I32
name|size
init|=
name|POPi
decl_stmt|;
specifier|register
name|I32
name|offset
init|=
name|POPi
decl_stmt|;
specifier|register
name|SV
modifier|*
name|src
init|=
name|POPs
decl_stmt|;
name|I32
name|lvalue
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|STRLEN
name|srclen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|SvPV
argument_list|(
name|src
argument_list|,
name|srclen
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|retnum
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|SvTAINTED_off
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
comment|/* decontaminate */
name|offset
operator|*=
name|size
expr_stmt|;
comment|/* turn into bit offset */
name|len
operator|=
operator|(
name|offset
operator|+
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|size
operator|<
literal|1
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lvalue
condition|)
block|{
comment|/* it's an lvalue! */
if|if
condition|(
name|SvTYPE
argument_list|(
name|TARG
argument_list|)
operator|<
name|SVt_PVLV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|TARG
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|TARG
argument_list|,
name|Nullsv
argument_list|,
literal|'v'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LvTYPE
argument_list|(
name|TARG
argument_list|)
operator|=
literal|'v'
expr_stmt|;
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|!=
name|src
condition|)
block|{
if|if
condition|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|LvTARG
argument_list|(
name|TARG
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|LvTARGOFF
argument_list|(
name|TARG
argument_list|)
operator|=
name|offset
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|TARG
argument_list|)
operator|=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|srclen
condition|)
block|{
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|offset
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|offset
operator|>=
name|srclen
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
else|else
name|retnum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|32
condition|)
block|{
if|if
condition|(
name|offset
operator|>=
name|srclen
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|+
literal|1
operator|>=
name|srclen
condition|)
name|retnum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|+
literal|2
operator|>=
name|srclen
condition|)
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
else|else
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|s
index|[
name|offset
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|<
literal|8
condition|)
name|retnum
operator|=
operator|(
name|s
index|[
name|offset
operator|>>
literal|3
index|]
operator|>>
operator|(
name|offset
operator|&
literal|7
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
name|offset
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|retnum
operator|=
name|s
index|[
name|offset
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|16
condition|)
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|8
operator|)
operator|+
name|s
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|32
condition|)
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|s
index|[
name|offset
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|s
index|[
name|offset
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
name|sv_setuv
argument_list|(
name|TARG
argument_list|,
operator|(
name|UV
operator|)
name|retnum
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_index
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|big
decl_stmt|;
name|SV
modifier|*
name|little
decl_stmt|;
name|I32
name|offset
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|tmps2
decl_stmt|;
name|STRLEN
name|biglen
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|3
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
name|POPi
operator|-
name|arybase
expr_stmt|;
name|little
operator|=
name|POPs
expr_stmt|;
name|big
operator|=
name|POPs
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|big
argument_list|,
name|biglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
name|biglen
condition|)
name|offset
operator|=
name|biglen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|offset
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|biglen
argument_list|,
name|little
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|retval
operator|=
operator|-
literal|1
operator|+
name|arybase
expr_stmt|;
else|else
name|retval
operator|=
name|tmps2
operator|-
name|tmps
operator|+
name|arybase
expr_stmt|;
name|PUSHi
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_rindex
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|big
decl_stmt|;
name|SV
modifier|*
name|little
decl_stmt|;
name|STRLEN
name|blen
decl_stmt|;
name|STRLEN
name|llen
decl_stmt|;
name|SV
modifier|*
name|offstr
decl_stmt|;
name|I32
name|offset
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|tmps2
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|>=
literal|3
condition|)
name|offstr
operator|=
name|POPs
expr_stmt|;
name|little
operator|=
name|POPs
expr_stmt|;
name|big
operator|=
name|POPs
expr_stmt|;
name|tmps2
operator|=
name|SvPV
argument_list|(
name|little
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPV
argument_list|(
name|big
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|3
condition|)
name|offset
operator|=
name|blen
expr_stmt|;
else|else
name|offset
operator|=
name|SvIV
argument_list|(
name|offstr
argument_list|)
operator|-
name|arybase
operator|+
name|llen
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
name|blen
condition|)
name|offset
operator|=
name|blen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|rninstr
argument_list|(
name|tmps
argument_list|,
name|tmps
operator|+
name|offset
argument_list|,
name|tmps2
argument_list|,
name|tmps2
operator|+
name|llen
argument_list|)
operator|)
condition|)
name|retval
operator|=
operator|-
literal|1
operator|+
name|arybase
expr_stmt|;
else|else
name|retval
operator|=
name|tmps2
operator|-
name|tmps
operator|+
name|arybase
expr_stmt|;
name|PUSHi
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sprintf
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
name|SET_NUMERIC_LOCAL
argument_list|()
expr_stmt|;
else|else
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|do_sprintf
argument_list|(
name|TARG
argument_list|,
name|SP
operator|-
name|MARK
argument_list|,
name|MARK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|SvTAINTED
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHTARG
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ord
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|I32
name|value
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
ifndef|#
directive|ifndef
name|I286
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|value
operator|=
call|(
name|I32
call|)
argument_list|(
operator|*
name|tmps
operator|&
literal|255
argument_list|)
expr_stmt|;
else|#
directive|else
name|I32
name|anum
decl_stmt|;
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|anum
operator|=
operator|(
name|I32
operator|)
operator|*
name|tmps
expr_stmt|;
name|value
operator|=
call|(
name|I32
call|)
argument_list|(
name|anum
operator|&
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XPUSHi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_chr
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|TARG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
operator|*
name|tmps
operator|++
operator|=
name|POPi
expr_stmt|;
operator|*
name|tmps
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_crypt
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|dPOPTOPssrl
expr_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_CRYPT
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|left
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FCRYPT
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|fcrypt
argument_list|(
name|tmps
argument_list|,
name|SvPV
argument_list|(
name|right
argument_list|,
name|n_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|PerlProc_crypt
argument_list|(
name|tmps
argument_list|,
name|SvPV
argument_list|(
name|right
argument_list|,
name|n_a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|DIE
argument_list|(
literal|"The crypt() function is unimplemented due to excessive paranoia."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_ucfirst
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|toUPPER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|=
name|toUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lcfirst
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|toLOWER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|=
name|toLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_uc
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toUPPER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lc
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|SvPADTMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTARGET
expr_stmt|;
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|TARG
expr_stmt|;
name|SETs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
block|{
name|TAINT
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toLOWER_LC
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|toLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_set
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_quotemeta
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|TOPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|TARG
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|TARG
argument_list|,
operator|(
name|len
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|TARG
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|TARG
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setpvn
argument_list|(
name|TARG
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|TARG
argument_list|)
condition|)
name|mg_set
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Arrays. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_aslice
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
specifier|register
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|I32
name|lval
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|I32
name|elem
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|av
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|lval
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
block|{
name|I32
name|max
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|svp
operator|=
name|MARK
operator|+
literal|1
init|;
name|svp
operator|<=
name|SP
condition|;
name|svp
operator|++
control|)
block|{
name|elem
operator|=
name|SvIVx
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|>
name|max
condition|)
name|max
operator|=
name|elem
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|>
name|AvMAX
argument_list|(
name|av
argument_list|)
condition|)
name|av_extend
argument_list|(
name|av
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|elem
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|>
literal|0
condition|)
name|elem
operator|-=
name|arybase
expr_stmt|;
name|svp
operator|=
name|av_fetch
argument_list|(
name|av
argument_list|,
name|elem
argument_list|,
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
block|{
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
name|DIE
argument_list|(
name|no_aelem
argument_list|,
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_aelem
argument_list|(
name|av
argument_list|,
name|elem
argument_list|,
name|svp
argument_list|)
expr_stmt|;
block|}
operator|*
name|MARK
operator|=
name|svp
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Associative arrays. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_each
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARGET
expr_stmt|;
name|HV
modifier|*
name|hash
init|=
operator|(
name|HV
operator|*
operator|)
name|POPs
decl_stmt|;
name|HE
modifier|*
name|entry
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|realhv
init|=
operator|(
name|SvTYPE
argument_list|(
name|hash
argument_list|)
operator|==
name|SVt_PVHV
operator|)
decl_stmt|;
name|PUTBACK
expr_stmt|;
comment|/* might clobber stack_sp */
name|entry
operator|=
name|realhv
condition|?
name|hv_iternext
argument_list|(
name|hash
argument_list|)
else|:
name|avhv_iternext
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hash
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|PUSHs
argument_list|(
name|hv_iterkeysv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* won't clobber stack_sp */
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|PUTBACK
expr_stmt|;
comment|/* might clobber stack_sp */
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
name|realhv
condition|?
name|hv_iterval
argument_list|(
name|hash
argument_list|,
name|entry
argument_list|)
else|:
name|avhv_iterval
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hash
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_values
argument_list|)
end_macro

begin_block
block|{
return|return
name|do_kv
argument_list|(
name|ARGS
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_keys
argument_list|)
end_macro

begin_block
block|{
return|return
name|do_kv
argument_list|(
name|ARGS
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_delete
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|discard
init|=
operator|(
name|gimme
operator|==
name|G_VOID
operator|)
condition|?
name|G_DISCARD
else|:
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpSLICE
condition|)
block|{
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|U32
name|hvtype
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
name|hvtype
operator|=
name|SvTYPE
argument_list|(
name|hv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|hvtype
operator|==
name|SVt_PVHV
condition|)
name|sv
operator|=
name|hv_delete_ent
argument_list|(
name|hv
argument_list|,
operator|*
name|MARK
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|DIE
argument_list|(
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
name|sv
condition|?
name|sv
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
if|if
condition|(
name|discard
condition|)
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|keysv
init|=
name|POPs
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|POPs
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
condition|)
name|sv
operator|=
name|hv_delete_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|DIE
argument_list|(
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|sv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
operator|!
name|discard
condition|)
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_exists
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|tmpsv
init|=
name|POPs
decl_stmt|;
name|HV
modifier|*
name|hv
init|=
operator|(
name|HV
operator|*
operator|)
name|POPs
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
condition|)
block|{
if|if
condition|(
name|hv_exists_ent
argument_list|(
name|hv
argument_list|,
name|tmpsv
argument_list|,
literal|0
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
if|if
condition|(
name|avhv_exists_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|tmpsv
argument_list|,
literal|0
argument_list|)
condition|)
name|RETPUSHYES
expr_stmt|;
block|}
else|else
block|{
name|DIE
argument_list|(
literal|"Not a HASH reference"
argument_list|)
expr_stmt|;
block|}
name|RETPUSHNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_hslice
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|HV
modifier|*
name|hv
init|=
operator|(
name|HV
operator|*
operator|)
name|POPs
decl_stmt|;
specifier|register
name|I32
name|lval
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|I32
name|realhv
init|=
operator|(
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVHV
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|realhv
operator|&&
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|DIE
argument_list|(
literal|"Can't localize pseudo-hash element"
argument_list|)
expr_stmt|;
if|if
condition|(
name|realhv
operator|||
name|SvTYPE
argument_list|(
name|hv
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
name|SV
modifier|*
name|keysv
init|=
operator|*
name|MARK
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
if|if
condition|(
name|realhv
condition|)
block|{
name|HE
modifier|*
name|he
init|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|lval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|svp
operator|=
name|he
condition|?
operator|&
name|HeVAL
argument_list|(
name|he
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|svp
operator|=
name|avhv_fetch_ent
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|hv
argument_list|,
name|keysv
argument_list|,
name|lval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lval
condition|)
block|{
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|DIE
argument_list|(
name|no_helem
argument_list|,
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|save_helem
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|svp
argument_list|)
expr_stmt|;
block|}
operator|*
name|MARK
operator|=
name|svp
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|MARK
operator|=
name|ORIGMARK
expr_stmt|;
operator|*
operator|++
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* List operators. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_list
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
operator|*
name|MARK
operator|=
operator|*
name|SP
expr_stmt|;
comment|/* unwanted list, return last item */
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lslice
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
modifier|*
name|lastrelem
init|=
name|PL_stack_sp
decl_stmt|;
name|SV
modifier|*
modifier|*
name|lastlelem
init|=
name|PL_stack_base
operator|+
name|POPMARK
decl_stmt|;
name|SV
modifier|*
modifier|*
name|firstlelem
init|=
name|PL_stack_base
operator|+
name|POPMARK
operator|+
literal|1
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|firstrelem
init|=
name|lastlelem
operator|+
literal|1
decl_stmt|;
name|I32
name|arybase
init|=
name|PL_curcop
operator|->
name|cop_arybase
decl_stmt|;
name|I32
name|lval
init|=
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_MOD
decl_stmt|;
name|I32
name|is_something_there
init|=
name|lval
decl_stmt|;
specifier|register
name|I32
name|max
init|=
name|lastrelem
operator|-
name|lastlelem
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|lelem
decl_stmt|;
specifier|register
name|I32
name|ix
decl_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|ix
operator|=
name|SvIVx
argument_list|(
operator|*
name|lastlelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
name|ix
operator|+=
name|max
expr_stmt|;
else|else
name|ix
operator|-=
name|arybase
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
operator|||
name|ix
operator|>=
name|max
condition|)
operator|*
name|firstlelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
else|else
operator|*
name|firstlelem
operator|=
name|firstrelem
index|[
name|ix
index|]
expr_stmt|;
name|SP
operator|=
name|firstlelem
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
name|SP
operator|=
name|firstlelem
operator|-
literal|1
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
for|for
control|(
name|lelem
operator|=
name|firstlelem
init|;
name|lelem
operator|<=
name|lastlelem
condition|;
name|lelem
operator|++
control|)
block|{
name|ix
operator|=
name|SvIVx
argument_list|(
operator|*
name|lelem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
block|{
name|ix
operator|+=
name|max
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
operator|*
name|lelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|*
name|lelem
operator|=
name|firstrelem
index|[
name|ix
index|]
operator|)
condition|)
operator|*
name|lelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
else|else
block|{
name|ix
operator|-=
name|arybase
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|max
operator|||
operator|!
operator|(
operator|*
name|lelem
operator|=
name|firstrelem
index|[
name|ix
index|]
operator|)
condition|)
operator|*
name|lelem
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_something_there
operator|&&
operator|(
name|SvOK
argument_list|(
operator|*
name|lelem
argument_list|)
operator|||
name|SvGMAGICAL
argument_list|(
operator|*
name|lelem
argument_list|)
operator|)
condition|)
name|is_something_there
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|is_something_there
condition|)
name|SP
operator|=
name|lastlelem
expr_stmt|;
else|else
name|SP
operator|=
name|firstlelem
operator|-
literal|1
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anonlist
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|I32
name|items
init|=
name|SP
operator|-
name|MARK
decl_stmt|;
name|SV
modifier|*
name|av
init|=
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av_make
argument_list|(
name|items
argument_list|,
name|MARK
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
comment|/* av_make() might realloc stack_sp */
name|XPUSHs
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_anonhash
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|HV
modifier|*
name|hv
init|=
operator|(
name|HV
operator|*
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|SV
modifier|*
name|key
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
name|SV
modifier|*
name|val
init|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
name|sv_setsv
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Odd number of elements in hash assignment"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_splice
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|src
decl_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|dst
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|offset
decl_stmt|;
specifier|register
name|I32
name|length
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
name|I32
name|after
decl_stmt|;
name|I32
name|diff
decl_stmt|;
name|SV
modifier|*
modifier|*
name|tmparyval
init|=
literal|0
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|perl_call_method
argument_list|(
literal|"SPLICE"
argument_list|,
name|GIMME_V
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|SP
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|MARK
operator|<
name|SP
condition|)
block|{
name|offset
operator|=
name|i
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|offset
operator|-=
name|PL_curcop
operator|->
name|cop_arybase
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|no_aelem
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|MARK
operator|<
name|SP
condition|)
block|{
name|length
operator|=
name|SvIVx
argument_list|(
operator|*
name|MARK
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|length
operator|+=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|-
name|offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|length
operator|=
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* close enough to infinity */
block|}
else|else
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
condition|)
name|offset
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
expr_stmt|;
name|after
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
operator|-
operator|(
name|offset
operator|+
name|length
operator|)
expr_stmt|;
if|if
condition|(
name|after
operator|<
literal|0
condition|)
block|{
comment|/* not that much array */
name|length
operator|+=
name|after
expr_stmt|;
comment|/* offset+length now in array */
name|after
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|AvALLOC
argument_list|(
name|ary
argument_list|)
condition|)
name|av_extend
argument_list|(
name|ary
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, MARK .. SP-1 is our new LIST */
name|newlen
operator|=
name|SP
operator|-
name|MARK
expr_stmt|;
name|diff
operator|=
name|newlen
operator|-
name|length
expr_stmt|;
if|if
condition|(
name|newlen
operator|&&
operator|!
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
if|if
condition|(
name|AvREIFY
argument_list|(
name|ary
argument_list|)
condition|)
name|av_reify
argument_list|(
name|ary
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
argument_list|)
expr_stmt|;
comment|/* would leak, so croak */
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
comment|/* shrinking the area */
if|if
condition|(
name|newlen
condition|)
block|{
name|New
argument_list|(
literal|451
argument_list|,
name|tmparyval
argument_list|,
name|newlen
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
comment|/* so remember insertion */
name|Copy
argument_list|(
name|MARK
argument_list|,
name|tmparyval
argument_list|,
name|newlen
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|=
name|ORIGMARK
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* copy return vals to stack */
name|MEXTEND
argument_list|(
name|MARK
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
argument_list|,
name|MARK
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|EXTEND_MORTAL
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|,
name|dst
operator|=
name|MARK
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
comment|/* free them eventualy */
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|MARK
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|MARK
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
operator|+
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|-
literal|1
operator|,
name|dst
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|SvREFCNT_dec
argument_list|(
operator|*
name|dst
operator|++
argument_list|)
expr_stmt|;
comment|/* free them now */
block|}
block|}
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
comment|/* pull up or down? */
if|if
condition|(
name|offset
operator|<
name|after
condition|)
block|{
comment|/* easier to pull up */
if|if
condition|(
name|offset
condition|)
block|{
comment|/* esp. if nothing to pull */
name|src
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|offset
operator|-
literal|1
index|]
expr_stmt|;
name|dst
operator|=
name|src
operator|-
name|diff
expr_stmt|;
comment|/* diff is negative */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
comment|/* can't trust Copy */
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|ary
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|diff
operator|)
expr_stmt|;
comment|/* diff is negative */
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|after
condition|)
block|{
comment|/* anything to pull down? */
name|src
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
operator|+
name|length
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|diff
expr_stmt|;
comment|/* diff is negative */
name|Move
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|after
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
operator|&
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
comment|/* avoid later double free */
block|}
name|i
operator|=
operator|-
name|diff
expr_stmt|;
while|while
condition|(
name|i
condition|)
name|dst
index|[
operator|--
name|i
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
if|if
condition|(
name|newlen
condition|)
block|{
for|for
control|(
name|src
operator|=
name|tmparyval
operator|,
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
init|;
name|newlen
condition|;
name|newlen
operator|--
control|)
block|{
operator|*
name|dst
operator|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
operator|*
name|dst
operator|++
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no, expanding (or same) */
if|if
condition|(
name|length
condition|)
block|{
name|New
argument_list|(
literal|452
argument_list|,
name|tmparyval
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
comment|/* so remember deletion */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
argument_list|,
name|tmparyval
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
comment|/* expanding */
comment|/* push up or down? */
if|if
condition|(
name|offset
operator|<
name|after
operator|&&
name|diff
operator|<=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|ary
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
condition|)
block|{
name|src
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|dst
operator|=
name|src
operator|-
name|diff
expr_stmt|;
name|Move
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|offset
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|SvPVX
argument_list|(
name|ary
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|diff
operator|)
expr_stmt|;
comment|/* diff is positive */
name|AvMAX
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|diff
operator|>=
name|AvMAX
argument_list|(
name|ary
argument_list|)
condition|)
comment|/* oh, well */
name|av_extend
argument_list|(
name|ary
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|diff
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|AvFILLp
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|-
name|diff
expr_stmt|;
for|for
control|(
name|i
operator|=
name|after
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|src
operator|=
name|MARK
operator|,
name|dst
operator|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|+
name|offset
init|;
name|newlen
condition|;
name|newlen
operator|--
control|)
block|{
operator|*
name|dst
operator|=
name|NEWSV
argument_list|(
literal|46
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
operator|*
name|dst
operator|++
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|=
name|ORIGMARK
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* copy return vals to stack */
if|if
condition|(
name|length
condition|)
block|{
name|Copy
argument_list|(
name|tmparyval
argument_list|,
name|MARK
argument_list|,
name|length
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|EXTEND_MORTAL
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
operator|,
name|dst
operator|=
name|MARK
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
comment|/* free them eventualy */
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
name|MARK
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|MARK
operator|=
name|tmparyval
index|[
name|length
index|]
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|sv_2mortal
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
name|SvREFCNT_dec
argument_list|(
name|tmparyval
index|[
name|length
index|]
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|tmparyval
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_push
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
init|=
operator|&
name|PL_sv_undef
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|perl_call_method
argument_list|(
literal|"PUSH"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
else|else
block|{
comment|/* Why no pre-extend of ary here ? */
for|for
control|(
operator|++
name|MARK
init|;
name|MARK
operator|<=
name|SP
condition|;
name|MARK
operator|++
control|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|51
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|MARK
condition|)
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|ary
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|AvFILL
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_pop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|av_pop
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_shift
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|POPs
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|av_shift
argument_list|(
name|av
argument_list|)
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|RETPUSHUNDEF
expr_stmt|;
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_unshift
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|AV
modifier|*
name|ary
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|0
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
operator|*
name|MARK
operator|--
operator|=
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|MARK
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|perl_call_method
argument_list|(
literal|"UNSHIFT"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
else|else
block|{
name|av_unshift
argument_list|(
name|ary
argument_list|,
name|SP
operator|-
name|MARK
argument_list|)
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|27
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|*
operator|++
name|MARK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|av_store
argument_list|(
name|ary
argument_list|,
name|i
operator|++
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHi
argument_list|(
name|AvFILL
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_reverse
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
name|tmp
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldsp
init|=
name|SP
decl_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|MARK
operator|++
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
name|tmp
operator|=
operator|*
name|MARK
expr_stmt|;
operator|*
name|MARK
operator|++
operator|=
operator|*
name|SP
expr_stmt|;
operator|*
name|SP
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
name|SP
operator|=
name|oldsp
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|up
decl_stmt|;
specifier|register
name|char
modifier|*
name|down
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
name|dTARGET
expr_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SP
operator|-
name|MARK
operator|>
literal|1
condition|)
name|do_join
argument_list|(
name|TARG
argument_list|,
operator|&
name|PL_sv_no
argument_list|,
name|MARK
argument_list|,
name|SP
argument_list|)
expr_stmt|;
else|else
name|sv_setsv
argument_list|(
name|TARG
argument_list|,
operator|(
name|SP
operator|>
name|MARK
operator|)
condition|?
operator|*
name|SP
else|:
name|DEFSV
argument_list|)
expr_stmt|;
name|up
operator|=
name|SvPV_force
argument_list|(
name|TARG
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|down
operator|=
name|SvPVX
argument_list|(
name|TARG
argument_list|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|down
operator|>
name|up
condition|)
block|{
name|tmp
operator|=
operator|*
name|up
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|*
name|down
expr_stmt|;
operator|*
name|down
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
operator|+
literal|1
expr_stmt|;
name|SETTARG
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|SV
modifier|*
name|mul128
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|U8
name|m
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|U32
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0000"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* need to grow sv */
name|SV
modifier|*
name|tmpNew
init|=
name|newSVpv
argument_list|(
literal|"0000000000"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|sv_catsv
argument_list|(
name|tmpNew
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* free old sv */
name|sv
operator|=
name|tmpNew
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|s
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|*
name|t
condition|)
comment|/* trailing '\0'? */
name|t
operator|--
expr_stmt|;
while|while
condition|(
name|t
operator|>
name|s
condition|)
block|{
name|i
operator|=
operator|(
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
operator|<<
literal|7
operator|)
operator|+
name|m
expr_stmt|;
operator|*
operator|(
name|t
operator|--
operator|)
operator|=
literal|'0'
operator|+
operator|(
name|i
operator|%
literal|10
operator|)
expr_stmt|;
name|m
operator|=
name|i
operator|/
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|sv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Explosives and implosives. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|uuemap
index|[]
init|=
literal|"`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|uudmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialised on first use */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|'I'
operator|==
literal|73
operator|&&
literal|'J'
operator|==
literal|74
end_if

begin_comment
comment|/* On an ASCII/ISO kind of system */
end_comment

begin_define
define|#
directive|define
name|ISUUCHAR
parameter_list|(
name|ch
parameter_list|)
value|((ch)>= ' '&& (ch)< 'a')
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*   Some other sort of character set - use memchr() so we don't match   the null byte.  */
end_comment

begin_define
define|#
directive|define
name|ISUUCHAR
parameter_list|(
name|ch
parameter_list|)
value|(memchr(uuemap, (ch), sizeof(uuemap)-1) || (ch) == ' ')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_unpack
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dPOPPOPssrl
expr_stmt|;
name|SV
modifier|*
modifier|*
name|oldsp
init|=
name|SP
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|STRLEN
name|llen
decl_stmt|;
name|STRLEN
name|rlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
init|=
name|SvPV
argument_list|(
name|left
argument_list|,
name|llen
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strend
init|=
name|s
operator|+
name|rlen
decl_stmt|;
name|char
modifier|*
name|strbeg
init|=
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|patend
init|=
name|pat
operator|+
name|llen
decl_stmt|;
name|I32
name|datumtype
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
specifier|register
name|I32
name|bits
decl_stmt|;
comment|/* These must not be in registers: */
name|I16
name|ashort
decl_stmt|;
name|int
name|aint
decl_stmt|;
name|I32
name|along
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|Quad_t
name|aquad
decl_stmt|;
endif|#
directive|endif
name|U16
name|aushort
decl_stmt|;
name|unsigned
name|int
name|auint
decl_stmt|;
name|U32
name|aulong
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|unsigned
name|Quad_t
name|auquad
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|aptr
decl_stmt|;
name|float
name|afloat
decl_stmt|;
name|double
name|adouble
decl_stmt|;
name|I32
name|checksum
init|=
literal|0
decl_stmt|;
specifier|register
name|U32
name|culong
decl_stmt|;
name|double
name|cdouble
decl_stmt|;
ifndef|#
directive|ifndef
name|PERL_OBJECT
specifier|static
name|char
modifier|*
name|bitcount
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|commas
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
comment|/* arrange to do first one only */
comment|/*SUPPRESS 530*/
for|for
control|(
name|patend
operator|=
name|pat
init|;
operator|!
name|isALPHA
argument_list|(
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|patend
operator|==
literal|'x'
condition|;
name|patend
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"aAZbBhHP"
argument_list|,
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|pat
operator|==
literal|'%'
condition|)
block|{
name|patend
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|patend
argument_list|)
operator|||
operator|*
name|patend
operator|==
literal|'*'
condition|)
name|patend
operator|++
expr_stmt|;
block|}
else|else
name|patend
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|pat
operator|<
name|patend
condition|)
block|{
name|reparse
label|:
name|datumtype
operator|=
operator|*
name|pat
operator|++
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
name|datumtype
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pat
operator|>=
name|patend
condition|)
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|strend
operator|-
name|strbeg
expr_stmt|;
comment|/* long enough */
name|pat
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|*
name|pat
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|len
operator|=
operator|(
name|len
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|pat
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|len
operator|=
operator|(
name|datumtype
operator|!=
literal|'@'
operator|)
expr_stmt|;
switch|switch
condition|(
name|datumtype
condition|)
block|{
default|default:
name|croak
argument_list|(
literal|"Invalid type in unpack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
case|case
literal|','
case|:
comment|/* grandfather in commas but with a warning */
if|if
condition|(
name|commas
operator|++
operator|==
literal|0
operator|&&
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Invalid type in unpack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|pat
index|[
operator|-
literal|1
index|]
operator|!=
literal|'1'
condition|)
name|len
operator|=
literal|16
expr_stmt|;
name|checksum
operator|=
name|len
expr_stmt|;
name|culong
operator|=
literal|0
expr_stmt|;
name|cdouble
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pat
operator|<
name|patend
condition|)
goto|goto
name|reparse
goto|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|strbeg
condition|)
name|DIE
argument_list|(
literal|"@ outside of string"
argument_list|)
expr_stmt|;
name|s
operator|=
name|strbeg
operator|+
name|len
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|len
operator|>
name|s
operator|-
name|strbeg
condition|)
name|DIE
argument_list|(
literal|"X outside of string"
argument_list|)
expr_stmt|;
name|s
operator|-=
name|len
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|DIE
argument_list|(
literal|"x outside of string"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
goto|goto
name|uchar_checksum
goto|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'A'
operator|||
name|datumtype
operator|==
literal|'Z'
condition|)
block|{
name|aptr
operator|=
name|s
expr_stmt|;
comment|/* borrow register */
if|if
condition|(
name|datumtype
operator|==
literal|'Z'
condition|)
block|{
comment|/* 'Z' strips stuff after first null */
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 'A' strips both nulls and spaces */
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
operator|!
operator|*
name|s
operator|||
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
name|s
operator|--
expr_stmt|;
operator|*
operator|++
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|s
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|aptr
expr_stmt|;
comment|/* unborrow register */
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|||
name|len
operator|>
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|8
condition|)
name|len
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
if|if
condition|(
operator|!
name|bitcount
condition|)
block|{
name|Newz
argument_list|(
literal|601
argument_list|,
name|bitcount
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
for|for
control|(
name|bits
operator|=
literal|1
init|;
name|bits
operator|<
literal|256
condition|;
name|bits
operator|++
control|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|4
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|8
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|16
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|32
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|64
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|128
condition|)
name|bitcount
index|[
name|bits
index|]
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|culong
operator|+=
name|bitcount
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|++
index|]
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|bits
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'b'
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|culong
operator|++
expr_stmt|;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|128
condition|)
name|culong
operator|++
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|pat
expr_stmt|;
comment|/* borrow register */
name|pat
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'b'
condition|)
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|7
condition|)
comment|/*SUPPRESS 595*/
name|bits
operator|>>=
literal|1
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|pat
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|bits
operator|&
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|bits
operator|<<=
literal|1
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|pat
operator|++
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|bits
operator|&
literal|128
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|pat
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
comment|/* unborrow register */
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|||
name|len
operator|>
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|2
condition|)
name|len
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|2
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|35
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|pat
expr_stmt|;
comment|/* borrow register */
name|pat
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'h'
condition|)
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|bits
operator|>>=
literal|4
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|pat
operator|++
operator|=
name|PL_hexdigit
index|[
name|bits
operator|&
literal|15
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|aint
operator|=
name|len
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|aint
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|bits
operator|<<=
literal|4
expr_stmt|;
else|else
name|bits
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|pat
operator|++
operator|=
name|PL_hexdigit
index|[
operator|(
name|bits
operator|>>
literal|4
operator|)
operator|&
literal|15
index|]
expr_stmt|;
block|}
block|}
operator|*
name|pat
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
comment|/* unborrow register */
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|aint
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|aint
operator|>=
literal|128
condition|)
comment|/* fake up signed chars */
name|aint
operator|-=
literal|256
expr_stmt|;
name|culong
operator|+=
name|aint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|aint
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|aint
operator|>=
literal|128
condition|)
comment|/* fake up signed chars */
name|aint
operator|-=
literal|256
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|36
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|len
operator|>
name|strend
operator|-
name|s
condition|)
name|len
operator|=
name|strend
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
name|uchar_checksum
label|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|auint
operator|=
operator|*
name|s
operator|++
operator|&
literal|255
expr_stmt|;
name|culong
operator|+=
name|auint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|auint
operator|=
operator|*
name|s
operator|++
operator|&
literal|255
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|37
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|auint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE16
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|>
name|SIZE16
if|if
condition|(
name|ashort
operator|>
literal|32767
condition|)
name|ashort
operator|-=
literal|65536
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|culong
operator|+=
name|ashort
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHORTSIZE
operator|>
name|SIZE16
if|if
condition|(
name|ashort
operator|>
literal|32767
condition|)
name|ashort
operator|-=
literal|65536
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|38
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|ashort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'v'
case|:
case|case
literal|'n'
case|:
case|case
literal|'S'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE16
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE16
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'n'
condition|)
name|aushort
operator|=
name|PerlSock_ntohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'v'
condition|)
name|aushort
operator|=
name|vtohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|culong
operator|+=
name|aushort
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY16
argument_list|(
name|s
argument_list|,
operator|&
name|aushort
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE16
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|39
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'n'
condition|)
name|aushort
operator|=
name|PerlSock_ntohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHS
if|if
condition|(
name|datumtype
operator|==
literal|'v'
condition|)
name|aushort
operator|=
name|vtohs
argument_list|(
name|aushort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aushort
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'i'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aint
argument_list|,
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|double
operator|)
name|aint
expr_stmt|;
else|else
name|culong
operator|+=
name|aint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aint
argument_list|,
literal|1
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__osf__
comment|/* Without the dummy below unpack("i", pack("i",-1))                      * return 0xFFffFFff instead of -1 for Digital Unix V4.0                      * cc with optimization turned on */
operator|(
name|aint
operator|)
condition|?
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
else|:
endif|#
directive|endif
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'I'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
argument|s
argument_list|,
argument|&auint
argument_list|,
literal|1
argument_list|,
argument|unsigned int
argument_list|)
empty_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|double
operator|)
name|auint
expr_stmt|;
else|else
name|culong
operator|+=
name|auint
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
argument|s
argument_list|,
argument|&auint
argument_list|,
literal|1
argument_list|,
argument|unsigned int
argument_list|)
empty_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__osf__
comment|/* Without the dummy below unpack("I", pack("I",0xFFFFFFFF))                      * returns 1.84467440737096e+19 instead of 0xFFFFFFFF for 		     * DEC C V5.8-009 on Digital UNIX V4.0 (Rev. 1091) (aka V4.0D) 		     * with optimization turned on. 		     * (DEC C V5.2-040 on Digital UNIX V4.0 (Rev. 564) (aka V4.0B) 		     * does not have this problem even with -O4) 		     */
operator|(
name|auint
operator|)
condition|?
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auint
argument_list|)
else|:
endif|#
directive|endif
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auint
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE32
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
if|if
condition|(
name|along
operator|>
literal|2147483647
condition|)
name|along
operator|-=
literal|4294967296
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE32
expr_stmt|;
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|double
operator|)
name|along
expr_stmt|;
else|else
name|culong
operator|+=
name|along
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
if|#
directive|if
name|LONGSIZE
operator|>
name|SIZE32
if|if
condition|(
name|along
operator|>
literal|2147483647
condition|)
name|along
operator|-=
literal|4294967296
expr_stmt|;
endif|#
directive|endif
name|s
operator|+=
name|SIZE32
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|along
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'V'
case|:
case|case
literal|'N'
case|:
case|case
literal|'L'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
name|SIZE32
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE32
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'N'
condition|)
name|aulong
operator|=
name|PerlSock_ntohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'V'
condition|)
name|aulong
operator|=
name|vtohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|checksum
operator|>
literal|32
condition|)
name|cdouble
operator|+=
operator|(
name|double
operator|)
name|aulong
expr_stmt|;
else|else
name|culong
operator|+=
name|aulong
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|COPY32
argument_list|(
name|s
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SIZE32
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'N'
condition|)
name|aulong
operator|=
name|PerlSock_ntohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_VTOHL
if|if
condition|(
name|datumtype
operator|==
literal|'V'
condition|)
name|aulong
operator|=
name|vtohl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv
operator|=
name|NEWSV
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|aulong
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
name|strend
operator|-
name|s
condition|)
break|break;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aptr
argument_list|,
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|44
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|aptr
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|{
name|UV
name|auv
init|=
literal|0
decl_stmt|;
name|U32
name|bytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|s
operator|<
name|strend
operator|)
condition|)
block|{
name|auv
operator|=
operator|(
name|auv
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
name|s
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|++
operator|&
literal|0x80
operator|)
condition|)
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|auv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|auv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|bytes
operator|>=
sizeof|sizeof
argument_list|(
name|UV
argument_list|)
condition|)
block|{
comment|/* promote to string */
name|char
modifier|*
name|t
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|sv
operator|=
name|newSVpvf
argument_list|(
literal|"%.*Vu"
argument_list|,
operator|(
name|int
operator|)
name|TYPE_DIGITS
argument_list|(
name|UV
argument_list|)
argument_list|,
name|auv
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|sv
operator|=
name|mul128
argument_list|(
name|sv
argument_list|,
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|++
operator|&
literal|0x80
operator|)
condition|)
block|{
name|bytes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|t
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|'0'
condition|)
name|t
operator|++
expr_stmt|;
name|sv_chop
argument_list|(
name|sv
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|auv
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|>=
name|strend
operator|)
operator|&&
name|bytes
condition|)
name|croak
argument_list|(
literal|"Unterminated compressed integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|>
name|strend
operator|-
name|s
condition|)
break|break;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aptr
argument_list|,
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|44
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|aptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'q'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|+
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
operator|>
name|strend
condition|)
name|aquad
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|aquad
argument_list|,
literal|1
argument_list|,
name|Quad_t
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aquad
operator|>=
name|IV_MIN
operator|&&
name|aquad
operator|<=
name|IV_MAX
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
operator|(
name|IV
operator|)
name|aquad
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|aquad
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|+
expr|sizeof
operator|(
name|unsigned
name|Quad_t
operator|)
operator|>
name|strend
condition|)
name|auquad
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|Copy
argument_list|(
argument|s
argument_list|,
argument|&auquad
argument_list|,
literal|1
argument_list|,
argument|unsigned Quad_t
argument_list|)
empty_stmt|;
name|s
operator|+=
expr|sizeof
operator|(
name|unsigned
name|Quad_t
operator|)
expr_stmt|;
block|}
name|sv
operator|=
name|NEWSV
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|auquad
operator|<=
name|UV_MAX
condition|)
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|auquad
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|auquad
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* float and double added gnb@melba.bby.oz.au 22/11/89 */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|afloat
argument_list|,
literal|1
argument_list|,
name|float
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
name|cdouble
operator|+=
name|afloat
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|afloat
argument_list|,
literal|1
argument_list|,
name|float
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|47
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|afloat
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|along
condition|)
name|len
operator|=
name|along
expr_stmt|;
if|if
condition|(
name|checksum
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|adouble
argument_list|,
literal|1
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|cdouble
operator|+=
name|adouble
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|Copy
argument_list|(
name|s
argument_list|,
operator|&
name|adouble
argument_list|,
literal|1
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|48
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|adouble
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'u'
case|:
comment|/* MKS: 	     * Initialise the decode mapping.  By using a table driven              * algorithm, the code will be character-set independent              * (and just as fast as doing character arithmetic)              */
if|if
condition|(
name|uudmap
index|[
literal|'M'
index|]
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uuemap
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
name|uudmap
index|[
name|uuemap
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/*                  * Because ' ' and '`' map to the same value,                  * we need to decode them both the same.                  */
name|uudmap
index|[
literal|' '
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|along
operator|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
name|along
argument_list|)
expr_stmt|;
if|if
condition|(
name|along
condition|)
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|>
literal|' '
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|I32
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|char
name|hunk
index|[
literal|4
index|]
decl_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|uudmap
index|[
operator|*
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|a
operator|=
name|uudmap
index|[
operator|*
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|b
operator|=
name|uudmap
index|[
operator|*
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|c
operator|=
name|uudmap
index|[
operator|*
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|ISUUCHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|d
operator|=
name|uudmap
index|[
operator|*
name|s
operator|++
index|]
operator|&
literal|077
expr_stmt|;
else|else
name|d
operator|=
literal|0
expr_stmt|;
name|hunk
index|[
literal|0
index|]
operator|=
operator|(
name|a
operator|<<
literal|2
operator|)
operator||
operator|(
name|b
operator|>>
literal|4
operator|)
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
operator|(
name|b
operator|<<
literal|4
operator|)
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
operator|(
name|c
operator|<<
literal|6
operator|)
operator||
name|d
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
operator|(
name|len
operator|>
literal|3
operator|)
condition|?
literal|3
else|:
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* possible checksum byte */
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checksum
condition|)
block|{
name|sv
operator|=
name|NEWSV
argument_list|(
literal|42
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"fFdD"
argument_list|,
name|datumtype
argument_list|)
operator|||
operator|(
name|checksum
operator|>
literal|32
operator|&&
name|strchr
argument_list|(
literal|"iIlLN"
argument_list|,
name|datumtype
argument_list|)
operator|)
condition|)
block|{
name|double
name|trouble
decl_stmt|;
name|adouble
operator|=
literal|1.0
expr_stmt|;
while|while
condition|(
name|checksum
operator|>=
literal|16
condition|)
block|{
name|checksum
operator|-=
literal|16
expr_stmt|;
name|adouble
operator|*=
literal|65536.0
expr_stmt|;
block|}
while|while
condition|(
name|checksum
operator|>=
literal|4
condition|)
block|{
name|checksum
operator|-=
literal|4
expr_stmt|;
name|adouble
operator|*=
literal|16.0
expr_stmt|;
block|}
while|while
condition|(
name|checksum
operator|--
condition|)
name|adouble
operator|*=
literal|2.0
expr_stmt|;
name|along
operator|=
operator|(
literal|1
operator|<<
name|checksum
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cdouble
operator|<
literal|0.0
condition|)
name|cdouble
operator|+=
name|adouble
expr_stmt|;
name|cdouble
operator|=
name|modf
argument_list|(
name|cdouble
operator|/
name|adouble
argument_list|,
operator|&
name|trouble
argument_list|)
operator|*
name|adouble
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|cdouble
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|checksum
operator|<
literal|32
condition|)
block|{
name|aulong
operator|=
operator|(
literal|1
operator|<<
name|checksum
operator|)
operator|-
literal|1
expr_stmt|;
name|culong
operator|&=
name|aulong
expr_stmt|;
block|}
name|sv_setuv
argument_list|(
name|sv
argument_list|,
operator|(
name|UV
operator|)
name|culong
argument_list|)
expr_stmt|;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SP
operator|==
name|oldsp
operator|&&
name|gimme
operator|==
name|G_SCALAR
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|void
name|doencodes
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
name|hunk
index|[
literal|5
index|]
decl_stmt|;
operator|*
name|hunk
operator|=
name|uuemap
index|[
name|len
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hunk
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|2
condition|)
block|{
name|hunk
index|[
literal|0
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|*
name|s
operator|>>
literal|2
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
operator|*
name|s
operator|<<
literal|4
operator|)
operator|&
literal|060
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|017
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
operator|&
literal|074
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|077
operator|)
operator|)
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|r
init|=
operator|(
name|len
operator|>
literal|1
condition|?
name|s
index|[
literal|1
index|]
else|:
literal|'\0'
operator|)
decl_stmt|;
name|hunk
index|[
literal|0
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|*
name|s
operator|>>
literal|2
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
operator|(
operator|*
name|s
operator|<<
literal|4
operator|)
operator|&
literal|060
operator|)
operator||
operator|(
operator|(
name|r
operator|>>
literal|4
operator|)
operator|&
literal|017
operator|)
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
name|uuemap
index|[
operator|(
literal|077
operator|&
operator|(
operator|(
name|r
operator|<<
literal|2
operator|)
operator|&
literal|074
operator|)
operator|)
index|]
expr_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
name|uuemap
index|[
literal|0
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|hunk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|SV
modifier|*
name|is_an_int
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|l
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|SV
modifier|*
name|result
init|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result_c
init|=
name|SvPV
argument_list|(
name|result
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
comment|/* convenience */
name|char
modifier|*
name|out
init|=
name|result_c
decl_stmt|;
name|bool
name|skip
init|=
literal|1
decl_stmt|;
name|bool
name|ignore
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
name|skip
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|skip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ignore
condition|)
block|{
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
operator|*
name|s
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|ignore
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|SvREFCNT_dec
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|result
argument_list|,
name|out
operator|-
name|result_c
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|div128
parameter_list|(
name|SV
modifier|*
name|pnum
parameter_list|,
name|bool
modifier|*
name|done
parameter_list|)
comment|/* must be '\0' terminated */
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|pnum
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
operator|*
name|done
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|m
operator|*
literal|10
operator|+
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
name|m
operator|=
name|i
operator|&
literal|0x7F
expr_stmt|;
name|r
operator|=
operator|(
name|i
operator|>>
literal|7
operator|)
expr_stmt|;
comment|/* r< 10 */
if|if
condition|(
name|r
condition|)
block|{
operator|*
name|done
operator|=
literal|0
expr_stmt|;
block|}
operator|*
operator|(
name|t
operator|++
operator|)
operator|=
literal|'0'
operator|+
name|r
expr_stmt|;
block|}
operator|*
operator|(
name|t
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|pnum
argument_list|,
call|(
name|STRLEN
call|)
argument_list|(
name|t
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_pack
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
name|dTARGET
expr_stmt|;
specifier|register
name|SV
modifier|*
name|cat
init|=
name|TARG
decl_stmt|;
specifier|register
name|I32
name|items
decl_stmt|;
name|STRLEN
name|fromlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
init|=
name|SvPVx
argument_list|(
operator|*
operator|++
name|MARK
argument_list|,
name|fromlen
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|patend
init|=
name|pat
operator|+
name|fromlen
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
name|I32
name|datumtype
decl_stmt|;
name|SV
modifier|*
name|fromstr
decl_stmt|;
comment|/*SUPPRESS 442*/
specifier|static
name|char
name|null10
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|space10
init|=
literal|"          "
decl_stmt|;
comment|/* These must not be in registers: */
name|char
name|achar
decl_stmt|;
name|I16
name|ashort
decl_stmt|;
name|int
name|aint
decl_stmt|;
name|unsigned
name|int
name|auint
decl_stmt|;
name|I32
name|along
decl_stmt|;
name|U32
name|aulong
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_QUAD
name|Quad_t
name|aquad
decl_stmt|;
name|unsigned
name|Quad_t
name|auquad
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|aptr
decl_stmt|;
name|float
name|afloat
decl_stmt|;
name|double
name|adouble
decl_stmt|;
name|int
name|commas
init|=
literal|0
decl_stmt|;
name|items
operator|=
name|SP
operator|-
name|MARK
expr_stmt|;
name|MARK
operator|++
expr_stmt|;
name|sv_setpvn
argument_list|(
name|cat
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|pat
operator|<
name|patend
condition|)
block|{
define|#
directive|define
name|NEXTFROM
value|(items--> 0 ? *MARK++ :&PL_sv_no)
name|datumtype
operator|=
operator|*
name|pat
operator|++
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
name|datumtype
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|strchr
argument_list|(
literal|"@Xxu"
argument_list|,
name|datumtype
argument_list|)
condition|?
literal|0
else|:
name|items
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|*
name|pat
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|len
operator|=
operator|(
name|len
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|pat
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|len
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|datumtype
condition|)
block|{
default|default:
name|croak
argument_list|(
literal|"Invalid type in pack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
case|case
literal|','
case|:
comment|/* grandfather in commas but with a warning */
if|if
condition|(
name|commas
operator|++
operator|==
literal|0
operator|&&
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Invalid type in pack: '%c'"
argument_list|,
operator|(
name|int
operator|)
name|datumtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|DIE
argument_list|(
literal|"%% may only be used in unpack"
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
name|len
operator|-=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|grow
goto|;
name|len
operator|=
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|shrink
goto|;
break|break;
case|case
literal|'X'
case|:
name|shrink
label|:
if|if
condition|(
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|<
name|len
condition|)
name|DIE
argument_list|(
literal|"X outside of string"
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|-=
name|len
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|cat
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|grow
label|:
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
if|if
condition|(
name|fromlen
operator|>
name|len
condition|)
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|fromlen
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'A'
condition|)
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|space10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|space10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
block|{
name|char
modifier|*
name|savepat
init|=
name|pat
decl_stmt|;
name|I32
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
name|aint
operator|=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+=
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromlen
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
name|items
operator||=
operator|*
name|pat
operator|++
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|pat
operator|++
operator|&
literal|1
condition|)
name|items
operator||=
literal|128
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|>>=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
name|items
operator|<<=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
else|else
name|items
operator|>>=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
block|}
name|pat
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|pat
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|savepat
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
block|{
name|char
modifier|*
name|savepat
init|=
name|pat
decl_stmt|;
name|I32
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
name|aint
operator|=
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|SvCUR
argument_list|(
name|cat
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromlen
condition|)
name|len
operator|=
name|fromlen
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'H'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
expr_stmt|;
else|else
name|items
operator||=
operator|*
name|pat
operator|++
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|<<=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
name|items
operator||=
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|>>=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|1
condition|)
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|pat
operator|=
name|SvPVX
argument_list|(
name|cat
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|cat
argument_list|)
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|pat
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|savepat
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|achar
operator|=
name|aint
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|&
name|achar
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Float and double added by gnb@melba.bby.oz.au  22/11/89 */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|afloat
operator|=
operator|(
name|float
operator|)
name|SvNV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|afloat
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|adouble
operator|=
operator|(
name|double
operator|)
name|SvNV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|adouble
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONS
name|ashort
operator|=
name|PerlSock_htons
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVS
name|ashort
operator|=
name|htovs
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|I16
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT16
argument_list|(
name|cat
argument_list|,
operator|&
name|ashort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auint
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auint
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|adouble
operator|=
name|floor
argument_list|(
name|SvNV
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adouble
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"Cannot compress negative numbers"
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|BW_BITS
name|adouble
operator|<=
name|BW_MASK
else|#
directive|else
ifdef|#
directive|ifdef
name|CXUX_BROKEN_CONSTANT_CONVERT
name|adouble
operator|<=
name|UV_MAX_cxux
else|#
directive|else
name|adouble
operator|<=
name|UV_MAX
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
name|char
name|buf
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|in
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|UV
name|auv
init|=
name|U_V
argument_list|(
name|adouble
argument_list|)
decl_stmt|;
empty_stmt|;
do|do
block|{
operator|*
operator|--
name|in
operator|=
operator|(
name|auv
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
name|auv
operator|>>=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|auv
condition|)
do|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|fromstr
argument_list|)
condition|)
block|{
comment|/* decimal string arithmetics */
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|SV
modifier|*
name|norm
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|bool
name|done
decl_stmt|;
comment|/* Copy string and check for compliance */
name|from
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|norm
operator|=
name|is_an_int
argument_list|(
name|from
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|croak
argument_list|(
literal|"can compress only unsigned integer"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|'w'
argument_list|,
name|result
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|in
operator|=
name|result
operator|+
name|len
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
operator|*
operator|--
name|in
operator|=
name|div128
argument_list|(
name|norm
argument_list|,
operator|&
name|done
argument_list|)
operator||
literal|0x80
expr_stmt|;
name|result
index|[
name|len
operator|-
literal|1
index|]
operator|&=
literal|0x7F
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|result
operator|+
name|len
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|norm
argument_list|)
expr_stmt|;
comment|/* free norm */
block|}
elseif|else
if|if
condition|(
name|SvNOKp
argument_list|(
name|fromstr
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
literal|2
index|]
decl_stmt|;
comment|/* 8/7<= 2 */
name|char
modifier|*
name|in
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
do|do
block|{
name|double
name|next
init|=
name|floor
argument_list|(
name|adouble
operator|/
literal|128
argument_list|)
decl_stmt|;
operator|*
operator|--
name|in
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|adouble
operator|-
operator|(
name|next
operator|*
literal|128
operator|)
argument_list|)
operator||
literal|0x80
expr_stmt|;
if|if
condition|(
operator|--
name|in
operator|<
name|buf
condition|)
comment|/* this cannot happen ;-) */
name|croak
argument_list|(
literal|"Cannot compress integer"
argument_list|)
expr_stmt|;
name|adouble
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|adouble
operator|>
literal|0
condition|)
do|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* clear continue bit */
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
name|in
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|-
name|in
argument_list|)
expr_stmt|;
block|}
else|else
name|croak
argument_list|(
literal|"Cannot compress non integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aint
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONL
name|aulong
operator|=
name|PerlSock_htonl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVL
name|aulong
operator|=
name|htovl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|SvUV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|aulong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|along
operator|=
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|CAT32
argument_list|(
name|cat
argument_list|,
operator|&
name|along
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_QUAD
case|case
literal|'Q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auquad
operator|=
operator|(
name|unsigned
name|Quad_t
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auquad
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|Quad_t
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aquad
operator|=
operator|(
name|Quad_t
operator|)
name|SvIV
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aquad
argument_list|,
sizeof|sizeof
argument_list|(
name|Quad_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* HAS_QUAD */
case|case
literal|'P'
case|:
name|len
operator|=
literal|1
expr_stmt|;
comment|/* assume SV is correct length */
comment|/* FALL THROUGH */
case|case
literal|'p'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
if|if
condition|(
name|fromstr
operator|==
operator|&
name|PL_sv_undef
condition|)
name|aptr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|STRLEN
name|n_a
decl_stmt|;
comment|/* XXX better yet, could spirit away the string to 		     * a safe spot and hang on to it until the result 		     * of pack() (and all copies of the result) are 		     * gone. 		     */
if|if
condition|(
name|PL_dowarn
operator|&&
operator|(
name|SvTEMP
argument_list|(
name|fromstr
argument_list|)
operator|||
name|SvPADTMP
argument_list|(
name|fromstr
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Attempt to pack pointer to temporary value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|fromstr
argument_list|)
operator|||
name|SvNIOK
argument_list|(
name|fromstr
argument_list|)
condition|)
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
else|else
name|aptr
operator|=
name|SvPV_force
argument_list|(
name|fromstr
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|cat
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|SvPV
argument_list|(
name|fromstr
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|cat
argument_list|,
name|fromlen
operator|*
literal|4
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|len
operator|=
literal|45
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|/
literal|3
operator|*
literal|3
expr_stmt|;
while|while
condition|(
name|fromlen
operator|>
literal|0
condition|)
block|{
name|I32
name|todo
decl_stmt|;
if|if
condition|(
name|fromlen
operator|>
name|len
condition|)
name|todo
operator|=
name|len
expr_stmt|;
else|else
name|todo
operator|=
name|fromlen
expr_stmt|;
name|doencodes
argument_list|(
name|cat
argument_list|,
name|aptr
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|fromlen
operator|-=
name|todo
expr_stmt|;
name|aptr
operator|+=
name|todo
expr_stmt|;
block|}
break|break;
block|}
block|}
name|SvSETMAGIC
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|PUSHs
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|NEXTFROM
end_undef

begin_macro
name|PP
argument_list|(
argument|pp_split
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTARG
expr_stmt|;
name|AV
modifier|*
name|ary
decl_stmt|;
specifier|register
name|I32
name|limit
init|=
name|POPi
decl_stmt|;
comment|/* note, negative is forever */
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strend
init|=
name|s
operator|+
name|len
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
specifier|register
name|REGEXP
modifier|*
name|rx
decl_stmt|;
specifier|register
name|SV
modifier|*
name|dstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
name|I32
name|iters
init|=
literal|0
decl_stmt|;
name|I32
name|maxiters
init|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|+
literal|10
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|char
modifier|*
name|orig
decl_stmt|;
name|I32
name|origlimit
init|=
name|limit
decl_stmt|;
name|I32
name|realarray
init|=
literal|0
decl_stmt|;
name|I32
name|base
decl_stmt|;
name|AV
modifier|*
name|oldstack
init|=
name|PL_curstack
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|I32
name|oldsave
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|make_mortal
init|=
literal|1
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|Copy
argument_list|(
operator|&
name|LvTARGOFF
argument_list|(
name|POPs
argument_list|)
argument_list|,
operator|&
name|pm
argument_list|,
literal|1
argument_list|,
name|PMOP
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|POPs
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pm
operator|||
operator|!
name|s
condition|)
name|DIE
argument_list|(
literal|"panic: do_split"
argument_list|)
expr_stmt|;
name|rx
operator|=
name|pm
operator|->
name|op_pmregexp
expr_stmt|;
name|TAINT_IF
argument_list|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
operator|&&
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
operator|(
name|PMf_WHITE
operator||
name|PMf_SKIPWHITE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmreplroot
condition|)
name|ary
operator|=
name|GvAVn
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|pm
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
ifdef|#
directive|ifdef
name|USE_THREADS
name|ary
operator|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|ary
operator|=
name|GvAVn
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
else|else
name|ary
operator|=
name|Nullav
expr_stmt|;
if|if
condition|(
name|ary
operator|&&
operator|(
name|gimme
operator|!=
name|G_ARRAY
operator|||
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_ONCE
operator|)
operator|)
condition|)
block|{
name|realarray
operator|=
literal|1
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|av_extend
argument_list|(
name|ary
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_clear
argument_list|(
name|ary
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|SvTIED_obj
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|,
name|mg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AvREAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|AvREAL_on
argument_list|(
name|ary
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|AvARRAY
argument_list|(
name|ary
argument_list|)
index|[
name|i
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
comment|/* don't free mere refs */
block|}
comment|/* temporarily switch stacks */
name|SWITCHSTACK
argument_list|(
name|PL_curstack
argument_list|,
name|ary
argument_list|)
expr_stmt|;
name|make_mortal
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|base
operator|=
name|SP
operator|-
name|PL_stack_base
expr_stmt|;
name|orig
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_SKIPWHITE
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
condition|)
block|{
while|while
condition|(
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
operator|(
name|PMf_MULTILINE
operator||
name|PMf_SINGLELINE
operator|)
condition|)
block|{
name|SAVEINT
argument_list|(
name|PL_multiline
argument_list|)
expr_stmt|;
name|PL_multiline
operator|=
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_MULTILINE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|limit
condition|)
name|limit
operator|=
name|maxiters
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_WHITE
condition|)
block|{
while|while
condition|(
operator|--
name|limit
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|m
operator|<
name|strend
operator|&&
operator|!
operator|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|isSPACE_LC
argument_list|(
operator|*
name|m
argument_list|)
else|:
name|isSPACE
argument_list|(
operator|*
name|m
argument_list|)
operator|)
condition|)
operator|++
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|(
operator|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
operator|++
name|s
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
literal|"^"
argument_list|,
name|rx
operator|->
name|precomp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|limit
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|m
operator|=
name|s
init|;
name|m
operator|<
name|strend
operator|&&
operator|*
name|m
operator|!=
literal|'\n'
condition|;
name|m
operator|++
control|)
empty_stmt|;
name|m
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rx
operator|->
name|check_substr
operator|&&
operator|!
name|rx
operator|->
name|nparens
operator|&&
operator|(
name|rx
operator|->
name|reganch
operator|&
name|ROPT_CHECK_ALL
operator|)
operator|&&
operator|!
operator|(
name|rx
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
name|i
operator|=
name|SvCUR
argument_list|(
name|rx
operator|->
name|check_substr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
operator|!
name|SvTAIL
argument_list|(
name|rx
operator|->
name|check_substr
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
name|SvPVX
argument_list|(
name|rx
operator|->
name|check_substr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|limit
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|m
operator|=
name|s
init|;
name|m
operator|<
name|strend
operator|&&
operator|*
name|m
operator|!=
name|i
condition|;
name|m
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|m
operator|>=
name|strend
condition|)
break|break;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|30
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|lint
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|--
name|limit
operator|&&
operator|(
name|m
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|rx
operator|->
name|check_substr
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|31
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|+
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|maxiters
operator|+=
operator|(
name|strend
operator|-
name|s
operator|)
operator|*
name|rx
operator|->
name|nparens
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|--
name|limit
operator|&&
name|CALLREGEXEC
argument_list|(
name|rx
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|orig
argument_list|,
literal|1
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TAINT_IF
argument_list|(
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|subbase
operator|&&
name|rx
operator|->
name|subbase
operator|!=
name|orig
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
name|orig
operator|=
name|rx
operator|->
name|subbase
expr_stmt|;
name|s
operator|=
name|orig
operator|+
operator|(
name|m
operator|-
name|s
operator|)
expr_stmt|;
name|strend
operator|=
name|s
operator|+
operator|(
name|strend
operator|-
name|m
operator|)
expr_stmt|;
block|}
name|m
operator|=
name|rx
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|32
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|nparens
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|rx
operator|->
name|startp
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
name|rx
operator|->
name|endp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|s
condition|)
block|{
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|33
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|33
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|rx
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
name|iters
operator|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|iters
operator|>
name|maxiters
condition|)
name|DIE
argument_list|(
literal|"Split loop"
argument_list|)
expr_stmt|;
comment|/* keep field after final delim? */
if|if
condition|(
name|s
operator|<
name|strend
operator|||
operator|(
name|iters
operator|&&
name|origlimit
operator|)
condition|)
block|{
name|dstr
operator|=
name|NEWSV
argument_list|(
literal|34
argument_list|,
name|strend
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|strend
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_mortal
condition|)
name|sv_2mortal
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|iters
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|origlimit
condition|)
block|{
while|while
condition|(
name|iters
operator|>
literal|0
operator|&&
operator|(
operator|!
name|TOPs
operator|||
operator|!
name|SvANY
argument_list|(
name|TOPs
argument_list|)
operator|||
name|SvCUR
argument_list|(
name|TOPs
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|iters
operator|--
operator|,
name|SP
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|realarray
condition|)
block|{
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|SWITCHSTACK
argument_list|(
name|ary
argument_list|,
name|oldstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvSMAGICAL
argument_list|(
name|ary
argument_list|)
condition|)
block|{
name|PUTBACK
expr_stmt|;
name|mg_set
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|ary
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
block|}
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|iters
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|ary
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|iters
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|iters
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
else|else
block|{
name|PUTBACK
expr_stmt|;
name|ENTER
expr_stmt|;
name|perl_call_method
argument_list|(
literal|"PUSH"
argument_list|,
name|G_SCALAR
operator||
name|G_DISCARD
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* EXTEND should not be needed - we just popped them */
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|iters
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|ary
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|PUSHs
argument_list|(
operator|(
name|svp
operator|)
condition|?
operator|*
name|svp
else|:
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|iters
operator|||
operator|!
name|pm
operator|->
name|op_pmreplroot
condition|)
block|{
name|GETTARGET
expr_stmt|;
name|PUSHi
argument_list|(
name|iters
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_THREADS
end_ifdef

begin_function
name|void
name|unlock_condpair
parameter_list|(
name|void
modifier|*
name|svv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|svv
argument_list|,
literal|'m'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mg
condition|)
name|croak
argument_list|(
literal|"panic: unlock_condpair unlocking non-mutex"
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|!=
name|thr
condition|)
name|croak
argument_list|(
literal|"panic: unlock_condpair unlocking mutex that we don't own"
argument_list|)
expr_stmt|;
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
name|MgOWNERCONDP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
argument|PerlIO_printf(PerlIO_stderr(),
literal|"0x%lx: unlock 0x%lx\n"
argument|, 			  (unsigned long)thr, (unsigned long)svv);
argument_list|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_THREADS */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_lock
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|retsv
init|=
name|sv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|mg
operator|=
name|condpair_magic
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|==
name|thr
condition|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
condition|)
name|COND_WAIT
argument_list|(
name|MgOWNERCONDP
argument_list|(
name|mg
argument_list|)
argument_list|,
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|=
name|thr
expr_stmt|;
name|DEBUG_S
argument_list|(
argument|PerlIO_printf(PerlIO_stderr(),
literal|"0x%lx: pp_lock lock 0x%lx\n"
argument|, 			      (unsigned long)thr, (unsigned long)sv);
argument_list|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|save_destructor
argument_list|(
name|unlock_condpair
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVAV
operator|||
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVHV
operator|||
name|SvTYPE
argument_list|(
name|retsv
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|retsv
operator|=
name|refto
argument_list|(
name|retsv
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|retsv
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_threadsv
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
condition|)
name|PUSHs
argument_list|(
operator|*
name|save_threadsv
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|THREADSV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
else|#
directive|else
name|DIE
argument_list|(
literal|"tried to access per-thread data in non-threaded perl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
block|}
end_block

end_unit

