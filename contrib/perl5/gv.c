begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    gv.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  *   'Mercy!' cried Gandalf.  'If the giving of information is to be the cure  * of your inquisitiveness, I shall spend all the rest of my days answering  * you.  What more do you want to know?'  *   'The names of all the stars, and of all living things, and the whole  * history of Middle-earth and Over-heaven and of the Sundering Seas,'  * laughed Pippin.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_GV_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_function
name|GV
modifier|*
name|Perl_gv_AVadd
parameter_list|(
name|pTHX_
specifier|register
name|GV
modifier|*
name|gv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gv
operator|||
name|SvTYPE
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad symbol for array"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvAV
argument_list|(
name|gv
argument_list|)
condition|)
name|GvAV
argument_list|(
name|gv
argument_list|)
operator|=
name|newAV
argument_list|()
expr_stmt|;
return|return
name|gv
return|;
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_gv_HVadd
parameter_list|(
name|pTHX_
specifier|register
name|GV
modifier|*
name|gv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gv
operator|||
name|SvTYPE
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad symbol for hash"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvHV
argument_list|(
name|gv
argument_list|)
condition|)
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|=
name|newHV
argument_list|()
expr_stmt|;
return|return
name|gv
return|;
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_gv_IOadd
parameter_list|(
name|pTHX_
specifier|register
name|GV
modifier|*
name|gv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gv
operator|||
name|SvTYPE
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad symbol for filehandle"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvIOp
argument_list|(
name|gv
argument_list|)
condition|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
operator|=
name|newIO
argument_list|()
expr_stmt|;
return|return
name|gv
return|;
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_gv_fetchfile
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|smallbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|STRLEN
name|tmplen
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
operator|!
name|PL_defstash
condition|)
return|return
name|Nullgv
return|;
name|tmplen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|tmplen
operator|<
sizeof|sizeof
name|smallbuf
condition|)
name|tmpbuf
operator|=
name|smallbuf
expr_stmt|;
else|else
name|New
argument_list|(
literal|603
argument_list|,
name|tmpbuf
argument_list|,
name|tmplen
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
literal|'<'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gv
operator|=
operator|*
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
name|tmpbuf
argument_list|,
name|tmplen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|gv_init
argument_list|(
name|gv
argument_list|,
name|PL_defstash
argument_list|,
name|tmpbuf
argument_list|,
name|tmplen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
condition|)
name|hv_magic
argument_list|(
name|GvHVn
argument_list|(
name|gv_AVadd
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|,
name|Nullgv
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpbuf
operator|!=
name|smallbuf
condition|)
name|Safefree
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
return|return
name|gv
return|;
block|}
end_function

begin_function
name|void
name|Perl_gv_init
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|int
name|multi
parameter_list|)
block|{
specifier|register
name|GP
modifier|*
name|gp
decl_stmt|;
name|bool
name|doproto
init|=
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|>
name|SVt_NULL
decl_stmt|;
name|char
modifier|*
name|proto
init|=
operator|(
name|doproto
operator|&&
name|SvPOK
argument_list|(
name|gv
argument_list|)
operator|)
condition|?
name|SvPVX
argument_list|(
name|gv
argument_list|)
else|:
name|NULL
decl_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvLEN
argument_list|(
name|gv
argument_list|)
condition|)
block|{
if|if
condition|(
name|proto
condition|)
block|{
name|SvPVX
argument_list|(
name|gv
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvLEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvPOK_off
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|602
argument_list|,
name|gp
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|gv
argument_list|)
operator|=
name|NEWSV
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvLINE
argument_list|(
name|gv
argument_list|)
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|GvFILE
argument_list|(
name|gv
argument_list|)
operator|=
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
condition|?
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
else|:
literal|""
expr_stmt|;
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvEGV
argument_list|(
name|gv
argument_list|)
operator|=
name|gv
expr_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'*'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|stash
argument_list|)
expr_stmt|;
name|GvNAME
argument_list|(
name|gv
argument_list|)
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|multi
operator|||
name|doproto
condition|)
comment|/* doproto means it _was_ mentioned */
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|doproto
condition|)
block|{
comment|/* Replicate part of newSUB here. */
name|SvIOK_off
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
comment|/* XXX unsafe for threads if eval_owner isn't held */
name|start_subparse
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create CV in compcv. */
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
name|PL_compcv
expr_stmt|;
name|LEAVE
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
name|CvGV
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|gv
expr_stmt|;
name|CvFILE
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|CvSTASH
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|PL_curstash
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CvMUTEXP
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
block|{
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|proto
condition|)
block|{
name|sv_setpv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|S_gv_init_sv
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|I32
name|sv_type
parameter_list|)
block|{
switch|switch
condition|(
name|sv_type
condition|)
block|{
case|case
name|SVt_PVIO
case|:
operator|(
name|void
operator|)
name|GvIOn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
operator|(
name|void
operator|)
name|GvAVn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
operator|(
name|void
operator|)
name|GvHVn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc gv_fetchmeth  Returns the glob with the given C<name> and a defined subroutine or C<NULL>.  The glob lives in the given C<stash>, or in the stashes accessible via @ISA and @UNIVERSAL.  The argument C<level> should be either 0 or -1.  If C<level==0>, as a side-effect creates a glob with the given C<name> in the given C<stash> which in the case of success contains an alias for the subroutine, and sets up caching info for this glob.  Similarly for all the searched stashes.  This function grants C<"SUPER"> token as a postfix of the stash name. The GV returned from C<gv_fetchmeth> may be a method cache entry, which is not visible to Perl code.  So when calling C<call_sv>, you should not use the GV directly; instead, you should use the method's CV, which can be obtained from the GV with the C<GvCV> macro.  =cut */
end_comment

begin_function
name|GV
modifier|*
name|Perl_gv_fetchmeth
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|I32
name|level
parameter_list|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
name|GV
modifier|*
name|topgv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|GV
modifier|*
modifier|*
name|gvp
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|level
operator|>
literal|100
operator|)
operator|||
operator|(
name|level
operator|<
operator|-
literal|100
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Recursive inheritance detected while looking for method '%s' in package '%s'"
argument_list|,
name|name
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Looking for method %s in package %s\n"
argument_list|,
name|name
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|(
name|level
operator|>=
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
condition|)
name|topgv
operator|=
name|Nullgv
expr_stmt|;
else|else
block|{
name|topgv
operator|=
operator|*
name|gvp
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|topgv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|gv_init
argument_list|(
name|topgv
argument_list|,
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|topgv
argument_list|)
operator|)
condition|)
block|{
comment|/* If genuine method or valid cache entry, use it */
if|if
condition|(
operator|!
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|||
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|==
name|PL_sub_generation
condition|)
return|return
name|topgv
return|;
comment|/* Stale cached entry: junk it */
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|topgv
argument_list|)
operator|=
name|cv
operator|=
name|Nullcv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|==
name|PL_sub_generation
condition|)
return|return
literal|0
return|;
comment|/* cache indicates sub doesn't exist */
block|}
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
literal|"ISA"
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|av
operator|=
operator|(
name|gvp
operator|&&
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
operator|&&
name|gv
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|)
condition|?
name|GvAV
argument_list|(
name|gv
argument_list|)
else|:
name|Nullav
expr_stmt|;
comment|/* create and re-create @.*::SUPER::ISA on demand */
if|if
condition|(
operator|!
name|av
operator|||
operator|!
name|SvMAGIC
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|char
modifier|*
name|packname
init|=
name|HvNAME
argument_list|(
name|stash
argument_list|)
decl_stmt|;
name|STRLEN
name|packlen
init|=
name|strlen
argument_list|(
name|packname
argument_list|)
decl_stmt|;
if|if
condition|(
name|packlen
operator|>=
literal|7
operator|&&
name|strEQ
argument_list|(
name|packname
operator|+
name|packlen
operator|-
literal|7
argument_list|,
literal|"::SUPER"
argument_list|)
condition|)
block|{
name|HV
modifier|*
name|basestash
decl_stmt|;
name|packlen
operator|-=
literal|7
expr_stmt|;
name|basestash
operator|=
name|gv_stashpvn
argument_list|(
name|packname
argument_list|,
name|packlen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|basestash
argument_list|,
literal|"ISA"
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gvp
operator|&&
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|av
operator|=
name|GvAV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
literal|"ISA"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
operator|||
operator|!
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Cannot create %s::ISA"
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|gv_init
argument_list|(
name|gv
argument_list|,
name|stash
argument_list|,
literal|"ISA"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|av
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|av
argument_list|)
decl_stmt|;
comment|/* NOTE: No support for tied ISA */
name|I32
name|items
init|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
operator|*
name|svp
operator|++
decl_stmt|;
name|HV
modifier|*
name|basestash
init|=
name|gv_stashsv
argument_list|(
name|sv
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|basestash
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Can't locate package %s for @%s::ISA"
argument_list|,
argument|SvPVX(sv)
argument_list|,
argument|HvNAME(stash)
argument_list|)
empty_stmt|;
continue|continue;
block|}
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|basestash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|(
name|level
operator|>=
literal|0
operator|)
condition|?
name|level
operator|+
literal|1
else|:
name|level
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
goto|goto
name|gotcha
goto|;
block|}
block|}
comment|/* if at top level, try UNIVERSAL */
if|if
condition|(
name|level
operator|==
literal|0
operator|||
name|level
operator|==
operator|-
literal|1
condition|)
block|{
name|HV
modifier|*
name|lastchance
decl_stmt|;
if|if
condition|(
operator|(
name|lastchance
operator|=
name|gv_stashpvn
argument_list|(
literal|"UNIVERSAL"
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|lastchance
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|(
name|level
operator|>=
literal|0
operator|)
condition|?
name|level
operator|+
literal|1
else|:
name|level
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|gotcha
label|:
comment|/* 		 * Cache method in topgv if: 		 *  1. topgv has no synonyms (else inheritance crosses wires) 		 *  2. method isn't a stub (else AUTOLOAD fails spectacularly) 		 */
if|if
condition|(
name|topgv
operator|&&
name|GvREFCNT
argument_list|(
name|topgv
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|topgv
argument_list|)
operator|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|topgv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|=
name|PL_sub_generation
expr_stmt|;
block|}
return|return
name|gv
return|;
block|}
elseif|else
if|if
condition|(
name|topgv
operator|&&
name|GvREFCNT
argument_list|(
name|topgv
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* cache the fact that the method is not defined */
name|GvCVGEN
argument_list|(
name|topgv
argument_list|)
operator|=
name|PL_sub_generation
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc gv_fetchmethod  See L<gv_fetchmethod_autoload>.  =cut */
end_comment

begin_function
name|GV
modifier|*
name|Perl_gv_fetchmethod
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|gv_fetchmethod_autoload
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc gv_fetchmethod_autoload  Returns the glob which contains the subroutine to call to invoke the method on the C<stash>.  In fact in the presence of autoloading this may be the glob for "AUTOLOAD".  In this case the corresponding variable $AUTOLOAD is already setup.  The third parameter of C<gv_fetchmethod_autoload> determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling C<gv_fetchmethod> is equivalent to calling C<gv_fetchmethod_autoload> with a non-zero C<autoload> parameter.  These functions grant C<"SUPER"> token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being "AUTOLOAD", since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created via a side effect to do this.  These functions have the same side-effects and as C<gv_fetchmeth> with C<level==0>.  C<name> should be writable if contains C<':'> or C<' ''>. The warning against passing the GV returned by C<gv_fetchmeth> to C<call_sv> apply equally to these functions.  =cut */
end_comment

begin_function
name|GV
modifier|*
name|Perl_gv_fetchmethod_autoload
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|autoload
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|nend
decl_stmt|;
specifier|const
name|char
modifier|*
name|nsplit
init|=
literal|0
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
for|for
control|(
name|nend
operator|=
name|name
init|;
operator|*
name|nend
condition|;
name|nend
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|nend
operator|==
literal|'\''
condition|)
name|nsplit
operator|=
name|nend
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|nend
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|nend
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
name|nsplit
operator|=
operator|++
name|nend
expr_stmt|;
block|}
if|if
condition|(
name|nsplit
condition|)
block|{
specifier|const
name|char
modifier|*
name|origname
init|=
name|name
decl_stmt|;
name|name
operator|=
name|nsplit
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|nsplit
operator|==
literal|':'
condition|)
operator|--
name|nsplit
expr_stmt|;
if|if
condition|(
operator|(
name|nsplit
operator|-
name|origname
operator|)
operator|==
literal|5
operator|&&
name|strnEQ
argument_list|(
name|origname
argument_list|,
literal|"SUPER"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* ->SUPER::method should really be looked up in original stash */
name|SV
modifier|*
name|tmpstr
init|=
name|sv_2mortal
argument_list|(
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%s::SUPER"
argument_list|,
name|CopSTASHPV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|stash
operator|=
name|gv_stashpvn
argument_list|(
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Treating %s as %s::%s\n"
argument_list|,
name|origname
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|stash
operator|=
name|gv_stashpvn
argument_list|(
name|origname
argument_list|,
name|nsplit
operator|-
name|origname
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|nend
operator|-
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"import"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"unimport"
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_yes
expr_stmt|;
elseif|else
if|if
condition|(
name|autoload
condition|)
name|gv
operator|=
name|gv_autoload4
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|nend
operator|-
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|autoload
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|GvCV
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|&&
operator|!
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|GV
modifier|*
name|stubgv
decl_stmt|;
name|GV
modifier|*
name|autogv
decl_stmt|;
if|if
condition|(
name|CvANON
argument_list|(
name|cv
argument_list|)
condition|)
name|stubgv
operator|=
name|gv
expr_stmt|;
else|else
block|{
name|stubgv
operator|=
name|CvGV
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvCV
argument_list|(
name|stubgv
argument_list|)
operator|!=
name|cv
condition|)
comment|/* orphaned import */
name|stubgv
operator|=
name|gv
expr_stmt|;
block|}
name|autogv
operator|=
name|gv_autoload4
argument_list|(
name|GvSTASH
argument_list|(
name|stubgv
argument_list|)
argument_list|,
name|GvNAME
argument_list|(
name|stubgv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|stubgv
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|autogv
condition|)
name|gv
operator|=
name|autogv
expr_stmt|;
block|}
block|}
return|return
name|gv
return|;
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_gv_autoload4
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|I32
name|method
parameter_list|)
block|{
specifier|static
name|char
name|autoload
index|[]
init|=
literal|"AUTOLOAD"
decl_stmt|;
specifier|static
name|STRLEN
name|autolen
init|=
literal|8
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|HV
modifier|*
name|varstash
decl_stmt|;
name|GV
modifier|*
name|vargv
decl_stmt|;
name|SV
modifier|*
name|varsv
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|autolen
operator|&&
name|strnEQ
argument_list|(
name|name
argument_list|,
name|autoload
argument_list|,
name|autolen
argument_list|)
condition|)
return|return
name|Nullgv
return|;
if|if
condition|(
operator|!
operator|(
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|stash
argument_list|,
name|autoload
argument_list|,
name|autolen
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
return|return
name|Nullgv
return|;
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CvROOT
argument_list|(
name|cv
argument_list|)
condition|)
return|return
name|Nullgv
return|;
comment|/*      * Inheriting AUTOLOAD for non-methods works ... for now.      */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
operator|&&
operator|!
name|method
operator|&&
operator|(
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|||
name|GvSTASH
argument_list|(
name|gv
argument_list|)
operator|!=
name|stash
operator|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated"
argument_list|,
argument|HvNAME(stash)
argument_list|,
argument|(int)len
argument_list|,
argument|name
argument_list|)
empty_stmt|;
comment|/*      * Given&FOO::AUTOLOAD, set $FOO::AUTOLOAD to desired function name.      * The subroutine's original name may not be "AUTOLOAD", so we don't      * use that, but for lack of anything better we will use the sub's      * original package to look up $AUTOLOAD.      */
name|varstash
operator|=
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|vargv
operator|=
operator|*
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|varstash
argument_list|,
name|autoload
argument_list|,
name|autolen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_lock
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|varstash
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isGV
argument_list|(
name|vargv
argument_list|)
condition|)
name|gv_init
argument_list|(
name|vargv
argument_list|,
name|varstash
argument_list|,
name|autoload
argument_list|,
name|autolen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|varsv
operator|=
name|GvSV
argument_list|(
name|vargv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_lock
argument_list|(
name|varsv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_setpv
argument_list|(
name|varsv
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|varsv
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|varsv
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvTAINTED_off
argument_list|(
name|varsv
argument_list|)
expr_stmt|;
return|return
name|gv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc gv_stashpv  Returns a pointer to the stash for a specified package.  C<name> should be a valid UTF-8 string.  If C<create> is set then the package will be created if it does not already exist.  If C<create> is not set and the package does not exist then NULL is returned.  =cut */
end_comment

begin_function
name|HV
modifier|*
name|Perl_gv_stashpv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
return|return
name|gv_stashpvn
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|create
argument_list|)
return|;
block|}
end_function

begin_function
name|HV
modifier|*
name|Perl_gv_stashpvn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|U32
name|namelen
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|char
name|smallbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|tmpgv
decl_stmt|;
if|if
condition|(
name|namelen
operator|+
literal|3
operator|<
sizeof|sizeof
name|smallbuf
condition|)
name|tmpbuf
operator|=
name|smallbuf
expr_stmt|;
else|else
name|New
argument_list|(
literal|606
argument_list|,
name|tmpbuf
argument_list|,
name|namelen
operator|+
literal|3
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|name
argument_list|,
name|tmpbuf
argument_list|,
name|namelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|namelen
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|tmpbuf
index|[
name|namelen
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|tmpbuf
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|create
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpbuf
operator|!=
name|smallbuf
condition|)
name|Safefree
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpgv
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|GvHV
argument_list|(
name|tmpgv
argument_list|)
condition|)
name|GvHV
argument_list|(
name|tmpgv
argument_list|)
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|stash
operator|=
name|GvHV
argument_list|(
name|tmpgv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HvNAME
argument_list|(
name|stash
argument_list|)
condition|)
name|HvNAME
argument_list|(
name|stash
argument_list|)
operator|=
name|savepv
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|stash
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc gv_stashsv  Returns a pointer to the stash for a specified package, which must be a valid UTF-8 string.  See C<gv_stashpv>.  =cut */
end_comment

begin_function
name|HV
modifier|*
name|Perl_gv_stashsv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|ptr
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|gv_stashpvn
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|create
argument_list|)
return|;
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_gv_fetchpv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|nambeg
parameter_list|,
name|I32
name|add
parameter_list|,
name|I32
name|sv_type
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
init|=
name|nambeg
decl_stmt|;
specifier|register
name|GV
modifier|*
name|gv
init|=
literal|0
decl_stmt|;
name|GV
modifier|*
modifier|*
name|gvp
decl_stmt|;
name|I32
name|len
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|namend
decl_stmt|;
name|HV
modifier|*
name|stash
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
operator|&&
name|isALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* accidental stringify on a GV? */
name|name
operator|++
expr_stmt|;
for|for
control|(
name|namend
operator|=
name|name
init|;
operator|*
name|namend
condition|;
name|namend
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|namend
operator|==
literal|':'
operator|&&
name|namend
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|namend
operator|==
literal|'\''
operator|&&
name|namend
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|stash
condition|)
name|stash
operator|=
name|PL_defstash
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
operator|!
name|SvREFCNT
argument_list|(
name|stash
argument_list|)
condition|)
comment|/* symbol table under destruction */
return|return
name|Nullgv
return|;
name|len
operator|=
name|namend
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|smallbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|3
operator|<
sizeof|sizeof
name|smallbuf
condition|)
name|tmpbuf
operator|=
name|smallbuf
expr_stmt|;
else|else
name|New
argument_list|(
literal|601
argument_list|,
name|tmpbuf
argument_list|,
name|len
operator|+
literal|3
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|name
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gvp
condition|?
operator|*
name|gvp
else|:
name|Nullgv
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|gv
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
name|gv_init
argument_list|(
name|gv
argument_list|,
name|stash
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|,
operator|(
name|add
operator|&
name|GV_ADDMULTI
operator|)
argument_list|)
expr_stmt|;
else|else
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpbuf
operator|!=
name|smallbuf
condition|)
name|Safefree
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gv
operator|||
name|gv
operator|==
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
condition|)
return|return
name|Nullgv
return|;
if|if
condition|(
operator|!
operator|(
name|stash
operator|=
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|stash
operator|=
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|=
name|newHV
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|HvNAME
argument_list|(
name|stash
argument_list|)
condition|)
name|HvNAME
argument_list|(
name|stash
argument_list|)
operator|=
name|savepvn
argument_list|(
name|nambeg
argument_list|,
name|namend
operator|-
name|nambeg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|namend
operator|==
literal|':'
condition|)
name|namend
operator|++
expr_stmt|;
name|namend
operator|++
expr_stmt|;
name|name
operator|=
name|namend
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
return|return
name|gv
condition|?
name|gv
else|:
operator|(
name|GV
operator|*
operator|)
operator|*
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
literal|"main::"
argument_list|,
literal|6
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
block|}
name|len
operator|=
name|namend
operator|-
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* No stash in name, so see how we can default */
if|if
condition|(
operator|!
name|stash
condition|)
block|{
if|if
condition|(
name|isIDFIRST_lazy
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|bool
name|global
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'S'
operator|&&
operator|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"SIG"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDIN"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDOUT"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDERR"
argument_list|)
operator|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'I'
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"INC"
argument_list|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'E'
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ENV"
argument_list|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'A'
operator|&&
operator|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ARGV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ARGVOUT"
argument_list|)
operator|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
operator|!
name|name
index|[
literal|1
index|]
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|global
condition|)
name|stash
operator|=
name|PL_defstash
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|COP
operator|*
operator|)
name|PL_curcop
operator|==
operator|&
name|PL_compiling
condition|)
block|{
name|stash
operator|=
name|PL_curstash
expr_stmt|;
if|if
condition|(
name|add
operator|&&
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_VARS
operator|)
operator|&&
name|sv_type
operator|!=
name|SVt_PVCV
operator|&&
name|sv_type
operator|!=
name|SVt_PVGV
operator|&&
name|sv_type
operator|!=
name|SVt_PVFM
operator|&&
name|sv_type
operator|!=
name|SVt_PVIO
operator|&&
operator|!
operator|(
name|len
operator|==
literal|1
operator|&&
name|sv_type
operator|==
name|SVt_PV
operator|&&
name|strchr
argument_list|(
literal|"ab"
argument_list|,
operator|*
name|name
argument_list|)
operator|)
condition|)
block|{
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
operator|||
operator|*
name|gvp
operator|==
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|||
name|SvTYPE
argument_list|(
operator|*
name|gvp
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
name|stash
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sv_type
operator|==
name|SVt_PV
operator|&&
operator|!
name|GvIMPORTED_SV
argument_list|(
operator|*
name|gvp
argument_list|)
operator|)
operator|||
operator|(
name|sv_type
operator|==
name|SVt_PVAV
operator|&&
operator|!
name|GvIMPORTED_AV
argument_list|(
operator|*
name|gvp
argument_list|)
operator|)
operator|||
operator|(
name|sv_type
operator|==
name|SVt_PVHV
operator|&&
operator|!
name|GvIMPORTED_HV
argument_list|(
operator|*
name|gvp
argument_list|)
operator|)
condition|)
block|{
name|Perl_warn
argument_list|(
name|aTHX_
literal|"Variable \"%c%s\" is not imported"
argument_list|,
name|sv_type
operator|==
name|SVt_PVAV
condition|?
literal|'@'
else|:
name|sv_type
operator|==
name|SVt_PVHV
condition|?
literal|'%'
else|:
literal|'$'
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvCVu
argument_list|(
operator|*
name|gvp
argument_list|)
condition|)
name|Perl_warn
argument_list|(
name|aTHX_
literal|"\t(Did you mean&%s instead?)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
name|stash
operator|=
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
else|else
name|stash
operator|=
name|PL_defstash
expr_stmt|;
block|}
comment|/* By this point we should have a stash and a name */
if|if
condition|(
operator|!
name|stash
condition|)
block|{
if|if
condition|(
name|add
condition|)
block|{
name|qerror
argument_list|(
name|Perl_mess
argument_list|(
name|aTHX_
literal|"Global symbol \"%s%s\" requires explicit package name"
argument_list|,
operator|(
name|sv_type
operator|==
name|SVt_PV
condition|?
literal|"$"
else|:
name|sv_type
operator|==
name|SVt_PVAV
condition|?
literal|"@"
else|:
name|sv_type
operator|==
name|SVt_PVHV
condition|?
literal|"%"
else|:
literal|""
operator|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|stash
operator|=
name|PL_nullstash
expr_stmt|;
block|}
else|else
return|return
name|Nullgv
return|;
block|}
if|if
condition|(
operator|!
name|SvREFCNT
argument_list|(
name|stash
argument_list|)
condition|)
comment|/* symbol table under destruction */
return|return
name|Nullgv
return|;
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
operator|||
operator|*
name|gvp
operator|==
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
condition|)
return|return
name|Nullgv
return|;
name|gv
operator|=
operator|*
name|gvp
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|add
condition|)
block|{
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|gv_init_sv
argument_list|(
name|gv
argument_list|,
name|sv_type
argument_list|)
expr_stmt|;
block|}
return|return
name|gv
return|;
block|}
elseif|else
if|if
condition|(
name|add
operator|&
name|GV_NOINIT
condition|)
block|{
return|return
name|gv
return|;
block|}
comment|/* Adding a new symbol */
if|if
condition|(
name|add
operator|&
name|GV_ADDWARN
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Had to create %s unexpectedly"
argument_list|,
argument|nambeg
argument_list|)
empty_stmt|;
name|gv_init
argument_list|(
name|gv
argument_list|,
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|add
operator|&
name|GV_ADDMULTI
argument_list|)
expr_stmt|;
name|gv_init_sv
argument_list|(
name|gv
argument_list|,
name|sv_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
operator|(
name|isLEXWARN_on
condition|?
name|ckWARN
argument_list|(
name|WARN_ONCE
argument_list|)
else|:
operator|(
name|PL_dowarn
operator|&
name|G_WARN_ON
operator|)
operator|)
condition|)
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
comment|/* set up magic where warranted */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ARGV"
argument_list|)
condition|)
block|{
name|IoFLAGS
argument_list|(
name|GvIOn
argument_list|(
name|gv
argument_list|)
argument_list|)
operator||=
name|IOf_ARGV
operator||
name|IOf_START
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|name
argument_list|,
literal|"EXPORT"
argument_list|,
literal|6
argument_list|)
condition|)
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ISA"
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|av
init|=
name|GvAVn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|'I'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE: No support for tied ISA */
if|if
condition|(
operator|(
name|add
operator|&
name|GV_ADDMULTI
operator|)
operator|&&
name|strEQ
argument_list|(
name|nambeg
argument_list|,
literal|"AnyDBM_File::ISA"
argument_list|)
operator|&&
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|pname
decl_stmt|;
name|av_push
argument_list|(
name|av
argument_list|,
name|newSVpvn
argument_list|(
name|pname
operator|=
literal|"NDBM_File"
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|gv_stashpvn
argument_list|(
name|pname
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|av
argument_list|,
name|newSVpvn
argument_list|(
name|pname
operator|=
literal|"DB_File"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|gv_stashpvn
argument_list|(
name|pname
argument_list|,
literal|7
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|av
argument_list|,
name|newSVpvn
argument_list|(
name|pname
operator|=
literal|"GDBM_File"
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|gv_stashpvn
argument_list|(
name|pname
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|av
argument_list|,
name|newSVpvn
argument_list|(
name|pname
operator|=
literal|"SDBM_File"
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|gv_stashpvn
argument_list|(
name|pname
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|av
argument_list|,
name|newSVpvn
argument_list|(
name|pname
operator|=
literal|"ODBM_File"
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|gv_stashpvn
argument_list|(
name|pname
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"OVERLOAD"
argument_list|)
condition|)
block|{
name|HV
modifier|*
name|hv
init|=
name|GvHVn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|hv_magic
argument_list|(
name|hv
argument_list|,
name|Nullgv
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"SIG"
argument_list|)
condition|)
block|{
name|HV
modifier|*
name|hv
decl_stmt|;
name|I32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|PL_psig_ptr
condition|)
block|{
name|int
name|sig_num
index|[]
init|=
block|{
name|SIG_NUM
block|}
decl_stmt|;
name|New
argument_list|(
literal|73
argument_list|,
name|PL_psig_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sig_num
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sig_num
argument_list|)
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|73
argument_list|,
name|PL_psig_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sig_num
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sig_num
argument_list|)
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|hv
operator|=
name|GvHVn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|hv_magic
argument_list|(
name|hv
argument_list|,
name|Nullgv
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|PL_sig_name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
modifier|*
name|init
decl_stmt|;
name|init
operator|=
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|PL_sig_name
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|PL_sig_name
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|sv_setsv
argument_list|(
operator|*
name|init
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|PL_psig_ptr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|PL_psig_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"VERSION"
argument_list|)
condition|)
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|PL_sawampersand
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ro_magicalize
goto|;
case|case
literal|'`'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|PL_sawampersand
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ro_magicalize
goto|;
case|case
literal|'\''
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|PL_sawampersand
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ro_magicalize
goto|;
case|case
literal|':'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|sv_setpv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|PL_chopset
argument_list|)
expr_stmt|;
goto|goto
name|magicalize
goto|;
case|case
literal|'?'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
ifdef|#
directive|ifdef
name|COMPLEX_STATUS
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|SVt_PVLV
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|magicalize
goto|;
case|case
literal|'!'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
if|if
condition|(
name|sv_type
operator|>
name|SVt_PV
operator|&&
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
block|{
name|HV
modifier|*
name|stash
init|=
name|gv_stashpvn
argument_list|(
literal|"Errno"
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
operator|!
operator|(
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
literal|"TIEHASH"
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|require_pv
argument_list|(
literal|"Errno.pm"
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|stash
operator|=
name|gv_stashpvn
argument_list|(
literal|"Errno"
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
operator|!
operator|(
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
literal|"TIEHASH"
argument_list|)
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use %%! because Errno.pm is not available"
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|magicalize
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
else|else
block|{
name|AV
modifier|*
name|av
init|=
name|GvAVn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
name|Nullsv
argument_list|,
literal|'D'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
goto|goto
name|magicalize
goto|;
case|case
literal|'#'
case|:
case|case
literal|'*'
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
operator|&&
name|len
operator|==
literal|1
operator|&&
name|sv_type
operator|==
name|SVt_PV
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"Use of $%s is deprecated"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'['
case|:
case|case
literal|'^'
case|:
case|case
literal|'~'
case|:
case|case
literal|'='
case|:
case|case
literal|'%'
case|:
case|case
literal|'.'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|','
case|:
case|case
literal|'\\'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\001'
case|:
comment|/* $^A */
case|case
literal|'\003'
case|:
comment|/* $^C */
case|case
literal|'\004'
case|:
comment|/* $^D */
case|case
literal|'\005'
case|:
comment|/* $^E */
case|case
literal|'\006'
case|:
comment|/* $^F */
case|case
literal|'\010'
case|:
comment|/* $^H */
case|case
literal|'\011'
case|:
comment|/* $^I, NOT \t in EBCDIC */
case|case
literal|'\017'
case|:
comment|/* $^O */
case|case
literal|'\020'
case|:
comment|/* $^P */
case|case
literal|'\024'
case|:
comment|/* $^T */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
goto|goto
name|magicalize
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|sv_setiv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|IoFLAGS
argument_list|(
name|GvIOp
argument_list|(
name|PL_defoutgv
argument_list|)
argument_list|)
operator|&
name|IOf_FLUSH
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|magicalize
goto|;
case|case
literal|'\023'
case|:
comment|/* $^S */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
goto|goto
name|ro_magicalize
goto|;
case|case
literal|'\027'
case|:
comment|/* $^W& $^WARNING_BITS */
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|strNE
argument_list|(
name|name
argument_list|,
literal|"\027ARNING_BITS"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|name
argument_list|,
literal|"\027IDE_SYSTEM_CALLS"
argument_list|)
condition|)
break|break;
goto|goto
name|magicalize
goto|;
case|case
literal|'+'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
else|else
block|{
name|AV
modifier|*
name|av
init|=
name|GvAVn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|,
literal|'D'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ro_magicalize
label|:
name|SvREADONLY_on
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|magicalize
label|:
name|sv_magic
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\014'
case|:
comment|/* $^L */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|sv_setpv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"\f"
argument_list|)
expr_stmt|;
name|PL_formfeed
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
break|break;
name|sv_setpv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"\034"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|GvSV
argument_list|(
name|gv
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|PERL_SUBVERSION
argument_list|)
operator|&&
operator|(
name|PERL_SUBVERSION
operator|>
literal|0
operator|)
literal|"%8.6"
else|#
directive|else
literal|"%5.3"
endif|#
directive|endif
argument|NVff
argument_list|,
argument|SvNVX(PL_patchlevel)
argument_list|)
empty_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvNOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\026'
case|:
comment|/* $^V */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|GvSV
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|GvSV
argument_list|(
name|gv
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|gv
return|;
block|}
end_function

begin_function
name|void
name|Perl_gv_fullname4
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|bool
name|keepmain
parameter_list|)
block|{
name|HV
modifier|*
name|hv
init|=
name|GvSTASH
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepmain
operator|||
name|strNE
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_gv_fullname3
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|HV
modifier|*
name|hv
init|=
name|GvSTASH
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|""
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_gv_efullname4
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|bool
name|keepmain
parameter_list|)
block|{
name|GV
modifier|*
name|egv
init|=
name|GvEGV
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|egv
condition|)
name|egv
operator|=
name|gv
expr_stmt|;
name|gv_fullname4
argument_list|(
name|sv
argument_list|,
name|egv
argument_list|,
name|prefix
argument_list|,
name|keepmain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_gv_efullname3
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|GV
modifier|*
name|egv
init|=
name|GvEGV
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|egv
condition|)
name|egv
operator|=
name|gv
expr_stmt|;
name|gv_fullname3
argument_list|(
name|sv
argument_list|,
name|egv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX compatibility with versions<= 5.003. */
end_comment

begin_function
name|void
name|Perl_gv_fullname
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|gv_fullname3
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|gv
condition|?
literal|"*"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX compatibility with versions<= 5.003. */
end_comment

begin_function
name|void
name|Perl_gv_efullname
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|gv
condition|?
literal|"*"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|IO
modifier|*
name|Perl_newIO
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|iogv
decl_stmt|;
name|io
operator|=
operator|(
name|IO
operator|*
operator|)
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|io
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
name|io
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvOBJECT_on
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|iogv
operator|=
name|gv_fetchpv
argument_list|(
literal|"FileHandle::"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
comment|/* unless exists($main::{FileHandle}) and defined(%main::FileHandle::) */
if|if
condition|(
operator|!
operator|(
name|iogv
operator|&&
name|GvHV
argument_list|(
name|iogv
argument_list|)
operator|&&
name|HvARRAY
argument_list|(
name|GvHV
argument_list|(
name|iogv
argument_list|)
argument_list|)
operator|)
condition|)
name|iogv
operator|=
name|gv_fetchpv
argument_list|(
literal|"IO::Handle::"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|io
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|GvHV
argument_list|(
name|iogv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|io
return|;
block|}
end_function

begin_function
name|void
name|Perl_gv_check
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
if|if
condition|(
operator|!
name|HvARRAY
argument_list|(
name|stash
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|I32
operator|)
name|HvMAX
argument_list|(
name|stash
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|HvARRAY
argument_list|(
name|stash
argument_list|)
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
index|[
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|)
operator|&&
operator|(
name|hv
operator|=
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|hv
operator|!=
name|PL_defstash
operator|&&
name|hv
operator|!=
name|stash
condition|)
name|gv_check
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* nested package */
block|}
elseif|else
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
operator|||
name|GvMULTI
argument_list|(
name|gv
argument_list|)
condition|)
continue|continue;
name|file
operator|=
name|GvFILE
argument_list|(
name|gv
argument_list|)
expr_stmt|;
comment|/* performance hack: if filename is absolute and it's a standard 		 * module, don't bother warning */
if|if
condition|(
name|file
operator|&&
name|PERL_FILE_IS_ABSOLUTE
argument_list|(
name|file
argument_list|)
operator|&&
operator|(
name|instr
argument_list|(
name|file
argument_list|,
literal|"/lib/"
argument_list|)
operator|||
name|instr
argument_list|(
name|file
argument_list|,
literal|".pm"
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|GvLINE
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
operator|=
name|file
expr_stmt|;
comment|/* set for warning */
else|#
directive|else
name|CopFILEGV
argument_list|(
name|PL_curcop
argument_list|)
operator|=
name|gv_fetchfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_ONCE
argument_list|,
literal|"Name \"%s::%s\" used only once: possible typo"
argument_list|,
argument|HvNAME(stash)
argument_list|,
argument|GvNAME(gv)
argument_list|)
empty_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|GV
modifier|*
name|Perl_newGVgen
parameter_list|(
name|pTHX_
name|char
modifier|*
name|pack
parameter_list|)
block|{
return|return
name|gv_fetchpv
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"%s::_GEN_%ld"
argument_list|,
name|pack
argument_list|,
operator|(
name|long
operator|)
name|PL_gensym
operator|++
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVGV
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* hopefully this is only called on local symbol table entries */
end_comment

begin_function
name|GP
modifier|*
name|Perl_gp_ref
parameter_list|(
name|pTHX_
name|GP
modifier|*
name|gp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gp
condition|)
return|return
operator|(
name|GP
operator|*
operator|)
name|NULL
return|;
name|gp
operator|->
name|gp_refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|gp_cv
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|gp_cvgen
condition|)
block|{
comment|/* multi-named GPs cannot be used for method cache */
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_cv
argument_list|)
expr_stmt|;
name|gp
operator|->
name|gp_cv
operator|=
name|Nullcv
expr_stmt|;
name|gp
operator|->
name|gp_cvgen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Adding a new name to a subroutine invalidates method cache */
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
block|}
return|return
name|gp
return|;
block|}
end_function

begin_function
name|void
name|Perl_gp_free
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|GP
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
operator|!
name|gv
operator|||
operator|!
operator|(
name|gp
operator|=
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|gp
operator|->
name|gp_refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Attempt to free unreferenced glob pointers"
argument_list|)
empty_stmt|;
return|return;
block|}
if|if
condition|(
name|gp
operator|->
name|gp_cv
condition|)
block|{
comment|/* Deleting the name of a subroutine invalidates method cache */
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|gp
operator|->
name|gp_refcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|gp_egv
operator|==
name|gv
condition|)
name|gp
operator|->
name|gp_egv
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_sv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_av
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_hv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_io
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_cv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|gp
operator|->
name|gp_form
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CRIPPLED_CC
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|iAPX286
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I286
argument_list|)
operator|||
name|defined
argument_list|(
name|I80286
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|MICROPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MICROPORT
end_ifdef

begin_comment
comment|/* Microport 2.4 hack */
end_comment

begin_function
name|AV
modifier|*
name|GvAVn
parameter_list|(
name|gv
parameter_list|)
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
block|{
if|if
condition|(
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|->
name|gp_av
condition|)
return|return
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|->
name|gp_av
return|;
else|else
return|return
name|GvGP
argument_list|(
name|gv_AVadd
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|->
name|gp_av
return|;
block|}
end_function

begin_function
name|HV
modifier|*
name|GvHVn
parameter_list|(
name|gv
parameter_list|)
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
block|{
if|if
condition|(
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|->
name|gp_hv
condition|)
return|return
name|GvGP
argument_list|(
name|gv
argument_list|)
operator|->
name|gp_hv
return|;
else|else
return|return
name|GvGP
argument_list|(
name|gv_HVadd
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|->
name|gp_hv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Microport 2.4 hack */
end_comment

begin_comment
comment|/* Updates and caches the CV's */
end_comment

begin_function
name|bool
name|Perl_Gv_AMupdate
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|stash
argument_list|,
literal|'c'
argument_list|)
decl_stmt|;
name|AMT
modifier|*
name|amtp
init|=
operator|(
name|mg
operator|)
condition|?
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
else|:
operator|(
name|AMT
operator|*
operator|)
name|NULL
decl_stmt|;
name|AMT
name|amt
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD_VIA_HASH
name|GV
modifier|*
modifier|*
name|gvp
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mg
operator|&&
name|amtp
operator|->
name|was_ok_am
operator|==
name|PL_amagic_generation
operator|&&
name|amtp
operator|->
name|was_ok_sub
operator|==
name|PL_sub_generation
condition|)
return|return
name|AMT_AMAGIC
argument_list|(
name|amtp
argument_list|)
return|;
if|if
condition|(
name|amtp
operator|&&
name|AMT_AMAGIC
argument_list|(
name|amtp
argument_list|)
condition|)
block|{
comment|/* Have table. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NofAMmeth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|amtp
operator|->
name|table
index|[
name|i
index|]
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|amtp
operator|->
name|table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sv_unmagic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|stash
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Recalcing overload magic in package %s\n"
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|amt
operator|.
name|was_ok_am
operator|=
name|PL_amagic_generation
expr_stmt|;
name|amt
operator|.
name|was_ok_sub
operator|=
name|PL_sub_generation
expr_stmt|;
name|amt
operator|.
name|fallback
operator|=
name|AMGfallNO
expr_stmt|;
name|amt
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD_VIA_HASH
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|stash
argument_list|,
literal|"OVERLOAD"
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* A shortcut */
if|if
condition|(
name|gvp
operator|&&
operator|(
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|hv
operator|=
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
comment|/* Work with "fallback" key, which we assume to be first in PL_AMG_names */
if|if
condition|(
operator|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_AMG_names
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|svp
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|(
name|sv
operator|=
operator|*
name|svp
operator|)
condition|)
block|{
if|if
condition|(
name|SvTRUE
argument_list|(
name|sv
argument_list|)
condition|)
name|amt
operator|.
name|fallback
operator|=
name|AMGfallYES
expr_stmt|;
elseif|else
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|amt
operator|.
name|fallback
operator|=
name|AMGfallNEVER
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NofAMmeth
condition|;
name|i
operator|++
control|)
block|{
name|cv
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_AMG_names
index|[
name|i
index|]
expr_stmt|;
name|svp
operator|=
operator|(
name|SV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|(
operator|(
name|sv
operator|=
operator|*
name|svp
operator|)
operator|!=
operator|&
name|PL_sv_undef
operator|)
condition|)
block|{
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
break|break;
name|gv
operator|=
name|gv_fetchmethod
argument_list|(
name|stash
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
break|break;
block|}
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|cv
argument_list|)
operator|==
name|SVt_PVCV
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVAV
case|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Not a subroutine reference in overload table"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|SVt_PVCV
case|:
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
operator|!
operator|(
name|cv
operator|=
name|GvCVu
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
operator|)
condition|)
name|cv
operator|=
name|sv_2cv
argument_list|(
name|sv
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cv
condition|)
name|filled
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Method for operation %s not found in package %.256s during blessing\n"
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|#
directive|else
block|{
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|NULL
decl_stmt|;
comment|/* Work with "fallback" key, which we assume to be first in PL_AMG_names */
if|if
condition|(
operator|(
name|cp
operator|=
name|PL_AMG_names
index|[
literal|0
index|]
operator|)
condition|)
block|{
comment|/* Try to find via inheritance. */
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|stash
argument_list|,
literal|"()"
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* A cookie: "()". */
if|if
condition|(
name|gv
condition|)
name|sv
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
goto|goto
name|no_table
goto|;
elseif|else
if|if
condition|(
name|SvTRUE
argument_list|(
name|sv
argument_list|)
condition|)
name|amt
operator|.
name|fallback
operator|=
name|AMGfallYES
expr_stmt|;
elseif|else
if|if
condition|(
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|amt
operator|.
name|fallback
operator|=
name|AMGfallNEVER
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NofAMmeth
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
name|cookie
init|=
name|sv_2mortal
argument_list|(
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"(%s"
argument_list|,
name|cp
operator|=
name|PL_AMG_names
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Checking overloading of `%s' in package `%.256s'\n"
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't fill the cache while looking up! */
name|gv
operator|=
name|gv_fetchmeth
argument_list|(
name|stash
argument_list|,
name|SvPVX
argument_list|(
name|cookie
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|cookie
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GvNAMELEN
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|==
literal|3
operator|&&
name|strEQ
argument_list|(
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|,
literal|"nil"
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"overload"
argument_list|)
condition|)
block|{
comment|/* GvSV contains the name of the method. */
name|GV
modifier|*
name|ngv
decl_stmt|;
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n"
argument_list|,
name|SvPV
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|||
operator|!
operator|(
name|ngv
operator|=
name|gv_fetchmethod_autoload
argument_list|(
name|stash
argument_list|,
name|SvPVX
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
comment|/* Can be an import stub (created by `can'). */
if|if
condition|(
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'"
argument_list|,
operator|(
name|SvPOK
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
else|:
literal|"???"
operator|)
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't resolve method `%.256s' overloading `%s' in package `%.256s'"
argument_list|,
operator|(
name|SvPOK
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
else|:
literal|"???"
operator|)
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
operator|=
name|ngv
argument_list|)
expr_stmt|;
block|}
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Overloading `%s' in package `%.256s' via `%.256s::%.256s' \n"
argument_list|,
name|cp
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|,
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|filled
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|amt
operator|.
name|table
index|[
name|i
index|]
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filled
condition|)
block|{
name|AMT_AMAGIC_on
argument_list|(
operator|&
name|amt
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|stash
argument_list|,
literal|0
argument_list|,
literal|'c'
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|amt
argument_list|,
sizeof|sizeof
argument_list|(
name|AMT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Here we have no table: */
name|no_table
label|:
name|AMT_AMAGIC_off
argument_list|(
operator|&
name|amt
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|stash
argument_list|,
literal|0
argument_list|,
literal|'c'
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|amt
argument_list|,
sizeof|sizeof
argument_list|(
name|AMTS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|SV
modifier|*
name|Perl_amagic_call
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|left
parameter_list|,
name|SV
modifier|*
name|right
parameter_list|,
name|int
name|method
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|CV
modifier|*
modifier|*
name|cvp
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|ocvp
init|=
name|NULL
decl_stmt|;
name|AMT
modifier|*
name|amtp
decl_stmt|,
modifier|*
name|oamtp
decl_stmt|;
name|int
name|fl
init|=
literal|0
decl_stmt|,
name|off
decl_stmt|,
name|off1
decl_stmt|,
name|lr
init|=
literal|0
decl_stmt|,
name|assign
init|=
name|AMGf_assign
operator|&
name|flags
decl_stmt|,
name|notfound
init|=
literal|0
decl_stmt|;
name|int
name|postpr
init|=
literal|0
decl_stmt|,
name|force_cpy
init|=
literal|0
decl_stmt|,
name|assignshift
init|=
name|assign
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|AMGf_noleft
operator|&
name|flags
operator|)
operator|&&
name|SvAMAGIC
argument_list|(
name|left
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
operator|(
name|stash
operator|=
name|SvSTASH
argument_list|(
name|SvRV
argument_list|(
name|left
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|'c'
argument_list|)
operator|)
operator|&&
operator|(
name|ocvp
operator|=
name|cvp
operator|=
operator|(
name|AMT_AMAGIC
argument_list|(
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
condition|?
operator|(
name|oamtp
operator|=
name|amtp
operator|=
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
operator|)
operator|->
name|table
else|:
operator|(
name|CV
operator|*
operator|*
operator|)
name|NULL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|method
operator|+
name|assignshift
index|]
operator|)
operator|||
operator|(
name|assign
operator|&&
name|amtp
operator|->
name|fallback
operator|>
name|AMGfallNEVER
operator|&&
comment|/* fallback to 						          * usual method */
operator|(
name|fl
operator|=
literal|1
operator|,
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|method
index|]
operator|)
operator|)
operator|)
condition|)
block|{
name|lr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Call method for left argument */
block|}
else|else
block|{
if|if
condition|(
name|cvp
operator|&&
name|amtp
operator|->
name|fallback
operator|>
name|AMGfallNEVER
operator|&&
name|flags
operator|&
name|AMGf_unary
condition|)
block|{
name|int
name|logic
decl_stmt|;
comment|/* look for substituted methods */
comment|/* In all the covered cases we should be called with assign==0. */
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|inc_amg
case|:
name|force_cpy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|add_ass_amg
index|]
operator|)
operator|||
operator|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|add_amg
index|]
operator|)
operator|&&
operator|(
name|force_cpy
operator|=
literal|0
operator|,
name|postpr
operator|=
literal|1
operator|)
operator|)
condition|)
block|{
name|right
operator|=
operator|&
name|PL_sv_yes
expr_stmt|;
name|lr
operator|=
operator|-
literal|1
expr_stmt|;
name|assign
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|dec_amg
case|:
name|force_cpy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|subtr_ass_amg
index|]
operator|)
operator|||
operator|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|subtr_amg
index|]
operator|)
operator|&&
operator|(
name|force_cpy
operator|=
literal|0
operator|,
name|postpr
operator|=
literal|1
operator|)
operator|)
condition|)
block|{
name|right
operator|=
operator|&
name|PL_sv_yes
expr_stmt|;
name|lr
operator|=
operator|-
literal|1
expr_stmt|;
name|assign
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|bool__amg
case|:
call|(
name|void
call|)
argument_list|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|numer_amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|string_amg
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|numer_amg
case|:
call|(
name|void
call|)
argument_list|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|string_amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|bool__amg
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|string_amg
case|:
call|(
name|void
call|)
argument_list|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|numer_amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|bool__amg
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|not_amg
case|:
call|(
name|void
call|)
argument_list|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|bool__amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|numer_amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|string_amg
index|]
operator|)
argument_list|)
expr_stmt|;
name|postpr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|copy_amg
case|:
block|{
comment|/* 		  * SV* ref causes confusion with the interpreter variable of 		  * the same name 		  */
name|SV
modifier|*
name|tmpRef
init|=
name|SvRV
argument_list|(
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|tmpRef
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|tmpRef
argument_list|)
operator|<=
name|SVt_PVMG
condition|)
block|{
comment|/* 		 * Just to be extra cautious.  Maybe in some 		 * additional cases sv_setsv is safe, too. 		 */
name|SV
modifier|*
name|newref
init|=
name|newSVsv
argument_list|(
name|tmpRef
argument_list|)
decl_stmt|;
name|SvOBJECT_on
argument_list|(
name|newref
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|newref
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|SvSTASH
argument_list|(
name|tmpRef
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newref
return|;
block|}
block|}
break|break;
case|case
name|abs_amg
case|:
if|if
condition|(
operator|(
name|cvp
index|[
name|off1
operator|=
name|lt_amg
index|]
operator|||
name|cvp
index|[
name|off1
operator|=
name|ncmp_amg
index|]
operator|)
operator|&&
operator|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|neg_amg
index|]
operator|)
operator|||
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|subtr_amg
index|]
operator|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|nullsv
init|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|off1
operator|==
name|lt_amg
condition|)
block|{
name|SV
modifier|*
name|lessp
init|=
name|amagic_call
argument_list|(
name|left
argument_list|,
name|nullsv
argument_list|,
name|lt_amg
argument_list|,
name|AMGf_noright
argument_list|)
decl_stmt|;
name|logic
operator|=
name|SvTRUE
argument_list|(
name|lessp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|lessp
init|=
name|amagic_call
argument_list|(
name|left
argument_list|,
name|nullsv
argument_list|,
name|ncmp_amg
argument_list|,
name|AMGf_noright
argument_list|)
decl_stmt|;
name|logic
operator|=
operator|(
name|SvNV
argument_list|(
name|lessp
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|logic
condition|)
block|{
if|if
condition|(
name|off
operator|==
name|subtr_amg
condition|)
block|{
name|right
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|nullsv
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
name|left
return|;
block|}
block|}
break|break;
case|case
name|neg_amg
case|:
if|if
condition|(
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|subtr_amg
index|]
operator|)
condition|)
block|{
name|right
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|iter_amg
case|:
comment|/* XXXX Eventually should do to_gv. */
comment|/* FAIL safe */
return|return
name|NULL
return|;
comment|/* Delegate operation to standard mechanisms. */
break|break;
case|case
name|to_sv_amg
case|:
case|case
name|to_av_amg
case|:
case|case
name|to_hv_amg
case|:
case|case
name|to_gv_amg
case|:
case|case
name|to_cv_amg
case|:
comment|/* FAIL safe */
return|return
name|left
return|;
comment|/* Delegate operation to standard mechanisms. */
break|break;
default|default:
goto|goto
name|not_found
goto|;
block|}
if|if
condition|(
operator|!
name|cv
condition|)
goto|goto
name|not_found
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|AMGf_noright
operator|&
name|flags
operator|)
operator|&&
name|SvAMAGIC
argument_list|(
name|right
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
operator|(
name|stash
operator|=
name|SvSTASH
argument_list|(
name|SvRV
argument_list|(
name|right
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|'c'
argument_list|)
operator|)
operator|&&
operator|(
name|cvp
operator|=
operator|(
name|AMT_AMAGIC
argument_list|(
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
condition|?
operator|(
name|amtp
operator|=
operator|(
name|AMT
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
operator|)
operator|->
name|table
else|:
operator|(
name|CV
operator|*
operator|*
operator|)
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|cv
operator|=
name|cvp
index|[
name|off
operator|=
name|method
index|]
operator|)
condition|)
block|{
comment|/* Method for right 					     * argument found */
name|lr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ocvp
operator|&&
name|oamtp
operator|->
name|fallback
operator|>
name|AMGfallNEVER
operator|&&
operator|(
name|cvp
operator|=
name|ocvp
operator|)
operator|&&
operator|(
name|lr
operator|=
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|cvp
operator|&&
name|amtp
operator|->
name|fallback
operator|>
name|AMGfallNEVER
operator|&&
operator|(
name|lr
operator|=
literal|1
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|AMGf_unary
operator|)
condition|)
block|{
comment|/* We look for substitution for 				 * comparison operations and 				 * concatenation */
if|if
condition|(
name|method
operator|==
name|concat_amg
operator|||
name|method
operator|==
name|concat_ass_amg
operator|||
name|method
operator|==
name|repeat_amg
operator|||
name|method
operator|==
name|repeat_ass_amg
condition|)
block|{
return|return
name|NULL
return|;
comment|/* Delegate operation to string conversion */
block|}
name|off
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|lt_amg
case|:
case|case
name|le_amg
case|:
case|case
name|gt_amg
case|:
case|case
name|ge_amg
case|:
case|case
name|eq_amg
case|:
case|case
name|ne_amg
case|:
name|postpr
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|ncmp_amg
expr_stmt|;
break|break;
case|case
name|slt_amg
case|:
case|case
name|sle_amg
case|:
case|case
name|sgt_amg
case|:
case|case
name|sge_amg
case|:
case|case
name|seq_amg
case|:
case|case
name|sne_amg
case|:
name|postpr
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|scmp_amg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|off
operator|!=
operator|-
literal|1
condition|)
name|cv
operator|=
name|cvp
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
block|{
goto|goto
name|not_found
goto|;
block|}
block|}
else|else
block|{
name|not_found
label|:
comment|/* No method found, either report or croak */
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|to_sv_amg
case|:
case|case
name|to_av_amg
case|:
case|case
name|to_hv_amg
case|:
case|case
name|to_gv_amg
case|:
case|case
name|to_cv_amg
case|:
comment|/* FAIL safe */
return|return
name|left
return|;
comment|/* Delegate operation to standard mechanisms. */
break|break;
block|}
if|if
condition|(
name|ocvp
operator|&&
operator|(
name|cv
operator|=
name|ocvp
index|[
name|nomethod_amg
index|]
operator|)
condition|)
block|{
comment|/* Call report method */
name|notfound
operator|=
literal|1
expr_stmt|;
name|lr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cvp
operator|&&
operator|(
name|cv
operator|=
name|cvp
index|[
name|nomethod_amg
index|]
operator|)
condition|)
block|{
name|notfound
operator|=
literal|1
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|off
operator|==
operator|-
literal|1
condition|)
name|off
operator|=
name|method
expr_stmt|;
name|msg
operator|=
name|sv_2mortal
argument_list|(
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"Operation `%s': no method found,%sargument %s%s%s%s"
argument_list|,
name|PL_AMG_names
index|[
name|method
operator|+
name|assignshift
index|]
argument_list|,
operator|(
name|flags
operator|&
name|AMGf_unary
condition|?
literal|" "
else|:
literal|"\n\tleft "
operator|)
argument_list|,
name|SvAMAGIC
argument_list|(
name|left
argument_list|)
condition|?
literal|"in overloaded package "
else|:
literal|"has no overloaded magic"
argument_list|,
name|SvAMAGIC
argument_list|(
name|left
argument_list|)
condition|?
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|SvRV
argument_list|(
name|left
argument_list|)
argument_list|)
argument_list|)
else|:
literal|""
argument_list|,
name|SvAMAGIC
argument_list|(
name|right
argument_list|)
condition|?
literal|",\n\tright argument in overloaded package "
else|:
operator|(
name|flags
operator|&
name|AMGf_unary
condition|?
literal|""
else|:
literal|",\n\tright argument has no overloaded magic"
operator|)
argument_list|,
name|SvAMAGIC
argument_list|(
name|right
argument_list|)
condition|?
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|SvRV
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amtp
operator|&&
name|amtp
operator|->
name|fallback
operator|>=
name|AMGfallYES
condition|)
block|{
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"%s"
argument_list|,
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%"
name|SVf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|force_cpy
operator|=
name|force_cpy
operator|||
name|assign
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|notfound
condition|)
block|{
name|DEBUG_o
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %s%s\n"
argument_list|,
name|PL_AMG_names
index|[
name|off
index|]
argument_list|,
name|method
operator|+
name|assignshift
operator|==
name|off
condition|?
literal|""
else|:
literal|" (initially `"
argument_list|,
name|method
operator|+
name|assignshift
operator|==
name|off
condition|?
literal|""
else|:
name|PL_AMG_names
index|[
name|method
operator|+
name|assignshift
index|]
argument_list|,
name|method
operator|+
name|assignshift
operator|==
name|off
condition|?
literal|""
else|:
literal|"')"
argument_list|,
name|flags
operator|&
name|AMGf_unary
condition|?
literal|""
else|:
name|lr
operator|==
literal|1
condition|?
literal|" for right argument"
else|:
literal|" for left argument"
argument_list|,
name|flags
operator|&
name|AMGf_unary
condition|?
literal|" for argument"
else|:
literal|""
argument_list|,
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|,
name|fl
condition|?
literal|",\n\tassignment variant used"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Since we use shallow copy during assignment, we need      * to dublicate the contents, probably calling user-supplied      * version of copy operator      */
comment|/* We need to copy in following cases:      * a) Assignment form was called.      * 		assignshift==1,  assign==T, method + 1 == off      * b) Increment or decrement, called directly.      * 		assignshift==0,  assign==0, method + 0 == off      * c) Increment or decrement, translated to assignment add/subtr.      * 		assignshift==0,  assign==T,      *		force_cpy == T      * d) Increment or decrement, translated to nomethod.      * 		assignshift==0,  assign==0,      *		force_cpy == T      * e) Assignment form translated to nomethod.      * 		assignshift==1,  assign==T, method + 1 != off      *		force_cpy == T      */
comment|/*	off is method, method+assignshift, or a result of opcode substitution.      *	In the latter case assignshift==0, so only notfound case is important.      */
if|if
condition|(
operator|(
operator|(
name|method
operator|+
name|assignshift
operator|==
name|off
operator|)
operator|&&
operator|(
name|assign
operator|||
operator|(
name|method
operator|==
name|inc_amg
operator|)
operator|||
operator|(
name|method
operator|==
name|dec_amg
operator|)
operator|)
operator|)
operator|||
name|force_cpy
condition|)
name|RvDEEPCP
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|{
name|dSP
expr_stmt|;
name|BINOP
name|myop
decl_stmt|;
name|SV
modifier|*
name|res
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|myop
argument_list|,
literal|1
argument_list|,
name|BINOP
argument_list|)
expr_stmt|;
name|myop
operator|.
name|op_last
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
name|myop
operator|.
name|op_flags
operator|=
name|OPf_WANT_SCALAR
operator||
name|OPf_STACKED
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_OVERLOAD
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|PL_op
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|pp_pushmark
argument_list|()
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|notfound
operator|+
literal|5
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|lr
operator|>
literal|0
condition|?
name|right
else|:
name|left
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|lr
operator|>
literal|0
condition|?
name|left
else|:
name|right
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|lr
operator|>
literal|0
condition|?
operator|&
name|PL_sv_yes
else|:
operator|(
name|assign
condition|?
operator|&
name|PL_sv_undef
else|:
operator|&
name|PL_sv_no
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notfound
condition|)
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_AMG_names
index|[
name|method
operator|+
name|assignshift
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|=
name|Perl_pp_entersub
argument_list|(
name|aTHX
argument_list|)
operator|)
condition|)
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|res
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|postpr
condition|)
block|{
name|int
name|ans
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|le_amg
case|:
case|case
name|sle_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|<=
literal|0
expr_stmt|;
break|break;
case|case
name|lt_amg
case|:
case|case
name|slt_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|ge_amg
case|:
case|case
name|sge_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|gt_amg
case|:
case|case
name|sgt_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|>
literal|0
expr_stmt|;
break|break;
case|case
name|eq_amg
case|:
case|case
name|seq_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|ne_amg
case|:
case|case
name|sne_amg
case|:
name|ans
operator|=
name|SvIV
argument_list|(
name|res
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|inc_amg
case|:
case|case
name|dec_amg
case|:
name|SvSetSV
argument_list|(
name|left
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|left
return|;
case|case
name|not_amg
case|:
name|ans
operator|=
operator|!
name|SvTRUE
argument_list|(
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|boolSV
argument_list|(
name|ans
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|method
operator|==
name|copy_amg
condition|)
block|{
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Copy method did not return a reference"
argument_list|)
expr_stmt|;
block|}
return|return
name|SvREFCNT_inc
argument_list|(
name|SvRV
argument_list|(
name|res
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|res
return|;
block|}
block|}
block|}
comment|/* =for apidoc is_gv_magical  Returns C<TRUE> if given the name of a magical GV.  Currently only useful internally when determining if a GV should be created even in rvalue contexts.  C<flags> is not used at present but available for future extension to allow selecting particular classes of magical variable.  =cut */
name|bool
name|Perl_is_gv_magical
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|len
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'I'
case|:
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ISA"
argument_list|)
condition|)
goto|goto
name|yes
goto|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"OVERLOAD"
argument_list|)
condition|)
goto|goto
name|yes
goto|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"SIG"
argument_list|)
condition|)
goto|goto
name|yes
goto|;
break|break;
case|case
literal|'\027'
case|:
comment|/* $^W& $^WARNING_BITS */
if|if
condition|(
name|len
operator|==
literal|1
operator|||
operator|(
name|len
operator|==
literal|12
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"\027ARNING_BITS"
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|17
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"\027IDE_SYSTEM_CALLS"
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|yes
goto|;
block|}
break|break;
case|case
literal|'&'
case|:
case|case
literal|'`'
case|:
case|case
literal|'\''
case|:
case|case
literal|':'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'-'
case|:
case|case
literal|'#'
case|:
case|case
literal|'*'
case|:
case|case
literal|'['
case|:
case|case
literal|'^'
case|:
case|case
literal|'~'
case|:
case|case
literal|'='
case|:
case|case
literal|'%'
case|:
case|case
literal|'.'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|','
case|:
case|case
literal|'\\'
case|:
case|case
literal|'/'
case|:
case|case
literal|'|'
case|:
case|case
literal|'+'
case|:
case|case
literal|';'
case|:
case|case
literal|']'
case|:
case|case
literal|'\001'
case|:
comment|/* $^A */
case|case
literal|'\003'
case|:
comment|/* $^C */
case|case
literal|'\004'
case|:
comment|/* $^D */
case|case
literal|'\005'
case|:
comment|/* $^E */
case|case
literal|'\006'
case|:
comment|/* $^F */
case|case
literal|'\010'
case|:
comment|/* $^H */
case|case
literal|'\011'
case|:
comment|/* $^I, NOT \t in EBCDIC */
case|case
literal|'\014'
case|:
comment|/* $^L */
case|case
literal|'\017'
case|:
comment|/* $^O */
case|case
literal|'\020'
case|:
comment|/* $^P */
case|case
literal|'\023'
case|:
comment|/* $^S */
case|case
literal|'\024'
case|:
comment|/* $^T */
case|case
literal|'\026'
case|:
comment|/* $^V */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
goto|goto
name|yes
goto|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|end
init|=
name|name
operator|+
name|len
decl_stmt|;
while|while
condition|(
operator|--
name|end
operator|>
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|yes
label|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

end_unit

