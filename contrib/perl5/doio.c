begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    doio.c  *  *    Copyright (c) 1991-1997, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "Far below them they saw the white waters pour into a foaming bowl, and  * then swirl darkly about a deep oval basin in the rocks, until they found  * their way out again through a narrow gate, and flowed away, fuming and  * chattering, into calmer and more level reaches."  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MSG
end_ifdef

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SEM
end_ifdef

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SHM
end_ifdef

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_SHMAT_PROTOTYPE
end_ifndef

begin_decl_stmt
specifier|extern
name|Shmat_t
name|shmat
name|_
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_UTIME
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|O_EXCL
end_ifdef

begin_define
define|#
directive|define
name|OPEN_EXCL
value|O_EXCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPEN_EXCL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_SOCKET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_comment
comment|/* VMS handles sockets via vmsish.h */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ENOTSOCK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|I_NET_ERRNO
end_ifdef

begin_include
include|#
directive|include
file|<net/errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put this after #includes because<unistd.h> defines _XOPEN_*. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sock_size_t
end_ifndef

begin_if
if|#
directive|if
name|_XOPEN_VERSION
operator|>=
literal|5
operator|||
name|defined
argument_list|(
name|_XOPEN_SOURCE_EXTENDED
argument_list|)
operator|||
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|Sock_size_t
value|Size_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Sock_size_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|do_open
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|,
specifier|register
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|len
parameter_list|,
name|int
name|as_raw
parameter_list|,
name|int
name|rawmode
parameter_list|,
name|int
name|rawperm
parameter_list|,
name|PerlIO
modifier|*
name|supplied_fp
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|PerlIO
modifier|*
name|saveifp
init|=
name|Nullfp
decl_stmt|;
name|PerlIO
modifier|*
name|saveofp
init|=
name|Nullfp
decl_stmt|;
name|char
name|savetype
init|=
literal|' '
decl_stmt|;
name|int
name|writing
init|=
literal|0
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|result
decl_stmt|;
name|bool
name|was_fdopen
init|=
name|FALSE
decl_stmt|;
name|PL_forkprocess
operator|=
literal|1
expr_stmt|;
comment|/* assume true if no fork */
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'-'
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|<=
name|PL_maxsysfd
condition|)
block|{
name|saveifp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|saveofp
operator|=
name|IoOFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|savetype
operator|=
name|IoTYPE
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'|'
condition|)
name|result
operator|=
name|PerlProc_pclose
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|!=
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EOF
operator|&&
name|fd
operator|>
name|PL_maxsysfd
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Warning: unable to close filehandle %s properly.\n"
argument_list|,
name|GvENAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
block|}
if|if
condition|(
name|as_raw
condition|)
block|{
ifndef|#
directive|ifndef
name|O_ACCMODE
define|#
directive|define
name|O_ACCMODE
value|3
comment|/* Assume traditional implementation */
endif|#
directive|endif
switch|switch
condition|(
name|result
operator|=
name|rawmode
operator|&
name|O_ACCMODE
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'<'
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'>'
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
default|default:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'+'
expr_stmt|;
break|break;
block|}
name|writing
operator|=
operator|(
name|result
operator|>
literal|0
operator|)
expr_stmt|;
name|fd
operator|=
name|PerlLIO_open3
argument_list|(
name|name
argument_list|,
name|rawmode
argument_list|,
name|rawperm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|fpmode
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|O_RDONLY
condition|)
name|fpmode
operator|=
literal|"r"
expr_stmt|;
ifdef|#
directive|ifdef
name|O_APPEND
elseif|else
if|if
condition|(
name|rawmode
operator|&
name|O_APPEND
condition|)
name|fpmode
operator|=
operator|(
name|result
operator|==
name|O_WRONLY
operator|)
condition|?
literal|"a"
else|:
literal|"a+"
expr_stmt|;
endif|#
directive|endif
else|else
name|fpmode
operator|=
operator|(
name|result
operator|==
name|O_WRONLY
operator|)
condition|?
literal|"w"
else|:
literal|"r+"
expr_stmt|;
name|fp
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
name|fpmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|myname
decl_stmt|;
name|char
name|mode
index|[
literal|3
index|]
decl_stmt|;
comment|/* stdio file mode ("r\0" or "r+\0") */
name|int
name|dodup
decl_stmt|;
name|myname
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|name
operator|=
name|myname
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|isSPACE
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
name|mode
index|[
literal|1
index|]
operator|=
name|mode
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
operator|*
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'+'
operator|&&
name|len
operator|>
literal|1
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'|'
condition|)
block|{
comment|/* scary */
name|mode
index|[
literal|1
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
operator|--
name|len
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'|'
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|name
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"piped open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Can't do bidirectional pipe"
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|PerlProc_popen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'>'
condition|)
block|{
name|TAINT_PROPER
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'>'
condition|)
block|{
name|mode
index|[
literal|0
index|]
operator|=
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'a'
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
else|else
name|mode
index|[
literal|0
index|]
operator|=
literal|'w'
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
name|duplicity
label|:
name|dodup
operator|=
literal|1
expr_stmt|;
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'='
condition|)
block|{
name|dodup
operator|=
literal|0
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|name
operator|&&
name|supplied_fp
condition|)
name|fp
operator|=
name|supplied_fp
expr_stmt|;
else|else
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|fd
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|IO
modifier|*
name|thatio
decl_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|thatio
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thatio
condition|)
block|{
ifdef|#
directive|ifdef
name|EINVAL
name|SETERRNO
argument_list|(
name|EINVAL
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|IoIFP
argument_list|(
name|thatio
argument_list|)
condition|)
block|{
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|thatio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|thatio
argument_list|)
operator|==
literal|'s'
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'s'
expr_stmt|;
block|}
else|else
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dodup
condition|)
name|fd
operator|=
name|PerlLIO_dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|was_fdopen
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dodup
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdout
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'<'
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|name
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
goto|goto
name|duplicity
goto|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdin
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|isSPACE
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"piped open"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|PerlProc_popen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'|'
expr_stmt|;
block|}
else|else
block|{
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'<'
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdin
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'<'
operator|&&
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
literal|'|'
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
literal|'-'
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'s'
expr_stmt|;
comment|/* in case a socket was passed in to us */
ifdef|#
directive|ifdef
name|HAS_SOCKET
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|S_IFMT
operator|!
operator|(
name|PL_statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
else|#
directive|else
operator|!
name|PL_statbuf
operator|.
name|st_mode
endif|#
directive|endif
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|Sock_size_t
name|buflen
init|=
sizeof|sizeof
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|PerlSock_getsockname
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|tmpbuf
argument_list|,
operator|&
name|buflen
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOTSOCK
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|'s'
expr_stmt|;
comment|/* some OS's return 0 on fstat()ed socket */
comment|/* but some return 0 for streams too, sigh */
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|saveifp
condition|)
block|{
comment|/* must use old fp? */
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|saveifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveofp
condition|)
block|{
name|PerlIO_flush
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
comment|/* emulate PerlIO_close() */
if|if
condition|(
name|saveofp
operator|!=
name|saveifp
condition|)
block|{
comment|/* was a socket? */
name|PerlIO_close
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|2
condition|)
name|Safefree
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|pid
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|PerlLIO_dup2
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|pid
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pid
expr_stmt|;
if|if
condition|(
operator|!
name|was_fdopen
condition|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|saveifp
expr_stmt|;
name|PerlIO_clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|writing
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'s'
operator|||
operator|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'>'
operator|&&
name|S_ISCHR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
block|}
else|else
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|fp
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|say_false
label|:
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|saveifp
expr_stmt|;
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|saveofp
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|savetype
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|PerlIO
modifier|*
name|nextargv
parameter_list|(
specifier|register
name|GV
modifier|*
name|gv
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|int
name|filedev
decl_stmt|;
name|int
name|fileino
decl_stmt|;
endif|#
directive|endif
name|int
name|fileuid
decl_stmt|;
name|int
name|filegid
decl_stmt|;
if|if
condition|(
operator|!
name|PL_argvoutgv
condition|)
name|PL_argvoutgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"ARGVOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_filemode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
name|PerlIO_flush
argument_list|(
name|IoIFP
argument_list|(
name|GvIOn
argument_list|(
name|PL_argvoutgv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chmod must follow last write */
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|PL_lastfd
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|PerlLIO_chmod
argument_list|(
name|PL_oldname
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|PL_filemode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|av_len
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|dTHR
expr_stmt|;
name|STRLEN
name|oldlen
decl_stmt|;
name|sv
operator|=
name|av_shift
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_oldname
operator|=
name|SvPVx
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open
argument_list|(
name|gv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_inplace
condition|)
block|{
name|TAINT_PROPER
argument_list|(
literal|"inplace open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlen
operator|==
literal|1
operator|&&
operator|*
name|PL_oldname
operator|==
literal|'-'
condition|)
block|{
name|setdefout
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|filedev
operator|=
name|PL_statbuf
operator|.
name|st_dev
expr_stmt|;
name|fileino
operator|=
name|PL_statbuf
operator|.
name|st_ino
expr_stmt|;
endif|#
directive|endif
name|PL_filemode
operator|=
name|PL_statbuf
operator|.
name|st_mode
expr_stmt|;
name|fileuid
operator|=
name|PL_statbuf
operator|.
name|st_uid
expr_stmt|;
name|filegid
operator|=
name|PL_statbuf
operator|.
name|st_gid
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|PL_filemode
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Can't do inplace edit: %s is not a regular file"
argument_list|,
name|PL_oldname
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|PL_inplace
condition|)
block|{
name|char
modifier|*
name|star
init|=
name|strchr
argument_list|(
name|PL_inplace
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
if|if
condition|(
name|star
condition|)
block|{
name|char
modifier|*
name|begin
init|=
name|PL_inplace
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|begin
argument_list|,
name|star
operator|-
name|begin
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
name|begin
operator|=
operator|++
name|star
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|star
operator|=
name|strchr
argument_list|(
name|begin
argument_list|,
literal|'*'
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
operator|*
name|begin
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PL_inplace
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FLEXFILENAMES
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|PL_statbuf
operator|.
name|st_dev
operator|==
name|filedev
operator|&&
name|PL_statbuf
operator|.
name|st_ino
operator|==
name|fileino
ifdef|#
directive|ifdef
name|DJGPP
operator|||
operator|(
name|_djstat_fail_bits
operator|&
name|_STFAIL_TRUENAME
operator|)
operator|!=
literal|0
endif|#
directive|endif
condition|)
block|{
name|warn
argument_list|(
literal|"Can't do inplace edit: %s would not be uniq"
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RENAME
ifndef|#
directive|ifndef
name|DOSISH
if|if
condition|(
name|PerlLIO_rename
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_unlink
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_rename
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|do_open
argument_list|(
name|gv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DOSISH */
else|#
directive|else
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|PL_oldname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
ifndef|#
directive|ifndef
name|VMS
comment|/* Don't delete; use automatic file versioning */
if|if
condition|(
name|UNLINK
argument_list|(
name|PL_oldname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't remove %s: %s, skipping file"
argument_list|,
name|PL_oldname
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
else|#
directive|else
name|croak
argument_list|(
literal|"Can't do inplace edit without backup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|">"
argument_list|,
operator|!
name|PL_inplace
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in case sprintf set errno */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|do_open
argument_list|(
name|PL_argvoutgv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|do_open
argument_list|(
name|PL_argvoutgv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|OPEN_EXCL
argument_list|,
literal|0666
argument_list|,
name|Nullfp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|warn
argument_list|(
literal|"Can't do inplace edit on %s: %s"
argument_list|,
name|PL_oldname
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|setdefout
argument_list|(
name|PL_argvoutgv
argument_list|)
expr_stmt|;
name|PL_lastfd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|PL_argvoutgv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_fstat
argument_list|(
name|PL_lastfd
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|PL_lastfd
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|)
comment|/* Borland runtime creates a readonly file! */
operator|(
name|void
operator|)
name|PerlLIO_chmod
argument_list|(
name|PL_oldname
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|fileuid
operator|!=
name|PL_statbuf
operator|.
name|st_uid
operator|||
name|filegid
operator|!=
name|PL_statbuf
operator|.
name|st_gid
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_FCHOWN
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|PL_lastfd
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_CHOWN
operator|(
name|void
operator|)
name|PerlLIO_chown
argument_list|(
name|PL_oldname
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
return|return
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
block|}
else|else
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Can't open %s: %s\n"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_inplace
condition|)
block|{
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|PL_argvoutgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|setdefout
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullfp
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_PIPE
name|void
name|do_pipe
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|rgv
parameter_list|,
name|GV
modifier|*
name|wgv
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|rstio
decl_stmt|;
specifier|register
name|IO
modifier|*
name|wstio
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|rgv
condition|)
goto|goto
name|badexit
goto|;
if|if
condition|(
operator|!
name|wgv
condition|)
goto|goto
name|badexit
goto|;
name|rstio
operator|=
name|GvIOn
argument_list|(
name|rgv
argument_list|)
expr_stmt|;
name|wstio
operator|=
name|GvIOn
argument_list|(
name|wgv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|rgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|wgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoIFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|IoOFP
argument_list|(
name|wstio
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|rstio
argument_list|)
operator|=
literal|'<'
expr_stmt|;
name|IoTYPE
argument_list|(
name|wstio
argument_list|)
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
return|return;
name|badexit
label|:
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* explicit renamed to avoid C++ conflict    -- kja */
name|bool
name|do_close
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|,
name|bool
name|not_implicit
parameter_list|)
block|{
name|bool
name|retval
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
name|gv
operator|=
name|PL_argvgv
expr_stmt|;
if|if
condition|(
operator|!
name|gv
operator|||
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|not_implicit
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
block|{
comment|/* never opened */
if|if
condition|(
name|not_implicit
condition|)
block|{
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Close on unopened file<%s>"
argument_list|,
name|GvENAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|retval
operator|=
name|io_close
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_implicit
condition|)
block|{
name|IoLINES
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IoPAGE
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|=
name|IoPAGE_LEN
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
literal|' '
expr_stmt|;
return|return
name|retval
return|;
block|}
name|bool
name|io_close
parameter_list|(
name|IO
modifier|*
name|io
parameter_list|)
block|{
name|bool
name|retval
init|=
name|FALSE
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'|'
condition|)
block|{
name|status
operator|=
name|PerlProc_pclose
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|STATUS_NATIVE_SET
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|STATUS_POSIX
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
literal|'-'
condition|)
name|retval
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|&&
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|!=
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
comment|/* a socket */
name|retval
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|retval
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
block|}
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
block|}
else|else
block|{
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
name|bool
name|do_eof
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|PerlIO_has_cntptr
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
block|{
comment|/* (the code works without this) */
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
comment|/* cheat a little, since */
return|return
name|FALSE
return|;
comment|/* this is the most usual case */
block|}
name|ch
operator|=
name|PerlIO_getc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_ungetc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|PerlIO_has_cntptr
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|&&
name|PerlIO_canset_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|<
operator|-
literal|1
condition|)
name|PerlIO_set_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
comment|/* not necessarily a real EOF yet? */
if|if
condition|(
operator|!
name|nextargv
argument_list|(
name|PL_argvgv
argument_list|)
condition|)
comment|/* get another fp handy */
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* normal fp, definitely end of file */
block|}
return|return
name|TRUE
return|;
block|}
name|long
name|do_tell
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|PerlIO_tell
argument_list|(
name|fp
argument_list|)
return|;
block|}
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"tell() on unopened file"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1L
return|;
block|}
name|bool
name|do_seek
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|,
name|long
name|int
name|pos
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
name|whence
argument_list|)
operator|>=
literal|0
return|;
block|}
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"seek() on unopened file"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|long
name|do_sysseek
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|,
name|long
name|int
name|pos
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
return|return
name|PerlLIO_lseek
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|pos
argument_list|,
name|whence
argument_list|)
return|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"sysseek() on unopened file"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1L
return|;
block|}
name|int
name|do_binmode
parameter_list|(
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|int
name|iotype
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
name|flag
operator|!=
name|TRUE
condition|)
name|croak
argument_list|(
literal|"panic: unsetting binmode"
argument_list|)
expr_stmt|;
comment|/* Not implemented yet */
ifdef|#
directive|ifdef
name|DOSISH
ifdef|#
directive|ifdef
name|atarist
if|if
condition|(
operator|!
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|fp
operator|->
name|_flag
operator||=
name|_IOBIN
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|PerlLIO_setmode
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|OP_BINARY
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* The translation mode of the stream is maintained independent 	 * of the translation mode of the fd in the Borland RTL (heavy 	 * digging through their runtime sources reveal).  User has to 	 * set the mode explicitly for the stream (though they don't 	 * document this anywhere). GSAR 97-5-24 	 */
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FILE
operator|*
operator|)
name|fp
operator|)
operator|->
name|flags
operator||=
name|_F_BIN
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|USEMYBINMODE
argument_list|)
if|if
condition|(
name|my_binmode
argument_list|(
name|fp
argument_list|,
name|iotype
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_TRUNCATE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_CHSIZE
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_FREESP
argument_list|)
comment|/* code courtesy of William Kucharski */
define|#
directive|define
name|HAS_CHSIZE
name|I32
name|my_chsize
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|I32
name|fd
decl_stmt|;
comment|/* file descriptor */
name|Off_t
name|length
decl_stmt|;
comment|/* length to set file to */
block|{
name|struct
name|flock
name|fl
decl_stmt|;
name|struct
name|stat
name|filebuf
decl_stmt|;
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|filebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|filebuf
operator|.
name|st_size
operator|<
name|length
condition|)
block|{
comment|/* extend file length */
if|if
condition|(
operator|(
name|PerlLIO_lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write a "0" byte */
if|if
condition|(
operator|(
name|PerlLIO_write
argument_list|(
name|fd
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* truncate length */
name|fl
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
name|length
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
comment|/* write lock on file space */
comment|/* 	* This relies on the UNDOCUMENTED F_FREESP argument to 	* fcntl(2), which truncates the file so that it ends at the 	* position indicated by fl.l_start. 	* 	* Will minor miracles never cease? 	*/
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_FREESP
argument_list|,
operator|&
name|fl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* F_FREESP */
name|bool
name|do_print
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|PerlIO
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
comment|/* assuming fp is checked earlier */
if|if
condition|(
operator|!
name|sv
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|PL_ofmt
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
name|PL_ofmt
argument_list|,
operator|(
name|double
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
operator|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|&&
name|sv_2nv
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
operator|)
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
name|PL_ofmt
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|SVt_IV
case|:
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
comment|/* FALL THROUGH */
default|default:
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|&&
operator|(
name|PerlIO_write
argument_list|(
name|fp
argument_list|,
name|tmps
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|||
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
name|I32
name|my_stat
parameter_list|(
name|ARGSproto
parameter_list|)
block|{
name|djSP
expr_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|tmpgv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmpgv
operator|=
name|cGVOP
operator|->
name|op_gv
expr_stmt|;
name|do_fstat
label|:
name|io
operator|=
name|GvIO
argument_list|(
name|tmpgv
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|&&
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|PL_statgv
operator|=
name|tmpgv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_laststype
operator|=
name|OP_STAT
expr_stmt|;
return|return
operator|(
name|PL_laststatval
operator|=
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|tmpgv
operator|==
name|PL_defgv
condition|)
return|return
name|PL_laststatval
return|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Stat on unopened file<%s>"
argument_list|,
name|GvENAME
argument_list|(
name|tmpgv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|PL_laststatval
operator|=
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|tmpgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|tmpgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PL_laststype
operator|=
name|OP_STAT
expr_stmt|;
name|PL_laststatval
operator|=
name|PerlLIO_stat
argument_list|(
name|s
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
operator|&&
name|PL_dowarn
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"stat"
argument_list|)
expr_stmt|;
return|return
name|PL_laststatval
return|;
block|}
block|}
name|I32
name|my_lstat
parameter_list|(
name|ARGSproto
parameter_list|)
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cGVOP
operator|->
name|op_gv
operator|==
name|PL_defgv
condition|)
block|{
if|if
condition|(
name|PL_laststype
operator|!=
name|OP_LSTAT
condition|)
name|croak
argument_list|(
literal|"The stat preceding -l _ wasn't an lstat"
argument_list|)
expr_stmt|;
return|return
name|PL_laststatval
return|;
block|}
name|croak
argument_list|(
literal|"You can't use -l on a filehandle"
argument_list|)
expr_stmt|;
block|}
name|PL_laststype
operator|=
name|OP_LSTAT
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_LSTAT
name|PL_laststatval
operator|=
name|PerlLIO_lstat
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
else|#
directive|else
name|PL_laststatval
operator|=
name|PerlLIO_stat
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
operator|&&
name|PL_dowarn
operator|&&
name|strchr
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"lstat"
argument_list|)
expr_stmt|;
return|return
name|PL_laststatval
return|;
block|}
name|bool
name|do_aexec
parameter_list|(
name|SV
modifier|*
name|really
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
if|if
condition|(
name|sp
operator|>
name|mark
condition|)
block|{
name|dTHR
expr_stmt|;
name|New
argument_list|(
literal|401
argument_list|,
name|PL_Argv
argument_list|,
name|sp
operator|-
name|mark
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|a
operator|=
name|PL_Argv
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|mark
condition|)
operator|*
name|a
operator|++
operator|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
else|else
operator|*
name|a
operator|++
operator|=
literal|""
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
operator|*
name|PL_Argv
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
comment|/* will execvp use PATH? */
name|TAINT_ENV
argument_list|()
expr_stmt|;
comment|/* testing IFS here is overkill, probably */
if|if
condition|(
name|really
operator|&&
operator|*
operator|(
name|tmps
operator|=
name|SvPV
argument_list|(
name|really
argument_list|,
name|PL_na
argument_list|)
operator|)
condition|)
name|PerlProc_execvp
argument_list|(
name|tmps
argument_list|,
name|PL_Argv
argument_list|)
expr_stmt|;
else|else
name|PerlProc_execvp
argument_list|(
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|PL_Argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Can't exec \"%s\": %s"
argument_list|,
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_execfree
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|void
name|do_execfree
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|PL_Argv
condition|)
block|{
name|Safefree
argument_list|(
name|PL_Argv
argument_list|)
expr_stmt|;
name|PL_Argv
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_Cmd
condition|)
block|{
name|Safefree
argument_list|(
name|PL_Cmd
argument_list|)
expr_stmt|;
name|PL_Cmd
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DJGPP
argument_list|)
name|bool
name|do_exec
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|flags
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|&&
name|isSPACE
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/* save an extra exec if possible */
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
name|strnEQ
argument_list|(
name|cmd
argument_list|,
name|PL_cshname
argument_list|,
name|PL_cshlen
argument_list|)
operator|&&
name|strnEQ
argument_list|(
name|cmd
operator|+
name|PL_cshlen
argument_list|,
literal|" -c"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|flags
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
name|s
operator|=
name|cmd
operator|+
name|PL_cshlen
operator|+
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\''
condition|)
block|{
name|char
modifier|*
name|ncmd
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
name|PerlProc_execl
argument_list|(
name|PL_cshname
argument_list|,
literal|"csh"
argument_list|,
name|flags
argument_list|,
name|ncmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\''
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* CSH */
comment|/* see if there are shell metacharacters in it */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'.'
operator|&&
name|isSPACE
argument_list|(
name|cmd
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|doshell
goto|;
if|if
condition|(
name|strnEQ
argument_list|(
name|cmd
argument_list|,
literal|"exec"
argument_list|,
literal|4
argument_list|)
operator|&&
name|isSPACE
argument_list|(
name|cmd
index|[
literal|4
index|]
argument_list|)
condition|)
goto|goto
name|doshell
goto|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* catch VAR=val gizmo */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
goto|goto
name|doshell
goto|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|!
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"$&*(){}[]'\";\\|?<>~`\n"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|doshell
label|:
name|PerlProc_execl
argument_list|(
name|PL_sh_path
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|New
argument_list|(
literal|402
argument_list|,
name|PL_Argv
argument_list|,
operator|(
name|s
operator|-
name|cmd
operator|)
operator|/
literal|2
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|PL_Cmd
operator|=
name|savepvn
argument_list|(
name|cmd
argument_list|,
name|s
operator|-
name|cmd
argument_list|)
expr_stmt|;
name|a
operator|=
name|PL_Argv
expr_stmt|;
for|for
control|(
name|s
operator|=
name|PL_Cmd
init|;
operator|*
name|s
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
operator|(
name|a
operator|++
operator|)
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|PL_Argv
index|[
literal|0
index|]
condition|)
block|{
name|PerlProc_execvp
argument_list|(
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|PL_Argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
comment|/* for system V NIH syndrome */
name|do_execfree
argument_list|()
expr_stmt|;
goto|goto
name|doshell
goto|;
block|}
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Can't exec \"%s\": %s"
argument_list|,
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|Strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|do_execfree
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* OS2 || WIN32 */
name|I32
name|apply
parameter_list|(
name|I32
name|type
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|val
decl_stmt|;
specifier|register
name|I32
name|val2
decl_stmt|;
specifier|register
name|I32
name|tot
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldmark
init|=
name|mark
decl_stmt|;
define|#
directive|define
name|APPLY_TAINT_PROPER
parameter_list|()
define|\
value|STMT_START {							\ 	if (PL_tainting&& PL_tainted) { goto taint_proper_label; }	\     } STMT_END
comment|/* This is a first heuristic; it doesn't catch tainting magic. */
if|if
condition|(
name|PL_tainting
condition|)
block|{
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
if|if
condition|(
name|SvTAINTED
argument_list|(
operator|*
name|mark
argument_list|)
condition|)
block|{
name|TAINT
expr_stmt|;
break|break;
block|}
block|}
name|mark
operator|=
name|oldmark
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_CHMOD
case|:
name|what
operator|=
literal|"chmod"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|PL_na
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_chmod
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_CHOWN
case|case
name|OP_CHOWN
case|:
name|what
operator|=
literal|"chown"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|-
name|mark
operator|>
literal|2
condition|)
block|{
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|val2
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|PL_na
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_chown
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|val2
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/*  XXX Should we make lchown() directly available from perl? For now, we'll let Configure test for HAS_LCHOWN, but do nothing in the core.     --AD  5/1998 */
ifdef|#
directive|ifdef
name|HAS_KILL
case|case
name|OP_KILL
case|:
name|what
operator|=
literal|"kill"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|mark
operator|==
name|sp
condition|)
break|break;
name|s
operator|=
name|SvPVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'S'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'G'
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|whichsig
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|croak
argument_list|(
literal|"Unrecognized signal name \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* kill() doesn't do process groups (job trees?) under VMS */
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SIGKILL
condition|)
block|{
include|#
directive|include
file|<starlet.h>
comment|/* Use native sys$delprc() to insure that target process is 	     * deleted; supervisor-mode images don't pay attention to 	     * CRTL's emulation of Unix-style signals and kill() 	     */
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|long
name|int
name|__vmssts
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|__vmssts
operator|=
name|sys$delprc
argument_list|(
operator|&
name|proc
argument_list|,
literal|0
argument_list|)
operator|)
operator|&
literal|1
operator|)
condition|)
block|{
name|tot
operator|--
expr_stmt|;
switch|switch
condition|(
name|__vmssts
condition|)
block|{
case|case
name|SS$_NONEXPR
case|:
case|case
name|SS$_NOSUCHNODE
case|:
name|SETERRNO
argument_list|(
name|ESRCH
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS$_NOPRIV
case|:
name|SETERRNO
argument_list|(
name|EPERM
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SETERRNO
argument_list|(
name|EVMSERR
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_KILLPG
if|if
condition|(
name|PerlProc_killpg
argument_list|(
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* BSD */
else|#
directive|else
if|if
condition|(
name|PerlProc_kill
argument_list|(
operator|-
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* SYSV */
endif|#
directive|endif
name|tot
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlProc_kill
argument_list|(
name|proc
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|OP_UNLINK
case|:
name|what
operator|=
literal|"unlink"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|s
operator|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_euid
operator|||
name|PL_unsafe
condition|)
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* don't let root wipe out directories without -U */
ifdef|#
directive|ifdef
name|HAS_LSTAT
if|if
condition|(
name|PerlLIO_lstat
argument_list|(
name|s
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|s
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
endif|#
directive|endif
name|tot
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_UTIME
case|case
name|OP_UTIME
case|:
name|what
operator|=
literal|"utime"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|-
name|mark
operator|>
literal|2
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|I_UTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
name|struct
name|utimbuf
name|utbuf
decl_stmt|;
else|#
directive|else
struct|struct
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
name|utbuf
struct|;
endif|#
directive|endif
name|Zero
argument_list|(
operator|&
name|utbuf
argument_list|,
sizeof|sizeof
name|utbuf
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_TIME
name|utbuf
operator|.
name|actime
operator|=
operator|(
name|Time_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time accessed */
name|utbuf
operator|.
name|modtime
operator|=
operator|(
name|Time_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time modified */
else|#
directive|else
name|utbuf
operator|.
name|actime
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time accessed */
name|utbuf
operator|.
name|modtime
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time modified */
endif|#
directive|endif
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|PL_na
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_utime
argument_list|(
name|name
argument_list|,
operator|&
name|utbuf
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
else|else
name|tot
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
return|return
name|tot
return|;
name|taint_proper_label
label|:
name|TAINT_PROPER
argument_list|(
name|what
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* this should never happen */
undef|#
directive|undef
name|APPLY_TAINT_PROPER
block|}
comment|/* Do the permissions allow some operation?  Assumes statcache already set. */
ifndef|#
directive|ifndef
name|VMS
comment|/* VMS' cando is in vms.c */
name|I32
name|cando
parameter_list|(
name|I32
name|bit
parameter_list|,
name|I32
name|effective
parameter_list|,
specifier|register
name|struct
name|stat
modifier|*
name|statbufp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DOSISH
comment|/* [Comments and code from Len Reed]      * MS-DOS "user" is similar to UNIX's "superuser," but can't write      * to write-protected files.  The execute permission bit is set      * by the Miscrosoft C library stat() function for the following:      *		.exe files      *		.com files      *		.bat files      *		directories      * All files and directories are readable.      * Directories and special files, e.g. "CON", cannot be      * write-protected.      * [Comment by Tom Dinger -- a directory can have the write-protect      *		bit set in the file system, but DOS permits changes to      *		the directory anyway.  In addition, all bets are off      *		here for networked software, such as Novell and      *		Sun's PC-NFS.]      */
comment|/* Atari stat() does pretty much the same thing. we set x_bit_set_in_stat       * too so it will actually look into the files for magic numbers       */
return|return
operator|(
name|bit
operator|&
name|statbufp
operator|->
name|st_mode
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
else|#
directive|else
comment|/* ! DOSISH */
if|if
condition|(
operator|(
name|effective
condition|?
name|PL_euid
else|:
name|PL_uid
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* root is special */
if|if
condition|(
name|bit
operator|==
name|S_IXUSR
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
literal|0111
operator|||
name|S_ISDIR
argument_list|(
name|statbufp
operator|->
name|st_mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* root reads and writes anything */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|statbufp
operator|->
name|st_uid
operator|==
operator|(
name|effective
condition|?
name|PL_euid
else|:
name|PL_uid
operator|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "user" */
block|}
elseif|else
if|if
condition|(
name|ingroup
argument_list|(
operator|(
name|I32
operator|)
name|statbufp
operator|->
name|st_gid
argument_list|,
name|effective
argument_list|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
operator|>>
literal|3
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "group" */
block|}
elseif|else
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
operator|>>
literal|6
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "other" */
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* ! DOSISH */
block|}
endif|#
directive|endif
comment|/* ! VMS */
name|I32
name|ingroup
parameter_list|(
name|I32
name|testgid
parameter_list|,
name|I32
name|effective
parameter_list|)
block|{
if|if
condition|(
name|testgid
operator|==
operator|(
name|effective
condition|?
name|PL_egid
else|:
name|PL_gid
operator|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|HAS_GETGROUPS
ifndef|#
directive|ifndef
name|NGROUPS
define|#
directive|define
name|NGROUPS
value|32
endif|#
directive|endif
block|{
name|Groups_t
name|gary
index|[
name|NGROUPS
index|]
decl_stmt|;
name|I32
name|anum
decl_stmt|;
name|anum
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gary
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|anum
operator|>=
literal|0
condition|)
if|if
condition|(
name|gary
index|[
name|anum
index|]
operator|==
name|testgid
condition|)
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
name|I32
name|do_ipcget
parameter_list|(
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|key_t
name|key
decl_stmt|;
name|I32
name|n
decl_stmt|,
name|flags
decl_stmt|;
name|key
operator|=
operator|(
name|key_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|OP_MSGGET
operator|)
condition|?
literal|0
else|:
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGGET
case|:
return|return
name|msgget
argument_list|(
name|key
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMGET
case|:
return|return
name|semget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMGET
case|:
return|return
name|shmget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|croak
argument_list|(
literal|"%s not implemented"
argument_list|,
name|op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|-
literal|1
return|;
comment|/* should never happen */
block|}
name|I32
name|do_ipcctl
parameter_list|(
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|astr
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|n
decl_stmt|,
name|cmd
decl_stmt|,
name|infosize
decl_stmt|,
name|getinfo
decl_stmt|;
name|I32
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|OP_SEMCTL
operator|)
condition|?
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
else|:
literal|0
expr_stmt|;
name|cmd
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|astr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|infosize
operator|=
literal|0
expr_stmt|;
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|IPC_STAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|shmid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|GETALL
operator|||
name|cmd
operator|==
name|SETALL
condition|)
block|{
name|struct
name|semid_ds
name|semds
decl_stmt|;
name|union
name|semun
name|semun
decl_stmt|;
name|semun
operator|.
name|buf
operator|=
operator|&
name|semds
expr_stmt|;
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|GETALL
operator|)
expr_stmt|;
if|if
condition|(
name|Semctl
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|IPC_STAT
argument_list|,
name|semun
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|infosize
operator|=
name|semds
operator|.
name|sem_nsems
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* "short" is technically wrong but much more portable 		   than guessing about u_?short(_t)? */
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|croak
argument_list|(
literal|"%s not implemented"
argument_list|,
name|op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|infosize
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|getinfo
condition|)
block|{
name|SvPV_force
argument_list|(
name|astr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|a
operator|=
name|SvGROW
argument_list|(
name|astr
argument_list|,
name|infosize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|SvPV
argument_list|(
name|astr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|infosize
condition|)
name|croak
argument_list|(
literal|"Bad arg length for %s, is %lu, should be %ld"
argument_list|,
name|op_desc
index|[
name|optype
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|long
operator|)
name|infosize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IV
name|i
init|=
name|SvIV
argument_list|(
name|astr
argument_list|)
decl_stmt|;
name|a
operator|=
operator|(
name|char
operator|*
operator|)
name|i
expr_stmt|;
comment|/* ouch */
block|}
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGCTL
case|:
name|ret
operator|=
name|msgctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|msqid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMCTL
case|:
block|{
name|union
name|semun
name|unsemds
decl_stmt|;
name|unsemds
operator|.
name|buf
operator|=
operator|(
expr|struct
name|semid_ds
operator|*
operator|)
name|a
expr_stmt|;
name|ret
operator|=
name|Semctl
argument_list|(
name|id
argument_list|,
name|n
argument_list|,
name|cmd
argument_list|,
name|unsemds
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMCTL
case|:
name|ret
operator|=
name|shmctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|shmid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|getinfo
operator|&&
name|ret
operator|>=
literal|0
condition|)
block|{
name|SvCUR_set
argument_list|(
name|astr
argument_list|,
name|infosize
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|astr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|astr
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|I32
name|do_msgsnd
parameter_list|(
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvPV
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msize
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"Arg too short for msgsnd"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|msgsnd
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|flags
argument_list|)
return|;
else|#
directive|else
name|croak
argument_list|(
literal|"msgsnd not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|I32
name|do_msgrcv
parameter_list|(
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|,
name|ret
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|msize
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mtype
operator|=
operator|(
name|long
operator|)
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|mstr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|mstr
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't msgrcv to readonly var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|mstr
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
block|}
name|SvPV_force
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvGROW
argument_list|(
name|mstr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|msgrcv
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|mtype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|SvCUR_set
argument_list|(
name|mstr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|ret
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|mstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ret
return|;
else|#
directive|else
name|croak
argument_list|(
literal|"msgrcv not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|I32
name|do_semop
parameter_list|(
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_SEM
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|opstr
decl_stmt|;
name|char
modifier|*
name|opbuf
decl_stmt|;
name|I32
name|id
decl_stmt|;
name|STRLEN
name|opsize
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|opstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|opbuf
operator|=
name|SvPV
argument_list|(
name|opstr
argument_list|,
name|opsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|opsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|||
operator|(
name|opsize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SETERRNO
argument_list|(
name|EINVAL
argument_list|,
name|LIB$_INVARG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|semop
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|sembuf
operator|*
operator|)
name|opbuf
argument_list|,
name|opsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|croak
argument_list|(
literal|"semop not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|I32
name|do_shmio
parameter_list|(
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_SHM
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|shm
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|mpos
decl_stmt|,
name|msize
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|struct
name|shmid_ds
name|shmds
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|mpos
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|msize
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmctl
argument_list|(
name|id
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|shmds
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mpos
operator|<
literal|0
operator|||
name|msize
operator|<
literal|0
operator|||
name|mpos
operator|+
name|msize
operator|>
name|shmds
operator|.
name|shm_segsz
condition|)
block|{
name|SETERRNO
argument_list|(
name|EFAULT
argument_list|,
name|SS$_ACCVIO
argument_list|)
expr_stmt|;
comment|/* can't do as caller requested */
return|return
operator|-
literal|1
return|;
block|}
name|shm
operator|=
operator|(
name|char
operator|*
operator|)
name|shmat
argument_list|(
name|id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|optype
operator|==
name|OP_SHMREAD
operator|)
condition|?
name|SHM_RDONLY
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shm
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
comment|/* I hate System V IPC, I really do */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|optype
operator|==
name|OP_SHMREAD
condition|)
block|{
name|SvPV_force
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvGROW
argument_list|(
name|mstr
argument_list|,
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|shm
operator|+
name|mpos
argument_list|,
name|mbuf
argument_list|,
name|msize
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|mstr
argument_list|,
name|msize
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|mstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I32
name|n
decl_stmt|;
name|mbuf
operator|=
name|SvPV
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|len
operator|)
operator|>
name|msize
condition|)
name|n
operator|=
name|msize
expr_stmt|;
name|Copy
argument_list|(
name|mbuf
argument_list|,
name|shm
operator|+
name|mpos
argument_list|,
name|n
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|msize
condition|)
name|memzero
argument_list|(
name|shm
operator|+
name|mpos
operator|+
name|n
argument_list|,
name|msize
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|shmdt
argument_list|(
name|shm
argument_list|)
return|;
else|#
directive|else
name|croak
argument_list|(
literal|"shm I/O not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV IPC */
end_comment

end_unit

