begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    doio.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "Far below them they saw the white waters pour into a foaming bowl, and  * then swirl darkly about a deep oval basin in the rocks, until they found  * their way out again through a narrow gate, and flowed away, fuming and  * chattering, into calmer and more level reaches."  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_DOIO_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_SEM
end_ifndef

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MSG
end_ifdef

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SHM
end_ifdef

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_SHMAT_PROTOTYPE
end_ifndef

begin_function_decl
specifier|extern
name|Shmat_t
name|shmat
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_UTIME
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|O_EXCL
end_ifdef

begin_define
define|#
directive|define
name|OPEN_EXCL
value|O_EXCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPEN_EXCL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|Perl_do_open
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
specifier|register
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|len
parameter_list|,
name|int
name|as_raw
parameter_list|,
name|int
name|rawmode
parameter_list|,
name|int
name|rawperm
parameter_list|,
name|PerlIO
modifier|*
name|supplied_fp
parameter_list|)
block|{
return|return
name|do_open9
argument_list|(
name|gv
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|as_raw
argument_list|,
name|rawmode
argument_list|,
name|rawperm
argument_list|,
name|supplied_fp
argument_list|,
name|Nullsv
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_open9
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
specifier|register
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|len
parameter_list|,
name|int
name|as_raw
parameter_list|,
name|int
name|rawmode
parameter_list|,
name|int
name|rawperm
parameter_list|,
name|PerlIO
modifier|*
name|supplied_fp
parameter_list|,
name|SV
modifier|*
name|svs
parameter_list|,
name|I32
name|num_svs
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
init|=
name|GvIOn
argument_list|(
name|gv
argument_list|)
decl_stmt|;
name|PerlIO
modifier|*
name|saveifp
init|=
name|Nullfp
decl_stmt|;
name|PerlIO
modifier|*
name|saveofp
init|=
name|Nullfp
decl_stmt|;
name|char
name|savetype
init|=
name|IoTYPE_CLOSED
decl_stmt|;
name|int
name|writing
init|=
literal|0
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|result
decl_stmt|;
name|bool
name|was_fdopen
init|=
name|FALSE
decl_stmt|;
name|bool
name|in_raw
init|=
literal|0
decl_stmt|,
name|in_crlf
init|=
literal|0
decl_stmt|,
name|out_raw
init|=
literal|0
decl_stmt|,
name|out_crlf
init|=
literal|0
decl_stmt|;
name|PL_forkprocess
operator|=
literal|1
expr_stmt|;
comment|/* assume true if no fork */
if|if
condition|(
name|PL_op
operator|&&
name|PL_op
operator|->
name|op_type
operator|==
name|OP_OPEN
condition|)
block|{
comment|/* set up disciplines */
name|U8
name|flags
init|=
name|PL_op
operator|->
name|op_private
decl_stmt|;
name|in_raw
operator|=
operator|(
name|flags
operator|&
name|OPpOPEN_IN_RAW
operator|)
expr_stmt|;
name|in_crlf
operator|=
operator|(
name|flags
operator|&
name|OPpOPEN_IN_CRLF
operator|)
expr_stmt|;
name|out_raw
operator|=
operator|(
name|flags
operator|&
name|OPpOPEN_OUT_RAW
operator|)
expr_stmt|;
name|out_crlf
operator|=
operator|(
name|flags
operator|&
name|OPpOPEN_OUT_CRLF
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_STD
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|<=
name|PL_maxsysfd
condition|)
block|{
name|saveifp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|saveofp
operator|=
name|IoOFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|savetype
operator|=
name|IoTYPE
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_PIPE
condition|)
name|result
operator|=
name|PerlProc_pclose
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|!=
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EOF
operator|&&
name|fd
operator|>
name|PL_maxsysfd
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"Warning: unable to close filehandle %s properly.\n"
argument_list|,
name|GvENAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
block|}
if|if
condition|(
name|as_raw
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_64_BIT_RAWIO
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_LARGEFILE
argument_list|)
name|rawmode
operator||=
name|O_LARGEFILE
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|O_ACCMODE
define|#
directive|define
name|O_ACCMODE
value|3
comment|/* Assume traditional implementation */
endif|#
directive|endif
switch|switch
condition|(
name|result
operator|=
name|rawmode
operator|&
name|O_ACCMODE
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_WRONLY
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
default|default:
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_RDWR
expr_stmt|;
break|break;
block|}
name|writing
operator|=
operator|(
name|result
operator|>
literal|0
operator|)
expr_stmt|;
name|fd
operator|=
name|PerlLIO_open3
argument_list|(
name|name
argument_list|,
name|rawmode
argument_list|,
name|rawperm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|char
name|fpmode
index|[
literal|4
index|]
decl_stmt|;
name|STRLEN
name|ix
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|O_RDONLY
condition|)
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
ifdef|#
directive|ifdef
name|O_APPEND
elseif|else
if|if
condition|(
name|rawmode
operator|&
name|O_APPEND
condition|)
block|{
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|O_WRONLY
condition|)
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|result
operator|==
name|O_WRONLY
condition|)
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
else|else
block|{
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rawmode
operator|&
name|O_BINARY
condition|)
name|fpmode
index|[
name|ix
operator|++
index|]
operator|=
literal|'b'
expr_stmt|;
name|fpmode
index|[
name|ix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
name|fpmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|oname
init|=
name|name
decl_stmt|;
name|STRLEN
name|tlen
decl_stmt|;
name|STRLEN
name|olen
init|=
name|len
decl_stmt|;
name|char
name|mode
index|[
literal|4
index|]
decl_stmt|;
comment|/* stdio file mode ("r\0", "rb\0", "r+b\0" etc.) */
name|int
name|dodup
decl_stmt|;
name|type
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|len
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_svs
condition|)
block|{
name|STRLEN
name|l
decl_stmt|;
name|name
operator|=
name|SvPV
argument_list|(
name|svs
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|I32
operator|)
name|l
expr_stmt|;
name|name
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|tlen
operator|&&
name|isSPACE
argument_list|(
name|type
index|[
name|tlen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|type
index|[
operator|--
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|type
expr_stmt|;
name|len
operator|=
name|tlen
expr_stmt|;
block|}
name|mode
index|[
literal|0
index|]
operator|=
name|mode
index|[
literal|1
index|]
operator|=
name|mode
index|[
literal|2
index|]
operator|=
name|mode
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
operator|*
name|type
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_RDWR
operator|&&
name|tlen
operator|>
literal|1
operator|&&
name|type
index|[
name|tlen
operator|-
literal|1
index|]
operator|!=
name|IoTYPE_PIPE
condition|)
block|{
comment|/* scary */
name|mode
index|[
literal|1
index|]
operator|=
operator|*
name|type
operator|++
expr_stmt|;
operator|--
name|tlen
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_PIPE
condition|)
block|{
if|if
condition|(
name|num_svs
operator|&&
operator|(
name|tlen
operator|!=
literal|2
operator|||
name|type
index|[
literal|1
index|]
operator|!=
name|IoTYPE_STD
operator|)
condition|)
block|{
name|unknown_desr
label|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unknown open() mode '%.*s'"
argument_list|,
operator|(
name|int
operator|)
name|olen
argument_list|,
name|oname
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 530*/
for|for
control|(
name|type
operator|++
operator|,
name|tlen
operator|--
init|;
name|isSPACE
argument_list|(
operator|*
name|type
argument_list|)
condition|;
name|type
operator|++
operator|,
name|tlen
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|num_svs
condition|)
block|{
name|name
operator|=
name|type
expr_stmt|;
name|len
operator|=
name|tlen
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* command is missing 19990114 */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PIPE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PIPE
argument_list|,
literal|"Missing command in piped open"
argument_list|)
empty_stmt|;
name|errno
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|strNE
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|||
name|num_svs
condition|)
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"piped open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PIPE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PIPE
argument_list|,
literal|"Can't open bidirectional pipe"
argument_list|)
empty_stmt|;
block|}
block|{
name|char
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|out_raw
condition|)
name|mode
operator|=
literal|"wb"
expr_stmt|;
elseif|else
if|if
condition|(
name|out_crlf
condition|)
name|mode
operator|=
literal|"wt"
expr_stmt|;
else|else
name|mode
operator|=
literal|"w"
expr_stmt|;
name|fp
operator|=
name|PerlProc_popen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|writing
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_WRONLY
condition|)
block|{
name|TAINT_PROPER
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|type
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_WRONLY
condition|)
block|{
comment|/* Two IoTYPE_WRONLYs in a row make for an IoTYPE_APPEND. */
name|mode
index|[
literal|0
index|]
operator|=
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_APPEND
expr_stmt|;
name|type
operator|++
expr_stmt|;
name|tlen
operator|--
expr_stmt|;
block|}
else|else
name|mode
index|[
literal|0
index|]
operator|=
literal|'w'
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|out_raw
condition|)
name|strcat
argument_list|(
name|mode
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_crlf
condition|)
name|strcat
argument_list|(
name|mode
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_svs
operator|&&
name|tlen
operator|!=
literal|1
condition|)
goto|goto
name|unknown_desr
goto|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'&'
condition|)
block|{
name|name
operator|=
name|type
expr_stmt|;
name|duplicity
label|:
name|dodup
operator|=
literal|1
expr_stmt|;
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'='
condition|)
block|{
name|dodup
operator|=
literal|0
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|name
operator|&&
name|supplied_fp
condition|)
name|fp
operator|=
name|supplied_fp
expr_stmt|;
else|else
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|fd
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|IO
modifier|*
name|thatio
decl_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|thatio
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thatio
condition|)
block|{
ifdef|#
directive|ifdef
name|EINVAL
name|SETERRNO
argument_list|(
name|EINVAL
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|IoIFP
argument_list|(
name|thatio
argument_list|)
condition|)
block|{
name|PerlIO
modifier|*
name|fp
init|=
name|IoIFP
argument_list|(
name|thatio
argument_list|)
decl_stmt|;
comment|/* Flush stdio buffer before dup. --mjd 			     * Unfortunately SEEK_CURing 0 seems to 			     * be optimized away on most platforms; 			     * only Solaris and Linux seem to flush 			     * on that. --jhi */
ifdef|#
directive|ifdef
name|USE_SFIO
comment|/* sfio fails to clear error on next 			       sfwrite, contrary to documentation. 			       -- Nick Clark */
if|if
condition|(
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PerlIO_clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On the other hand, do all platforms 			     * take gracefully to flushing a read-only 			     * filehandle?  Perhaps we should do 			     * fsetpos(src)+fgetpos(dst)?  --nik */
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* When dup()ing STDIN, STDOUT or STDERR 			     * explicitly set appropriate access mode */
if|if
condition|(
name|IoIFP
argument_list|(
name|thatio
argument_list|)
operator|==
name|PerlIO_stdout
argument_list|()
operator|||
name|IoIFP
argument_list|(
name|thatio
argument_list|)
operator|==
name|PerlIO_stderr
argument_list|()
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_WRONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|IoIFP
argument_list|(
name|thatio
argument_list|)
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
comment|/* When dup()ing a socket, say result is 			     * one as well */
elseif|else
if|if
condition|(
name|IoTYPE
argument_list|(
name|thatio
argument_list|)
operator|==
name|IoTYPE_SOCKET
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
block|}
else|else
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dodup
condition|)
name|fd
operator|=
name|PerlLIO_dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|was_fdopen
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dodup
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|type
argument_list|)
condition|;
name|type
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_STD
operator|&&
operator|!
name|type
index|[
literal|1
index|]
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdout
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_STD
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
operator|(
name|num_svs
condition|?
name|name
else|:
name|type
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_RDONLY
condition|)
block|{
if|if
condition|(
name|num_svs
operator|&&
name|tlen
operator|!=
literal|1
condition|)
goto|goto
name|unknown_desr
goto|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|type
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|type
argument_list|)
condition|;
name|type
operator|++
control|)
empty_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|in_raw
condition|)
name|strcat
argument_list|(
name|mode
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_crlf
condition|)
name|strcat
argument_list|(
name|mode
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
literal|'&'
condition|)
block|{
name|name
operator|=
name|type
expr_stmt|;
goto|goto
name|duplicity
goto|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
name|IoTYPE_STD
operator|&&
operator|!
name|type
index|[
literal|1
index|]
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdin
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_STD
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|PerlIO_open
argument_list|(
operator|(
name|num_svs
condition|?
name|name
else|:
name|type
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tlen
operator|>
literal|1
operator|&&
name|type
index|[
name|tlen
operator|-
literal|1
index|]
operator|==
name|IoTYPE_PIPE
condition|)
block|{
if|if
condition|(
name|num_svs
condition|)
block|{
if|if
condition|(
name|tlen
operator|!=
literal|2
operator|||
name|type
index|[
literal|0
index|]
operator|!=
name|IoTYPE_STD
condition|)
goto|goto
name|unknown_desr
goto|;
block|}
else|else
block|{
name|type
index|[
operator|--
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|tlen
operator|&&
name|isSPACE
argument_list|(
name|type
index|[
name|tlen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|type
index|[
operator|--
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|type
argument_list|)
condition|;
name|type
operator|++
control|)
empty_stmt|;
name|name
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* command is missing 19990114 */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PIPE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PIPE
argument_list|,
literal|"Missing command in piped open"
argument_list|)
empty_stmt|;
name|errno
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|strNE
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|||
name|num_svs
condition|)
name|TAINT_ENV
argument_list|()
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"piped open"
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|in_raw
condition|)
name|mode
operator|=
literal|"rb"
expr_stmt|;
elseif|else
if|if
condition|(
name|in_crlf
condition|)
name|mode
operator|=
literal|"rt"
expr_stmt|;
else|else
name|mode
operator|=
literal|"r"
expr_stmt|;
name|fp
operator|=
name|PerlProc_popen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_PIPE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|num_svs
condition|)
goto|goto
name|unknown_desr
goto|;
name|name
operator|=
name|type
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|PerlIO_stdin
argument_list|()
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_STD
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|in_raw
condition|)
name|mode
operator|=
literal|"rb"
expr_stmt|;
elseif|else
if|if
condition|(
name|in_crlf
condition|)
name|mode
operator|=
literal|"rt"
expr_stmt|;
else|else
name|mode
operator|=
literal|"r"
expr_stmt|;
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_NEWLINE
argument_list|)
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_RDONLY
operator|&&
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NEWLINE
argument_list|,
argument|PL_warn_nl
argument_list|,
literal|"open"
argument_list|)
empty_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
name|IoTYPE_PIPE
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
name|IoTYPE_STD
condition|)
block|{
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
comment|/* in case a socket was passed in to us */
ifdef|#
directive|ifdef
name|HAS_SOCKET
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|S_IFMT
operator|!
operator|(
name|PL_statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
else|#
directive|else
operator|!
name|PL_statbuf
operator|.
name|st_mode
endif|#
directive|endif
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
name|IoTYPE_WRONLY
comment|/* Dups of STD* filehandles already have */
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|!=
name|IoTYPE_RDONLY
comment|/* type so they aren't marked as sockets */
condition|)
block|{
comment|/* on OS's that return 0 on fstat()ed pipe */
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|Sock_size_t
name|buflen
init|=
sizeof|sizeof
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|PerlSock_getsockname
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|tmpbuf
argument_list|,
operator|&
name|buflen
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOTSOCK
condition|)
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_SOCKET
expr_stmt|;
comment|/* some OS's return 0 on fstat()ed socket */
comment|/* but some return 0 for streams too, sigh */
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|saveifp
condition|)
block|{
comment|/* must use old fp? */
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|saveifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveofp
condition|)
block|{
name|PerlIO_flush
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
comment|/* emulate PerlIO_close() */
if|if
condition|(
name|saveofp
operator|!=
name|saveifp
condition|)
block|{
comment|/* was a socket? */
name|PerlIO_close
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|2
condition|)
name|Safefree
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|Pid_t
name|pid
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|PerlLIO_dup2
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|fd
operator|!=
name|PerlIO_fileno
argument_list|(
name|PerlIO_stdin
argument_list|()
argument_list|)
condition|)
block|{
name|char
name|newname
index|[
name|FILENAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|fgetname
argument_list|(
name|fp
argument_list|,
name|newname
argument_list|)
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|PerlIO_fileno
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|)
condition|)
name|Perl_vmssetuserlnm
argument_list|(
literal|"SYS$OUTPUT"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|PerlIO_fileno
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|)
condition|)
name|Perl_vmssetuserlnm
argument_list|(
literal|"SYS$ERROR"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|LOCK_FDPID_MUTEX
expr_stmt|;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|pid
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|UNLOCK_FDPID_MUTEX
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pid
expr_stmt|;
if|if
condition|(
operator|!
name|was_fdopen
condition|)
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|saveifp
expr_stmt|;
name|PerlIO_clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|fd
operator|=
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>
name|PL_maxsysfd
argument_list|)
expr_stmt|;
comment|/* can change errno */
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
endif|#
directive|endif
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|fp
expr_stmt|;
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&=
operator|~
name|IOf_NOLINE
expr_stmt|;
if|if
condition|(
name|writing
condition|)
block|{
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_SOCKET
operator|||
operator|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_WRONLY
operator|&&
name|S_ISCHR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|out_raw
condition|)
name|mode
operator|=
literal|"wb"
expr_stmt|;
elseif|else
if|if
condition|(
name|out_crlf
condition|)
name|mode
operator|=
literal|"wt"
expr_stmt|;
else|else
name|mode
operator|=
literal|"w"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|PerlIO_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
block|}
else|else
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|fp
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|say_false
label|:
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|saveifp
expr_stmt|;
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|saveofp
expr_stmt|;
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|savetype
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|PerlIO
modifier|*
name|Perl_nextargv
parameter_list|(
name|pTHX_
specifier|register
name|GV
modifier|*
name|gv
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|int
name|filedev
decl_stmt|;
name|int
name|fileino
decl_stmt|;
endif|#
directive|endif
name|Uid_t
name|fileuid
decl_stmt|;
name|Gid_t
name|filegid
decl_stmt|;
name|IO
modifier|*
name|io
init|=
name|GvIOp
argument_list|(
name|gv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PL_argvoutgv
condition|)
name|PL_argvoutgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"ARGVOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|&&
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_ARGV
operator|)
operator|&&
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_START
operator|)
condition|)
block|{
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&=
operator|~
name|IOf_START
expr_stmt|;
if|if
condition|(
name|PL_inplace
condition|)
block|{
if|if
condition|(
operator|!
name|PL_argvout_stack
condition|)
name|PL_argvout_stack
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_argvout_stack
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|PL_defoutgv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_filemode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
name|PerlIO_flush
argument_list|(
name|IoIFP
argument_list|(
name|GvIOn
argument_list|(
name|PL_argvoutgv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chmod must follow last write */
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|PL_lastfd
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|PerlLIO_chmod
argument_list|(
name|PL_oldname
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|PL_filemode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|av_len
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|STRLEN
name|oldlen
decl_stmt|;
name|sv
operator|=
name|av_shift
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_oldname
operator|=
name|SvPVx
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open
argument_list|(
name|gv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_inplace
condition|)
block|{
name|TAINT_PROPER
argument_list|(
literal|"inplace open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlen
operator|==
literal|1
operator|&&
operator|*
name|PL_oldname
operator|==
literal|'-'
condition|)
block|{
name|setdefout
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|filedev
operator|=
name|PL_statbuf
operator|.
name|st_dev
expr_stmt|;
name|fileino
operator|=
name|PL_statbuf
operator|.
name|st_ino
expr_stmt|;
endif|#
directive|endif
name|PL_filemode
operator|=
name|PL_statbuf
operator|.
name|st_mode
expr_stmt|;
name|fileuid
operator|=
name|PL_statbuf
operator|.
name|st_uid
expr_stmt|;
name|filegid
operator|=
name|PL_statbuf
operator|.
name|st_gid
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|PL_filemode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't do inplace edit: %s is not a regular file"
argument_list|,
argument|PL_oldname
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|PL_inplace
condition|)
block|{
name|char
modifier|*
name|star
init|=
name|strchr
argument_list|(
name|PL_inplace
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
if|if
condition|(
name|star
condition|)
block|{
name|char
modifier|*
name|begin
init|=
name|PL_inplace
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|begin
argument_list|,
name|star
operator|-
name|begin
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
name|begin
operator|=
operator|++
name|star
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|star
operator|=
name|strchr
argument_list|(
name|begin
argument_list|,
literal|'*'
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
operator|*
name|begin
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PL_inplace
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FLEXFILENAMES
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|PL_statbuf
operator|.
name|st_dev
operator|==
name|filedev
operator|&&
name|PL_statbuf
operator|.
name|st_ino
operator|==
name|fileino
ifdef|#
directive|ifdef
name|DJGPP
operator|||
operator|(
name|_djstat_fail_bits
operator|&
name|_STFAIL_TRUENAME
operator|)
operator|!=
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't do inplace edit: %s would not be unique"
argument_list|,
argument|SvPVX(sv)
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RENAME
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|PerlLIO_rename
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
argument|PL_oldname
argument_list|,
argument|SvPVX(sv)
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_unlink
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_rename
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|do_open
argument_list|(
name|gv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DOSISH */
else|#
directive|else
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|PL_oldname
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
argument|PL_oldname
argument_list|,
argument|SvPVX(sv)
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|PL_oldname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
ifndef|#
directive|ifndef
name|VMS
comment|/* Don't delete; use automatic file versioning */
if|if
condition|(
name|UNLINK
argument_list|(
name|PL_oldname
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't remove %s: %s, skipping file"
argument_list|,
argument|PL_oldname
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't do inplace edit without backup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|">"
argument_list|,
operator|!
name|PL_inplace
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|PL_oldname
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in case sprintf set errno */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|do_open
argument_list|(
name|PL_argvoutgv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0
argument_list|,
name|Nullfp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|do_open
argument_list|(
name|PL_argvoutgv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|PL_inplace
operator|!=
literal|0
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|OPEN_EXCL
argument_list|,
literal|0666
argument_list|,
name|Nullfp
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't do inplace edit on %s: %s"
argument_list|,
argument|PL_oldname
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
name|do_close
argument_list|(
name|gv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|setdefout
argument_list|(
name|PL_argvoutgv
argument_list|)
expr_stmt|;
name|PL_lastfd
operator|=
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|PL_argvoutgv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlLIO_fstat
argument_list|(
name|PL_lastfd
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|PL_lastfd
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|)
comment|/* Borland runtime creates a readonly file! */
operator|(
name|void
operator|)
name|PerlLIO_chmod
argument_list|(
name|PL_oldname
argument_list|,
name|PL_filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|fileuid
operator|!=
name|PL_statbuf
operator|.
name|st_uid
operator|||
name|filegid
operator|!=
name|PL_statbuf
operator|.
name|st_gid
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_FCHOWN
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|PL_lastfd
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_CHOWN
operator|(
name|void
operator|)
name|PerlLIO_chown
argument_list|(
name|PL_oldname
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
return|return
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INPLACE
argument_list|)
condition|)
block|{
name|int
name|eno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|PL_oldname
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't do inplace edit: %s is not a regular file"
argument_list|,
argument|PL_oldname
argument_list|)
empty_stmt|;
block|}
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INPLACE
argument_list|,
literal|"Can't open %s: %s"
argument_list|,
argument|PL_oldname
argument_list|,
argument|Strerror(eno)
argument_list|)
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|io
operator|&&
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_ARGV
operator|)
condition|)
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator||=
name|IOf_START
expr_stmt|;
if|if
condition|(
name|PL_inplace
condition|)
block|{
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|PL_argvoutgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|&&
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_ARGV
operator|)
operator|&&
name|PL_argvout_stack
operator|&&
name|AvFILLp
argument_list|(
name|PL_argvout_stack
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|GV
modifier|*
name|oldout
init|=
operator|(
name|GV
operator|*
operator|)
name|av_pop
argument_list|(
name|PL_argvout_stack
argument_list|)
decl_stmt|;
name|setdefout
argument_list|(
name|oldout
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|oldout
argument_list|)
expr_stmt|;
return|return
name|Nullfp
return|;
block|}
name|setdefout
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullfp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_PIPE
end_ifdef

begin_function
name|void
name|Perl_do_pipe
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|GV
modifier|*
name|rgv
parameter_list|,
name|GV
modifier|*
name|wgv
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|rstio
decl_stmt|;
specifier|register
name|IO
modifier|*
name|wstio
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|rgv
condition|)
goto|goto
name|badexit
goto|;
if|if
condition|(
operator|!
name|wgv
condition|)
goto|goto
name|badexit
goto|;
name|rstio
operator|=
name|GvIOn
argument_list|(
name|rgv
argument_list|)
expr_stmt|;
name|wstio
operator|=
name|GvIOn
argument_list|(
name|wgv
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|rgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|do_close
argument_list|(
name|wgv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|IoOFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|PerlIO_fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|IoIFP
argument_list|(
name|wstio
argument_list|)
operator|=
name|IoOFP
argument_list|(
name|wstio
argument_list|)
expr_stmt|;
name|IoTYPE
argument_list|(
name|rstio
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
name|IoTYPE
argument_list|(
name|wstio
argument_list|)
operator|=
name|IoTYPE_WRONLY
expr_stmt|;
if|if
condition|(
operator|!
name|IoIFP
argument_list|(
name|rstio
argument_list|)
operator|||
operator|!
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|rstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
condition|)
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|wstio
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlLIO_close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
return|return;
name|badexit
label|:
name|sv_setsv
argument_list|(
name|sv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* explicit renamed to avoid C++ conflict    -- kja */
end_comment

begin_function
name|bool
name|Perl_do_close
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|bool
name|not_implicit
parameter_list|)
block|{
name|bool
name|retval
decl_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
name|gv
operator|=
name|PL_argvgv
expr_stmt|;
if|if
condition|(
operator|!
name|gv
operator|||
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|not_implicit
condition|)
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
block|{
comment|/* never opened */
if|if
condition|(
name|not_implicit
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNOPENED
argument_list|)
condition|)
comment|/* no check for closed here */
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|retval
operator|=
name|io_close
argument_list|(
name|io
argument_list|,
name|not_implicit
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_implicit
condition|)
block|{
name|IoLINES
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IoPAGE
argument_list|(
name|io
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IoLINES_LEFT
argument_list|(
name|io
argument_list|)
operator|=
name|IoPAGE_LEN
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|=
name|IoTYPE_CLOSED
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|bool
name|Perl_io_close
parameter_list|(
name|pTHX_
name|IO
modifier|*
name|io
parameter_list|,
name|bool
name|not_implicit
parameter_list|)
block|{
name|bool
name|retval
init|=
name|FALSE
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_PIPE
condition|)
block|{
name|status
operator|=
name|PerlProc_pclose
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_implicit
condition|)
block|{
name|STATUS_NATIVE_SET
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|STATUS_POSIX
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|(
name|status
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_STD
condition|)
name|retval
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|&&
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|!=
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
comment|/* a socket */
name|retval
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|retval
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
block|}
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not_implicit
condition|)
block|{
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|SS$_IVCHAN
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_eof
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_IO
argument_list|)
operator|&&
operator|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_WRONLY
operator|||
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|==
name|PerlIO_stdout
argument_list|()
operator|||
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|==
name|PerlIO_stderr
argument_list|()
operator|)
condition|)
block|{
comment|/* integrate to report_evil_fh()? */
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle %s opened only for output"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
else|else
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_IO
argument_list|,
literal|"Filehandle opened only for output"
argument_list|)
empty_stmt|;
block|}
while|while
condition|(
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|PerlIO_has_cntptr
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
block|{
comment|/* (the code works without this) */
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
comment|/* cheat a little, since */
return|return
name|FALSE
return|;
comment|/* this is the most usual case */
block|}
name|ch
operator|=
name|PerlIO_getc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_ungetc
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|PerlIO_has_cntptr
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|&&
name|PerlIO_canset_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|PerlIO_get_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
operator|<
operator|-
literal|1
condition|)
name|PerlIO_set_cnt
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
comment|/* not necessarily a real EOF yet? */
if|if
condition|(
operator|!
name|nextargv
argument_list|(
name|PL_argvgv
argument_list|)
condition|)
comment|/* get another fp handy */
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* normal fp, definitely end of file */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|Off_t
name|Perl_do_tell
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|PerlIO_tell
argument_list|(
name|fp
argument_list|)
return|;
block|}
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
operator|(
name|Off_t
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_seek
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|Off_t
name|pos
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
name|whence
argument_list|)
operator|>=
literal|0
return|;
block|}
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|Off_t
name|Perl_do_sysseek
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|Off_t
name|pos
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
specifier|register
name|IO
modifier|*
name|io
decl_stmt|;
specifier|register
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
operator|(
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
operator|(
name|fp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|)
condition|)
return|return
name|PerlLIO_lseek
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|pos
argument_list|,
name|whence
argument_list|)
return|;
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
operator|(
name|Off_t
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|Perl_mode_from_discipline
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|discp
parameter_list|)
block|{
name|int
name|mode
init|=
name|O_BINARY
decl_stmt|;
if|if
condition|(
name|discp
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|discp
argument_list|,
name|len
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
name|strnEQ
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"raw"
argument_list|,
literal|3
argument_list|)
operator|&&
operator|(
operator|!
name|s
index|[
literal|4
index|]
operator|||
name|s
index|[
literal|4
index|]
operator|==
literal|':'
operator|||
name|isSPACE
argument_list|(
name|s
index|[
literal|4
index|]
argument_list|)
operator|)
condition|)
block|{
name|mode
operator|=
name|O_BINARY
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
literal|'c'
case|:
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|strnEQ
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"crlf"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|(
operator|!
name|s
index|[
literal|5
index|]
operator|||
name|s
index|[
literal|5
index|]
operator|==
literal|':'
operator|||
name|isSPACE
argument_list|(
name|s
index|[
literal|5
index|]
argument_list|)
operator|)
condition|)
block|{
name|mode
operator|=
name|O_TEXT
expr_stmt|;
name|s
operator|+=
literal|5
expr_stmt|;
name|len
operator|-=
literal|5
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
default|default:
goto|goto
name|fail_discipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|fail_discipline
label|:
name|end
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|s
operator|+
name|len
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unknown discipline '%.*s'"
argument_list|,
name|end
operator|-
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|mode
return|;
block|}
end_function

begin_function
name|int
name|Perl_do_binmode
parameter_list|(
name|pTHX_
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|int
name|iotype
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DOSISH
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
if|if
condition|(
operator|!
name|PerlIO_flush
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|O_BINARY
condition|)
operator|(
operator|(
name|FILE
operator|*
operator|)
name|fp
operator|)
operator|->
name|_flag
operator||=
name|_IOBIN
expr_stmt|;
else|else
operator|(
operator|(
name|FILE
operator|*
operator|)
name|fp
operator|)
operator|->
name|_flag
operator|&=
operator|~
name|_IOBIN
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|PerlLIO_setmode
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* The translation mode of the stream is maintained independent 	 * of the translation mode of the fd in the Borland RTL (heavy 	 * digging through their runtime sources reveal).  User has to 	 * set the mode explicitly for the stream (though they don't 	 * document this anywhere). GSAR 97-5-24 	 */
name|PerlIO_seek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_BINARY
condition|)
operator|(
operator|(
name|FILE
operator|*
operator|)
name|fp
operator|)
operator|->
name|flags
operator||=
name|_F_BIN
expr_stmt|;
else|else
operator|(
operator|(
name|FILE
operator|*
operator|)
name|fp
operator|)
operator|->
name|flags
operator|&=
operator|~
name|_F_BIN
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|USEMYBINMODE
argument_list|)
if|if
condition|(
name|my_binmode
argument_list|(
name|fp
argument_list|,
name|iotype
argument_list|,
name|mode
argument_list|)
operator|!=
name|FALSE
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_TRUNCATE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_CHSIZE
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_FREESP
argument_list|)
end_if

begin_comment
comment|/* code courtesy of William Kucharski */
end_comment

begin_define
define|#
directive|define
name|HAS_CHSIZE
end_define

begin_function
name|I32
name|my_chsize
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|I32
name|fd
decl_stmt|;
comment|/* file descriptor */
name|Off_t
name|length
decl_stmt|;
comment|/* length to set file to */
block|{
name|struct
name|flock
name|fl
decl_stmt|;
name|struct
name|stat
name|filebuf
decl_stmt|;
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|filebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|filebuf
operator|.
name|st_size
operator|<
name|length
condition|)
block|{
comment|/* extend file length */
if|if
condition|(
operator|(
name|PerlLIO_lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write a "0" byte */
if|if
condition|(
operator|(
name|PerlLIO_write
argument_list|(
name|fd
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* truncate length */
name|fl
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
name|length
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
comment|/* write lock on file space */
comment|/* 	* This relies on the UNDOCUMENTED F_FREESP argument to 	* fcntl(2), which truncates the file so that it ends at the 	* position indicated by fl.l_start. 	* 	* Will minor miracles never cease? 	*/
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_FREESP
argument_list|,
operator|&
name|fl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_FREESP */
end_comment

begin_function
name|bool
name|Perl_do_print
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|PerlIO
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
comment|/* assuming fp is checked earlier */
if|if
condition|(
operator|!
name|sv
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|PL_ofmt
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
name|PL_ofmt
argument_list|,
operator|(
name|NV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
operator|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|&&
name|sv_2nv
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
operator|)
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
name|PL_ofmt
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UNINITIALIZED
argument_list|)
condition|)
name|report_uninit
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|SVt_IV
case|:
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIsUV
argument_list|(
name|sv
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
literal|"%"
name|UVuf
argument_list|,
operator|(
name|UV
operator|)
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlIO_printf
argument_list|(
name|fp
argument_list|,
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
comment|/* FALL THROUGH */
default|default:
name|tmps
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* To detect whether the process is about to overstep its      * filesize limit we would need getrlimit().  We could then      * also transparently raise the limit with setrlimit() --      * but only until the system hard limit/the filesystem limit,      * at which we would get EPERM.  Note that when using buffered      * io the write failure can be delayed until the flush/close. --jhi */
if|if
condition|(
name|len
operator|&&
operator|(
name|PerlIO_write
argument_list|(
name|fp
argument_list|,
name|tmps
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|!
name|PerlIO_error
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|I32
name|Perl_my_stat
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gv
operator|=
name|cGVOP_gv
expr_stmt|;
name|do_fstat
label|:
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|&&
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|PL_statgv
operator|=
name|gv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_laststype
operator|=
name|OP_STAT
expr_stmt|;
return|return
operator|(
name|PL_laststatval
operator|=
name|PerlLIO_fstat
argument_list|(
name|PerlIO_fileno
argument_list|(
name|IoIFP
argument_list|(
name|io
argument_list|)
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|gv
operator|==
name|PL_defgv
condition|)
return|return
name|PL_laststatval
return|;
if|if
condition|(
name|ckWARN2
argument_list|(
name|WARN_UNOPENED
argument_list|,
name|WARN_CLOSED
argument_list|)
condition|)
name|report_evil_fh
argument_list|(
name|gv
argument_list|,
name|io
argument_list|,
name|PL_op
operator|->
name|op_type
argument_list|)
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|PL_laststatval
operator|=
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
elseif|else
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|do_fstat
goto|;
block|}
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PL_laststype
operator|=
name|OP_STAT
expr_stmt|;
name|PL_laststatval
operator|=
name|PerlLIO_stat
argument_list|(
name|s
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
operator|&&
name|ckWARN
argument_list|(
name|WARN_NEWLINE
argument_list|)
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NEWLINE
argument_list|,
argument|PL_warn_nl
argument_list|,
literal|"stat"
argument_list|)
empty_stmt|;
return|return
name|PL_laststatval
return|;
block|}
block|}
end_function

begin_function
name|I32
name|Perl_my_lstat
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cGVOP_gv
operator|==
name|PL_defgv
condition|)
block|{
if|if
condition|(
name|PL_laststype
operator|!=
name|OP_LSTAT
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"The stat preceding -l _ wasn't an lstat"
argument_list|)
expr_stmt|;
return|return
name|PL_laststatval
return|;
block|}
name|Perl_croak
argument_list|(
name|aTHX_
literal|"You can't use -l on a filehandle"
argument_list|)
expr_stmt|;
block|}
name|PL_laststype
operator|=
name|OP_LSTAT
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_statname
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
name|PL_laststatval
operator|=
name|PerlLIO_lstat
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
operator|&
name|PL_statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_laststatval
operator|<
literal|0
operator|&&
name|ckWARN
argument_list|(
name|WARN_NEWLINE
argument_list|)
operator|&&
name|strchr
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_NEWLINE
argument_list|,
argument|PL_warn_nl
argument_list|,
literal|"lstat"
argument_list|)
empty_stmt|;
return|return
name|PL_laststatval
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_aexec
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|really
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|do_aexec5
argument_list|(
name|really
argument_list|,
name|mark
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_aexec5
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|really
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|sp
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|do_report
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|Perl_croak
argument_list|(
name|aTHX_
literal|"exec? I'm not *that* kind of operating system"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|sp
operator|>
name|mark
condition|)
block|{
name|New
argument_list|(
literal|401
argument_list|,
name|PL_Argv
argument_list|,
name|sp
operator|-
name|mark
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|a
operator|=
name|PL_Argv
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|mark
condition|)
operator|*
name|a
operator|++
operator|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
else|else
operator|*
name|a
operator|++
operator|=
literal|""
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|really
condition|)
name|tmps
operator|=
name|SvPV
argument_list|(
name|really
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|really
operator|&&
operator|*
name|PL_Argv
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
operator|||
operator|(
name|really
operator|&&
operator|*
name|tmps
operator|!=
literal|'/'
operator|)
condition|)
comment|/* will execvp use PATH? */
name|TAINT_ENV
argument_list|()
expr_stmt|;
comment|/* testing IFS here is overkill, probably */
if|if
condition|(
name|really
operator|&&
operator|*
name|tmps
condition|)
name|PerlProc_execvp
argument_list|(
name|tmps
argument_list|,
name|EXEC_ARGV_CAST
argument_list|(
name|PL_Argv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlProc_execvp
argument_list|(
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|EXEC_ARGV_CAST
argument_list|(
name|PL_Argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXEC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXEC
argument_list|,
literal|"Can't exec \"%s\": %s"
argument_list|,
argument|(really ? tmps : PL_Argv[
literal|0
argument|])
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
if|if
condition|(
name|do_report
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|PerlLIO_write
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|do_execfree
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|Perl_do_execfree
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|if
condition|(
name|PL_Argv
condition|)
block|{
name|Safefree
argument_list|(
name|PL_Argv
argument_list|)
expr_stmt|;
name|PL_Argv
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_Cmd
condition|)
block|{
name|Safefree
argument_list|(
name|PL_Cmd
argument_list|)
expr_stmt|;
name|PL_Cmd
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DJGPP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
end_if

begin_function
name|bool
name|Perl_do_exec
parameter_list|(
name|pTHX_
name|char
modifier|*
name|cmd
parameter_list|)
block|{
return|return
name|do_exec3
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|Perl_do_exec3
parameter_list|(
name|pTHX_
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|do_report
parameter_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|flags
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|&&
name|isSPACE
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/* save an extra exec if possible */
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
name|strnEQ
argument_list|(
name|cmd
argument_list|,
name|PL_cshname
argument_list|,
name|PL_cshlen
argument_list|)
operator|&&
name|strnEQ
argument_list|(
name|cmd
operator|+
name|PL_cshlen
argument_list|,
literal|" -c"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|flags
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
name|s
operator|=
name|cmd
operator|+
name|PL_cshlen
operator|+
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\''
condition|)
block|{
name|char
modifier|*
name|ncmd
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
name|PerlProc_execl
argument_list|(
name|PL_cshname
argument_list|,
literal|"csh"
argument_list|,
name|flags
argument_list|,
name|ncmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\''
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* CSH */
comment|/* see if there are shell metacharacters in it */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'.'
operator|&&
name|isSPACE
argument_list|(
name|cmd
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|doshell
goto|;
if|if
condition|(
name|strnEQ
argument_list|(
name|cmd
argument_list|,
literal|"exec"
argument_list|,
literal|4
argument_list|)
operator|&&
name|isSPACE
argument_list|(
name|cmd
index|[
literal|4
index|]
argument_list|)
condition|)
goto|goto
name|doshell
goto|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
operator|&&
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* catch VAR=val gizmo */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
goto|goto
name|doshell
goto|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|!
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"$&*(){}[]'\";\\|?<>~`\n"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
comment|/* handle the 2>&1 construct at the end */
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'&'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'1'
operator|&&
name|s
operator|>
name|cmd
operator|+
literal|1
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'2'
operator|&&
name|isSPACE
argument_list|(
name|s
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|s
index|[
literal|3
index|]
operator|||
name|isSPACE
argument_list|(
name|s
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|s
operator|+
literal|3
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
operator|&&
operator|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|doshell
label|:
name|PerlProc_execl
argument_list|(
name|PL_sh_path
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|New
argument_list|(
literal|402
argument_list|,
name|PL_Argv
argument_list|,
operator|(
name|s
operator|-
name|cmd
operator|)
operator|/
literal|2
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|PL_Cmd
operator|=
name|savepvn
argument_list|(
name|cmd
argument_list|,
name|s
operator|-
name|cmd
argument_list|)
expr_stmt|;
name|a
operator|=
name|PL_Argv
expr_stmt|;
for|for
control|(
name|s
operator|=
name|PL_Cmd
init|;
operator|*
name|s
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
operator|(
name|a
operator|++
operator|)
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|PL_Argv
index|[
literal|0
index|]
condition|)
block|{
name|PerlProc_execvp
argument_list|(
name|PL_Argv
index|[
literal|0
index|]
argument_list|,
name|PL_Argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
comment|/* for system V NIH syndrome */
name|do_execfree
argument_list|()
expr_stmt|;
goto|goto
name|doshell
goto|;
block|}
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXEC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXEC
argument_list|,
literal|"Can't exec \"%s\": %s"
argument_list|,
argument|PL_Argv[
literal|0
argument|]
argument_list|,
argument|Strerror(errno)
argument_list|)
empty_stmt|;
if|if
condition|(
name|do_report
condition|)
block|{
name|PerlLIO_write
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_execfree
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 || WIN32 */
end_comment

begin_function
name|I32
name|Perl_apply
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
specifier|register
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
specifier|register
name|I32
name|val
decl_stmt|;
specifier|register
name|I32
name|val2
decl_stmt|;
specifier|register
name|I32
name|tot
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldmark
init|=
name|mark
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
define|#
directive|define
name|APPLY_TAINT_PROPER
parameter_list|()
define|\
value|STMT_START {							\ 	if (PL_tainted) { TAINT_PROPER(what); }				\     } STMT_END
comment|/* This is a first heuristic; it doesn't catch tainting magic. */
if|if
condition|(
name|PL_tainting
condition|)
block|{
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
if|if
condition|(
name|SvTAINTED
argument_list|(
operator|*
name|mark
argument_list|)
condition|)
block|{
name|TAINT
expr_stmt|;
break|break;
block|}
block|}
name|mark
operator|=
name|oldmark
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_CHMOD
case|:
name|what
operator|=
literal|"chmod"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_chmod
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_CHOWN
case|case
name|OP_CHOWN
case|:
name|what
operator|=
literal|"chown"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|-
name|mark
operator|>
literal|2
condition|)
block|{
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|val2
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_chown
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|val2
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/*  XXX Should we make lchown() directly available from perl? For now, we'll let Configure test for HAS_LCHOWN, but do nothing in the core.     --AD  5/1998 */
ifdef|#
directive|ifdef
name|HAS_KILL
case|case
name|OP_KILL
case|:
name|what
operator|=
literal|"kill"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|mark
operator|==
name|sp
condition|)
break|break;
name|s
operator|=
name|SvPVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'S'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'G'
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|whichsig
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unrecognized signal name \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* kill() doesn't do process groups (job trees?) under VMS */
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
operator|-
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SIGKILL
condition|)
block|{
include|#
directive|include
file|<starlet.h>
comment|/* Use native sys$delprc() to insure that target process is 	     * deleted; supervisor-mode images don't pay attention to 	     * CRTL's emulation of Unix-style signals and kill() 	     */
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|long
name|int
name|__vmssts
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|__vmssts
operator|=
name|sys$delprc
argument_list|(
operator|&
name|proc
argument_list|,
literal|0
argument_list|)
operator|)
operator|&
literal|1
operator|)
condition|)
block|{
name|tot
operator|--
expr_stmt|;
switch|switch
condition|(
name|__vmssts
condition|)
block|{
case|case
name|SS$_NONEXPR
case|:
case|case
name|SS$_NOSUCHNODE
case|:
name|SETERRNO
argument_list|(
name|ESRCH
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS$_NOPRIV
case|:
name|SETERRNO
argument_list|(
name|EPERM
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SETERRNO
argument_list|(
name|EVMSERR
argument_list|,
name|__vmssts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_KILLPG
if|if
condition|(
name|PerlProc_killpg
argument_list|(
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* BSD */
else|#
directive|else
if|if
condition|(
name|PerlProc_kill
argument_list|(
operator|-
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* SYSV */
endif|#
directive|endif
name|tot
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|I32
name|proc
init|=
name|SvIVx
argument_list|(
operator|*
name|mark
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlProc_kill
argument_list|(
name|proc
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|OP_UNLINK
case|:
name|what
operator|=
literal|"unlink"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|s
operator|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_euid
operator|||
name|PL_unsafe
condition|)
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* don't let root wipe out directories without -U */
if|if
condition|(
name|PerlLIO_lstat
argument_list|(
name|s
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_UTIME
case|case
name|OP_UTIME
case|:
name|what
operator|=
literal|"utime"
expr_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|-
name|mark
operator|>
literal|2
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|I_UTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
name|struct
name|utimbuf
name|utbuf
decl_stmt|;
else|#
directive|else
struct|struct
block|{
name|Time_t
name|actime
decl_stmt|;
name|Time_t
name|modtime
decl_stmt|;
block|}
name|utbuf
struct|;
endif|#
directive|endif
name|Zero
argument_list|(
operator|&
name|utbuf
argument_list|,
sizeof|sizeof
name|utbuf
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIG_TIME
name|utbuf
operator|.
name|actime
operator|=
operator|(
name|Time_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time accessed */
name|utbuf
operator|.
name|modtime
operator|=
operator|(
name|Time_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time modified */
else|#
directive|else
name|utbuf
operator|.
name|actime
operator|=
operator|(
name|Time_t
operator|)
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time accessed */
name|utbuf
operator|.
name|modtime
operator|=
operator|(
name|Time_t
operator|)
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
comment|/* time modified */
endif|#
directive|endif
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
name|tot
operator|=
name|sp
operator|-
name|mark
expr_stmt|;
while|while
condition|(
operator|++
name|mark
operator|<=
name|sp
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|*
name|mark
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|APPLY_TAINT_PROPER
argument_list|()
expr_stmt|;
if|if
condition|(
name|PerlLIO_utime
argument_list|(
name|name
argument_list|,
operator|&
name|utbuf
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
else|else
name|tot
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
return|return
name|tot
return|;
undef|#
directive|undef
name|APPLY_TAINT_PROPER
block|}
end_function

begin_comment
comment|/* Do the permissions allow some operation?  Assumes statcache already set. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_comment
comment|/* VMS' cando is in vms.c */
end_comment

begin_function
name|bool
name|Perl_cando
parameter_list|(
name|pTHX_
name|Mode_t
name|mode
parameter_list|,
name|Uid_t
name|effective
parameter_list|,
specifier|register
name|Stat_t
modifier|*
name|statbufp
parameter_list|)
comment|/* Note: we use `effective' both for uids and gids.  * Here we are betting on Uid_t being equal or wider than Gid_t.  */
block|{
ifdef|#
directive|ifdef
name|DOSISH
comment|/* [Comments and code from Len Reed]      * MS-DOS "user" is similar to UNIX's "superuser," but can't write      * to write-protected files.  The execute permission bit is set      * by the Miscrosoft C library stat() function for the following:      *		.exe files      *		.com files      *		.bat files      *		directories      * All files and directories are readable.      * Directories and special files, e.g. "CON", cannot be      * write-protected.      * [Comment by Tom Dinger -- a directory can have the write-protect      *		bit set in the file system, but DOS permits changes to      *		the directory anyway.  In addition, all bets are off      *		here for networked software, such as Novell and      *		Sun's PC-NFS.]      */
comment|/* Atari stat() does pretty much the same thing. we set x_bit_set_in_stat       * too so it will actually look into the files for magic numbers       */
return|return
operator|(
name|mode
operator|&
name|statbufp
operator|->
name|st_mode
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
else|#
directive|else
comment|/* ! DOSISH */
if|if
condition|(
operator|(
name|effective
condition|?
name|PL_euid
else|:
name|PL_uid
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* root is special */
if|if
condition|(
name|mode
operator|==
name|S_IXUSR
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
literal|0111
operator|||
name|S_ISDIR
argument_list|(
name|statbufp
operator|->
name|st_mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* root reads and writes anything */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|statbufp
operator|->
name|st_uid
operator|==
operator|(
name|effective
condition|?
name|PL_euid
else|:
name|PL_uid
operator|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|mode
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "user" */
block|}
elseif|else
if|if
condition|(
name|ingroup
argument_list|(
name|statbufp
operator|->
name|st_gid
argument_list|,
name|effective
argument_list|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|mode
operator|>>
literal|3
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "group" */
block|}
elseif|else
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|mode
operator|>>
literal|6
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "other" */
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* ! DOSISH */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! VMS */
end_comment

begin_function
name|bool
name|Perl_ingroup
parameter_list|(
name|pTHX_
name|Gid_t
name|testgid
parameter_list|,
name|Uid_t
name|effective
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
comment|/* This is simply not correct for AppleShare, but fix it yerself. */
return|return
name|TRUE
return|;
else|#
directive|else
if|if
condition|(
name|testgid
operator|==
operator|(
name|effective
condition|?
name|PL_egid
else|:
name|PL_gid
operator|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|HAS_GETGROUPS
ifndef|#
directive|ifndef
name|NGROUPS
define|#
directive|define
name|NGROUPS
value|32
endif|#
directive|endif
block|{
name|Groups_t
name|gary
index|[
name|NGROUPS
index|]
decl_stmt|;
name|I32
name|anum
decl_stmt|;
name|anum
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gary
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|anum
operator|>=
literal|0
condition|)
if|if
condition|(
name|gary
index|[
name|anum
index|]
operator|==
name|testgid
condition|)
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
end_if

begin_function
name|I32
name|Perl_do_ipcget
parameter_list|(
name|pTHX_
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|key_t
name|key
decl_stmt|;
name|I32
name|n
decl_stmt|,
name|flags
decl_stmt|;
name|key
operator|=
operator|(
name|key_t
operator|)
name|SvNVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|OP_MSGGET
operator|)
condition|?
literal|0
else|:
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGGET
case|:
return|return
name|msgget
argument_list|(
name|key
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMGET
case|:
return|return
name|semget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMGET
case|:
return|return
name|shmget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s not implemented"
argument_list|,
name|PL_op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|-
literal|1
return|;
comment|/* should never happen */
block|}
end_function

begin_function
name|I32
name|Perl_do_ipcctl
parameter_list|(
name|pTHX_
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|SV
modifier|*
name|astr
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|n
decl_stmt|,
name|cmd
decl_stmt|,
name|infosize
decl_stmt|,
name|getinfo
decl_stmt|;
name|I32
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|OP_SEMCTL
operator|)
condition|?
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
else|:
literal|0
expr_stmt|;
name|cmd
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|astr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|infosize
operator|=
literal|0
expr_stmt|;
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|IPC_STAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|shmid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMCTL
case|:
ifdef|#
directive|ifdef
name|Semctl
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|GETALL
operator|||
name|cmd
operator|==
name|SETALL
condition|)
block|{
name|struct
name|semid_ds
name|semds
decl_stmt|;
name|union
name|semun
name|semun
decl_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_F_IN_SEMUN_BUF
name|semun
operator|.
name|buff
operator|=
operator|&
name|semds
expr_stmt|;
else|#
directive|else
name|semun
operator|.
name|buf
operator|=
operator|&
name|semds
expr_stmt|;
endif|#
directive|endif
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|GETALL
operator|)
expr_stmt|;
if|if
condition|(
name|Semctl
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|IPC_STAT
argument_list|,
name|semun
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|infosize
operator|=
name|semds
operator|.
name|sem_nsems
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* "short" is technically wrong but much more portable 		   than guessing about u_?short(_t)? */
block|}
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s not implemented"
argument_list|,
name|PL_op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s not implemented"
argument_list|,
name|PL_op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|infosize
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|getinfo
condition|)
block|{
name|SvPV_force
argument_list|(
name|astr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|a
operator|=
name|SvGROW
argument_list|(
name|astr
argument_list|,
name|infosize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|SvPV
argument_list|(
name|astr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|infosize
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad arg length for %s, is %lu, should be %ld"
argument_list|,
name|PL_op_desc
index|[
name|optype
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|long
operator|)
name|infosize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IV
name|i
init|=
name|SvIV
argument_list|(
name|astr
argument_list|)
decl_stmt|;
name|a
operator|=
name|INT2PTR
argument_list|(
name|char
operator|*
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* ouch */
block|}
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|OP_MSGCTL
case|:
name|ret
operator|=
name|msgctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|msqid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|OP_SEMCTL
case|:
block|{
ifdef|#
directive|ifdef
name|Semctl
name|union
name|semun
name|unsemds
decl_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_F_IN_SEMUN_BUF
name|unsemds
operator|.
name|buff
operator|=
operator|(
expr|struct
name|semid_ds
operator|*
operator|)
name|a
expr_stmt|;
else|#
directive|else
name|unsemds
operator|.
name|buf
operator|=
operator|(
expr|struct
name|semid_ds
operator|*
operator|)
name|a
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|Semctl
argument_list|(
name|id
argument_list|,
name|n
argument_list|,
name|cmd
argument_list|,
name|unsemds
argument_list|)
expr_stmt|;
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s not implemented"
argument_list|,
name|PL_op_desc
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|OP_SHMCTL
case|:
name|ret
operator|=
name|shmctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|shmid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|getinfo
operator|&&
name|ret
operator|>=
literal|0
condition|)
block|{
name|SvCUR_set
argument_list|(
name|astr
argument_list|,
name|infosize
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|astr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|astr
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|I32
name|Perl_do_msgsnd
parameter_list|(
name|pTHX_
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvPV
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msize
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Arg too short for msgsnd"
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|msgsnd
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|flags
argument_list|)
return|;
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"msgsnd not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|I32
name|Perl_do_msgrcv
parameter_list|(
name|pTHX_
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|,
name|ret
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
comment|/* suppress warning when reading into undef var --jhi */
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|mstr
argument_list|)
condition|)
name|sv_setpvn
argument_list|(
name|mstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msize
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mtype
operator|=
operator|(
name|long
operator|)
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvGROW
argument_list|(
name|mstr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|msgrcv
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|mtype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|SvCUR_set
argument_list|(
name|mstr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|ret
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|mstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
comment|/* who knows who has been playing with this message? */
name|SvTAINTED_on
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ret
return|;
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"msgrcv not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|I32
name|Perl_do_semop
parameter_list|(
name|pTHX_
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_SEM
name|SV
modifier|*
name|opstr
decl_stmt|;
name|char
modifier|*
name|opbuf
decl_stmt|;
name|I32
name|id
decl_stmt|;
name|STRLEN
name|opsize
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|opstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|opbuf
operator|=
name|SvPV
argument_list|(
name|opstr
argument_list|,
name|opsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|opsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|||
operator|(
name|opsize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SETERRNO
argument_list|(
name|EINVAL
argument_list|,
name|LIB$_INVARG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|semop
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|sembuf
operator|*
operator|)
name|opbuf
argument_list|,
name|opsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"semop not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|I32
name|Perl_do_shmio
parameter_list|(
name|pTHX_
name|I32
name|optype
parameter_list|,
name|SV
modifier|*
modifier|*
name|mark
parameter_list|,
name|SV
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAS_SHM
name|SV
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|shm
decl_stmt|;
name|I32
name|id
decl_stmt|,
name|mpos
decl_stmt|,
name|msize
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|struct
name|shmid_ds
name|shmds
decl_stmt|;
name|id
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|mstr
operator|=
operator|*
operator|++
name|mark
expr_stmt|;
name|mpos
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|msize
operator|=
name|SvIVx
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmctl
argument_list|(
name|id
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|shmds
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mpos
operator|<
literal|0
operator|||
name|msize
operator|<
literal|0
operator|||
name|mpos
operator|+
name|msize
operator|>
name|shmds
operator|.
name|shm_segsz
condition|)
block|{
name|SETERRNO
argument_list|(
name|EFAULT
argument_list|,
name|SS$_ACCVIO
argument_list|)
expr_stmt|;
comment|/* can't do as caller requested */
return|return
operator|-
literal|1
return|;
block|}
name|shm
operator|=
operator|(
name|char
operator|*
operator|)
name|shmat
argument_list|(
name|id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|optype
operator|==
name|OP_SHMREAD
operator|)
condition|?
name|SHM_RDONLY
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shm
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
comment|/* I hate System V IPC, I really do */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|optype
operator|==
name|OP_SHMREAD
condition|)
block|{
comment|/* suppress warning when reading into undef var (tchrist 3/Mar/00) */
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|mstr
argument_list|)
condition|)
name|sv_setpvn
argument_list|(
name|mstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|SvGROW
argument_list|(
name|mstr
argument_list|,
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|shm
operator|+
name|mpos
argument_list|,
name|mbuf
argument_list|,
name|msize
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|mstr
argument_list|,
name|msize
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|mstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
comment|/* who knows who has been playing with this shared memory? */
name|SvTAINTED_on
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|I32
name|n
decl_stmt|;
name|mbuf
operator|=
name|SvPV
argument_list|(
name|mstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|len
operator|)
operator|>
name|msize
condition|)
name|n
operator|=
name|msize
expr_stmt|;
name|Copy
argument_list|(
name|mbuf
argument_list|,
name|shm
operator|+
name|mpos
argument_list|,
name|n
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|msize
condition|)
name|memzero
argument_list|(
name|shm
operator|+
name|mpos
operator|+
name|n
argument_list|,
name|msize
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|shmdt
argument_list|(
name|shm
argument_list|)
return|;
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"shm I/O not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV IPC */
end_comment

end_unit

