begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    malloc.c  *  */
end_comment

begin_comment
comment|/*   Here are some notes on configuring Perl's malloc.     There are two macros which serve as bulk disablers of advanced   features of this malloc: NO_FANCY_MALLOC, PLAIN_MALLOC (undef by   default).  Look in the list of default values below to understand   their exact effect.  Defining NO_FANCY_MALLOC returns malloc.c to the   state of the malloc in Perl 5.004.  Additionally defining PLAIN_MALLOC   returns it to the state as of Perl 5.000.    Note that some of the settings below may be ignored in the code based   on values of other macros.  The PERL_CORE symbol is only defined when   perl itself is being compiled (so malloc can make some assumptions   about perl's facilities being available to it).    Each config option has a short description, followed by its name,   default value, and a comment about the default (if applicable).  Some   options take a precise value, while the others are just boolean.   The boolean ones are listed first.      # Enable code for an emergency memory pool in $^M.  See perlvar.pod     # for a description of $^M.     PERL_EMERGENCY_SBRK		(!PLAIN_MALLOC&& PERL_CORE)      # Enable code for printing memory statistics.     DEBUGGING_MSTATS		(!PLAIN_MALLOC&& PERL_CORE)      # Move allocation info for small buckets into separate areas.     # Memory optimization (especially for small allocations, of the     # less than 64 bytes).  Since perl usually makes a large number     # of small allocations, this is usually a win.     PACK_MALLOC			(!PLAIN_MALLOC&& !RCHECK)      # Add one page to big powers of two when calculating bucket size.     # This is targeted at big allocations, as are common in image     # processing.     TWO_POT_OPTIMIZE		!PLAIN_MALLOC       # Use intermediate bucket sizes between powers-of-two.  This is     # generally a memory optimization, and a (small) speed pessimization.     BUCKETS_ROOT2		!NO_FANCY_MALLOC      # Do not check small deallocations for bad free().  Memory     # and speed optimization, error reporting pessimization.     IGNORE_SMALL_BAD_FREE	(!NO_FANCY_MALLOC&& !RCHECK)      # Use table lookup to decide in which bucket a given allocation will go.     SMALL_BUCKET_VIA_TABLE	!NO_FANCY_MALLOC      # Use a perl-defined sbrk() instead of the (presumably broken or     # missing) system-supplied sbrk().     USE_PERL_SBRK		undef      # Use system malloc() (or calloc() etc.) to emulate sbrk(). Normally     # only used with broken sbrk()s.     PERL_SBRK_VIA_MALLOC	undef      # Which allocator to use if PERL_SBRK_VIA_MALLOC     SYSTEM_ALLOC(a) 		malloc(a)      # Disable memory overwrite checking with DEBUGGING.  Memory and speed     # optimization, error reporting pessimization.     NO_RCHECK			undef      # Enable memory overwrite checking with DEBUGGING.  Memory and speed     # pessimization, error reporting optimization     RCHECK			(DEBUGGING&& !NO_RCHECK)      # Failed allocations bigger than this size croak (if     # PERL_EMERGENCY_SBRK is enabled) without touching $^M.  See     # perlvar.pod for a description of $^M.     BIG_SIZE			 (1<<16)	# 64K      # Starting from this power of two, add an extra page to the     # size of the bucket. This enables optimized allocations of sizes     # close to powers of 2.  Note that the value is indexed at 0.     FIRST_BIG_POW2 		15		# 32K, 16K is used too often      # Estimate of minimal memory footprint.  malloc uses this value to     # request the most reasonable largest blocks of memory from the system.     FIRST_SBRK 			(48*1024)      # Round up sbrk()s to multiples of this.     MIN_SBRK 			2048      # Round up sbrk()s to multiples of this percent of footprint.     MIN_SBRK_FRAC 		3      # Add this much memory to big powers of two to get the bucket size.     PERL_PAGESIZE 		4096      # This many sbrk() discontinuities should be tolerated even     # from the start without deciding that sbrk() is usually     # discontinuous.     SBRK_ALLOW_FAILURES		3      # This many continuous sbrk()s compensate for one discontinuous one.     SBRK_FAILURE_PRICE		50      # Some configurations may ask for 12-byte-or-so allocations which     # require 8-byte alignment (?!).  In such situation one needs to     # define this to disable 12-byte bucket (will increase memory footprint)     STRICT_ALIGNMENT		undef    This implementation assumes that calling PerlIO_printf() does not   result in any memory allocation calls (used during a panic).   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FANCY_MALLOC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL_BUCKET_VIA_TABLE
end_ifndef

begin_define
define|#
directive|define
name|SMALL_BUCKET_VIA_TABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUCKETS_ROOT2
end_ifndef

begin_define
define|#
directive|define
name|BUCKETS_ROOT2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SMALL_BAD_FREE
end_ifndef

begin_define
define|#
directive|define
name|IGNORE_SMALL_BAD_FREE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PLAIN_MALLOC
end_ifndef

begin_comment
comment|/* Bulk enable features */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PACK_MALLOC
end_ifndef

begin_define
define|#
directive|define
name|PACK_MALLOC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TWO_POT_OPTIMIZE
end_ifndef

begin_define
define|#
directive|define
name|TWO_POT_OPTIMIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PERL_EMERGENCY_SBRK
argument_list|)
end_if

begin_define
define|#
directive|define
name|PERL_EMERGENCY_SBRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEBUGGING_MSTATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MIN_BUC_POW2
value|(sizeof(void*)> 4 ? 3 : 2)
end_define

begin_comment
comment|/* Allow for 4-byte arena. */
end_comment

begin_define
define|#
directive|define
name|MIN_BUCKET
value|(MIN_BUC_POW2 * BUCKETS_PER_POW2)
end_define

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
operator|)
end_if

begin_comment
comment|/* take 2k unless the block is bigger than that */
end_comment

begin_define
define|#
directive|define
name|LOG_OF_MIN_ARENA
value|11
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* take 16k unless the block is bigger than that  	   (80286s like large segments!), probably good on the atari too */
end_comment

begin_define
define|#
directive|define
name|LOG_OF_MIN_ARENA
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_RCHECK
argument_list|)
end_if

begin_define
define|#
directive|define
name|RCHECK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RCHECK
argument_list|)
operator|&&
name|defined
argument_list|(
name|IGNORE_SMALL_BAD_FREE
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|IGNORE_SMALL_BAD_FREE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * malloc.c (Caltech) 2/21/82  * Chris Kingsley, kingsley@cit-20.  *  * This is a very fast storage allocator.  It allocates blocks of a small   * number of different sizes, and keeps free lists of each size.  Blocks that  * don't exactly fit are passed up to the next larger size.  In this   * implementation, the available sizes are 2^n-4 (or 2^n-12) bytes long.  * If PACK_MALLOC is defined, small blocks are 2^n bytes long.  * This is designed for use in a program that uses vast quantities of memory,  * but bombs when it runs out.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_CORE
end_ifdef

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FOR_X2P
end_ifdef

begin_include
include|#
directive|include
file|"../EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"../perl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|arg
parameter_list|)
value|arg
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|Malloc_t
end_ifndef

begin_define
define|#
directive|define
name|Malloc_t
value|void *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MEM_SIZE
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|0x7FFFFFFF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV
end_ifndef

begin_define
define|#
directive|define
name|UV
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|caddr_t
end_ifndef

begin_define
define|#
directive|define
name|caddr_t
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Free_t
end_ifndef

begin_define
define|#
directive|define
name|Free_t
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Copy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|(void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
end_define

begin_define
define|#
directive|define
name|PerlEnv_getenv
value|getenv
end_define

begin_define
define|#
directive|define
name|PerlIO_printf
value|fprintf
end_define

begin_define
define|#
directive|define
name|PerlIO_stderr
parameter_list|()
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|croak
end_ifndef

begin_comment
comment|/* make depend */
end_comment

begin_define
define|#
directive|define
name|croak
parameter_list|(
name|mess
parameter_list|,
name|arg
parameter_list|)
value|warn((mess), (arg)); exit(1);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|warn
end_ifndef

begin_define
define|#
directive|define
name|warn
parameter_list|(
name|mess
parameter_list|,
name|arg
parameter_list|)
value|fprintf(stderr, (mess), (arg));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_m
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUG_m
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUG_m
parameter_list|(
name|a
parameter_list|)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUGGING
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MUTEX_LOCK
end_ifndef

begin_define
define|#
directive|define
name|MUTEX_LOCK
parameter_list|(
name|l
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MUTEX_UNLOCK
end_ifndef

begin_define
define|#
directive|define
name|MUTEX_UNLOCK
parameter_list|(
name|l
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUG_m
end_undef

begin_define
define|#
directive|define
name|DEBUG_m
parameter_list|(
name|a
parameter_list|)
value|if (PL_debug& 128)   a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I don't much care whether these are defined in sys/types.h--LAW */
end_comment

begin_define
define|#
directive|define
name|u_char
value|unsigned char
end_define

begin_define
define|#
directive|define
name|u_int
value|unsigned int
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_QUAD
end_ifdef

begin_define
define|#
directive|define
name|u_bigint
value|UV
end_define

begin_comment
comment|/* Needs to eat *void. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* needed? */
end_comment

begin_define
define|#
directive|define
name|u_bigint
value|unsigned long
end_define

begin_comment
comment|/* Needs to eat *void. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|u_short
value|unsigned short
end_define

begin_comment
comment|/* 286 and atarist like big chunks, which gives too much overhead. */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|RCHECK
argument_list|)
operator|||
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|PACK_MALLOC
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|PACK_MALLOC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The description below is applicable if PACK_MALLOC is not defined.  *  * The overhead on a block is at least 4 bytes.  When free, this space  * contains a pointer to the next free block, and the bottom two bits must  * be zero.  When in use, the first byte is set to MAGIC, and the second  * byte is the size index.  The remaining bytes are for alignment.  * If range checking is enabled and the size of the block fits  * in two bytes, then the top two bytes hold the size of the requested block  * plus the range checking words, and the header word MINUS ONE.  */
end_comment

begin_union
union|union
name|overhead
block|{
name|union
name|overhead
modifier|*
name|ov_next
decl_stmt|;
comment|/* when free */
if|#
directive|if
name|MEM_ALIGNBYTES
operator|>
literal|4
name|double
name|strut
decl_stmt|;
comment|/* alignment problems */
endif|#
directive|endif
struct|struct
block|{
name|u_char
name|ovu_magic
decl_stmt|;
comment|/* magic number */
name|u_char
name|ovu_index
decl_stmt|;
comment|/* bucket # */
ifdef|#
directive|ifdef
name|RCHECK
name|u_short
name|ovu_size
decl_stmt|;
comment|/* actual block size */
name|u_int
name|ovu_rmagic
decl_stmt|;
comment|/* range magic number */
endif|#
directive|endif
block|}
name|ovu
struct|;
define|#
directive|define
name|ov_magic
value|ovu.ovu_magic
define|#
directive|define
name|ov_index
value|ovu.ovu_index
define|#
directive|define
name|ov_size
value|ovu.ovu_size
define|#
directive|define
name|ov_rmagic
value|ovu.ovu_rmagic
block|}
union|;
end_union

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|botch
name|_
argument_list|(
operator|(
name|char
operator|*
name|diag
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|morecore
name|_
argument_list|(
operator|(
name|int
name|bucket
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findbucket
name|_
argument_list|(
operator|(
expr|union
name|overhead
operator|*
name|freep
operator|,
name|int
name|srchlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_to_chain
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|,
name|MEM_SIZE
name|chip
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAGIC
value|0xff
end_define

begin_comment
comment|/* magic # on accounting info */
end_comment

begin_define
define|#
directive|define
name|RMAGIC
value|0x55555555
end_define

begin_comment
comment|/* magic # on range info */
end_comment

begin_define
define|#
directive|define
name|RMAGIC_C
value|0x55
end_define

begin_comment
comment|/* magic # on range info */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCHECK
end_ifdef

begin_define
define|#
directive|define
name|RSLOP
value|sizeof (u_int)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
end_ifdef

begin_define
define|#
directive|define
name|MAX_SHORT_BUCKET
value|(12 * BUCKETS_PER_POW2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_SHORT_BUCKET
value|(13 * BUCKETS_PER_POW2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RSLOP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PACK_MALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUCKETS_ROOT2
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|BUCKETS_ROOT2
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|BUCKET_TABLE_SHIFT
value|2
end_define

begin_define
define|#
directive|define
name|BUCKET_POW2_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|BUCKETS_PER_POW2
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUCKET_TABLE_SHIFT
value|MIN_BUC_POW2
end_define

begin_define
define|#
directive|define
name|BUCKET_POW2_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|BUCKETS_PER_POW2
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MEM_ALIGNBYTES
argument_list|)
operator|||
operator|(
operator|(
name|MEM_ALIGNBYTES
operator|>
literal|4
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRICT_ALIGNMENT
argument_list|)
operator|)
end_if

begin_comment
comment|/* Figure out the alignment of void*. */
end_comment

begin_struct
struct|struct
name|aligner
block|{
name|char
name|c
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ALIGN_SMALL
value|((int)((caddr_t)&(((struct aligner*)0)->p)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ALIGN_SMALL
value|MEM_ALIGNBYTES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IF_ALIGN_8
parameter_list|(
name|yes
parameter_list|,
name|no
parameter_list|)
value|((ALIGN_SMALL>4) ? (yes) : (no))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MAX_BUCKET_BY_TABLE
value|13
end_define

begin_decl_stmt
specifier|static
name|u_short
name|buck_size
index|[
name|MAX_BUCKET_BY_TABLE
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|32
block|,
literal|48
block|,
literal|64
block|,
literal|80
block|,   }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUCKET_SIZE
parameter_list|(
name|i
parameter_list|)
value|((i) % 2 ? buck_size[i] : (1<< ((i)>> BUCKET_POW2_SHIFT)))
end_define

begin_define
define|#
directive|define
name|BUCKET_SIZE_REAL
parameter_list|(
name|i
parameter_list|)
value|((i)<= MAX_BUCKET_BY_TABLE		\ 			       ? buck_size[i] 				\ 			       : ((1<< ((i)>> BUCKET_POW2_SHIFT))	\ 				  - MEM_OVERHEAD(i)			\ 				  + POW2_OPTIMIZE_SURPLUS(i)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUCKET_SIZE
parameter_list|(
name|i
parameter_list|)
value|(1<< ((i)>> BUCKET_POW2_SHIFT))
end_define

begin_define
define|#
directive|define
name|BUCKET_SIZE_REAL
parameter_list|(
name|i
parameter_list|)
value|(BUCKET_SIZE(i) - MEM_OVERHEAD(i) + POW2_OPTIMIZE_SURPLUS(i))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PACK_MALLOC
end_ifdef

begin_comment
comment|/* In this case it is assumed that if we do sbrk() in 2K units, we  * will get 2K aligned arenas (at least after some initial  * alignment). The bucket number of the given subblock is on the start  * of 2K arena which contains the subblock.  Several following bytes  * contain the magic numbers for the subblocks in the block.  *  * Sizes of chunks are powers of 2 for chunks in buckets<=  * MAX_PACKED, after this they are (2^n - sizeof(union overhead)) (to  * get alignment right).  *  * Consider an arena for 2^n with n>MAX_PACKED.  We suppose that  * starts of all the chunks in a 2K arena are in different  * 2^n-byte-long chunks.  If the top of the last chunk is aligned on a  * boundary of 2K block, this means that sizeof(union  * overhead)*"number of chunks"< 2^n, or sizeof(union overhead)*2K<  * 4^n, or n> 6 + log2(sizeof()/2)/2, since a chunk of size 2^n -  * overhead is used.  Since this rules out n = 7 for 8 byte alignment,  * we specialcase allocation of the first of 16 128-byte-long chunks.  *  * Note that with the above assumption we automatically have enough  * place for MAGIC at the start of 2K block.  Note also that we  * overlay union overhead over the chunk, thus the start of small chunks  * is immediately overwritten after freeing.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PACKED_POW2
value|6
end_define

begin_define
define|#
directive|define
name|MAX_PACKED
value|(MAX_PACKED_POW2 * BUCKETS_PER_POW2 + BUCKET_POW2_SHIFT)
end_define

begin_define
define|#
directive|define
name|MAX_POW2_ALGO
value|((1<<(MAX_PACKED_POW2 + 1)) - M_OVERHEAD)
end_define

begin_define
define|#
directive|define
name|TWOK_MASK
value|((1<<LOG_OF_MIN_ARENA) - 1)
end_define

begin_define
define|#
directive|define
name|TWOK_MASKED
parameter_list|(
name|x
parameter_list|)
value|((u_bigint)(x)& ~TWOK_MASK)
end_define

begin_define
define|#
directive|define
name|TWOK_SHIFT
parameter_list|(
name|x
parameter_list|)
value|((u_bigint)(x)& TWOK_MASK)
end_define

begin_define
define|#
directive|define
name|OV_INDEXp
parameter_list|(
name|block
parameter_list|)
value|((u_char*)(TWOK_MASKED(block)))
end_define

begin_define
define|#
directive|define
name|OV_INDEX
parameter_list|(
name|block
parameter_list|)
value|(*OV_INDEXp(block))
end_define

begin_define
define|#
directive|define
name|OV_MAGIC
parameter_list|(
name|block
parameter_list|,
name|bucket
parameter_list|)
value|(*(OV_INDEXp(block) +			\ 				    (TWOK_SHIFT(block)>>		\ 				     (bucket>>BUCKET_POW2_SHIFT)) +	\ 				    (bucket>= MIN_NEEDS_SHIFT ? 1 : 0)))
end_define

begin_comment
comment|/* A bucket can have a shift smaller than it size, we need to        shift its magic number so it will not overwrite index: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MIN_NEEDS_SHIFT
value|(7*BUCKETS_PER_POW2 - 1)
end_define

begin_comment
comment|/* Shift 80 greater than chunk 64. */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIN_NEEDS_SHIFT
value|(7*BUCKETS_PER_POW2)
end_define

begin_comment
comment|/* Shift 128 greater than chunk 32. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHUNK_SHIFT
value|0
end_define

begin_comment
comment|/* Number of active buckets of given ordinal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
end_ifdef

begin_define
define|#
directive|define
name|FIRST_BUCKET_WITH_CHECK
value|(6 * BUCKETS_PER_POW2)
end_define

begin_comment
comment|/* 64 */
end_comment

begin_define
define|#
directive|define
name|N_BLKS
parameter_list|(
name|bucket
parameter_list|)
value|( (bucket)< FIRST_BUCKET_WITH_CHECK 		\ 			 ? ((1<<LOG_OF_MIN_ARENA) - 1)/BUCKET_SIZE(bucket) \ 			 : n_blks[bucket] )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|N_BLKS
parameter_list|(
name|bucket
parameter_list|)
value|n_blks[bucket]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_short
name|n_blks
index|[
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
index|]
init|=
block|{
if|#
directive|if
name|BUCKETS_PER_POW2
operator|==
literal|1
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
literal|224
block|,
literal|120
block|,
literal|62
block|,
literal|31
block|,
literal|16
block|,
literal|8
block|,
literal|4
block|,
literal|2
else|#
directive|else
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
comment|/* 4, 4 */
literal|224
block|,
literal|149
block|,
literal|120
block|,
literal|80
block|,
literal|62
block|,
literal|41
block|,
literal|31
block|,
literal|25
block|,
literal|16
block|,
literal|16
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shift of the first bucket with the given ordinal inside 2K chunk. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
end_ifdef

begin_define
define|#
directive|define
name|BLK_SHIFT
parameter_list|(
name|bucket
parameter_list|)
value|( (bucket)< FIRST_BUCKET_WITH_CHECK 	\ 			      ? ((1<<LOG_OF_MIN_ARENA)			\ 				 - BUCKET_SIZE(bucket) * N_BLKS(bucket)) \ 			      : blk_shift[bucket])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BLK_SHIFT
parameter_list|(
name|bucket
parameter_list|)
value|blk_shift[bucket]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_short
name|blk_shift
index|[
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
index|]
init|=
block|{
if|#
directive|if
name|BUCKETS_PER_POW2
operator|==
literal|1
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
literal|256
block|,
literal|128
block|,
literal|64
block|,
literal|64
block|,
comment|/* 8 to 64 */
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
else|#
directive|else
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
literal|256
block|,
literal|260
block|,
literal|128
block|,
literal|128
block|,
literal|64
block|,
literal|80
block|,
literal|64
block|,
literal|48
block|,
comment|/* 8 to 96 */
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|OV_MAGIC
parameter_list|(
name|block
parameter_list|,
name|bucket
parameter_list|)
value|(block)->ov_magic
end_define

begin_define
define|#
directive|define
name|OV_INDEX
parameter_list|(
name|block
parameter_list|)
value|(block)->ov_index
end_define

begin_define
define|#
directive|define
name|CHUNK_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MAX_PACKED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|M_OVERHEAD
value|(sizeof(union overhead) + RSLOP)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PACK_MALLOC
end_ifdef

begin_define
define|#
directive|define
name|MEM_OVERHEAD
parameter_list|(
name|bucket
parameter_list|)
define|\
value|(bucket<= MAX_PACKED ? 0 : M_OVERHEAD)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
end_ifdef

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|((MAX_PACKED_POW2 + 1) * BUCKETS_PER_POW2)
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|MAX_PACKED_POW2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_comment
comment|/* Chunks of size 3*2^n. */
end_comment

begin_define
define|#
directive|define
name|SIZE_TABLE_MAX
value|80
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIZE_TABLE_MAX
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|bucket_of
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
comment|/* Chunks of size 3*2^n. */
comment|/* 0 to 15 in 4-byte increments. */
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|>
literal|4
operator|?
literal|6
operator|:
literal|5
operator|)
block|,
comment|/* 4/8, 5-th bucket for better reports */
literal|6
block|,
comment|/* 8 */
name|IF_ALIGN_8
argument_list|(
literal|8
argument_list|,
literal|7
argument_list|)
block|,
literal|8
block|,
comment|/* 16/12, 16 */
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
comment|/* 24, 32 */
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
comment|/* 48 */
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
comment|/* 64 */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
comment|/* 80 */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
comment|/* 80 */
else|#
directive|else
comment|/* !BUCKETS_ROOT2 */
comment|/* 0 to 15 in 4-byte increments. */
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|>
literal|4
operator|?
literal|3
operator|:
literal|2
operator|)
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
endif|#
directive|endif
comment|/* !BUCKETS_ROOT2 */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMALL_BUCKET_VIA_TABLE */
end_comment

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|MIN_BUCKET
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|(MIN_BUC_POW2 - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMALL_BUCKET_VIA_TABLE */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|MEM_OVERHEAD
parameter_list|(
name|bucket
parameter_list|)
value|M_OVERHEAD
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
end_ifdef

begin_undef
undef|#
directive|undef
name|SMALL_BUCKET_VIA_TABLE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|MIN_BUCKET
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|(MIN_BUC_POW2 - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_comment
comment|/*  * Big allocations are often of the size 2^n bytes. To make them a  * little bit better, make blocks of size 2^n+pagesize for big n.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PAGESIZE
end_ifndef

begin_define
define|#
directive|define
name|PERL_PAGESIZE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_BIG_POW2
end_ifndef

begin_define
define|#
directive|define
name|FIRST_BIG_POW2
value|15
end_define

begin_comment
comment|/* 32K, 16K is used too often. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FIRST_BIG_BLOCK
value|(1<<FIRST_BIG_POW2)
end_define

begin_comment
comment|/* If this value or more, check against bigger blocks. */
end_comment

begin_define
define|#
directive|define
name|FIRST_BIG_BOUND
value|(FIRST_BIG_BLOCK - M_OVERHEAD)
end_define

begin_comment
comment|/* If less than this value, goes into 2^n-overhead-block. */
end_comment

begin_define
define|#
directive|define
name|LAST_SMALL_BOUND
value|((FIRST_BIG_BLOCK>>1) - M_OVERHEAD)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_ADJUST
parameter_list|(
name|nbytes
parameter_list|)
define|\
value|((nbytes>= FIRST_BIG_BOUND) ? nbytes -= PERL_PAGESIZE : 0)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_SURPLUS
parameter_list|(
name|bucket
parameter_list|)
define|\
value|((bucket>= FIRST_BIG_POW2 * BUCKETS_PER_POW2) ? PERL_PAGESIZE : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !TWO_POT_OPTIMIZE */
end_comment

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_ADJUST
parameter_list|(
name|nbytes
parameter_list|)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_SURPLUS
parameter_list|(
name|bucket
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TWO_POT_OPTIMIZE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_64K_LIMIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
end_if

begin_define
define|#
directive|define
name|BARK_64K_LIMIT
parameter_list|(
name|what
parameter_list|,
name|nbytes
parameter_list|,
name|size
parameter_list|)
define|\
value|if (nbytes> 0xffff) {						\ 		PerlIO_printf(PerlIO_stderr(),				\ 			      "%s too large: %lx\n", what, size);	\ 		my_exit(1);						\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAS_64K_LIMIT || !PERL_CORE */
end_comment

begin_define
define|#
directive|define
name|BARK_64K_LIMIT
parameter_list|(
name|what
parameter_list|,
name|nbytes
parameter_list|,
name|size
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_64K_LIMIT || !PERL_CORE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_SBRK
end_ifndef

begin_define
define|#
directive|define
name|MIN_SBRK
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_SBRK
end_ifndef

begin_define
define|#
directive|define
name|FIRST_SBRK
value|(48*1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minimal sbrk in percents of what is already alloced. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_SBRK_FRAC
end_ifndef

begin_define
define|#
directive|define
name|MIN_SBRK_FRAC
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SBRK_ALLOW_FAILURES
end_ifndef

begin_define
define|#
directive|define
name|SBRK_ALLOW_FAILURES
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SBRK_FAILURE_PRICE
end_ifndef

begin_define
define|#
directive|define
name|SBRK_FAILURE_PRICE
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_EMERGENCY_SBRK
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|BIG_SIZE
end_ifndef

begin_define
define|#
directive|define
name|BIG_SIZE
value|(1<<16)
end_define

begin_comment
comment|/* 64K */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MUTEX_INIT_CALLS_MALLOC
end_ifdef

begin_undef
undef|#
directive|undef
name|MUTEX_LOCK
end_undef

begin_define
define|#
directive|define
name|MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|STMT_START { if (*m) mutex_lock(*m); } STMT_END
end_define

begin_undef
undef|#
directive|undef
name|MUTEX_UNLOCK
end_undef

begin_define
define|#
directive|define
name|MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|STMT_START { if (*m) mutex_unlock(*m); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|emergency_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MEM_SIZE
name|emergency_buffer_size
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|Malloc_t
name|emergency_sbrk
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|Malloc_t
name|emergency_sbrk
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|MEM_SIZE
name|rsize
init|=
operator|(
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|LOG_OF_MIN_ARENA
operator|)
operator|+
literal|1
operator|)
operator|<<
name|LOG_OF_MIN_ARENA
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|BIG_SIZE
condition|)
block|{
comment|/* Give the possibility to recover: */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"Out of memory during \"large\" request for %i bytes"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emergency_buffer_size
operator|>=
name|rsize
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|emergency_buffer
decl_stmt|;
name|emergency_buffer_size
operator|-=
name|rsize
expr_stmt|;
name|emergency_buffer
operator|+=
name|rsize
expr_stmt|;
return|return
name|old
return|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
comment|/* First offense, give a possibility to recover by dieing. */
comment|/* No malloc involved here: */
name|GV
modifier|*
modifier|*
name|gvp
init|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
literal|"^M"
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|pv
decl_stmt|;
name|int
name|have
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|emergency_buffer_size
condition|)
block|{
name|add_to_chain
argument_list|(
name|emergency_buffer
argument_list|,
name|emergency_buffer_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emergency_buffer_size
operator|=
literal|0
expr_stmt|;
name|emergency_buffer
operator|=
name|Nullch
expr_stmt|;
name|have
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gvp
condition|)
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
literal|"\015"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
operator|||
operator|!
operator|(
name|sv
operator|=
name|GvSV
argument_list|(
operator|*
name|gvp
argument_list|)
operator|)
operator|||
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|LOG_OF_MIN_ARENA
operator|)
operator|-
name|M_OVERHEAD
operator|)
condition|)
block|{
if|if
condition|(
name|have
condition|)
goto|goto
name|do_croak
goto|;
return|return
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* Now die die die... */
block|}
comment|/* Got it, now detach SvPV: */
name|pv
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
comment|/* Check alignment: */
if|if
condition|(
operator|(
call|(
name|UV
call|)
argument_list|(
name|pv
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|LOG_OF_MIN_ARENA
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Bad alignment of $^M!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* die die die */
block|}
name|emergency_buffer
operator|=
name|pv
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
expr_stmt|;
name|emergency_buffer_size
operator|=
name|malloced_size
argument_list|(
name|pv
argument_list|)
operator|+
name|M_OVERHEAD
expr_stmt|;
name|SvPOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|Nullch
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|do_croak
label|:
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"Out of memory during request for %i bytes"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(defined(PERL_EMERGENCY_SBRK)&& defined(PERL_CORE)) */
end_comment

begin_define
define|#
directive|define
name|emergency_sbrk
parameter_list|(
name|size
parameter_list|)
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(defined(PERL_EMERGENCY_SBRK)&& defined(PERL_CORE)) */
end_comment

begin_comment
comment|/*  * nextf[i] is the pointer to the next free block of size 2^i.  The  * smallest allocatable block is 8 bytes.  The overhead information  * precedes the data area returned to the user.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|(32*BUCKETS_PER_POW2 + 1)
end_define

begin_decl_stmt
specifier|static
name|union
name|overhead
modifier|*
name|nextf
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PERL_SBRK
end_ifdef

begin_define
define|#
directive|define
name|sbrk
parameter_list|(
name|a
parameter_list|)
value|Perl_sbrk(a)
end_define

begin_decl_stmt
name|Malloc_t
name|Perl_sbrk
name|_
argument_list|(
operator|(
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_DECLARE_STD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|Malloc_t
name|sbrk
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
end_ifdef

begin_comment
comment|/*  * nmalloc[i] is the difference between the number of mallocs and frees  * for a given block size.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nmalloc
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|sbrk_slack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|start_slack
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int
name|goodsbrk
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|ASSERT
end_undef

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|,
name|diag
parameter_list|)
value|if (!(p)) botch(diag,STRINGIFY(p));  else
end_define

begin_function
specifier|static
name|void
name|botch
parameter_list|(
name|char
modifier|*
name|diag
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"assertion botched (%s?): %s\n"
argument_list|,
name|diag
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PerlProc_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|,
name|diag
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Malloc_t
name|malloc
parameter_list|(
specifier|register
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|register
name|union
name|overhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bucket
decl_stmt|;
specifier|register
name|MEM_SIZE
name|shiftr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|RCHECK
argument_list|)
name|MEM_SIZE
name|size
init|=
name|nbytes
decl_stmt|;
endif|#
directive|endif
name|BARK_64K_LIMIT
argument_list|(
literal|"Allocation"
argument_list|,
name|nbytes
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|nbytes
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"panic: malloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Convert amount of memory requested into 	 * closest block size stored in hash buckets 	 * which satisfies request.  Account for 	 * space used per block for accounting. 	 */
ifdef|#
directive|ifdef
name|PACK_MALLOC
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|bucket
operator|=
name|MIN_BUCKET
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|SIZE_TABLE_MAX
condition|)
block|{
name|bucket
operator|=
name|bucket_of
index|[
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
name|BUCKET_TABLE_SHIFT
index|]
expr_stmt|;
block|}
elseif|else
else|#
directive|else
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|nbytes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
name|MAX_POW2_ALGO
condition|)
goto|goto
name|do_shifts
goto|;
else|else
endif|#
directive|endif
endif|#
directive|endif
block|{
name|POW2_OPTIMIZE_ADJUST
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|M_OVERHEAD
expr_stmt|;
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|do_shifts
label|:
name|shiftr
operator|=
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
name|START_SHIFT
expr_stmt|;
name|bucket
operator|=
name|START_SHIFTS_BUCKET
expr_stmt|;
comment|/* apart from this loop, this is O(1) */
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|bucket
operator|+=
name|BUCKETS_PER_POW2
expr_stmt|;
block|}
comment|/* 	 * If nothing in hash bucket right now, 	 * request more memory from the system. 	 */
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
operator|==
name|NULL
condition|)
name|morecore
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|nextf
index|[
name|bucket
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_CORE
if|if
condition|(
operator|!
name|PL_nomemok
condition|)
block|{
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05lu) malloc %ld bytes\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|p
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove from linked list */
if|#
directive|if
name|defined
argument_list|(
name|RCHECK
argument_list|)
if|if
condition|(
operator|(
operator|(
name|UV
operator|)
name|p
operator|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Corrupt malloc ptr 0x%lx at 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nextf
index|[
name|bucket
index|]
operator|=
name|p
operator|->
name|ov_next
expr_stmt|;
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
name|bucket
operator|>=
name|FIRST_BUCKET_WITH_CHECK
condition|)
endif|#
directive|endif
name|OV_MAGIC
argument_list|(
name|p
argument_list|,
name|bucket
argument_list|)
operator|=
name|MAGIC
expr_stmt|;
ifndef|#
directive|ifndef
name|PACK_MALLOC
name|OV_INDEX
argument_list|(
name|p
argument_list|)
operator|=
name|bucket
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RCHECK
comment|/* 	 * Record allocated size of block and 	 * bound space with magic numbers. 	 */
name|p
operator|->
name|ov_rmagic
operator|=
name|RMAGIC
expr_stmt|;
if|if
condition|(
name|bucket
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|;
name|nbytes
operator|=
name|size
operator|+
name|M_OVERHEAD
expr_stmt|;
name|p
operator|->
name|ov_size
operator|=
name|nbytes
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|=
name|RMAGIC_C
expr_stmt|;
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|Malloc_t
call|)
argument_list|(
name|p
operator|+
name|CHUNK_SHIFT
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_sbrk_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This arena can be easily extended. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sbrked_remains
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbrk_good
init|=
name|SBRK_ALLOW_FAILURES
operator|*
name|SBRK_FAILURE_PRICE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sbrks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|chunk_chain_s
block|{
name|struct
name|chunk_chain_s
modifier|*
name|next
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|chunk_chain_s
modifier|*
name|chunk_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_chunks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|max_bucket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cutoff a piece of one of the chunks in the chain.  Prefer smaller chunk. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|get_from_chain
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|struct
name|chunk_chain_s
modifier|*
name|elt
init|=
name|chunk_chain
decl_stmt|,
modifier|*
modifier|*
name|oldp
init|=
operator|&
name|chunk_chain
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
modifier|*
name|oldgoodp
init|=
name|NULL
decl_stmt|;
name|long
name|min_remain
init|=
name|LONG_MAX
decl_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|size
operator|>=
name|size
condition|)
block|{
name|long
name|remains
init|=
name|elt
operator|->
name|size
operator|-
name|size
decl_stmt|;
if|if
condition|(
name|remains
operator|>=
literal|0
operator|&&
name|remains
operator|<
name|min_remain
condition|)
block|{
name|oldgoodp
operator|=
name|oldp
expr_stmt|;
name|min_remain
operator|=
name|remains
expr_stmt|;
block|}
if|if
condition|(
name|remains
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|oldp
operator|=
operator|&
operator|(
name|elt
operator|->
name|next
operator|)
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldgoodp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|min_remain
condition|)
block|{
name|void
modifier|*
name|ret
init|=
operator|*
name|oldgoodp
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
name|next
init|=
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
decl_stmt|;
operator|*
name|oldgoodp
operator|=
operator|(
expr|struct
name|chunk_chain_s
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|+
name|size
operator|)
expr_stmt|;
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|size
operator|=
name|min_remain
expr_stmt|;
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|void
modifier|*
name|ret
init|=
operator|*
name|oldgoodp
decl_stmt|;
operator|*
name|oldgoodp
operator|=
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
expr_stmt|;
name|n_chunks
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_to_chain
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|,
name|MEM_SIZE
name|chip
parameter_list|)
block|{
name|struct
name|chunk_chain_s
modifier|*
name|next
init|=
name|chunk_chain
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|cp
operator|+=
name|chip
expr_stmt|;
name|chunk_chain
operator|=
operator|(
expr|struct
name|chunk_chain_s
operator|*
operator|)
name|cp
expr_stmt|;
name|chunk_chain
operator|->
name|size
operator|=
name|size
operator|-
name|chip
expr_stmt|;
name|chunk_chain
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|n_chunks
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_from_bigger_buckets
parameter_list|(
name|int
name|bucket
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|int
name|price
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|bucketprice
index|[
name|NBUCKETS
index|]
decl_stmt|;
while|while
condition|(
name|bucket
operator|<=
name|max_bucket
condition|)
block|{
comment|/* We postpone stealing from bigger buckets until we want it 	   often enough. */
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
operator|&&
name|bucketprice
index|[
name|bucket
index|]
operator|++
operator|>=
name|price
condition|)
block|{
comment|/* Steal it! */
name|void
modifier|*
name|ret
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|nextf
index|[
name|bucket
index|]
operator|-
literal|1
operator|+
name|CHUNK_SHIFT
operator|)
decl_stmt|;
name|bucketprice
index|[
name|bucket
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|nextf
index|[
name|bucket
index|]
operator|)
operator|-
name|M_OVERHEAD
operator|==
name|last_op
condition|)
block|{
name|last_op
operator|=
name|NULL
expr_stmt|;
comment|/* Disable optimization */
block|}
name|nextf
index|[
name|bucket
index|]
operator|=
name|nextf
index|[
name|bucket
index|]
operator|->
name|ov_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|--
expr_stmt|;
name|start_slack
operator|-=
name|M_OVERHEAD
expr_stmt|;
endif|#
directive|endif
name|add_to_chain
argument_list|(
name|ret
argument_list|,
operator|(
name|BUCKET_SIZE
argument_list|(
name|bucket
argument_list|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|bucket
argument_list|)
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|bucket
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|overhead
modifier|*
name|getpages
parameter_list|(
name|int
name|needed
parameter_list|,
name|int
modifier|*
name|nblksp
parameter_list|,
name|int
name|bucket
parameter_list|)
block|{
comment|/* Need to do (possibly expensive) system call. Try to        optimize it for rare calling. */
name|MEM_SIZE
name|require
init|=
name|needed
operator|-
name|sbrked_remains
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|int
name|slack
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sbrk_good
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|last_sbrk_top
operator|&&
name|require
operator|<
name|FIRST_SBRK
condition|)
name|require
operator|=
name|FIRST_SBRK
expr_stmt|;
elseif|else
if|if
condition|(
name|require
operator|<
name|MIN_SBRK
condition|)
name|require
operator|=
name|MIN_SBRK
expr_stmt|;
if|if
condition|(
name|require
operator|<
name|goodsbrk
operator|*
name|MIN_SBRK_FRAC
operator|/
literal|100
condition|)
name|require
operator|=
name|goodsbrk
operator|*
name|MIN_SBRK_FRAC
operator|/
literal|100
expr_stmt|;
name|require
operator|=
operator|(
operator|(
name|require
operator|-
literal|1
operator|+
name|MIN_SBRK
operator|)
operator|/
name|MIN_SBRK
operator|)
operator|*
name|MIN_SBRK
expr_stmt|;
block|}
else|else
block|{
name|require
operator|=
name|needed
expr_stmt|;
name|last_sbrk_top
operator|=
literal|0
expr_stmt|;
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk(%ld) for %ld-byte-long arena\n"
argument_list|,
operator|(
name|long
operator|)
name|require
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
name|last_sbrk_top
condition|)
block|{
comment|/* Common case, anything is fine. */
name|sbrk_good
operator|++
expr_stmt|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
name|cp
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
name|sbrked_remains
operator|=
name|require
operator|-
operator|(
name|needed
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* no more room! */
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|emergency_sbrk
argument_list|(
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|ovp
return|;
block|}
else|else
block|{
comment|/* Non-continuous or first sbrk(). */
name|long
name|add
init|=
name|sbrked_remains
decl_stmt|;
name|char
modifier|*
name|newcp
decl_stmt|;
if|if
condition|(
name|sbrked_remains
condition|)
block|{
comment|/* Put rest into chain, we 				   cannot use it right now. */
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
argument_list|,
name|sbrked_remains
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Second, check alignment. */
name|slack
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|atarist
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINT__
argument_list|)
comment|/* on the atari we dont have to worry about this */
ifndef|#
directive|ifndef
name|I286
comment|/* The sbrk(0) call on the I286 always returns the next segment */
comment|/* CHUNK_SHIFT is 1 for PACK_MALLOC, 0 otherwise. */
if|if
condition|(
operator|(
name|UV
operator|)
name|cp
operator|&
operator|(
literal|0x7FF
operator|>>
name|CHUNK_SHIFT
operator|)
condition|)
block|{
comment|/* Not aligned. */
name|slack
operator|=
operator|(
literal|0x800
operator|>>
name|CHUNK_SHIFT
operator|)
operator|-
operator|(
operator|(
name|UV
operator|)
name|cp
operator|&
operator|(
literal|0x7FF
operator|>>
name|CHUNK_SHIFT
operator|)
operator|)
expr_stmt|;
name|add
operator|+=
name|slack
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !atarist&& !MINT */
if|if
condition|(
name|add
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk(%ld) to fix non-continuous/off-page sbrk:\n\t%ld for alignement,\t%ld were assumed to come from the tail of the previous sbrk\n"
argument_list|,
operator|(
name|long
operator|)
name|add
argument_list|,
operator|(
name|long
operator|)
name|slack
argument_list|,
operator|(
name|long
operator|)
name|sbrked_remains
argument_list|)
argument_list|)
expr_stmt|;
name|newcp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|add
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
name|sbrks
operator|++
expr_stmt|;
name|sbrk_slack
operator|+=
name|add
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newcp
operator|!=
name|cp
operator|+
name|require
condition|)
block|{
comment|/* Too bad: even rounding sbrk() is not continuous.*/
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"failed to fix bad sbrk()\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
if|if
condition|(
name|slack
condition|)
block|{
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"panic: Off-page sbrk"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sbrked_remains
condition|)
block|{
comment|/* Try again. */
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
name|sbrk_slack
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
name|require
operator|=
name|needed
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"straight sbrk(%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|require
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
name|sbrk_good
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Disable optimization! 				   Continue with not-aligned... */
block|}
else|else
block|{
name|cp
operator|+=
name|slack
expr_stmt|;
name|require
operator|+=
name|sbrked_remains
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_sbrk_top
condition|)
block|{
name|sbrk_good
operator|-=
name|SBRK_FAILURE_PRICE
expr_stmt|;
block|}
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|cp
expr_stmt|;
comment|/* 	 * Round up to minimum allocation size boundary 	 * and deduct from block count to reflect. 	 */
ifndef|#
directive|ifndef
name|I286
comment|/* Again, this should always be ok on an 80286 */
if|if
condition|(
operator|(
name|UV
operator|)
name|ovp
operator|&
literal|7
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
operator|(
name|UV
operator|)
name|ovp
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"fixing sbrk(): %d bytes off machine alignement\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|UV
operator|)
name|ovp
operator|&
literal|7
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nblksp
operator|)
operator|--
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
comment|/* This is only approx. if TWO_POT_OPTIMIZE: */
name|sbrk_slack
operator|+=
operator|(
literal|1
operator|<<
name|bucket
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|sbrked_remains
operator|=
name|require
operator|-
name|needed
expr_stmt|;
block|}
name|last_sbrk_top
operator|=
name|cp
operator|+
name|require
expr_stmt|;
name|last_op
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|goodsbrk
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
return|return
name|ovp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getpages_adjacent
parameter_list|(
name|int
name|require
parameter_list|)
block|{
if|if
condition|(
name|require
operator|<=
name|sbrked_remains
condition|)
block|{
name|sbrked_remains
operator|-=
name|require
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|require
operator|-=
name|sbrked_remains
expr_stmt|;
comment|/* We do not try to optimize sbrks here, we go for place. */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
name|goodsbrk
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
name|last_sbrk_top
condition|)
block|{
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
name|last_sbrk_top
operator|=
name|cp
operator|+
name|require
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Out of memory */
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|goodsbrk
operator|-=
name|require
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* Report the failure: */
if|if
condition|(
name|sbrked_remains
condition|)
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
argument_list|,
name|sbrked_remains
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|,
name|require
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbrk_good
operator|-=
name|SBRK_FAILURE_PRICE
expr_stmt|;
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
name|last_sbrk_top
operator|=
literal|0
expr_stmt|;
name|last_op
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate more memory to the indicated bucket.  */
end_comment

begin_function
specifier|static
name|void
name|morecore
parameter_list|(
specifier|register
name|int
name|bucket
parameter_list|)
block|{
specifier|register
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
specifier|register
name|int
name|rnu
decl_stmt|;
comment|/* 2^rnu bytes will be requested */
name|int
name|nblks
decl_stmt|;
comment|/* become nblks blocks of the desired size */
specifier|register
name|MEM_SIZE
name|siz
decl_stmt|,
name|needed
decl_stmt|;
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
condition|)
return|return;
if|if
condition|(
name|bucket
operator|==
sizeof|sizeof
argument_list|(
name|MEM_SIZE
argument_list|)
operator|*
literal|8
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"Out of memory during ridiculously large request"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bucket
operator|>
name|max_bucket
condition|)
name|max_bucket
operator|=
name|bucket
expr_stmt|;
name|rnu
operator|=
operator|(
operator|(
name|bucket
operator|<=
operator|(
name|LOG_OF_MIN_ARENA
operator|<<
name|BUCKET_POW2_SHIFT
operator|)
operator|)
condition|?
name|LOG_OF_MIN_ARENA
else|:
operator|(
name|bucket
operator|>>
name|BUCKET_POW2_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* This may be overwritten later: */
name|nblks
operator|=
literal|1
operator|<<
operator|(
name|rnu
operator|-
operator|(
name|bucket
operator|>>
name|BUCKET_POW2_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* how many blocks to get */
name|needed
operator|=
operator|(
operator|(
name|MEM_SIZE
operator|)
literal|1
operator|<<
name|rnu
operator|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
condition|)
block|{
comment|/* 2048b bucket. */
name|ovp
operator|=
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|-
literal|1
operator|+
name|CHUNK_SHIFT
expr_stmt|;
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|=
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|->
name|ov_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|--
expr_stmt|;
name|start_slack
operator|-=
name|M_OVERHEAD
expr_stmt|;
endif|#
directive|endif
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from %ld arena\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|,
operator|(
name|long
operator|)
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_chain
operator|&&
operator|(
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|get_from_chain
argument_list|(
name|needed
argument_list|)
operator|)
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from chain\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|get_from_bigger_buckets
argument_list|(
operator|(
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
operator|)
operator|+
literal|1
argument_list|,
name|needed
argument_list|)
operator|)
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from bigger buckets\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needed
operator|<=
name|sbrked_remains
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
name|sbrked_remains
operator|-=
name|needed
expr_stmt|;
name|last_op
operator|=
operator|(
name|char
operator|*
operator|)
name|ovp
expr_stmt|;
block|}
else|else
name|ovp
operator|=
name|getpages
argument_list|(
name|needed
argument_list|,
operator|&
name|nblks
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ovp
condition|)
return|return;
comment|/* 	 * Add new memory allocated to that on 	 * free list for this hash bucket. 	 */
name|siz
operator|=
name|BUCKET_SIZE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
operator|*
operator|(
name|u_char
operator|*
operator|)
name|ovp
operator|=
name|bucket
expr_stmt|;
comment|/* Fill index. */
if|if
condition|(
name|bucket
operator|<=
name|MAX_PACKED
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ovp
operator|+
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
operator|)
expr_stmt|;
name|nblks
operator|=
name|N_BLKS
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|start_slack
operator|+=
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bucket
operator|<
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ovp
operator|+
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
operator|)
expr_stmt|;
name|siz
operator|-=
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
expr_stmt|;
block|}
else|else
name|ovp
operator|++
expr_stmt|;
comment|/* One chunk per block. */
endif|#
directive|endif
comment|/* PACK_MALLOC */
name|nextf
index|[
name|bucket
index|]
operator|=
name|ovp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|+=
name|nblks
expr_stmt|;
if|if
condition|(
name|bucket
operator|>
name|MAX_PACKED
condition|)
block|{
name|start_slack
operator|+=
name|M_OVERHEAD
operator|*
name|nblks
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|--
name|nblks
operator|>
literal|0
condition|)
block|{
name|ovp
operator|->
name|ov_next
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|siz
operator|)
expr_stmt|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|siz
operator|)
expr_stmt|;
block|}
comment|/* Not all sbrks return zeroed memory.*/
name|ovp
operator|->
name|ov_next
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
if|if
condition|(
name|bucket
operator|==
literal|7
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
comment|/* Special case, explanation is above. */
name|union
name|overhead
modifier|*
name|n_op
init|=
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|->
name|ov_next
decl_stmt|;
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|)
expr_stmt|;
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|->
name|ov_next
operator|=
name|n_op
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !PACK_MALLOC */
block|}
end_function

begin_function
name|Free_t
name|free
parameter_list|(
name|void
modifier|*
name|mp
parameter_list|)
block|{
specifier|register
name|MEM_SIZE
name|size
decl_stmt|;
specifier|register
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|u_char
name|bucket
decl_stmt|;
endif|#
directive|endif
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05lu) free\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cp
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|bucket
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
operator|(
name|bucket
operator|>=
name|FIRST_BUCKET_WITH_CHECK
operator|)
operator|&&
operator|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
condition|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|bad_free_warn
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bad_free_warn
operator|==
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|pbf
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_BADFREE"
argument_list|)
decl_stmt|;
name|bad_free_warn
operator|=
operator|(
name|pbf
operator|)
condition|?
name|atoi
argument_list|(
name|pbf
argument_list|)
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad_free_warn
condition|)
return|return;
ifdef|#
directive|ifdef
name|RCHECK
name|warn
argument_list|(
literal|"%s free() ignored"
argument_list|,
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
operator|-
literal|1
condition|?
literal|"Duplicate"
else|:
literal|"Bad"
argument_list|)
expr_stmt|;
else|#
directive|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
literal|"Bad free() ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/* sanity */
block|}
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RCHECK
name|ASSERT
argument_list|(
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's head overwrite"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|;
name|MEM_SIZE
name|nbytes
init|=
name|ovp
operator|->
name|ov_size
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|==
name|RMAGIC_C
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
name|ovp
operator|->
name|ov_rmagic
operator|=
name|RMAGIC
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<
name|NBUCKETS
argument_list|,
literal|"chunk's head overwrite"
argument_list|)
expr_stmt|;
name|size
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
name|ovp
operator|->
name|ov_next
operator|=
name|nextf
index|[
name|size
index|]
expr_stmt|;
name|nextf
index|[
name|size
index|]
operator|=
name|ovp
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a program attempts "storage compaction" as mentioned in the  * old malloc man page, it realloc's an already freed block.  Usually  * this is the last block it freed; occasionally it might be farther  * back.  We have to search all the free lists for the block in order  * to determine its bucket: 1st we make one pass thru the lists  * checking only the first block in each; if that fails we search  * ``reall_srchlen'' blocks in each list for a match (the variable  * is extern so the caller can modify it).  If that fails we just copy  * however many bytes was given to realloc() and hope it's not huge.  */
end_comment

begin_decl_stmt
name|int
name|reall_srchlen
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4 should be plenty, -1 =>'s whole list */
end_comment

begin_function
name|Malloc_t
name|realloc
parameter_list|(
name|void
modifier|*
name|mp
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|register
name|MEM_SIZE
name|onb
decl_stmt|;
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
name|int
name|prev_bucket
decl_stmt|;
specifier|register
name|int
name|bucket
decl_stmt|;
name|int
name|was_alloced
init|=
literal|0
decl_stmt|,
name|incr
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|mp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
name|MEM_SIZE
name|size
init|=
name|nbytes
decl_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|nbytes
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"panic: realloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BARK_64K_LIMIT
argument_list|(
literal|"Reallocation"
argument_list|,
name|nbytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|malloc
argument_list|(
name|nbytes
argument_list|)
return|;
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
expr_stmt|;
name|bucket
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
operator|(
name|bucket
operator|<
name|FIRST_BUCKET_WITH_CHECK
operator|)
operator|||
operator|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|==
name|MAGIC
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|==
name|MAGIC
condition|)
endif|#
directive|endif
block|{
name|was_alloced
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Already free, doing "compaction". 		 * 		 * Search for the old block of memory on the 		 * free list.  First, check the most common 		 * case (last element free'd), then (this failing) 		 * the last ``reall_srchlen'' items free'd. 		 * If all lookups fail, then assume the size of 		 * the memory block being realloc'd is the 		 * smallest possible. 		 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|findbucket
argument_list|(
name|ovp
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|bucket
operator|=
name|findbucket
argument_list|(
name|ovp
argument_list|,
name|reall_srchlen
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|bucket
operator|=
literal|0
expr_stmt|;
block|}
name|onb
operator|=
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/*  	 *  avoid the copy if same size block. 	 *  We are not agressive with boundary cases. Note that it might 	 *  (for a small number of cases) give false negative if 	 *  both new size and old one are in the bucket for 	 *  FIRST_BIG_POW2, but the new one is near the lower end. 	 * 	 *  We do not try to go to 1.5 times smaller bucket so far. 	 */
if|if
condition|(
name|nbytes
operator|>
name|onb
condition|)
name|incr
operator|=
literal|1
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DO_NOT_TRY_HARDER_WHEN_SHRINKING
if|if
condition|(
comment|/* This is a little bit pessimal if PACK_MALLOC: */
name|nbytes
operator|>
operator|(
operator|(
name|onb
operator|>>
literal|1
operator|)
operator|-
name|M_OVERHEAD
operator|)
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
operator|||
operator|(
name|bucket
operator|==
name|FIRST_BIG_POW2
operator|&&
name|nbytes
operator|>=
name|LAST_SMALL_BOUND
operator|)
endif|#
directive|endif
condition|)
else|#
directive|else
comment|/* !DO_NOT_TRY_HARDER_WHEN_SHRINKING */
name|prev_bucket
operator|=
operator|(
operator|(
name|bucket
operator|>
name|MAX_PACKED
operator|+
literal|1
operator|)
condition|?
name|bucket
operator|-
name|BUCKETS_PER_POW2
else|:
name|bucket
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|BUCKET_SIZE_REAL
argument_list|(
name|prev_bucket
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !DO_NOT_TRY_HARDER_WHEN_SHRINKING */
name|incr
operator|=
literal|0
expr_stmt|;
else|else
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|was_alloced
ifdef|#
directive|ifdef
name|STRESS_REALLOC
operator|||
literal|1
comment|/* always do it the hard way */
endif|#
directive|endif
condition|)
goto|goto
name|hard_way
goto|;
elseif|else
if|if
condition|(
name|incr
operator|==
literal|0
condition|)
block|{
name|inplace_label
label|:
ifdef|#
directive|ifdef
name|RCHECK
comment|/* 		 * Record new allocated size of block and 		 * bound space with magic numbers. 		 */
if|if
condition|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nb
init|=
name|ovp
operator|->
name|ov_size
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nb
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nb
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|==
name|RMAGIC_C
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
block|}
name|nb
operator|=
operator|(
name|nb
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nb
operator|-
name|RSLOP
operator|)
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
comment|/* 			 * Convert amount of memory requested into 			 * closest block size stored in hash buckets 			 * which satisfies request.  Account for 			 * space used per block for accounting. 			 */
name|nbytes
operator|+=
name|M_OVERHEAD
expr_stmt|;
name|ovp
operator|->
name|ov_size
operator|=
name|nbytes
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|=
name|RMAGIC_C
expr_stmt|;
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|cp
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05lu) realloc %ld bytes inplace\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|res
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incr
operator|==
literal|1
operator|&&
operator|(
name|cp
operator|-
name|M_OVERHEAD
operator|==
name|last_op
operator|)
operator|&&
operator|(
name|onb
operator|>
operator|(
literal|1
operator|<<
name|LOG_OF_MIN_ARENA
operator|)
operator|)
condition|)
block|{
name|MEM_SIZE
name|require
decl_stmt|,
name|newarena
init|=
name|nbytes
decl_stmt|,
name|pow
decl_stmt|;
name|int
name|shiftr
decl_stmt|;
name|POW2_OPTIMIZE_ADJUST
argument_list|(
name|newarena
argument_list|)
expr_stmt|;
name|newarena
operator|=
name|newarena
operator|+
name|M_OVERHEAD
expr_stmt|;
comment|/* newarena = (newarena + 3)&~ 3; */
name|shiftr
operator|=
operator|(
name|newarena
operator|-
literal|1
operator|)
operator|>>
name|LOG_OF_MIN_ARENA
expr_stmt|;
name|pow
operator|=
name|LOG_OF_MIN_ARENA
operator|+
literal|1
expr_stmt|;
comment|/* apart from this loop, this is O(1) */
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|pow
operator|++
expr_stmt|;
name|newarena
operator|=
operator|(
literal|1
operator|<<
name|pow
operator|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|pow
operator|*
name|BUCKETS_PER_POW2
argument_list|)
expr_stmt|;
name|require
operator|=
name|newarena
operator|-
name|onb
operator|-
name|M_OVERHEAD
expr_stmt|;
if|if
condition|(
name|getpages_adjacent
argument_list|(
name|require
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|--
expr_stmt|;
name|nmalloc
index|[
name|pow
operator|*
name|BUCKETS_PER_POW2
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|cp
operator|-
name|M_OVERHEAD
operator|)
operator|=
name|pow
operator|*
name|BUCKETS_PER_POW2
expr_stmt|;
comment|/* Fill index. */
goto|goto
name|inplace_label
goto|;
block|}
else|else
goto|goto
name|hard_way
goto|;
block|}
else|else
block|{
name|hard_way
label|:
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_malloc_mutex
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05lu) realloc %ld bytes the hard way\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cp
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|!=
name|res
condition|)
comment|/* common optimization */
name|Copy
argument_list|(
name|cp
argument_list|,
name|res
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|nbytes
operator|<
name|onb
condition|?
name|nbytes
else|:
name|onb
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_alloced
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Malloc_t
operator|)
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search ``srchlen'' elements of each free list for a block whose  * header starts at ``freep''.  If srchlen is -1 search the whole list.  * Return bucket number, or -1 if not found.  */
end_comment

begin_function
specifier|static
name|int
name|findbucket
parameter_list|(
name|union
name|overhead
modifier|*
name|freep
parameter_list|,
name|int
name|srchlen
parameter_list|)
block|{
specifier|register
name|union
name|overhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nextf
index|[
name|i
index|]
init|;
name|p
operator|&&
name|j
operator|!=
name|srchlen
condition|;
name|p
operator|=
name|p
operator|->
name|ov_next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|freep
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|j
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|Malloc_t
name|calloc
parameter_list|(
specifier|register
name|size_t
name|elements
parameter_list|,
specifier|register
name|size_t
name|size
parameter_list|)
block|{
name|long
name|sz
init|=
name|elements
operator|*
name|size
decl_stmt|;
name|Malloc_t
name|p
init|=
name|malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|MEM_SIZE
name|malloced_size
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|overhead
modifier|*
name|ovp
init|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
decl_stmt|;
name|int
name|bucket
init|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|RCHECK
comment|/* The caller wants to have a complete control over the chunk,        disable the memory checking inside the chunk.  */
if|if
condition|(
name|bucket
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|MEM_SIZE
name|size
init|=
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
decl_stmt|;
name|ovp
operator|->
name|ov_size
operator|=
name|size
operator|+
name|M_OVERHEAD
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|size
operator|+
name|M_OVERHEAD
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MIN_EVEN_REPORT
value|6
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIN_EVEN_REPORT
value|MIN_BUCKET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * mstats - print out statistics about malloc  *   * Prints two lines of numbers, one showing the length of the free list  * for each size category, the second showing the number of mallocs -  * frees for each size category.  */
end_comment

begin_function
name|void
name|dump_mstats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|union
name|overhead
modifier|*
name|p
decl_stmt|;
name|int
name|topbucket
init|=
literal|0
decl_stmt|,
name|topbucket_ev
init|=
literal|0
decl_stmt|,
name|topbucket_odd
init|=
literal|0
decl_stmt|,
name|totfree
init|=
literal|0
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|u_int
name|nfree
index|[
name|NBUCKETS
index|]
decl_stmt|;
name|int
name|total_chain
init|=
literal|0
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
name|nextchain
init|=
name|chunk_chain
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p
operator|=
name|nextf
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|ov_next
operator|,
name|j
operator|++
control|)
empty_stmt|;
name|nfree
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|totfree
operator|+=
name|nfree
index|[
name|i
index|]
operator|*
name|BUCKET_SIZE_REAL
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|total
operator|+=
name|nmalloc
index|[
name|i
index|]
operator|*
name|BUCKET_SIZE_REAL
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmalloc
index|[
name|i
index|]
condition|)
block|{
name|i
operator|%
literal|2
condition|?
operator|(
name|topbucket_odd
operator|=
name|i
operator|)
else|:
operator|(
name|topbucket_ev
operator|=
name|i
operator|)
expr_stmt|;
name|topbucket
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Memory allocation statistics %s (buckets %ld(%ld)..%ld(%ld)\n"
argument_list|,
name|s
argument_list|,
operator|(
name|long
operator|)
name|BUCKET_SIZE_REAL
argument_list|(
name|MIN_BUCKET
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|BUCKET_SIZE
argument_list|(
name|MIN_BUCKET
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|BUCKET_SIZE_REAL
argument_list|(
name|topbucket
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|BUCKET_SIZE
argument_list|(
name|topbucket
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%8d free:"
argument_list|,
name|totfree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_EVEN_REPORT
init|;
name|i
operator|<=
name|topbucket
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5d"
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3d"
else|:
literal|" %d"
operator|)
operator|)
argument_list|,
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n\t   "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
operator|+
literal|1
init|;
name|i
operator|<=
name|topbucket_odd
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5d"
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3d"
else|:
literal|" %d"
operator|)
operator|)
argument_list|,
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n%8d used:"
argument_list|,
name|total
operator|-
name|totfree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_EVEN_REPORT
init|;
name|i
operator|<=
name|topbucket
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5d"
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3d"
else|:
literal|" %d"
operator|)
operator|)
argument_list|,
name|nmalloc
index|[
name|i
index|]
operator|-
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n\t   "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
operator|+
literal|1
init|;
name|i
operator|<=
name|topbucket_odd
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5d"
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3d"
else|:
literal|" %d"
operator|)
operator|)
argument_list|,
name|nmalloc
index|[
name|i
index|]
operator|-
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|nextchain
condition|)
block|{
name|total_chain
operator|+=
name|nextchain
operator|->
name|size
expr_stmt|;
name|nextchain
operator|=
name|nextchain
operator|->
name|next
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\nTotal sbrk(): %d/%d:%d. Odd ends: pad+heads+chain+tail: %d+%d+%d+%d.\n"
argument_list|,
name|goodsbrk
operator|+
name|sbrk_slack
argument_list|,
name|sbrks
argument_list|,
name|sbrk_good
argument_list|,
name|sbrk_slack
argument_list|,
name|start_slack
argument_list|,
name|total_chain
argument_list|,
name|sbrked_remains
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|dump_mstats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PERL_SBRK
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MACHTEN_PPC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NeXT__
argument_list|)
end_if

begin_define
define|#
directive|define
name|PERL_SBRK_VIA_MALLOC
end_define

begin_comment
comment|/*  * MachTen's malloc() returns a buffer aligned on a two-byte boundary.  * While this is adequate, it may slow down access to longer data  * types by forcing multiple memory accesses.  It also causes  * complaints when RCHECK is in force.  So we allocate six bytes  * more than we need to, and return an address rounded up to an  * eight-byte boundary.  *  * 980701 Dominic Dunlop<domo@computer.org>  */
end_comment

begin_define
define|#
directive|define
name|SYSTEM_ALLOC
parameter_list|(
name|a
parameter_list|)
value|((void *)(((unsigned)malloc((a)+6)+6)&~7))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_SBRK_VIA_MALLOC
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HIDEMYMALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|EMBEDMYMALLOC
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_comment
comment|/* Expose names that  */
end_comment

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_comment
comment|/* HIDEMYMALLOC hides */
end_comment

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"Error: -DPERL_SBRK_VIA_MALLOC needs -D(HIDE|EMBED)MYMALLOC"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* it may seem schizophrenic to use perl's malloc and let it call system */
end_comment

begin_comment
comment|/* malloc, the reason for that is only the 3.2 version of the OS that had */
end_comment

begin_comment
comment|/* frequent core dumps within nxzonefreenolock. This sbrk routine put an */
end_comment

begin_comment
comment|/* end to the cores */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSTEM_ALLOC
end_ifndef

begin_define
define|#
directive|define
name|SYSTEM_ALLOC
parameter_list|(
name|a
parameter_list|)
value|malloc(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_SBRK_VIA_MALLOC */
end_comment

begin_decl_stmt
specifier|static
name|IV
name|Perl_sbrk_oldchunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|Perl_sbrk_oldsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PERLSBRK_32_K
value|(1<<15)
end_define

begin_define
define|#
directive|define
name|PERLSBRK_64_K
value|(1<<16)
end_define

begin_function
name|Malloc_t
name|Perl_sbrk
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|IV
name|got
decl_stmt|;
name|int
name|small
decl_stmt|,
name|reqsize
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|PERL_CORE
name|reqsize
operator|=
name|size
expr_stmt|;
comment|/* just for the DEBUG_m statement */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|size
operator|=
operator|(
name|size
operator|+
literal|0x7ff
operator|)
operator|&
operator|~
literal|0x7ff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|<=
name|Perl_sbrk_oldsize
condition|)
block|{
name|got
operator|=
name|Perl_sbrk_oldchunk
expr_stmt|;
name|Perl_sbrk_oldchunk
operator|+=
name|size
expr_stmt|;
name|Perl_sbrk_oldsize
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|>=
name|PERLSBRK_32_K
condition|)
block|{
name|small
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|PERLSBRK_64_K
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
name|got
operator|=
operator|(
name|IV
operator|)
name|SYSTEM_ALLOC
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|got
operator|=
operator|(
name|got
operator|+
literal|0x7ff
operator|)
operator|&
operator|~
literal|0x7ff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|small
condition|)
block|{
comment|/* Chunk is small, register the rest for future allocs. */
name|Perl_sbrk_oldchunk
operator|=
name|got
operator|+
name|reqsize
expr_stmt|;
name|Perl_sbrk_oldsize
operator|=
name|size
operator|-
name|reqsize
expr_stmt|;
block|}
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk malloc size %ld (reqsize %ld), left size %ld, give addr 0x%lx\n"
argument_list|,
name|size
argument_list|,
name|reqsize
argument_list|,
name|Perl_sbrk_oldsize
argument_list|,
name|got
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|got
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined USE_PERL_SBRK */
end_comment

end_unit

