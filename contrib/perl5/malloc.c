begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    malloc.c  *  */
end_comment

begin_comment
comment|/*   Here are some notes on configuring Perl's malloc.  (For non-perl   usage see below.)     There are two macros which serve as bulk disablers of advanced   features of this malloc: NO_FANCY_MALLOC, PLAIN_MALLOC (undef by   default).  Look in the list of default values below to understand   their exact effect.  Defining NO_FANCY_MALLOC returns malloc.c to the   state of the malloc in Perl 5.004.  Additionally defining PLAIN_MALLOC   returns it to the state as of Perl 5.000.    Note that some of the settings below may be ignored in the code based   on values of other macros.  The PERL_CORE symbol is only defined when   perl itself is being compiled (so malloc can make some assumptions   about perl's facilities being available to it).    Each config option has a short description, followed by its name,   default value, and a comment about the default (if applicable).  Some   options take a precise value, while the others are just boolean.   The boolean ones are listed first.      # Enable code for an emergency memory pool in $^M.  See perlvar.pod     # for a description of $^M.     PERL_EMERGENCY_SBRK		(!PLAIN_MALLOC&& PERL_CORE)      # Enable code for printing memory statistics.     DEBUGGING_MSTATS		(!PLAIN_MALLOC&& PERL_CORE)      # Move allocation info for small buckets into separate areas.     # Memory optimization (especially for small allocations, of the     # less than 64 bytes).  Since perl usually makes a large number     # of small allocations, this is usually a win.     PACK_MALLOC			(!PLAIN_MALLOC&& !RCHECK)      # Add one page to big powers of two when calculating bucket size.     # This is targeted at big allocations, as are common in image     # processing.     TWO_POT_OPTIMIZE		!PLAIN_MALLOC       # Use intermediate bucket sizes between powers-of-two.  This is     # generally a memory optimization, and a (small) speed pessimization.     BUCKETS_ROOT2		!NO_FANCY_MALLOC      # Do not check small deallocations for bad free().  Memory     # and speed optimization, error reporting pessimization.     IGNORE_SMALL_BAD_FREE	(!NO_FANCY_MALLOC&& !RCHECK)      # Use table lookup to decide in which bucket a given allocation will go.     SMALL_BUCKET_VIA_TABLE	!NO_FANCY_MALLOC      # Use a perl-defined sbrk() instead of the (presumably broken or     # missing) system-supplied sbrk().     USE_PERL_SBRK		undef      # Use system malloc() (or calloc() etc.) to emulate sbrk(). Normally     # only used with broken sbrk()s.     PERL_SBRK_VIA_MALLOC	undef      # Which allocator to use if PERL_SBRK_VIA_MALLOC     SYSTEM_ALLOC(a) 		malloc(a)      # Minimal alignment (in bytes, should be a power of 2) of SYSTEM_ALLOC     SYSTEM_ALLOC_ALIGNMENT	MEM_ALIGNBYTES      # Disable memory overwrite checking with DEBUGGING.  Memory and speed     # optimization, error reporting pessimization.     NO_RCHECK			undef      # Enable memory overwrite checking with DEBUGGING.  Memory and speed     # pessimization, error reporting optimization     RCHECK			(DEBUGGING&& !NO_RCHECK)      # Failed allocations bigger than this size croak (if     # PERL_EMERGENCY_SBRK is enabled) without touching $^M.  See     # perlvar.pod for a description of $^M.     BIG_SIZE			 (1<<16)	# 64K      # Starting from this power of two, add an extra page to the     # size of the bucket. This enables optimized allocations of sizes     # close to powers of 2.  Note that the value is indexed at 0.     FIRST_BIG_POW2 		15		# 32K, 16K is used too often      # Estimate of minimal memory footprint.  malloc uses this value to     # request the most reasonable largest blocks of memory from the system.     FIRST_SBRK 			(48*1024)      # Round up sbrk()s to multiples of this.     MIN_SBRK 			2048      # Round up sbrk()s to multiples of this percent of footprint.     MIN_SBRK_FRAC 		3      # Add this much memory to big powers of two to get the bucket size.     PERL_PAGESIZE 		4096      # This many sbrk() discontinuities should be tolerated even     # from the start without deciding that sbrk() is usually     # discontinuous.     SBRK_ALLOW_FAILURES		3      # This many continuous sbrk()s compensate for one discontinuous one.     SBRK_FAILURE_PRICE		50      # Some configurations may ask for 12-byte-or-so allocations which     # require 8-byte alignment (?!).  In such situation one needs to     # define this to disable 12-byte bucket (will increase memory footprint)     STRICT_ALIGNMENT		undef    This implementation assumes that calling PerlIO_printf() does not   result in any memory allocation calls (used during a panic).   */
end_comment

begin_comment
comment|/*    If used outside of Perl environment, it may be useful to redefine    the following macros (listed below with defaults):       # Type of address returned by allocation functions      Malloc_t				void *       # Type of size argument for allocation functions      MEM_SIZE				unsigned long       # size of void*      PTRSIZE				4       # Maximal value in LONG      LONG_MAX				0x7FFFFFFF       # Unsigned integer type big enough to keep a pointer      UV					unsigned long       # Type of pointer with 1-byte granularity      caddr_t				char *       # Type returned by free()      Free_t				void       # Very fatal condition reporting function (cannot call any )      fatalcroak(arg)			write(2,arg,strlen(arg)) + exit(2)         # Fatal error reporting function      croak(format, arg)			warn(idem) + exit(1)         # Fatal error reporting function      croak2(format, arg1, arg2)		warn2(idem) + exit(1)         # Error reporting function      warn(format, arg)			fprintf(stderr, idem)       # Error reporting function      warn2(format, arg1, arg2)		fprintf(stderr, idem)       # Locking/unlocking for MT operation      MALLOC_LOCK			MUTEX_LOCK(&PL_malloc_mutex)      MALLOC_UNLOCK			MUTEX_UNLOCK(&PL_malloc_mutex)       # Locking/unlocking mutex for MT operation      MUTEX_LOCK(l)			void      MUTEX_UNLOCK(l)			void  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FANCY_MALLOC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL_BUCKET_VIA_TABLE
end_ifndef

begin_define
define|#
directive|define
name|SMALL_BUCKET_VIA_TABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUCKETS_ROOT2
end_ifndef

begin_define
define|#
directive|define
name|BUCKETS_ROOT2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SMALL_BAD_FREE
end_ifndef

begin_define
define|#
directive|define
name|IGNORE_SMALL_BAD_FREE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PLAIN_MALLOC
end_ifndef

begin_comment
comment|/* Bulk enable features */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PACK_MALLOC
end_ifndef

begin_define
define|#
directive|define
name|PACK_MALLOC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TWO_POT_OPTIMIZE
end_ifndef

begin_define
define|#
directive|define
name|TWO_POT_OPTIMIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PERL_EMERGENCY_SBRK
argument_list|)
end_if

begin_define
define|#
directive|define
name|PERL_EMERGENCY_SBRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEBUGGING_MSTATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MIN_BUC_POW2
value|(sizeof(void*)> 4 ? 3 : 2)
end_define

begin_comment
comment|/* Allow for 4-byte arena. */
end_comment

begin_define
define|#
directive|define
name|MIN_BUCKET
value|(MIN_BUC_POW2 * BUCKETS_PER_POW2)
end_define

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
operator|)
end_if

begin_comment
comment|/* take 2k unless the block is bigger than that */
end_comment

begin_define
define|#
directive|define
name|LOG_OF_MIN_ARENA
value|11
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* take 16k unless the block is bigger than that  	   (80286s like large segments!), probably good on the atari too */
end_comment

begin_define
define|#
directive|define
name|LOG_OF_MIN_ARENA
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_RCHECK
argument_list|)
end_if

begin_define
define|#
directive|define
name|RCHECK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RCHECK
argument_list|)
operator|&&
name|defined
argument_list|(
name|IGNORE_SMALL_BAD_FREE
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|IGNORE_SMALL_BAD_FREE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * malloc.c (Caltech) 2/21/82  * Chris Kingsley, kingsley@cit-20.  *  * This is a very fast storage allocator.  It allocates blocks of a small   * number of different sizes, and keeps free lists of each size.  Blocks that  * don't exactly fit are passed up to the next larger size.  In this   * implementation, the available sizes are 2^n-4 (or 2^n-12) bytes long.  * If PACK_MALLOC is defined, small blocks are 2^n bytes long.  * This is designed for use in a program that uses vast quantities of memory,  * but bombs when it runs out.  *   * Modifications Copyright Ilya Zakharevich 1996-99.  *   * Still very quick, but much more thrifty.  (Std config is 10% slower  * than it was, and takes 67% of old heap size for typical usage.)  *  * Allocations of small blocks are now table-driven to many different  * buckets.  Sizes of really big buckets are increased to accomodata  * common size=power-of-2 blocks.  Running-out-of-memory is made into  * an exception.  Deeply configurable and thread-safe.  *   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_CORE
end_ifdef

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_MALLOC_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_define
define|#
directive|define
name|croak
value|Perl_croak_nocontext
end_define

begin_define
define|#
directive|define
name|croak2
value|Perl_croak_nocontext
end_define

begin_define
define|#
directive|define
name|warn
value|Perl_warn_nocontext
end_define

begin_define
define|#
directive|define
name|warn2
value|Perl_warn_nocontext
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|croak2
value|croak
end_define

begin_define
define|#
directive|define
name|warn2
value|warn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FOR_X2P
end_ifdef

begin_include
include|#
directive|include
file|"../EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"../perl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|arg
parameter_list|)
value|arg
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|Malloc_t
end_ifndef

begin_define
define|#
directive|define
name|Malloc_t
value|void *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRSIZE
end_ifndef

begin_define
define|#
directive|define
name|PTRSIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MEM_SIZE
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|0x7FFFFFFF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV
end_ifndef

begin_define
define|#
directive|define
name|UV
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|caddr_t
end_ifndef

begin_define
define|#
directive|define
name|caddr_t
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Free_t
end_ifndef

begin_define
define|#
directive|define
name|Free_t
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Copy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|(void)memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
end_define

begin_define
define|#
directive|define
name|PerlEnv_getenv
value|getenv
end_define

begin_define
define|#
directive|define
name|PerlIO_printf
value|fprintf
end_define

begin_define
define|#
directive|define
name|PerlIO_stderr
parameter_list|()
value|stderr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|croak
end_ifndef

begin_comment
comment|/* make depend */
end_comment

begin_define
define|#
directive|define
name|croak
parameter_list|(
name|mess
parameter_list|,
name|arg
parameter_list|)
value|(warn((mess), (arg)), exit(1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|croak2
end_ifndef

begin_comment
comment|/* make depend */
end_comment

begin_define
define|#
directive|define
name|croak2
parameter_list|(
name|mess
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|(warn2((mess), (arg1), (arg2)), exit(1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|warn
end_ifndef

begin_define
define|#
directive|define
name|warn
parameter_list|(
name|mess
parameter_list|,
name|arg
parameter_list|)
value|fprintf(stderr, (mess), (arg))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|warn2
end_ifndef

begin_define
define|#
directive|define
name|warn2
parameter_list|(
name|mess
parameter_list|,
name|arg1
parameter_list|)
value|fprintf(stderr, (mess), (arg1), (arg2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_m
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUG_m
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUG_m
parameter_list|(
name|a
parameter_list|)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUGGING
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pTHX
end_ifndef

begin_define
define|#
directive|define
name|pTHX
value|void
end_define

begin_define
define|#
directive|define
name|pTHX_
end_define

begin_define
define|#
directive|define
name|dTHX
value|extern int Perl___notused
end_define

begin_define
define|#
directive|define
name|WITH_THX
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_GET_INTERP
end_ifndef

begin_define
define|#
directive|define
name|PERL_GET_INTERP
value|PL_curinterp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Perl_malloc
end_ifndef

begin_define
define|#
directive|define
name|Perl_malloc
value|malloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Perl_mfree
end_ifndef

begin_define
define|#
directive|define
name|Perl_mfree
value|free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Perl_realloc
end_ifndef

begin_define
define|#
directive|define
name|Perl_realloc
value|realloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Perl_calloc
end_ifndef

begin_define
define|#
directive|define
name|Perl_calloc
value|calloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Perl_strdup
end_ifndef

begin_define
define|#
directive|define
name|Perl_strdup
value|strdup
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MUTEX_LOCK
end_ifndef

begin_define
define|#
directive|define
name|MUTEX_LOCK
parameter_list|(
name|l
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MUTEX_UNLOCK
end_ifndef

begin_define
define|#
directive|define
name|MUTEX_UNLOCK
parameter_list|(
name|l
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_LOCK
end_ifndef

begin_define
define|#
directive|define
name|MALLOC_LOCK
value|MUTEX_LOCK(&PL_malloc_mutex)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_UNLOCK
end_ifndef

begin_define
define|#
directive|define
name|MALLOC_UNLOCK
value|MUTEX_UNLOCK(&PL_malloc_mutex)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|fatalcroak
end_ifndef

begin_comment
comment|/* make depend */
end_comment

begin_define
define|#
directive|define
name|fatalcroak
parameter_list|(
name|mess
parameter_list|)
value|(write(2, (mess), strlen(mess)), exit(2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|DEBUG_m
end_undef

begin_define
define|#
directive|define
name|DEBUG_m
parameter_list|(
name|a
parameter_list|)
define|\
value|STMT_START {							\ 	if (PERL_GET_INTERP) { dTHX; if (PL_debug& 128) { a; } }	\     } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_define
define|#
directive|define
name|PERL_IS_ALIVE
value|aTHX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_IS_ALIVE
value|TRUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Layout of memory:  * ~~~~~~~~~~~~~~~~  * The memory is broken into "blocks" which occupy multiples of 2K (and  * generally speaking, have size "close" to a power of 2).  The addresses  * of such *unused* blocks are kept in nextf[i] with big enough i.  (nextf  * is an array of linked lists.)  (Addresses of used blocks are not known.)  *   * Moreover, since the algorithm may try to "bite" smaller blocks out  * of unused bigger ones, there are also regions of "irregular" size,  * managed separately, by a linked list chunk_chain.  *   * The third type of storage is the sbrk()ed-but-not-yet-used space, its  * end and size are kept in last_sbrk_top and sbrked_remains.  *   * Growing blocks "in place":  * ~~~~~~~~~~~~~~~~~~~~~~~~~  * The address of the block with the greatest address is kept in last_op  * (if not known, last_op is 0).  If it is known that the memory above  * last_op is not continuous, or contains a chunk from chunk_chain,  * last_op is set to 0.  *   * The chunk with address last_op may be grown by expanding into  * sbrk()ed-but-not-yet-used space, or trying to sbrk() more continuous  * memory.  *   * Management of last_op:  * ~~~~~~~~~~~~~~~~~~~~~  *   * free() never changes the boundaries of blocks, so is not relevant.  *   * The only way realloc() may change the boundaries of blocks is if it  * grows a block "in place".  However, in the case of success such a  * chunk is automatically last_op, and it remains last_op.  In the case  * of failure getpages_adjacent() clears last_op.  *   * malloc() may change blocks by calling morecore() only.  *   * morecore() may create new blocks by:  *   a) biting pieces from chunk_chain (cannot create one above last_op);  *   b) biting a piece from an unused block (if block was last_op, this  *      may create a chunk from chain above last_op, thus last_op is  *      invalidated in such a case).  *   c) biting of sbrk()ed-but-not-yet-used space.  This creates   *      a block which is last_op.  *   d) Allocating new pages by calling getpages();  *   * getpages() creates a new block.  It marks last_op at the bottom of  * the chunk of memory it returns.  *   * Active pages footprint:  * ~~~~~~~~~~~~~~~~~~~~~~  * Note that we do not need to traverse the lists in nextf[i], just take  * the first element of this list.  However, we *need* to traverse the  * list in chunk_chain, but most the time it should be a very short one,  * so we do not step on a lot of pages we are not going to use.  *   * Flaws:  * ~~~~~  * get_from_bigger_buckets(): forget to increment price => Quite  * aggressive.  */
end_comment

begin_comment
comment|/* I don't much care whether these are defined in sys/types.h--LAW */
end_comment

begin_define
define|#
directive|define
name|u_char
value|unsigned char
end_define

begin_define
define|#
directive|define
name|u_int
value|unsigned int
end_define

begin_comment
comment|/*   * I removed the definition of u_bigint which appeared to be u_bigint = UV  * u_bigint was only used in TWOK_MASKED and TWOK_SHIFT   * where I have used PTR2UV.  RMB  */
end_comment

begin_define
define|#
directive|define
name|u_short
value|unsigned short
end_define

begin_comment
comment|/* 286 and atarist like big chunks, which gives too much overhead. */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|RCHECK
argument_list|)
operator|||
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|PACK_MALLOC
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|PACK_MALLOC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The description below is applicable if PACK_MALLOC is not defined.  *  * The overhead on a block is at least 4 bytes.  When free, this space  * contains a pointer to the next free block, and the bottom two bits must  * be zero.  When in use, the first byte is set to MAGIC, and the second  * byte is the size index.  The remaining bytes are for alignment.  * If range checking is enabled and the size of the block fits  * in two bytes, then the top two bytes hold the size of the requested block  * plus the range checking words, and the header word MINUS ONE.  */
end_comment

begin_union
union|union
name|overhead
block|{
name|union
name|overhead
modifier|*
name|ov_next
decl_stmt|;
comment|/* when free */
if|#
directive|if
name|MEM_ALIGNBYTES
operator|>
literal|4
name|double
name|strut
decl_stmt|;
comment|/* alignment problems */
endif|#
directive|endif
struct|struct
block|{
comment|/*  * Keep the ovu_index and ovu_magic in this order, having a char  * field first gives alignment indigestion in some systems, such as  * MachTen.  */
name|u_char
name|ovu_index
decl_stmt|;
comment|/* bucket # */
name|u_char
name|ovu_magic
decl_stmt|;
comment|/* magic number */
ifdef|#
directive|ifdef
name|RCHECK
name|u_short
name|ovu_size
decl_stmt|;
comment|/* actual block size */
name|u_int
name|ovu_rmagic
decl_stmt|;
comment|/* range magic number */
endif|#
directive|endif
block|}
name|ovu
struct|;
define|#
directive|define
name|ov_magic
value|ovu.ovu_magic
define|#
directive|define
name|ov_index
value|ovu.ovu_index
define|#
directive|define
name|ov_size
value|ovu.ovu_size
define|#
directive|define
name|ov_rmagic
value|ovu.ovu_rmagic
block|}
union|;
end_union

begin_define
define|#
directive|define
name|MAGIC
value|0xff
end_define

begin_comment
comment|/* magic # on accounting info */
end_comment

begin_define
define|#
directive|define
name|RMAGIC
value|0x55555555
end_define

begin_comment
comment|/* magic # on range info */
end_comment

begin_define
define|#
directive|define
name|RMAGIC_C
value|0x55
end_define

begin_comment
comment|/* magic # on range info */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCHECK
end_ifdef

begin_define
define|#
directive|define
name|RSLOP
value|sizeof (u_int)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
end_ifdef

begin_define
define|#
directive|define
name|MAX_SHORT_BUCKET
value|(12 * BUCKETS_PER_POW2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_SHORT_BUCKET
value|(13 * BUCKETS_PER_POW2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RSLOP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PACK_MALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUCKETS_ROOT2
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|BUCKETS_ROOT2
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|BUCKET_TABLE_SHIFT
value|2
end_define

begin_define
define|#
directive|define
name|BUCKET_POW2_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|BUCKETS_PER_POW2
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUCKET_TABLE_SHIFT
value|MIN_BUC_POW2
end_define

begin_define
define|#
directive|define
name|BUCKET_POW2_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|BUCKETS_PER_POW2
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MEM_ALIGNBYTES
argument_list|)
operator|||
operator|(
operator|(
name|MEM_ALIGNBYTES
operator|>
literal|4
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRICT_ALIGNMENT
argument_list|)
operator|)
end_if

begin_comment
comment|/* Figure out the alignment of void*. */
end_comment

begin_struct
struct|struct
name|aligner
block|{
name|char
name|c
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ALIGN_SMALL
value|((int)((caddr_t)&(((struct aligner*)0)->p)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ALIGN_SMALL
value|MEM_ALIGNBYTES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IF_ALIGN_8
parameter_list|(
name|yes
parameter_list|,
name|no
parameter_list|)
value|((ALIGN_SMALL>4) ? (yes) : (no))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MAX_BUCKET_BY_TABLE
value|13
end_define

begin_decl_stmt
specifier|static
name|u_short
name|buck_size
index|[
name|MAX_BUCKET_BY_TABLE
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|32
block|,
literal|48
block|,
literal|64
block|,
literal|80
block|,   }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUCKET_SIZE
parameter_list|(
name|i
parameter_list|)
value|((i) % 2 ? buck_size[i] : (1<< ((i)>> BUCKET_POW2_SHIFT)))
end_define

begin_define
define|#
directive|define
name|BUCKET_SIZE_REAL
parameter_list|(
name|i
parameter_list|)
value|((i)<= MAX_BUCKET_BY_TABLE		\ 			       ? buck_size[i] 				\ 			       : ((1<< ((i)>> BUCKET_POW2_SHIFT))	\ 				  - MEM_OVERHEAD(i)			\ 				  + POW2_OPTIMIZE_SURPLUS(i)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUCKET_SIZE
parameter_list|(
name|i
parameter_list|)
value|(1<< ((i)>> BUCKET_POW2_SHIFT))
end_define

begin_define
define|#
directive|define
name|BUCKET_SIZE_REAL
parameter_list|(
name|i
parameter_list|)
value|(BUCKET_SIZE(i) - MEM_OVERHEAD(i) + POW2_OPTIMIZE_SURPLUS(i))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PACK_MALLOC
end_ifdef

begin_comment
comment|/* In this case there are several possible layout of arenas depending  * on the size.  Arenas are of sizes multiple to 2K, 2K-aligned, and  * have a size close to a power of 2.  *  * Arenas of the size>= 4K keep one chunk only.  Arenas of size 2K  * may keep one chunk or multiple chunks.  Here are the possible  * layouts of arenas:  *  *	# One chunk only, chunksize 2^k + SOMETHING - ALIGN, k>= 11  *  * INDEX MAGIC1 UNUSED CHUNK1  *  *	# Multichunk with sanity checking and chunksize 2^k-ALIGN, k>7  *  * INDEX MAGIC1 MAGIC2 MAGIC3 UNUSED CHUNK1 CHUNK2 CHUNK3 ...  *  *	# Multichunk with sanity checking and size 2^k-ALIGN, k=7  *  * INDEX MAGIC1 MAGIC2 MAGIC3 UNUSED CHUNK1 UNUSED CHUNK2 CHUNK3 ...  *  *	# Multichunk with sanity checking and size up to 80  *  * INDEX UNUSED MAGIC1 UNUSED MAGIC2 UNUSED ... CHUNK1 CHUNK2 CHUNK3 ...  *  *	# No sanity check (usually up to 48=byte-long buckets)  * INDEX UNUSED CHUNK1 CHUNK2 ...  *  * Above INDEX and MAGIC are one-byte-long.  Sizes of UNUSED are  * appropriate to keep algorithms simple and memory aligned.  INDEX  * encodes the size of the chunk, while MAGICn encodes state (used,  * free or non-managed-by-us-so-it-indicates-a-bug) of CHUNKn.  MAGIC  * is used for sanity checking purposes only.  SOMETHING is 0 or 4K  * (to make size of big CHUNK accomodate allocations for powers of two  * better).  *  * [There is no need to alignment between chunks, since C rules ensure  *  that structs which need 2^k alignment have sizeof which is  *  divisible by 2^k.  Thus as far as the last chunk is aligned at the  *  end of the arena, and 2K-alignment does not contradict things,  *  everything is going to be OK for sizes of chunks 2^n and 2^n +  *  2^k.  Say, 80-bit buckets will be 16-bit aligned, and as far as we  *  put allocations for requests in 65..80 range, all is fine.  *  *  Note, however, that standard malloc() puts more strict  *  requirements than the above C rules.  Moreover, our algorithms of  *  realloc() may break this idyll, but we suppose that realloc() does  *  need not change alignment.]  *  * Is very important to make calculation of the offset of MAGICm as  * quick as possible, since it is done on each malloc()/free().  In  * fact it is so quick that it has quite little effect on the speed of  * doing malloc()/free().  [By default] We forego such calculations  * for small chunks, but only to save extra 3% of memory, not because  * of speed considerations.  *  * Here is the algorithm [which is the same for all the allocations  * schemes above], see OV_MAGIC(block,bucket).  Let OFFSETm be the  * offset of the CHUNKm from the start of ARENA.  Then offset of  * MAGICm is (OFFSET1>> SHIFT) + ADDOFFSET.  Here SHIFT and ADDOFFSET  * are numbers which depend on the size of the chunks only.  *  * Let as check some sanity conditions.  Numbers OFFSETm>>SHIFT are  * different for all the chunks in the arena if 2^SHIFT is not greater  * than size of the chunks in the arena.  MAGIC1 will not overwrite  * INDEX provided ADDOFFSET is>0 if OFFSET1< 2^SHIFT.  MAGIClast  * will not overwrite CHUNK1 if OFFSET1> (OFFSETlast>> SHIFT) +  * ADDOFFSET.  *   * Make SHIFT the maximal possible (there is no point in making it  * smaller).  Since OFFSETlast is 2K - CHUNKSIZE, above restrictions  * give restrictions on OFFSET1 and on ADDOFFSET.  *   * In particular, for chunks of size 2^k with k>=6 we can put  * ADDOFFSET to be from 0 to 2^k - 2^(11-k), and have  * OFFSET1==chunksize.  For chunks of size 80 OFFSET1 of 2K%80=48 is  * large enough to have ADDOFFSET between 1 and 16 (similarly for 96,  * when ADDOFFSET should be 1).  In particular, keeping MAGICs for  * these sizes gives no additional size penalty.  *   * However, for chunks of size 2^k with k<=5 this gives OFFSET1>=  * ADDOFSET + 2^(11-k).  Keeping ADDOFFSET 0 allows for 2^(11-k)-2^(11-2k)  * chunks per arena.  This is smaller than 2^(11-k) - 1 which are  * needed if no MAGIC is kept.  [In fact, having a negative ADDOFFSET  * would allow for slightly more buckets per arena for k=2,3.]  *   * Similarly, for chunks of size 3/2*2^k with k<=5 MAGICs would span  * the area up to 2^(11-k)+ADDOFFSET.  For k=4 this give optimal  * ADDOFFSET as -7..0.  For k=3 ADDOFFSET can go up to 4 (with tiny  * savings for negative ADDOFFSET).  For k=5 ADDOFFSET can go -1..16  * (with no savings for negative values).  *  * In particular, keeping ADDOFFSET 0 for sizes of chunks up to 2^6  * leads to tiny pessimizations in case of sizes 4, 8, 12, 24, and  * leads to no contradictions except for size=80 (or 96.)  *  * However, it also makes sense to keep no magic for sizes 48 or less.  * This is what we do.  In this case one needs ADDOFFSET>=1 also for  * chunksizes 12, 24, and 48, unless one gets one less chunk per  * arena.  *    * The algo of OV_MAGIC(block,bucket) keeps ADDOFFSET 0 until  * chunksize of 64, then makes it 1.   *  * This allows for an additional optimization: the above scheme leads  * to giant overheads for sizes 128 or more (one whole chunk needs to  * be sacrifised to keep INDEX).  Instead we use chunks not of size  * 2^k, but of size 2^k-ALIGN.  If we pack these chunks at the end of  * the arena, then the beginnings are still in different 2^k-long  * sections of the arena if k>=7 for ALIGN==4, and k>=8 if ALIGN=8.  * Thus for k>7 the above algo of calculating the offset of the magic  * will still give different answers for different chunks.  And to  * avoid the overrun of MAGIC1 into INDEX, one needs ADDOFFSET of>=1.  * In the case k=7 we just move the first chunk an extra ALIGN  * backward inside the ARENA (this is done once per arena lifetime,  * thus is not a big overhead).  */
end_comment

begin_define
define|#
directive|define
name|MAX_PACKED_POW2
value|6
end_define

begin_define
define|#
directive|define
name|MAX_PACKED
value|(MAX_PACKED_POW2 * BUCKETS_PER_POW2 + BUCKET_POW2_SHIFT)
end_define

begin_define
define|#
directive|define
name|MAX_POW2_ALGO
value|((1<<(MAX_PACKED_POW2 + 1)) - M_OVERHEAD)
end_define

begin_define
define|#
directive|define
name|TWOK_MASK
value|((1<<LOG_OF_MIN_ARENA) - 1)
end_define

begin_define
define|#
directive|define
name|TWOK_MASKED
parameter_list|(
name|x
parameter_list|)
value|(PTR2UV(x)& ~TWOK_MASK)
end_define

begin_define
define|#
directive|define
name|TWOK_SHIFT
parameter_list|(
name|x
parameter_list|)
value|(PTR2UV(x)& TWOK_MASK)
end_define

begin_define
define|#
directive|define
name|OV_INDEXp
parameter_list|(
name|block
parameter_list|)
value|(INT2PTR(u_char*,TWOK_MASKED(block)))
end_define

begin_define
define|#
directive|define
name|OV_INDEX
parameter_list|(
name|block
parameter_list|)
value|(*OV_INDEXp(block))
end_define

begin_define
define|#
directive|define
name|OV_MAGIC
parameter_list|(
name|block
parameter_list|,
name|bucket
parameter_list|)
value|(*(OV_INDEXp(block) +			\ 				    (TWOK_SHIFT(block)>>		\ 				     (bucket>>BUCKET_POW2_SHIFT)) +	\ 				    (bucket>= MIN_NEEDS_SHIFT ? 1 : 0)))
end_define

begin_comment
comment|/* A bucket can have a shift smaller than it size, we need to        shift its magic number so it will not overwrite index: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MIN_NEEDS_SHIFT
value|(7*BUCKETS_PER_POW2 - 1)
end_define

begin_comment
comment|/* Shift 80 greater than chunk 64. */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIN_NEEDS_SHIFT
value|(7*BUCKETS_PER_POW2)
end_define

begin_comment
comment|/* Shift 128 greater than chunk 32. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CHUNK_SHIFT
value|0
end_define

begin_comment
comment|/* Number of active buckets of given ordinal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
end_ifdef

begin_define
define|#
directive|define
name|FIRST_BUCKET_WITH_CHECK
value|(6 * BUCKETS_PER_POW2)
end_define

begin_comment
comment|/* 64 */
end_comment

begin_define
define|#
directive|define
name|N_BLKS
parameter_list|(
name|bucket
parameter_list|)
value|( (bucket)< FIRST_BUCKET_WITH_CHECK 		\ 			 ? ((1<<LOG_OF_MIN_ARENA) - 1)/BUCKET_SIZE(bucket) \ 			 : n_blks[bucket] )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|N_BLKS
parameter_list|(
name|bucket
parameter_list|)
value|n_blks[bucket]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_short
name|n_blks
index|[
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
index|]
init|=
block|{
if|#
directive|if
name|BUCKETS_PER_POW2
operator|==
literal|1
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
literal|224
block|,
literal|120
block|,
literal|62
block|,
literal|31
block|,
literal|16
block|,
literal|8
block|,
literal|4
block|,
literal|2
else|#
directive|else
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|384
operator|:
literal|0
operator|)
block|,
comment|/* 4, 4 */
literal|224
block|,
literal|149
block|,
literal|120
block|,
literal|80
block|,
literal|62
block|,
literal|41
block|,
literal|31
block|,
literal|25
block|,
literal|16
block|,
literal|16
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shift of the first bucket with the given ordinal inside 2K chunk. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
end_ifdef

begin_define
define|#
directive|define
name|BLK_SHIFT
parameter_list|(
name|bucket
parameter_list|)
value|( (bucket)< FIRST_BUCKET_WITH_CHECK 	\ 			      ? ((1<<LOG_OF_MIN_ARENA)			\ 				 - BUCKET_SIZE(bucket) * N_BLKS(bucket)) \ 			      : blk_shift[bucket])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BLK_SHIFT
parameter_list|(
name|bucket
parameter_list|)
value|blk_shift[bucket]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_short
name|blk_shift
index|[
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
index|]
init|=
block|{
if|#
directive|if
name|BUCKETS_PER_POW2
operator|==
literal|1
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
literal|256
block|,
literal|128
block|,
literal|64
block|,
literal|64
block|,
comment|/* 8 to 64 */
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
else|#
directive|else
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
operator|(
name|MIN_BUC_POW2
operator|==
literal|2
operator|?
literal|512
operator|:
literal|0
operator|)
block|,
literal|256
block|,
literal|260
block|,
literal|128
block|,
literal|128
block|,
literal|64
block|,
literal|80
block|,
literal|64
block|,
literal|48
block|,
comment|/* 8 to 96 */
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|16
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|8
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEEDED_ALIGNMENT
value|0x800
end_define

begin_comment
comment|/* 2k boundaries */
end_comment

begin_define
define|#
directive|define
name|WANTED_ALIGNMENT
value|0x800
end_define

begin_comment
comment|/* 2k boundaries */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|OV_MAGIC
parameter_list|(
name|block
parameter_list|,
name|bucket
parameter_list|)
value|(block)->ov_magic
end_define

begin_define
define|#
directive|define
name|OV_INDEX
parameter_list|(
name|block
parameter_list|)
value|(block)->ov_index
end_define

begin_define
define|#
directive|define
name|CHUNK_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MAX_PACKED
value|-1
end_define

begin_define
define|#
directive|define
name|NEEDED_ALIGNMENT
value|MEM_ALIGNBYTES
end_define

begin_define
define|#
directive|define
name|WANTED_ALIGNMENT
value|0x400
end_define

begin_comment
comment|/* 1k boundaries */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|M_OVERHEAD
value|(sizeof(union overhead) + RSLOP)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PACK_MALLOC
end_ifdef

begin_define
define|#
directive|define
name|MEM_OVERHEAD
parameter_list|(
name|bucket
parameter_list|)
define|\
value|(bucket<= MAX_PACKED ? 0 : M_OVERHEAD)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
end_ifdef

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|((MAX_PACKED_POW2 + 1) * BUCKETS_PER_POW2)
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|MAX_PACKED_POW2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_comment
comment|/* Chunks of size 3*2^n. */
end_comment

begin_define
define|#
directive|define
name|SIZE_TABLE_MAX
value|80
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIZE_TABLE_MAX
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|bucket_of
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
comment|/* Chunks of size 3*2^n. */
comment|/* 0 to 15 in 4-byte increments. */
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|>
literal|4
operator|?
literal|6
operator|:
literal|5
operator|)
block|,
comment|/* 4/8, 5-th bucket for better reports */
literal|6
block|,
comment|/* 8 */
name|IF_ALIGN_8
argument_list|(
literal|8
argument_list|,
literal|7
argument_list|)
block|,
literal|8
block|,
comment|/* 16/12, 16 */
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
comment|/* 24, 32 */
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
comment|/* 48 */
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
comment|/* 64 */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
comment|/* 80 */
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
comment|/* 80 */
else|#
directive|else
comment|/* !BUCKETS_ROOT2 */
comment|/* 0 to 15 in 4-byte increments. */
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|>
literal|4
operator|?
literal|3
operator|:
literal|2
operator|)
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
endif|#
directive|endif
comment|/* !BUCKETS_ROOT2 */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMALL_BUCKET_VIA_TABLE */
end_comment

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|MIN_BUCKET
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|(MIN_BUC_POW2 - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMALL_BUCKET_VIA_TABLE */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_define
define|#
directive|define
name|MEM_OVERHEAD
parameter_list|(
name|bucket
parameter_list|)
value|M_OVERHEAD
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
end_ifdef

begin_undef
undef|#
directive|undef
name|SMALL_BUCKET_VIA_TABLE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|START_SHIFTS_BUCKET
value|MIN_BUCKET
end_define

begin_define
define|#
directive|define
name|START_SHIFT
value|(MIN_BUC_POW2 - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PACK_MALLOC */
end_comment

begin_comment
comment|/*  * Big allocations are often of the size 2^n bytes. To make them a  * little bit better, make blocks of size 2^n+pagesize for big n.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PAGESIZE
end_ifndef

begin_define
define|#
directive|define
name|PERL_PAGESIZE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_BIG_POW2
end_ifndef

begin_define
define|#
directive|define
name|FIRST_BIG_POW2
value|15
end_define

begin_comment
comment|/* 32K, 16K is used too often. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FIRST_BIG_BLOCK
value|(1<<FIRST_BIG_POW2)
end_define

begin_comment
comment|/* If this value or more, check against bigger blocks. */
end_comment

begin_define
define|#
directive|define
name|FIRST_BIG_BOUND
value|(FIRST_BIG_BLOCK - M_OVERHEAD)
end_define

begin_comment
comment|/* If less than this value, goes into 2^n-overhead-block. */
end_comment

begin_define
define|#
directive|define
name|LAST_SMALL_BOUND
value|((FIRST_BIG_BLOCK>>1) - M_OVERHEAD)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_ADJUST
parameter_list|(
name|nbytes
parameter_list|)
define|\
value|((nbytes>= FIRST_BIG_BOUND) ? nbytes -= PERL_PAGESIZE : 0)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_SURPLUS
parameter_list|(
name|bucket
parameter_list|)
define|\
value|((bucket>= FIRST_BIG_POW2 * BUCKETS_PER_POW2) ? PERL_PAGESIZE : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !TWO_POT_OPTIMIZE */
end_comment

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_ADJUST
parameter_list|(
name|nbytes
parameter_list|)
end_define

begin_define
define|#
directive|define
name|POW2_OPTIMIZE_SURPLUS
parameter_list|(
name|bucket
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TWO_POT_OPTIMIZE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_64K_LIMIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
end_if

begin_define
define|#
directive|define
name|BARK_64K_LIMIT
parameter_list|(
name|what
parameter_list|,
name|nbytes
parameter_list|,
name|size
parameter_list|)
define|\
value|if (nbytes> 0xffff) {						\ 		PerlIO_printf(PerlIO_stderr(),				\ 			      "%s too large: %lx\n", what, size);	\ 		my_exit(1);						\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAS_64K_LIMIT || !PERL_CORE */
end_comment

begin_define
define|#
directive|define
name|BARK_64K_LIMIT
parameter_list|(
name|what
parameter_list|,
name|nbytes
parameter_list|,
name|size
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_64K_LIMIT || !PERL_CORE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_SBRK
end_ifndef

begin_define
define|#
directive|define
name|MIN_SBRK
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_SBRK
end_ifndef

begin_define
define|#
directive|define
name|FIRST_SBRK
value|(48*1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minimal sbrk in percents of what is already alloced. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_SBRK_FRAC
end_ifndef

begin_define
define|#
directive|define
name|MIN_SBRK_FRAC
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SBRK_ALLOW_FAILURES
end_ifndef

begin_define
define|#
directive|define
name|SBRK_ALLOW_FAILURES
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SBRK_FAILURE_PRICE
end_ifndef

begin_define
define|#
directive|define
name|SBRK_FAILURE_PRICE
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|morecore
parameter_list|(
specifier|register
name|int
name|bucket
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|botch
parameter_list|(
name|char
modifier|*
name|diag
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|add_to_chain
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|,
name|MEM_SIZE
name|chip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|get_from_chain
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|get_from_bigger_buckets
parameter_list|(
name|int
name|bucket
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|overhead
modifier|*
name|getpages
parameter_list|(
name|MEM_SIZE
name|needed
parameter_list|,
name|int
modifier|*
name|nblksp
parameter_list|,
name|int
name|bucket
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getpages_adjacent
parameter_list|(
name|MEM_SIZE
name|require
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_CORE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_MACH_CTHREADS
end_ifdef

begin_undef
undef|#
directive|undef
name|MUTEX_LOCK
end_undef

begin_define
define|#
directive|define
name|MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|STMT_START { if (*m) mutex_lock(*m);   } STMT_END
end_define

begin_undef
undef|#
directive|undef
name|MUTEX_UNLOCK
end_undef

begin_define
define|#
directive|define
name|MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|STMT_START { if (*m) mutex_unlock(*m); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BITS_IN_PTR
end_ifndef

begin_define
define|#
directive|define
name|BITS_IN_PTR
value|(8*PTRSIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * nextf[i] is the pointer to the next free block of size 2^i.  The  * smallest allocatable block is 8 bytes.  The overhead information  * precedes the data area returned to the user.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|(BITS_IN_PTR*BUCKETS_PER_POW2 + 1)
end_define

begin_decl_stmt
specifier|static
name|union
name|overhead
modifier|*
name|nextf
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PURIFY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_PERL_SBRK
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_PERL_SBRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PERL_SBRK
end_ifdef

begin_define
define|#
directive|define
name|sbrk
parameter_list|(
name|a
parameter_list|)
value|Perl_sbrk(a)
end_define

begin_function_decl
name|Malloc_t
name|Perl_sbrk
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_SBRK_PROTO
end_ifndef

begin_function_decl
specifier|extern
name|Malloc_t
name|sbrk
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
end_ifdef

begin_comment
comment|/*  * nmalloc[i] is the difference between the number of mallocs and frees  * for a given block size.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nmalloc
index|[
name|NBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|sbrk_slack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|start_slack
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !( defined DEBUGGING_MSTATS ) */
end_comment

begin_define
define|#
directive|define
name|sbrk_slack
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int
name|goodsbrk
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_EMERGENCY_SBRK
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BIG_SIZE
end_ifndef

begin_define
define|#
directive|define
name|BIG_SIZE
value|(1<<16)
end_define

begin_comment
comment|/* 64K */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|emergency_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MEM_SIZE
name|emergency_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if the last request for more memory succeeded. 			   Otherwise the size of the failing request. */
end_comment

begin_function
specifier|static
name|Malloc_t
name|emergency_sbrk
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|MEM_SIZE
name|rsize
init|=
operator|(
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|LOG_OF_MIN_ARENA
operator|)
operator|+
literal|1
operator|)
operator|<<
name|LOG_OF_MIN_ARENA
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|BIG_SIZE
operator|&&
operator|(
operator|!
name|no_mem
operator|||
operator|(
name|size
operator|<
name|no_mem
operator|)
operator|)
condition|)
block|{
comment|/* Give the possibility to recover, but avoid an infinite cycle. */
name|MALLOC_UNLOCK
expr_stmt|;
name|no_mem
operator|=
name|size
expr_stmt|;
name|croak2
argument_list|(
literal|"Out of memory during \"large\" request for %"
name|UVuf
literal|" bytes, total sbrk() is %"
name|UVuf
literal|" bytes"
argument_list|,
operator|(
name|UV
operator|)
name|size
argument_list|,
call|(
name|UV
call|)
argument_list|(
name|goodsbrk
operator|+
name|sbrk_slack
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emergency_buffer_size
operator|>=
name|rsize
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|emergency_buffer
decl_stmt|;
name|emergency_buffer_size
operator|-=
name|rsize
expr_stmt|;
name|emergency_buffer
operator|+=
name|rsize
expr_stmt|;
return|return
name|old
return|;
block|}
else|else
block|{
name|dTHX
expr_stmt|;
comment|/* First offense, give a possibility to recover by dieing. */
comment|/* No malloc involved here: */
name|GV
modifier|*
modifier|*
name|gvp
init|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
literal|"^M"
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|pv
decl_stmt|;
name|int
name|have
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|emergency_buffer_size
condition|)
block|{
name|add_to_chain
argument_list|(
name|emergency_buffer
argument_list|,
name|emergency_buffer_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emergency_buffer_size
operator|=
literal|0
expr_stmt|;
name|emergency_buffer
operator|=
name|Nullch
expr_stmt|;
name|have
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gvp
condition|)
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_defstash
argument_list|,
literal|"\015"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gvp
operator|||
operator|!
operator|(
name|sv
operator|=
name|GvSV
argument_list|(
operator|*
name|gvp
argument_list|)
operator|)
operator|||
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|<
operator|(
literal|1
operator|<<
name|LOG_OF_MIN_ARENA
operator|)
operator|-
name|M_OVERHEAD
operator|)
condition|)
block|{
if|if
condition|(
name|have
condition|)
goto|goto
name|do_croak
goto|;
return|return
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* Now die die die... */
block|}
comment|/* Got it, now detach SvPV: */
name|pv
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
comment|/* Check alignment: */
if|if
condition|(
operator|(
name|PTR2UV
argument_list|(
name|pv
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|)
operator|&
operator|(
name|NEEDED_ALIGNMENT
operator|-
literal|1
operator|)
condition|)
block|{
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Bad alignment of $^M!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* die die die */
block|}
name|emergency_buffer
operator|=
name|pv
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
expr_stmt|;
name|emergency_buffer_size
operator|=
name|malloced_size
argument_list|(
name|pv
argument_list|)
operator|+
name|M_OVERHEAD
expr_stmt|;
name|SvPOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|Nullch
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|do_croak
label|:
name|MALLOC_UNLOCK
expr_stmt|;
name|croak
argument_list|(
literal|"Out of memory during request for %"
name|UVuf
literal|" bytes, total sbrk() is %"
name|UVuf
literal|" bytes"
argument_list|,
operator|(
name|UV
operator|)
name|size
argument_list|,
call|(
name|UV
call|)
argument_list|(
name|goodsbrk
operator|+
name|sbrk_slack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|Nullch
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  !defined(PERL_EMERGENCY_SBRK) */
end_comment

begin_define
define|#
directive|define
name|emergency_sbrk
parameter_list|(
name|size
parameter_list|)
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef PERL_CORE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|ASSERT
end_undef

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|,
name|diag
parameter_list|)
value|if (!(p)) botch(diag,STRINGIFY(p));  else
end_define

begin_function
specifier|static
name|void
name|botch
parameter_list|(
name|char
modifier|*
name|diag
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"assertion botched (%s?): %s\n"
argument_list|,
name|diag
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PerlProc_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|p
parameter_list|,
name|diag
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Malloc_t
name|Perl_malloc
parameter_list|(
specifier|register
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|register
name|union
name|overhead
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bucket
decl_stmt|;
specifier|register
name|MEM_SIZE
name|shiftr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|RCHECK
argument_list|)
name|MEM_SIZE
name|size
init|=
name|nbytes
decl_stmt|;
endif|#
directive|endif
name|BARK_64K_LIMIT
argument_list|(
literal|"Allocation"
argument_list|,
name|nbytes
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|nbytes
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"panic: malloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Convert amount of memory requested into 	 * closest block size stored in hash buckets 	 * which satisfies request.  Account for 	 * space used per block for accounting. 	 */
ifdef|#
directive|ifdef
name|PACK_MALLOC
ifdef|#
directive|ifdef
name|SMALL_BUCKET_VIA_TABLE
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|bucket
operator|=
name|MIN_BUCKET
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|SIZE_TABLE_MAX
condition|)
block|{
name|bucket
operator|=
name|bucket_of
index|[
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
name|BUCKET_TABLE_SHIFT
index|]
expr_stmt|;
block|}
elseif|else
else|#
directive|else
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|nbytes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
name|MAX_POW2_ALGO
condition|)
goto|goto
name|do_shifts
goto|;
else|else
endif|#
directive|endif
endif|#
directive|endif
block|{
name|POW2_OPTIMIZE_ADJUST
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|M_OVERHEAD
expr_stmt|;
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|do_shifts
label|:
name|shiftr
operator|=
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|>>
name|START_SHIFT
expr_stmt|;
name|bucket
operator|=
name|START_SHIFTS_BUCKET
expr_stmt|;
comment|/* apart from this loop, this is O(1) */
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|bucket
operator|+=
name|BUCKETS_PER_POW2
expr_stmt|;
block|}
name|MALLOC_LOCK
expr_stmt|;
comment|/* 	 * If nothing in hash bucket right now, 	 * request more memory from the system. 	 */
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
operator|==
name|NULL
condition|)
name|morecore
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|nextf
index|[
name|bucket
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|MALLOC_UNLOCK
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_CORE
block|{
name|dTHX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_nomemok
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PLAIN_MALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_FANCY_MALLOC
argument_list|)
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|buff
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|eb
init|=
name|buff
operator|+
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|eb
decl_stmt|;
name|size_t
name|n
init|=
name|nbytes
decl_stmt|;
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Out of memory during request for "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|RCHECK
argument_list|)
name|n
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
operator|*
name|s
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s
operator|=
literal|'0'
operator|+
operator|(
name|n
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|/=
literal|10
condition|)
do|;
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|" bytes, total sbrk() is "
argument_list|)
expr_stmt|;
name|s
operator|=
name|eb
expr_stmt|;
name|n
operator|=
name|goodsbrk
operator|+
name|sbrk_slack
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s
operator|=
literal|'0'
operator|+
operator|(
name|n
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|/=
literal|10
condition|)
do|;
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|" bytes!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(PLAIN_MALLOC)&& defined(NO_FANCY_MALLOC) */
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05lu) malloc %ld bytes\n"
argument_list|,
name|PTR2UV
argument_list|(
name|p
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove from linked list */
if|#
directive|if
name|defined
argument_list|(
name|RCHECK
argument_list|)
if|if
condition|(
operator|(
name|PTR2UV
argument_list|(
name|p
argument_list|)
operator|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
condition|)
block|{
name|dTHX
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Unaligned pointer in the free chain 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PTR2UV
argument_list|(
name|p
operator|->
name|ov_next
argument_list|)
operator|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
condition|)
block|{
name|dTHX
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Unaligned `next' pointer in the free "
literal|"chain 0x%"
name|UVxf
literal|" at 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|p
operator|->
name|ov_next
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|nextf
index|[
name|bucket
index|]
operator|=
name|p
operator|->
name|ov_next
expr_stmt|;
name|MALLOC_UNLOCK
expr_stmt|;
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
name|bucket
operator|>=
name|FIRST_BUCKET_WITH_CHECK
condition|)
endif|#
directive|endif
name|OV_MAGIC
argument_list|(
name|p
argument_list|,
name|bucket
argument_list|)
operator|=
name|MAGIC
expr_stmt|;
ifndef|#
directive|ifndef
name|PACK_MALLOC
name|OV_INDEX
argument_list|(
name|p
argument_list|)
operator|=
name|bucket
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RCHECK
comment|/* 	 * Record allocated size of block and 	 * bound space with magic numbers. 	 */
name|p
operator|->
name|ov_rmagic
operator|=
name|RMAGIC
expr_stmt|;
if|if
condition|(
name|bucket
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|;
name|nbytes
operator|=
name|size
operator|+
name|M_OVERHEAD
expr_stmt|;
name|p
operator|->
name|ov_size
operator|=
name|nbytes
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|=
name|RMAGIC_C
expr_stmt|;
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
call|(
name|Malloc_t
call|)
argument_list|(
name|p
operator|+
name|CHUNK_SHIFT
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_sbrk_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This arena can be easily extended. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sbrked_remains
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbrk_good
init|=
name|SBRK_ALLOW_FAILURES
operator|*
name|SBRK_FAILURE_PRICE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sbrks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|chunk_chain_s
block|{
name|struct
name|chunk_chain_s
modifier|*
name|next
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|chunk_chain_s
modifier|*
name|chunk_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_chunks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|max_bucket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cutoff a piece of one of the chunks in the chain.  Prefer smaller chunk. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|get_from_chain
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|struct
name|chunk_chain_s
modifier|*
name|elt
init|=
name|chunk_chain
decl_stmt|,
modifier|*
modifier|*
name|oldp
init|=
operator|&
name|chunk_chain
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
modifier|*
name|oldgoodp
init|=
name|NULL
decl_stmt|;
name|long
name|min_remain
init|=
name|LONG_MAX
decl_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|size
operator|>=
name|size
condition|)
block|{
name|long
name|remains
init|=
name|elt
operator|->
name|size
operator|-
name|size
decl_stmt|;
if|if
condition|(
name|remains
operator|>=
literal|0
operator|&&
name|remains
operator|<
name|min_remain
condition|)
block|{
name|oldgoodp
operator|=
name|oldp
expr_stmt|;
name|min_remain
operator|=
name|remains
expr_stmt|;
block|}
if|if
condition|(
name|remains
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|oldp
operator|=
operator|&
operator|(
name|elt
operator|->
name|next
operator|)
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldgoodp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|min_remain
condition|)
block|{
name|void
modifier|*
name|ret
init|=
operator|*
name|oldgoodp
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
name|next
init|=
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
decl_stmt|;
operator|*
name|oldgoodp
operator|=
operator|(
expr|struct
name|chunk_chain_s
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|+
name|size
operator|)
expr_stmt|;
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|size
operator|=
name|min_remain
expr_stmt|;
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|void
modifier|*
name|ret
init|=
operator|*
name|oldgoodp
decl_stmt|;
operator|*
name|oldgoodp
operator|=
operator|(
operator|*
name|oldgoodp
operator|)
operator|->
name|next
expr_stmt|;
name|n_chunks
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_to_chain
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|,
name|MEM_SIZE
name|chip
parameter_list|)
block|{
name|struct
name|chunk_chain_s
modifier|*
name|next
init|=
name|chunk_chain
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|cp
operator|+=
name|chip
expr_stmt|;
name|chunk_chain
operator|=
operator|(
expr|struct
name|chunk_chain_s
operator|*
operator|)
name|cp
expr_stmt|;
name|chunk_chain
operator|->
name|size
operator|=
name|size
operator|-
name|chip
expr_stmt|;
name|chunk_chain
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|n_chunks
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_from_bigger_buckets
parameter_list|(
name|int
name|bucket
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|int
name|price
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|bucketprice
index|[
name|NBUCKETS
index|]
decl_stmt|;
while|while
condition|(
name|bucket
operator|<=
name|max_bucket
condition|)
block|{
comment|/* We postpone stealing from bigger buckets until we want it 	   often enough. */
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
operator|&&
name|bucketprice
index|[
name|bucket
index|]
operator|++
operator|>=
name|price
condition|)
block|{
comment|/* Steal it! */
name|void
modifier|*
name|ret
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|nextf
index|[
name|bucket
index|]
operator|-
literal|1
operator|+
name|CHUNK_SHIFT
operator|)
decl_stmt|;
name|bucketprice
index|[
name|bucket
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|nextf
index|[
name|bucket
index|]
operator|)
operator|-
name|M_OVERHEAD
operator|==
name|last_op
condition|)
block|{
name|last_op
operator|=
name|NULL
expr_stmt|;
comment|/* Disable optimization */
block|}
name|nextf
index|[
name|bucket
index|]
operator|=
name|nextf
index|[
name|bucket
index|]
operator|->
name|ov_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|--
expr_stmt|;
name|start_slack
operator|-=
name|M_OVERHEAD
expr_stmt|;
endif|#
directive|endif
name|add_to_chain
argument_list|(
name|ret
argument_list|,
operator|(
name|BUCKET_SIZE
argument_list|(
name|bucket
argument_list|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|bucket
argument_list|)
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|bucket
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|overhead
modifier|*
name|getpages
parameter_list|(
name|MEM_SIZE
name|needed
parameter_list|,
name|int
modifier|*
name|nblksp
parameter_list|,
name|int
name|bucket
parameter_list|)
block|{
comment|/* Need to do (possibly expensive) system call. Try to        optimize it for rare calling. */
name|MEM_SIZE
name|require
init|=
name|needed
operator|-
name|sbrked_remains
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|MEM_SIZE
name|slack
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sbrk_good
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|last_sbrk_top
operator|&&
name|require
operator|<
name|FIRST_SBRK
condition|)
name|require
operator|=
name|FIRST_SBRK
expr_stmt|;
elseif|else
if|if
condition|(
name|require
operator|<
name|MIN_SBRK
condition|)
name|require
operator|=
name|MIN_SBRK
expr_stmt|;
if|if
condition|(
name|require
operator|<
name|goodsbrk
operator|*
name|MIN_SBRK_FRAC
operator|/
literal|100
condition|)
name|require
operator|=
name|goodsbrk
operator|*
name|MIN_SBRK_FRAC
operator|/
literal|100
expr_stmt|;
name|require
operator|=
operator|(
operator|(
name|require
operator|-
literal|1
operator|+
name|MIN_SBRK
operator|)
operator|/
name|MIN_SBRK
operator|)
operator|*
name|MIN_SBRK
expr_stmt|;
block|}
else|else
block|{
name|require
operator|=
name|needed
expr_stmt|;
name|last_sbrk_top
operator|=
literal|0
expr_stmt|;
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk(%ld) for %ld-byte-long arena\n"
argument_list|,
operator|(
name|long
operator|)
name|require
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
name|last_sbrk_top
condition|)
block|{
comment|/* Common case, anything is fine. */
name|sbrk_good
operator|++
expr_stmt|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
name|cp
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
name|last_op
operator|=
name|cp
operator|-
name|sbrked_remains
expr_stmt|;
name|sbrked_remains
operator|=
name|require
operator|-
operator|(
name|needed
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* no more room! */
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|emergency_sbrk
argument_list|(
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ovp
operator|)
operator|>
name|last_op
condition|)
block|{
comment|/* Cannot happen with current emergency_sbrk() */
name|last_op
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ovp
return|;
block|}
else|else
block|{
comment|/* Non-continuous or first sbrk(). */
name|long
name|add
init|=
name|sbrked_remains
decl_stmt|;
name|char
modifier|*
name|newcp
decl_stmt|;
if|if
condition|(
name|sbrked_remains
condition|)
block|{
comment|/* Put rest into chain, we 				   cannot use it right now. */
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
argument_list|,
name|sbrked_remains
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Second, check alignment. */
name|slack
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|atarist
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINT__
argument_list|)
comment|/* on the atari we dont have to worry about this */
ifndef|#
directive|ifndef
name|I286
comment|/* The sbrk(0) call on the I286 always returns the next segment */
comment|/* WANTED_ALIGNMENT may be more than NEEDED_ALIGNMENT, but this may 	   improve performance of memory access. */
if|if
condition|(
name|PTR2UV
argument_list|(
name|cp
argument_list|)
operator|&
operator|(
name|WANTED_ALIGNMENT
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Not aligned. */
name|slack
operator|=
name|WANTED_ALIGNMENT
operator|-
operator|(
name|PTR2UV
argument_list|(
name|cp
argument_list|)
operator|&
operator|(
name|WANTED_ALIGNMENT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|add
operator|+=
name|slack
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !atarist&& !MINT */
if|if
condition|(
name|add
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk(%ld) to fix non-continuous/off-page sbrk:\n\t%ld for alignement,\t%ld were assumed to come from the tail of the previous sbrk\n"
argument_list|,
operator|(
name|long
operator|)
name|add
argument_list|,
operator|(
name|long
operator|)
name|slack
argument_list|,
operator|(
name|long
operator|)
name|sbrked_remains
argument_list|)
argument_list|)
expr_stmt|;
name|newcp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|add
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
name|sbrks
operator|++
expr_stmt|;
name|sbrk_slack
operator|+=
name|add
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newcp
operator|!=
name|cp
operator|+
name|require
condition|)
block|{
comment|/* Too bad: even rounding sbrk() is not continuous.*/
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"failed to fix bad sbrk()\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
if|if
condition|(
name|slack
condition|)
block|{
name|MALLOC_UNLOCK
expr_stmt|;
name|fatalcroak
argument_list|(
literal|"panic: Off-page sbrk\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sbrked_remains
condition|)
block|{
comment|/* Try again. */
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
name|sbrk_slack
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
name|require
operator|=
name|needed
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"straight sbrk(%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|require
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
block|}
name|sbrk_good
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Disable optimization! 				   Continue with not-aligned... */
block|}
else|else
block|{
name|cp
operator|+=
name|slack
expr_stmt|;
name|require
operator|+=
name|sbrked_remains
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_sbrk_top
condition|)
block|{
name|sbrk_good
operator|-=
name|SBRK_FAILURE_PRICE
expr_stmt|;
block|}
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|cp
expr_stmt|;
comment|/* 	 * Round up to minimum allocation size boundary 	 * and deduct from block count to reflect. 	 */
if|#
directive|if
name|NEEDED_ALIGNMENT
operator|>
name|MEM_ALIGNBYTES
if|if
condition|(
name|PTR2UV
argument_list|(
name|ovp
argument_list|)
operator|&
operator|(
name|NEEDED_ALIGNMENT
operator|-
literal|1
operator|)
condition|)
name|fatalcroak
argument_list|(
literal|"Misalignment of sbrk()\n"
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|I286
comment|/* Again, this should always be ok on an 80286 */
if|if
condition|(
name|PTR2UV
argument_list|(
name|ovp
argument_list|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"fixing sbrk(): %d bytes off machine alignement\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|PTR2UV
argument_list|(
name|ovp
argument_list|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ovp
operator|=
name|INT2PTR
argument_list|(
expr|union
name|overhead
operator|*
argument_list|,
operator|(
name|PTR2UV
argument_list|(
name|ovp
argument_list|)
operator|+
name|MEM_ALIGNBYTES
operator|)
operator|&
operator|(
name|MEM_ALIGNBYTES
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nblksp
operator|)
operator|--
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING_MSTATS
argument_list|)
comment|/* This is only approx. if TWO_POT_OPTIMIZE: */
name|sbrk_slack
operator|+=
operator|(
literal|1
operator|<<
operator|(
name|bucket
operator|>>
name|BUCKET_POW2_SHIFT
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
empty_stmt|;
comment|/* Finish `else' */
name|sbrked_remains
operator|=
name|require
operator|-
name|needed
expr_stmt|;
name|last_op
operator|=
name|cp
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PLAIN_MALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_FANCY_MALLOC
argument_list|)
name|no_mem
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|last_sbrk_top
operator|=
name|cp
operator|+
name|require
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|goodsbrk
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
return|return
name|ovp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getpages_adjacent
parameter_list|(
name|MEM_SIZE
name|require
parameter_list|)
block|{
if|if
condition|(
name|require
operator|<=
name|sbrked_remains
condition|)
block|{
name|sbrked_remains
operator|-=
name|require
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|require
operator|-=
name|sbrked_remains
expr_stmt|;
comment|/* We do not try to optimize sbrks here, we go for place. */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|require
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|sbrks
operator|++
expr_stmt|;
name|goodsbrk
operator|+=
name|require
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
name|last_sbrk_top
condition|)
block|{
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
name|last_sbrk_top
operator|=
name|cp
operator|+
name|require
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Out of memory */
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|goodsbrk
operator|-=
name|require
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* Report the failure: */
if|if
condition|(
name|sbrked_remains
condition|)
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
argument_list|,
name|sbrked_remains
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_to_chain
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|,
name|require
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbrk_good
operator|-=
name|SBRK_FAILURE_PRICE
expr_stmt|;
name|sbrked_remains
operator|=
literal|0
expr_stmt|;
name|last_sbrk_top
operator|=
literal|0
expr_stmt|;
name|last_op
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate more memory to the indicated bucket.  */
end_comment

begin_function
specifier|static
name|void
name|morecore
parameter_list|(
specifier|register
name|int
name|bucket
parameter_list|)
block|{
specifier|register
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
specifier|register
name|int
name|rnu
decl_stmt|;
comment|/* 2^rnu bytes will be requested */
name|int
name|nblks
decl_stmt|;
comment|/* become nblks blocks of the desired size */
specifier|register
name|MEM_SIZE
name|siz
decl_stmt|,
name|needed
decl_stmt|;
if|if
condition|(
name|nextf
index|[
name|bucket
index|]
condition|)
return|return;
if|if
condition|(
name|bucket
operator|==
sizeof|sizeof
argument_list|(
name|MEM_SIZE
argument_list|)
operator|*
literal|8
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
name|MALLOC_UNLOCK
expr_stmt|;
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"Out of memory during ridiculously large request"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bucket
operator|>
name|max_bucket
condition|)
name|max_bucket
operator|=
name|bucket
expr_stmt|;
name|rnu
operator|=
operator|(
operator|(
name|bucket
operator|<=
operator|(
name|LOG_OF_MIN_ARENA
operator|<<
name|BUCKET_POW2_SHIFT
operator|)
operator|)
condition|?
name|LOG_OF_MIN_ARENA
else|:
operator|(
name|bucket
operator|>>
name|BUCKET_POW2_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* This may be overwritten later: */
name|nblks
operator|=
literal|1
operator|<<
operator|(
name|rnu
operator|-
operator|(
name|bucket
operator|>>
name|BUCKET_POW2_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* how many blocks to get */
name|needed
operator|=
operator|(
operator|(
name|MEM_SIZE
operator|)
literal|1
operator|<<
name|rnu
operator|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
condition|)
block|{
comment|/* 2048b bucket. */
name|ovp
operator|=
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|-
literal|1
operator|+
name|CHUNK_SHIFT
expr_stmt|;
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|=
name|nextf
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|->
name|ov_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
index|]
operator|--
expr_stmt|;
name|start_slack
operator|-=
name|M_OVERHEAD
expr_stmt|;
endif|#
directive|endif
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from %ld arena\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|,
operator|(
name|long
operator|)
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_chain
operator|&&
operator|(
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|get_from_chain
argument_list|(
name|needed
argument_list|)
operator|)
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from chain\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|get_from_bigger_buckets
argument_list|(
operator|(
name|rnu
operator|<<
name|BUCKET_POW2_SHIFT
operator|)
operator|+
literal|1
argument_list|,
name|needed
argument_list|)
operator|)
condition|)
block|{
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stealing %ld bytes from bigger buckets\n"
argument_list|,
operator|(
name|long
operator|)
name|needed
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needed
operator|<=
name|sbrked_remains
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
name|last_sbrk_top
operator|-
name|sbrked_remains
operator|)
expr_stmt|;
name|sbrked_remains
operator|-=
name|needed
expr_stmt|;
name|last_op
operator|=
operator|(
name|char
operator|*
operator|)
name|ovp
expr_stmt|;
block|}
else|else
name|ovp
operator|=
name|getpages
argument_list|(
name|needed
argument_list|,
operator|&
name|nblks
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ovp
condition|)
return|return;
comment|/* 	 * Add new memory allocated to that on 	 * free list for this hash bucket. 	 */
name|siz
operator|=
name|BUCKET_SIZE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
operator|*
operator|(
name|u_char
operator|*
operator|)
name|ovp
operator|=
name|bucket
expr_stmt|;
comment|/* Fill index. */
if|if
condition|(
name|bucket
operator|<=
name|MAX_PACKED
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ovp
operator|+
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
operator|)
expr_stmt|;
name|nblks
operator|=
name|N_BLKS
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|start_slack
operator|+=
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bucket
operator|<
name|LOG_OF_MIN_ARENA
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ovp
operator|+
name|BLK_SHIFT
argument_list|(
name|bucket
argument_list|)
operator|)
expr_stmt|;
name|siz
operator|-=
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
expr_stmt|;
block|}
else|else
name|ovp
operator|++
expr_stmt|;
comment|/* One chunk per block. */
endif|#
directive|endif
comment|/* PACK_MALLOC */
name|nextf
index|[
name|bucket
index|]
operator|=
name|ovp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|+=
name|nblks
expr_stmt|;
if|if
condition|(
name|bucket
operator|>
name|MAX_PACKED
condition|)
block|{
name|start_slack
operator|+=
name|M_OVERHEAD
operator|*
name|nblks
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|--
name|nblks
operator|>
literal|0
condition|)
block|{
name|ovp
operator|->
name|ov_next
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|siz
operator|)
expr_stmt|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|siz
operator|)
expr_stmt|;
block|}
comment|/* Not all sbrks return zeroed memory.*/
name|ovp
operator|->
name|ov_next
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
if|if
condition|(
name|bucket
operator|==
literal|7
operator|*
name|BUCKETS_PER_POW2
condition|)
block|{
comment|/* Special case, explanation is above. */
name|union
name|overhead
modifier|*
name|n_op
init|=
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|->
name|ov_next
decl_stmt|;
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|)
expr_stmt|;
name|nextf
index|[
literal|7
operator|*
name|BUCKETS_PER_POW2
index|]
operator|->
name|ov_next
operator|=
name|n_op
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !PACK_MALLOC */
block|}
end_function

begin_function
name|Free_t
name|Perl_mfree
parameter_list|(
name|void
modifier|*
name|mp
parameter_list|)
block|{
specifier|register
name|MEM_SIZE
name|size
decl_stmt|;
specifier|register
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|u_char
name|bucket
decl_stmt|;
endif|#
directive|endif
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05lu) free\n"
argument_list|,
name|PTR2UV
argument_list|(
name|cp
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|bucket
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
operator|(
name|bucket
operator|>=
name|FIRST_BUCKET_WITH_CHECK
operator|)
operator|&&
operator|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
condition|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|bad_free_warn
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bad_free_warn
operator|==
operator|-
literal|1
condition|)
block|{
name|dTHX
expr_stmt|;
name|char
modifier|*
name|pbf
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_BADFREE"
argument_list|)
decl_stmt|;
name|bad_free_warn
operator|=
operator|(
name|pbf
operator|)
condition|?
name|atoi
argument_list|(
name|pbf
argument_list|)
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad_free_warn
condition|)
return|return;
ifdef|#
directive|ifdef
name|RCHECK
ifdef|#
directive|ifdef
name|PERL_CORE
block|{
name|dTHX
expr_stmt|;
if|if
condition|(
operator|!
name|PERL_IS_ALIVE
operator|||
operator|!
name|PL_curcop
operator|||
name|ckWARN_d
argument_list|(
name|WARN_MALLOC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MALLOC
argument_list|,
literal|"%s free() ignored"
argument_list|,
argument|ovp->ov_rmagic == RMAGIC -
literal|1
argument|?
literal|"Duplicate"
argument|:
literal|"Bad"
argument_list|)
empty_stmt|;
block|}
else|#
directive|else
name|warn
argument_list|(
literal|"%s free() ignored"
argument_list|,
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
operator|-
literal|1
condition|?
literal|"Duplicate"
else|:
literal|"Bad"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|PERL_CORE
block|{
name|dTHX
expr_stmt|;
if|if
condition|(
operator|!
name|PERL_IS_ALIVE
operator|||
operator|!
name|PL_curcop
operator|||
name|ckWARN_d
argument_list|(
name|WARN_MALLOC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MALLOC
argument_list|,
literal|"%s"
argument_list|,
literal|"Bad free() ignored"
argument_list|)
empty_stmt|;
block|}
else|#
directive|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
literal|"Bad free() ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
comment|/* sanity */
block|}
ifdef|#
directive|ifdef
name|RCHECK
name|ASSERT
argument_list|(
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's head overwrite"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|;
name|MEM_SIZE
name|nbytes
init|=
name|ovp
operator|->
name|ov_size
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|==
name|RMAGIC_C
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
name|ovp
operator|->
name|ov_rmagic
operator|=
name|RMAGIC
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<
name|NBUCKETS
argument_list|,
literal|"chunk's head overwrite"
argument_list|)
expr_stmt|;
name|size
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
name|MALLOC_LOCK
expr_stmt|;
name|ovp
operator|->
name|ov_next
operator|=
name|nextf
index|[
name|size
index|]
expr_stmt|;
name|nextf
index|[
name|size
index|]
operator|=
name|ovp
expr_stmt|;
name|MALLOC_UNLOCK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* There is no need to do any locking in realloc (with an exception of    trying to grow in place if we are at the end of the chain).    If somebody calls us from a different thread with the same address,    we are sole anyway.  */
end_comment

begin_function
name|Malloc_t
name|Perl_realloc
parameter_list|(
name|void
modifier|*
name|mp
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|register
name|MEM_SIZE
name|onb
decl_stmt|;
name|union
name|overhead
modifier|*
name|ovp
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
name|int
name|prev_bucket
decl_stmt|;
specifier|register
name|int
name|bucket
decl_stmt|;
name|int
name|incr
decl_stmt|;
comment|/* 1 if does not fit, -1 if "easily" fits in a 				   smaller bucket, otherwise 0.  */
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|mp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|PERL_CORE
argument_list|)
name|MEM_SIZE
name|size
init|=
name|nbytes
decl_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|nbytes
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"%s"
argument_list|,
literal|"panic: realloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BARK_64K_LIMIT
argument_list|(
literal|"Reallocation"
argument_list|,
name|nbytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|Perl_malloc
argument_list|(
name|nbytes
argument_list|)
return|;
name|ovp
operator|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
expr_stmt|;
name|bucket
operator|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IGNORE_SMALL_BAD_FREE
if|if
condition|(
operator|(
name|bucket
operator|>=
name|FIRST_BUCKET_WITH_CHECK
operator|)
operator|&&
operator|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|OV_MAGIC
argument_list|(
name|ovp
argument_list|,
name|bucket
argument_list|)
operator|!=
name|MAGIC
condition|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|bad_free_warn
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bad_free_warn
operator|==
operator|-
literal|1
condition|)
block|{
name|dTHX
expr_stmt|;
name|char
modifier|*
name|pbf
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_BADFREE"
argument_list|)
decl_stmt|;
name|bad_free_warn
operator|=
operator|(
name|pbf
operator|)
condition|?
name|atoi
argument_list|(
name|pbf
argument_list|)
else|:
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad_free_warn
condition|)
return|return
name|Nullch
return|;
ifdef|#
directive|ifdef
name|RCHECK
ifdef|#
directive|ifdef
name|PERL_CORE
block|{
name|dTHX
expr_stmt|;
if|if
condition|(
operator|!
name|PERL_IS_ALIVE
operator|||
operator|!
name|PL_curcop
operator|||
name|ckWARN_d
argument_list|(
name|WARN_MALLOC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MALLOC
argument_list|,
literal|"%srealloc() %signored"
argument_list|,
argument|(ovp->ov_rmagic == RMAGIC -
literal|1
argument|?
literal|""
argument|:
literal|"Bad "
argument|)
argument_list|,
argument|ovp->ov_rmagic == RMAGIC -
literal|1
argument|?
literal|"of freed memory "
argument|:
literal|""
argument_list|)
empty_stmt|;
block|}
else|#
directive|else
name|warn
argument_list|(
literal|"%srealloc() %signored"
argument_list|,
operator|(
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
operator|-
literal|1
condition|?
literal|""
else|:
literal|"Bad "
operator|)
argument_list|,
name|ovp
operator|->
name|ov_rmagic
operator|==
name|RMAGIC
operator|-
literal|1
condition|?
literal|"of freed memory "
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|PERL_CORE
block|{
name|dTHX
expr_stmt|;
if|if
condition|(
operator|!
name|PERL_IS_ALIVE
operator|||
operator|!
name|PL_curcop
operator|||
name|ckWARN_d
argument_list|(
name|WARN_MALLOC
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MALLOC
argument_list|,
literal|"%s"
argument_list|,
literal|"Bad realloc() ignored"
argument_list|)
empty_stmt|;
block|}
else|#
directive|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
literal|"Bad realloc() ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|Nullch
return|;
comment|/* sanity */
block|}
name|onb
operator|=
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|/*  	 *  avoid the copy if same size block. 	 *  We are not agressive with boundary cases. Note that it might 	 *  (for a small number of cases) give false negative if 	 *  both new size and old one are in the bucket for 	 *  FIRST_BIG_POW2, but the new one is near the lower end. 	 * 	 *  We do not try to go to 1.5 times smaller bucket so far. 	 */
if|if
condition|(
name|nbytes
operator|>
name|onb
condition|)
name|incr
operator|=
literal|1
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DO_NOT_TRY_HARDER_WHEN_SHRINKING
if|if
condition|(
comment|/* This is a little bit pessimal if PACK_MALLOC: */
name|nbytes
operator|>
operator|(
operator|(
name|onb
operator|>>
literal|1
operator|)
operator|-
name|M_OVERHEAD
operator|)
ifdef|#
directive|ifdef
name|TWO_POT_OPTIMIZE
operator|||
operator|(
name|bucket
operator|==
name|FIRST_BIG_POW2
operator|&&
name|nbytes
operator|>=
name|LAST_SMALL_BOUND
operator|)
endif|#
directive|endif
condition|)
else|#
directive|else
comment|/* !DO_NOT_TRY_HARDER_WHEN_SHRINKING */
name|prev_bucket
operator|=
operator|(
operator|(
name|bucket
operator|>
name|MAX_PACKED
operator|+
literal|1
operator|)
condition|?
name|bucket
operator|-
name|BUCKETS_PER_POW2
else|:
name|bucket
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|BUCKET_SIZE_REAL
argument_list|(
name|prev_bucket
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !DO_NOT_TRY_HARDER_WHEN_SHRINKING */
name|incr
operator|=
literal|0
expr_stmt|;
else|else
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STRESS_REALLOC
goto|goto
name|hard_way
goto|;
endif|#
directive|endif
if|if
condition|(
name|incr
operator|==
literal|0
condition|)
block|{
name|inplace_label
label|:
ifdef|#
directive|ifdef
name|RCHECK
comment|/* 		 * Record new allocated size of block and 		 * bound space with magic numbers. 		 */
if|if
condition|(
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|int
name|i
decl_stmt|,
name|nb
init|=
name|ovp
operator|->
name|ov_size
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nb
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nb
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|==
name|RMAGIC_C
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
block|}
block|}
name|nb
operator|=
operator|(
name|nb
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nb
operator|-
name|RSLOP
operator|)
operator|==
name|RMAGIC
argument_list|,
literal|"chunk's tail overwrite"
argument_list|)
expr_stmt|;
comment|/* 			 * Convert amount of memory requested into 			 * closest block size stored in hash buckets 			 * which satisfies request.  Account for 			 * space used per block for accounting. 			 */
name|nbytes
operator|+=
name|M_OVERHEAD
expr_stmt|;
name|ovp
operator|->
name|ov_size
operator|=
name|nbytes
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|nbytes
operator|&
literal|3
operator|)
condition|)
block|{
name|i
operator|=
literal|4
operator|-
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|+
name|i
operator|)
operator|)
operator|=
name|RMAGIC_C
expr_stmt|;
block|}
name|nbytes
operator|=
operator|(
name|nbytes
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|nbytes
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|cp
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05lu) realloc %ld bytes inplace\n"
argument_list|,
name|PTR2UV
argument_list|(
name|res
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incr
operator|==
literal|1
operator|&&
operator|(
name|cp
operator|-
name|M_OVERHEAD
operator|==
name|last_op
operator|)
operator|&&
operator|(
name|onb
operator|>
operator|(
literal|1
operator|<<
name|LOG_OF_MIN_ARENA
operator|)
operator|)
condition|)
block|{
name|MEM_SIZE
name|require
decl_stmt|,
name|newarena
init|=
name|nbytes
decl_stmt|,
name|pow
decl_stmt|;
name|int
name|shiftr
decl_stmt|;
name|POW2_OPTIMIZE_ADJUST
argument_list|(
name|newarena
argument_list|)
expr_stmt|;
name|newarena
operator|=
name|newarena
operator|+
name|M_OVERHEAD
expr_stmt|;
comment|/* newarena = (newarena + 3)&~ 3; */
name|shiftr
operator|=
operator|(
name|newarena
operator|-
literal|1
operator|)
operator|>>
name|LOG_OF_MIN_ARENA
expr_stmt|;
name|pow
operator|=
name|LOG_OF_MIN_ARENA
operator|+
literal|1
expr_stmt|;
comment|/* apart from this loop, this is O(1) */
while|while
condition|(
name|shiftr
operator|>>=
literal|1
condition|)
name|pow
operator|++
expr_stmt|;
name|newarena
operator|=
operator|(
literal|1
operator|<<
name|pow
operator|)
operator|+
name|POW2_OPTIMIZE_SURPLUS
argument_list|(
name|pow
operator|*
name|BUCKETS_PER_POW2
argument_list|)
expr_stmt|;
name|require
operator|=
name|newarena
operator|-
name|onb
operator|-
name|M_OVERHEAD
expr_stmt|;
name|MALLOC_LOCK
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|M_OVERHEAD
operator|==
name|last_op
comment|/* We *still* are the last chunk */
operator|&&
name|getpages_adjacent
argument_list|(
name|require
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
name|nmalloc
index|[
name|bucket
index|]
operator|--
expr_stmt|;
name|nmalloc
index|[
name|pow
operator|*
name|BUCKETS_PER_POW2
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|cp
operator|-
name|M_OVERHEAD
operator|)
operator|=
name|pow
operator|*
name|BUCKETS_PER_POW2
expr_stmt|;
comment|/* Fill index. */
name|MALLOC_UNLOCK
expr_stmt|;
goto|goto
name|inplace_label
goto|;
block|}
else|else
block|{
name|MALLOC_UNLOCK
expr_stmt|;
goto|goto
name|hard_way
goto|;
block|}
block|}
else|else
block|{
name|hard_way
label|:
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05lu) realloc %ld bytes the hard way\n"
argument_list|,
name|PTR2UV
argument_list|(
name|cp
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PL_an
operator|++
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|Perl_malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|!=
name|res
condition|)
comment|/* common optimization */
name|Copy
argument_list|(
name|cp
argument_list|,
name|res
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|nbytes
operator|<
name|onb
condition|?
name|nbytes
else|:
name|onb
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Perl_mfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Malloc_t
operator|)
name|res
operator|)
return|;
block|}
end_function

begin_function
name|Malloc_t
name|Perl_calloc
parameter_list|(
specifier|register
name|size_t
name|elements
parameter_list|,
specifier|register
name|size_t
name|size
parameter_list|)
block|{
name|long
name|sz
init|=
name|elements
operator|*
name|size
decl_stmt|;
name|Malloc_t
name|p
init|=
name|Perl_malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|MEM_SIZE
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s1
init|=
operator|(
name|char
operator|*
operator|)
name|Perl_malloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Copy
argument_list|(
name|s
argument_list|,
name|s1
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|l
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_CORE
end_ifdef

begin_function
name|int
name|Perl_putenv
parameter_list|(
name|char
modifier|*
name|a
parameter_list|)
block|{
comment|/* Sometimes system's putenv conflicts with my_setenv() - this is system        malloc vs Perl's free(). */
name|dTHX
expr_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|a
decl_stmt|;
name|MEM_SIZE
name|l
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|val
operator|&&
operator|*
name|val
operator|!=
literal|'='
condition|)
name|val
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|val
condition|)
return|return
operator|-
literal|1
return|;
name|l
operator|=
name|val
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|l
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|var
operator|=
name|buf
expr_stmt|;
else|else
name|var
operator|=
name|Perl_malloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|a
argument_list|,
name|var
argument_list|,
name|l
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|var
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|my_setenv
argument_list|(
name|var
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|!=
name|buf
condition|)
name|Perl_mfree
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|MEM_SIZE
name|Perl_malloced_size
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|overhead
modifier|*
name|ovp
init|=
operator|(
expr|union
name|overhead
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|-
sizeof|sizeof
argument_list|(
expr|union
name|overhead
argument_list|)
operator|*
name|CHUNK_SHIFT
operator|)
decl_stmt|;
name|int
name|bucket
init|=
name|OV_INDEX
argument_list|(
name|ovp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|RCHECK
comment|/* The caller wants to have a complete control over the chunk,        disable the memory checking inside the chunk.  */
if|if
condition|(
name|bucket
operator|<=
name|MAX_SHORT_BUCKET
condition|)
block|{
name|MEM_SIZE
name|size
init|=
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
decl_stmt|;
name|ovp
operator|->
name|ov_size
operator|=
name|size
operator|+
name|M_OVERHEAD
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ovp
operator|+
name|size
operator|+
name|M_OVERHEAD
operator|-
name|RSLOP
operator|)
operator|)
operator|=
name|RMAGIC
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|BUCKET_SIZE_REAL
argument_list|(
name|bucket
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
end_ifdef

begin_define
define|#
directive|define
name|MIN_EVEN_REPORT
value|6
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MIN_EVEN_REPORT
value|MIN_BUCKET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|Perl_get_mstats
parameter_list|(
name|pTHX_
name|perl_mstats_t
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|level
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|union
name|overhead
modifier|*
name|p
decl_stmt|;
name|struct
name|chunk_chain_s
modifier|*
name|nextchain
decl_stmt|;
name|buf
operator|->
name|topbucket
operator|=
name|buf
operator|->
name|topbucket_ev
operator|=
name|buf
operator|->
name|topbucket_odd
operator|=
name|buf
operator|->
name|totfree
operator|=
name|buf
operator|->
name|total
operator|=
name|buf
operator|->
name|total_chain
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|minbucket
operator|=
name|MIN_BUCKET
expr_stmt|;
name|MALLOC_LOCK
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p
operator|=
name|nextf
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|ov_next
operator|,
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|buflen
condition|)
block|{
name|buf
operator|->
name|nfree
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|buf
operator|->
name|ntotal
index|[
name|i
index|]
operator|=
name|nmalloc
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf
operator|->
name|totfree
operator|+=
name|j
operator|*
name|BUCKET_SIZE_REAL
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|buf
operator|->
name|total
operator|+=
name|nmalloc
index|[
name|i
index|]
operator|*
name|BUCKET_SIZE_REAL
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmalloc
index|[
name|i
index|]
condition|)
block|{
name|i
operator|%
literal|2
condition|?
operator|(
name|buf
operator|->
name|topbucket_odd
operator|=
name|i
operator|)
else|:
operator|(
name|buf
operator|->
name|topbucket_ev
operator|=
name|i
operator|)
expr_stmt|;
name|buf
operator|->
name|topbucket
operator|=
name|i
expr_stmt|;
block|}
block|}
name|nextchain
operator|=
name|chunk_chain
expr_stmt|;
while|while
condition|(
name|nextchain
condition|)
block|{
name|buf
operator|->
name|total_chain
operator|+=
name|nextchain
operator|->
name|size
expr_stmt|;
name|nextchain
operator|=
name|nextchain
operator|->
name|next
expr_stmt|;
block|}
name|buf
operator|->
name|total_sbrk
operator|=
name|goodsbrk
operator|+
name|sbrk_slack
expr_stmt|;
name|buf
operator|->
name|sbrks
operator|=
name|sbrks
expr_stmt|;
name|buf
operator|->
name|sbrk_good
operator|=
name|sbrk_good
expr_stmt|;
name|buf
operator|->
name|sbrk_slack
operator|=
name|sbrk_slack
expr_stmt|;
name|buf
operator|->
name|start_slack
operator|=
name|start_slack
expr_stmt|;
name|buf
operator|->
name|sbrked_remains
operator|=
name|sbrked_remains
expr_stmt|;
name|MALLOC_UNLOCK
expr_stmt|;
name|buf
operator|->
name|nbuckets
operator|=
name|NBUCKETS
expr_stmt|;
if|if
condition|(
name|level
condition|)
block|{
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
init|;
name|i
operator|<
name|NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|buflen
condition|)
break|break;
name|buf
operator|->
name|bucket_mem_size
index|[
name|i
index|]
operator|=
name|BUCKET_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bucket_available_size
index|[
name|i
index|]
operator|=
name|BUCKET_SIZE_REAL
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined DEBUGGING_MSTATS */
return|return
literal|0
return|;
comment|/* XXX unused */
block|}
end_function

begin_comment
comment|/*  * mstats - print out statistics about malloc  *   * Prints two lines of numbers, one showing the length of the free list  * for each size category, the second showing the number of mallocs -  * frees for each size category.  */
end_comment

begin_function
name|void
name|Perl_dump_mstats
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING_MSTATS
specifier|register
name|int
name|i
decl_stmt|;
name|perl_mstats_t
name|buffer
decl_stmt|;
name|UV
name|nf
index|[
name|NBUCKETS
index|]
decl_stmt|;
name|UV
name|nt
index|[
name|NBUCKETS
index|]
decl_stmt|;
name|buffer
operator|.
name|nfree
operator|=
name|nf
expr_stmt|;
name|buffer
operator|.
name|ntotal
operator|=
name|nt
expr_stmt|;
name|get_mstats
argument_list|(
operator|&
name|buffer
argument_list|,
name|NBUCKETS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"Memory allocation statistics %s (buckets %"
name|IVdf
literal|"(%"
name|IVdf
literal|")..%"
name|IVdf
literal|"(%"
name|IVdf
literal|")\n"
argument_list|,
name|s
argument_list|,
operator|(
name|IV
operator|)
name|BUCKET_SIZE_REAL
argument_list|(
name|MIN_BUCKET
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|BUCKET_SIZE
argument_list|(
name|MIN_BUCKET
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|BUCKET_SIZE_REAL
argument_list|(
name|buffer
operator|.
name|topbucket
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|BUCKET_SIZE
argument_list|(
name|buffer
operator|.
name|topbucket
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"%8"
name|IVdf
literal|" free:"
argument_list|,
name|buffer
operator|.
name|totfree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_EVEN_REPORT
init|;
name|i
operator|<=
name|buffer
operator|.
name|topbucket
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5"
name|UVuf
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3"
name|UVuf
else|:
literal|" %"
name|UVuf
operator|)
operator|)
argument_list|,
name|buffer
operator|.
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\n\t   "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
operator|+
literal|1
init|;
name|i
operator|<=
name|buffer
operator|.
name|topbucket_odd
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5"
name|UVuf
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3"
name|UVuf
else|:
literal|" %"
name|UVuf
operator|)
operator|)
argument_list|,
name|buffer
operator|.
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\n%8"
name|IVdf
literal|" used:"
argument_list|,
name|buffer
operator|.
name|total
operator|-
name|buffer
operator|.
name|totfree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_EVEN_REPORT
init|;
name|i
operator|<=
name|buffer
operator|.
name|topbucket
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5"
name|IVdf
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3"
name|IVdf
else|:
literal|" %"
name|IVdf
operator|)
operator|)
argument_list|,
name|buffer
operator|.
name|ntotal
index|[
name|i
index|]
operator|-
name|buffer
operator|.
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BUCKETS_ROOT2
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\n\t   "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_BUCKET
operator|+
literal|1
init|;
name|i
operator|<=
name|buffer
operator|.
name|topbucket_odd
condition|;
name|i
operator|+=
name|BUCKETS_PER_POW2
control|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
operator|(
operator|(
name|i
operator|<
literal|8
operator|*
name|BUCKETS_PER_POW2
operator|||
name|i
operator|==
literal|10
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %5"
name|IVdf
else|:
operator|(
operator|(
name|i
operator|<
literal|12
operator|*
name|BUCKETS_PER_POW2
operator|)
condition|?
literal|" %3"
name|IVdf
else|:
literal|" %"
name|IVdf
operator|)
operator|)
argument_list|,
name|buffer
operator|.
name|ntotal
index|[
name|i
index|]
operator|-
name|buffer
operator|.
name|nfree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\nTotal sbrk(): %"
name|IVdf
literal|"/%"
name|IVdf
literal|":%"
name|IVdf
literal|". Odd ends: pad+heads+chain+tail: %"
name|IVdf
literal|"+%"
name|IVdf
literal|"+%"
name|IVdf
literal|"+%"
name|IVdf
literal|".\n"
argument_list|,
name|buffer
operator|.
name|total_sbrk
argument_list|,
name|buffer
operator|.
name|sbrks
argument_list|,
name|buffer
operator|.
name|sbrk_good
argument_list|,
name|buffer
operator|.
name|sbrk_slack
argument_list|,
name|buffer
operator|.
name|start_slack
argument_list|,
name|buffer
operator|.
name|total_chain
argument_list|,
name|buffer
operator|.
name|sbrked_remains
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING_MSTATS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PERL_SBRK
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MACHTEN_PPC__
argument_list|)
operator|||
name|defined
argument_list|(
name|NeXT
argument_list|)
operator|||
name|defined
argument_list|(
name|__NeXT__
argument_list|)
operator|||
name|defined
argument_list|(
name|PURIFY
argument_list|)
end_if

begin_define
define|#
directive|define
name|PERL_SBRK_VIA_MALLOC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_SBRK_VIA_MALLOC
end_ifdef

begin_comment
comment|/* it may seem schizophrenic to use perl's malloc and let it call system */
end_comment

begin_comment
comment|/* malloc, the reason for that is only the 3.2 version of the OS that had */
end_comment

begin_comment
comment|/* frequent core dumps within nxzonefreenolock. This sbrk routine put an */
end_comment

begin_comment
comment|/* end to the cores */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSTEM_ALLOC
end_ifndef

begin_define
define|#
directive|define
name|SYSTEM_ALLOC
parameter_list|(
name|a
parameter_list|)
value|malloc(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSTEM_ALLOC_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|SYSTEM_ALLOC_ALIGNMENT
value|MEM_ALIGNBYTES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_SBRK_VIA_MALLOC */
end_comment

begin_decl_stmt
specifier|static
name|IV
name|Perl_sbrk_oldchunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|Perl_sbrk_oldsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PERLSBRK_32_K
value|(1<<15)
end_define

begin_define
define|#
directive|define
name|PERLSBRK_64_K
value|(1<<16)
end_define

begin_function
name|Malloc_t
name|Perl_sbrk
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|IV
name|got
decl_stmt|;
name|int
name|small
decl_stmt|,
name|reqsize
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|PERL_CORE
name|reqsize
operator|=
name|size
expr_stmt|;
comment|/* just for the DEBUG_m statement */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PACK_MALLOC
name|size
operator|=
operator|(
name|size
operator|+
literal|0x7ff
operator|)
operator|&
operator|~
literal|0x7ff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|<=
name|Perl_sbrk_oldsize
condition|)
block|{
name|got
operator|=
name|Perl_sbrk_oldchunk
expr_stmt|;
name|Perl_sbrk_oldchunk
operator|+=
name|size
expr_stmt|;
name|Perl_sbrk_oldsize
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|>=
name|PERLSBRK_32_K
condition|)
block|{
name|small
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|PERLSBRK_64_K
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|NEEDED_ALIGNMENT
operator|>
name|SYSTEM_ALLOC_ALIGNMENT
name|size
operator|+=
name|NEEDED_ALIGNMENT
operator|-
name|SYSTEM_ALLOC_ALIGNMENT
expr_stmt|;
endif|#
directive|endif
name|got
operator|=
operator|(
name|IV
operator|)
name|SYSTEM_ALLOC
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|NEEDED_ALIGNMENT
operator|>
name|SYSTEM_ALLOC_ALIGNMENT
name|got
operator|=
operator|(
name|got
operator|+
name|NEEDED_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|NEEDED_ALIGNMENT
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|small
condition|)
block|{
comment|/* Chunk is small, register the rest for future allocs. */
name|Perl_sbrk_oldchunk
operator|=
name|got
operator|+
name|reqsize
expr_stmt|;
name|Perl_sbrk_oldsize
operator|=
name|size
operator|-
name|reqsize
expr_stmt|;
block|}
block|}
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"sbrk malloc size %ld (reqsize %ld), left size %ld, give addr 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|size
argument_list|,
name|reqsize
argument_list|,
name|Perl_sbrk_oldsize
argument_list|,
name|PTR2UV
argument_list|(
name|got
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|got
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined USE_PERL_SBRK */
end_comment

end_unit

