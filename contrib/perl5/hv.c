begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    hv.c  *  *    Copyright (c) 1991-2000, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "I sit beside the fire and think of all that I have seen."  --Bilbo  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_HV_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_function
name|STATIC
name|HE
modifier|*
name|S_new_he
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|HE
modifier|*
name|he
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_he_root
condition|)
name|more_he
argument_list|()
expr_stmt|;
name|he
operator|=
name|PL_he_root
expr_stmt|;
name|PL_he_root
operator|=
name|HeNEXT
argument_list|(
name|he
argument_list|)
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|he
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_del_he
parameter_list|(
name|pTHX_
name|HE
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|HeNEXT
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|HE
operator|*
operator|)
name|PL_he_root
expr_stmt|;
name|PL_he_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_more_he
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
name|he
decl_stmt|;
specifier|register
name|HE
modifier|*
name|heend
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|PL_he_root
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|HE
argument_list|)
argument_list|,
name|HE
argument_list|)
expr_stmt|;
name|he
operator|=
name|PL_he_root
expr_stmt|;
name|heend
operator|=
operator|&
name|he
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|HE
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|he
operator|<
name|heend
condition|)
block|{
name|HeNEXT
argument_list|(
name|he
argument_list|)
operator|=
operator|(
name|HE
operator|*
operator|)
operator|(
name|he
operator|+
literal|1
operator|)
expr_stmt|;
name|he
operator|++
expr_stmt|;
block|}
name|HeNEXT
argument_list|(
name|he
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_HE
parameter_list|()
value|(HE*)safemalloc(sizeof(HE))
end_define

begin_define
define|#
directive|define
name|del_HE
parameter_list|(
name|p
parameter_list|)
value|safefree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|new_HE
parameter_list|()
value|new_he()
end_define

begin_define
define|#
directive|define
name|del_HE
parameter_list|(
name|p
parameter_list|)
value|del_he(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|HEK
modifier|*
name|S_save_hek
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|char
modifier|*
name|k
decl_stmt|;
specifier|register
name|HEK
modifier|*
name|hek
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|hek
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
name|Copy
argument_list|(
name|str
argument_list|,
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|*
operator|(
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|HEK_LEN
argument_list|(
name|hek
argument_list|)
operator|=
name|len
expr_stmt|;
name|HEK_HASH
argument_list|(
name|hek
argument_list|)
operator|=
name|hash
expr_stmt|;
return|return
name|hek
return|;
block|}
end_function

begin_function
name|void
name|Perl_unshare_hek
parameter_list|(
name|pTHX_
name|HEK
modifier|*
name|hek
parameter_list|)
block|{
name|unsharepvn
argument_list|(
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
argument_list|,
name|HEK_LEN
argument_list|(
name|hek
argument_list|)
argument_list|,
name|HEK_HASH
argument_list|(
name|hek
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
end_if

begin_function
name|HE
modifier|*
name|Perl_he_dup
parameter_list|(
name|pTHX_
name|HE
modifier|*
name|e
parameter_list|,
name|bool
name|shared
parameter_list|)
block|{
name|HE
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|Nullhe
return|;
comment|/* look for it in the table first */
name|ret
operator|=
operator|(
name|HE
operator|*
operator|)
name|ptr_table_fetch
argument_list|(
name|PL_ptr_table
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* create anew and remember what it is */
name|ret
operator|=
name|new_HE
argument_list|()
expr_stmt|;
name|ptr_table_store
argument_list|(
name|PL_ptr_table
argument_list|,
name|e
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|HeNEXT
argument_list|(
name|ret
argument_list|)
operator|=
name|he_dup
argument_list|(
name|HeNEXT
argument_list|(
name|e
argument_list|)
argument_list|,
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|HeKLEN
argument_list|(
name|e
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
name|HeKEY_sv
argument_list|(
name|ret
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv_dup
argument_list|(
name|HeKEY_sv
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shared
condition|)
name|HeKEY_hek
argument_list|(
name|ret
argument_list|)
operator|=
name|share_hek
argument_list|(
name|HeKEY
argument_list|(
name|e
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|e
argument_list|)
argument_list|,
name|HeHASH
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|HeKEY_hek
argument_list|(
name|ret
argument_list|)
operator|=
name|save_hek
argument_list|(
name|HeKEY
argument_list|(
name|e
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|e
argument_list|)
argument_list|,
name|HeHASH
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|ret
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv_dup
argument_list|(
name|HeVAL
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ITHREADS */
end_comment

begin_comment
comment|/* (klen == HEf_SVKEY) is special for MAGICAL hv entries, meaning key slot  * contains an SV* */
end_comment

begin_comment
comment|/* =for apidoc hv_fetch  Returns the SV which corresponds to the specified key in the hash.  The C<klen> is the length of the key.  If C<lval> is set then the fetch will be part of a store.  Check that the return value is non-null before dereferencing it to a C<SV*>.   See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied hashes.  =cut */
end_comment

begin_function
name|SV
modifier|*
modifier|*
name|Perl_hv_fetch
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|I32
name|lval
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|PL_hv_fetch_sv
operator|=
name|sv
expr_stmt|;
return|return
operator|&
name|PL_hv_fetch_sv
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|key
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|nkey
init|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ret
init|=
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|nkey
argument_list|,
name|klen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|lval
condition|)
name|ret
operator|=
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
block|{
if|if
condition|(
name|lval
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* if it's an %ENV lookup, we may get it on the fly */
operator|||
operator|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|Newz
argument_list|(
literal|503
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* %ENV lookup?  If so, try to fetch the value now */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|PerlEnv_ENVgetenv_len
argument_list|(
name|key
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|sv
operator|=
name|newSVpvn
argument_list|(
name|env
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lval
condition|)
block|{
comment|/* gonna assign to this, so it better be there */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* returns a HE * structure with the all fields set */
end_comment

begin_comment
comment|/* note that hent_val will be a mortal sv for MAGICAL hashes */
end_comment

begin_comment
comment|/* =for apidoc hv_fetch_ent  Returns the hash entry which corresponds to the specified key in the hash. C<hash> must be a valid precomputed hash number for the given C<key>, or 0 if you want the function to compute it.  IF C<lval> is set then the fetch will be part of a store.  Make sure the return value is non-null before accessing it.  The return value when C<tb> is a tied hash is a pointer to a static location, so be sure to make a copy of the structure if you need to store it somewhere.   See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied hashes.  =cut */
end_comment

begin_function
name|HE
modifier|*
name|Perl_hv_fetch_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|lval
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
condition|)
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
block|}
name|HeSVKEY_set
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|,
name|keysv
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
operator|=
name|sv
expr_stmt|;
return|return
operator|&
name|PL_hv_fetch_ent_mh
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|key
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|nkeysv
init|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|nkeysv
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|nkeysv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|&&
name|lval
condition|)
name|entry
operator|=
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
block|{
if|if
condition|(
name|lval
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* if it's an %ENV lookup, we may get it on the fly */
operator|||
operator|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|Newz
argument_list|(
literal|503
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|entry
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* %ENV lookup?  If so, try to fetch the value now */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|PerlEnv_ENVgetenv_len
argument_list|(
name|key
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|sv
operator|=
name|newSVpvn
argument_list|(
name|env
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lval
condition|)
block|{
comment|/* gonna assign to this, so it better be there */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_hv_magic_check
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|bool
modifier|*
name|needs_copy
parameter_list|,
name|bool
modifier|*
name|needs_store
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|SvMAGIC
argument_list|(
name|hv
argument_list|)
decl_stmt|;
operator|*
name|needs_copy
operator|=
name|FALSE
expr_stmt|;
operator|*
name|needs_store
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|mg
condition|)
block|{
if|if
condition|(
name|isUPPER
argument_list|(
name|mg
operator|->
name|mg_type
argument_list|)
condition|)
block|{
operator|*
name|needs_copy
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|mg
operator|->
name|mg_type
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'S'
case|:
operator|*
name|needs_store
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|mg
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc hv_store  Stores an SV in a hash.  The hash key is specified as C<key> and C<klen> is the length of the key.  The C<hash> parameter is the precomputed hash value; if it is zero then Perl will compute it.  The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes).  Otherwise it can be dereferenced to get the original C<SV*>.  Note that the caller is responsible for suitably incrementing the reference count of C<val> before the call, and decrementing it if the function returned NULL.    See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied hashes.  =cut */
end_comment

begin_function
name|SV
modifier|*
modifier|*
name|Perl_hv_store
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
condition|)
block|{
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|val
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
operator|&&
operator|!
name|needs_store
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
decl_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|505
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
name|entry
operator|=
name|new_HE
argument_list|()
expr_stmt|;
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|share_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
else|else
comment|/* gotta do the real thing */
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_store_ent  Stores C<val> in a hash.  The hash key is specified as C<key>.  The C<hash> parameter is the precomputed hash value; if it is zero then Perl will compute it.  The return value is the new hash entry so created.  It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes).  Otherwise the contents of the return value can be accessed using the C<He???> macros described here.  Note that the caller is responsible for suitably incrementing the reference count of C<val> before the call, and decrementing it if the function returned NULL.   See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for more information on how to use this function on tied hashes.  =cut */
end_comment

begin_function
name|HE
modifier|*
name|Perl_hv_store_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
condition|)
block|{
name|bool
name|save_taint
init|=
name|PL_tainted
decl_stmt|;
if|if
condition|(
name|PL_tainting
condition|)
name|PL_tainted
operator|=
name|SvTAINTED
argument_list|(
name|keysv
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|save_taint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
operator|&&
operator|!
name|needs_store
condition|)
return|return
name|Nullhe
return|;
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|505
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|new_HE
argument_list|()
expr_stmt|;
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|share_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
else|else
comment|/* gotta do the real thing */
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_delete  Deletes a key/value pair in the hash.  The value SV is removed from the hash and returned to the caller.  The C<klen> is the length of the key.  The C<flags> value will normally be zero; if set to G_DISCARD then NULL will be returned.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_hv_delete
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
operator|&&
operator|(
name|svp
operator|=
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
name|sv
operator|=
operator|*
name|svp
expr_stmt|;
name|mg_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_store
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
comment|/* No longer an element */
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
comment|/* element cannot be deleted */
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
name|Nullsv
return|;
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
name|sv
operator|=
name|Nullsv
expr_stmt|;
else|else
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|xhv
operator|->
name|xhv_eiter
condition|)
name|HvLAZYDEL_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
else|else
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_delete_ent  Deletes a key/value pair in the hash.  The value SV is removed from the hash and returned to the caller.  The C<flags> value will normally be zero; if set to G_DISCARD then NULL will be returned.  C<hash> can be a valid precomputed hash value, or 0 to ask for it to be computed.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_hv_delete_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|flags
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
operator|&&
operator|(
name|entry
operator|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|TRUE
argument_list|,
name|hash
argument_list|)
operator|)
condition|)
block|{
name|sv
operator|=
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|mg_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_store
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
comment|/* No longer an element */
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
comment|/* element cannot be deleted */
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
name|Nullsv
return|;
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
name|sv
operator|=
name|Nullsv
expr_stmt|;
else|else
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|==
name|xhv
operator|->
name|xhv_eiter
condition|)
name|HvLAZYDEL_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
else|else
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_exists  Returns a boolean indicating whether the specified hash key exists.  The C<klen> is the length of the key.  =cut */
end_comment

begin_function
name|bool
name|Perl_hv_exists
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|magic_existspack
argument_list|(
name|sv
argument_list|,
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvTRUE
argument_list|(
name|sv
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DYNAMIC_ENV_FETCH
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|entry
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|TRUE
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* is it out there? */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|PerlEnv_ENVgetenv_len
argument_list|(
name|key
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|sv
operator|=
name|newSVpvn
argument_list|(
name|env
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_exists_ent  Returns a boolean indicating whether the specified hash key exists. C<hash> can be a valid precomputed hash value, or 0 to ask for it to be computed.  =cut */
end_comment

begin_function
name|bool
name|Perl_hv_exists_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
comment|/* just for SvTRUE */
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
name|magic_existspack
argument_list|(
name|sv
argument_list|,
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvTRUE
argument_list|(
name|sv
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DYNAMIC_ENV_FETCH
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|entry
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|TRUE
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* is it out there? */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|PerlEnv_ENVgetenv_len
argument_list|(
name|key
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|sv
operator|=
name|newSVpvn
argument_list|(
name|env
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_hsplit
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
decl_stmt|;
name|I32
name|oldsize
init|=
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
decl_stmt|;
comment|/* sic(k) */
specifier|register
name|I32
name|newsize
init|=
name|oldsize
operator|*
literal|2
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
init|=
name|xhv
operator|->
name|xhv_array
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|aep
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|bep
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|PL_nomemok
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
name|Renew
argument_list|(
name|a
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
else|#
directive|else
define|#
directive|define
name|MALLOC_OVERHEAD
value|16
name|New
argument_list|(
literal|2
argument_list|,
name|a
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|Copy
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|a
argument_list|,
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|>=
literal|64
condition|)
block|{
name|offer_nice_chunk
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|oldsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|a
index|[
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
index|]
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* zero 2nd half*/
name|xhv
operator|->
name|xhv_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|xhv
operator|->
name|xhv_array
operator|=
name|a
expr_stmt|;
name|aep
operator|=
operator|(
name|HE
operator|*
operator|*
operator|)
name|a
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|aep
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* non-existent */
continue|continue;
name|bep
operator|=
name|aep
operator|+
name|oldsize
expr_stmt|;
for|for
control|(
name|oentry
operator|=
name|aep
operator|,
name|entry
operator|=
operator|*
name|aep
init|;
name|entry
condition|;
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
operator|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|&
name|newsize
operator|)
operator|!=
name|i
condition|)
block|{
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|bep
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bep
condition|)
name|xhv
operator|->
name|xhv_fill
operator|++
expr_stmt|;
operator|*
name|bep
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
else|else
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* everything moved */
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_hv_ksplit
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|IV
name|newmax
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
decl_stmt|;
name|I32
name|oldsize
init|=
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
decl_stmt|;
comment|/* sic(k) */
specifier|register
name|I32
name|newsize
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|aep
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|newsize
operator|=
operator|(
name|I32
operator|)
name|newmax
expr_stmt|;
comment|/* possible truncation here */
if|if
condition|(
name|newsize
operator|!=
name|newmax
operator|||
name|newmax
operator|<=
name|oldsize
condition|)
return|return;
while|while
condition|(
operator|(
name|newsize
operator|&
operator|(
literal|1
operator|+
operator|~
name|newsize
operator|)
operator|)
operator|!=
name|newsize
condition|)
block|{
name|newsize
operator|&=
operator|~
operator|(
name|newsize
operator|&
operator|(
literal|1
operator|+
operator|~
name|newsize
operator|)
operator|)
expr_stmt|;
comment|/* get proper power of 2 */
block|}
if|if
condition|(
name|newsize
operator|<
name|newmax
condition|)
name|newsize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
name|newmax
condition|)
return|return;
comment|/* overflow detection */
name|a
operator|=
name|xhv
operator|->
name|xhv_array
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
name|Renew
argument_list|(
name|a
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|New
argument_list|(
literal|2
argument_list|,
name|a
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|Copy
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|a
argument_list|,
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|>=
literal|64
condition|)
block|{
name|offer_nice_chunk
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|oldsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|a
index|[
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
index|]
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* zero 2nd half*/
block|}
else|else
block|{
name|Newz
argument_list|(
literal|0
argument_list|,
name|a
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|xhv
operator|->
name|xhv_array
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_fill
condition|)
comment|/* skip rest if no entries */
return|return;
name|aep
operator|=
operator|(
name|HE
operator|*
operator|*
operator|)
name|a
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|aep
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* non-existent */
continue|continue;
for|for
control|(
name|oentry
operator|=
name|aep
operator|,
name|entry
operator|=
operator|*
name|aep
init|;
name|entry
condition|;
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|&
name|newsize
operator|)
operator|)
operator|!=
name|i
condition|)
block|{
name|j
operator|-=
name|i
expr_stmt|;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
name|aep
index|[
name|j
index|]
operator|)
condition|)
name|xhv
operator|->
name|xhv_fill
operator|++
expr_stmt|;
name|aep
index|[
name|j
index|]
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
else|else
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* everything moved */
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc newHV  Creates a new HV.  The reference count is set to 1.  =cut */
end_comment

begin_function
name|HV
modifier|*
name|Perl_newHV
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|HV
modifier|*
name|hv
decl_stmt|;
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|502
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvPOK_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvNOK_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NODEFAULT_SHAREKEYS
name|HvSHAREKEYS_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* key-sharing on by default */
endif|#
directive|endif
name|xhv
operator|->
name|xhv_max
operator|=
literal|7
expr_stmt|;
comment|/* start with 8 buckets */
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_pmroot
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|hv_iterinit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* so each() will start off right */
return|return
name|hv
return|;
block|}
end_function

begin_function
name|HV
modifier|*
name|Perl_newHVhv
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|ohv
parameter_list|)
block|{
specifier|register
name|HV
modifier|*
name|hv
decl_stmt|;
name|STRLEN
name|hv_max
init|=
name|ohv
condition|?
name|HvMAX
argument_list|(
name|ohv
argument_list|)
else|:
literal|0
decl_stmt|;
name|STRLEN
name|hv_fill
init|=
name|ohv
condition|?
name|HvFILL
argument_list|(
name|ohv
argument_list|)
else|:
literal|0
decl_stmt|;
name|hv
operator|=
name|newHV
argument_list|()
expr_stmt|;
while|while
condition|(
name|hv_max
operator|&&
name|hv_max
operator|+
literal|1
operator|>=
name|hv_fill
operator|*
literal|2
condition|)
name|hv_max
operator|=
name|hv_max
operator|/
literal|2
expr_stmt|;
comment|/* Is always 2^n-1 */
name|HvMAX
argument_list|(
name|hv
argument_list|)
operator|=
name|hv_max
expr_stmt|;
if|if
condition|(
operator|!
name|hv_fill
condition|)
return|return
name|hv
return|;
if|#
directive|if
literal|0
block|if (! SvTIED_mg((SV*)ohv, 'P')) {
comment|/* Quick way ???*/
block|}      else
endif|#
directive|endif
block|{
name|HE
modifier|*
name|entry
decl_stmt|;
name|I32
name|hv_riter
init|=
name|HvRITER
argument_list|(
name|ohv
argument_list|)
decl_stmt|;
comment|/* current root of iterator */
name|HE
modifier|*
name|hv_eiter
init|=
name|HvEITER
argument_list|(
name|ohv
argument_list|)
decl_stmt|;
comment|/* current entry of iterator */
comment|/* Slow way */
name|hv_iterinit
argument_list|(
name|ohv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|hv_iternext
argument_list|(
name|ohv
argument_list|)
operator|)
condition|)
block|{
name|hv_store
argument_list|(
name|hv
argument_list|,
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|,
name|HeHASH
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HvRITER
argument_list|(
name|ohv
argument_list|)
operator|=
name|hv_riter
expr_stmt|;
name|HvEITER
argument_list|(
name|ohv
argument_list|)
operator|=
name|hv_eiter
expr_stmt|;
block|}
return|return
name|hv
return|;
block|}
end_function

begin_function
name|void
name|Perl_hv_free_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
name|SV
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
name|val
operator|=
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|isGV
argument_list|(
name|val
argument_list|)
operator|&&
name|GvCVu
argument_list|(
name|val
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
name|PL_sub_generation
operator|++
expr_stmt|;
comment|/* may be deletion of method from stash */
name|SvREFCNT_dec
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|unshare_hek
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_HE
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_hv_delayfree_ent
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
if|if
condition|(
name|isGV
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|GvCVu
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
name|PL_sub_generation
operator|++
expr_stmt|;
comment|/* may be deletion of method from stash */
name|sv_2mortal
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* free between statements */
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|sv_2mortal
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|unshare_hek
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_HE
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_clear  Clears a hash, making it empty.  =cut */
end_comment

begin_function
name|void
name|Perl_hv_clear
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hfreeentries
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_array
condition|)
operator|(
name|void
operator|)
name|memzero
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
operator|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
name|mg_clear
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_hfreeentries
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
name|oentry
init|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
decl_stmt|;
name|I32
name|riter
decl_stmt|;
name|I32
name|max
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
if|if
condition|(
operator|!
name|HvARRAY
argument_list|(
name|hv
argument_list|)
condition|)
return|return;
name|riter
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|HvMAX
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|array
operator|=
name|HvARRAY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|entry
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|entry
condition|)
block|{
name|oentry
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|oentry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
operator|++
name|riter
operator|>
name|max
condition|)
break|break;
name|entry
operator|=
name|array
index|[
name|riter
index|]
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|hv_iterinit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_undef  Undefines the hash.  =cut */
end_comment

begin_function
name|void
name|Perl_hv_undef
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hfreeentries
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|Safefree
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|)
expr_stmt|;
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_array
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_max
operator|=
literal|7
expr_stmt|;
comment|/* it's a normal hash */
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
name|mg_clear
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_iterinit  Prepares a starting point to traverse a hash table.  Returns the number of keys in the hash (i.e. the same as C<HvKEYS(tb)>).  The return value is currently only meaningful for hashes without tie magic.   NOTE: Before version 5.004_65, C<hv_iterinit> used to return the number of hash buckets that happen to be in use.  If you still need that esoteric value, you can get it through the macro C<HvFILL(tb)>.  =cut */
end_comment

begin_function
name|I32
name|Perl_hv_iterinit
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
name|HE
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad hash"
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|entry
operator|=
name|xhv
operator|->
name|xhv_eiter
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|HvLAZYDEL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
comment|/* was deleted earlier? */
name|HvLAZYDEL_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_riter
operator|=
operator|-
literal|1
expr_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
return|return
name|xhv
operator|->
name|xhv_keys
return|;
comment|/* used to be xhv->xhv_fill before 5.004_65 */
block|}
end_function

begin_comment
comment|/* =for apidoc hv_iternext  Returns entries from a hash iterator.  See C<hv_iterinit>.  =cut */
end_comment

begin_function
name|HE
modifier|*
name|Perl_hv_iternext
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|HE
modifier|*
name|oldentry
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad hash"
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|oldentry
operator|=
name|entry
operator|=
name|xhv
operator|->
name|xhv_eiter
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|key
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|sv_setsv
argument_list|(
name|key
argument_list|,
name|HeSVKEY_force
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|HeSVKEY
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get rid of previous key */
block|}
else|else
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|HEK
modifier|*
name|hek
decl_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|entry
operator|=
name|new_HE
argument_list|()
expr_stmt|;
comment|/* one HE per MAGICAL hash */
name|Zero
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|,
name|HE
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|hek
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|hek
expr_stmt|;
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|=
name|HEf_SVKEY
expr_stmt|;
block|}
name|magic_nextpack
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|mg
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|/* force key to stay around until next time */
name|HeSVKEY_set
argument_list|(
name|entry
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
comment|/* beware, hent_val is not set */
block|}
if|if
condition|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_HE
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
return|return
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* set up %ENV for iteration */
if|if
condition|(
operator|!
name|entry
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
name|prime_env_iter
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|506
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|PERL_HV_ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|entry
condition|)
block|{
operator|++
name|xhv
operator|->
name|xhv_riter
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_riter
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
block|{
name|xhv
operator|->
name|xhv_riter
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|xhv
operator|->
name|xhv_riter
index|]
expr_stmt|;
block|}
if|if
condition|(
name|oldentry
operator|&&
name|HvLAZYDEL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
comment|/* was deleted earlier? */
name|HvLAZYDEL_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|oldentry
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_eiter
operator|=
name|entry
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_iterkey  Returns the key from the current position of the hash iterator.  See C<hv_iterinit>.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_hv_iterkey
parameter_list|(
name|pTHX_
specifier|register
name|HE
modifier|*
name|entry
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|SvPV
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
operator|*
name|retlen
operator|=
name|HeKLEN
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|HeKEY
argument_list|(
name|entry
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* unlike hv_iterval(), this always returns a mortal copy of the key */
end_comment

begin_comment
comment|/* =for apidoc hv_iterkeysv  Returns the key as an C<SV*> from the current position of the hash iterator.  The return value will always be a mortal copy of the key.  Also see C<hv_iterinit>.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_hv_iterkeysv
parameter_list|(
name|pTHX_
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
return|return
name|sv_mortalcopy
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
else|else
return|return
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
operator|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
condition|?
name|HeKEY
argument_list|(
name|entry
argument_list|)
else|:
literal|""
operator|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_iterval  Returns the value from the current position of the hash iterator.  See C<hv_iterkey>.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_hv_iterval
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
else|else
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
block|}
return|return
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_iternextsv  Performs an C<hv_iternext>, C<hv_iterkey>, and C<hv_iterval> in one operation.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_hv_iternextsv
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
name|HE
modifier|*
name|he
decl_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|hv_iternext
argument_list|(
name|hv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|key
operator|=
name|hv_iterkey
argument_list|(
name|he
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
return|return
name|hv_iterval
argument_list|(
name|hv
argument_list|,
name|he
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc hv_magic  Adds magic to a hash.  See C<sv_magic>.  =cut */
end_comment

begin_function
name|void
name|Perl_hv_magic
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|hv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|how
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_sharepvn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sv
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
return|return
name|HEK_KEY
argument_list|(
name|share_hek
argument_list|(
name|sv
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* possibly free a shared string if no one has access to it  * len and hash must both be valid for str.  */
end_comment

begin_function
name|void
name|Perl_unsharepvn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|1
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
comment|/* what follows is the moral equivalent of:     if ((Svp = hv_fetch(PL_strtab, tmpsv, FALSE, hash))) { 	if (--*Svp == Nullsv) 	    hv_delete(PL_strtab, str, len, G_DISCARD, hash);     } */
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* assert(xhv_array != 0) */
name|LOCK_STRTAB_MUTEX
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|len
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|==
name|Nullsv
condition|)
block|{
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_HE
argument_list|(
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
block|}
break|break;
block|}
name|UNLOCK_STRTAB_MUTEX
expr_stmt|;
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Attempt to free non-existent shared string"
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get a (constant) string ptr from the global string table  * string will get added if it is not already there.  * len and hash must both be valid for str.  */
end_comment

begin_function
name|HEK
modifier|*
name|Perl_share_hek
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|1
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
comment|/* what follows is the moral equivalent of:             if (!(Svp = hv_fetch(PL_strtab, str, len, FALSE)))     	hv_store(PL_strtab, str, len, Nullsv, hash);     */
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* assert(xhv_array != 0) */
name|LOCK_STRTAB_MUTEX
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|len
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|entry
operator|=
name|new_HE
argument_list|()
expr_stmt|;
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|Nullsv
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* use value slot as REFCNT */
name|UNLOCK_STRTAB_MUTEX
expr_stmt|;
return|return
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

end_unit

