begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    hv.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "I sit beside the fire and think of all that I have seen."  --Bilbo  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|hv_magic_check
name|_
argument_list|(
operator|(
name|HV
operator|*
name|hv
operator|,
name|bool
operator|*
name|needs_copy
operator|,
name|bool
operator|*
name|needs_store
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|hsplit
name|_
argument_list|(
operator|(
name|HV
operator|*
name|hv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hfreeentries
name|_
argument_list|(
operator|(
name|HV
operator|*
name|hv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|more_he
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
end_if

begin_define
define|#
directive|define
name|ARRAY_ALLOC_BYTES
parameter_list|(
name|size
parameter_list|)
value|( (size)*sizeof(HE*) )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MALLOC_OVERHEAD
value|16
end_define

begin_define
define|#
directive|define
name|ARRAY_ALLOC_BYTES
parameter_list|(
name|size
parameter_list|)
value|( (size)*sizeof(HE*)*2 - MALLOC_OVERHEAD )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|HE
modifier|*
name|new_he
parameter_list|(
name|void
parameter_list|)
block|{
name|HE
modifier|*
name|he
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_he_root
condition|)
name|more_he
argument_list|()
expr_stmt|;
name|he
operator|=
name|PL_he_root
expr_stmt|;
name|PL_he_root
operator|=
name|HeNEXT
argument_list|(
name|he
argument_list|)
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|he
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|del_he
parameter_list|(
name|HE
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|HeNEXT
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|HE
operator|*
operator|)
name|PL_he_root
expr_stmt|;
name|PL_he_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|more_he
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
name|he
decl_stmt|;
specifier|register
name|HE
modifier|*
name|heend
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|PL_he_root
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|HE
argument_list|)
argument_list|,
name|HE
argument_list|)
expr_stmt|;
name|he
operator|=
name|PL_he_root
expr_stmt|;
name|heend
operator|=
operator|&
name|he
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|HE
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|he
operator|<
name|heend
condition|)
block|{
name|HeNEXT
argument_list|(
name|he
argument_list|)
operator|=
operator|(
name|HE
operator|*
operator|)
operator|(
name|he
operator|+
literal|1
operator|)
expr_stmt|;
name|he
operator|++
expr_stmt|;
block|}
name|HeNEXT
argument_list|(
name|he
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|HEK
modifier|*
name|save_hek
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|char
modifier|*
name|k
decl_stmt|;
specifier|register
name|HEK
modifier|*
name|hek
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|hek
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
name|Copy
argument_list|(
name|str
argument_list|,
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|*
operator|(
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|HEK_LEN
argument_list|(
name|hek
argument_list|)
operator|=
name|len
expr_stmt|;
name|HEK_HASH
argument_list|(
name|hek
argument_list|)
operator|=
name|hash
expr_stmt|;
return|return
name|hek
return|;
block|}
end_function

begin_function
name|void
name|unshare_hek
parameter_list|(
name|HEK
modifier|*
name|hek
parameter_list|)
block|{
name|unsharepvn
argument_list|(
name|HEK_KEY
argument_list|(
name|hek
argument_list|)
argument_list|,
name|HEK_LEN
argument_list|(
name|hek
argument_list|)
argument_list|,
name|HEK_HASH
argument_list|(
name|hek
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* (klen == HEf_SVKEY) is special for MAGICAL hv entries, meaning key slot  * contains an SV* */
end_comment

begin_function
name|SV
modifier|*
modifier|*
name|hv_fetch
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|I32
name|lval
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|PL_hv_fetch_sv
operator|=
name|sv
expr_stmt|;
return|return
operator|&
name|PL_hv_fetch_sv
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|key
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|nkey
init|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ret
init|=
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|nkey
argument_list|,
name|klen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|lval
condition|)
name|ret
operator|=
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
block|{
if|if
condition|(
name|lval
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* if it's an %ENV lookup, we may get it on the fly */
operator|||
operator|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|Newz
argument_list|(
literal|503
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* %ENV lookup?  If so, try to fetch the value now */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|char
modifier|*
name|gotenv
decl_stmt|;
if|if
condition|(
operator|(
name|gotenv
operator|=
name|PerlEnv_getenv
argument_list|(
name|key
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|sv
operator|=
name|newSVpv
argument_list|(
name|gotenv
argument_list|,
name|strlen
argument_list|(
name|gotenv
argument_list|)
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lval
condition|)
block|{
comment|/* gonna assign to this, so it better be there */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hv_store
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* returns a HE * structure with the all fields set */
end_comment

begin_comment
comment|/* note that hent_val will be a mortal sv for MAGICAL hashes */
end_comment

begin_function
name|HE
modifier|*
name|hv_fetch_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|lval
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
condition|)
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|New
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
block|}
name|HeSVKEY_set
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|,
name|keysv
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
operator|=
name|sv
expr_stmt|;
return|return
operator|&
name|PL_hv_fetch_ent_mh
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|U32
name|i
decl_stmt|;
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|klen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|key
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|nkeysv
init|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|nkeysv
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|nkeysv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|&&
name|lval
condition|)
name|entry
operator|=
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
block|{
if|if
condition|(
name|lval
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* if it's an %ENV lookup, we may get it on the fly */
operator|||
operator|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|Newz
argument_list|(
literal|503
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|entry
return|;
block|}
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* %ENV lookup?  If so, try to fetch the value now */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
block|{
name|char
modifier|*
name|gotenv
decl_stmt|;
if|if
condition|(
operator|(
name|gotenv
operator|=
name|PerlEnv_getenv
argument_list|(
name|key
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|sv
operator|=
name|newSVpv
argument_list|(
name|gotenv
argument_list|,
name|strlen
argument_list|(
name|gotenv
argument_list|)
argument_list|)
expr_stmt|;
name|SvTAINTED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lval
condition|)
block|{
comment|/* gonna assign to this, so it better be there */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hv_store_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|sv
argument_list|,
name|hash
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hv_magic_check
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|bool
modifier|*
name|needs_copy
parameter_list|,
name|bool
modifier|*
name|needs_store
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|SvMAGIC
argument_list|(
name|hv
argument_list|)
decl_stmt|;
operator|*
name|needs_copy
operator|=
name|FALSE
expr_stmt|;
operator|*
name|needs_store
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|mg
condition|)
block|{
if|if
condition|(
name|isUPPER
argument_list|(
name|mg
operator|->
name|mg_type
argument_list|)
condition|)
block|{
operator|*
name|needs_copy
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|mg
operator|->
name|mg_type
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'S'
case|:
operator|*
name|needs_store
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|mg
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
block|}
block|}
end_function

begin_function
name|SV
modifier|*
modifier|*
name|hv_store
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
condition|)
block|{
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|val
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
operator|&&
operator|!
name|needs_store
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
decl_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|505
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
name|entry
operator|=
name|new_he
argument_list|()
expr_stmt|;
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|share_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
else|else
comment|/* gotta do the real thing */
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
name|HE
modifier|*
name|hv_store_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|SV
modifier|*
name|val
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
condition|)
block|{
name|bool
name|save_taint
init|=
name|PL_tainted
decl_stmt|;
if|if
condition|(
name|PL_tainting
condition|)
name|PL_tainted
operator|=
name|SvTAINTED
argument_list|(
name|keysv
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|save_taint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
operator|&&
operator|!
name|needs_store
condition|)
return|return
name|Nullhe
return|;
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|505
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|new_he
argument_list|()
expr_stmt|;
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|share_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
else|else
comment|/* gotta do the real thing */
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|val
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|hv_delete
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
operator|&&
operator|(
name|svp
operator|=
name|hv_fetch
argument_list|(
name|hv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
name|sv
operator|=
operator|*
name|svp
expr_stmt|;
name|mg_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_store
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
comment|/* No longer an element */
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
comment|/* element cannot be deleted */
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
name|Nullsv
return|;
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
name|sv
operator|=
name|Nullsv
expr_stmt|;
else|else
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|xhv
operator|->
name|xhv_eiter
condition|)
name|HvLAZYDEL_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
else|else
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|hv_delete_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|I32
name|flags
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|bool
name|needs_copy
decl_stmt|;
name|bool
name|needs_store
decl_stmt|;
name|hv_magic_check
argument_list|(
name|hv
argument_list|,
operator|&
name|needs_copy
argument_list|,
operator|&
name|needs_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_copy
operator|&&
operator|(
name|entry
operator|=
name|hv_fetch_ent
argument_list|(
name|hv
argument_list|,
name|keysv
argument_list|,
name|TRUE
argument_list|,
name|hash
argument_list|)
operator|)
condition|)
block|{
name|sv
operator|=
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|mg_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_store
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
condition|)
block|{
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
comment|/* No longer an element */
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
comment|/* element cannot be deleted */
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
name|Nullsv
return|;
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
name|sv
operator|=
name|Nullsv
expr_stmt|;
else|else
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|xhv
operator|->
name|xhv_eiter
condition|)
name|HvLAZYDEL_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
else|else
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
return|return
name|sv
return|;
block|}
return|return
name|Nullsv
return|;
block|}
end_function

begin_function
name|bool
name|hv_exists
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|U32
name|klen
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|U32
name|hash
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|magic_existspack
argument_list|(
name|sv
argument_list|,
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvTRUE
argument_list|(
name|sv
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
literal|0
return|;
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool
name|hv_exists_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|SV
modifier|*
name|keysv
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|klen
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
comment|/* just for SvTRUE */
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|keysv
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
name|magic_existspack
argument_list|(
name|sv
argument_list|,
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvTRUE
argument_list|(
name|sv
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|ENV_IS_CASELESS
elseif|else
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'E'
argument_list|)
condition|)
block|{
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|keysv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strupr
argument_list|(
name|SvPVX
argument_list|(
name|keysv
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
return|return
literal|0
return|;
name|key
operator|=
name|SvPV
argument_list|(
name|keysv
argument_list|,
name|klen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|hsplit
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
decl_stmt|;
name|I32
name|oldsize
init|=
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
decl_stmt|;
comment|/* sic(k) */
specifier|register
name|I32
name|newsize
init|=
name|oldsize
operator|*
literal|2
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
init|=
name|xhv
operator|->
name|xhv_array
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|aep
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|bep
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|PL_nomemok
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
name|Renew
argument_list|(
name|a
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
else|#
directive|else
define|#
directive|define
name|MALLOC_OVERHEAD
value|16
name|New
argument_list|(
literal|2
argument_list|,
name|a
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|Copy
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|a
argument_list|,
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|>=
literal|64
condition|)
block|{
name|offer_nice_chunk
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|oldsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|a
index|[
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
index|]
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* zero 2nd half*/
name|xhv
operator|->
name|xhv_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|xhv
operator|->
name|xhv_array
operator|=
name|a
expr_stmt|;
name|aep
operator|=
operator|(
name|HE
operator|*
operator|*
operator|)
name|a
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|aep
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* non-existent */
continue|continue;
name|bep
operator|=
name|aep
operator|+
name|oldsize
expr_stmt|;
for|for
control|(
name|oentry
operator|=
name|aep
operator|,
name|entry
operator|=
operator|*
name|aep
init|;
name|entry
condition|;
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
operator|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|&
name|newsize
operator|)
operator|!=
name|i
condition|)
block|{
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|bep
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bep
condition|)
name|xhv
operator|->
name|xhv_fill
operator|++
expr_stmt|;
operator|*
name|bep
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
else|else
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* everything moved */
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hv_ksplit
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|IV
name|newmax
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
init|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
decl_stmt|;
name|I32
name|oldsize
init|=
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
decl_stmt|;
comment|/* sic(k) */
specifier|register
name|I32
name|newsize
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|aep
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|newsize
operator|=
operator|(
name|I32
operator|)
name|newmax
expr_stmt|;
comment|/* possible truncation here */
if|if
condition|(
name|newsize
operator|!=
name|newmax
operator|||
name|newmax
operator|<=
name|oldsize
condition|)
return|return;
while|while
condition|(
operator|(
name|newsize
operator|&
operator|(
literal|1
operator|+
operator|~
name|newsize
operator|)
operator|)
operator|!=
name|newsize
condition|)
block|{
name|newsize
operator|&=
operator|~
operator|(
name|newsize
operator|&
operator|(
literal|1
operator|+
operator|~
name|newsize
operator|)
operator|)
expr_stmt|;
comment|/* get proper power of 2 */
block|}
if|if
condition|(
name|newsize
operator|<
name|newmax
condition|)
name|newsize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
name|newmax
condition|)
return|return;
comment|/* overflow detection */
name|a
operator|=
name|xhv
operator|->
name|xhv_array
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STRANGE_MALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
name|Renew
argument_list|(
name|a
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|New
argument_list|(
literal|2
argument_list|,
name|a
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|Copy
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|a
argument_list|,
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|>=
literal|64
condition|)
block|{
name|offer_nice_chunk
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|oldsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_nomemok
operator|=
name|FALSE
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|a
index|[
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
index|]
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* zero 2nd half*/
block|}
else|else
block|{
name|Newz
argument_list|(
literal|0
argument_list|,
name|a
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|newsize
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|xhv
operator|->
name|xhv_array
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_fill
condition|)
comment|/* skip rest if no entries */
return|return;
name|aep
operator|=
operator|(
name|HE
operator|*
operator|*
operator|)
name|a
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|aep
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* non-existent */
continue|continue;
for|for
control|(
name|oentry
operator|=
name|aep
operator|,
name|entry
operator|=
operator|*
name|aep
init|;
name|entry
condition|;
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|&
name|newsize
operator|)
operator|)
operator|!=
name|i
condition|)
block|{
name|j
operator|-=
name|i
expr_stmt|;
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
name|aep
index|[
name|j
index|]
operator|)
condition|)
name|xhv
operator|->
name|xhv_fill
operator|++
expr_stmt|;
name|aep
index|[
name|j
index|]
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
else|else
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|aep
condition|)
comment|/* everything moved */
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HV
modifier|*
name|newHV
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|HV
modifier|*
name|hv
decl_stmt|;
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
name|hv
operator|=
operator|(
name|HV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|502
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvPOK_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvNOK_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NODEFAULT_SHAREKEYS
name|HvSHAREKEYS_on
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* key-sharing on by default */
endif|#
directive|endif
name|xhv
operator|->
name|xhv_max
operator|=
literal|7
expr_stmt|;
comment|/* start with 8 buckets */
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_pmroot
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|hv_iterinit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* so each() will start off right */
return|return
name|hv
return|;
block|}
end_function

begin_function
name|HV
modifier|*
name|newHVhv
parameter_list|(
name|HV
modifier|*
name|ohv
parameter_list|)
block|{
specifier|register
name|HV
modifier|*
name|hv
decl_stmt|;
name|STRLEN
name|hv_max
init|=
name|ohv
condition|?
name|HvMAX
argument_list|(
name|ohv
argument_list|)
else|:
literal|0
decl_stmt|;
name|STRLEN
name|hv_fill
init|=
name|ohv
condition|?
name|HvFILL
argument_list|(
name|ohv
argument_list|)
else|:
literal|0
decl_stmt|;
name|hv
operator|=
name|newHV
argument_list|()
expr_stmt|;
while|while
condition|(
name|hv_max
operator|&&
name|hv_max
operator|+
literal|1
operator|>=
name|hv_fill
operator|*
literal|2
condition|)
name|hv_max
operator|=
name|hv_max
operator|/
literal|2
expr_stmt|;
comment|/* Is always 2^n-1 */
name|HvMAX
argument_list|(
name|hv
argument_list|)
operator|=
name|hv_max
expr_stmt|;
if|if
condition|(
operator|!
name|hv_fill
condition|)
return|return
name|hv
return|;
if|#
directive|if
literal|0
block|if (! SvTIED_mg((SV*)ohv, 'P')) {
comment|/* Quick way ???*/
block|}      else
endif|#
directive|endif
block|{
name|HE
modifier|*
name|entry
decl_stmt|;
name|I32
name|hv_riter
init|=
name|HvRITER
argument_list|(
name|ohv
argument_list|)
decl_stmt|;
comment|/* current root of iterator */
name|HE
modifier|*
name|hv_eiter
init|=
name|HvEITER
argument_list|(
name|ohv
argument_list|)
decl_stmt|;
comment|/* current entry of iterator */
comment|/* Slow way */
name|hv_iterinit
argument_list|(
name|ohv
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|=
name|hv_iternext
argument_list|(
name|ohv
argument_list|)
condition|)
block|{
name|hv_store
argument_list|(
name|hv
argument_list|,
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|,
name|HeHASH
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HvRITER
argument_list|(
name|ohv
argument_list|)
operator|=
name|hv_riter
expr_stmt|;
name|HvEITER
argument_list|(
name|ohv
argument_list|)
operator|=
name|hv_eiter
expr_stmt|;
block|}
return|return
name|hv
return|;
block|}
end_function

begin_function
name|void
name|hv_free_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
name|SV
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
name|val
operator|=
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|isGV
argument_list|(
name|val
argument_list|)
operator|&&
name|GvCVu
argument_list|(
name|val
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
name|PL_sub_generation
operator|++
expr_stmt|;
comment|/* may be deletion of method from stash */
name|SvREFCNT_dec
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|unshare_hek
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_he
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hv_delayfree_ent
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
if|if
condition|(
name|isGV
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|GvCVu
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
name|PL_sub_generation
operator|++
expr_stmt|;
comment|/* may be deletion of method from stash */
name|sv_2mortal
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* free between statements */
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|sv_2mortal
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|hv
argument_list|)
condition|)
name|unshare_hek
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_he
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hv_clear
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hfreeentries
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_array
condition|)
operator|(
name|void
operator|)
name|memzero
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|,
operator|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
name|mg_clear
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|hfreeentries
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
name|oentry
init|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
decl_stmt|;
name|I32
name|riter
decl_stmt|;
name|I32
name|max
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
if|if
condition|(
operator|!
name|HvARRAY
argument_list|(
name|hv
argument_list|)
condition|)
return|return;
name|riter
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|HvMAX
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|array
operator|=
name|HvARRAY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|entry
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|entry
condition|)
block|{
name|oentry
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|oentry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
operator|++
name|riter
operator|>
name|max
condition|)
break|break;
name|entry
operator|=
name|array
index|[
name|riter
index|]
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|hv_iterinit
argument_list|(
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hv_undef
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
return|return;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hfreeentries
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|xhv
operator|->
name|xhv_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
condition|)
block|{
name|Safefree
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|)
expr_stmt|;
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_array
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_max
operator|=
literal|7
expr_stmt|;
comment|/* it's a normal hash */
name|xhv
operator|->
name|xhv_fill
operator|=
literal|0
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
name|mg_clear
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|I32
name|hv_iterinit
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
name|HE
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|croak
argument_list|(
literal|"Bad hash"
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|entry
operator|=
name|xhv
operator|->
name|xhv_eiter
expr_stmt|;
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
comment|/* set up %ENV for iteration */
if|if
condition|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
name|ENV_HV_NAME
argument_list|)
condition|)
name|prime_env_iter
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|&&
name|HvLAZYDEL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
comment|/* was deleted earlier? */
name|HvLAZYDEL_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_riter
operator|=
operator|-
literal|1
expr_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
return|return
name|xhv
operator|->
name|xhv_keys
return|;
comment|/* used to be xhv->xhv_fill before 5.004_65 */
block|}
end_function

begin_function
name|HE
modifier|*
name|hv_iternext
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
name|HE
modifier|*
name|oldentry
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|croak
argument_list|(
literal|"Bad hash"
argument_list|)
expr_stmt|;
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|oldentry
operator|=
name|entry
operator|=
name|xhv
operator|->
name|xhv_eiter
expr_stmt|;
if|if
condition|(
name|mg
operator|=
name|SvTIED_mg
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|key
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|sv_setsv
argument_list|(
name|key
argument_list|,
name|HeSVKEY_force
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|HeSVKEY
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get rid of previous key */
block|}
else|else
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|HEK
modifier|*
name|hek
decl_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|entry
operator|=
name|new_he
argument_list|()
expr_stmt|;
comment|/* one HE per MAGICAL hash */
name|Zero
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|,
name|HE
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|54
argument_list|,
name|k
argument_list|,
name|HEK_BASESIZE
operator|+
sizeof|sizeof
argument_list|(
name|SV
operator|*
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|hek
operator|=
operator|(
name|HEK
operator|*
operator|)
name|k
expr_stmt|;
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|hek
expr_stmt|;
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|=
name|HEf_SVKEY
expr_stmt|;
block|}
name|magic_nextpack
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|mg
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|/* force key to stay around until next time */
name|HeSVKEY_set
argument_list|(
name|entry
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
comment|/* beware, hent_val is not set */
block|}
if|if
condition|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|HeVAL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_he
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|xhv
operator|->
name|xhv_eiter
operator|=
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
expr_stmt|;
return|return
name|Null
argument_list|(
name|HE
operator|*
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|xhv
operator|->
name|xhv_array
condition|)
name|Newz
argument_list|(
literal|506
argument_list|,
name|xhv
operator|->
name|xhv_array
argument_list|,
name|ARRAY_ALLOC_BYTES
argument_list|(
name|xhv
operator|->
name|xhv_max
operator|+
literal|1
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|entry
condition|)
block|{
operator|++
name|xhv
operator|->
name|xhv_riter
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_riter
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
block|{
name|xhv
operator|->
name|xhv_riter
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|entry
operator|=
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|xhv
operator|->
name|xhv_riter
index|]
expr_stmt|;
block|}
if|if
condition|(
name|oldentry
operator|&&
name|HvLAZYDEL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
comment|/* was deleted earlier? */
name|HvLAZYDEL_off
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|hv_free_ent
argument_list|(
name|hv
argument_list|,
name|oldentry
argument_list|)
expr_stmt|;
block|}
name|xhv
operator|->
name|xhv_eiter
operator|=
name|entry
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|hv_iterkey
parameter_list|(
specifier|register
name|HE
modifier|*
name|entry
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|SvPV
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
operator|*
name|retlen
operator|=
name|HeKLEN
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|HeKEY
argument_list|(
name|entry
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* unlike hv_iterval(), this always returns a mortal copy of the key */
end_comment

begin_function
name|SV
modifier|*
name|hv_iterkeysv
parameter_list|(
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
return|return
name|sv_mortalcopy
argument_list|(
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|)
return|;
else|else
return|return
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
operator|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
condition|?
name|HeKEY
argument_list|(
name|entry
argument_list|)
else|:
literal|""
operator|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|hv_iterval
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
specifier|register
name|HE
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|SvRMAGICAL
argument_list|(
name|hv
argument_list|)
condition|)
block|{
if|if
condition|(
name|mg_find
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
literal|'P'
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|==
name|HEf_SVKEY
condition|)
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|HeKEY_sv
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HEf_SVKEY
argument_list|)
expr_stmt|;
else|else
name|mg_copy
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
name|sv
argument_list|,
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|HeKLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
block|}
return|return
name|HeVAL
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|hv_iternextsv
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
name|HE
modifier|*
name|he
decl_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|hv_iternext
argument_list|(
name|hv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|key
operator|=
name|hv_iterkey
argument_list|(
name|he
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
return|return
name|hv_iterval
argument_list|(
name|hv
argument_list|,
name|he
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|hv_magic
parameter_list|(
name|HV
modifier|*
name|hv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|sv_magic
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|hv
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|how
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|sharepvn
parameter_list|(
name|char
modifier|*
name|sv
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
return|return
name|HEK_KEY
argument_list|(
name|share_hek
argument_list|(
name|sv
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* possibly free a shared string if no one has access to it  * len and hash must both be valid for str.  */
end_comment

begin_function
name|void
name|unsharepvn
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|1
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
comment|/* what follows is the moral equivalent of:     if ((Svp = hv_fetch(PL_strtab, tmpsv, FALSE, hash))) { 	if (--*Svp == Nullsv) 	    hv_delete(PL_strtab, str, len, G_DISCARD, hash);     } */
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* assert(xhv_array != 0) */
name|LOCK_STRTAB_MUTEX
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|len
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|==
name|Nullsv
condition|)
block|{
operator|*
name|oentry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|xhv
operator|->
name|xhv_fill
operator|--
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|del_he
argument_list|(
name|entry
argument_list|)
expr_stmt|;
operator|--
name|xhv
operator|->
name|xhv_keys
expr_stmt|;
block|}
break|break;
block|}
name|UNLOCK_STRTAB_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|warn
argument_list|(
literal|"Attempt to free non-existent shared string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a (constant) string ptr from the global string table  * string will get added if it is not already there.  * len and hash must both be valid for str.  */
end_comment

begin_function
name|HEK
modifier|*
name|share_hek
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|I32
name|len
parameter_list|,
specifier|register
name|U32
name|hash
parameter_list|)
block|{
specifier|register
name|XPVHV
modifier|*
name|xhv
decl_stmt|;
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HE
modifier|*
modifier|*
name|oentry
decl_stmt|;
specifier|register
name|I32
name|i
init|=
literal|1
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
comment|/* what follows is the moral equivalent of:             if (!(Svp = hv_fetch(PL_strtab, str, len, FALSE)))     	hv_store(PL_strtab, str, len, Nullsv, hash);     */
name|xhv
operator|=
operator|(
name|XPVHV
operator|*
operator|)
name|SvANY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* assert(xhv_array != 0) */
name|LOCK_STRTAB_MUTEX
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
operator|(
name|HE
operator|*
operator|*
operator|)
name|xhv
operator|->
name|xhv_array
operator|)
index|[
name|hash
operator|&
operator|(
name|I32
operator|)
name|xhv
operator|->
name|xhv_max
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
name|HeHASH
argument_list|(
name|entry
argument_list|)
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|HeKLEN
argument_list|(
name|entry
argument_list|)
operator|!=
name|len
condition|)
continue|continue;
if|if
condition|(
name|memNE
argument_list|(
name|HeKEY
argument_list|(
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|entry
operator|=
name|new_he
argument_list|()
expr_stmt|;
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
operator|=
name|save_hek
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|HeVAL
argument_list|(
name|entry
argument_list|)
operator|=
name|Nullsv
expr_stmt|;
name|HeNEXT
argument_list|(
name|entry
argument_list|)
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
name|xhv
operator|->
name|xhv_keys
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
operator|++
name|xhv
operator|->
name|xhv_fill
expr_stmt|;
if|if
condition|(
name|xhv
operator|->
name|xhv_keys
operator|>
name|xhv
operator|->
name|xhv_max
condition|)
name|hsplit
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* use value slot as REFCNT */
name|UNLOCK_STRTAB_MUTEX
expr_stmt|;
return|return
name|HeKEY_hek
argument_list|(
name|entry
argument_list|)
return|;
block|}
end_function

end_unit

