begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    toke.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  *   "It all comes from here, the stench and the peril."  --Frodo  */
end_comment

begin_comment
comment|/*  * This file is the lexer for Perl.  It's closely linked to the  * parser, perly.y.  *  * The main routine is yylex(), which returns the next token.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_TOKE_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_define
define|#
directive|define
name|yychar
value|PL_yychar
end_define

begin_define
define|#
directive|define
name|yylval
value|PL_yylval
end_define

begin_decl_stmt
specifier|static
name|char
name|ident_too_long
index|[]
init|=
literal|"Identifier too long"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|restore_rsfp
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_NO_UTF16_FILTER
end_ifndef

begin_function_decl
specifier|static
name|I32
name|utf16_textfilter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|utf16rev_textfilter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XFAKEBRACK
value|128
end_define

begin_define
define|#
directive|define
name|XENUMMASK
value|127
end_define

begin_comment
comment|/*#define UTF (SvUTF8(PL_linestr)&& !(PL_hints& HINT_BYTE))*/
end_comment

begin_define
define|#
directive|define
name|UTF
value|(PL_hints& HINT_UTF8)
end_define

begin_comment
comment|/* In variables name $^X, these are the legal values for X.  * 1999-02-27 mjd-perl-patch@plover.com */
end_comment

begin_define
define|#
directive|define
name|isCONTROLVAR
parameter_list|(
name|x
parameter_list|)
value|(isUPPER(x) || strchr("[\\]^_?", (x)))
end_define

begin_comment
comment|/* On MacOS, respect nonbreaking spaces */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
end_ifdef

begin_define
define|#
directive|define
name|SPACE_OR_TAB
parameter_list|(
name|c
parameter_list|)
value|((c)==' '||(c)=='\312'||(c)=='\t')
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPACE_OR_TAB
parameter_list|(
name|c
parameter_list|)
value|((c)==' '||(c)=='\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEX_* are values for PL_lex_state, the state of the lexer.  * They are arranged oddly so that the guard on the switch statement  * can get by with a single comparison (if the compiler is smart enough).  */
end_comment

begin_comment
comment|/* #define LEX_NOTPARSING		11 is done in perl.h. */
end_comment

begin_define
define|#
directive|define
name|LEX_NORMAL
value|10
end_define

begin_define
define|#
directive|define
name|LEX_INTERPNORMAL
value|9
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCASEMOD
value|8
end_define

begin_define
define|#
directive|define
name|LEX_INTERPPUSH
value|7
end_define

begin_define
define|#
directive|define
name|LEX_INTERPSTART
value|6
end_define

begin_define
define|#
directive|define
name|LEX_INTERPEND
value|5
end_define

begin_define
define|#
directive|define
name|LEX_INTERPENDMAYBE
value|4
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCONCAT
value|3
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCONST
value|2
end_define

begin_define
define|#
directive|define
name|LEX_FORMLINE
value|1
end_define

begin_define
define|#
directive|define
name|LEX_KNOWNEXT
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ff_next
end_ifdef

begin_undef
undef|#
directive|undef
name|ff_next
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PURE_BISON
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXLEVEL
end_ifndef

begin_define
define|#
directive|define
name|YYMAXLEVEL
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
modifier|*
name|yylval_pointer
index|[
name|YYMAXLEVEL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|yychar_pointer
index|[
name|YYMAXLEVEL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyactlevel
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|yylval
end_undef

begin_undef
undef|#
directive|undef
name|yychar
end_undef

begin_define
define|#
directive|define
name|yylval
value|(*yylval_pointer[yyactlevel])
end_define

begin_define
define|#
directive|define
name|yychar
value|(*yychar_pointer[yyactlevel])
end_define

begin_define
define|#
directive|define
name|PERL_YYLEX_PARAM
value|yylval_pointer[yyactlevel],yychar_pointer[yyactlevel]
end_define

begin_undef
undef|#
directive|undef
name|yylex
end_undef

begin_define
define|#
directive|define
name|yylex
parameter_list|()
value|Perl_yylex_r(aTHX_ yylval_pointer[yyactlevel],yychar_pointer[yyactlevel])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_comment
comment|/* CLINE is a macro that ensures PL_copline has a sane value */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLINE
end_ifdef

begin_undef
undef|#
directive|undef
name|CLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CLINE
value|(PL_copline = (CopLINE(PL_curcop)< PL_copline ? CopLINE(PL_curcop) : PL_copline))
end_define

begin_comment
comment|/*  * Convenience functions to return different tokens and prime the  * lexer for the next token.  They all take an argument.  *  * TOKEN        : generic token (used for '(', DOLSHARP, etc)  * OPERATOR     : generic operator  * AOPERATOR    : assignment operator  * PREBLOCK     : beginning the block after an if, while, foreach, ...  * PRETERMBLOCK : beginning a non-code-defining {} block (eg, hash ref)  * PREREF       : *EXPR where EXPR is not a simple identifier  * TERM         : expression term  * LOOPX        : loop exiting command (goto, last, dump, etc)  * FTST         : file test operator  * FUN0         : zero-argument function  * FUN1         : not used, except for not, which isn't a UNIOP  * BOop         : bitwise or or xor  * BAop         : bitwise and  * SHop         : shift operator  * PWop         : power operator  * PMop         : pattern-matching operator  * Aop          : addition-level operator  * Mop          : multiplication-level operator  * Eop          : equality-testing operator  * Rop          : relational operator<= != gt  *  * Also see LOP and lop() below.  */
end_comment

begin_define
define|#
directive|define
name|TOKEN
parameter_list|(
name|retval
parameter_list|)
value|return (PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|OPERATOR
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XTERM,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|AOPERATOR
parameter_list|(
name|retval
parameter_list|)
value|return ao((PL_expect = XTERM,PL_bufptr = s,(int)retval))
end_define

begin_define
define|#
directive|define
name|PREBLOCK
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|PRETERMBLOCK
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|PREREF
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XREF,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|TERM
parameter_list|(
name|retval
parameter_list|)
value|return (CLINE, PL_expect = XOPERATOR,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|LOOPX
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
end_define

begin_define
define|#
directive|define
name|FTST
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
end_define

begin_define
define|#
directive|define
name|FUN0
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
end_define

begin_define
define|#
directive|define
name|FUN1
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
end_define

begin_define
define|#
directive|define
name|BOop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
end_define

begin_define
define|#
directive|define
name|BAop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
end_define

begin_define
define|#
directive|define
name|SHop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
end_define

begin_define
define|#
directive|define
name|PWop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
end_define

begin_define
define|#
directive|define
name|PMop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
end_define

begin_define
define|#
directive|define
name|Aop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
end_define

begin_define
define|#
directive|define
name|Mop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
end_define

begin_define
define|#
directive|define
name|Eop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
end_define

begin_define
define|#
directive|define
name|Rop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
end_define

begin_comment
comment|/* This bit of chicanery makes a unary function followed by  * a parenthesis into a function with one argument, highest precedence.  */
end_comment

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f, \ 	PL_expect = XTERM, \ 	PL_bufptr = s, \ 	PL_last_uni = PL_oldbufptr, \ 	PL_last_lop_op = f, \ 	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
end_define

begin_define
define|#
directive|define
name|UNIBRACK
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f, \ 	PL_bufptr = s, \ 	PL_last_uni = PL_oldbufptr, \ 	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
end_define

begin_comment
comment|/* grandfather return to old style */
end_comment

begin_define
define|#
directive|define
name|OLDLOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
end_define

begin_comment
comment|/*  * S_ao  *  * This subroutine detects&&= and ||= and turns an ANDAND or OROR  * into an OP_ANDASSIGN or OP_ORASSIGN  */
end_comment

begin_function
name|STATIC
name|int
name|S_ao
parameter_list|(
name|pTHX_
name|int
name|toketype
parameter_list|)
block|{
if|if
condition|(
operator|*
name|PL_bufptr
operator|==
literal|'='
condition|)
block|{
name|PL_bufptr
operator|++
expr_stmt|;
if|if
condition|(
name|toketype
operator|==
name|ANDAND
condition|)
name|yylval
operator|.
name|ival
operator|=
name|OP_ANDASSIGN
expr_stmt|;
elseif|else
if|if
condition|(
name|toketype
operator|==
name|OROR
condition|)
name|yylval
operator|.
name|ival
operator|=
name|OP_ORASSIGN
expr_stmt|;
name|toketype
operator|=
name|ASSIGNOP
expr_stmt|;
block|}
return|return
name|toketype
return|;
block|}
end_function

begin_comment
comment|/*  * S_no_op  * When Perl expects an operator and finds something else, no_op  * prints the warning.  It always prints "<something> found where  * operator expected.  It prints "Missing semicolon on previous line?"  * if the surprise occurs at the start of the line.  "do you need to  * predeclare ..." is printed out for code like "sub bar; foo bar $x"  * where the compiler doesn't know if foo is a method call or a function.  * It prints "Missing operator before end of line" if there's nothing  * after the missing operator, or "... before<...>" if there is something  * after the missing operator.  */
end_comment

begin_function
name|STATIC
name|void
name|S_no_op
parameter_list|(
name|pTHX_
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|oldbp
init|=
name|PL_bufptr
decl_stmt|;
name|bool
name|is_first
init|=
operator|(
name|PL_oldbufptr
operator|==
name|PL_linestart
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|oldbp
expr_stmt|;
else|else
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|yywarn
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"%s found where operator expected"
argument_list|,
name|what
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_first
condition|)
name|Perl_warn
argument_list|(
name|aTHX_
literal|"\t(Missing semicolon on previous line?)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_oldoldbufptr
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|PL_oldoldbufptr
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|PL_oldoldbufptr
init|;
operator|*
name|t
operator|&&
operator|(
name|isALNUM_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|':'
operator|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|t
operator|<
name|PL_bufptr
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|Perl_warn
argument_list|(
name|aTHX_
literal|"\t(Do you need to predeclare %.*s?)\n"
argument_list|,
name|t
operator|-
name|PL_oldoldbufptr
argument_list|,
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|s
operator|>=
name|oldbp
argument_list|)
expr_stmt|;
name|Perl_warn
argument_list|(
name|aTHX_
literal|"\t(Missing operator before %.*s?)\n"
argument_list|,
name|s
operator|-
name|oldbp
argument_list|,
name|oldbp
argument_list|)
expr_stmt|;
block|}
name|PL_bufptr
operator|=
name|oldbp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * S_missingterm  * Complain about missing quote/regexp/heredoc terminator.  * If it's called with (char *)NULL then it cauterizes the line buffer.  * If we're in a delimited string and the delimiter is a control  * character, it's reformatted into a two-char sequence like ^C.  * This is fatal.  */
end_comment

begin_function
name|STATIC
name|void
name|S_missingterm
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|tmpbuf
index|[
literal|3
index|]
decl_stmt|;
name|char
name|q
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|char
modifier|*
name|nl
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|EBCDIC
name|iscntrl
argument_list|(
argument|PL_multi_close
argument_list|)
else|#
directive|else
name|PL_multi_close
operator|<
literal|32
operator|||
name|PL_multi_close
operator|==
literal|127
endif|#
directive|endif
condition|)
block|{
operator|*
name|tmpbuf
operator|=
literal|'^'
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
name|toCTRL
argument_list|(
name|PL_multi_close
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\\n"
expr_stmt|;
name|tmpbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tmpbuf
operator|=
name|PL_multi_close
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
block|}
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'"'
argument_list|)
condition|?
literal|'\''
else|:
literal|'"'
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't find string terminator %c%s%c anywhere before EOF"
argument_list|,
name|q
argument_list|,
name|s
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perl_deprecate  */
end_comment

begin_function
name|void
name|Perl_deprecate
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"Use of %s is deprecated"
argument_list|,
argument|s
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * depcom  * Deprecate a comma-less variable list.  */
end_comment

begin_function
name|STATIC
name|void
name|S_depcom
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|deprecate
argument_list|(
literal|"comma-less variable list"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * experimental text filters for win32 carriage-returns, utf16-to-utf8 and  * utf16-to-utf8-reversed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_CR_FILTER
end_ifdef

begin_function
specifier|static
name|void
name|strip_return
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* outer loop optimized to do nothing if there are no CR-LFs */
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\r'
operator|&&
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
comment|/* hit a CR-LF, need to copy the rest */
specifier|register
name|char
modifier|*
name|d
init|=
name|s
operator|-
literal|1
decl_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-=
name|s
operator|-
name|d
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_cr_textfilter
parameter_list|(
name|pTHX_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|I32
name|count
init|=
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|!
name|maxlen
condition|)
name|strip_return
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Perl_lex_start  * Initialize variables.  Uses the Perl save_stack to save its state (for  * recursive calls to the parser).  */
end_comment

begin_function
name|void
name|Perl_lex_start
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_dojoin
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_brackets
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_casemods
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_starts
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_state
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_lex_inpat
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_inwhat
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_KNOWNEXT
condition|)
block|{
name|I32
name|toke
init|=
name|PL_nexttoke
decl_stmt|;
while|while
condition|(
operator|--
name|toke
operator|>=
literal|0
condition|)
block|{
name|SAVEI32
argument_list|(
name|PL_nexttype
index|[
name|toke
index|]
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_nextval
index|[
name|toke
index|]
argument_list|)
expr_stmt|;
block|}
name|SAVEI32
argument_list|(
name|PL_nexttoke
argument_list|)
expr_stmt|;
block|}
name|SAVECOPLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufend
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_last_lop
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_last_uni
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_linestart
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|SAVEDESTRUCTOR_X
argument_list|(
name|restore_rsfp
argument_list|,
name|PL_rsfp
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_defer
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_sublex_info
operator|.
name|sub_inwhat
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|SAVEINT
argument_list|(
name|PL_expect
argument_list|)
expr_stmt|;
name|SAVEINT
argument_list|(
name|PL_lex_expect
argument_list|)
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|PL_lex_defer
operator|=
literal|0
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_brackstack
argument_list|,
literal|120
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_casestack
argument_list|,
literal|12
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_dojoin
operator|=
literal|0
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
name|PL_lex_inpat
operator|=
literal|0
expr_stmt|;
name|PL_nexttoke
operator|=
literal|0
expr_stmt|;
name|PL_lex_inwhat
operator|=
literal|0
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_inwhat
operator|=
literal|0
expr_stmt|;
name|PL_linestr
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|PL_linestr
argument_list|)
condition|)
name|PL_linestr
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|PL_linestr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|PL_linestr
argument_list|)
operator|&
name|SVs_TEMP
operator|)
condition|)
name|PL_linestr
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|"\n;"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|SvTEMP_off
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|newSVpvn
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perl_lex_end  * Finalizer for lexing operations.  Must be called when the parser is  * done with the lexer.  */
end_comment

begin_function
name|void
name|Perl_lex_end
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * S_incline  * This subroutine has nothing to do with tilting, whether at windmills  * or pinball tables.  Its name is short for "increment line".  It  * increments the current line number in CopLINE(PL_curcop) and checks  * to see whether the line starts with a comment of the form  *    # line 500 "foo.pm"  * If so, it sets the current line number and file to the values in the comment.  */
end_comment

begin_function
name|STATIC
name|void
name|S_incline
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'#'
condition|)
return|return;
while|while
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"line"
argument_list|,
literal|4
argument_list|)
condition|)
name|s
operator|+=
literal|4
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
return|return;
while|while
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return;
name|n
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|)
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|e
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
operator|!
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|e
operator|=
name|t
expr_stmt|;
block|}
while|while
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|e
argument_list|)
operator|||
operator|*
name|e
operator|==
literal|'\r'
operator|||
operator|*
name|e
operator|==
literal|'\f'
condition|)
name|e
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|!=
literal|'\n'
operator|&&
operator|*
name|e
operator|!=
literal|'\0'
condition|)
return|return;
comment|/* false alarm */
name|ch
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t
operator|-
name|s
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|Safefree
argument_list|(
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SvREFCNT_dec
argument_list|(
name|CopFILEGV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CopFILE_set
argument_list|(
name|PL_curcop
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
operator|*
name|t
operator|=
name|ch
expr_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|atoi
argument_list|(
name|n
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * S_skipspace  * Called to gobble the appropriate amount and type of whitespace.  * Skips comments as well.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_skipspace
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|STRLEN
name|prevlen
decl_stmt|;
name|SSize_t
name|oldprevlen
decl_stmt|,
name|oldoldprevlen
decl_stmt|;
name|SSize_t
name|oldloplen
decl_stmt|,
name|oldunilen
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
operator|&&
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* comment */
if|if
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* only continue to recharge the buffer if we're at the end 	 * of the buffer, we're not reading from a source filter, and 	 * we're in normal lexing mode 	 */
if|if
condition|(
name|s
operator|<
name|PL_bufend
operator|||
operator|!
name|PL_rsfp
operator|||
name|PL_sublex_info
operator|.
name|sub_inwhat
operator|||
name|PL_lex_state
operator|==
name|LEX_FORMLINE
condition|)
return|return
name|s
return|;
comment|/* try to recharge the buffer */
if|if
condition|(
operator|(
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
operator|(
name|prevlen
operator|=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
comment|/* end of file.  Add on the -p or -n magic */
if|if
condition|(
name|PL_minus_n
operator|||
name|PL_minus_p
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|PL_minus_p
condition|?
literal|";}continue{print or die qq(-p destination: $!\\n)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";}"
argument_list|)
expr_stmt|;
name|PL_minus_n
operator|=
name|PL_minus_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
comment|/* reset variables for next time we lex */
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
comment|/* Close the filehandle.  Could be from -P preprocessor, 	     * STDIN, or a regular file.  If we were reading code from 	     * STDIN (because the commandline held no -e or filename) 	     * then we don't close it, we reset it so the code can 	     * read from STDIN too. 	     */
if|if
condition|(
name|PL_preprocess
operator|&&
operator|!
name|PL_in_eval
condition|)
operator|(
name|void
operator|)
name|PerlProc_pclose
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/* not at end of file, so we only read another line */
comment|/* make corresponding updates to old pointers, for yyerror() */
name|oldprevlen
operator|=
name|PL_oldbufptr
operator|-
name|PL_bufend
expr_stmt|;
name|oldoldprevlen
operator|=
name|PL_oldoldbufptr
operator|-
name|PL_bufend
expr_stmt|;
if|if
condition|(
name|PL_last_uni
condition|)
name|oldunilen
operator|=
name|PL_last_uni
operator|-
name|PL_bufend
expr_stmt|;
if|if
condition|(
name|PL_last_lop
condition|)
name|oldloplen
operator|=
name|PL_last_lop
operator|-
name|PL_bufend
expr_stmt|;
name|PL_linestart
operator|=
name|PL_bufptr
operator|=
name|s
operator|+
name|prevlen
expr_stmt|;
name|PL_bufend
operator|=
name|s
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|PL_oldbufptr
operator|=
name|s
operator|+
name|oldprevlen
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|s
operator|+
name|oldoldprevlen
expr_stmt|;
if|if
condition|(
name|PL_last_uni
condition|)
name|PL_last_uni
operator|=
name|s
operator|+
name|oldunilen
expr_stmt|;
if|if
condition|(
name|PL_last_lop
condition|)
name|PL_last_lop
operator|=
name|s
operator|+
name|oldloplen
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* debugger active and we're not compiling the debugger code, 	 * so store the line into the debugger's array of lines 	 */
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|PL_bufptr
argument_list|,
name|PL_bufend
operator|-
name|PL_bufptr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * S_check_uni  * Check the unary operators to ensure there's no ambiguity in how they're  * used.  An ambiguous piece of code would be:  *     rand + 5  * This doesn't mean rand() + 5.  Because rand() is a unary operator,  * the +5 is its argument.  */
end_comment

begin_function
name|STATIC
name|void
name|S_check_uni
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|PL_oldoldbufptr
operator|!=
name|PL_last_uni
condition|)
return|return;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_last_uni
argument_list|)
condition|)
name|PL_last_uni
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|PL_last_uni
init|;
name|isALNUM_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|&&
name|t
operator|<
name|PL_bufptr
condition|)
return|return;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
condition|)
block|{
name|char
name|ch
init|=
operator|*
name|s
decl_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Warning: Use of \"%s\" without parens is ambiguous"
argument_list|,
argument|PL_last_uni
argument_list|)
empty_stmt|;
operator|*
name|s
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* workaround to replace the UNI() macro with a function.  Only the  * hints/uts.sh file mentions this.  Other comments elsewhere in the  * source indicate Microport Unix might need it too.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CRIPPLED_CC
end_ifdef

begin_undef
undef|#
directive|undef
name|UNI
end_undef

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return uni(f,s)
end_define

begin_function
name|STATIC
name|int
name|S_uni
parameter_list|(
name|pTHX_
name|I32
name|f
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_last_uni
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|f
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
else|else
return|return
name|UNIOP
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRIPPLED_CC */
end_comment

begin_comment
comment|/*  * LOP : macro to build a list operator.  Its behaviour has been replaced  * with a subroutine, S_lop() for which LOP is just another name.  */
end_comment

begin_define
define|#
directive|define
name|LOP
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
value|return lop(f,x,s)
end_define

begin_comment
comment|/*  * S_lop  * Build a list operator (or something that might be one).  The rules:  *  - if we have a next token, then it's a list operator [why?]  *  - if the next thing is an opening paren, then it's a function  *  - else it's a list operator  */
end_comment

begin_function
name|STATIC
name|I32
name|S_lop
parameter_list|(
name|pTHX_
name|I32
name|f
parameter_list|,
name|int
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|CLINE
expr_stmt|;
name|PL_expect
operator|=
name|x
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|PL_nexttoke
condition|)
return|return
name|LSTOP
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC
return|;
else|else
return|return
name|LSTOP
return|;
block|}
end_function

begin_comment
comment|/*  * S_force_next  * When the lexer realizes it knows the next token (for instance,  * it is reordering tokens for the parser) then it can call S_force_next  * to know what token to return the next time the lexer is called.  Caller  * will need to set PL_nextval[], and possibly PL_expect to ensure the lexer  * handles the token correctly.  */
end_comment

begin_function
name|STATIC
name|void
name|S_force_next
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|)
block|{
name|PL_nexttype
index|[
name|PL_nexttoke
index|]
operator|=
name|type
expr_stmt|;
name|PL_nexttoke
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_KNOWNEXT
condition|)
block|{
name|PL_lex_defer
operator|=
name|PL_lex_state
expr_stmt|;
name|PL_lex_expect
operator|=
name|PL_expect
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_KNOWNEXT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * S_force_word  * When the lexer knows the next thing is a word (for instance, it has  * just seen -> and it knows that the next char is a word char, then  * it calls S_force_word to stick the next word into the PL_next lookahead.  *  * Arguments:  *   char *start : buffer position (must be within PL_linestr)  *   int token   : PL_next will be this type of bare word (e.g., METHOD,WORD)  *   int check_keyword : if true, Perl checks to make sure the word isn't  *       a keyword (do this if the word is a label, e.g. goto FOO)  *   int allow_pack : if true, : characters will also be allowed (require,  *       use, etc. do this)  *   int allow_initial_tick : used by the "sub" lexer only.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_force_word
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|start
parameter_list|,
name|int
name|token
parameter_list|,
name|int
name|check_keyword
parameter_list|,
name|int
name|allow_pack
parameter_list|,
name|int
name|allow_initial_tick
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|start
operator|=
name|skipspace
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|s
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|||
operator|(
name|allow_pack
operator|&&
operator|*
name|s
operator|==
literal|':'
operator|)
operator|||
operator|(
name|allow_initial_tick
operator|&&
operator|*
name|s
operator|==
literal|'\''
operator|)
condition|)
block|{
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|allow_pack
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_keyword
operator|&&
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|start
return|;
if|if
condition|(
name|token
operator|==
name|METHOD
condition|)
block|{
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
else|else
block|{
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
block|}
block|}
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_private
operator||=
name|OPpCONST_BARE
expr_stmt|;
name|force_next
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * S_force_ident  * Called when the lexer wants $foo *foo&foo etc, but the program  * text only contains the "foo" portion.  The first argument is a pointer  * to the "foo", and the second argument is the type symbol to prefix.  * Forces the next token to be a "WORD".  * Creates the symbol if it didn't already exist (via gv_fetchpv()).  */
end_comment

begin_function
name|STATIC
name|void
name|S_force_ident
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|OP
modifier|*
name|o
init|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|o
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
condition|)
block|{
name|o
operator|->
name|op_private
operator|=
name|OPpCONST_ENTERED
expr_stmt|;
comment|/* XXX see note in pp_entereval() for why we forgo typo 	       warnings if the symbol must be introduced in an eval. 	       GSAR 96-10-12 */
name|gv_fetchpv
argument_list|(
name|s
argument_list|,
name|PL_in_eval
condition|?
operator|(
name|GV_ADDMULTI
operator||
name|GV_ADDINEVAL
operator|)
else|:
name|TRUE
argument_list|,
name|kind
operator|==
literal|'$'
condition|?
name|SVt_PV
else|:
name|kind
operator|==
literal|'@'
condition|?
name|SVt_PVAV
else|:
name|kind
operator|==
literal|'%'
condition|?
name|SVt_PVHV
else|:
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|NV
name|Perl_str_to_version
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|NV
name|retval
init|=
literal|0.0
decl_stmt|;
name|NV
name|nshift
init|=
literal|1.0
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|SvPVx
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|bool
name|utf
init|=
name|SvUTF8
argument_list|(
name|sv
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|STRLEN
name|skip
decl_stmt|;
name|UV
name|n
decl_stmt|;
if|if
condition|(
name|utf
condition|)
name|n
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|start
argument_list|,
name|len
argument_list|,
operator|&
name|skip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
operator|*
operator|(
name|U8
operator|*
operator|)
name|start
expr_stmt|;
name|skip
operator|=
literal|1
expr_stmt|;
block|}
name|retval
operator|+=
operator|(
operator|(
name|NV
operator|)
name|n
operator|)
operator|/
name|nshift
expr_stmt|;
name|start
operator|+=
name|skip
expr_stmt|;
name|nshift
operator|*=
literal|1000
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * S_force_version  * Forces the next token to be a version number.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_force_version
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|OP
modifier|*
name|version
init|=
name|Nullop
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'v'
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'_'
operator|||
operator|*
name|d
operator|==
literal|'.'
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|';'
operator|||
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'}'
operator|||
operator|!
operator|*
name|d
condition|)
block|{
name|SV
modifier|*
name|ver
decl_stmt|;
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
name|version
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
name|ver
operator|=
name|cSVOPx
argument_list|(
name|version
argument_list|)
operator|->
name|op_sv
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|ver
argument_list|)
operator|&&
operator|!
name|SvNIOK
argument_list|(
name|ver
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|ver
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|ver
argument_list|)
operator|=
name|str_to_version
argument_list|(
name|ver
argument_list|)
expr_stmt|;
name|SvNOK_on
argument_list|(
name|ver
argument_list|)
expr_stmt|;
comment|/* hint that it is a version */
block|}
block|}
block|}
comment|/* NOTE: The parser sees the package name and the VERSION swapped */
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|version
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * S_tokeq  * Tokenize a quoted string passed in as an SV.  It finds the next  * chunk, up to end of string or a backslash.  It may make a new  * SV containing that chunk (if HINT_NEW_STRING is on).  It also  * turns \\ into \.  */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|S_tokeq
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|STRLEN
name|len
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|pv
init|=
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|finish
goto|;
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVIV
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|finish
goto|;
name|send
operator|=
name|s
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|'\\'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
goto|goto
name|finish
goto|;
name|d
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_STRING
condition|)
name|pv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|SvPVX
argument_list|(
name|pv
argument_list|)
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* all that, just for this */
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_STRING
condition|)
return|return
name|new_constant
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"q"
argument_list|,
name|sv
argument_list|,
name|pv
argument_list|,
literal|"q"
argument_list|)
return|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/*  * Now come three functions related to double-quote context,  * S_sublex_start, S_sublex_push, and S_sublex_done.  They're used when  * converting things like "\u\Lgnat" into ucfirst(lc("gnat")).  They  * interact with PL_lex_state, and create fake ( ... ) argument lists  * to handle functions and concatenation.  * They assume that whoever calls them will be setting up a fake  * join call, because each subthing puts a ',' after it.  This lets  *   "lower \luPpEr"  * become  *  join($, , 'lower ', lcfirst( 'uPpEr', ) ,)  *  * (I'm not sure whether the spurious commas at the end of lcfirst's  * arguments and join's arguments are created or not).  */
end_comment

begin_comment
comment|/*  * S_sublex_start  * Assumes that yylval.ival is the op we're creating (e.g. OP_LCFIRST).  *  * Pattern matching will set PL_lex_op to the pattern-matching op to  * make (we return THING if yylval.ival is OP_NULL, PMFUNC otherwise).  *  * OP_CONST and OP_READLINE are easy--just make the new op and return.  *  * Everything else becomes a FUNC.  *  * Sets PL_lex_state to LEX_INTERPPUSH unless (ival was OP_NULL or we  * had an OP_CONST or OP_READLINE).  This just sets us up for a  * call to S_sublex_push().  */
end_comment

begin_function
name|STATIC
name|I32
name|S_sublex_start
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|I32
name|op_type
init|=
name|yylval
operator|.
name|ival
decl_stmt|;
if|if
condition|(
name|op_type
operator|==
name|OP_NULL
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_op
operator|=
name|Nullop
expr_stmt|;
return|return
name|THING
return|;
block|}
if|if
condition|(
name|op_type
operator|==
name|OP_CONST
operator|||
name|op_type
operator|==
name|OP_READLINE
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|tokeq
argument_list|(
name|PL_lex_stuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVIV
condition|)
block|{
comment|/* Overloaded constants, nothing fancy: Convert to SVt_PV: */
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|SV
modifier|*
name|nsv
decl_stmt|;
name|p
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nsv
operator|=
name|newSVpvn
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|nsv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|nsv
expr_stmt|;
block|}
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|op_type
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
return|return
name|THING
return|;
block|}
name|PL_sublex_info
operator|.
name|super_state
operator|=
name|PL_lex_state
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_inwhat
operator|=
name|op_type
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_op
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPPUSH
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
if|if
condition|(
name|PL_lex_op
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_op
operator|=
name|Nullop
expr_stmt|;
return|return
name|PMFUNC
return|;
block|}
else|else
return|return
name|FUNC
return|;
block|}
end_function

begin_comment
comment|/*  * S_sublex_push  * Create a new scope to save the lexing state.  The scope will be  * ended in S_sublex_done.  Returns a '(', starting the function arguments  * to the uc, lc, etc. found before.  * Sets PL_lex_state to LEX_INTERPCONCAT.  */
end_comment

begin_function
name|STATIC
name|I32
name|S_sublex_push
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|ENTER
expr_stmt|;
name|PL_lex_state
operator|=
name|PL_sublex_info
operator|.
name|super_state
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_dojoin
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_brackets
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_casemods
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_starts
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_state
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_lex_inpat
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_inwhat
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_last_lop
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_last_uni
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_linestart
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_linestr
operator|=
name|PL_lex_stuff
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_brackstack
argument_list|,
literal|120
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_casestack
argument_list|,
literal|12
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_start
argument_list|)
expr_stmt|;
name|PL_lex_inwhat
operator|=
name|PL_sublex_info
operator|.
name|sub_inwhat
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_MATCH
operator|||
name|PL_lex_inwhat
operator|==
name|OP_QR
operator|||
name|PL_lex_inwhat
operator|==
name|OP_SUBST
condition|)
name|PL_lex_inpat
operator|=
name|PL_sublex_info
operator|.
name|sub_op
expr_stmt|;
else|else
name|PL_lex_inpat
operator|=
name|Nullop
expr_stmt|;
return|return
literal|'('
return|;
block|}
end_function

begin_comment
comment|/*  * S_sublex_done  * Restores lexer state after a S_sublex_push.  */
end_comment

begin_function
name|STATIC
name|I32
name|S_sublex_done
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PL_lex_starts
operator|++
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|PL_linestr
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
return|return
name|THING
return|;
block|}
if|if
condition|(
name|PL_lex_casemods
condition|)
block|{
comment|/* oops, we've got some unbalanced parens */
name|PL_lex_state
operator|=
name|LEX_INTERPCASEMOD
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
comment|/* Is there a right-hand side to take care of? (s//RHS/ or tr//RHS/) */
if|if
condition|(
name|PL_lex_repl
operator|&&
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|||
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|)
condition|)
block|{
name|PL_linestr
operator|=
name|PL_lex_repl
expr_stmt|;
name|PL_lex_inpat
operator|=
literal|0
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvEVALED
argument_list|(
name|PL_lex_repl
argument_list|)
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
name|PL_lex_starts
operator|++
expr_stmt|;
comment|/*	we don't clear PL_lex_repl here, so that we can check later 		whether this is an evalled subst; that means we rely on the 		logic to ensure sublex_done() is called again only via the 		branch (in yylex()) that clears PL_lex_repl, else we'll loop */
block|}
else|else
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
block|}
return|return
literal|','
return|;
block|}
else|else
block|{
name|LEAVE
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_inwhat
operator|=
literal|0
expr_stmt|;
return|return
literal|')'
return|;
block|}
block|}
end_function

begin_comment
comment|/*   scan_const    Extracts a pattern, double-quoted string, or transliteration.  This   is terrifying code.    It looks at lex_inwhat and PL_lex_inpat to find out whether it's   processing a pattern (PL_lex_inpat is true), a transliteration   (lex_inwhat& OP_TRANS is true), or a double-quoted string.    Returns a pointer to the character scanned up to. Iff this is   advanced from the start pointer supplied (ie if anything was   successfully parsed), will leave an OP for the substring scanned   in yylval. Caller must intuit reason for not parsing further   by looking at the next characters herself.    In patterns:     backslashes:       double-quoted style: \r and \n       regexp special ones: \D \s       constants: \x3       backrefs: \1 (deprecated in substitution replacements)       case and quoting: \U \Q \E     stops on @ and $, but not for $ as tail anchor    In transliterations:     characters are VERY literal, except for - not at the start or end     of the string, which indicates a range.  scan_const expands the     range to the full set of intermediate characters.    In double-quoted strings:     backslashes:       double-quoted style: \r and \n       constants: \x3       backrefs: \1 (deprecated)       case and quoting: \U \Q \E     stops on @ and $    scan_const does *not* construct ops to handle interpolated strings.   It stops processing as soon as it finds an embedded $ or @ variable   and leaves it to the caller to work out what's going on.    @ in pattern could be: @foo, @{foo}, @$foo, @'foo, @:foo.    $ in pattern could be $foo or could be tail anchor.  Assumption:   it's a tail anchor if $ is the last thing in the string, or if it's   followed by one of ")| \n\t"    \1 (backreferences) are turned into $1    The structure of the code is       while (there's a character to process) {           handle transliteration ranges 	  skip regexp comments 	  skip # initiated comments in //x patterns 	  check for embedded @foo 	  check for embedded scalars 	  if (backslash) { 	      leave intact backslashes from leave (below) 	      deprecate \1 in strings and sub replacements 	      handle string-changing backslashes \l \U \Q \E, etc. 	      switch (what was escaped) { 	          handle - in a transliteration (becomes a literal -) 		  handle \132 octal characters 		  handle 0x15 hex characters 		  handle \cV (control V) 		  handle printf backslashes (\f, \r, \n, etc) 	      } (end switch) 	  } (end if backslash)     } (end while character to read) 		 */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_const
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|send
init|=
name|PL_bufend
decl_stmt|;
comment|/* end of the constant */
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|93
argument_list|,
name|send
operator|-
name|start
argument_list|)
decl_stmt|;
comment|/* sv for the constant */
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* start of the constant */
specifier|register
name|char
modifier|*
name|d
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* destination for copies */
name|bool
name|dorange
init|=
name|FALSE
decl_stmt|;
comment|/* are we in a translit range? */
name|bool
name|has_utf8
init|=
name|FALSE
decl_stmt|;
comment|/* embedded \x{} */
name|UV
name|uv
decl_stmt|;
name|I32
name|utf
init|=
operator|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|&&
name|PL_sublex_info
operator|.
name|sub_op
operator|)
condition|?
operator|(
name|PL_sublex_info
operator|.
name|sub_op
operator|->
name|op_private
operator|&
operator|(
name|OPpTRANS_FROM_UTF
operator||
name|OPpTRANS_TO_UTF
operator|)
operator|)
else|:
name|UTF
decl_stmt|;
name|I32
name|this_utf8
init|=
operator|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|&&
name|PL_sublex_info
operator|.
name|sub_op
operator|)
condition|?
operator|(
name|PL_sublex_info
operator|.
name|sub_op
operator|->
name|op_private
operator|&
operator|(
name|PL_lex_repl
condition|?
name|OPpTRANS_FROM_UTF
else|:
name|OPpTRANS_TO_UTF
operator|)
operator|)
else|:
name|UTF
decl_stmt|;
specifier|const
name|char
modifier|*
name|leaveit
init|=
comment|/* set of acceptably-backslashed characters */
name|PL_lex_inpat
condition|?
literal|"\\.^$@AGZdDwWsSbBpPXC+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
else|:
literal|""
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|||
name|dorange
condition|)
block|{
comment|/* get transliterations out of the way (they're most literal) */
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|)
block|{
comment|/* expand a range A-Z to the full set of characters.  AIE! */
if|if
condition|(
name|dorange
condition|)
block|{
name|I32
name|i
decl_stmt|;
comment|/* current expanded character */
name|I32
name|min
decl_stmt|;
comment|/* first character in range */
name|I32
name|max
decl_stmt|;
comment|/* last character in range */
name|i
operator|=
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* remember current offset */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
literal|256
argument_list|)
expr_stmt|;
comment|/* never more than 256 chars in a range */
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* refresh d after realloc */
name|d
operator|-=
literal|2
expr_stmt|;
comment|/* eat the first char and the - */
name|min
operator|=
operator|(
name|U8
operator|)
operator|*
name|d
expr_stmt|;
comment|/* first char in range */
name|max
operator|=
operator|(
name|U8
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
comment|/* last char in range  */
ifndef|#
directive|ifndef
name|ASCIIish
if|if
condition|(
operator|(
name|isLOWER
argument_list|(
name|min
argument_list|)
operator|&&
name|isLOWER
argument_list|(
name|max
argument_list|)
operator|)
operator|||
operator|(
name|isUPPER
argument_list|(
name|min
argument_list|)
operator|&&
name|isUPPER
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isLOWER
argument_list|(
name|min
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|i
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isUPPER
argument_list|(
name|i
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
comment|/* mark the range as done, and continue */
name|dorange
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* range begins (ignore - as first or last char) */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
name|s
operator|!=
name|start
condition|)
block|{
if|if
condition|(
name|utf
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
comment|/* use illegal utf8 byte--see pmtrans */
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
name|dorange
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* if we get here, we're not doing a transliteration */
comment|/* skip for regexp comments /(?#comment)/ and code /(?{code})/, 	   except for the last char, which will be done separately. */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|&&
name|PL_lex_inpat
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|')'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'{'
comment|/* This should match regcomp.c */
operator|||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'?'
operator|)
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'{'
operator|)
condition|)
block|{
name|I32
name|count
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|regparse
init|=
name|s
operator|+
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'{'
condition|?
literal|3
else|:
literal|4
operator|)
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|c
operator|=
operator|*
name|regparse
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|regparse
index|[
literal|1
index|]
condition|)
name|regparse
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|regparse
operator|!=
literal|')'
condition|)
block|{
name|regparse
operator|--
expr_stmt|;
comment|/* Leave one char for continuation. */
name|yyerror
argument_list|(
literal|"Sequence (?{...}) not terminated or not {}-balanced"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<
name|regparse
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* likewise skip #-initiated comments in //x patterns */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|PL_lex_inpat
operator|&&
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|PL_lex_inpat
operator|)
operator|->
name|op_pmflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
while|while
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* check for embedded arrays (@foo, @:foo, @'foo, @{foo}, @$foo) */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'@'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|isALNUM_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
operator|||
name|strchr
argument_list|(
literal|":'{$"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
break|break;
comment|/* check for embedded scalars.  only stop if we're sure it's a 	   variable.         */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
comment|/* not a regexp, so $ must be var */
break|break;
if|if
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|!
name|strchr
argument_list|(
literal|"()| \n\t"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
comment|/* in regexp, $ might be tail anchor */
block|}
comment|/* backslashes */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
name|bool
name|to_be_utf8
init|=
name|FALSE
decl_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* some backslashes we leave behind */
if|if
condition|(
operator|*
name|leaveit
operator|&&
operator|*
name|s
operator|&&
name|strchr
argument_list|(
name|leaveit
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* deprecate \1 in strings and substitution replacements */
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
operator|!
name|PL_lex_inpat
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'0'
operator|&&
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"\\%c better written as $%c"
argument_list|,
argument|*s
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
operator|*
operator|--
name|s
operator|=
literal|'$'
expr_stmt|;
break|break;
block|}
comment|/* string-change backslash escapes */
if|if
condition|(
name|PL_lex_inwhat
operator|!=
name|OP_TRANS
operator|&&
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"lLuUEQ"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
operator|--
name|s
expr_stmt|;
break|break;
block|}
comment|/* if we get here, it's either a quoted -, or a digit */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* quoted - in transliterations */
case|case
literal|'-'
case|:
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* FALL THROUGH */
default|default:
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Unrecognized escape \\%c passed through"
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
comment|/* default action is to copy the quoted character */
goto|goto
name|default_action
goto|;
block|}
comment|/* \132 indicates an octal constant */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|STRLEN
name|len
init|=
literal|0
decl_stmt|;
comment|/* disallow underscores */
name|uv
operator|=
operator|(
name|UV
operator|)
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
goto|goto
name|NUM_ESCAPE_INSERT
goto|;
comment|/* \x24 indicates a hex constant */
case|case
literal|'x'
case|:
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|e
init|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'}'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|yyerror
argument_list|(
literal|"Missing right brace on \\x{}"
argument_list|)
expr_stmt|;
name|e
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|STRLEN
name|len
init|=
literal|1
decl_stmt|;
comment|/* allow underscores */
name|uv
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|e
operator|-
name|s
operator|-
literal|1
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|to_be_utf8
operator|=
name|TRUE
expr_stmt|;
block|}
name|s
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
block|{
name|STRLEN
name|len
init|=
literal|0
decl_stmt|;
comment|/* disallow underscores */
name|uv
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|NUM_ESCAPE_INSERT
label|:
comment|/* Insert oct or hex escaped character. 		 * There will always enough room in sv since such 		 * escapes will be longer than any UT-F8 sequence 		 * they can end up as. */
comment|/* This spot is wrong for EBCDIC.  Characters like 		 * the lowercase letters and digits are>127 in EBCDIC, 		 * so here they would need to be mapped to the Unicode 		 * repertoire.   --jhi */
if|if
condition|(
name|uv
operator|>
literal|127
condition|)
block|{
if|if
condition|(
operator|!
name|has_utf8
operator|&&
operator|(
name|to_be_utf8
operator|||
name|uv
operator|>
literal|255
operator|)
condition|)
block|{
comment|/* Might need to recode whatever we have 			 * accumulated so far if it contains any 			 * hibit chars. 			 * 			 * (Can't we keep track of that and avoid 			 *  this rescan? --jhi) 			 */
name|int
name|hicount
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
init|;
name|c
operator|<
name|d
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|hicount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hicount
condition|)
block|{
name|char
modifier|*
name|old_pvx
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|d
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|hicount
operator|+
literal|1
argument_list|)
operator|+
operator|(
name|d
operator|-
name|old_pvx
operator|)
expr_stmt|;
name|src
operator|=
name|d
operator|-
literal|1
expr_stmt|;
name|d
operator|+=
name|hicount
expr_stmt|;
name|dst
operator|=
name|d
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|dst
condition|)
block|{
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
operator|*
name|dst
operator|--
operator|=
name|UTF8_EIGHT_BIT_LO
argument_list|(
operator|*
name|src
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|--
operator|=
name|UTF8_EIGHT_BIT_HI
argument_list|(
operator|*
name|src
operator|--
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|to_be_utf8
operator|||
name|has_utf8
operator|||
name|uv
operator|>
literal|255
condition|)
block|{
name|d
operator|=
operator|(
name|char
operator|*
operator|)
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|d
argument_list|,
name|uv
argument_list|)
expr_stmt|;
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|&&
name|PL_sublex_info
operator|.
name|sub_op
condition|)
block|{
name|PL_sublex_info
operator|.
name|sub_op
operator|->
name|op_private
operator||=
operator|(
name|PL_lex_repl
condition|?
name|OPpTRANS_FROM_UTF
else|:
name|OPpTRANS_TO_UTF
operator|)
expr_stmt|;
name|utf
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|char
operator|)
name|uv
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|char
operator|)
name|uv
expr_stmt|;
block|}
continue|continue;
comment|/* \N{latin small letter a} is a named character */
case|case
literal|'N'
case|:
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|e
init|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'}'
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|res
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|yyerror
argument_list|(
literal|"Missing right brace on \\N{}"
argument_list|)
expr_stmt|;
name|e
operator|=
name|s
operator|-
literal|1
expr_stmt|;
goto|goto
name|cont_scan
goto|;
block|}
name|res
operator|=
name|newSVpvn
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|e
operator|-
name|s
operator|-
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|new_constant
argument_list|(
name|Nullch
argument_list|,
literal|0
argument_list|,
literal|"charnames"
argument_list|,
name|res
argument_list|,
name|Nullsv
argument_list|,
literal|"\\N{...}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_utf8
condition|)
name|sv_utf8_upgrade
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|str
operator|=
name|SvPV
argument_list|(
name|res
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_utf8
operator|&&
name|SvUTF8
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ostart
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|d
operator|-
name|ostart
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|sv_utf8_upgrade
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* this just broke our allocation above... */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|send
operator|-
name|start
argument_list|)
expr_stmt|;
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|e
operator|-
name|s
operator|+
literal|4
condition|)
block|{
name|char
modifier|*
name|odest
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
operator|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|len
operator|-
operator|(
name|e
operator|-
name|s
operator|+
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
operator|(
name|d
operator|-
name|odest
operator|)
expr_stmt|;
block|}
name|Copy
argument_list|(
name|str
argument_list|,
name|d
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|len
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|cont_scan
label|:
name|s
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|yyerror
argument_list|(
literal|"Missing braces on \\N{}"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* \c is a control character */
case|case
literal|'c'
case|:
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|EBCDIC
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|d
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toUPPER
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
operator|*
name|d
operator|=
name|toCTRL
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
else|#
directive|else
block|{
name|U8
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
operator|*
name|d
operator|++
operator|=
name|toCTRL
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
comment|/* printf-style backslashes, formfeeds, newlines, etc */
case|case
literal|'b'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EBCDIC
case|case
literal|'e'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\047'
expr_stmt|;
comment|/* CP 1047 */
break|break;
case|case
literal|'a'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\057'
expr_stmt|;
comment|/* CP 1047 */
break|break;
else|#
directive|else
case|case
literal|'e'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\007'
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* end switch */
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* end if (backslash) */
name|default_action
label|:
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
name|this_utf8
operator|||
name|has_utf8
operator|)
condition|)
block|{
name|STRLEN
name|len
init|=
operator|(
name|STRLEN
operator|)
operator|-
literal|1
decl_stmt|;
name|UV
name|uv
decl_stmt|;
if|if
condition|(
name|this_utf8
condition|)
block|{
name|uv
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
name|send
operator|-
name|s
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
operator|(
name|STRLEN
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Illegal UTF8 (a high-bit byte), make it valid. */
name|char
modifier|*
name|old_pvx
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* need space for one extra char (NOTE: SvCUR() not set here) */
name|d
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
operator|(
name|d
operator|-
name|old_pvx
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|char
operator|*
operator|)
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|d
argument_list|,
operator|(
name|U8
operator|)
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|&&
name|PL_sublex_info
operator|.
name|sub_op
condition|)
block|{
name|PL_sublex_info
operator|.
name|sub_op
operator|->
name|op_private
operator||=
operator|(
name|PL_lex_repl
condition|?
name|OPpTRANS_FROM_UTF
else|:
name|OPpTRANS_TO_UTF
operator|)
expr_stmt|;
name|utf
operator|=
name|TRUE
expr_stmt|;
block|}
continue|continue;
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* while loop to process each character */
comment|/* terminate the string and set up the sv */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_utf8
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* shrink the sv if we allocated more than we used */
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/* return the substring (via yylval) only if we parsed anything */
if|if
condition|(
name|s
operator|>
name|PL_bufptr
condition|)
block|{
if|if
condition|(
name|PL_hints
operator|&
operator|(
name|PL_lex_inpat
condition|?
name|HINT_NEW_RE
else|:
name|HINT_NEW_STRING
operator|)
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|,
operator|(
name|PL_lex_inpat
condition|?
literal|"qr"
else|:
literal|"q"
operator|)
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
operator|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|?
literal|"tr"
else|:
operator|(
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
operator|!
name|PL_lex_inpat
operator|)
condition|?
literal|"s"
else|:
literal|"qq"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* S_intuit_more  * Returns TRUE if there's more to the expression (e.g., a subscript),  * FALSE otherwise.  *  * It deals with "$foo[3]" and /$foo[3]/ and /$foo[0123456789$]+/  *  * ->[ and ->{ return TRUE  * { and [ outside a pattern are always subscripts, so return TRUE  * if we're outside a pattern and it's not { or [, then return FALSE  * if we're in a pattern and the first char is a {  *   {4,5} (any digits around the comma) returns FALSE  * if we're in a pattern and the first char is a [  *   [] returns FALSE  *   [SOMETHING] has a funky algorithm to decide whether it's a  *      character class or not.  It has to deal with things like  *      /$foo[-3]/ and /$foo[$bar]/ as well as /$foo[$\d]+/  * anything else returns TRUE  */
end_comment

begin_comment
comment|/* This is the one truly awful dwimmer necessary to conflate C and sed. */
end_comment

begin_function
name|STATIC
name|int
name|S_intuit_more
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|PL_lex_brackets
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'>'
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'['
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'{'
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|*
name|s
operator|!=
literal|'['
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
return|return
name|TRUE
return|;
comment|/* In a pattern, so maybe we have {n,m}. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
comment|/* On the other hand, maybe we have a character class */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|']'
operator|||
operator|*
name|s
operator|==
literal|'^'
condition|)
return|return
name|FALSE
return|;
else|else
block|{
comment|/* this is terrifying, and it works */
name|int
name|weight
init|=
literal|2
decl_stmt|;
comment|/* let's weigh the evidence */
name|char
name|seen
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|un_char
init|=
literal|255
decl_stmt|,
name|last_un_char
decl_stmt|;
name|char
modifier|*
name|send
init|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
operator|*
literal|4
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|send
condition|)
comment|/* has to be an expression */
return|return
name|TRUE
return|;
name|Zero
argument_list|(
name|seen
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
name|weight
operator|-=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|']'
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
else|else
name|weight
operator|-=
literal|100
expr_stmt|;
block|}
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
block|{
name|last_un_char
operator|=
name|un_char
expr_stmt|;
name|un_char
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|isALNUM_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|scan_ident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
operator|>
literal|1
operator|&&
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PV
argument_list|)
condition|)
name|weight
operator|-=
literal|100
expr_stmt|;
else|else
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
literal|"[#!%*<>()-="
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
comment|/*{*/
name|strchr
argument_list|(
literal|"])} ="
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
else|else
name|weight
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
name|un_char
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"wds]"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|seen
index|[
literal|'\''
index|]
operator|||
name|seen
index|[
literal|'"'
index|]
condition|)
name|weight
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"rnftbxcav"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|weight
operator|+=
literal|40
expr_stmt|;
while|while
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
name|weight
operator|+=
literal|100
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|weight
operator|+=
literal|50
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"aA01! "
argument_list|,
name|last_un_char
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"zZ79~"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
if|if
condition|(
name|last_un_char
operator|==
literal|255
operator|&&
operator|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
name|weight
operator|-=
literal|5
expr_stmt|;
comment|/* cope with negative subscript */
break|break;
default|default:
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|last_un_char
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|"$@&"
argument_list|,
name|last_un_char
argument_list|)
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|d
init|=
name|tmpbuf
decl_stmt|;
while|while
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|d
operator|-
name|tmpbuf
argument_list|)
condition|)
name|weight
operator|-=
literal|150
expr_stmt|;
block|}
if|if
condition|(
name|un_char
operator|==
name|last_un_char
operator|+
literal|1
condition|)
name|weight
operator|+=
literal|5
expr_stmt|;
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
expr_stmt|;
break|break;
block|}
name|seen
index|[
name|un_char
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
operator|>=
literal|0
condition|)
comment|/* probably a character class */
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * S_intuit_method  *  * Does all the checking to disambiguate  *   foo bar  * between foo(bar) and bar->foo.  Returns 0 if not a method, otherwise  * FUNCMETH (bar->foo(args)) or METHOD (bar->foo args).  *  * First argument is the stuff after the first token, e.g. "bar".  *  * Not a method if bar is a filehandle.  * Not a method if foo is a subroutine prototyped to take a filehandle.  * Not a method if it's really "Foo $bar"  * Method if it's "foo $bar"  * Not a method if it's really "print foo $bar"  * Method if it's really "foo package::" (interpreted as package->foo)  * Not a method if bar is known to be a subroutne ("sub bar; foo bar")  * Not a method if bar is a filehandle or package, but is quoted with  *   =>  */
end_comment

begin_function
name|STATIC
name|int
name|S_intuit_method
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|start
operator|+
operator|(
operator|*
name|start
operator|==
literal|'$'
operator|)
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|GV
modifier|*
name|indirgv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|GvIO
argument_list|(
name|gv
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|proto
init|=
name|SvPVX
argument_list|(
name|cv
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
condition|)
block|{
if|if
condition|(
operator|*
name|proto
operator|==
literal|';'
condition|)
name|proto
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
literal|'*'
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
name|gv
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* start is the beginning of the possible filehandle/object,      * and s is the end of it      * tmpbuf is a copy of it      */
if|if
condition|(
operator|*
name|start
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|gv
operator|||
name|PL_last_lop_op
operator|==
name|OP_PRINT
operator|||
name|isUPPER
argument_list|(
operator|*
name|PL_tokenbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|start
expr_stmt|;
name|PL_expect
operator|=
name|XREF
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'('
condition|?
name|FUNCMETH
else|:
name|METHOD
return|;
block|}
if|if
condition|(
operator|!
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|len
operator|-=
literal|2
expr_stmt|;
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|bare_package
goto|;
block|}
name|indirgv
operator|=
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirgv
operator|&&
name|GvCVu
argument_list|(
name|indirgv
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* filehandle or package name makes it a method */
if|if
condition|(
operator|!
name|gv
operator|||
name|GvIO
argument_list|(
name|indirgv
argument_list|)
operator|||
name|gv_stashpvn
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_bufend
operator|-
name|s
operator|)
operator|>=
literal|2
operator|&&
operator|*
name|s
operator|==
literal|'='
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'>'
condition|)
return|return
literal|0
return|;
comment|/* no assumptions -- "=>" quotes bearword */
name|bare_package
label|:
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'('
condition|?
name|FUNCMETH
else|:
name|METHOD
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * S_incl_perldb  * Return a string of Perl code to load the debugger.  If PERL5DB  * is set, it will return the contents of that, otherwise a  * compile-time require of perl5db.pl.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_incl_perldb
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|if
condition|(
name|PL_perldb
condition|)
block|{
name|char
modifier|*
name|pdb
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL5DB"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdb
condition|)
return|return
name|pdb
return|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
return|return
literal|"BEGIN { require 'perl5db.pl' }"
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Encoded script support. filter_add() effectively inserts a  * 'pre-processing' function into the current source input stream.  * Note that the filter function only applies to the current source file  * (e.g., it will not affect files 'require'd or 'use'd by this one).  *  * The datasv parameter (which may be NULL) can be used to pass  * private data to this instance of the filter. The filter function  * can recover the SV using the FILTER_DATA macro and use it to  * store private buffers and state information.  *  * The supplied datasv parameter is upgraded to a PVIO type  * and the IoDIRP/IoANY field is used to store the function pointer,  * and IOf_FAKE_DIRP is enabled on datasv to mark this as such.  * Note that IoTOP_NAME, IoFMT_NAME, IoBOTTOM_NAME, if set for  * private use must be set using malloc'd pointers.  */
end_comment

begin_function
name|SV
modifier|*
name|Perl_filter_add
parameter_list|(
name|pTHX_
name|filter_t
name|funcp
parameter_list|,
name|SV
modifier|*
name|datasv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|funcp
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
name|PL_rsfp_filters
operator|=
name|newAV
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|datasv
condition|)
name|datasv
operator|=
name|NEWSV
argument_list|(
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvUPGRADE
argument_list|(
name|datasv
argument_list|,
name|SVt_PVIO
argument_list|)
condition|)
name|Perl_die
argument_list|(
name|aTHX_
literal|"Can't upgrade filter_add data to SVt_PVIO"
argument_list|)
expr_stmt|;
name|IoANY
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|funcp
expr_stmt|;
comment|/* stash funcp into spare field */
name|IoFLAGS
argument_list|(
name|datasv
argument_list|)
operator||=
name|IOf_FAKE_DIRP
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"filter_add func %p (%s)\n"
argument_list|,
name|funcp
argument_list|,
name|SvPV_nolen
argument_list|(
name|datasv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|av_unshift
argument_list|(
name|PL_rsfp_filters
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_rsfp_filters
argument_list|,
literal|0
argument_list|,
name|datasv
argument_list|)
expr_stmt|;
return|return
operator|(
name|datasv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete most recently added instance of this filter function.	*/
end_comment

begin_function
name|void
name|Perl_filter_del
parameter_list|(
name|pTHX_
name|filter_t
name|funcp
parameter_list|)
block|{
name|SV
modifier|*
name|datasv
decl_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"filter_del func %p"
argument_list|,
name|funcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_rsfp_filters
operator|||
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* if filter is on top of stack (usual case) just pop it off */
name|datasv
operator|=
name|FILTER_DATA
argument_list|(
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoANY
argument_list|(
name|datasv
argument_list|)
operator|==
operator|(
name|void
operator|*
operator|)
name|funcp
condition|)
block|{
name|IoFLAGS
argument_list|(
name|datasv
argument_list|)
operator|&=
operator|~
name|IOf_FAKE_DIRP
expr_stmt|;
name|IoANY
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|NULL
expr_stmt|;
name|sv_free
argument_list|(
name|av_pop
argument_list|(
name|PL_rsfp_filters
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we need to search for the correct entry and clear it	*/
name|Perl_die
argument_list|(
name|aTHX_
literal|"filter_del can only delete in reverse order (currently)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invoke the n'th filter function for the current rsfp.	 */
end_comment

begin_function
name|I32
name|Perl_filter_read
parameter_list|(
name|pTHX_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
comment|/* 0 = read one text line */
block|{
name|filter_t
name|funcp
decl_stmt|;
name|SV
modifier|*
name|datasv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|idx
operator|>
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
condition|)
block|{
comment|/* Any more filters?	*/
comment|/* Provide a default input filter to make life easy.	*/
comment|/* Note that we append to the line. This is handy.	*/
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"filter_read %d: from rsfp\n"
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlen
condition|)
block|{
comment|/* Want a block */
name|int
name|len
decl_stmt|;
name|int
name|old_len
init|=
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
decl_stmt|;
comment|/* ensure buf_sv is large enough */
name|SvGROW
argument_list|(
name|buf_sv
argument_list|,
name|old_len
operator|+
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|PerlIO_read
argument_list|(
name|PL_rsfp
argument_list|,
name|SvPVX
argument_list|(
name|buf_sv
argument_list|)
operator|+
name|old_len
argument_list|,
name|maxlen
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PerlIO_error
argument_list|(
name|PL_rsfp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error */
else|else
return|return
literal|0
return|;
comment|/* end of file */
block|}
name|SvCUR_set
argument_list|(
name|buf_sv
argument_list|,
name|old_len
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Want a line */
if|if
condition|(
name|sv_gets
argument_list|(
name|buf_sv
argument_list|,
name|PL_rsfp
argument_list|,
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|PerlIO_error
argument_list|(
name|PL_rsfp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error */
else|else
return|return
literal|0
return|;
comment|/* end of file */
block|}
block|}
return|return
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
return|;
block|}
comment|/* Skip this filter slot if filter has been deleted	*/
if|if
condition|(
operator|(
name|datasv
operator|=
name|FILTER_DATA
argument_list|(
name|idx
argument_list|)
operator|)
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"filter_read %d: skipped (filter deleted)\n"
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|buf_sv
argument_list|,
name|maxlen
argument_list|)
return|;
comment|/* recurse */
block|}
comment|/* Get function pointer hidden within datasv	*/
name|funcp
operator|=
operator|(
name|filter_t
operator|)
name|IoANY
argument_list|(
name|datasv
argument_list|)
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"filter_read %d: via function %p (%s)\n"
argument_list|,
name|idx
argument_list|,
name|funcp
argument_list|,
name|SvPV_nolen
argument_list|(
name|datasv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call function. The function is expected to 	*/
comment|/* call "FILTER_READ(idx+1, buf_sv)" first.		*/
comment|/* Return:<0:error, =0:eof,>0:not eof 		*/
return|return
operator|(
operator|*
name|funcp
operator|)
operator|(
name|aTHXo_
name|idx
operator|,
name|buf_sv
operator|,
name|maxlen
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_filter_gets
parameter_list|(
name|pTHX_
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|STRLEN
name|append
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PERL_CR_FILTER
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
block|{
name|filter_add
argument_list|(
name|S_cr_textfilter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|PL_rsfp_filters
condition|)
block|{
if|if
condition|(
operator|!
name|append
condition|)
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start with empty line	*/
if|if
condition|(
name|FILTER_READ
argument_list|(
literal|0
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
return|;
else|else
return|return
name|Nullch
return|;
block|}
else|else
return|return
operator|(
name|sv_gets
argument_list|(
name|sv
argument_list|,
name|fp
argument_list|,
name|append
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|HV
modifier|*
name|S_find_in_my_stash
parameter_list|(
name|pTHX_
name|char
modifier|*
name|pkgname
parameter_list|,
name|I32
name|len
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|11
operator|&&
operator|*
name|pkgname
operator|==
literal|'_'
operator|&&
name|strEQ
argument_list|(
name|pkgname
argument_list|,
literal|"__PACKAGE__"
argument_list|)
condition|)
return|return
name|PL_curstash
return|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|pkgname
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|pkgname
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|pkgname
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVHV
argument_list|)
operator|)
condition|)
block|{
return|return
name|GvHV
argument_list|(
name|gv
argument_list|)
return|;
comment|/* Foo:: */
block|}
comment|/* use constant CLASS => 'MyClass' */
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|pkgname
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|(
name|sv
operator|=
name|cv_const_sv
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|pkgname
operator|=
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gv_stashpv
argument_list|(
name|pkgname
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|exp_name
index|[]
init|=
block|{
literal|"OPERATOR"
block|,
literal|"TERM"
block|,
literal|"REF"
block|,
literal|"STATE"
block|,
literal|"BLOCK"
block|,
literal|"ATTRBLOCK"
block|,
literal|"ATTRTERM"
block|,
literal|"TERMBLOCK"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   yylex    Works out what to call the token just pulled out of the input   stream.  The yacc parser takes care of taking the ops we return and   stitching them into a tree.    Returns:     PRIVATEREF    Structure:       if read an identifier           if we're in a my declaration 	      croak if they tried to say my($foo::bar) 	      build the ops for a my() declaration 	  if it's an access to a my() variable 	      are we in a sort block? 	          croak if my($a); $a<=> $b 	      build ops for access to a my() variable 	  if in a dq string, and they've said @foo and we can't find @foo 	      croak 	  build ops for a bareword       if we already built the token before, use it. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PURE_BISON
end_ifdef

begin_function
name|int
name|Perl_yylex_r
parameter_list|(
name|pTHX_
name|YYSTYPE
modifier|*
name|lvalp
parameter_list|,
name|int
modifier|*
name|lcharp
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|yyactlevel
operator|++
expr_stmt|;
name|yylval_pointer
index|[
name|yyactlevel
index|]
operator|=
name|lvalp
expr_stmt|;
name|yychar_pointer
index|[
name|yyactlevel
index|]
operator|=
name|lcharp
expr_stmt|;
if|if
condition|(
name|yyactlevel
operator|>=
name|YYMAXLEVEL
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: YYMAXLEVEL"
argument_list|)
expr_stmt|;
name|r
operator|=
name|Perl_yylex
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
name|yyactlevel
operator|--
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__SC__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|segment
name|Perl_yylex
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|Perl_yylex
parameter_list|(
name|pTHX
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
name|Nullgv
decl_stmt|;
name|GV
modifier|*
modifier|*
name|gvp
init|=
literal|0
decl_stmt|;
name|bool
name|bof
init|=
name|FALSE
decl_stmt|;
comment|/* check if there's an identifier for us to look at */
if|if
condition|(
name|PL_pending_ident
condition|)
block|{
comment|/* pit holds the identifier we read and pending_ident is reset */
name|char
name|pit
init|=
name|PL_pending_ident
decl_stmt|;
name|PL_pending_ident
operator|=
literal|0
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Tokener saw identifier '%s'\n"
argument|, PL_tokenbuf); }
argument_list|)
comment|/* if we're in a my(), we can't allow dynamics here. 	   $foo'bar has already been turned into $foo::bar, so 	   just check for colons.  	   if it's a legal name, the OP is a PADANY. 	*/
if|if
condition|(
name|PL_in_my
condition|)
block|{
if|if
condition|(
name|PL_in_my
operator|==
name|KEY_our
condition|)
block|{
comment|/* "our" is merely analogous to "my" */
if|if
condition|(
name|strchr
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"No package name allowed for "
literal|"variable %s in \"our\""
argument_list|,
name|PL_tokenbuf
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|pad_allocmy
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
argument|aTHX_ PL_no_myglob
argument_list|,
argument|PL_tokenbuf
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_PADANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|pad_allocmy
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
block|}
comment|/* 	   build the ops for accesses to a my() variable.  	   Deny my($a) or my($b) in a sort block, *if* $a or $b is 	   then used in a comparison.  This catches most, but not 	   all cases.  For instance, it catches 	       sort { my($a); $a<=> $b } 	   but not 	       sort { my($a); $a< $b ? -1 : $a == $b ? 0 : 1; } 	   (although why you'd do that is anyone's guess). 	*/
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
comment|/* Check for single character per-thread SVs */
if|if
condition|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|isALPHA
argument_list|(
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
comment|/* Rule out obvious non-threadsvs */
operator|&&
operator|(
name|tmp
operator|=
name|find_threadsv
argument_list|(
operator|&
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|(
name|tmp
operator|=
name|pad_findmy
argument_list|(
name|PL_tokenbuf
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|SV
modifier|*
name|namesv
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
index|[
name|tmp
index|]
decl_stmt|;
comment|/* might be an "our" variable" */
if|if
condition|(
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator|&
name|SVpad_OUR
condition|)
block|{
comment|/* build ops for a bareword */
name|SV
modifier|*
name|sym
init|=
name|newSVpv
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|namesv
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_catpvn
argument_list|(
name|sym
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sym
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_ENTERED
expr_stmt|;
name|gv_fetchpv
argument_list|(
name|SvPVX
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|PL_in_eval
condition|?
operator|(
name|GV_ADDMULTI
operator||
name|GV_ADDINEVAL
operator|)
else|:
name|TRUE
operator|)
argument_list|,
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
condition|?
name|SVt_PV
else|:
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|?
name|SVt_PVAV
else|:
name|SVt_PVHV
operator|)
argument_list|)
expr_stmt|;
return|return
name|WORD
return|;
block|}
comment|/* if it's a sort block and they're naming $a or $b */
if|if
condition|(
name|PL_last_lop_op
operator|==
name|OP_SORT
operator|&&
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
operator|(
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'a'
operator|||
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|!
name|PL_tokenbuf
index|[
literal|2
index|]
condition|)
block|{
for|for
control|(
name|d
operator|=
name|PL_in_eval
condition|?
name|PL_oldoldbufptr
else|:
name|PL_linestart
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|!=
literal|'\n'
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"<=>"
argument_list|,
literal|3
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"cmp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use \"my %s\" in sort comparison"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_PADANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
block|}
comment|/* 	   Whine if they've said @foo in a doublequoted string, 	   and @foo isn't a variable we can find in the symbol 	   table. 	*/
if|if
condition|(
name|pit
operator|==
literal|'@'
operator|&&
name|PL_lex_state
operator|!=
name|LEX_NORMAL
operator|&&
operator|!
name|PL_lex_brackets
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|gv
operator|||
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|?
operator|!
name|GvAV
argument_list|(
name|gv
argument_list|)
else|:
operator|!
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|)
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
condition|)
block|{
comment|/* Downgraded from fatal to warning 20000522 mjd */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Possible unintended interpolation of %s in string"
argument_list|,
argument|PL_tokenbuf
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* build ops for a bareword */
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_ENTERED
expr_stmt|;
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
name|PL_in_eval
condition|?
operator|(
name|GV_ADDMULTI
operator||
name|GV_ADDINEVAL
operator|)
else|:
name|TRUE
argument_list|,
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
condition|?
name|SVt_PV
else|:
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|?
name|SVt_PVAV
else|:
name|SVt_PVHV
operator|)
argument_list|)
expr_stmt|;
return|return
name|WORD
return|;
block|}
comment|/* no identifier pending identification */
switch|switch
condition|(
name|PL_lex_state
condition|)
block|{
ifdef|#
directive|ifdef
name|COMMENTARY
case|case
name|LEX_NORMAL
case|:
comment|/* Some compilers will produce faster */
case|case
name|LEX_INTERPNORMAL
case|:
comment|/* code if we comment these out. */
break|break;
endif|#
directive|endif
comment|/* when we've already built the next token, just pull it out of the queue */
case|case
name|LEX_KNOWNEXT
case|:
name|PL_nexttoke
operator|--
expr_stmt|;
name|yylval
operator|=
name|PL_nextval
index|[
name|PL_nexttoke
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|PL_nexttoke
condition|)
block|{
name|PL_lex_state
operator|=
name|PL_lex_defer
expr_stmt|;
name|PL_expect
operator|=
name|PL_lex_expect
expr_stmt|;
name|PL_lex_defer
operator|=
name|LEX_NORMAL
expr_stmt|;
block|}
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Next token after '%s' was known, type %"
argument|IVdf
literal|"\n"
argument|, PL_bufptr,               (IV)PL_nexttype[PL_nexttoke]); }
argument_list|)
return|return
operator|(
name|PL_nexttype
index|[
name|PL_nexttoke
index|]
operator|)
return|;
comment|/* interpolated case modifiers like \L \U, including \Q and \E.        when we get here, PL_bufptr is at the \     */
case|case
name|LEX_INTERPCASEMOD
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
operator|&&
operator|*
name|PL_bufptr
operator|!=
literal|'\\'
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: INTERPCASEMOD"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* handle \E or end of string */
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
operator|||
name|PL_bufptr
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|char
name|oldmod
decl_stmt|;
comment|/* if at a \E */
if|if
condition|(
name|PL_lex_casemods
condition|)
block|{
name|oldmod
operator|=
name|PL_lex_casestack
index|[
operator|--
name|PL_lex_casemods
index|]
expr_stmt|;
name|PL_lex_casestack
index|[
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
operator|&&
name|strchr
argument_list|(
literal|"LUQ"
argument_list|,
name|oldmod
argument_list|)
condition|)
block|{
name|PL_bufptr
operator|+=
literal|2
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
block|}
return|return
literal|')'
return|;
block|}
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
condition|)
name|PL_bufptr
operator|+=
literal|2
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
else|else
block|{
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw case modifier at '%s'\n"
argument|, PL_bufptr); }
argument_list|)
name|s
operator|=
name|PL_bufptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"L\\u"
argument_list|,
literal|3
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"U\\l"
argument_list|,
literal|3
argument_list|)
condition|)
name|tmp
operator|=
operator|*
name|s
operator|,
operator|*
name|s
operator|=
name|s
index|[
literal|2
index|]
operator|,
name|s
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* misordered... */
if|if
condition|(
name|strchr
argument_list|(
literal|"LU"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|PL_lex_casestack
argument_list|,
literal|'L'
argument_list|)
operator|||
name|strchr
argument_list|(
name|PL_lex_casestack
argument_list|,
literal|'U'
argument_list|)
operator|)
condition|)
block|{
name|PL_lex_casestack
index|[
operator|--
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|')'
return|;
block|}
if|if
condition|(
name|PL_lex_casemods
operator|>
literal|10
condition|)
block|{
name|char
modifier|*
name|newlb
init|=
name|Renew
argument_list|(
name|PL_lex_casestack
argument_list|,
name|PL_lex_casemods
operator|+
literal|2
argument_list|,
name|char
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlb
operator|!=
name|PL_lex_casestack
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|newlb
argument_list|)
expr_stmt|;
name|PL_lex_casestack
operator|=
name|newlb
expr_stmt|;
block|}
block|}
name|PL_lex_casestack
index|[
name|PL_lex_casemods
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|PL_lex_casestack
index|[
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'l'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_LCFIRST
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'u'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_UCFIRST
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'L'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_LC
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'U'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_UC
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'Q'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_QUOTEMETA
expr_stmt|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: yylex"
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|force_next
argument_list|(
name|FUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_starts
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|yylex
argument_list|()
return|;
block|}
case|case
name|LEX_INTERPPUSH
case|:
return|return
name|sublex_push
argument_list|()
return|;
case|case
name|LEX_INTERPSTART
case|:
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
condition|)
return|return
name|sublex_done
argument_list|()
return|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Interpolated variable at '%s'\n"
argument|, PL_bufptr); }
argument_list|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|PL_lex_dojoin
operator|=
operator|(
operator|*
name|PL_bufptr
operator|==
literal|'@'
operator|)
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
if|if
condition|(
name|PL_lex_dojoin
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|','
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
name|PRIVATEREF
argument_list|)
expr_stmt|;
else|#
directive|else
name|force_ident
argument_list|(
literal|"\""
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_JOIN
expr_stmt|;
comment|/* emulate join($", ...) */
name|force_next
argument_list|(
name|FUNC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_lex_starts
operator|++
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
return|return
name|yylex
argument_list|()
return|;
case|case
name|LEX_INTERPENDMAYBE
case|:
if|if
condition|(
name|intuit_more
argument_list|(
name|PL_bufptr
argument_list|)
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
comment|/* false alarm, more expr */
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|LEX_INTERPEND
case|:
if|if
condition|(
name|PL_lex_dojoin
condition|)
block|{
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
return|return
literal|')'
return|;
block|}
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
name|PL_linestr
operator|==
name|PL_lex_repl
operator|&&
name|SvEVALED
argument_list|(
name|PL_lex_repl
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad evalled substitution pattern"
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|LEX_INTERPCONCAT
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|PL_lex_brackets
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: INTERPCONCAT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
condition|)
return|return
name|sublex_done
argument_list|()
return|;
if|if
condition|(
name|SvIVX
argument_list|(
name|PL_linestr
argument_list|)
operator|==
literal|'\''
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
name|sv
operator|=
name|tokeq
argument_list|(
name|sv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_RE
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"qr"
argument_list|,
name|sv
argument_list|,
name|sv
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|PL_bufend
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|scan_const
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPCASEMOD
expr_stmt|;
else|else
name|PL_lex_state
operator|=
name|LEX_INTERPSTART
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|PL_bufptr
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|=
name|yylval
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_starts
operator|++
condition|)
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
else|else
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
block|}
return|return
name|yylex
argument_list|()
return|;
case|case
name|LEX_FORMLINE
case|:
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|s
operator|=
name|scan_formline
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_lex_formbrack
condition|)
goto|goto
name|rightbracket
goto|;
name|OPERATOR
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_oldbufptr
operator|=
name|s
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ 	PerlIO_printf(Perl_debug_log,
literal|"### Tokener expecting %s at %s\n"
argument|, 		      exp_name[PL_expect], s);     }
argument_list|)
name|retry
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
goto|goto
name|keylookup
goto|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unrecognized character \\x%02X"
argument_list|,
operator|*
name|s
operator|&
literal|255
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
case|case
literal|26
case|:
goto|goto
name|fake_eof
goto|;
comment|/* emulate EOF on ^D or ^Z */
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|PL_rsfp
condition|)
block|{
name|PL_last_uni
operator|=
literal|0
expr_stmt|;
name|PL_last_lop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
condition|)
name|yyerror
argument_list|(
literal|"Missing right curly or square bracket"
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Tokener got EOF\n"
argument|);             }
argument_list|)
name|TOKEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|++
operator|<
name|PL_bufend
condition|)
goto|goto
name|retry
goto|;
comment|/* ignore stray nulls */
name|PL_last_uni
operator|=
literal|0
expr_stmt|;
name|PL_last_lop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_eval
operator|&&
operator|!
name|PL_preambled
condition|)
block|{
name|PL_preambled
operator|=
name|TRUE
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|incl_perldb
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_preambleav
condition|)
block|{
while|while
condition|(
name|AvFILLp
argument_list|(
name|PL_preambleav
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
name|tmpsv
init|=
name|av_shift
argument_list|(
name|PL_preambleav
argument_list|)
decl_stmt|;
name|sv_catsv
argument_list|(
name|PL_linestr
argument_list|,
name|tmpsv
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|sv_free
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
block|}
name|sv_free
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_preambleav
argument_list|)
expr_stmt|;
name|PL_preambleav
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|PL_minus_n
operator|||
name|PL_minus_p
condition|)
block|{
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"LINE: while (<>) {"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_l
condition|)
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"chomp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_a
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
literal|"::F"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
condition|)
name|GvIMPORTED_AV_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_F
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"/'\""
argument_list|,
operator|*
name|PL_splitstr
argument_list|)
operator|&&
name|strchr
argument_list|(
name|PL_splitstr
operator|+
literal|1
argument_list|,
operator|*
name|PL_splitstr
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_linestr
argument_list|,
literal|"@F=split(%s);"
argument_list|,
argument|PL_splitstr
argument_list|)
empty_stmt|;
else|else
block|{
name|char
name|delim
decl_stmt|;
name|s
operator|=
literal|"'~#\200\1'"
expr_stmt|;
comment|/* surely one char is unused...*/
while|while
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|PL_splitstr
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|delim
operator|=
operator|*
name|s
expr_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_linestr
argument_list|,
literal|"@F=split(%s%c"
argument_list|,
literal|"q"
argument|+ (delim ==
literal|'\''
argument|)
argument_list|,
argument|delim
argument_list|)
empty_stmt|;
for|for
control|(
name|s
operator|=
name|PL_splitstr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|"\\"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_linestr
argument_list|,
literal|"%c);"
argument_list|,
argument|delim
argument_list|)
empty_stmt|;
block|}
block|}
else|else
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"@F=split(' ');"
argument_list|)
expr_stmt|;
block|}
block|}
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
block|}
do|do
block|{
name|bof
operator|=
name|PL_rsfp
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
name|fake_eof
label|:
if|if
condition|(
name|PL_rsfp
condition|)
block|{
if|if
condition|(
name|PL_preprocess
operator|&&
operator|!
name|PL_in_eval
condition|)
operator|(
name|void
operator|)
name|PerlProc_pclose
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PL_in_eval
operator|&&
operator|(
name|PL_minus_n
operator|||
name|PL_minus_p
operator|)
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|PL_minus_p
condition|?
literal|";}continue{print"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";}"
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|PL_minus_n
operator|=
name|PL_minus_p
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
comment|/* not infinite loop because rsfp is NULL now */
block|}
comment|/* if it looks like the start of a BOM, check if it in fact is */
elseif|else
if|if
condition|(
name|bof
operator|&&
operator|(
operator|!
operator|*
name|s
operator|||
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|==
literal|0xEF
operator|||
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|>=
literal|0xFE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PERLIO_IS_STDIO
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
if|#
directive|if
name|__GNU_LIBRARY__
operator|==
literal|1
comment|/* Linux glibc5 */
define|#
directive|define
name|FTELL_FOR_PIPE_IS_BROKEN
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|__GLIBC__
if|#
directive|if
name|__GLIBC__
operator|==
literal|1
comment|/* maybe some glibc5 release had it like this? */
define|#
directive|define
name|FTELL_FOR_PIPE_IS_BROKEN
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FTELL_FOR_PIPE_IS_BROKEN
comment|/* This loses the possibility to detect the bof 		 * situation on perl -P when the libc5 is being used. 		 * Workaround?  Maybe attach some extra state to PL_rsfp? 		 */
if|if
condition|(
operator|!
name|PL_preprocess
condition|)
name|bof
operator|=
name|PerlIO_tell
argument_list|(
name|PL_rsfp
argument_list|)
operator|==
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
else|#
directive|else
name|bof
operator|=
name|PerlIO_tell
argument_list|(
name|PL_rsfp
argument_list|)
operator|==
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bof
condition|)
block|{
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|s
operator|=
name|swallow_bom
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_doextract
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'!'
operator|&&
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
condition|)
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
comment|/* Incest with pod. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=cut"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|PL_doextract
condition|)
do|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
comment|/* for csh execing sh scripts */
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_eval
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'!'
condition|)
name|d
operator|=
name|s
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
else|else
block|{
specifier|static
name|char
name|as
index|[]
init|=
name|ALTERNATE_SHEBANG
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|as
index|[
literal|0
index|]
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
name|as
argument_list|,
sizeof|sizeof
argument_list|(
name|as
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|d
operator|=
name|s
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|as
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTERNATE_SHEBANG */
block|}
if|if
condition|(
name|d
condition|)
block|{
name|char
modifier|*
name|ipath
decl_stmt|;
name|char
modifier|*
name|ipathend
decl_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|ipath
operator|=
name|d
expr_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|ipathend
operator|=
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|ARG_ZERO_IS_SCRIPT
if|if
condition|(
name|ipathend
operator|>
name|ipath
condition|)
block|{
comment|/* 		     * HP-UX (at least) sets argv[0] to the script name, 		     * which makes $^X incorrect.  And Digital UNIX and Linux, 		     * at least, set argv[0] to the basename of the Perl 		     * interpreter. So, having found "#!", we'll set it right. 		     */
name|SV
modifier|*
name|x
init|=
name|GvSV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"\030"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|SvPOK
argument_list|(
name|x
argument_list|)
operator|||
name|SvGMAGICAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv_eq
argument_list|(
name|x
argument_list|,
name|CopFILESV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|x
argument_list|,
name|ipath
argument_list|,
name|ipathend
operator|-
name|ipath
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
comment|/* $^X is always tainted, but that's OK */
block|}
endif|#
directive|endif
comment|/* ARG_ZERO_IS_SCRIPT */
comment|/* 		 * Look for options. 		 */
name|d
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl -"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
comment|/* avoid getting into infinite loops when shebang 		     * line contains "Perl" rather than "perl" */
if|if
condition|(
operator|!
name|d
condition|)
block|{
for|for
control|(
name|d
operator|=
name|ipathend
operator|-
literal|4
init|;
name|d
operator|>=
name|ipath
condition|;
operator|--
name|d
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|d
operator|==
literal|'p'
operator|||
operator|*
name|d
operator|==
literal|'P'
operator|)
operator|&&
operator|!
name|ibcmp
argument_list|(
name|d
argument_list|,
literal|"perl"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|<
name|ipath
condition|)
name|d
operator|=
name|Nullch
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
comment|/* 		 * If the ALTERNATE_SHEBANG on this system starts with a 		 * character that can be part of a Perl expression, then if 		 * we see it but not "perl", we're probably looking at the 		 * start of Perl code, not a request to hand off to some 		 * other interpreter.  Similarly, if "perl" is there, but 		 * not in the first 'word' of the line, we assume the line 		 * contains the start of the Perl program. 		 */
if|if
condition|(
name|d
operator|&&
operator|*
name|s
operator|!=
literal|'#'
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|ipath
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|!
name|strchr
argument_list|(
literal|"; \t\r\n\f\v#"
argument_list|,
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|d
condition|)
name|d
operator|=
name|Nullch
expr_stmt|;
comment|/* "perl" not in first word; ignore */
else|else
operator|*
name|s
operator|=
literal|'#'
expr_stmt|;
comment|/* Don't try to parse shebang line */
block|}
endif|#
directive|endif
comment|/* ALTERNATE_SHEBANG */
ifndef|#
directive|ifndef
name|MACOS_TRADITIONAL
if|if
condition|(
operator|!
name|d
operator|&&
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|ipathend
operator|>
name|ipath
operator|&&
operator|!
name|PL_minus_c
operator|&&
operator|!
name|instr
argument_list|(
name|s
argument_list|,
literal|"indir"
argument_list|)
operator|&&
name|instr
argument_list|(
name|PL_origargv
index|[
literal|0
index|]
argument_list|,
literal|"perl"
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|newargv
decl_stmt|;
operator|*
name|ipathend
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|ipathend
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
name|Newz
argument_list|(
literal|899
argument_list|,
name|newargv
argument_list|,
name|PL_origargc
operator|+
literal|3
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|newargv
index|[
literal|1
index|]
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|Copy
argument_list|(
name|PL_origargv
operator|+
literal|1
argument_list|,
name|newargv
operator|+
literal|2
argument_list|,
name|PL_origargc
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|newargv
operator|=
name|PL_origargv
expr_stmt|;
name|newargv
index|[
literal|0
index|]
operator|=
name|ipath
expr_stmt|;
name|PerlProc_execv
argument_list|(
name|ipath
argument_list|,
name|EXEC_ARGV_CAST
argument_list|(
name|newargv
argument_list|)
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't exec %s"
argument_list|,
name|ipath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
condition|)
block|{
name|U32
name|oldpdb
init|=
name|PL_perldb
decl_stmt|;
name|bool
name|oldn
init|=
name|PL_minus_n
decl_stmt|;
name|bool
name|oldp
init|=
name|PL_minus_p
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|SPACE_OR_TAB
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|==
literal|'-'
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'M'
operator|||
operator|*
name|d
operator|==
literal|'m'
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Too late for \"-%.*s\" option"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|d
operator|-
name|m
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|moreswitches
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|d
condition|)
do|;
if|if
condition|(
operator|(
name|PERLDB_LINE
operator|&&
operator|!
name|oldpdb
operator|)
operator|||
operator|(
operator|(
name|PL_minus_n
operator|||
name|PL_minus_p
operator|)
operator|&&
operator|!
operator|(
name|oldn
operator|||
name|oldp
operator|)
operator|)
condition|)
comment|/* if we have already added "LINE: while (<>) {", 			         we must not do it again */
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
name|PL_preambled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
condition|)
operator|(
name|void
operator|)
name|gv_fetchfile
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'\r'
case|:
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
name|Perl_warn
argument_list|(
name|aTHX_
literal|"Illegal character \\%03o (carriage return)"
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"\t(Maybe you didn't strip carriage returns after a network transfer?)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|013
case|:
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
case|case
literal|'\312'
case|:
endif|#
directive|endif
name|s
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'#'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_NORMAL
operator|||
operator|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|s
operator|==
name|PL_linestart
operator|&&
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
comment|/* handle eval qq[#line 1 "foo"\n ...] */
name|CopLINE_dec
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|PL_bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|d
condition|)
name|s
operator|++
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
block|}
else|else
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|PL_bufend
operator|=
name|s
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isALNUM
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|I32
name|ftst
init|=
literal|0
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|s
operator|=
name|force_word
argument_list|(
name|PL_bufptr
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw unary minus before =>, forcing word '%s'\n"
argument|, s);                 }
argument_list|)
name|OPERATOR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* unary minus */
block|}
name|PL_last_uni
operator|=
name|PL_oldbufptr
expr_stmt|;
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
literal|'r'
case|:
name|ftst
operator|=
name|OP_FTEREAD
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ftst
operator|=
name|OP_FTEWRITE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ftst
operator|=
name|OP_FTEEXEC
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ftst
operator|=
name|OP_FTEOWNED
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|ftst
operator|=
name|OP_FTRREAD
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|ftst
operator|=
name|OP_FTRWRITE
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|ftst
operator|=
name|OP_FTREXEC
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|ftst
operator|=
name|OP_FTROWNED
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ftst
operator|=
name|OP_FTIS
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ftst
operator|=
name|OP_FTZERO
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ftst
operator|=
name|OP_FTSIZE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ftst
operator|=
name|OP_FTFILE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ftst
operator|=
name|OP_FTDIR
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ftst
operator|=
name|OP_FTLINK
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ftst
operator|=
name|OP_FTPIPE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ftst
operator|=
name|OP_FTSOCK
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ftst
operator|=
name|OP_FTSUID
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|ftst
operator|=
name|OP_FTSGID
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|ftst
operator|=
name|OP_FTSVTX
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ftst
operator|=
name|OP_FTBLK
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ftst
operator|=
name|OP_FTCHR
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ftst
operator|=
name|OP_FTTTY
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ftst
operator|=
name|OP_FTTEXT
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|ftst
operator|=
name|OP_FTBINARY
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'A'
case|:
case|case
literal|'C'
case|:
name|gv_fetchpv
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
literal|'M'
case|:
name|ftst
operator|=
name|OP_FTMTIME
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|ftst
operator|=
name|OP_FTATIME
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|ftst
operator|=
name|OP_FTCTIME
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unrecognized file test: -%c"
argument_list|,
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|PL_last_lop_op
operator|=
name|ftst
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw file test %c\n"
argument|, (int)ftst); 	    }
argument_list|)
name|FTST
argument_list|(
name|ftst
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|TERM
argument_list|(
name|POSTDEC
argument_list|)
expr_stmt|;
else|else
name|OPERATOR
argument_list|(
name|PREDEC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|METHOD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
name|OPERATOR
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
else|else
name|TERM
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Aop
argument_list|(
name|OP_SUBTRACT
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|PL_bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* unary minus */
block|}
case|case
literal|'+'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|TERM
argument_list|(
name|POSTINC
argument_list|)
expr_stmt|;
else|else
name|OPERATOR
argument_list|(
name|PREINC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Aop
argument_list|(
name|OP_ADD
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|PL_bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
case|case
literal|'*'
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_ident
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|PL_tokenbuf
condition|)
name|PREREF
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|PWop
argument_list|(
name|OP_POW
argument_list|)
expr_stmt|;
block|}
name|Mop
argument_list|(
name|OP_MULTIPLY
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
operator|++
name|s
expr_stmt|;
name|Mop
argument_list|(
name|OP_MODULO
argument_list|)
expr_stmt|;
block|}
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final % should be \\% or %name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
name|PL_pending_ident
operator|=
literal|'%'
expr_stmt|;
name|TERM
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
name|s
operator|++
expr_stmt|;
name|BOop
argument_list|(
name|OP_BIT_XOR
argument_list|)
expr_stmt|;
case|case
literal|'['
case|:
name|PL_lex_brackets
operator|++
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'~'
case|:
case|case
literal|','
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|':'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
goto|goto
name|just_a_word
goto|;
block|}
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|PL_expect
condition|)
block|{
name|OP
modifier|*
name|attrs
decl_stmt|;
case|case
name|XOPERATOR
case|:
if|if
condition|(
operator|!
name|PL_in_my
operator|||
name|PL_lex_state
operator|!=
name|LEX_NORMAL
condition|)
break|break;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
comment|/* update in case we back off */
goto|goto
name|grabattrs
goto|;
case|case
name|XATTRBLOCK
case|:
name|PL_expect
operator|=
name|XBLOCK
expr_stmt|;
goto|goto
name|grabattrs
goto|;
case|case
name|XATTRTERM
case|:
name|PL_expect
operator|=
name|XTERMBLOCK
expr_stmt|;
name|grabattrs
label|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|Nullop
expr_stmt|;
while|while
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|d
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|(
name|tmp
operator|=
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
name|KEY_or
case|:
case|case
name|KEY_and
case|:
case|case
name|KEY_for
case|:
case|case
name|KEY_unless
case|:
case|case
name|KEY_if
case|:
case|case
name|KEY_while
case|:
case|case
name|KEY_until
case|:
goto|goto
name|got_attrs
goto|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'('
condition|)
block|{
name|d
operator|=
name|scan_str
argument_list|(
name|d
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
comment|/* MUST advance bufptr here to avoid bogus 			   "at end of line" context messages from yyerror(). 			 */
name|PL_bufptr
operator|=
name|s
operator|+
name|len
expr_stmt|;
name|yyerror
argument_list|(
literal|"Unterminated attribute parameter in attribute list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|op_free
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* EOF indicator */
block|}
block|}
if|if
condition|(
name|PL_lex_stuff
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|sv_catsv
argument_list|(
name|sv
argument_list|,
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|attrs
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PL_in_my
operator|&&
name|len
operator|==
literal|6
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"lvalue"
argument_list|,
name|len
argument_list|)
condition|)
name|CvLVALUE_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|PL_in_my
operator|&&
name|len
operator|==
literal|6
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"locked"
argument_list|,
name|len
argument_list|)
condition|)
name|CvLOCKED_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|PL_in_my
operator|&&
name|len
operator|==
literal|6
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"method"
argument_list|,
name|len
argument_list|)
condition|)
name|CvMETHOD_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
comment|/* After we've set the flags, it could be argued that 		       we don't need to do the attributes.pm-based setting 		       process, and shouldn't bother appending recognized 		       flags. To experiment with that, uncomment the 		       following "else": */
comment|/* else */
name|attrs
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|attrs
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|skipspace
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|d
condition|)
break|break;
comment|/* require real whitespace or :'s */
block|}
name|tmp
operator|=
operator|(
name|PL_expect
operator|==
name|XOPERATOR
condition|?
literal|'='
else|:
literal|'{'
operator|)
expr_stmt|;
comment|/*'}(' for vi */
if|if
condition|(
operator|*
name|s
operator|!=
literal|';'
operator|&&
operator|*
name|s
operator|!=
name|tmp
operator|&&
operator|(
name|tmp
operator|!=
literal|'='
operator|||
operator|*
name|s
operator|!=
literal|')'
operator|)
condition|)
block|{
name|char
name|q
init|=
operator|(
operator|(
operator|*
name|s
operator|==
literal|'\''
operator|)
condition|?
literal|'"'
else|:
literal|'\''
operator|)
decl_stmt|;
comment|/* If here for an expression, and parsed no attrs, back off. */
if|if
condition|(
name|tmp
operator|==
literal|'='
operator|&&
operator|!
name|attrs
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
break|break;
block|}
comment|/* MUST advance bufptr here to avoid bogus "at end of line" 		   context messages from yyerror(). 		 */
name|PL_bufptr
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|yyerror
argument_list|(
literal|"Unterminated attribute list"
argument_list|)
expr_stmt|;
else|else
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Invalid separator character %c%c%c in attribute list"
argument_list|,
name|q
argument_list|,
operator|*
name|s
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|op_free
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
name|got_attrs
label|:
if|if
condition|(
name|attrs
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|attrs
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
name|TOKEN
argument_list|(
name|COLONATTR
argument_list|)
expr_stmt|;
block|}
name|OPERATOR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|||
name|PL_last_uni
operator|==
name|PL_oldoldbufptr
condition|)
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
expr_stmt|;
comment|/* allow print(STDOUT 123) */
else|else
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|TOKEN
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
name|CLINE
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|')'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PREBLOCK
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|']'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<=
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Unmatched right square bracket"
argument_list|)
expr_stmt|;
else|else
operator|--
name|PL_lex_brackets
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
condition|)
block|{
if|if
condition|(
name|PL_lex_brackets
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'['
operator|&&
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'-'
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|'>'
operator|)
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
block|}
block|}
name|TERM
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
name|leftbracket
label|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|>
literal|100
condition|)
block|{
name|char
modifier|*
name|newlb
init|=
name|Renew
argument_list|(
name|PL_lex_brackstack
argument_list|,
name|PL_lex_brackets
operator|+
literal|1
argument_list|,
name|char
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlb
operator|!=
name|PL_lex_brackstack
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|newlb
argument_list|)
expr_stmt|;
name|PL_lex_brackstack
operator|=
name|newlb
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|PL_expect
condition|)
block|{
case|case
name|XTERM
case|:
if|if
condition|(
name|PL_lex_formbrack
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|PRETERMBLOCK
argument_list|(
name|DO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
condition|)
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XTERM
expr_stmt|;
else|else
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
case|case
name|XOPERATOR
case|:
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|==
literal|'-'
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|d
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|d
operator|=
name|scan_word
argument_list|(
name|d
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'}'
condition|)
block|{
name|char
name|minus
init|=
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
decl_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
operator|+
name|minus
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|IN_BYTE
operator|&&
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
operator|&&
name|PL_nextval
index|[
name|PL_nexttoke
operator|-
literal|1
index|]
operator|.
name|opval
condition|)
name|SvUTF8_on
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|PL_nextval
index|[
name|PL_nexttoke
operator|-
literal|1
index|]
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus
condition|)
name|force_next
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FALL THROUGH */
case|case
name|XATTRBLOCK
case|:
case|case
name|XBLOCK
case|:
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XSTATE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
break|break;
case|case
name|XATTRTERM
case|:
case|case
name|XTERMBLOCK
case|:
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
break|break;
default|default:
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
condition|)
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XTERM
expr_stmt|;
else|else
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
comment|/* This hack serves to disambiguate a pair of curlies 		 * as being a block or an anon hash.  Normally, expectation 		 * determines that, but in cases where we're not in a 		 * position to expect anything in particular (like inside 		 * eval"") we have to resolve the ambiguity.  This code 		 * covers the case where the first term in the curlies is a 		 * quoted string.  Most other cases need to be explicitly 		 * disambiguated by prepending a `+' before the opening 		 * curly in order to force resolution as an anon hash. 		 * 		 * XXX should probably propagate the outer expectation 		 * into eval"" to rely less on this hack, but that could 		 * potentially break current behavior of eval"". 		 * GSAR 97-07-21 		 */
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|*
name|s
operator|==
literal|'"'
operator|||
operator|*
name|s
operator|==
literal|'`'
condition|)
block|{
comment|/* common case: get past first string, handling escapes */
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
operator|&&
operator|*
name|t
operator|!=
operator|*
name|s
condition|;
control|)
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'\\'
operator|||
operator|*
name|t
operator|==
operator|*
name|s
operator|)
condition|)
name|t
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
operator|++
name|t
operator|<
name|PL_bufend
operator|&&
operator|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|t
operator|==
literal|'q'
operator|||
operator|*
name|t
operator|==
literal|'x'
operator|)
operator|&&
operator|++
name|t
operator|<
name|PL_bufend
operator|&&
operator|!
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
name|open
decl_stmt|,
name|close
decl_stmt|,
name|term
decl_stmt|;
name|I32
name|brackets
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|term
operator|=
operator|*
name|t
expr_stmt|;
name|open
operator|=
name|term
expr_stmt|;
if|if
condition|(
name|term
operator|&&
operator|(
name|tmps
operator|=
name|strchr
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|tmps
index|[
literal|5
index|]
expr_stmt|;
name|close
operator|=
name|term
expr_stmt|;
if|if
condition|(
name|open
operator|==
name|close
condition|)
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
operator|&&
name|t
operator|+
literal|1
operator|<
name|PL_bufend
operator|&&
name|open
operator|!=
literal|'\\'
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|open
condition|)
break|break;
block|}
else|else
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
operator|&&
name|t
operator|+
literal|1
operator|<
name|PL_bufend
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|close
operator|&&
operator|--
name|brackets
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|open
condition|)
name|brackets
operator|++
expr_stmt|;
block|}
block|}
name|t
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isALNUM_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
name|isALNUM_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
condition|)
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* if comma follows first term, call it an anon hash */
comment|/* XXX it could be a comma expression with loop modifiers */
if|if
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
operator|(
operator|(
operator|*
name|t
operator|==
literal|','
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'q'
operator|||
operator|!
name|isLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'='
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
condition|)
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XREF
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
else|else
block|{
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|-
literal|1
index|]
operator|=
name|XSTATE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
block|}
break|break;
block|}
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'#'
condition|)
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
comment|/* invalidate current command line number */
name|TOKEN
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
name|rightbracket
label|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<=
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Unmatched right curly bracket"
argument_list|)
expr_stmt|;
else|else
name|PL_expect
operator|=
operator|(
name|expectation
operator|)
name|PL_lex_brackstack
index|[
operator|--
name|PL_lex_brackets
index|]
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<
name|PL_lex_formbrack
operator|&&
name|PL_lex_state
operator|!=
name|LEX_INTERPNORMAL
condition|)
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
condition|)
block|{
if|if
condition|(
name|PL_lex_brackets
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PL_expect
operator|&
name|XFAKEBRACK
condition|)
block|{
name|PL_expect
operator|&=
name|XENUMMASK
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
comment|/* ignore fake brackets */
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPENDMAYBE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|'['
operator|&&
operator|*
name|s
operator|!=
literal|'{'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_expect
operator|&
name|XFAKEBRACK
condition|)
block|{
name|PL_expect
operator|&=
name|XENUMMASK
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
comment|/* ignore fake brackets */
block|}
name|force_next
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'&'
condition|)
name|AOPERATOR
argument_list|(
name|ANDAND
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SEMICOLON
argument_list|)
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|&&
name|PL_bufptr
operator|==
name|PL_linestart
condition|)
block|{
name|CopLINE_dec
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SEMICOLON
argument_list|,
argument|PL_warn_nosemi
argument_list|)
empty_stmt|;
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
name|BAop
argument_list|(
name|OP_BIT_AND
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|scan_ident
argument_list|(
name|s
operator|-
literal|1
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|PL_tokenbuf
condition|)
block|{
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_ident
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
block|}
else|else
name|PREREF
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
operator|(
name|OPpENTERSUB_AMPER
operator|<<
literal|8
operator|)
expr_stmt|;
name|TERM
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'|'
condition|)
name|AOPERATOR
argument_list|(
name|OROR
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|BOop
argument_list|(
name|OP_BIT_OR
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Eop
argument_list|(
name|OP_EQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|OPERATOR
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|PMop
argument_list|(
name|OP_MATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
operator|&&
name|tmp
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"+-*/%.^&|<"
argument_list|,
name|tmp
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Reversed %c= operator"
argument_list|,
argument|(int)tmp
argument_list|)
empty_stmt|;
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|isALPHA
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|(
name|s
operator|==
name|PL_linestart
operator|+
literal|1
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|d
operator|=
name|PL_bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=cut"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|d
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
goto|goto
name|retry
goto|;
block|}
name|s
operator|=
name|PL_bufend
expr_stmt|;
name|PL_doextract
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|PL_lex_brackets
operator|<
name|PL_lex_formbrack
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
for|for
control|(
name|t
operator|=
name|s
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
else|#
directive|else
for|for
control|(
name|t
operator|=
name|s
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'\r'
condition|;
name|t
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
operator|||
operator|*
name|t
operator|==
literal|'#'
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|PL_expect
operator|=
name|XBLOCK
expr_stmt|;
goto|goto
name|leftbracket
goto|;
block|}
block|}
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|ASSIGNOP
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Eop
argument_list|(
name|OP_NE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|PMop
argument_list|(
name|OP_NOT
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
operator|!
name|strchr
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
name|s
operator|=
name|scan_heredoc
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|scan_inputsymbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'<'
condition|)
name|SHop
argument_list|(
name|OP_LEFT_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|Eop
argument_list|(
name|OP_NCMP
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_LE
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_LT
argument_list|)
expr_stmt|;
case|case
literal|'>'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|SHop
argument_list|(
name|OP_RIGHT_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Rop
argument_list|(
name|OP_GE
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_GT
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
name|CLINE
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
block|}
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|UTF
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"{$:+-"
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Array length"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
name|PREREF
argument_list|(
name|DOLSHARP
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|PL_pending_ident
operator|=
literal|'#'
expr_stmt|;
name|TOKEN
argument_list|(
name|DOLSHARP
argument_list|)
expr_stmt|;
block|}
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Scalar"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final $ should be \\$ or $name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
block|}
comment|/* This kludge not intended to be bulletproof. */
if|if
condition|(
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'['
operator|&&
operator|!
name|PL_tokenbuf
index|[
literal|2
index|]
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
name|PL_compiling
operator|.
name|cop_arybase
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_ARYBASE
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|s
expr_stmt|;
name|tmp
operator|=
operator|(
name|I32
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_expect
operator|!=
name|XREF
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|)
operator|&&
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
operator|||
name|isALNUM_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'$'
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|','
condition|)
block|{
name|PL_bufptr
operator|=
name|skipspace
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
operator|*
name|t
operator|!=
literal|']'
condition|)
name|t
operator|++
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Multidimensional syntax %.*s not supported"
argument_list|,
argument|(t - PL_bufptr) +
literal|1
argument_list|,
argument|PL_bufptr
argument_list|)
empty_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
literal|"SIG"
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'}'
argument_list|)
operator|)
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|t
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
for|for
control|(
name|t
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|t
operator|=
name|scan_word
argument_list|(
name|t
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|';'
operator|&&
name|get_cv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"You need to quote \"%s\""
argument_list|,
argument|tmpbuf
argument_list|)
empty_stmt|;
block|}
block|}
block|}
block|}
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
operator|&&
name|isSPACE
argument_list|(
operator|(
name|char
operator|)
name|tmp
argument_list|)
condition|)
block|{
name|bool
name|islop
init|=
operator|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|islop
operator|||
name|PL_last_lop_op
operator|==
name|OP_GREPSTART
condition|)
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"$@\"'`q"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh "foo" */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"&*<%"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh&sub */
elseif|else
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
comment|/* binary operators exclude handle interpretations */
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
operator|-
name|KEY_x
case|:
case|case
operator|-
name|KEY_eq
case|:
case|case
operator|-
name|KEY_ne
case|:
case|case
operator|-
name|KEY_gt
case|:
case|case
operator|-
name|KEY_lt
case|:
case|case
operator|-
name|KEY_ge
case|:
case|case
operator|-
name|KEY_le
case|:
case|case
operator|-
name|KEY_cmp
case|:
break|break;
default|default:
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh length() */
break|break;
block|}
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh subr() */
block|}
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh 3 */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh .3 */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"/?-+"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
operator|!
name|isSPACE
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh -1 */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'<'
operator|&&
operator|!
name|isSPACE
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'='
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* print $fh<<"EOF" */
block|}
name|PL_pending_ident
operator|=
literal|'$'
expr_stmt|;
name|TOKEN
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Array"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final @ should be \\@ or @name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_expect
operator|!=
name|XREF
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|)
operator|&&
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
comment|/* Warn about @ where they meant $. */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|s
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
name|isALNUM_lazy_if
argument_list|(
name|t
argument_list|,
name|UTF
argument_list|)
operator|||
name|strchr
argument_list|(
literal|" \t$#+-'\""
argument_list|,
operator|*
name|t
argument_list|)
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'}'
operator|||
operator|*
name|t
operator|==
literal|']'
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|PL_bufptr
operator|=
name|skipspace
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Scalar value %.*s better written as $%.*s"
argument_list|,
argument|t-PL_bufptr
argument_list|,
argument|PL_bufptr
argument_list|,
argument|t-PL_bufptr-
literal|1
argument_list|,
argument|PL_bufptr+
literal|1
argument_list|)
empty_stmt|;
block|}
block|}
block|}
block|}
name|PL_pending_ident
operator|=
literal|'@'
expr_stmt|;
name|TERM
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
comment|/* may either be division or pattern */
case|case
literal|'?'
case|:
comment|/* may either be conditional or pattern */
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
comment|/* Disable warning on "study /blah/" */
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_uni
operator|&&
operator|(
operator|*
name|PL_last_uni
operator|!=
literal|'s'
operator|||
name|s
operator|-
name|PL_last_uni
operator|<
literal|5
operator|||
name|memNE
argument_list|(
name|PL_last_uni
argument_list|,
literal|"study"
argument_list|,
literal|5
argument_list|)
operator|||
name|isALNUM_lazy_if
argument_list|(
name|PL_last_uni
operator|+
literal|5
argument_list|,
name|UTF
argument_list|)
operator|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_MATCH
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'/'
condition|)
name|Mop
argument_list|(
name|OP_DIVIDE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'.'
case|:
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
else|#
directive|else
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\r'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\n'
operator|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|s
operator|==
name|PL_linestart
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
goto|goto
name|rightbracket
goto|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
operator|||
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OPf_SPECIAL
expr_stmt|;
block|}
else|else
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|DOTDOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw number in '%s'\n"
argument|, s);         }
argument_list|)
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw string before '%s'\n"
argument|, s);         }
argument_list|)
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
else|else
name|no_op
argument_list|(
literal|"String"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'"'
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw string before '%s'\n"
argument|, s);         }
argument_list|)
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
else|else
name|no_op
argument_list|(
literal|"String"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
for|for
control|(
name|d
operator|=
name|SvPV
argument_list|(
name|PL_lex_stuff
argument_list|,
name|len
argument_list|)
init|;
name|len
condition|;
name|len
operator|--
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|||
operator|*
name|d
operator|==
literal|'@'
operator|||
operator|*
name|d
operator|==
literal|'\\'
operator|||
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|OP_STRINGIFY
expr_stmt|;
break|break;
block|}
block|}
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'`'
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|DEBUG_T
argument_list|(
argument|{ PerlIO_printf(Perl_debug_log,
literal|"### Saw backtick string before '%s'\n"
argument|, s);         }
argument_list|)
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Backticks"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_BACKTICK
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
operator|&&
name|PL_lex_inwhat
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Can't use \\%c to mean $%c in expression"
argument_list|,
argument|*s
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Backslash"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|REFGEN
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|s
decl_stmt|;
name|start
operator|++
expr_stmt|;
name|start
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|start
argument_list|)
operator|||
operator|*
name|start
operator|==
literal|'_'
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|start
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
comment|/* avoid v123abc() or $h{v1}, allow C<print v10;> */
elseif|else
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|start
argument_list|)
operator|&&
operator|(
name|PL_expect
operator|==
name|XTERM
operator|||
name|PL_expect
operator|==
name|XREF
operator|)
condition|)
block|{
name|char
name|c
init|=
operator|*
name|start
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
operator|*
name|start
operator|=
literal|'\0'
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
block|{
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|,
operator|&
name|yylval
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|keylookup
goto|;
case|case
literal|'x'
case|:
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|Mop
argument_list|(
name|OP_REPEAT
argument_list|)
expr_stmt|;
block|}
goto|goto
name|keylookup
goto|;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
name|keylookup
label|:
block|{
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* Some keywords can be followed by any delimiter, including ':' */
name|tmp
operator|=
operator|(
operator|(
name|len
operator|==
literal|1
operator|&&
name|strchr
argument_list|(
literal|"msyq"
argument_list|,
name|PL_tokenbuf
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|2
operator|&&
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|strchr
argument_list|(
literal|"qwxr"
argument_list|,
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* x::* is just a word, unless x is "CORE" */
if|if
condition|(
operator|!
name|tmp
operator|&&
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|strNE
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|"CORE"
argument_list|)
condition|)
goto|goto
name|just_a_word
goto|;
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
comment|/* no comments skipped here, or s### is misparsed */
comment|/* Is this a label? */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|d
operator|+
literal|1
operator|)
operator|!=
literal|':'
condition|)
block|{
name|s
operator|=
name|d
operator|+
literal|1
expr_stmt|;
name|yylval
operator|.
name|pval
operator|=
name|savepv
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|CLINE
expr_stmt|;
name|TOKEN
argument_list|(
name|LABEL
argument_list|)
expr_stmt|;
block|}
comment|/* Check for keywords */
name|tmp
operator|=
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Is this a word before a => operator? */
if|if
condition|(
operator|*
name|d
operator|==
literal|'='
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|CLINE
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|IN_BYTE
operator|&&
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
block|{
comment|/* second-class keyword? */
name|GV
modifier|*
name|ogv
init|=
name|Nullgv
decl_stmt|;
comment|/* override (winner) */
name|GV
modifier|*
name|hgv
init|=
name|Nullgv
decl_stmt|;
comment|/* hidden (loser) */
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|':'
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
operator|)
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
operator|)
operator|&&
operator|(
name|cv
operator|=
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
name|ogv
operator|=
name|gv
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CvMETHOD
argument_list|(
name|cv
argument_list|)
condition|)
name|hgv
operator|=
name|gv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ogv
operator|&&
operator|(
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_globalstash
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|ogv
operator|=
name|gv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ogv
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* overridden by import or by GLOBAL */
block|}
elseif|else
if|if
condition|(
name|gv
operator|&&
operator|!
name|gvp
operator|&&
operator|-
name|tmp
operator|==
name|KEY_lock
comment|/* XXX generalizable kludge */
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|&&
operator|!
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
literal|"Thread.pm"
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* any sub overrides "weak" keyword */
block|}
else|else
block|{
comment|/* no override */
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
operator|&&
name|hgv
operator|&&
name|tmp
operator|!=
name|KEY_x
operator|&&
name|tmp
operator|!=
name|KEY_CORE
condition|)
comment|/* never ambiguous */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Ambiguous call resolved as CORE::%s(), %s"
argument_list|,
argument|GvENAME(hgv)
argument_list|,
literal|"qualify as such or use&"
argument_list|)
empty_stmt|;
block|}
block|}
name|reserved_word
label|:
switch|switch
condition|(
name|tmp
condition|)
block|{
default|default:
comment|/* not a keyword */
name|just_a_word
label|:
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
name|lastchar
init|=
operator|(
name|PL_bufptr
operator|==
name|PL_oldoldbufptr
condition|?
literal|0
else|:
name|PL_bufptr
index|[
operator|-
literal|1
index|]
operator|)
decl_stmt|;
comment|/* Get the rest if it looks like a package qualifier */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|STRLEN
name|morelen
decl_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
name|len
argument_list|,
name|TRUE
argument_list|,
operator|&
name|morelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|morelen
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad name after %s%s"
argument_list|,
name|PL_tokenbuf
argument_list|,
operator|*
name|s
operator|==
literal|'\''
condition|?
literal|"'"
else|:
literal|"::"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|morelen
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_linestart
condition|)
block|{
name|CopLINE_dec
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SEMICOLON
argument_list|,
argument|PL_warn_nosemi
argument_list|)
empty_stmt|;
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
else|else
name|no_op
argument_list|(
literal|"Bareword"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a subroutine with this name in current package, 		   unless name is "Foo::", in which case Foo is a bearword 		   (and a package name). */
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|PL_tokenbuf
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|PL_tokenbuf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_BAREWORD
argument_list|)
operator|&&
operator|!
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVHV
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_BAREWORD
argument_list|,
literal|"Bareword \"%s\" refers to nonexistent package"
argument_list|,
argument|PL_tokenbuf
argument_list|)
empty_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|PL_tokenbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
block|}
comment|/* if we saw a global override before, get the right name */
if|if
condition|(
name|gvp
condition|)
block|{
name|sv
operator|=
name|newSVpvn
argument_list|(
literal|"CORE::GLOBAL::"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|sv
operator|=
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Presume this is going to be a bareword of some sort. */
name|CLINE
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
comment|/* And if "Foo::", then that's what it certainly is. */
if|if
condition|(
name|len
condition|)
goto|goto
name|safe_bareword
goto|;
comment|/* See if it's the indirect object for a list operator. */
if|if
condition|(
name|PL_oldoldbufptr
operator|&&
name|PL_oldoldbufptr
operator|<
name|PL_bufptr
operator|&&
operator|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_uni
operator|)
operator|&&
comment|/* NO SKIPSPACE BEFORE HERE! */
operator|(
name|PL_expect
operator|==
name|XREF
operator|||
operator|(
operator|(
name|PL_opargs
index|[
name|PL_last_lop_op
index|]
operator|>>
name|OASHIFT
operator|)
operator|&
literal|7
operator|)
operator|==
name|OA_FILEREF
operator|)
condition|)
block|{
name|bool
name|immediate_paren
init|=
operator|*
name|s
operator|==
literal|'('
decl_stmt|;
comment|/* (Now we can afford to cross potential line boundary.) */
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Two barewords in a row may indicate method call. */
if|if
condition|(
operator|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|tmp
operator|=
name|intuit_method
argument_list|(
name|s
argument_list|,
name|gv
argument_list|)
operator|)
condition|)
return|return
name|tmp
return|;
comment|/* If not a declared subroutine, it's an indirect object. */
comment|/* (But it's an indir obj regardless for sort.) */
if|if
condition|(
operator|(
name|PL_last_lop_op
operator|==
name|OP_SORT
operator|||
operator|(
operator|!
name|immediate_paren
operator|&&
operator|(
operator|!
name|gv
operator|||
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|PL_last_lop_op
operator|!=
name|OP_MAPSTART
operator|&&
name|PL_last_lop_op
operator|!=
name|OP_GREPSTART
operator|)
condition|)
block|{
name|PL_expect
operator|=
operator|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|)
condition|?
name|XTERM
else|:
name|XOPERATOR
expr_stmt|;
goto|goto
name|bareword
goto|;
block|}
block|}
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Is this a word before a => operator? */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|CLINE
expr_stmt|;
name|sv_setpv
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|IN_BYTE
operator|&&
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
comment|/* If followed by a paren, it's certainly a subroutine. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|CLINE
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
operator|+
literal|1
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|')'
operator|&&
operator|(
name|sv
operator|=
name|cv_const_sv
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|d
operator|+
literal|1
expr_stmt|;
goto|goto
name|its_constant
goto|;
block|}
block|}
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|TOKEN
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
block|}
comment|/* If followed by var or block, call it a method (unless sub) */
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'$'
operator|||
operator|*
name|s
operator|==
literal|'{'
operator|)
operator|&&
operator|(
operator|!
name|gv
operator|||
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_METHOD
expr_stmt|;
name|PREBLOCK
argument_list|(
name|METHOD
argument_list|)
expr_stmt|;
block|}
comment|/* If followed by a bareword, see if it looks like indir obj. */
if|if
condition|(
operator|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|tmp
operator|=
name|intuit_method
argument_list|(
name|s
argument_list|,
name|gv
argument_list|)
operator|)
condition|)
return|return
name|tmp
return|;
comment|/* Not a method, so call it a subroutine (if defined) */
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|lastchar
operator|==
literal|'-'
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Ambiguous use of -%s resolved as -&%s()"
argument_list|,
argument|PL_tokenbuf
argument_list|,
argument|PL_tokenbuf
argument_list|)
empty_stmt|;
comment|/* Check for a constant sub */
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sv
operator|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|its_constant
label|:
name|SvREFCNT_dec
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
name|TOKEN
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve to GV now. */
name|op_free
argument_list|(
name|yylval
operator|.
name|opval
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
name|newCVREF
argument_list|(
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator||=
name|OPpENTERSUB_NOPAREN
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_ENTERSUB
expr_stmt|;
comment|/* Is there a prototype? */
if|if
condition|(
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|proto
init|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|TERM
argument_list|(
name|FUNC0SUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|proto
argument_list|,
literal|"$"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|UNIOPSUB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
literal|'&'
operator|&&
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"__ANON__"
argument_list|)
expr_stmt|;
name|PREBLOCK
argument_list|(
name|LSTOPSUB
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|NOAMP
argument_list|)
expr_stmt|;
block|}
comment|/* Call it a bare word */
if|if
condition|(
name|PL_hints
operator|&
name|HINT_STRICT_SUBS
condition|)
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator||=
name|OPpCONST_STRICT
expr_stmt|;
else|else
block|{
name|bareword
label|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_RESERVED
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastchar
operator|!=
literal|'-'
condition|)
block|{
for|for
control|(
name|d
operator|=
name|PL_tokenbuf
init|;
operator|*
name|d
operator|&&
name|isLOWER
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_RESERVED
argument_list|,
argument|PL_warn_reserved
argument_list|,
argument|PL_tokenbuf
argument_list|)
empty_stmt|;
block|}
block|}
block|}
name|safe_bareword
label|:
if|if
condition|(
name|lastchar
operator|&&
name|strchr
argument_list|(
literal|"*%&"
argument_list|,
name|lastchar
argument_list|)
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Operator or semicolon missing before %c%s"
argument_list|,
argument|lastchar
argument_list|,
argument|PL_tokenbuf
argument_list|)
empty_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Ambiguous use of %c resolved as operator %c"
argument_list|,
argument|lastchar
argument_list|,
argument|lastchar
argument_list|)
empty_stmt|;
block|}
name|TOKEN
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
case|case
name|KEY___FILE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___LINE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___PACKAGE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
operator|(
name|PL_curstash
condition|?
name|newSVsv
argument_list|(
name|PL_curstname
argument_list|)
else|:
operator|&
name|PL_sv_undef
operator|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___DATA__
case|:
case|case
name|KEY___END__
case|:
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|PL_rsfp
operator|&&
operator|(
operator|!
name|PL_in_eval
operator|||
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'D'
operator|)
condition|)
block|{
name|char
modifier|*
name|pname
init|=
literal|"main"
decl_stmt|;
if|if
condition|(
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'D'
condition|)
name|pname
operator|=
name|HvNAME
argument_list|(
name|PL_curstash
condition|?
name|PL_curstash
else|:
name|PL_defstash
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"%s::DATA"
argument_list|,
name|pname
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvIO
argument_list|(
name|gv
argument_list|)
condition|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
operator|=
name|newIO
argument_list|()
expr_stmt|;
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|PL_rsfp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
block|{
name|int
name|fd
init|=
name|PerlIO_fileno
argument_list|(
name|PL_rsfp
argument_list|)
decl_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>=
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Mark this internal pseudo-handle as clean */
name|IoFLAGS
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator||=
name|IOf_UNTAINT
expr_stmt|;
if|if
condition|(
name|PL_preprocess
condition|)
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|IoTYPE_PIPE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|IoTYPE_STD
expr_stmt|;
else|else
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|IoTYPE_RDONLY
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PERL_TEXTMODE_SCRIPTS
argument_list|)
comment|/* if the script was opened in binmode, we need to revert 		 * it to text mode for compatibility; but only iff it has CRs 		 * XXX this is a questionable hack at best. */
if|if
condition|(
name|PL_bufend
operator|-
name|PL_bufptr
operator|>
literal|2
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{
name|Off_t
name|loc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|==
name|IoTYPE_RDONLY
condition|)
block|{
name|loc
operator|=
name|PerlIO_tell
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_seek
argument_list|(
name|PL_rsfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PerlLIO_setmode
argument_list|(
name|PerlIO_fileno
argument_list|(
name|PL_rsfp
argument_list|)
argument_list|,
name|O_TEXT
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* XXX see note in do_binmode() */
operator|(
operator|(
name|FILE
operator|*
operator|)
name|PL_rsfp
operator|)
operator|->
name|flags
operator|&=
operator|~
name|_F_BIN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|loc
operator|>
literal|0
condition|)
name|PerlIO_seek
argument_list|(
name|PL_rsfp
argument_list|,
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
goto|goto
name|fake_eof
goto|;
block|}
case|case
name|KEY_AUTOLOAD
case|:
case|case
name|KEY_DESTROY
case|:
case|case
name|KEY_BEGIN
case|:
case|case
name|KEY_CHECK
case|:
case|case
name|KEY_INIT
case|:
case|case
name|KEY_END
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
goto|goto
name|really_sub
goto|;
block|}
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_CORE
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"CORE::%s is not a keyword"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
goto|goto
name|reserved_word
goto|;
block|}
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_abs
case|:
name|UNI
argument_list|(
name|OP_ABS
argument_list|)
expr_stmt|;
case|case
name|KEY_alarm
case|:
name|UNI
argument_list|(
name|OP_ALARM
argument_list|)
expr_stmt|;
case|case
name|KEY_accept
case|:
name|LOP
argument_list|(
name|OP_ACCEPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_and
case|:
name|OPERATOR
argument_list|(
name|ANDOP
argument_list|)
expr_stmt|;
case|case
name|KEY_atan2
case|:
name|LOP
argument_list|(
name|OP_ATAN2
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_bind
case|:
name|LOP
argument_list|(
name|OP_BIND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_binmode
case|:
name|LOP
argument_list|(
name|OP_BINMODE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_bless
case|:
name|LOP
argument_list|(
name|OP_BLESS
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chop
case|:
name|UNI
argument_list|(
name|OP_CHOP
argument_list|)
expr_stmt|;
case|case
name|KEY_continue
case|:
name|PREBLOCK
argument_list|(
name|CONTINUE
argument_list|)
expr_stmt|;
case|case
name|KEY_chdir
case|:
operator|(
name|void
operator|)
name|gv_fetchpv
argument_list|(
literal|"ENV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
comment|/* may use HOME */
name|UNI
argument_list|(
name|OP_CHDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_close
case|:
name|UNI
argument_list|(
name|OP_CLOSE
argument_list|)
expr_stmt|;
case|case
name|KEY_closedir
case|:
name|UNI
argument_list|(
name|OP_CLOSEDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_cmp
case|:
name|Eop
argument_list|(
name|OP_SCMP
argument_list|)
expr_stmt|;
case|case
name|KEY_caller
case|:
name|UNI
argument_list|(
name|OP_CALLER
argument_list|)
expr_stmt|;
case|case
name|KEY_crypt
case|:
ifdef|#
directive|ifdef
name|FCRYPT
if|if
condition|(
operator|!
name|PL_cryptseen
condition|)
block|{
name|PL_cryptseen
operator|=
name|TRUE
expr_stmt|;
name|init_des
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|LOP
argument_list|(
name|OP_CRYPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chmod
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CHMOD
argument_list|)
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'('
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|!=
literal|'0'
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_CHMOD
argument_list|,
literal|"chmod() mode argument is missing initial 0"
argument_list|)
empty_stmt|;
block|}
name|LOP
argument_list|(
name|OP_CHMOD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chown
case|:
name|LOP
argument_list|(
name|OP_CHOWN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_connect
case|:
name|LOP
argument_list|(
name|OP_CONNECT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chr
case|:
name|UNI
argument_list|(
name|OP_CHR
argument_list|)
expr_stmt|;
case|case
name|KEY_cos
case|:
name|UNI
argument_list|(
name|OP_COS
argument_list|)
expr_stmt|;
case|case
name|KEY_chroot
case|:
name|UNI
argument_list|(
name|OP_CHROOT
argument_list|)
expr_stmt|;
case|case
name|KEY_do
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PRETERMBLOCK
argument_list|(
name|DO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\''
condition|)
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|DO
argument_list|)
expr_stmt|;
case|case
name|KEY_die
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|LOP
argument_list|(
name|OP_DIE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_defined
case|:
name|UNI
argument_list|(
name|OP_DEFINED
argument_list|)
expr_stmt|;
case|case
name|KEY_delete
case|:
name|UNI
argument_list|(
name|OP_DELETE
argument_list|)
expr_stmt|;
case|case
name|KEY_dbmopen
case|:
name|gv_fetchpv
argument_list|(
literal|"AnyDBM_File::ISA"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_DBMOPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_dbmclose
case|:
name|UNI
argument_list|(
name|OP_DBMCLOSE
argument_list|)
expr_stmt|;
case|case
name|KEY_dump
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_DUMP
argument_list|)
expr_stmt|;
case|case
name|KEY_else
case|:
name|PREBLOCK
argument_list|(
name|ELSE
argument_list|)
expr_stmt|;
case|case
name|KEY_elsif
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|ELSIF
argument_list|)
expr_stmt|;
case|case
name|KEY_eq
case|:
name|Eop
argument_list|(
name|OP_SEQ
argument_list|)
expr_stmt|;
case|case
name|KEY_exists
case|:
name|UNI
argument_list|(
name|OP_EXISTS
argument_list|)
expr_stmt|;
case|case
name|KEY_exit
case|:
name|UNI
argument_list|(
name|OP_EXIT
argument_list|)
expr_stmt|;
case|case
name|KEY_eval
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|)
condition|?
name|XTERMBLOCK
else|:
name|XTERM
expr_stmt|;
name|UNIBRACK
argument_list|(
name|OP_ENTEREVAL
argument_list|)
expr_stmt|;
case|case
name|KEY_eof
case|:
name|UNI
argument_list|(
name|OP_EOF
argument_list|)
expr_stmt|;
case|case
name|KEY_exp
case|:
name|UNI
argument_list|(
name|OP_EXP
argument_list|)
expr_stmt|;
case|case
name|KEY_each
case|:
name|UNI
argument_list|(
name|OP_EACH
argument_list|)
expr_stmt|;
case|case
name|KEY_exec
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_EXEC
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_endhostent
case|:
name|FUN0
argument_list|(
name|OP_EHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endnetent
case|:
name|FUN0
argument_list|(
name|OP_ENETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endservent
case|:
name|FUN0
argument_list|(
name|OP_ESERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endprotoent
case|:
name|FUN0
argument_list|(
name|OP_EPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endpwent
case|:
name|FUN0
argument_list|(
name|OP_EPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endgrent
case|:
name|FUN0
argument_list|(
name|OP_EGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_for
case|:
case|case
name|KEY_foreach
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|PL_bufend
operator|-
name|p
operator|)
operator|>=
literal|3
operator|&&
name|strnEQ
argument_list|(
name|p
argument_list|,
literal|"my"
argument_list|,
literal|2
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PL_bufend
operator|-
name|p
operator|)
operator|>=
literal|4
operator|&&
name|strnEQ
argument_list|(
name|p
argument_list|,
literal|"our"
argument_list|,
literal|3
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
argument_list|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|p
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|p
operator|=
name|scan_ident
argument_list|(
name|p
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'$'
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Missing $ on loop variable"
argument_list|)
expr_stmt|;
block|}
name|OPERATOR
argument_list|(
name|FOR
argument_list|)
expr_stmt|;
case|case
name|KEY_formline
case|:
name|LOP
argument_list|(
name|OP_FORMLINE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_fork
case|:
name|FUN0
argument_list|(
name|OP_FORK
argument_list|)
expr_stmt|;
case|case
name|KEY_fcntl
case|:
name|LOP
argument_list|(
name|OP_FCNTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_fileno
case|:
name|UNI
argument_list|(
name|OP_FILENO
argument_list|)
expr_stmt|;
case|case
name|KEY_flock
case|:
name|LOP
argument_list|(
name|OP_FLOCK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_gt
case|:
name|Rop
argument_list|(
name|OP_SGT
argument_list|)
expr_stmt|;
case|case
name|KEY_ge
case|:
name|Rop
argument_list|(
name|OP_SGE
argument_list|)
expr_stmt|;
case|case
name|KEY_grep
case|:
name|LOP
argument_list|(
name|OP_GREPSTART
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_goto
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_GOTO
argument_list|)
expr_stmt|;
case|case
name|KEY_gmtime
case|:
name|UNI
argument_list|(
name|OP_GMTIME
argument_list|)
expr_stmt|;
case|case
name|KEY_getc
case|:
name|UNI
argument_list|(
name|OP_GETC
argument_list|)
expr_stmt|;
case|case
name|KEY_getppid
case|:
name|FUN0
argument_list|(
name|OP_GETPPID
argument_list|)
expr_stmt|;
case|case
name|KEY_getpgrp
case|:
name|UNI
argument_list|(
name|OP_GETPGRP
argument_list|)
expr_stmt|;
case|case
name|KEY_getpriority
case|:
name|LOP
argument_list|(
name|OP_GETPRIORITY
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotobyname
case|:
name|UNI
argument_list|(
name|OP_GPBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotobynumber
case|:
name|LOP
argument_list|(
name|OP_GPBYNUMBER
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotoent
case|:
name|FUN0
argument_list|(
name|OP_GPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwent
case|:
name|FUN0
argument_list|(
name|OP_GPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwnam
case|:
name|UNI
argument_list|(
name|OP_GPWNAM
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwuid
case|:
name|UNI
argument_list|(
name|OP_GPWUID
argument_list|)
expr_stmt|;
case|case
name|KEY_getpeername
case|:
name|UNI
argument_list|(
name|OP_GETPEERNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostbyname
case|:
name|UNI
argument_list|(
name|OP_GHBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostbyaddr
case|:
name|LOP
argument_list|(
name|OP_GHBYADDR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostent
case|:
name|FUN0
argument_list|(
name|OP_GHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetbyname
case|:
name|UNI
argument_list|(
name|OP_GNBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetbyaddr
case|:
name|LOP
argument_list|(
name|OP_GNBYADDR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetent
case|:
name|FUN0
argument_list|(
name|OP_GNETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getservbyname
case|:
name|LOP
argument_list|(
name|OP_GSBYNAME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getservbyport
case|:
name|LOP
argument_list|(
name|OP_GSBYPORT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getservent
case|:
name|FUN0
argument_list|(
name|OP_GSERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getsockname
case|:
name|UNI
argument_list|(
name|OP_GETSOCKNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getsockopt
case|:
name|LOP
argument_list|(
name|OP_GSOCKOPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrent
case|:
name|FUN0
argument_list|(
name|OP_GGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrnam
case|:
name|UNI
argument_list|(
name|OP_GGRNAM
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrgid
case|:
name|UNI
argument_list|(
name|OP_GGRGID
argument_list|)
expr_stmt|;
case|case
name|KEY_getlogin
case|:
name|FUN0
argument_list|(
name|OP_GETLOGIN
argument_list|)
expr_stmt|;
case|case
name|KEY_glob
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_GLOB
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_hex
case|:
name|UNI
argument_list|(
name|OP_HEX
argument_list|)
expr_stmt|;
case|case
name|KEY_if
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|IF
argument_list|)
expr_stmt|;
case|case
name|KEY_index
case|:
name|LOP
argument_list|(
name|OP_INDEX
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_int
case|:
name|UNI
argument_list|(
name|OP_INT
argument_list|)
expr_stmt|;
case|case
name|KEY_ioctl
case|:
name|LOP
argument_list|(
name|OP_IOCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_join
case|:
name|LOP
argument_list|(
name|OP_JOIN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_keys
case|:
name|UNI
argument_list|(
name|OP_KEYS
argument_list|)
expr_stmt|;
case|case
name|KEY_kill
case|:
name|LOP
argument_list|(
name|OP_KILL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_last
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
case|case
name|KEY_lc
case|:
name|UNI
argument_list|(
name|OP_LC
argument_list|)
expr_stmt|;
case|case
name|KEY_lcfirst
case|:
name|UNI
argument_list|(
name|OP_LCFIRST
argument_list|)
expr_stmt|;
case|case
name|KEY_local
case|:
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|LOCAL
argument_list|)
expr_stmt|;
case|case
name|KEY_length
case|:
name|UNI
argument_list|(
name|OP_LENGTH
argument_list|)
expr_stmt|;
case|case
name|KEY_lt
case|:
name|Rop
argument_list|(
name|OP_SLT
argument_list|)
expr_stmt|;
case|case
name|KEY_le
case|:
name|Rop
argument_list|(
name|OP_SLE
argument_list|)
expr_stmt|;
case|case
name|KEY_localtime
case|:
name|UNI
argument_list|(
name|OP_LOCALTIME
argument_list|)
expr_stmt|;
case|case
name|KEY_log
case|:
name|UNI
argument_list|(
name|OP_LOG
argument_list|)
expr_stmt|;
case|case
name|KEY_link
case|:
name|LOP
argument_list|(
name|OP_LINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_listen
case|:
name|LOP
argument_list|(
name|OP_LISTEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_lock
case|:
name|UNI
argument_list|(
name|OP_LOCK
argument_list|)
expr_stmt|;
case|case
name|KEY_lstat
case|:
name|UNI
argument_list|(
name|OP_LSTAT
argument_list|)
expr_stmt|;
case|case
name|KEY_m
case|:
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_MATCH
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_map
case|:
name|LOP
argument_list|(
name|OP_MAPSTART
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_mkdir
case|:
name|LOP
argument_list|(
name|OP_MKDIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgctl
case|:
name|LOP
argument_list|(
name|OP_MSGCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgget
case|:
name|LOP
argument_list|(
name|OP_MSGGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgrcv
case|:
name|LOP
argument_list|(
name|OP_MSGRCV
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgsnd
case|:
name|LOP
argument_list|(
name|OP_MSGSND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_our
case|:
case|case
name|KEY_my
case|:
name|PL_in_my
operator|=
name|tmp
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
name|strnEQ
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|"sub"
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|really_sub
goto|;
name|PL_in_my_stash
operator|=
name|find_in_my_stash
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_my_stash
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|1024
index|]
decl_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"No such class %.1000s"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|yylval
operator|.
name|ival
operator|=
literal|1
expr_stmt|;
name|OPERATOR
argument_list|(
name|MY
argument_list|)
expr_stmt|;
case|case
name|KEY_next
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_NEXT
argument_list|)
expr_stmt|;
case|case
name|KEY_ne
case|:
name|Eop
argument_list|(
name|OP_SNE
argument_list|)
expr_stmt|;
case|case
name|KEY_no
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XSTATE
condition|)
name|yyerror
argument_list|(
literal|"\"no\" not allowed in expression"
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|USE
argument_list|)
expr_stmt|;
case|case
name|KEY_not
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|||
operator|(
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
operator|,
operator|*
name|s
operator|==
literal|'('
operator|)
condition|)
name|FUN1
argument_list|(
name|OP_NOT
argument_list|)
expr_stmt|;
else|else
name|OPERATOR
argument_list|(
name|NOTOP
argument_list|)
expr_stmt|;
case|case
name|KEY_open
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|d
operator|=
name|s
init|;
name|isALNUM_lazy_if
argument_list|(
name|d
argument_list|,
name|UTF
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
name|t
operator|=
name|skipspace
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"|&*+-=!?:."
argument_list|,
operator|*
name|t
argument_list|)
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_PRECEDENCE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PRECEDENCE
argument_list|,
literal|"Precedence problem: open %.*s should be open(%.*s)"
argument_list|,
argument|d-s
argument_list|,
argument|s
argument_list|,
argument|d-s
argument_list|,
argument|s
argument_list|)
empty_stmt|;
block|}
name|LOP
argument_list|(
name|OP_OPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_or
case|:
name|yylval
operator|.
name|ival
operator|=
name|OP_OR
expr_stmt|;
name|OPERATOR
argument_list|(
name|OROP
argument_list|)
expr_stmt|;
case|case
name|KEY_ord
case|:
name|UNI
argument_list|(
name|OP_ORD
argument_list|)
expr_stmt|;
case|case
name|KEY_oct
case|:
name|UNI
argument_list|(
name|OP_OCT
argument_list|)
expr_stmt|;
case|case
name|KEY_opendir
case|:
name|LOP
argument_list|(
name|OP_OPEN_DIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_print
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_PRINT
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_printf
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_PRTF
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_prototype
case|:
name|UNI
argument_list|(
name|OP_PROTOTYPE
argument_list|)
expr_stmt|;
case|case
name|KEY_push
case|:
name|LOP
argument_list|(
name|OP_PUSH
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_pop
case|:
name|UNI
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
case|case
name|KEY_pos
case|:
name|UNI
argument_list|(
name|OP_POS
argument_list|)
expr_stmt|;
case|case
name|KEY_pack
case|:
name|LOP
argument_list|(
name|OP_PACK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_package
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
case|case
name|KEY_pipe
case|:
name|LOP
argument_list|(
name|OP_PIPE_OP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_q
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_quotemeta
case|:
name|UNI
argument_list|(
name|OP_QUOTEMETA
argument_list|)
expr_stmt|;
case|case
name|KEY_qw
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|PL_lex_stuff
argument_list|)
condition|)
block|{
name|OP
modifier|*
name|words
init|=
name|Nullop
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|d
operator|=
name|SvPV_force
argument_list|(
name|PL_lex_stuff
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|&&
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|d
control|)
empty_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|char
modifier|*
name|b
init|=
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|ckWARN
argument_list|(
name|WARN_QW
argument_list|)
condition|)
block|{
for|for
control|(
init|;
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|&&
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|d
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|','
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_QW
argument_list|,
literal|"Possible attempt to separate words with commas"
argument_list|)
empty_stmt|;
operator|++
name|warned
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'#'
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_QW
argument_list|,
literal|"Possible attempt to put comments in qw() list"
argument_list|)
empty_stmt|;
operator|++
name|warned
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
init|;
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|&&
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|d
control|)
empty_stmt|;
block|}
name|sv
operator|=
name|newSVpvn
argument_list|(
name|b
argument_list|,
name|d
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|PL_lex_stuff
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|words
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|words
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|tokeq
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|words
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|words
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_lex_stuff
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
block|}
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|TOKEN
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
case|case
name|KEY_qq
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_STRINGIFY
expr_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|==
literal|'\''
condition|)
name|SvIVX
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* qq'$foo' should intepolate */
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_qr
case|:
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_QR
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_qx
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_BACKTICK
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_return
case|:
name|OLDLOP
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
case|case
name|KEY_require
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'v'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|PL_tokenbuf
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|PL_tokenbuf
argument_list|,
name|UTF
argument_list|)
condition|)
name|gv_stashpvn
argument_list|(
name|PL_tokenbuf
argument_list|,
name|strlen
argument_list|(
name|PL_tokenbuf
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
condition|)
name|yyerror
argument_list|(
literal|"<> should be quotes"
argument_list|)
expr_stmt|;
block|}
name|UNI
argument_list|(
name|OP_REQUIRE
argument_list|)
expr_stmt|;
case|case
name|KEY_reset
case|:
name|UNI
argument_list|(
name|OP_RESET
argument_list|)
expr_stmt|;
case|case
name|KEY_redo
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_REDO
argument_list|)
expr_stmt|;
case|case
name|KEY_rename
case|:
name|LOP
argument_list|(
name|OP_RENAME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_rand
case|:
name|UNI
argument_list|(
name|OP_RAND
argument_list|)
expr_stmt|;
case|case
name|KEY_rmdir
case|:
name|UNI
argument_list|(
name|OP_RMDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_rindex
case|:
name|LOP
argument_list|(
name|OP_RINDEX
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_read
case|:
name|LOP
argument_list|(
name|OP_READ
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_readdir
case|:
name|UNI
argument_list|(
name|OP_READDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_readline
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|UNI
argument_list|(
name|OP_READLINE
argument_list|)
expr_stmt|;
case|case
name|KEY_readpipe
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|UNI
argument_list|(
name|OP_BACKTICK
argument_list|)
expr_stmt|;
case|case
name|KEY_rewinddir
case|:
name|UNI
argument_list|(
name|OP_REWINDDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_recv
case|:
name|LOP
argument_list|(
name|OP_RECV
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_reverse
case|:
name|LOP
argument_list|(
name|OP_REVERSE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_readlink
case|:
name|UNI
argument_list|(
name|OP_READLINK
argument_list|)
expr_stmt|;
case|case
name|KEY_ref
case|:
name|UNI
argument_list|(
name|OP_REF
argument_list|)
expr_stmt|;
case|case
name|KEY_s
case|:
name|s
operator|=
name|scan_subst
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylval
operator|.
name|opval
condition|)
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|TOKEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force error */
case|case
name|KEY_chomp
case|:
name|UNI
argument_list|(
name|OP_CHOMP
argument_list|)
expr_stmt|;
case|case
name|KEY_scalar
case|:
name|UNI
argument_list|(
name|OP_SCALAR
argument_list|)
expr_stmt|;
case|case
name|KEY_select
case|:
name|LOP
argument_list|(
name|OP_SELECT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_seek
case|:
name|LOP
argument_list|(
name|OP_SEEK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semctl
case|:
name|LOP
argument_list|(
name|OP_SEMCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semget
case|:
name|LOP
argument_list|(
name|OP_SEMGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semop
case|:
name|LOP
argument_list|(
name|OP_SEMOP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_send
case|:
name|LOP
argument_list|(
name|OP_SEND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setpgrp
case|:
name|LOP
argument_list|(
name|OP_SETPGRP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setpriority
case|:
name|LOP
argument_list|(
name|OP_SETPRIORITY
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sethostent
case|:
name|UNI
argument_list|(
name|OP_SHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setnetent
case|:
name|UNI
argument_list|(
name|OP_SNETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setservent
case|:
name|UNI
argument_list|(
name|OP_SSERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setprotoent
case|:
name|UNI
argument_list|(
name|OP_SPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setpwent
case|:
name|FUN0
argument_list|(
name|OP_SPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setgrent
case|:
name|FUN0
argument_list|(
name|OP_SGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_seekdir
case|:
name|LOP
argument_list|(
name|OP_SEEKDIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setsockopt
case|:
name|LOP
argument_list|(
name|OP_SSOCKOPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shift
case|:
name|UNI
argument_list|(
name|OP_SHIFT
argument_list|)
expr_stmt|;
case|case
name|KEY_shmctl
case|:
name|LOP
argument_list|(
name|OP_SHMCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmget
case|:
name|LOP
argument_list|(
name|OP_SHMGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmread
case|:
name|LOP
argument_list|(
name|OP_SHMREAD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmwrite
case|:
name|LOP
argument_list|(
name|OP_SHMWRITE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shutdown
case|:
name|LOP
argument_list|(
name|OP_SHUTDOWN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sin
case|:
name|UNI
argument_list|(
name|OP_SIN
argument_list|)
expr_stmt|;
case|case
name|KEY_sleep
case|:
name|UNI
argument_list|(
name|OP_SLEEP
argument_list|)
expr_stmt|;
case|case
name|KEY_socket
case|:
name|LOP
argument_list|(
name|OP_SOCKET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_socketpair
case|:
name|LOP
argument_list|(
name|OP_SOCKPAIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sort
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"subroutine name"
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|')'
condition|)
comment|/* probably a close */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"sort is now a reserved word"
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_SORT
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_split
case|:
name|LOP
argument_list|(
name|OP_SPLIT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sprintf
case|:
name|LOP
argument_list|(
name|OP_SPRINTF
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_splice
case|:
name|LOP
argument_list|(
name|OP_SPLICE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sqrt
case|:
name|UNI
argument_list|(
name|OP_SQRT
argument_list|)
expr_stmt|;
case|case
name|KEY_srand
case|:
name|UNI
argument_list|(
name|OP_SRAND
argument_list|)
expr_stmt|;
case|case
name|KEY_stat
case|:
name|UNI
argument_list|(
name|OP_STAT
argument_list|)
expr_stmt|;
case|case
name|KEY_study
case|:
name|UNI
argument_list|(
name|OP_STUDY
argument_list|)
expr_stmt|;
case|case
name|KEY_substr
case|:
name|LOP
argument_list|(
name|OP_SUBSTR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_format
case|:
case|case
name|KEY_sub
case|:
name|really_sub
label|:
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|SSize_t
name|tboffset
decl_stmt|;
name|expectation
name|attrful
decl_stmt|;
name|bool
name|have_name
decl_stmt|,
name|have_proto
decl_stmt|;
name|int
name|key
init|=
name|tmp
decl_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|PL_expect
operator|=
name|XBLOCK
expr_stmt|;
name|attrful
operator|=
name|XATTRBLOCK
expr_stmt|;
comment|/* remember buffer pos'n for later force_word */
name|tboffset
operator|=
name|s
operator|-
name|PL_oldbufptr
expr_stmt|;
name|d
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|tmpbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
else|else
block|{
name|sv_setsv
argument_list|(
name|PL_subname
argument_list|,
name|PL_curstname
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_subname
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_subname
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|skipspace
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|have_name
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|==
name|KEY_my
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Missing name in \"my sub\""
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XTERMBLOCK
expr_stmt|;
name|attrful
operator|=
name|XATTRTERM
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|have_name
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
name|KEY_format
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|PL_lex_formbrack
operator|=
name|PL_lex_brackets
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|have_name
condition|)
operator|(
name|void
operator|)
name|force_word
argument_list|(
name|PL_oldbufptr
operator|+
name|tboffset
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|FORMAT
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a prototype */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Prototype not terminated"
argument_list|)
expr_stmt|;
comment|/* strip spaces */
name|d
operator|=
name|SvPVX
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|d
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|d
index|[
name|tmp
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|d
index|[
name|tmp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|have_proto
operator|=
name|TRUE
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|have_proto
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|PL_expect
operator|=
name|attrful
expr_stmt|;
if|if
condition|(
name|have_proto
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_name
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"__ANON__"
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|ANONSUB
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|force_word
argument_list|(
name|PL_oldbufptr
operator|+
name|tboffset
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|KEY_my
condition|)
name|TOKEN
argument_list|(
name|MYSUB
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|SUB
argument_list|)
expr_stmt|;
block|}
case|case
name|KEY_system
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_SYSTEM
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_symlink
case|:
name|LOP
argument_list|(
name|OP_SYMLINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_syscall
case|:
name|LOP
argument_list|(
name|OP_SYSCALL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysopen
case|:
name|LOP
argument_list|(
name|OP_SYSOPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysseek
case|:
name|LOP
argument_list|(
name|OP_SYSSEEK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysread
case|:
name|LOP
argument_list|(
name|OP_SYSREAD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_syswrite
case|:
name|LOP
argument_list|(
name|OP_SYSWRITE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_tr
case|:
name|s
operator|=
name|scan_trans
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_tell
case|:
name|UNI
argument_list|(
name|OP_TELL
argument_list|)
expr_stmt|;
case|case
name|KEY_telldir
case|:
name|UNI
argument_list|(
name|OP_TELLDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_tie
case|:
name|LOP
argument_list|(
name|OP_TIE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_tied
case|:
name|UNI
argument_list|(
name|OP_TIED
argument_list|)
expr_stmt|;
case|case
name|KEY_time
case|:
name|FUN0
argument_list|(
name|OP_TIME
argument_list|)
expr_stmt|;
case|case
name|KEY_times
case|:
name|FUN0
argument_list|(
name|OP_TMS
argument_list|)
expr_stmt|;
case|case
name|KEY_truncate
case|:
name|LOP
argument_list|(
name|OP_TRUNCATE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_uc
case|:
name|UNI
argument_list|(
name|OP_UC
argument_list|)
expr_stmt|;
case|case
name|KEY_ucfirst
case|:
name|UNI
argument_list|(
name|OP_UCFIRST
argument_list|)
expr_stmt|;
case|case
name|KEY_untie
case|:
name|UNI
argument_list|(
name|OP_UNTIE
argument_list|)
expr_stmt|;
case|case
name|KEY_until
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNTIL
argument_list|)
expr_stmt|;
case|case
name|KEY_unless
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNLESS
argument_list|)
expr_stmt|;
case|case
name|KEY_unlink
case|:
name|LOP
argument_list|(
name|OP_UNLINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_undef
case|:
name|UNI
argument_list|(
name|OP_UNDEF
argument_list|)
expr_stmt|;
case|case
name|KEY_unpack
case|:
name|LOP
argument_list|(
name|OP_UNPACK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_utime
case|:
name|LOP
argument_list|(
name|OP_UTIME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_umask
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_UMASK
argument_list|)
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'('
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|!=
literal|'0'
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_UMASK
argument_list|,
literal|"umask: argument is missing initial 0"
argument_list|)
empty_stmt|;
block|}
name|UNI
argument_list|(
name|OP_UMASK
argument_list|)
expr_stmt|;
case|case
name|KEY_unshift
case|:
name|LOP
argument_list|(
name|OP_UNSHIFT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_use
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XSTATE
condition|)
name|yyerror
argument_list|(
literal|"\"use\" not allowed in expression"
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'v'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|(
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
operator|,
operator|*
name|s
operator|==
literal|';'
operator|)
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|Nullop
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ival
operator|=
literal|1
expr_stmt|;
name|OPERATOR
argument_list|(
name|USE
argument_list|)
expr_stmt|;
case|case
name|KEY_values
case|:
name|UNI
argument_list|(
name|OP_VALUES
argument_list|)
expr_stmt|;
case|case
name|KEY_vec
case|:
name|LOP
argument_list|(
name|OP_VEC
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_while
case|:
name|yylval
operator|.
name|ival
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|WHILE
argument_list|)
expr_stmt|;
case|case
name|KEY_warn
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|LOP
argument_list|(
name|OP_WARN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_wait
case|:
name|FUN0
argument_list|(
name|OP_WAIT
argument_list|)
expr_stmt|;
case|case
name|KEY_waitpid
case|:
name|LOP
argument_list|(
name|OP_WAITPID
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_wantarray
case|:
name|FUN0
argument_list|(
name|OP_WANTARRAY
argument_list|)
expr_stmt|;
case|case
name|KEY_write
case|:
ifdef|#
directive|ifdef
name|EBCDIC
block|{
specifier|static
name|char
name|ctl_l
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|ctl_l
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ctl_l
index|[
literal|0
index|]
operator|=
name|toCTRL
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|gv_fetchpv
argument_list|(
name|ctl_l
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gv_fetchpv
argument_list|(
literal|"\f"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* Make sure $^L is defined */
endif|#
directive|endif
name|UNI
argument_list|(
name|OP_ENTERWRITE
argument_list|)
expr_stmt|;
case|case
name|KEY_x
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Mop
argument_list|(
name|OP_REPEAT
argument_list|)
expr_stmt|;
name|check_uni
argument_list|()
expr_stmt|;
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_xor
case|:
name|yylval
operator|.
name|ival
operator|=
name|OP_XOR
expr_stmt|;
name|OPERATOR
argument_list|(
name|OROP
argument_list|)
expr_stmt|;
case|case
name|KEY_y
case|:
name|s
operator|=
name|scan_trans
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__SC__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|segment
name|Main
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|I32
name|Perl_keyword
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|d
parameter_list|,
name|I32
name|len
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'_'
case|:
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__FILE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___FILE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__LINE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___LINE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__PACKAGE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___PACKAGE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__DATA__"
argument_list|)
condition|)
return|return
name|KEY___DATA__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__END__"
argument_list|)
condition|)
return|return
name|KEY___END__
return|;
block|}
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"AUTOLOAD"
argument_list|)
condition|)
return|return
name|KEY_AUTOLOAD
return|;
break|break;
case|case
literal|'a'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"and"
argument_list|)
condition|)
return|return
operator|-
name|KEY_and
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"abs"
argument_list|)
condition|)
return|return
operator|-
name|KEY_abs
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"alarm"
argument_list|)
condition|)
return|return
operator|-
name|KEY_alarm
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"atan2"
argument_list|)
condition|)
return|return
operator|-
name|KEY_atan2
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"accept"
argument_list|)
condition|)
return|return
operator|-
name|KEY_accept
return|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
return|return
name|KEY_BEGIN
return|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"bless"
argument_list|)
condition|)
return|return
operator|-
name|KEY_bless
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"bind"
argument_list|)
condition|)
return|return
operator|-
name|KEY_bind
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"binmode"
argument_list|)
condition|)
return|return
operator|-
name|KEY_binmode
return|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"CORE"
argument_list|)
condition|)
return|return
operator|-
name|KEY_CORE
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"CHECK"
argument_list|)
condition|)
return|return
name|KEY_CHECK
return|;
break|break;
case|case
literal|'c'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cmp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_cmp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cos"
argument_list|)
condition|)
return|return
operator|-
name|KEY_cos
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chop"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chop
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"close"
argument_list|)
condition|)
return|return
operator|-
name|KEY_close
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chdir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chomp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chomp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chmod"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chmod
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chown"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chown
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"crypt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_crypt
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chroot"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chroot
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"caller"
argument_list|)
condition|)
return|return
operator|-
name|KEY_caller
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"connect"
argument_list|)
condition|)
return|return
operator|-
name|KEY_connect
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"closedir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_closedir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"continue"
argument_list|)
condition|)
return|return
operator|-
name|KEY_continue
return|;
break|break;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"DESTROY"
argument_list|)
condition|)
return|return
name|KEY_DESTROY
return|;
break|break;
case|case
literal|'d'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"do"
argument_list|)
condition|)
return|return
name|KEY_do
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"die"
argument_list|)
condition|)
return|return
operator|-
name|KEY_die
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dump"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dump
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"delete"
argument_list|)
condition|)
return|return
name|KEY_delete
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"defined"
argument_list|)
condition|)
return|return
name|KEY_defined
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmopen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dbmopen
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmclose"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dbmclose
return|;
break|break;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"EQ"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_eq
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"END"
argument_list|)
condition|)
return|return
name|KEY_END
return|;
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eq"
argument_list|)
condition|)
return|return
operator|-
name|KEY_eq
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eof"
argument_list|)
condition|)
return|return
operator|-
name|KEY_eof
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exp
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"else"
argument_list|)
condition|)
return|return
name|KEY_else
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exit"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exit
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eval"
argument_list|)
condition|)
return|return
name|KEY_eval
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exec"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exec
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"each"
argument_list|)
condition|)
return|return
operator|-
name|KEY_each
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elsif"
argument_list|)
condition|)
return|return
name|KEY_elsif
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exists"
argument_list|)
condition|)
return|return
name|KEY_exists
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elseif"
argument_list|)
condition|)
name|Perl_warn
argument_list|(
name|aTHX_
literal|"elseif should be elsif"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endgrent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endgrent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endpwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endpwent
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endnetent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endnetent
return|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endhostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endhostent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endservent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endservent
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endprotoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endprotoent
return|;
break|break;
block|}
break|break;
case|case
literal|'f'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"for"
argument_list|)
condition|)
return|return
name|KEY_for
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fork"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fork
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fcntl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fcntl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"flock"
argument_list|)
condition|)
return|return
operator|-
name|KEY_flock
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"format"
argument_list|)
condition|)
return|return
name|KEY_format
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fileno"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fileno
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"foreach"
argument_list|)
condition|)
return|return
name|KEY_foreach
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"formline"
argument_list|)
condition|)
return|return
operator|-
name|KEY_formline
return|;
break|break;
block|}
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GT"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_gt
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_ge
return|;
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"get"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|d
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'p'
condition|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ppid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getppid
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pgrp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpgrp
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwnam"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwnam
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwuid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwuid
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"peername"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpeername
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotoent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"priority"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpriority
return|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotobyname
return|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobynumber"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotobynumber
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyaddr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostbyaddr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostent
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyaddr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetbyaddr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetent
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyport"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservbyport
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getsockname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockopt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getsockopt
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grnam"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrnam
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grgid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrgid
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"login"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getlogin
return|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"c"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getc
return|;
break|break;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ge"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ge
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grep"
argument_list|)
condition|)
return|return
name|KEY_grep
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"goto"
argument_list|)
condition|)
return|return
name|KEY_goto
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"glob"
argument_list|)
condition|)
return|return
name|KEY_glob
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gmtime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gmtime
return|;
break|break;
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hex"
argument_list|)
condition|)
return|return
operator|-
name|KEY_hex
return|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"INIT"
argument_list|)
condition|)
return|return
name|KEY_INIT
return|;
break|break;
case|case
literal|'i'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"if"
argument_list|)
condition|)
return|return
name|KEY_if
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
operator|-
name|KEY_int
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"index"
argument_list|)
condition|)
return|return
operator|-
name|KEY_index
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ioctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ioctl
return|;
break|break;
block|}
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"join"
argument_list|)
condition|)
return|return
operator|-
name|KEY_join
return|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"keys"
argument_list|)
condition|)
return|return
operator|-
name|KEY_keys
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"kill"
argument_list|)
condition|)
return|return
operator|-
name|KEY_kill
return|;
block|}
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LT"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_lt
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_le
return|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"le"
argument_list|)
condition|)
return|return
operator|-
name|KEY_le
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lc"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lc
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"log"
argument_list|)
condition|)
return|return
operator|-
name|KEY_log
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"last"
argument_list|)
condition|)
return|return
name|KEY_last
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"link"
argument_list|)
condition|)
return|return
operator|-
name|KEY_link
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lock"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lock
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"local"
argument_list|)
condition|)
return|return
name|KEY_local
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lstat"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lstat
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"length"
argument_list|)
condition|)
return|return
operator|-
name|KEY_length
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"listen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_listen
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lcfirst"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lcfirst
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"localtime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_localtime
return|;
break|break;
block|}
break|break;
case|case
literal|'m'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
return|return
name|KEY_m
return|;
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"my"
argument_list|)
condition|)
return|return
name|KEY_my
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"map"
argument_list|)
condition|)
return|return
name|KEY_map
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"mkdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_mkdir
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgget
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgrcv"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgrcv
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgsnd"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgsnd
return|;
break|break;
block|}
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"NE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_ne
return|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"next"
argument_list|)
condition|)
return|return
name|KEY_next
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ne"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ne
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"not"
argument_list|)
condition|)
return|return
operator|-
name|KEY_not
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"no"
argument_list|)
condition|)
return|return
name|KEY_no
return|;
break|break;
case|case
literal|'o'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"or"
argument_list|)
condition|)
return|return
operator|-
name|KEY_or
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ord"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ord
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"oct"
argument_list|)
condition|)
return|return
operator|-
name|KEY_oct
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"our"
argument_list|)
condition|)
return|return
name|KEY_our
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"open"
argument_list|)
condition|)
return|return
operator|-
name|KEY_open
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"opendir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_opendir
return|;
break|break;
block|}
break|break;
case|case
literal|'p'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pop"
argument_list|)
condition|)
return|return
operator|-
name|KEY_pop
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pos"
argument_list|)
condition|)
return|return
name|KEY_pos
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"push"
argument_list|)
condition|)
return|return
operator|-
name|KEY_push
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pack"
argument_list|)
condition|)
return|return
operator|-
name|KEY_pack
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pipe"
argument_list|)
condition|)
return|return
operator|-
name|KEY_pipe
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"print"
argument_list|)
condition|)
return|return
name|KEY_print
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"printf"
argument_list|)
condition|)
return|return
name|KEY_printf
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"package"
argument_list|)
condition|)
return|return
name|KEY_package
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"prototype"
argument_list|)
condition|)
return|return
name|KEY_prototype
return|;
block|}
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|len
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"q"
argument_list|)
condition|)
return|return
name|KEY_q
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qr"
argument_list|)
condition|)
return|return
name|KEY_qr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qq"
argument_list|)
condition|)
return|return
name|KEY_qq
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qw"
argument_list|)
condition|)
return|return
name|KEY_qw
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qx"
argument_list|)
condition|)
return|return
name|KEY_qx
return|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"quotemeta"
argument_list|)
condition|)
return|return
operator|-
name|KEY_quotemeta
return|;
break|break;
case|case
literal|'r'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ref"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ref
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"read"
argument_list|)
condition|)
return|return
operator|-
name|KEY_read
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rand"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rand
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"recv"
argument_list|)
condition|)
return|return
operator|-
name|KEY_recv
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"redo"
argument_list|)
condition|)
return|return
name|KEY_redo
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rmdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rmdir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reset"
argument_list|)
condition|)
return|return
operator|-
name|KEY_reset
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"return"
argument_list|)
condition|)
return|return
name|KEY_return
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rename"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rename
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rindex"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rindex
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"require"
argument_list|)
condition|)
return|return
operator|-
name|KEY_require
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reverse"
argument_list|)
condition|)
return|return
operator|-
name|KEY_reverse
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readdir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readlink
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readline"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readline
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readpipe"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readpipe
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rewinddir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rewinddir
return|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
return|return
name|KEY_s
return|;
case|case
literal|'c'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"scalar"
argument_list|)
condition|)
return|return
name|KEY_scalar
return|;
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seek"
argument_list|)
condition|)
return|return
operator|-
name|KEY_seek
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"send"
argument_list|)
condition|)
return|return
operator|-
name|KEY_send
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semop"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semop
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"select"
argument_list|)
condition|)
return|return
operator|-
name|KEY_select
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semget
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpgrp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpgrp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seekdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_seekdir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpwent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setgrent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setgrent
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setnetent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setnetent
return|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setsockopt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setsockopt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sethostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sethostent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setservent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setservent
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpriority"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpriority
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setprotoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setprotoent
return|;
break|break;
block|}
break|break;
case|case
literal|'h'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shift"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shift
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmget
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmread"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmread
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmwrite"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmwrite
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shutdown"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shutdown
return|;
break|break;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sin"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sin
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sleep"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sleep
return|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sort"
argument_list|)
condition|)
return|return
name|KEY_sort
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socket"
argument_list|)
condition|)
return|return
operator|-
name|KEY_socket
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socketpair"
argument_list|)
condition|)
return|return
operator|-
name|KEY_socketpair
return|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"split"
argument_list|)
condition|)
return|return
name|KEY_split
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sprintf"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sprintf
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"splice"
argument_list|)
condition|)
return|return
operator|-
name|KEY_splice
return|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sqrt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sqrt
return|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"srand"
argument_list|)
condition|)
return|return
operator|-
name|KEY_srand
return|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"stat"
argument_list|)
condition|)
return|return
operator|-
name|KEY_stat
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"study"
argument_list|)
condition|)
return|return
name|KEY_study
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"substr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_substr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sub"
argument_list|)
condition|)
return|return
name|KEY_sub
return|;
break|break;
case|case
literal|'y'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"system"
argument_list|)
condition|)
return|return
operator|-
name|KEY_system
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"symlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_symlink
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syscall"
argument_list|)
condition|)
return|return
operator|-
name|KEY_syscall
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysopen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysopen
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysread"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysread
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysseek"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysseek
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syswrite"
argument_list|)
condition|)
return|return
operator|-
name|KEY_syswrite
return|;
break|break;
block|}
break|break;
block|}
break|break;
case|case
literal|'t'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tr"
argument_list|)
condition|)
return|return
name|KEY_tr
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tie"
argument_list|)
condition|)
return|return
name|KEY_tie
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tell"
argument_list|)
condition|)
return|return
operator|-
name|KEY_tell
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tied"
argument_list|)
condition|)
return|return
name|KEY_tied
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"time"
argument_list|)
condition|)
return|return
operator|-
name|KEY_time
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"times"
argument_list|)
condition|)
return|return
operator|-
name|KEY_times
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"telldir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_telldir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"truncate"
argument_list|)
condition|)
return|return
operator|-
name|KEY_truncate
return|;
break|break;
block|}
break|break;
case|case
literal|'u'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"uc"
argument_list|)
condition|)
return|return
operator|-
name|KEY_uc
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"use"
argument_list|)
condition|)
return|return
name|KEY_use
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"undef"
argument_list|)
condition|)
return|return
name|KEY_undef
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"until"
argument_list|)
condition|)
return|return
name|KEY_until
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"untie"
argument_list|)
condition|)
return|return
name|KEY_untie
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"utime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_utime
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"umask"
argument_list|)
condition|)
return|return
operator|-
name|KEY_umask
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unless"
argument_list|)
condition|)
return|return
name|KEY_unless
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unpack"
argument_list|)
condition|)
return|return
operator|-
name|KEY_unpack
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_unlink
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unshift"
argument_list|)
condition|)
return|return
operator|-
name|KEY_unshift
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ucfirst"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ucfirst
return|;
break|break;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"values"
argument_list|)
condition|)
return|return
operator|-
name|KEY_values
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"vec"
argument_list|)
condition|)
return|return
operator|-
name|KEY_vec
return|;
break|break;
case|case
literal|'w'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"warn"
argument_list|)
condition|)
return|return
operator|-
name|KEY_warn
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wait"
argument_list|)
condition|)
return|return
operator|-
name|KEY_wait
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"while"
argument_list|)
condition|)
return|return
name|KEY_while
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"write"
argument_list|)
condition|)
return|return
operator|-
name|KEY_write
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"waitpid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_waitpid
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wantarray"
argument_list|)
condition|)
return|return
operator|-
name|KEY_wantarray
return|;
break|break;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|-
name|KEY_x
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"xor"
argument_list|)
condition|)
return|return
operator|-
name|KEY_xor
return|;
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
name|KEY_y
return|;
break|break;
case|case
literal|'z'
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_checkcomma
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|what
parameter_list|)
block|{
name|char
modifier|*
name|w
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* XXX gotta be a better way */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
for|for
control|(
name|w
operator|=
name|s
operator|+
literal|2
init|;
operator|*
name|w
operator|&&
name|level
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|w
operator|==
literal|'('
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|w
operator|==
literal|')'
condition|)
operator|--
name|level
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|w
condition|)
for|for
control|(
init|;
operator|*
name|w
operator|&&
name|isSPACE
argument_list|(
operator|*
name|w
argument_list|)
condition|;
name|w
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|w
operator|||
operator|!
name|strchr
argument_list|(
literal|";|})]oaiuw!="
argument_list|,
operator|*
name|w
argument_list|)
condition|)
comment|/* an advisory hack only... */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"%s (...) interpreted as function"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
block|}
block|}
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|w
operator|=
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isALNUM_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|int
name|kw
decl_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|kw
operator|=
name|keyword
argument_list|(
name|w
argument_list|,
name|s
operator|-
name|w
argument_list|)
operator|||
name|get_cv
argument_list|(
name|w
argument_list|,
name|FALSE
argument_list|)
operator|!=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|kw
condition|)
return|return;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No comma allowed after %s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Either returns sv, or mortalizes sv and returns a new SV*.    Best used as sv=new_constant(..., sv, ...).    If s, pv are NULL, calls subroutine with one argument,    and type is used with error messages only. */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|S_new_constant
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|SV
modifier|*
name|pv
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|HV
modifier|*
name|table
init|=
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
decl_stmt|;
comment|/* ^H */
name|SV
modifier|*
name|res
decl_stmt|;
name|SV
modifier|*
modifier|*
name|cvp
decl_stmt|;
name|SV
modifier|*
name|cv
decl_stmt|,
modifier|*
name|typesv
decl_stmt|;
specifier|const
name|char
modifier|*
name|why1
decl_stmt|,
modifier|*
name|why2
decl_stmt|,
modifier|*
name|why3
decl_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_LOCALIZE_HH
operator|)
condition|)
block|{
name|SV
modifier|*
name|msg
decl_stmt|;
name|why2
operator|=
name|strEQ
argument_list|(
name|key
argument_list|,
literal|"charnames"
argument_list|)
condition|?
literal|"(possibly a missing \"use charnames ...\")"
else|:
literal|""
expr_stmt|;
name|msg
operator|=
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"Constant(%s) unknown: %s"
argument_list|,
operator|(
name|type
condition|?
name|type
else|:
literal|"undef"
operator|)
argument_list|,
name|why2
argument_list|)
expr_stmt|;
comment|/* This is convoluted and evil ("goto considered harmful") 	 * but I do not understand the intricacies of all the different 	 * failure modes of %^H in here.  The goal here is to make 	 * the most probable error message user-friendly. --jhi */
goto|goto
name|msgdone
goto|;
name|report
label|:
name|msg
operator|=
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"Constant(%s): %s%s%s"
argument_list|,
operator|(
name|type
condition|?
name|type
else|:
literal|"undef"
operator|)
argument_list|,
name|why1
argument_list|,
name|why2
argument_list|,
name|why3
argument_list|)
expr_stmt|;
name|msgdone
label|:
name|yyerror
argument_list|(
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
name|cvp
operator|=
name|hv_fetch
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvp
operator|||
operator|!
name|SvOK
argument_list|(
operator|*
name|cvp
argument_list|)
condition|)
block|{
name|why1
operator|=
literal|"$^H{"
expr_stmt|;
name|why2
operator|=
name|key
expr_stmt|;
name|why3
operator|=
literal|"} is not defined"
expr_stmt|;
goto|goto
name|report
goto|;
block|}
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Parent created it permanently */
name|cv
operator|=
operator|*
name|cvp
expr_stmt|;
if|if
condition|(
operator|!
name|pv
operator|&&
name|s
condition|)
name|pv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|pv
condition|)
name|typesv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|typesv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_OVERLOAD
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|sp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|PUSHs
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|PUSHs
argument_list|(
name|typesv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
name|cv
argument_list|,
name|G_SCALAR
operator||
operator|(
name|PL_in_eval
condition|?
literal|0
else|:
name|G_EVAL
operator|)
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
comment|/* Check the eval first */
if|if
condition|(
operator|!
name|PL_in_eval
operator|&&
name|SvTRUE
argument_list|(
name|ERRSV
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|sv_catpv
argument_list|(
name|ERRSV
argument_list|,
literal|"Propagated"
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|SvPV
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Duplicates the message inside eval */
operator|(
name|void
operator|)
name|POPs
expr_stmt|;
name|res
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|POPs
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
name|PUTBACK
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
name|POPSTACK
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|why1
operator|=
literal|"Call to&{$^H{"
expr_stmt|;
name|why2
operator|=
name|key
expr_stmt|;
name|why3
operator|=
literal|"}} did not return a defined value"
expr_stmt|;
name|sv
operator|=
name|res
expr_stmt|;
goto|goto
name|report
goto|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_word
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|STRLEN
name|destlen
parameter_list|,
name|int
name|allow_package
parameter_list|,
name|STRLEN
modifier|*
name|slp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|dest
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
init|=
name|d
operator|+
name|destlen
operator|-
literal|3
decl_stmt|;
comment|/* two-character token, ending NUL */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* UTF handled below */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|&&
name|allow_package
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|allow_package
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'$'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UTF
operator|&&
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isALNUM_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|s
operator|+
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|t
argument_list|)
operator|&&
name|is_utf8_mark
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|t
argument_list|)
condition|)
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|+
operator|(
name|t
operator|-
name|s
operator|)
operator|>
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
name|Copy
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|t
operator|-
name|s
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|t
operator|-
name|s
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|slp
operator|=
name|d
operator|-
name|dest
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_ident
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|char
modifier|*
name|send
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|STRLEN
name|destlen
parameter_list|,
name|I32
name|ck_uni
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|bracket
init|=
literal|0
decl_stmt|;
name|char
name|funny
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
name|e
operator|=
name|d
operator|+
name|destlen
operator|-
literal|3
expr_stmt|;
comment|/* two-character token, ending NUL */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* UTF handled below */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|&&
name|isIDFIRST_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UTF
operator|&&
name|UTF8_IS_START
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isALNUM_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|s
operator|+
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|t
argument_list|)
operator|&&
name|is_utf8_mark
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|t
argument_list|)
condition|)
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|+
operator|(
name|t
operator|-
name|s
operator|)
operator|>
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
name|Copy
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|t
operator|-
name|s
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|t
operator|-
name|s
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_NORMAL
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPENDMAYBE
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|isALNUM_lazy_if
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|UTF
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"${"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
return|return
name|s
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|bracket
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ck_uni
condition|)
name|check_uni
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'^'
operator|&&
operator|*
name|s
operator|&&
name|isCONTROLVAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|d
operator|=
name|toCTRL
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bracket
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|char
name|ch
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|SPACE_OR_TAB
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|d
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isIDFIRST_lazy_if
argument_list|(
name|d
argument_list|,
name|UTF
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
name|e
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|<
name|send
operator|&&
name|isALNUM_lazy_if
argument_list|(
name|e
argument_list|,
name|UTF
argument_list|)
operator|)
operator|||
operator|*
name|e
operator|==
literal|':'
condition|)
block|{
name|e
operator|+=
name|UTF8SKIP
argument_list|(
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|<
name|send
operator|&&
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|e
argument_list|)
operator|&&
name|is_utf8_mark
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|e
argument_list|)
condition|)
name|e
operator|+=
name|UTF8SKIP
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|Copy
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|e
operator|-
name|s
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|e
operator|-
name|s
expr_stmt|;
name|s
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
operator|)
operator|&&
name|d
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|SPACE_OR_TAB
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|&&
name|strNE
argument_list|(
name|dest
argument_list|,
literal|"sub"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
operator|&&
name|keyword
argument_list|(
name|dest
argument_list|,
name|d
operator|-
name|dest
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|brack
init|=
operator|*
name|s
operator|==
literal|'['
condition|?
literal|"[...]"
else|:
literal|"{...}"
decl_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Ambiguous use of %c{%s%s} resolved to %c%s%s"
argument_list|,
argument|funny
argument_list|,
argument|dest
argument_list|,
argument|brack
argument_list|,
argument|funny
argument_list|,
argument|dest
argument_list|,
argument|brack
argument_list|)
empty_stmt|;
block|}
name|bracket
operator|++
expr_stmt|;
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|XOPERATOR
operator||
name|XFAKEBRACK
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
comment|/* Handle extended ${^Foo} variables 	 * 1999-02-27 mjd-perl-patch@plover.com */
elseif|else
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
operator|&&
operator|!
name|isPRINT
argument_list|(
operator|*
name|d
argument_list|)
comment|/* isCTRL(d) */
operator|&&
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|d
operator|<
name|e
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ ident_too_long
argument_list|)
empty_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
operator|&&
operator|!
name|PL_lex_brackets
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
if|if
condition|(
name|funny
operator|==
literal|'#'
condition|)
name|funny
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_AMBIGUOUS
argument_list|)
operator|&&
operator|(
name|keyword
argument_list|(
name|dest
argument_list|,
name|d
operator|-
name|dest
argument_list|)
operator|||
name|get_cv
argument_list|(
name|dest
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_AMBIGUOUS
argument_list|,
literal|"Ambiguous use of %c{%s} resolved to %c%s"
argument_list|,
argument|funny
argument_list|,
argument|dest
argument_list|,
argument|funny
argument_list|,
argument|dest
argument_list|)
empty_stmt|;
block|}
block|}
block|}
else|else
block|{
name|s
operator|=
name|bracket
expr_stmt|;
comment|/* let the parser handle it */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
operator|&&
operator|!
name|PL_lex_brackets
operator|&&
operator|!
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|Perl_pmflag
parameter_list|(
name|pTHX_
name|U16
modifier|*
name|pmfl
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'i'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_FOLD
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'g'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_GLOBAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_CONTINUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'o'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_KEEP
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'m'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_MULTILINE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'s'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_SINGLELINE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'x'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_EXTENDED
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_pat
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Search pattern not terminated"
argument_list|)
expr_stmt|;
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|newPMOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_multi_open
operator|==
literal|'?'
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_ONCE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_QR
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"iomsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|pm
operator|->
name|op_pmpermflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|pm
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_MATCH
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_subst
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|I32
name|first_start
decl_stmt|;
name|I32
name|es
init|=
literal|0
decl_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Substitution pattern not terminated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|PL_multi_open
condition|)
name|s
operator|--
expr_stmt|;
name|first_start
operator|=
name|PL_multi_start
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
block|}
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Substitution replacement not terminated"
argument_list|)
expr_stmt|;
block|}
name|PL_multi_start
operator|=
name|first_start
expr_stmt|;
comment|/* so whole substitution is taken together */
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|newPMOP
argument_list|(
name|OP_SUBST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|es
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|es
condition|)
block|{
name|SV
modifier|*
name|repl
decl_stmt|;
name|PL_sublex_info
operator|.
name|super_bufptr
operator|=
name|s
expr_stmt|;
name|PL_sublex_info
operator|.
name|super_bufend
operator|=
name|PL_bufend
expr_stmt|;
name|PL_multi_end
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_EVAL
expr_stmt|;
name|repl
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|es
operator|--
operator|>
literal|0
condition|)
name|sv_catpv
argument_list|(
name|repl
argument_list|,
name|es
condition|?
literal|"eval "
else|:
literal|"do "
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|repl
argument_list|,
literal|"{ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|repl
argument_list|,
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|repl
argument_list|,
literal|" };"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SvEVALED_on
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|repl
expr_stmt|;
block|}
name|pm
operator|->
name|op_pmpermflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|pm
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_SUBST
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_trans
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|short
modifier|*
name|tbl
decl_stmt|;
name|I32
name|squash
decl_stmt|;
name|I32
name|del
decl_stmt|;
name|I32
name|complement
decl_stmt|;
name|I32
name|utf8
decl_stmt|;
name|I32
name|count
init|=
literal|0
decl_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Transliteration pattern not terminated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|PL_multi_open
condition|)
name|s
operator|--
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
block|}
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Transliteration replacement not terminated"
argument_list|)
expr_stmt|;
block|}
name|New
argument_list|(
literal|803
argument_list|,
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|o
operator|=
name|newPVOP
argument_list|(
name|OP_TRANS
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbl
argument_list|)
expr_stmt|;
name|complement
operator|=
name|del
operator|=
name|squash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|strchr
argument_list|(
literal|"cds"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'c'
condition|)
name|complement
operator|=
name|OPpTRANS_COMPLEMENT
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
condition|)
name|del
operator|=
name|OPpTRANS_DELETE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'s'
condition|)
name|squash
operator|=
name|OPpTRANS_SQUASH
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|o
operator|->
name|op_private
operator|=
name|del
operator||
name|squash
operator||
name|complement
operator||
operator|(
name|DO_UTF8
argument_list|(
name|PL_lex_stuff
argument_list|)
condition|?
name|OPpTRANS_FROM_UTF
else|:
literal|0
operator|)
operator||
operator|(
name|DO_UTF8
argument_list|(
name|PL_lex_repl
argument_list|)
condition|?
name|OPpTRANS_TO_UTF
else|:
literal|0
operator|)
expr_stmt|;
name|PL_lex_op
operator|=
name|o
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_TRANS
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_heredoc
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
name|SV
modifier|*
name|herewas
decl_stmt|;
name|I32
name|op_type
init|=
name|OP_SCALAR
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|SV
modifier|*
name|tmpstr
decl_stmt|;
name|char
name|term
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|peek
decl_stmt|;
name|int
name|outer
init|=
operator|(
name|PL_rsfp
operator|&&
operator|!
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SCALAR
operator|)
operator|)
decl_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|outer
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|peek
operator|=
name|s
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|peek
argument_list|)
condition|;
name|peek
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|peek
operator|&&
name|strchr
argument_list|(
literal|"`'\""
argument_list|,
operator|*
name|peek
argument_list|)
condition|)
block|{
name|s
operator|=
name|peek
expr_stmt|;
name|term
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|delimcpy
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|term
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|d
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|s
operator|++
operator|,
name|term
operator|=
literal|'\''
expr_stmt|;
else|else
name|term
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
operator|!
name|isALNUM_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|)
name|deprecate
argument_list|(
literal|"bare<< to mean<<\"\""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isALNUM_lazy_if
argument_list|(
name|s
argument_list|,
name|UTF
argument_list|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|>=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Delimiter for here document is too long"
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|d
operator|-
name|PL_tokenbuf
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
name|d
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|char
modifier|*
name|olds
init|=
name|s
decl_stmt|;
name|s
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\r'
condition|)
block|{
comment|/* \015\013 on a mac? */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|PL_bufend
operator|=
name|d
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|PL_bufend
operator|-
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|olds
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|outer
operator|||
operator|!
operator|(
name|d
operator|=
name|ninstr
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|d
argument_list|,
name|d
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|herewas
operator|=
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|PL_bufend
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|--
operator|,
name|herewas
operator|=
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SvCUR
argument_list|(
name|herewas
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|NEWSV
argument_list|(
literal|87
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|tmpstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\''
condition|)
block|{
name|op_type
operator|=
name|OP_CONST
expr_stmt|;
name|SvIVX
argument_list|(
name|tmpstr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|term
operator|==
literal|'`'
condition|)
block|{
name|op_type
operator|=
name|OP_BACKTICK
expr_stmt|;
name|SvIVX
argument_list|(
name|tmpstr
argument_list|)
operator|=
literal|'\\'
expr_stmt|;
block|}
name|CLINE
expr_stmt|;
name|PL_multi_start
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|PL_multi_open
operator|=
name|PL_multi_close
operator|=
literal|'<'
expr_stmt|;
name|term
operator|=
operator|*
name|PL_tokenbuf
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|char
modifier|*
name|bufptr
init|=
name|PL_sublex_info
operator|.
name|super_bufptr
decl_stmt|;
name|char
modifier|*
name|bufend
init|=
name|PL_sublex_info
operator|.
name|super_bufend
decl_stmt|;
name|char
modifier|*
name|olds
init|=
name|s
operator|-
name|SvCUR
argument_list|(
name|herewas
argument_list|)
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|bufptr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|bufend
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
operator|(
operator|*
name|s
operator|!=
name|term
operator|||
name|memNE
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_start
argument_list|)
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|sv_setpvn
argument_list|(
name|herewas
argument_list|,
name|bufptr
argument_list|,
name|d
operator|-
name|bufptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|sv_catpvn
argument_list|(
name|herewas
argument_list|,
name|s
argument_list|,
name|bufend
operator|-
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bufptr
argument_list|,
name|SvPVX
argument_list|(
name|herewas
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|olds
expr_stmt|;
goto|goto
name|retval
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|outer
condition|)
block|{
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|s
operator|!=
name|term
operator|||
name|memNE
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
name|PL_bufend
condition|)
block|{
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_start
argument_list|)
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
comment|/* the preceding stmt passes a newline */
name|sv_catpvn
argument_list|(
name|herewas
argument_list|,
name|s
argument_list|,
name|PL_bufend
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|PL_linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
block|}
else|else
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* avoid "uninitialized" warning */
while|while
condition|(
name|s
operator|>=
name|PL_bufend
condition|)
block|{
comment|/* multiple line string? */
if|if
condition|(
operator|!
name|outer
operator|||
operator|!
operator|(
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_start
argument_list|)
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
if|if
condition|(
name|PL_bufend
operator|-
name|PL_linestart
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|PL_bufend
operator|--
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|PL_bufend
operator|-
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufend
operator|-
name|PL_linestart
operator|==
literal|1
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|88
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|term
operator|&&
name|memEQ
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|s
operator|=
name|PL_bufend
operator|-
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
name|sv_catsv
argument_list|(
name|PL_linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|PL_bufend
expr_stmt|;
name|sv_catsv
argument_list|(
name|tmpstr
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|++
expr_stmt|;
name|retval
label|:
name|PL_multi_end
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|tmpstr
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|herewas
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|IN_BYTE
operator|&&
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
condition|)
name|SvUTF8_on
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|tmpstr
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|op_type
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* scan_inputsymbol    takes: current position in input buffer    returns: new position in input buffer    side-effects: yylval and lex_op are set.     This code handles:<>		read from ARGV<FH> 	read from filehandle<pkg::FH>	read from package qualified filehandle<pkg'FH>	read from package qualified filehandle<$fh>	read from filehandle in $fh<*.h>	filename glob  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_inputsymbol
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in buffer */
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
comment|/* start of temp holding space */
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
expr_stmt|;
comment|/* end of temp holding space */
name|end
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|PL_bufend
expr_stmt|;
name|s
operator|=
name|delimcpy
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|end
argument_list|,
literal|'>'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* extract until> */
comment|/* die if we didn't have space for the contents of the<>,        or if it didn't end, or if we see a newline     */
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|PL_tokenbuf
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Excessively long<> operator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|end
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unterminated<> operator"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* check for<$fh>        Remember, only scalar variables are interpreted as filehandles by        this code.  Anything more complex (e.g.,<$fh{$num}>) will be        treated as a glob() call.        This code makes use of the fact that except for the $ at the front,        a scalar variable and a filehandle look the same.     */
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
condition|)
name|d
operator|++
expr_stmt|;
comment|/* allow<Pkg'VALUE> or<Pkg::VALUE> */
while|while
condition|(
operator|*
name|d
operator|&&
operator|(
name|isALNUM_lazy_if
argument_list|(
name|d
argument_list|,
name|UTF
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'\''
operator|||
operator|*
name|d
operator|==
literal|':'
operator|)
condition|)
name|d
operator|++
expr_stmt|;
comment|/* If we've tried to read what we allow filehandles to look like, and        there's still text left, then it must be a glob() and not a getline.        Use scan_str to pull out the stuff between the<> and treat it        as nothing more than a string.     */
if|if
condition|(
name|d
operator|-
name|PL_tokenbuf
operator|!=
name|len
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|OP_GLOB
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Glob not terminated"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
comment|/* we're in a filehandle read situation */
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
comment|/* turn<> into<ARGV> */
if|if
condition|(
operator|!
name|len
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"ARGV"
argument_list|)
expr_stmt|;
comment|/* if<$fh>, create the ops to turn the variable into a 	   filehandle 	*/
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
condition|)
block|{
name|I32
name|tmp
decl_stmt|;
comment|/* try to find it in the pad for this block, otherwise find 	       add symbol table ops 	    */
if|if
condition|(
operator|(
name|tmp
operator|=
name|pad_findmy
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|OP
modifier|*
name|o
init|=
name|newOP
argument_list|(
name|OP_PADSV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
decl_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|newUNOP
argument_list|(
name|OP_RV2SV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PL_lex_op
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* we created the ops in PL_lex_op, so make yylval.ival a null op */
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
block|}
comment|/* If it's none of the above, it must be a literal filehandle 	   (<Foo::BAR> or<FOO>) so build a simple readline OP */
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|d
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
decl_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* scan_str    takes: start position in buffer 	  keep_quoted preserve \ on the embedded delimiter(s) 	  keep_delims preserve the delimiters around the string    returns: position to continue reading from buffer    side-effects: multi_start, multi_close, lex_repl or lex_stuff, and    	updates the read buffer.     This subroutine pulls a string out of the input.  It is called for:    	q		single quotes		q(literal text) 	'		single quotes		'literal text' 	qq		double quotes		qq(interpolate $here please) 	"		double quotes		"interpolate $here please" 	qx		backticks		qx(/bin/ls -l) 	`		backticks		`/bin/ls -l` 	qw		quote words		@EXPORT_OK = qw( func() $spam ) 	m//		regexp match		m/this/ 	s///		regexp substitute	s/this/that/ 	tr///		string transliterate	tr/this/that/ 	y///		string transliterate	y/this/that/ 	($*@)		sub prototypes		sub foo ($) 	(stuff)		sub attr parameters	sub foo : attr(stuff)<>		readline or globs<FOO>,<>,<$fh>, or<*.c> 	    In most of these cases (all but<>, patterns and transliterate)    yylex() calls scan_str().  m// makes yylex() call scan_pat() which    calls scan_str().  s/// makes yylex() call scan_subst() which calls    scan_str().  tr/// and y/// make yylex() call scan_trans() which    calls scan_str().     It skips whitespace before the string starts, and treats the first    character as the delimiter.  If the delimiter is one of ([{< then    the corresponding "close" character )]}> is used as the closing    delimiter.  It allows quoting of delimiters, and if the string has    balanced delimiters ([{<>}]) it allows nesting.     On success, the SV with the resulting string is put into lex_stuff or,    if that is already non-NULL, into lex_repl. The second case occurs only    when parsing the RHS of the special constructs s/// and tr/// (y///).    For convenience, the terminating delimiter character is stuffed into    SvIVX of the SV. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_str
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|int
name|keep_quoted
parameter_list|,
name|int
name|keep_delims
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
comment|/* scalar value: string */
name|char
modifier|*
name|tmps
decl_stmt|;
comment|/* temp string, used for delimiter matching */
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in the buffer */
specifier|register
name|char
name|term
decl_stmt|;
comment|/* terminating character */
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
comment|/* current position in the sv's data */
name|I32
name|brackets
init|=
literal|1
decl_stmt|;
comment|/* bracket nesting level */
name|bool
name|has_utf8
init|=
name|FALSE
decl_stmt|;
comment|/* is there any utf8 content? */
comment|/* skip space before the delimiter */
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* mark where we are, in case we need to report errors */
name|CLINE
expr_stmt|;
comment|/* after skipping whitespace, the next character is the terminator */
name|term
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
name|term
argument_list|)
operator|&&
name|UTF
condition|)
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
comment|/* mark where we are */
name|PL_multi_start
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|PL_multi_open
operator|=
name|term
expr_stmt|;
comment|/* find corresponding closing delimiter */
if|if
condition|(
name|term
operator|&&
operator|(
name|tmps
operator|=
name|strchr
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|tmps
index|[
literal|5
index|]
expr_stmt|;
name|PL_multi_close
operator|=
name|term
expr_stmt|;
comment|/* create a new SV to hold the contents.  87 is leak category, I'm        assuming.  79 is the SV's initial length.  What a random number. */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|87
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|term
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
comment|/* move past delimiter and try to read a complete string */
if|if
condition|(
name|keep_delims
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* extend sv if need be */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
operator|(
name|PL_bufend
operator|-
name|s
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* set 'to' to the next character in the sv's string */
name|to
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* if open delimiter is the close delimiter read unbridle */
if|if
condition|(
name|PL_multi_open
operator|==
name|PL_multi_close
condition|)
block|{
for|for
control|(
init|;
name|s
operator|<
name|PL_bufend
condition|;
name|s
operator|++
operator|,
name|to
operator|++
control|)
block|{
comment|/* embedded newlines increment the current line number */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|PL_rsfp
condition|)
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
comment|/* handle quoted delimiters */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|PL_bufend
operator|&&
name|term
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|keep_quoted
operator|&&
name|s
index|[
literal|1
index|]
operator|==
name|term
condition|)
name|s
operator|++
expr_stmt|;
comment|/* any other quotes are simply copied straight through */
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* terminate when run out of buffer (the for() condition), or 		   have found the terminator */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|term
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|has_utf8
operator|&&
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|UTF
condition|)
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
operator|*
name|to
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
comment|/* if the terminator isn't the same as the start character (e.g., 	   matched brackets), we have to allow more in the quoting, and 	   be prepared for nested brackets. 	*/
else|else
block|{
comment|/* read until we run out of string, or we find the terminator */
for|for
control|(
init|;
name|s
operator|<
name|PL_bufend
condition|;
name|s
operator|++
operator|,
name|to
operator|++
control|)
block|{
comment|/* embedded newlines increment the line count */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|PL_rsfp
condition|)
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
comment|/* backslashes can escape the open or closing characters */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|PL_bufend
condition|)
block|{
if|if
condition|(
operator|!
name|keep_quoted
operator|&&
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|PL_multi_open
operator|)
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|PL_multi_close
operator|)
operator|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* allow nested opens and closes */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|PL_multi_close
operator|&&
operator|--
name|brackets
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|PL_multi_open
condition|)
name|brackets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|has_utf8
operator|&&
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|UTF
condition|)
name|has_utf8
operator|=
name|TRUE
expr_stmt|;
operator|*
name|to
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
comment|/* terminate the copied string and update the sv's end-of-string */
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * this next chunk reads more into the buffer if we're not done yet 	 */
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
break|break;
comment|/* handle case where we are done yet :-) */
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
if|if
condition|(
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|to
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|to
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|to
index|[
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|to
operator|--
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|to
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|1
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|to
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
comment|/* if we're out of file, or a read fails, bail and reset the current 	   line marker so we can report where the unterminated string began 	*/
if|if
condition|(
operator|!
name|PL_rsfp
operator|||
operator|!
operator|(
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|sv_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_start
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/* we read a line, so increment our line counter */
name|CopLINE_inc
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
comment|/* update debugger info */
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|88
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
comment|/* having changed the buffer, we must update PL_bufend */
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
block|}
comment|/* at this point, we have successfully read the delimited string */
if|if
condition|(
name|keep_delims
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_utf8
condition|)
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_multi_end
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* if we allocated too much space, give some back */
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/* decide whether this is the first or second quoted string we've read        for this op     */
if|if
condition|(
name|PL_lex_stuff
condition|)
name|PL_lex_repl
operator|=
name|sv
expr_stmt|;
else|else
name|PL_lex_stuff
operator|=
name|sv
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*   scan_num   takes: pointer to position in buffer   returns: pointer to new position in buffer   side-effects: builds ops for the constant in yylval.op    Read a number in any of the formats that Perl accepts:    0(x[0-7A-F]+)|([0-7]+)|(b[01])   [\d_]+(\.[\d_]*)?[Ee](\d+)    Underbars (_) are allowed in decimal numbers.  If -w is on,   underbars before a decimal point must be at three digit intervals.    Like most scan_ routines, it uses the PL_tokenbuf buffer to hold the   thing it reads.    If it reads a number without a decimal point or an exponent, it will   try converting the number to an integer and see if it can do so   without loss of precision. */
end_comment

begin_function
name|char
modifier|*
name|Perl_scan_num
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|YYSTYPE
modifier|*
name|lvalp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in buffer */
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
comment|/* destination in temp buffer */
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
comment|/* end of temp buffer */
name|NV
name|nv
decl_stmt|;
comment|/* number read, as a double */
name|SV
modifier|*
name|sv
init|=
name|Nullsv
decl_stmt|;
comment|/* place to put the converted number */
name|bool
name|floatit
decl_stmt|;
comment|/* boolean: int or float? */
name|char
modifier|*
name|lastub
init|=
literal|0
decl_stmt|;
comment|/* position of last underbar */
specifier|static
name|char
name|number_too_long
index|[]
init|=
literal|"Number too long"
decl_stmt|;
comment|/* We use the first character to decide what type of number this is */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: scan_num"
argument_list|)
expr_stmt|;
comment|/* if it starts with a 0, it could be an octal number, a decimal in        0.13 disguise, or a hexadecimal number, or a binary number. */
case|case
literal|'0'
case|:
block|{
comment|/* variables: 	     u		holds the "number so far" 	     shift	the power of 2 of the base 			(hex == 4, octal == 3, binary == 1) 	     overflowed	was the number more than we can hold?  	     Shift is used when we add a digit.  It also serves as an "are 	     we in octal/hex/binary?" indicator to disallow hex characters 	     when in octal mode. 	   */
name|NV
name|n
init|=
literal|0.0
decl_stmt|;
name|UV
name|u
init|=
literal|0
decl_stmt|;
name|I32
name|shift
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
specifier|static
name|NV
name|nvshift
index|[
literal|5
index|]
init|=
block|{
literal|1.0
block|,
literal|2.0
block|,
literal|4.0
block|,
literal|8.0
block|,
literal|16.0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bases
index|[
literal|5
index|]
init|=
block|{
literal|""
block|,
literal|"binary"
block|,
literal|""
block|,
literal|"octal"
block|,
literal|"hexadecimal"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|Bases
index|[
literal|5
index|]
init|=
block|{
literal|""
block|,
literal|"Binary"
block|,
literal|""
block|,
literal|"Octal"
block|,
literal|"Hexadecimal"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|maxima
index|[
literal|5
index|]
init|=
block|{
literal|""
block|,
literal|"0b11111111111111111111111111111111"
block|,
literal|""
block|,
literal|"037777777777"
block|,
literal|"0xffffffff"
block|}
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|Base
decl_stmt|,
modifier|*
name|max
decl_stmt|;
comment|/* check for hex */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
name|shift
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* check for a decimal in disguise */
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'e'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
goto|goto
name|decimal
goto|;
comment|/* so it must be octal */
else|else
name|shift
operator|=
literal|3
expr_stmt|;
name|base
operator|=
name|bases
index|[
name|shift
index|]
expr_stmt|;
name|Base
operator|=
name|Bases
index|[
name|shift
index|]
expr_stmt|;
name|max
operator|=
name|maxima
index|[
name|shift
index|]
expr_stmt|;
comment|/* read the rest of the number */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* x is used in the overflow test, 		   b is the digit we're adding on. */
name|UV
name|x
decl_stmt|,
name|b
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* if we don't mention it, we're done */
default|default:
goto|goto
name|out
goto|;
comment|/* _ are ignored */
case|case
literal|'_'
case|:
name|s
operator|++
expr_stmt|;
break|break;
comment|/* 8 and 9 are not octal */
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|shift
operator|==
literal|3
condition|)
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Illegal octal digit '%c'"
argument_list|,
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
comment|/* octal digits */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
if|if
condition|(
name|shift
operator|==
literal|1
condition|)
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Illegal binary digit '%c'"
argument_list|,
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
name|b
operator|=
operator|*
name|s
operator|++
operator|&
literal|15
expr_stmt|;
comment|/* ASCII digit -> value of digit */
goto|goto
name|digit
goto|;
comment|/* hex digits */
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
comment|/* make sure they said 0x */
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
goto|goto
name|out
goto|;
name|b
operator|=
operator|(
operator|*
name|s
operator|++
operator|&
literal|7
operator|)
operator|+
literal|9
expr_stmt|;
comment|/* Prepare to put the digit we have onto the end 		       of the number so far.  We check for overflows. 		    */
name|digit
label|:
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
name|x
operator|=
name|u
operator|<<
name|shift
expr_stmt|;
comment|/* make room for the digit */
if|if
condition|(
operator|(
name|x
operator|>>
name|shift
operator|)
operator|!=
name|u
operator|&&
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_NEW_BINARY
operator|)
condition|)
block|{
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|n
operator|=
operator|(
name|NV
operator|)
name|u
expr_stmt|;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_OVERFLOW
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_OVERFLOW
argument_list|,
literal|"Integer overflow in %s number"
argument_list|,
argument|base
argument_list|)
empty_stmt|;
block|}
else|else
name|u
operator|=
name|x
operator||
name|b
expr_stmt|;
comment|/* add the digit to the end */
block|}
if|if
condition|(
name|overflowed
condition|)
block|{
name|n
operator|*=
name|nvshift
index|[
name|shift
index|]
expr_stmt|;
comment|/* If an NV has not enough bits in its 			 * mantissa to represent an UV this summing of 			 * small low-order numbers is a waste of time 			 * (because the NV cannot preserve the 			 * low-order bits anyway): we could just 			 * remember when did we overflow and in the 			 * end just multiply n by the right 			 * amount. */
name|n
operator|+=
operator|(
name|NV
operator|)
name|b
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* if we get here, we had success: make a scalar value from 	     the number. 	  */
name|out
label|:
name|sv
operator|=
name|NEWSV
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflowed
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PORTABLE
argument_list|)
operator|&&
name|n
operator|>
literal|4294967295.0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PORTABLE
argument_list|,
literal|"%s number> %s non-portable"
argument_list|,
argument|Base
argument_list|,
argument|max
argument_list|)
empty_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|UVSIZE
operator|>
literal|4
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PORTABLE
argument_list|)
operator|&&
name|u
operator|>
literal|0xffffffff
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PORTABLE
argument_list|,
literal|"%s number> %s non-portable"
argument_list|,
argument|Base
argument_list|,
argument|max
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_BINARY
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|,
literal|"binary"
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*       handle decimal numbers.       we're also sent here when we read a 0 as the first digit     */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|decimal
label|:
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|6
expr_stmt|;
comment|/* room for various punctuation */
name|floatit
operator|=
name|FALSE
expr_stmt|;
comment|/* read next group of digits and _ and copy into d */
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
comment|/* skip underscores, checking for misplaced ones 	       if -w is on 	    */
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
operator|&&
name|lastub
operator|&&
name|s
operator|-
name|lastub
operator|!=
literal|3
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Misplaced _ in number"
argument_list|)
empty_stmt|;
name|lastub
operator|=
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* check for end of fixed-length buffer */
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ number_too_long
argument_list|)
empty_stmt|;
comment|/* if we're ok, copy the character */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* final misplaced underbar check */
if|if
condition|(
name|lastub
operator|&&
name|s
operator|-
name|lastub
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Misplaced _ in number"
argument_list|)
empty_stmt|;
block|}
comment|/* read a decimal portion if there is one.  avoid 	   3..5 being interpreted as the number 3. followed 	   by .5 	*/
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|floatit
operator|=
name|TRUE
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* copy, ignoring underbars, until we run out of 	       digits.  Note: no misplaced underbar checks! 	    */
for|for
control|(
init|;
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|;
name|s
operator|++
control|)
block|{
comment|/* fixed length buffer check */
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ number_too_long
argument_list|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'_'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* oops, it's really a v-string, but without the "v" */
name|s
operator|=
name|start
operator|-
literal|1
expr_stmt|;
goto|goto
name|vstring
goto|;
block|}
block|}
comment|/* read exponent part, if present */
if|if
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"eE"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"+-0123456789"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|floatit
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* regardless of whether user said 3E5 or 3e5, use lower 'e' */
operator|*
name|d
operator|++
operator|=
literal|'e'
expr_stmt|;
comment|/* At least some Mach atof()s don't grok 'E' */
comment|/* allow positive or negative exponent */
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* read digits of exponent (no underbars :-) */
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ number_too_long
argument_list|)
empty_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* terminate the string */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
comment|/* make an sv from the string */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Strtol
argument_list|)
operator|&&
name|defined
argument_list|(
name|Strtoul
argument_list|)
comment|/* 	   strtol/strtoll sets errno to ERANGE if the number is too big 	   for an integer. We try to do an integer conversion first 	   if no characters indicating "float" have been found. 	 */
if|if
condition|(
operator|!
name|floatit
condition|)
block|{
name|IV
name|iv
decl_stmt|;
name|UV
name|uv
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|PL_tokenbuf
operator|==
literal|'-'
condition|)
name|iv
operator|=
name|Strtol
argument_list|(
name|PL_tokenbuf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|uv
operator|=
name|Strtoul
argument_list|(
name|PL_tokenbuf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|floatit
operator|=
name|TRUE
expr_stmt|;
comment|/* Probably just too large. */
elseif|else
if|if
condition|(
operator|*
name|PL_tokenbuf
operator|==
literal|'-'
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|iv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uv
operator|<=
name|IV_MAX
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|uv
argument_list|)
expr_stmt|;
comment|/* Prefer IVs over UVs. */
else|else
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|uv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|floatit
condition|)
block|{
name|nv
operator|=
name|Atof
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	   No working strtou?ll?.  	   Unfortunately atol() doesn't do range checks (returning 	   LONG_MIN/LONG_MAX, and setting errno to ERANGE on overflows) 	   everywhere [1], so we cannot use use atol() (or atoll()). 	   If we could, they would be used, as Atol(), very much like 	   Strtol() and Strtoul() are used above.  	   [1] XXX Configure test needed to check for atol() 	           (and atoll()) overflow behaviour XXX  	   --jhi  	   We need to do this the hard way.  */
name|nv
operator|=
name|Atof
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
comment|/* See if we can make do with an integer value without loss of 	   precision.  We use U_V to cast to a UV, because some 	   compilers have issues.  Then we try casting it back and see 	   if it was the same [1].  We only do this if we know we 	   specifically read an integer.  If floatit is true, then we 	   don't need to do the conversion at all.  	   [1] Note that this is lossy if our NVs cannot preserve our 	   UVs.  There are metaconfig defines NV_PRESERVES_UV (a boolean) 	   and NV_PRESERVES_UV_BITS (a number), but in general we really 	   do hope all such potentially lossy platforms have strtou?ll? 	   to do a lossless IV/UV conversion.  	   Maybe could do some tricks with DBL_DIG, LDBL_DIG and 	   DBL_MANT_DIG and LDBL_MANT_DIG (these are already available 	   as NV_DIG and NV_MANT_DIG)? 	 	   --jhi 	   */
block|{
name|UV
name|uv
init|=
name|U_V
argument_list|(
name|nv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|floatit
operator|&&
operator|(
name|NV
operator|)
name|uv
operator|==
name|nv
condition|)
block|{
if|if
condition|(
name|uv
operator|<=
name|IV_MAX
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|uv
argument_list|)
expr_stmt|;
comment|/* Prefer IVs over UVs. */
else|else
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|uv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|floatit
condition|?
operator|(
name|PL_hints
operator|&
name|HINT_NEW_FLOAT
operator|)
else|:
operator|(
name|PL_hints
operator|&
name|HINT_NEW_INTEGER
operator|)
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|PL_tokenbuf
argument_list|,
name|d
operator|-
name|PL_tokenbuf
argument_list|,
operator|(
name|floatit
condition|?
literal|"float"
else|:
literal|"integer"
operator|)
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* if it starts with a v, it could be a v-string */
case|case
literal|'v'
case|:
name|vstring
label|:
block|{
name|char
modifier|*
name|pos
init|=
name|s
decl_stmt|;
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pos
argument_list|)
operator|||
operator|*
name|pos
operator|==
literal|'_'
condition|)
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
block|{
name|UV
name|rev
decl_stmt|;
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|U8
modifier|*
name|tmpend
decl_stmt|;
name|bool
name|utf8
init|=
name|FALSE
decl_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* get past 'v' */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|92
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|yyerror
argument_list|(
literal|"Octal number in vector unsupported"
argument_list|)
expr_stmt|;
name|rev
operator|=
literal|0
expr_stmt|;
block|{
comment|/* this is atoi() that tolerates underscores */
name|char
modifier|*
name|end
init|=
name|pos
decl_stmt|;
name|UV
name|mult
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|--
name|end
operator|>=
name|s
condition|)
block|{
name|UV
name|orev
decl_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'_'
condition|)
continue|continue;
name|orev
operator|=
name|rev
expr_stmt|;
name|rev
operator|+=
operator|(
operator|*
name|end
operator|-
literal|'0'
operator|)
operator|*
name|mult
expr_stmt|;
name|mult
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|orev
operator|>
name|rev
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_OVERFLOW
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_OVERFLOW
argument_list|,
literal|"Integer overflow in decimal number"
argument_list|)
empty_stmt|;
block|}
block|}
name|tmpend
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|utf8
operator|=
name|utf8
operator|||
name|rev
operator|>
literal|127
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|tmpend
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|pos
index|[
literal|1
index|]
argument_list|)
condition|)
name|s
operator|=
operator|++
name|pos
expr_stmt|;
else|else
block|{
name|s
operator|=
name|pos
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pos
argument_list|)
operator|||
operator|*
name|pos
operator|==
literal|'_'
condition|)
name|pos
operator|++
expr_stmt|;
block|}
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8
condition|)
block|{
name|SvUTF8_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|UTF
operator|||
name|IN_BYTE
condition|)
name|sv_utf8_downgrade
argument_list|(
name|sv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* make the op for the constant and return */
if|if
condition|(
name|sv
condition|)
name|lvalp
operator|->
name|opval
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
else|else
name|lvalp
operator|->
name|opval
operator|=
name|Nullop
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_scan_formline
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|eol
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|SV
modifier|*
name|stuff
init|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|needargs
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|!
name|needargs
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|||
operator|*
name|s
operator|==
comment|/*{*/
literal|'}'
condition|)
block|{
comment|/*SUPPRESS 530*/
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
else|#
directive|else
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
name|SPACE_OR_TAB
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'\r'
condition|;
name|t
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
operator|||
name|t
operator|==
name|PL_bufend
condition|)
break|break;
block|}
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|eol
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
operator|++
condition|)
name|eol
operator|=
name|PL_bufend
expr_stmt|;
block|}
else|else
name|eol
operator|=
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'#'
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
operator|<
name|eol
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'~'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'~'
operator|&&
name|SvCUR
argument_list|(
name|stuff
argument_list|)
condition|)
block|{
name|needargs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|enough
goto|;
comment|/* ~~ must be first line in formline */
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'@'
operator|||
operator|*
name|t
operator|==
literal|'^'
condition|)
name|needargs
operator|=
name|TRUE
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|stuff
argument_list|,
name|s
argument_list|,
name|eol
operator|-
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
if|if
condition|(
name|eol
operator|-
name|s
operator|>
literal|1
operator|&&
name|eol
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|eol
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|end
init|=
name|SvPVX
argument_list|(
name|stuff
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|stuff
argument_list|)
decl_stmt|;
name|end
index|[
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|end
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|stuff
argument_list|)
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|s
operator|=
name|eol
expr_stmt|;
if|if
condition|(
name|PL_rsfp
condition|)
block|{
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_last_uni
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|yyerror
argument_list|(
literal|"Format not terminated"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|enough
label|:
if|if
condition|(
name|SvCUR
argument_list|(
name|stuff
argument_list|)
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
if|if
condition|(
name|needargs
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
else|else
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_FORMLINE
expr_stmt|;
name|force_next
argument_list|(
name|LSTOP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SvREFCNT_dec
argument_list|(
name|stuff
argument_list|)
expr_stmt|;
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_set_csh
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
operator|!
name|PL_cshlen
condition|)
name|PL_cshlen
operator|=
name|strlen
argument_list|(
name|PL_cshname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|I32
name|Perl_start_subparse
parameter_list|(
name|pTHX_
name|I32
name|is_format
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|I32
name|oldsavestack_ix
init|=
name|PL_savestack_ix
decl_stmt|;
name|CV
modifier|*
name|outsidecv
init|=
name|PL_compcv
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
if|if
condition|(
name|PL_compcv
condition|)
block|{
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|PL_compcv
argument_list|)
operator|==
name|SVt_PVCV
argument_list|)
expr_stmt|;
block|}
name|SAVEI32
argument_list|(
name|PL_subline
argument_list|)
expr_stmt|;
name|save_item
argument_list|(
name|PL_subname
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_padix
argument_list|)
expr_stmt|;
name|SAVECOMPPAD
argument_list|()
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_pad_reset_pending
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|is_format
condition|?
name|SVt_PVFM
else|:
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|PL_compcv
argument_list|)
operator||=
name|flags
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
name|PL_subline
operator|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|outsidecv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|oldsavestack_ix
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__SC__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|segment
name|Perl_yylex
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|Perl_yywarn
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|PL_in_eval
operator||=
name|EVAL_WARNONLY
expr_stmt|;
name|yyerror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_in_eval
operator|&=
operator|~
name|EVAL_WARNONLY
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|Perl_yyerror
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|context
init|=
name|NULL
decl_stmt|;
name|int
name|contlen
init|=
operator|-
literal|1
decl_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|yychar
operator|||
operator|(
name|yychar
operator|==
literal|';'
operator|&&
operator|!
name|PL_rsfp
operator|)
condition|)
name|where
operator|=
literal|"at EOF"
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_bufptr
operator|>
name|PL_oldoldbufptr
operator|&&
name|PL_bufptr
operator|-
name|PL_oldoldbufptr
operator|<
literal|200
operator|&&
name|PL_oldoldbufptr
operator|!=
name|PL_oldbufptr
operator|&&
name|PL_oldbufptr
operator|!=
name|PL_bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_oldoldbufptr
argument_list|)
condition|)
name|PL_oldoldbufptr
operator|++
expr_stmt|;
name|context
operator|=
name|PL_oldoldbufptr
expr_stmt|;
name|contlen
operator|=
name|PL_bufptr
operator|-
name|PL_oldoldbufptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufptr
operator|>
name|PL_oldbufptr
operator|&&
name|PL_bufptr
operator|-
name|PL_oldbufptr
operator|<
literal|200
operator|&&
name|PL_oldbufptr
operator|!=
name|PL_bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_oldbufptr
argument_list|)
condition|)
name|PL_oldbufptr
operator|++
expr_stmt|;
name|context
operator|=
name|PL_oldbufptr
expr_stmt|;
name|contlen
operator|=
name|PL_bufptr
operator|-
name|PL_oldbufptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yychar
operator|>
literal|255
condition|)
name|where
operator|=
literal|"next token ???"
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PURE_BISON
comment|/*  GNU Bison sets the value -2 */
elseif|else
if|if
condition|(
name|yychar
operator|==
operator|-
literal|2
condition|)
block|{
else|#
directive|else
elseif|else
if|if
condition|(
operator|(
name|yychar
operator|&
literal|127
operator|)
operator|==
literal|127
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
operator|||
operator|(
name|PL_lex_state
operator|==
name|LEX_KNOWNEXT
operator|&&
name|PL_lex_defer
operator|==
name|LEX_NORMAL
operator|)
condition|)
name|where
operator|=
literal|"at end of line"
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_lex_inpat
condition|)
name|where
operator|=
literal|"within pattern"
expr_stmt|;
else|else
name|where
operator|=
literal|"within string"
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|where_sv
init|=
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|"next char "
argument_list|,
literal|10
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|32
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ where_sv
argument_list|,
literal|"^%c"
argument_list|,
argument|toCTRL(yychar)
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|isPRINT_LC
argument_list|(
name|yychar
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ where_sv
argument_list|,
literal|"%c"
argument_list|,
argument|yychar
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ where_sv
argument_list|,
literal|"\\%03o"
argument_list|,
argument|yychar&
literal|255
argument_list|)
empty_stmt|;
name|where
operator|=
name|SvPVX
argument_list|(
name|where_sv
argument_list|)
expr_stmt|;
block|}
name|msg
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|" at %s line %"
argument|IVdf
literal|", "
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(IV)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
if|if
condition|(
name|context
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"near \"%.*s\"\n"
argument_list|,
argument|contlen
argument_list|,
argument|context
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"%s\n"
argument_list|,
argument|where
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_multi_start
operator|<
name|PL_multi_end
operator|&&
call|(
name|U32
call|)
argument_list|(
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
operator|-
name|PL_multi_end
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"  (Might be a runaway multi-line %c%c string starting on line %"
argument|IVdf
literal|")\n"
argument_list|,
argument|(int)PL_multi_open
argument_list|,
argument|(int)PL_multi_close
argument_list|,
argument|(IV)PL_multi_start
argument_list|)
empty_stmt|;
name|PL_multi_end
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|PL_in_eval
operator|&
name|EVAL_WARNONLY
condition|)
name|Perl_warn
argument_list|(
name|aTHX_
literal|"%"
name|SVf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|qerror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
operator|>=
literal|10
condition|)
block|{
if|if
condition|(
name|PL_in_eval
operator|&&
name|SvCUR
argument_list|(
name|ERRSV
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%"
name|SVf
literal|"%s has too many errors.\n"
argument_list|,
name|ERRSV
argument_list|,
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s has too many errors.\n"
argument_list|,
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PL_in_my
operator|=
literal|0
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|__SC__
pragma|#
directive|pragma
name|segment
name|Main
endif|#
directive|endif
name|STATIC
name|char
modifier|*
name|S_swallow_bom
parameter_list|(
name|pTHX_
name|U8
modifier|*
name|s
parameter_list|)
block|{
name|STRLEN
name|slen
decl_stmt|;
name|slen
operator|=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|0xFF
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|0xFE
condition|)
block|{
comment|/* UTF-16 little-endian */
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|0
condition|)
comment|/* UTF-32 little-endian */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unsupported script encoding"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_NO_UTF16_FILTER
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"UTF-LE script encoding\n"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|PL_bufend
operator|>
operator|(
name|char
operator|*
operator|)
name|s
condition|)
block|{
name|U8
modifier|*
name|news
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
name|filter_add
argument_list|(
name|utf16rev_textfilter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|898
argument_list|,
name|news
argument_list|,
operator|(
name|PL_bufend
operator|-
operator|(
name|char
operator|*
operator|)
name|s
operator|)
operator|*
literal|3
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
operator|(
name|char
operator|*
operator|)
name|utf16_to_utf8_reversed
argument_list|(
name|s
argument_list|,
name|news
argument_list|,
name|PL_bufend
operator|-
operator|(
name|char
operator|*
operator|)
name|s
operator|-
literal|1
argument_list|,
operator|&
name|newlen
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|news
argument_list|,
name|s
argument_list|,
name|newlen
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|newlen
expr_stmt|;
name|news
index|[
name|newlen
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Safefree
argument_list|(
name|news
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unsupported script encoding"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|0xFE
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|0xFF
condition|)
block|{
comment|/* UTF-16 big-endian */
ifndef|#
directive|ifndef
name|PERL_NO_UTF16_FILTER
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"UTF-16BE script encoding\n"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|PL_bufend
operator|>
operator|(
name|char
operator|*
operator|)
name|s
condition|)
block|{
name|U8
modifier|*
name|news
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
name|filter_add
argument_list|(
name|utf16_textfilter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|898
argument_list|,
name|news
argument_list|,
operator|(
name|PL_bufend
operator|-
operator|(
name|char
operator|*
operator|)
name|s
operator|)
operator|*
literal|3
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
operator|(
name|char
operator|*
operator|)
name|utf16_to_utf8
argument_list|(
name|s
argument_list|,
name|news
argument_list|,
name|PL_bufend
operator|-
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|&
name|newlen
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|news
argument_list|,
name|s
argument_list|,
name|newlen
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|newlen
expr_stmt|;
name|news
index|[
name|newlen
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Safefree
argument_list|(
name|news
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unsupported script encoding"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|0xEF
case|:
if|if
condition|(
name|slen
operator|>
literal|2
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|0xBB
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|0xBF
condition|)
block|{
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"UTF-8 script encoding\n"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
comment|/* UTF-8 */
block|}
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|slen
operator|>
literal|3
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
comment|/* UTF-32 big-endian */
name|s
index|[
literal|2
index|]
operator|==
literal|0xFE
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|0xFF
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unsupported script encoding"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
include|#
directive|include
file|"XSUB.h"
endif|#
directive|endif
comment|/*  * restore_rsfp  * Restore a source filter.  */
specifier|static
name|void
name|restore_rsfp
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|f
parameter_list|)
block|{
name|PerlIO
modifier|*
name|fp
init|=
operator|(
name|PerlIO
operator|*
operator|)
name|f
decl_stmt|;
if|if
condition|(
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_rsfp
operator|&&
operator|(
name|PL_rsfp
operator|!=
name|fp
operator|)
condition|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|fp
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PERL_NO_UTF16_FILTER
specifier|static
name|I32
name|utf16_textfilter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|I32
name|count
init|=
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|U8
modifier|*
name|tmps
decl_stmt|;
name|U8
modifier|*
name|tend
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
name|New
argument_list|(
literal|898
argument_list|,
name|tmps
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|*
literal|3
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
return|return
name|count
return|;
name|tend
operator|=
name|utf16_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|newlen
argument_list|)
expr_stmt|;
name|sv_usepvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmps
argument_list|,
name|tend
operator|-
name|tmps
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
specifier|static
name|I32
name|utf16rev_textfilter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|I32
name|count
init|=
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|U8
modifier|*
name|tmps
decl_stmt|;
name|U8
modifier|*
name|tend
decl_stmt|;
name|I32
name|newlen
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
condition|)
comment|/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
return|return
name|count
return|;
name|New
argument_list|(
literal|898
argument_list|,
name|tmps
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|*
literal|3
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|tend
operator|=
name|utf16_to_utf8_reversed
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|&
name|newlen
argument_list|)
expr_stmt|;
name|sv_usepvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmps
argument_list|,
name|tend
operator|-
name|tmps
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

