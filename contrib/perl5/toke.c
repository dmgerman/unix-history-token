begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    toke.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  *   "It all comes from here, the stench and the peril."  --Frodo  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|check_uni
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_next
name|_
argument_list|(
operator|(
name|I32
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|force_version
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|force_word
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|int
name|token
operator|,
name|int
name|check_keyword
operator|,
name|int
name|allow_pack
operator|,
name|int
name|allow_tick
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SV
modifier|*
name|tokeq
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_const
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_formline
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_heredoc
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_ident
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|char
operator|*
name|send
operator|,
name|char
operator|*
name|dest
operator|,
name|STRLEN
name|destlen
operator|,
name|I32
name|ck_uni
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_inputsymbol
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_pat
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|I32
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_str
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_subst
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_trans
name|_
argument_list|(
operator|(
name|char
operator|*
name|start
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_word
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|char
operator|*
name|dest
operator|,
name|STRLEN
name|destlen
operator|,
name|int
name|allow_package
operator|,
name|STRLEN
operator|*
name|slp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skipspace
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkcomma
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|what
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_ident
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|int
name|kind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incline
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intuit_method
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|GV
operator|*
name|gv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intuit_more
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|lop
name|_
argument_list|(
operator|(
name|I32
name|f
operator|,
name|expectation
name|x
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|missingterm
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|no_op
name|_
argument_list|(
operator|(
name|char
operator|*
name|what
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_csh
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|sublex_done
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|sublex_push
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|sublex_start
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CRIPPLED_CC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|uni
name|_
argument_list|(
operator|(
name|I32
name|f
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filter_gets
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|,
name|PerlIO
operator|*
name|fp
operator|,
name|STRLEN
name|append
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_rsfp
name|_
argument_list|(
operator|(
name|void
operator|*
name|f
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SV
modifier|*
name|new_constant
name|_
argument_list|(
operator|(
name|char
operator|*
name|s
operator|,
name|STRLEN
name|len
operator|,
name|char
operator|*
name|key
operator|,
name|SV
operator|*
name|sv
operator|,
name|SV
operator|*
name|pv
operator|,
name|char
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_expect
name|_
argument_list|(
operator|(
name|void
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_lex_expect
name|_
argument_list|(
operator|(
name|void
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PL_super_bufptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PL_super_bufend
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_OBJECT */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ident_too_long
index|[]
init|=
literal|"Identifier too long"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are arranged oddly so that the guard on the switch statement  * can get by with a single comparison (if the compiler is smart enough).  */
end_comment

begin_comment
comment|/* #define LEX_NOTPARSING		11 is done in perl.h. */
end_comment

begin_define
define|#
directive|define
name|LEX_NORMAL
value|10
end_define

begin_define
define|#
directive|define
name|LEX_INTERPNORMAL
value|9
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCASEMOD
value|8
end_define

begin_define
define|#
directive|define
name|LEX_INTERPPUSH
value|7
end_define

begin_define
define|#
directive|define
name|LEX_INTERPSTART
value|6
end_define

begin_define
define|#
directive|define
name|LEX_INTERPEND
value|5
end_define

begin_define
define|#
directive|define
name|LEX_INTERPENDMAYBE
value|4
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCONCAT
value|3
end_define

begin_define
define|#
directive|define
name|LEX_INTERPCONST
value|2
end_define

begin_define
define|#
directive|define
name|LEX_FORMLINE
value|1
end_define

begin_define
define|#
directive|define
name|LEX_KNOWNEXT
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* Needed for execv() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ff_next
end_ifdef

begin_undef
undef|#
directive|undef
name|ff_next
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CLINE
end_ifdef

begin_undef
undef|#
directive|undef
name|CLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CLINE
value|(PL_copline = (PL_curcop->cop_line< PL_copline ? PL_curcop->cop_line : PL_copline))
end_define

begin_define
define|#
directive|define
name|TOKEN
parameter_list|(
name|retval
parameter_list|)
value|return (PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|OPERATOR
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XTERM,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|AOPERATOR
parameter_list|(
name|retval
parameter_list|)
value|return ao((PL_expect = XTERM,PL_bufptr = s,(int)retval))
end_define

begin_define
define|#
directive|define
name|PREBLOCK
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|PRETERMBLOCK
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|PREREF
parameter_list|(
name|retval
parameter_list|)
value|return (PL_expect = XREF,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|TERM
parameter_list|(
name|retval
parameter_list|)
value|return (CLINE, PL_expect = XOPERATOR,PL_bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|LOOPX
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
end_define

begin_define
define|#
directive|define
name|FTST
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
end_define

begin_define
define|#
directive|define
name|FUN0
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
end_define

begin_define
define|#
directive|define
name|FUN1
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
end_define

begin_define
define|#
directive|define
name|BOop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
end_define

begin_define
define|#
directive|define
name|BAop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
end_define

begin_define
define|#
directive|define
name|SHop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
end_define

begin_define
define|#
directive|define
name|PWop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
end_define

begin_define
define|#
directive|define
name|PMop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
end_define

begin_define
define|#
directive|define
name|Aop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
end_define

begin_define
define|#
directive|define
name|Mop
parameter_list|(
name|f
parameter_list|)
value|return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
end_define

begin_define
define|#
directive|define
name|Eop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
end_define

begin_define
define|#
directive|define
name|Rop
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
end_define

begin_comment
comment|/* This bit of chicanery makes a unary function followed by  * a parenthesis into a function with one argument, highest precedence.  */
end_comment

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f, \ 	PL_expect = XTERM, \ 	PL_bufptr = s, \ 	PL_last_uni = PL_oldbufptr, \ 	PL_last_lop_op = f, \ 	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
end_define

begin_define
define|#
directive|define
name|UNIBRACK
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f, \ 	PL_bufptr = s, \ 	PL_last_uni = PL_oldbufptr, \ 	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
end_define

begin_comment
comment|/* grandfather return to old style */
end_comment

begin_define
define|#
directive|define
name|OLDLOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
end_define

begin_function
name|STATIC
name|int
name|ao
parameter_list|(
name|int
name|toketype
parameter_list|)
block|{
if|if
condition|(
operator|*
name|PL_bufptr
operator|==
literal|'='
condition|)
block|{
name|PL_bufptr
operator|++
expr_stmt|;
if|if
condition|(
name|toketype
operator|==
name|ANDAND
condition|)
name|yylval
operator|.
name|ival
operator|=
name|OP_ANDASSIGN
expr_stmt|;
elseif|else
if|if
condition|(
name|toketype
operator|==
name|OROR
condition|)
name|yylval
operator|.
name|ival
operator|=
name|OP_ORASSIGN
expr_stmt|;
name|toketype
operator|=
name|ASSIGNOP
expr_stmt|;
block|}
return|return
name|toketype
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|no_op
parameter_list|(
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|oldbp
init|=
name|PL_bufptr
decl_stmt|;
name|bool
name|is_first
init|=
operator|(
name|PL_oldbufptr
operator|==
name|PL_linestart
operator|)
decl_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|yywarn
argument_list|(
name|form
argument_list|(
literal|"%s found where operator expected"
argument_list|,
name|what
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_first
condition|)
name|warn
argument_list|(
literal|"\t(Missing semicolon on previous line?)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_oldoldbufptr
operator|&&
name|isIDFIRST
argument_list|(
operator|*
name|PL_oldoldbufptr
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|PL_oldoldbufptr
init|;
operator|*
name|t
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|':'
operator|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|t
operator|<
name|PL_bufptr
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|warn
argument_list|(
literal|"\t(Do you need to predeclare %.*s?)\n"
argument_list|,
name|t
operator|-
name|PL_oldoldbufptr
argument_list|,
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"\t(Missing operator before %.*s?)\n"
argument_list|,
name|s
operator|-
name|oldbp
argument_list|,
name|oldbp
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|oldbp
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|missingterm
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|tmpbuf
index|[
literal|3
index|]
decl_stmt|;
name|char
name|q
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|char
modifier|*
name|nl
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|EBCDIC
name|iscntrl
argument_list|(
argument|PL_multi_close
argument_list|)
else|#
directive|else
name|PL_multi_close
operator|<
literal|32
operator|||
name|PL_multi_close
operator|==
literal|127
endif|#
directive|endif
condition|)
block|{
operator|*
name|tmpbuf
operator|=
literal|'^'
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
name|toCTRL
argument_list|(
name|PL_multi_close
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\\n"
expr_stmt|;
name|tmpbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tmpbuf
operator|=
name|PL_multi_close
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
block|}
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'"'
argument_list|)
condition|?
literal|'\''
else|:
literal|'"'
expr_stmt|;
name|croak
argument_list|(
literal|"Can't find string terminator %c%s%c anywhere before EOF"
argument_list|,
name|q
argument_list|,
name|s
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deprecate
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Use of %s is deprecated"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|depcom
parameter_list|(
name|void
parameter_list|)
block|{
name|deprecate
argument_list|(
literal|"comma-less variable list"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_function
name|STATIC
name|I32
name|win32_textfilter
parameter_list|(
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|I32
name|count
init|=
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|!
name|maxlen
condition|)
name|win32_strip_return
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lex_start
parameter_list|(
name|SV
modifier|*
name|line
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_dojoin
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_brackets
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_fakebrack
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_casemods
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_starts
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_state
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_inpat
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_inwhat
argument_list|)
expr_stmt|;
name|SAVEI16
argument_list|(
name|PL_curcop
operator|->
name|cop_line
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufend
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_linestart
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|SAVEDESTRUCTOR
argument_list|(
name|restore_rsfp
argument_list|,
name|PL_rsfp
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_defer
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|SAVEDESTRUCTOR
argument_list|(
name|restore_expect
argument_list|,
name|PL_tokenbuf
operator|+
name|PL_expect
argument_list|)
expr_stmt|;
comment|/* encode as pointer */
name|SAVEDESTRUCTOR
argument_list|(
name|restore_lex_expect
argument_list|,
name|PL_tokenbuf
operator|+
name|PL_expect
argument_list|)
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|PL_lex_defer
operator|=
literal|0
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|PL_lex_fakebrack
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_brackstack
argument_list|,
literal|120
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_casestack
argument_list|,
literal|12
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_dojoin
operator|=
literal|0
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
name|PL_lex_inpat
operator|=
literal|0
expr_stmt|;
name|PL_lex_inwhat
operator|=
literal|0
expr_stmt|;
name|PL_linestr
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|PL_linestr
argument_list|)
condition|)
name|PL_linestr
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|PL_linestr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|PL_linestr
argument_list|)
operator|&
name|SVs_TEMP
operator|)
condition|)
name|PL_linestr
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|"\n;"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|SvTEMP_off
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|newSVpv
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lex_end
parameter_list|(
name|void
parameter_list|)
block|{
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|restore_rsfp
parameter_list|(
name|void
modifier|*
name|f
parameter_list|)
block|{
name|PerlIO
modifier|*
name|fp
init|=
operator|(
name|PerlIO
operator|*
operator|)
name|f
decl_stmt|;
if|if
condition|(
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_rsfp
operator|&&
operator|(
name|PL_rsfp
operator|!=
name|fp
operator|)
condition|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|fp
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|restore_expect
parameter_list|(
name|void
modifier|*
name|e
parameter_list|)
block|{
comment|/* a safe way to store a small integer in a pointer */
name|PL_expect
operator|=
call|(
name|expectation
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
operator|-
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|restore_lex_expect
parameter_list|(
name|void
modifier|*
name|e
parameter_list|)
block|{
comment|/* a safe way to store a small integer in a pointer */
name|PL_lex_expect
operator|=
call|(
name|expectation
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
operator|-
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|incline
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|sawline
init|=
literal|0
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'#'
condition|)
return|return;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"line "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
name|sawline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return;
name|n
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|)
operator|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|sawline
condition|)
return|return;
comment|/* false alarm */
for|for
control|(
name|t
operator|=
name|s
init|;
operator|!
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
block|}
name|ch
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t
operator|-
name|s
operator|>
literal|0
condition|)
name|PL_curcop
operator|->
name|cop_filegv
operator|=
name|gv_fetchfile
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|PL_curcop
operator|->
name|cop_filegv
operator|=
name|gv_fetchfile
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|ch
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|atoi
argument_list|(
name|n
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|skipspace
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|STRLEN
name|prevlen
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
operator|&&
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|s
operator|<
name|PL_bufend
operator|||
operator|!
name|PL_rsfp
operator|||
name|PL_lex_state
operator|!=
name|LEX_NORMAL
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|(
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
operator|(
name|prevlen
operator|=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|PL_minus_n
operator|||
name|PL_minus_p
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|PL_minus_p
condition|?
literal|";}continue{print or die qq(-p destination: $!\\n)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";}"
argument_list|)
expr_stmt|;
name|PL_minus_n
operator|=
name|PL_minus_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_preprocess
operator|&&
operator|!
name|PL_in_eval
condition|)
operator|(
name|void
operator|)
name|PerlProc_pclose
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
return|return
name|s
return|;
block|}
name|PL_linestart
operator|=
name|PL_bufptr
operator|=
name|s
operator|+
name|prevlen
expr_stmt|;
name|PL_bufend
operator|=
name|s
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|PL_bufptr
argument_list|,
name|PL_bufend
operator|-
name|PL_bufptr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|check_uni
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|PL_oldoldbufptr
operator|!=
name|PL_last_uni
condition|)
return|return;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_last_uni
argument_list|)
condition|)
name|PL_last_uni
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|PL_last_uni
init|;
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|&&
name|t
operator|<
name|PL_bufptr
condition|)
return|return;
name|ch
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|warn
argument_list|(
literal|"Warning: Use of \"%s\" without parens is ambiguous"
argument_list|,
name|PL_last_uni
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CRIPPLED_CC
end_ifdef

begin_undef
undef|#
directive|undef
name|UNI
end_undef

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return uni(f,s)
end_define

begin_function
name|STATIC
name|int
name|uni
parameter_list|(
name|I32
name|f
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_last_uni
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|f
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
else|else
return|return
name|UNIOP
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRIPPLED_CC */
end_comment

begin_define
define|#
directive|define
name|LOP
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
value|return lop(f,x,s)
end_define

begin_function
name|STATIC
name|I32
name|lop
parameter_list|(
name|I32
name|f
parameter_list|,
name|expectation
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|CLINE
expr_stmt|;
name|PL_expect
operator|=
name|x
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|PL_nexttoke
condition|)
return|return
name|LSTOP
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC
return|;
else|else
return|return
name|LSTOP
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|force_next
parameter_list|(
name|I32
name|type
parameter_list|)
block|{
name|PL_nexttype
index|[
name|PL_nexttoke
index|]
operator|=
name|type
expr_stmt|;
name|PL_nexttoke
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_KNOWNEXT
condition|)
block|{
name|PL_lex_defer
operator|=
name|PL_lex_state
expr_stmt|;
name|PL_lex_expect
operator|=
name|PL_expect
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_KNOWNEXT
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|force_word
parameter_list|(
specifier|register
name|char
modifier|*
name|start
parameter_list|,
name|int
name|token
parameter_list|,
name|int
name|check_keyword
parameter_list|,
name|int
name|allow_pack
parameter_list|,
name|int
name|allow_initial_tick
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|start
operator|=
name|skipspace
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|s
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
name|allow_pack
operator|&&
operator|*
name|s
operator|==
literal|':'
operator|)
operator|||
operator|(
name|allow_initial_tick
operator|&&
operator|*
name|s
operator|==
literal|'\''
operator|)
condition|)
block|{
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|allow_pack
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_keyword
operator|&&
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|start
return|;
if|if
condition|(
name|token
operator|==
name|METHOD
condition|)
block|{
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
else|else
block|{
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_next
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_private
operator||=
name|OPpCONST_BARE
expr_stmt|;
name|force_next
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|force_ident
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|OP
modifier|*
name|o
init|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|o
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
condition|)
block|{
name|dTHR
expr_stmt|;
comment|/* just for in_eval */
name|o
operator|->
name|op_private
operator|=
name|OPpCONST_ENTERED
expr_stmt|;
comment|/* XXX see note in pp_entereval() for why we forgo typo 	       warnings if the symbol must be introduced in an eval. 	       GSAR 96-10-12 */
name|gv_fetchpv
argument_list|(
name|s
argument_list|,
name|PL_in_eval
condition|?
operator|(
name|GV_ADDMULTI
operator||
name|GV_ADDINEVAL
operator|)
else|:
name|TRUE
argument_list|,
name|kind
operator|==
literal|'$'
condition|?
name|SVt_PV
else|:
name|kind
operator|==
literal|'@'
condition|?
name|SVt_PVAV
else|:
name|kind
operator|==
literal|'%'
condition|?
name|SVt_PVHV
else|:
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|force_version
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|OP
modifier|*
name|version
init|=
name|Nullop
decl_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* default VERSION number -- GBARR */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|d
operator|=
name|s
operator|,
name|c
operator|=
literal|1
init|;
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'_'
operator|||
operator|(
operator|*
name|d
operator|==
literal|'.'
operator|&&
name|c
operator|--
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|d
operator|==
literal|';'
operator|||
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|)
operator|&&
operator|*
operator|(
name|skipspace
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
literal|','
condition|)
block|{
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* real VERSION number -- GBARR */
name|version
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
block|}
block|}
comment|/* NOTE: The parser sees the package name and the VERSION swapped */
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|version
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|SV
modifier|*
name|tokeq
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|STRLEN
name|len
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|pv
init|=
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|finish
goto|;
name|s
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|finish
goto|;
name|send
operator|=
name|s
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|'\\'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
goto|goto
name|finish
goto|;
name|d
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_STRING
condition|)
name|pv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|SvPVX
argument_list|(
name|pv
argument_list|)
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* all that, just for this */
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_STRING
condition|)
return|return
name|new_constant
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"q"
argument_list|,
name|sv
argument_list|,
name|pv
argument_list|,
literal|"q"
argument_list|)
return|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|sublex_start
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|I32
name|op_type
init|=
name|yylval
operator|.
name|ival
decl_stmt|;
if|if
condition|(
name|op_type
operator|==
name|OP_NULL
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_op
operator|=
name|Nullop
expr_stmt|;
return|return
name|THING
return|;
block|}
if|if
condition|(
name|op_type
operator|==
name|OP_CONST
operator|||
name|op_type
operator|==
name|OP_READLINE
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|tokeq
argument_list|(
name|PL_lex_stuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVIV
condition|)
block|{
comment|/* Overloaded constants, nothing fancy: Convert to SVt_PV: */
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|SV
modifier|*
name|nsv
decl_stmt|;
name|p
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nsv
operator|=
name|newSVpv
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|nsv
expr_stmt|;
block|}
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|op_type
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
return|return
name|THING
return|;
block|}
name|PL_sublex_info
operator|.
name|super_state
operator|=
name|PL_lex_state
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_inwhat
operator|=
name|op_type
expr_stmt|;
name|PL_sublex_info
operator|.
name|sub_op
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPPUSH
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
if|if
condition|(
name|PL_lex_op
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|PL_lex_op
expr_stmt|;
name|PL_lex_op
operator|=
name|Nullop
expr_stmt|;
return|return
name|PMFUNC
return|;
block|}
else|else
return|return
name|FUNC
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|sublex_push
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|ENTER
expr_stmt|;
name|PL_lex_state
operator|=
name|PL_sublex_info
operator|.
name|super_state
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_dojoin
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_brackets
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_fakebrack
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_casemods
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_starts
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_state
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_lex_inpat
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_lex_inwhat
argument_list|)
expr_stmt|;
name|SAVEI16
argument_list|(
name|PL_curcop
operator|->
name|cop_line
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_oldoldbufptr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_linestart
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_linestr
operator|=
name|PL_lex_stuff
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|PL_lex_fakebrack
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_brackstack
argument_list|,
literal|120
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|899
argument_list|,
name|PL_lex_casestack
argument_list|,
literal|12
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_brackstack
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_lex_casestack
argument_list|)
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_multi_start
expr_stmt|;
name|PL_lex_inwhat
operator|=
name|PL_sublex_info
operator|.
name|sub_inwhat
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_MATCH
operator|||
name|PL_lex_inwhat
operator|==
name|OP_QR
operator|||
name|PL_lex_inwhat
operator|==
name|OP_SUBST
condition|)
name|PL_lex_inpat
operator|=
name|PL_sublex_info
operator|.
name|sub_op
expr_stmt|;
else|else
name|PL_lex_inpat
operator|=
name|Nullop
expr_stmt|;
return|return
literal|'('
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|sublex_done
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PL_lex_starts
operator|++
condition|)
block|{
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|THING
return|;
block|}
if|if
condition|(
name|PL_lex_casemods
condition|)
block|{
comment|/* oops, we've got some unbalanced parens */
name|PL_lex_state
operator|=
name|LEX_INTERPCASEMOD
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
comment|/* Is there a right-hand side to take care of? */
if|if
condition|(
name|PL_lex_repl
operator|&&
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|||
name|PL_lex_inwhat
operator|==
name|OP_TRANS
operator|)
condition|)
block|{
name|PL_linestr
operator|=
name|PL_lex_repl
expr_stmt|;
name|PL_lex_inpat
operator|=
literal|0
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_brackets
operator|=
literal|0
expr_stmt|;
name|PL_lex_fakebrack
operator|=
literal|0
expr_stmt|;
name|PL_lex_casemods
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_lex_casestack
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvCOMPILED
argument_list|(
name|PL_lex_repl
argument_list|)
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
name|PL_lex_starts
operator|++
expr_stmt|;
block|}
else|else
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
return|return
literal|','
return|;
block|}
else|else
block|{
name|LEAVE
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|+=
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
return|return
literal|')'
return|;
block|}
block|}
end_function

begin_comment
comment|/*   scan_const    Extracts a pattern, double-quoted string, or transliteration.  This   is terrifying code.    It looks at lex_inwhat and PL_lex_inpat to find out whether it's   processing a pattern (PL_lex_inpat is true), a transliteration   (lex_inwhat& OP_TRANS is true), or a double-quoted string.    Returns a pointer to the character scanned up to. Iff this is   advanced from the start pointer supplied (ie if anything was   successfully parsed), will leave an OP for the substring scanned   in yylval. Caller must intuit reason for not parsing further   by looking at the next characters herself.    In patterns:     backslashes:       double-quoted style: \r and \n       regexp special ones: \D \s       constants: \x3       backrefs: \1 (deprecated in substitution replacements)       case and quoting: \U \Q \E     stops on @ and $, but not for $ as tail anchor    In transliterations:     characters are VERY literal, except for - not at the start or end     of the string, which indicates a range.  scan_const expands the     range to the full set of intermediate characters.    In double-quoted strings:     backslashes:       double-quoted style: \r and \n       constants: \x3       backrefs: \1 (deprecated)       case and quoting: \U \Q \E     stops on @ and $    scan_const does *not* construct ops to handle interpolated strings.   It stops processing as soon as it finds an embedded $ or @ variable   and leaves it to the caller to work out what's going on.    @ in pattern could be: @foo, @{foo}, @$foo, @'foo, @:foo.    $ in pattern could be $foo or could be tail anchor.  Assumption:   it's a tail anchor if $ is the last thing in the string, or if it's   followed by one of ")| \n\t"    \1 (backreferences) are turned into $1    The structure of the code is       while (there's a character to process) {           handle transliteration ranges 	  skip regexp comments 	  skip # initiated comments in //x patterns 	  check for embedded @foo 	  check for embedded scalars 	  if (backslash) { 	      leave intact backslashes from leave (below) 	      deprecate \1 in strings and sub replacements 	      handle string-changing backslashes \l \U \Q \E, etc. 	      switch (what was escaped) { 	          handle - in a transliteration (becomes a literal -) 		  handle \132 octal characters 		  handle 0x15 hex characters 		  handle \cV (control V) 		  handle printf backslashes (\f, \r, \n, etc) 	      } (end switch) 	  } (end if backslash)     } (end while character to read) 		   */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|scan_const
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|send
init|=
name|PL_bufend
decl_stmt|;
comment|/* end of the constant */
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|93
argument_list|,
name|send
operator|-
name|start
argument_list|)
decl_stmt|;
comment|/* sv for the constant */
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* start of the constant */
specifier|register
name|char
modifier|*
name|d
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* destination for copies */
name|bool
name|dorange
init|=
name|FALSE
decl_stmt|;
comment|/* are we in a translit range? */
name|I32
name|len
decl_stmt|;
comment|/* ? */
comment|/* leaveit is the set of acceptably-backslashed characters */
name|char
modifier|*
name|leaveit
init|=
name|PL_lex_inpat
condition|?
literal|"\\.^$@AGZdDwWsSbB+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
else|:
literal|""
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|||
name|dorange
condition|)
block|{
comment|/* get transliterations out of the way (they're most literal) */
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|)
block|{
comment|/* expand a range A-Z to the full set of characters.  AIE! */
if|if
condition|(
name|dorange
condition|)
block|{
name|I32
name|i
decl_stmt|;
comment|/* current expanded character */
name|I32
name|min
decl_stmt|;
comment|/* first character in range */
name|I32
name|max
decl_stmt|;
comment|/* last character in range */
name|i
operator|=
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* remember current offset */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
literal|256
argument_list|)
expr_stmt|;
comment|/* expand the sv -- there'll never be more'n 256 chars in a range for it to grow by */
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* restore d after the grow potentially has changed the ptr */
name|d
operator|-=
literal|2
expr_stmt|;
comment|/* eat the first char and the - */
name|min
operator|=
operator|(
name|U8
operator|)
operator|*
name|d
expr_stmt|;
comment|/* first char in range */
name|max
operator|=
operator|(
name|U8
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
comment|/* last char in range  */
ifndef|#
directive|ifndef
name|ASCIIish
if|if
condition|(
operator|(
name|isLOWER
argument_list|(
name|min
argument_list|)
operator|&&
name|isLOWER
argument_list|(
name|max
argument_list|)
operator|)
operator|||
operator|(
name|isUPPER
argument_list|(
name|min
argument_list|)
operator|&&
name|isUPPER
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isLOWER
argument_list|(
name|min
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|i
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isUPPER
argument_list|(
name|i
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
comment|/* mark the range as done, and continue */
name|dorange
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* range begins (ignore - as first or last char) */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
name|s
operator|!=
name|start
condition|)
block|{
name|dorange
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* if we get here, we're not doing a transliteration */
comment|/* skip for regexp comments /(?#comment)/ */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|&&
name|PL_lex_inpat
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|')'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* This should march regcomp.c */
name|I32
name|count
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|regparse
init|=
name|s
operator|+
literal|3
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|c
operator|=
operator|*
name|regparse
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|regparse
index|[
literal|1
index|]
condition|)
name|regparse
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|regparse
operator|==
literal|')'
condition|)
name|regparse
operator|++
expr_stmt|;
else|else
name|yyerror
argument_list|(
literal|"Sequence (?{...}) not terminated or not {}-balanced"
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|regparse
operator|&&
operator|*
name|s
operator|!=
literal|')'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* likewise skip #-initiated comments in //x patterns */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|PL_lex_inpat
operator|&&
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|PL_lex_inpat
operator|)
operator|->
name|op_pmflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
while|while
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* check for embedded arrays (@foo, @:foo, @'foo, @{foo}, @$foo) */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'@'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|isALNUM
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|":'{$"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
break|break;
comment|/* check for embedded scalars.  only stop if we're sure it's a 	   variable.         */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
comment|/* not a regexp, so $ must be var */
break|break;
if|if
condition|(
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|!
name|strchr
argument_list|(
literal|"()| \n\t"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
comment|/* in regexp, $ might be tail anchor */
block|}
comment|/* backslashes */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* some backslashes we leave behind */
if|if
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
name|leaveit
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* deprecate \1 in strings and substitution replacements */
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
operator|!
name|PL_lex_inpat
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'0'
operator|&&
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"\\%c better written as $%c"
argument_list|,
operator|*
name|s
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|*
operator|--
name|s
operator|=
literal|'$'
expr_stmt|;
break|break;
block|}
comment|/* string-change backslash escapes */
if|if
condition|(
name|PL_lex_inwhat
operator|!=
name|OP_TRANS
operator|&&
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"lLuUEQ"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
operator|--
name|s
expr_stmt|;
break|break;
block|}
comment|/* if we get here, it's either a quoted -, or a digit */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* quoted - in transliterations */
case|case
literal|'-'
case|:
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* FALL THROUGH */
comment|/* default action is to copy the quoted character */
default|default:
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
comment|/* \132 indicates an octal constant */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
operator|*
name|d
operator|++
operator|=
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
comment|/* \x24 indicates a hex constant */
case|case
literal|'x'
case|:
operator|*
name|d
operator|++
operator|=
name|scan_hex
argument_list|(
operator|++
name|s
argument_list|,
literal|2
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
comment|/* \c is a control character */
case|case
literal|'c'
case|:
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|EBCDIC
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|d
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toUPPER
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|toCTRL
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|toCTRL
argument_list|(
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
comment|/* printf-style backslashes, formfeeds, newlines, etc */
case|case
literal|'b'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\007'
expr_stmt|;
break|break;
block|}
comment|/* end switch */
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* end if (backslash) */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* while loop to process each character */
comment|/* terminate the string and set up the sv */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|d
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* shrink the sv if we allocated more than we used */
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/* return the substring (via yylval) only if we parsed anything */
if|if
condition|(
name|s
operator|>
name|PL_bufptr
condition|)
block|{
if|if
condition|(
name|PL_hints
operator|&
operator|(
name|PL_lex_inpat
condition|?
name|HINT_NEW_RE
else|:
name|HINT_NEW_STRING
operator|)
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|,
operator|(
name|PL_lex_inpat
condition|?
literal|"qr"
else|:
literal|"q"
operator|)
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
operator|(
name|PL_lex_inwhat
operator|==
name|OP_TRANS
condition|?
literal|"tr"
else|:
operator|(
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
operator|!
name|PL_lex_inpat
operator|)
condition|?
literal|"s"
else|:
literal|"qq"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* This is the one truly awful dwimmer necessary to conflate C and sed. */
end_comment

begin_function
name|STATIC
name|int
name|intuit_more
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|PL_lex_brackets
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'>'
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'['
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'{'
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|*
name|s
operator|!=
literal|'['
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
return|return
name|TRUE
return|;
comment|/* In a pattern, so maybe we have {n,m}. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
comment|/* On the other hand, maybe we have a character class */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|']'
operator|||
operator|*
name|s
operator|==
literal|'^'
condition|)
return|return
name|FALSE
return|;
else|else
block|{
name|int
name|weight
init|=
literal|2
decl_stmt|;
comment|/* let's weigh the evidence */
name|char
name|seen
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|un_char
init|=
literal|255
decl_stmt|,
name|last_un_char
decl_stmt|;
name|char
modifier|*
name|send
init|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
operator|*
literal|4
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|send
condition|)
comment|/* has to be an expression */
return|return
name|TRUE
return|;
name|Zero
argument_list|(
name|seen
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
name|weight
operator|-=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|']'
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
else|else
name|weight
operator|-=
literal|100
expr_stmt|;
block|}
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
block|{
name|last_un_char
operator|=
name|un_char
expr_stmt|;
name|un_char
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|scan_ident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
operator|>
literal|1
operator|&&
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PV
argument_list|)
condition|)
name|weight
operator|-=
literal|100
expr_stmt|;
else|else
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
literal|"[#!%*<>()-="
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
comment|/*{*/
name|strchr
argument_list|(
literal|"])} ="
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
else|else
name|weight
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
name|un_char
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"wds]"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|seen
index|[
literal|'\''
index|]
operator|||
name|seen
index|[
literal|'"'
index|]
condition|)
name|weight
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"rnftbxcav"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|weight
operator|+=
literal|40
expr_stmt|;
while|while
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
name|weight
operator|+=
literal|100
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|weight
operator|+=
literal|50
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"aA01! "
argument_list|,
name|last_un_char
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"zZ79~"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
if|if
condition|(
name|last_un_char
operator|==
literal|255
operator|&&
operator|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
name|weight
operator|-=
literal|5
expr_stmt|;
comment|/* cope with negative subscript */
break|break;
default|default:
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|last_un_char
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|"$@&"
argument_list|,
name|last_un_char
argument_list|)
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|d
init|=
name|tmpbuf
decl_stmt|;
while|while
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|d
operator|-
name|tmpbuf
argument_list|)
condition|)
name|weight
operator|-=
literal|150
expr_stmt|;
block|}
if|if
condition|(
name|un_char
operator|==
name|last_un_char
operator|+
literal|1
condition|)
name|weight
operator|+=
literal|5
expr_stmt|;
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
expr_stmt|;
break|break;
block|}
name|seen
index|[
name|un_char
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
operator|>=
literal|0
condition|)
comment|/* probably a character class */
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|intuit_method
parameter_list|(
name|char
modifier|*
name|start
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|start
operator|+
operator|(
operator|*
name|start
operator|==
literal|'$'
operator|)
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|GV
modifier|*
name|indirgv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|GvIO
argument_list|(
name|gv
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|proto
init|=
name|SvPVX
argument_list|(
name|cv
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
condition|)
block|{
if|if
condition|(
operator|*
name|proto
operator|==
literal|';'
condition|)
name|proto
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
literal|'*'
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
name|gv
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|gv
operator|||
name|PL_last_lop_op
operator|==
name|OP_PRINT
operator|||
name|isUPPER
argument_list|(
operator|*
name|PL_tokenbuf
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|start
expr_stmt|;
name|PL_expect
operator|=
name|XREF
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'('
condition|?
name|FUNCMETH
else|:
name|METHOD
return|;
block|}
if|if
condition|(
operator|!
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|len
operator|-=
literal|2
expr_stmt|;
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|bare_package
goto|;
block|}
name|indirgv
operator|=
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirgv
operator|&&
name|GvCVu
argument_list|(
name|indirgv
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* filehandle or package name makes it a method */
if|if
condition|(
operator|!
name|gv
operator|||
name|GvIO
argument_list|(
name|indirgv
argument_list|)
operator|||
name|gv_stashpvn
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_bufend
operator|-
name|s
operator|)
operator|>=
literal|2
operator|&&
operator|*
name|s
operator|==
literal|'='
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'>'
condition|)
return|return
literal|0
return|;
comment|/* no assumptions -- "=>" quotes bearword */
name|bare_package
label|:
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'('
condition|?
name|FUNCMETH
else|:
name|METHOD
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|incl_perldb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|PL_perldb
condition|)
block|{
name|char
modifier|*
name|pdb
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL5DB"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdb
condition|)
return|return
name|pdb
return|;
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
return|return
literal|"BEGIN { require 'perl5db.pl' }"
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Encoded script support. filter_add() effectively inserts a  * 'pre-processing' function into the current source input stream.   * Note that the filter function only applies to the current source file  * (e.g., it will not affect files 'require'd or 'use'd by this one).  *  * The datasv parameter (which may be NULL) can be used to pass  * private data to this instance of the filter. The filter function  * can recover the SV using the FILTER_DATA macro and use it to  * store private buffers and state information.  *  * The supplied datasv parameter is upgraded to a PVIO type  * and the IoDIRP field is used to store the function pointer.  * Note that IoTOP_NAME, IoFMT_NAME, IoBOTTOM_NAME, if set for  * private use must be set using malloc'd pointers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|filter_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|SV
modifier|*
name|filter_add
parameter_list|(
name|filter_t
name|funcp
parameter_list|,
name|SV
modifier|*
name|datasv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|funcp
condition|)
block|{
comment|/* temporary handy debugging hack to be deleted */
name|filter_debug
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|datasv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
name|PL_rsfp_filters
operator|=
name|newAV
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|datasv
condition|)
name|datasv
operator|=
name|NEWSV
argument_list|(
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvUPGRADE
argument_list|(
name|datasv
argument_list|,
name|SVt_PVIO
argument_list|)
condition|)
name|die
argument_list|(
literal|"Can't upgrade filter_add data to SVt_PVIO"
argument_list|)
expr_stmt|;
name|IoDIRP
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|DIR
operator|*
operator|)
name|funcp
expr_stmt|;
comment|/* stash funcp into spare field */
if|if
condition|(
name|filter_debug
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|warn
argument_list|(
literal|"filter_add func %p (%s)"
argument_list|,
name|funcp
argument_list|,
name|SvPV
argument_list|(
name|datasv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|av_unshift
argument_list|(
name|PL_rsfp_filters
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_rsfp_filters
argument_list|,
literal|0
argument_list|,
name|datasv
argument_list|)
expr_stmt|;
return|return
operator|(
name|datasv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete most recently added instance of this filter function.	*/
end_comment

begin_function
name|void
name|filter_del
parameter_list|(
name|filter_t
name|funcp
parameter_list|)
block|{
if|if
condition|(
name|filter_debug
condition|)
name|warn
argument_list|(
literal|"filter_del func %p"
argument_list|,
name|funcp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_rsfp_filters
operator|||
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* if filter is on top of stack (usual case) just pop it off */
if|if
condition|(
name|IoDIRP
argument_list|(
name|FILTER_DATA
argument_list|(
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
argument_list|)
argument_list|)
operator|==
operator|(
name|DIR
operator|*
operator|)
name|funcp
condition|)
block|{
name|sv_free
argument_list|(
name|av_pop
argument_list|(
name|PL_rsfp_filters
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we need to search for the correct entry and clear it	*/
name|die
argument_list|(
literal|"filter_del can only delete in reverse order (currently)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invoke the n'th filter function for the current rsfp.	 */
end_comment

begin_function
name|I32
name|filter_read
parameter_list|(
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
comment|/* 0 = read one text line */
block|{
name|filter_t
name|funcp
decl_stmt|;
name|SV
modifier|*
name|datasv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|idx
operator|>
name|AvFILLp
argument_list|(
name|PL_rsfp_filters
argument_list|)
condition|)
block|{
comment|/* Any more filters?	*/
comment|/* Provide a default input filter to make life easy.	*/
comment|/* Note that we append to the line. This is handy.	*/
if|if
condition|(
name|filter_debug
condition|)
name|warn
argument_list|(
literal|"filter_read %d: from rsfp\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlen
condition|)
block|{
comment|/* Want a block */
name|int
name|len
decl_stmt|;
name|int
name|old_len
init|=
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
decl_stmt|;
comment|/* ensure buf_sv is large enough */
name|SvGROW
argument_list|(
name|buf_sv
argument_list|,
name|old_len
operator|+
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|PerlIO_read
argument_list|(
name|PL_rsfp
argument_list|,
name|SvPVX
argument_list|(
name|buf_sv
argument_list|)
operator|+
name|old_len
argument_list|,
name|maxlen
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PerlIO_error
argument_list|(
name|PL_rsfp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error */
else|else
return|return
literal|0
return|;
comment|/* end of file */
block|}
name|SvCUR_set
argument_list|(
name|buf_sv
argument_list|,
name|old_len
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Want a line */
if|if
condition|(
name|sv_gets
argument_list|(
name|buf_sv
argument_list|,
name|PL_rsfp
argument_list|,
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|PerlIO_error
argument_list|(
name|PL_rsfp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error */
else|else
return|return
literal|0
return|;
comment|/* end of file */
block|}
block|}
return|return
name|SvCUR
argument_list|(
name|buf_sv
argument_list|)
return|;
block|}
comment|/* Skip this filter slot if filter has been deleted	*/
if|if
condition|(
operator|(
name|datasv
operator|=
name|FILTER_DATA
argument_list|(
name|idx
argument_list|)
operator|)
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
if|if
condition|(
name|filter_debug
condition|)
name|warn
argument_list|(
literal|"filter_read %d: skipped (filter deleted)\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|buf_sv
argument_list|,
name|maxlen
argument_list|)
return|;
comment|/* recurse */
block|}
comment|/* Get function pointer hidden within datasv	*/
name|funcp
operator|=
operator|(
name|filter_t
operator|)
name|IoDIRP
argument_list|(
name|datasv
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_debug
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|warn
argument_list|(
literal|"filter_read %d: via function %p (%s)\n"
argument_list|,
name|idx
argument_list|,
name|funcp
argument_list|,
name|SvPV
argument_list|(
name|datasv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Call function. The function is expected to 	*/
comment|/* call "FILTER_READ(idx+1, buf_sv)" first.		*/
comment|/* Return:<0:error, =0:eof,>0:not eof 		*/
return|return
operator|(
operator|*
name|funcp
operator|)
operator|(
name|PERL_OBJECT_THIS_
name|idx
operator|,
name|buf_sv
operator|,
name|maxlen
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|filter_gets
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|STRLEN
name|append
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WIN32FILTER
if|if
condition|(
operator|!
name|PL_rsfp_filters
condition|)
block|{
name|filter_add
argument_list|(
name|win32_textfilter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|PL_rsfp_filters
condition|)
block|{
if|if
condition|(
operator|!
name|append
condition|)
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start with empty line	*/
if|if
condition|(
name|FILTER_READ
argument_list|(
literal|0
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
return|;
else|else
return|return
name|Nullch
return|;
block|}
else|else
return|return
operator|(
name|sv_gets
argument_list|(
name|sv
argument_list|,
name|fp
argument_list|,
name|append
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|exp_name
index|[]
init|=
block|{
literal|"OPERATOR"
block|,
literal|"TERM"
block|,
literal|"REF"
block|,
literal|"STATE"
block|,
literal|"BLOCK"
block|,
literal|"TERMBLOCK"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|EXT
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last token */
end_comment

begin_comment
comment|/*   yylex    Works out what to call the token just pulled out of the input   stream.  The yacc parser takes care of taking the ops we return and   stitching them into a tree.    Returns:     PRIVATEREF    Structure:       if read an identifier           if we're in a my declaration 	      croak if they tried to say my($foo::bar) 	      build the ops for a my() declaration 	  if it's an access to a my() variable 	      are we in a sort block? 	          croak if my($a); $a<=> $b 	      build ops for access to a my() variable 	  if in a dq string, and they've said @foo and we can't find @foo 	      croak 	  build ops for a bareword       if we already built the token before, use it. */
end_comment

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
name|Nullgv
decl_stmt|;
name|GV
modifier|*
modifier|*
name|gvp
init|=
literal|0
decl_stmt|;
comment|/* check if there's an identifier for us to look at */
if|if
condition|(
name|PL_pending_ident
condition|)
block|{
comment|/* pit holds the identifier we read and pending_ident is reset */
name|char
name|pit
init|=
name|PL_pending_ident
decl_stmt|;
name|PL_pending_ident
operator|=
literal|0
expr_stmt|;
comment|/* if we're in a my(), we can't allow dynamics here. 	   $foo'bar has already been turned into $foo::bar, so 	   just check for colons.  	   if it's a legal name, the OP is a PADANY. 	*/
if|if
condition|(
name|PL_in_my
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|croak
argument_list|(
name|no_myglob
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_PADANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|pad_allocmy
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
comment|/*  	   build the ops for accesses to a my() variable.  	   Deny my($a) or my($b) in a sort block, *if* $a or $b is 	   then used in a comparison.  This catches most, but not 	   all cases.  For instance, it catches 	       sort { my($a); $a<=> $b } 	   but not 	       sort { my($a); $a< $b ? -1 : $a == $b ? 0 : 1; } 	   (although why you'd do that is anyone's guess). 	*/
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
comment|/* Check for single character per-thread SVs */
if|if
condition|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|isALPHA
argument_list|(
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
comment|/* Rule out obvious non-threadsvs */
operator|&&
operator|(
name|tmp
operator|=
name|find_threadsv
argument_list|(
operator|&
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|(
name|tmp
operator|=
name|pad_findmy
argument_list|(
name|PL_tokenbuf
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
comment|/* if it's a sort block and they're naming $a or $b */
if|if
condition|(
name|PL_last_lop_op
operator|==
name|OP_SORT
operator|&&
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
operator|(
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'a'
operator|||
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|&&
operator|!
name|PL_tokenbuf
index|[
literal|2
index|]
condition|)
block|{
for|for
control|(
name|d
operator|=
name|PL_in_eval
condition|?
name|PL_oldoldbufptr
else|:
name|PL_linestart
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|!=
literal|'\n'
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"<=>"
argument_list|,
literal|3
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"cmp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|croak
argument_list|(
literal|"Can't use \"my %s\" in sort comparison"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|yylval
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_PADANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
return|return
name|PRIVATEREF
return|;
block|}
block|}
comment|/* 	   Whine if they've said @foo in a doublequoted string, 	   and @foo isn't a variable we can find in the symbol 	   table. 	*/
if|if
condition|(
name|pit
operator|==
literal|'@'
operator|&&
name|PL_lex_state
operator|!=
name|LEX_NORMAL
operator|&&
operator|!
name|PL_lex_brackets
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gv
operator|||
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|?
operator|!
name|GvAV
argument_list|(
name|gv
argument_list|)
else|:
operator|!
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"In string, %s now must be written as \\%s"
argument_list|,
name|PL_tokenbuf
argument_list|,
name|PL_tokenbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* build ops for a bareword */
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_ENTERED
expr_stmt|;
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
name|PL_in_eval
condition|?
operator|(
name|GV_ADDMULTI
operator||
name|GV_ADDINEVAL
operator|)
else|:
name|TRUE
argument_list|,
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
condition|?
name|SVt_PV
else|:
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|?
name|SVt_PVAV
else|:
name|SVt_PVHV
operator|)
argument_list|)
expr_stmt|;
return|return
name|WORD
return|;
block|}
comment|/* no identifier pending identification */
switch|switch
condition|(
name|PL_lex_state
condition|)
block|{
ifdef|#
directive|ifdef
name|COMMENTARY
case|case
name|LEX_NORMAL
case|:
comment|/* Some compilers will produce faster */
case|case
name|LEX_INTERPNORMAL
case|:
comment|/* code if we comment these out. */
break|break;
endif|#
directive|endif
comment|/* when we're already built the next token, just pull it out the queue */
case|case
name|LEX_KNOWNEXT
case|:
name|PL_nexttoke
operator|--
expr_stmt|;
name|yylval
operator|=
name|PL_nextval
index|[
name|PL_nexttoke
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|PL_nexttoke
condition|)
block|{
name|PL_lex_state
operator|=
name|PL_lex_defer
expr_stmt|;
name|PL_expect
operator|=
name|PL_lex_expect
expr_stmt|;
name|PL_lex_defer
operator|=
name|LEX_NORMAL
expr_stmt|;
block|}
return|return
operator|(
name|PL_nexttype
index|[
name|PL_nexttoke
index|]
operator|)
return|;
comment|/* interpolated case modifiers like \L \U, including \Q and \E.        when we get here, PL_bufptr is at the \     */
case|case
name|LEX_INTERPCASEMOD
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
operator|&&
operator|*
name|PL_bufptr
operator|!=
literal|'\\'
condition|)
name|croak
argument_list|(
literal|"panic: INTERPCASEMOD"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* handle \E or end of string */
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
operator|||
name|PL_bufptr
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|char
name|oldmod
decl_stmt|;
comment|/* if at a \E */
if|if
condition|(
name|PL_lex_casemods
condition|)
block|{
name|oldmod
operator|=
name|PL_lex_casestack
index|[
operator|--
name|PL_lex_casemods
index|]
expr_stmt|;
name|PL_lex_casestack
index|[
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
operator|&&
name|strchr
argument_list|(
literal|"LUQ"
argument_list|,
name|oldmod
argument_list|)
condition|)
block|{
name|PL_bufptr
operator|+=
literal|2
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
block|}
return|return
literal|')'
return|;
block|}
if|if
condition|(
name|PL_bufptr
operator|!=
name|PL_bufend
condition|)
name|PL_bufptr
operator|+=
literal|2
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
else|else
block|{
name|s
operator|=
name|PL_bufptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"L\\u"
argument_list|,
literal|3
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"U\\l"
argument_list|,
literal|3
argument_list|)
condition|)
name|tmp
operator|=
operator|*
name|s
operator|,
operator|*
name|s
operator|=
name|s
index|[
literal|2
index|]
operator|,
name|s
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* misordered... */
if|if
condition|(
name|strchr
argument_list|(
literal|"LU"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|PL_lex_casestack
argument_list|,
literal|'L'
argument_list|)
operator|||
name|strchr
argument_list|(
name|PL_lex_casestack
argument_list|,
literal|'U'
argument_list|)
operator|)
condition|)
block|{
name|PL_lex_casestack
index|[
operator|--
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|')'
return|;
block|}
if|if
condition|(
name|PL_lex_casemods
operator|>
literal|10
condition|)
block|{
name|char
modifier|*
name|newlb
init|=
name|Renew
argument_list|(
name|PL_lex_casestack
argument_list|,
name|PL_lex_casemods
operator|+
literal|2
argument_list|,
name|char
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlb
operator|!=
name|PL_lex_casestack
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|newlb
argument_list|)
expr_stmt|;
name|PL_lex_casestack
operator|=
name|newlb
expr_stmt|;
block|}
block|}
name|PL_lex_casestack
index|[
name|PL_lex_casemods
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|PL_lex_casestack
index|[
name|PL_lex_casemods
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'l'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_LCFIRST
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'u'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_UCFIRST
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'L'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_LC
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'U'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_UC
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'Q'
condition|)
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_QUOTEMETA
expr_stmt|;
else|else
name|croak
argument_list|(
literal|"panic: yylex"
argument_list|)
expr_stmt|;
name|PL_bufptr
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|force_next
argument_list|(
name|FUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_starts
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|PL_lex_starts
operator|=
literal|0
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|yylex
argument_list|()
return|;
block|}
case|case
name|LEX_INTERPPUSH
case|:
return|return
name|sublex_push
argument_list|()
return|;
case|case
name|LEX_INTERPSTART
case|:
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
condition|)
return|return
name|sublex_done
argument_list|()
return|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|PL_lex_dojoin
operator|=
operator|(
operator|*
name|PL_bufptr
operator|==
literal|'@'
operator|)
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
if|if
condition|(
name|PL_lex_dojoin
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|','
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
name|PRIVATEREF
argument_list|)
expr_stmt|;
else|#
directive|else
name|force_ident
argument_list|(
literal|"\""
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_JOIN
expr_stmt|;
comment|/* emulate join($", ...) */
name|force_next
argument_list|(
name|FUNC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_lex_starts
operator|++
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
return|return
name|yylex
argument_list|()
return|;
case|case
name|LEX_INTERPENDMAYBE
case|:
if|if
condition|(
name|intuit_more
argument_list|(
name|PL_bufptr
argument_list|)
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPNORMAL
expr_stmt|;
comment|/* false alarm, more expr */
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|LEX_INTERPEND
case|:
if|if
condition|(
name|PL_lex_dojoin
condition|)
block|{
name|PL_lex_dojoin
operator|=
name|FALSE
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_INTERPCONCAT
expr_stmt|;
return|return
literal|')'
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|LEX_INTERPCONCAT
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|PL_lex_brackets
condition|)
name|croak
argument_list|(
literal|"panic: INTERPCONCAT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_bufend
condition|)
return|return
name|sublex_done
argument_list|()
return|;
if|if
condition|(
name|SvIVX
argument_list|(
name|PL_linestr
argument_list|)
operator|==
literal|'\''
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVsv
argument_list|(
name|PL_linestr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PL_lex_inpat
condition|)
name|sv
operator|=
name|tokeq
argument_list|(
name|sv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_RE
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"qr"
argument_list|,
name|sv
argument_list|,
name|sv
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|PL_bufend
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|scan_const
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPCASEMOD
expr_stmt|;
else|else
name|PL_lex_state
operator|=
name|LEX_INTERPSTART
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|PL_bufptr
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|=
name|yylval
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_starts
operator|++
condition|)
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
else|else
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
block|}
return|return
name|yylex
argument_list|()
return|;
case|case
name|LEX_FORMLINE
case|:
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|s
operator|=
name|scan_formline
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_lex_formbrack
condition|)
goto|goto
name|rightbracket
goto|;
name|OPERATOR
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_oldbufptr
operator|=
name|s
expr_stmt|;
name|DEBUG_p
argument_list|(
argument|{ 	PerlIO_printf(PerlIO_stderr(),
literal|"### Tokener expecting %s at %s\n"
argument|, exp_name[PL_expect], s);     }
argument_list|)
name|retry
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
name|croak
argument_list|(
literal|"Unrecognized character \\%03o"
argument_list|,
operator|*
name|s
operator|&
literal|255
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
case|case
literal|26
case|:
goto|goto
name|fake_eof
goto|;
comment|/* emulate EOF on ^D or ^Z */
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|PL_rsfp
condition|)
block|{
name|PL_last_uni
operator|=
literal|0
expr_stmt|;
name|PL_last_lop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
condition|)
name|yyerror
argument_list|(
literal|"Missing right bracket"
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|++
operator|<
name|PL_bufend
condition|)
goto|goto
name|retry
goto|;
comment|/* ignore stray nulls */
name|PL_last_uni
operator|=
literal|0
expr_stmt|;
name|PL_last_lop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_eval
operator|&&
operator|!
name|PL_preambled
condition|)
block|{
name|PL_preambled
operator|=
name|TRUE
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|incl_perldb
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_preambleav
condition|)
block|{
while|while
condition|(
name|AvFILLp
argument_list|(
name|PL_preambleav
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
name|tmpsv
init|=
name|av_shift
argument_list|(
name|PL_preambleav
argument_list|)
decl_stmt|;
name|sv_catsv
argument_list|(
name|PL_linestr
argument_list|,
name|tmpsv
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|sv_free
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
block|}
name|sv_free
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_preambleav
argument_list|)
expr_stmt|;
name|PL_preambleav
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|PL_minus_n
operator|||
name|PL_minus_p
condition|)
block|{
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"LINE: while (<>) {"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_l
condition|)
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"chomp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_a
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
literal|"::F"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
condition|)
name|GvIMPORTED_AV_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_F
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"/'\""
argument_list|,
operator|*
name|PL_splitstr
argument_list|)
operator|&&
name|strchr
argument_list|(
name|PL_splitstr
operator|+
literal|1
argument_list|,
operator|*
name|PL_splitstr
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|PL_linestr
argument_list|,
literal|"@F=split(%s);"
argument_list|,
name|PL_splitstr
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|delim
decl_stmt|;
name|s
operator|=
literal|"'~#\200\1'"
expr_stmt|;
comment|/* surely one char is unused...*/
while|while
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|PL_splitstr
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|delim
operator|=
operator|*
name|s
expr_stmt|;
name|sv_catpvf
argument_list|(
name|PL_linestr
argument_list|,
literal|"@F=split(%s%c"
argument_list|,
literal|"q"
operator|+
operator|(
name|delim
operator|==
literal|'\''
operator|)
argument_list|,
name|delim
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|PL_splitstr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|"\\"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_linestr
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sv_catpvf
argument_list|(
name|PL_linestr
argument_list|,
literal|"%c);"
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"@F=split(' ');"
argument_list|)
expr_stmt|;
block|}
block|}
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
block|}
do|do
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
name|fake_eof
label|:
if|if
condition|(
name|PL_rsfp
condition|)
block|{
if|if
condition|(
name|PL_preprocess
operator|&&
operator|!
name|PL_in_eval
condition|)
operator|(
name|void
operator|)
name|PerlProc_pclose
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|PerlIO_clearerr
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PL_in_eval
operator|&&
operator|(
name|PL_minus_n
operator|||
name|PL_minus_p
operator|)
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
name|PL_minus_p
condition|?
literal|";}continue{print"
else|:
literal|""
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_linestr
argument_list|,
literal|";}"
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_minus_n
operator|=
name|PL_minus_p
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
comment|/* not infinite loop because rsfp is NULL now */
block|}
if|if
condition|(
name|PL_doextract
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'!'
operator|&&
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
condition|)
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
comment|/* Incest with pod. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=cut"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|PL_doextract
condition|)
do|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|->
name|cop_line
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
comment|/* for csh execing sh scripts */
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_eval
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'!'
condition|)
name|d
operator|=
name|s
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
else|else
block|{
specifier|static
name|char
name|as
index|[]
init|=
name|ALTERNATE_SHEBANG
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|as
index|[
literal|0
index|]
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
name|as
argument_list|,
sizeof|sizeof
argument_list|(
name|as
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|d
operator|=
name|s
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|as
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTERNATE_SHEBANG */
block|}
if|if
condition|(
name|d
condition|)
block|{
name|char
modifier|*
name|ipath
decl_stmt|;
name|char
modifier|*
name|ipathend
decl_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|ipath
operator|=
name|d
expr_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|ipathend
operator|=
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|ARG_ZERO_IS_SCRIPT
if|if
condition|(
name|ipathend
operator|>
name|ipath
condition|)
block|{
comment|/* 		     * HP-UX (at least) sets argv[0] to the script name, 		     * which makes $^X incorrect.  And Digital UNIX and Linux, 		     * at least, set argv[0] to the basename of the Perl 		     * interpreter. So, having found "#!", we'll set it right. 		     */
name|SV
modifier|*
name|x
init|=
name|GvSV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"\030"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|SvPOK
argument_list|(
name|x
argument_list|)
operator|||
name|SvGMAGICAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv_eq
argument_list|(
name|x
argument_list|,
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|x
argument_list|,
name|ipath
argument_list|,
name|ipathend
operator|-
name|ipath
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
comment|/* $^X is always tainted, but that's OK */
block|}
endif|#
directive|endif
comment|/* ARG_ZERO_IS_SCRIPT */
comment|/* 		 * Look for options. 		 */
name|d
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl -"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
comment|/* 		 * If the ALTERNATE_SHEBANG on this system starts with a 		 * character that can be part of a Perl expression, then if 		 * we see it but not "perl", we're probably looking at the 		 * start of Perl code, not a request to hand off to some 		 * other interpreter.  Similarly, if "perl" is there, but 		 * not in the first 'word' of the line, we assume the line 		 * contains the start of the Perl program. 		 */
if|if
condition|(
name|d
operator|&&
operator|*
name|s
operator|!=
literal|'#'
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|ipath
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|!
name|strchr
argument_list|(
literal|"; \t\r\n\f\v#"
argument_list|,
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|d
condition|)
name|d
operator|=
name|Nullch
expr_stmt|;
comment|/* "perl" not in first word; ignore */
else|else
operator|*
name|s
operator|=
literal|'#'
expr_stmt|;
comment|/* Don't try to parse shebang line */
block|}
endif|#
directive|endif
comment|/* ALTERNATE_SHEBANG */
if|if
condition|(
operator|!
name|d
operator|&&
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|ipathend
operator|>
name|ipath
operator|&&
operator|!
name|PL_minus_c
operator|&&
operator|!
name|instr
argument_list|(
name|s
argument_list|,
literal|"indir"
argument_list|)
operator|&&
name|instr
argument_list|(
name|PL_origargv
index|[
literal|0
index|]
argument_list|,
literal|"perl"
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|newargv
decl_stmt|;
operator|*
name|ipathend
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|ipathend
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
name|Newz
argument_list|(
literal|899
argument_list|,
name|newargv
argument_list|,
name|PL_origargc
operator|+
literal|3
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|newargv
index|[
literal|1
index|]
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|Copy
argument_list|(
name|PL_origargv
operator|+
literal|1
argument_list|,
name|newargv
operator|+
literal|2
argument_list|,
name|PL_origargc
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|newargv
operator|=
name|PL_origargv
expr_stmt|;
name|newargv
index|[
literal|0
index|]
operator|=
name|ipath
expr_stmt|;
name|PerlProc_execv
argument_list|(
name|ipath
argument_list|,
name|newargv
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"Can't exec %s"
argument_list|,
name|ipath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
block|{
name|U32
name|oldpdb
init|=
name|PL_perldb
decl_stmt|;
name|bool
name|oldn
init|=
name|PL_minus_n
decl_stmt|;
name|bool
name|oldp
init|=
name|PL_minus_p
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\t'
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|==
literal|'-'
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'M'
operator|||
operator|*
name|d
operator|==
literal|'m'
condition|)
block|{
name|char
modifier|*
name|m
init|=
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
name|croak
argument_list|(
literal|"Too late for \"-%.*s\" option"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|d
operator|-
name|m
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|moreswitches
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|d
condition|)
do|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
operator|!
name|oldpdb
operator|||
operator|(
name|PL_minus_n
operator|||
name|PL_minus_p
operator|)
operator|&&
operator|!
operator|(
name|oldn
operator|||
name|oldp
operator|)
condition|)
comment|/* if we have already added "LINE: while (<>) {", 			         we must not do it again */
block|{
name|sv_setpv
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_preambled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
condition|)
operator|(
name|void
operator|)
name|gv_fetchfile
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'\r'
case|:
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
name|warn
argument_list|(
literal|"Illegal character \\%03o (carriage return)"
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"(Maybe you didn't strip carriage returns after a network transfer?)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|013
case|:
name|s
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'#'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_NORMAL
operator|||
operator|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
operator|)
condition|)
block|{
name|d
operator|=
name|PL_bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|d
condition|)
name|s
operator|++
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|<=
name|PL_lex_formbrack
condition|)
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
block|}
else|else
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|PL_bufend
operator|=
name|s
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isALNUM
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|s
operator|=
name|force_word
argument_list|(
name|PL_bufptr
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* unary minus */
block|}
name|PL_last_uni
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_FTEREAD
expr_stmt|;
comment|/* good enough */
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
literal|'r'
case|:
name|FTST
argument_list|(
name|OP_FTEREAD
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
name|FTST
argument_list|(
name|OP_FTEWRITE
argument_list|)
expr_stmt|;
case|case
literal|'x'
case|:
name|FTST
argument_list|(
name|OP_FTEEXEC
argument_list|)
expr_stmt|;
case|case
literal|'o'
case|:
name|FTST
argument_list|(
name|OP_FTEOWNED
argument_list|)
expr_stmt|;
case|case
literal|'R'
case|:
name|FTST
argument_list|(
name|OP_FTRREAD
argument_list|)
expr_stmt|;
case|case
literal|'W'
case|:
name|FTST
argument_list|(
name|OP_FTRWRITE
argument_list|)
expr_stmt|;
case|case
literal|'X'
case|:
name|FTST
argument_list|(
name|OP_FTREXEC
argument_list|)
expr_stmt|;
case|case
literal|'O'
case|:
name|FTST
argument_list|(
name|OP_FTROWNED
argument_list|)
expr_stmt|;
case|case
literal|'e'
case|:
name|FTST
argument_list|(
name|OP_FTIS
argument_list|)
expr_stmt|;
case|case
literal|'z'
case|:
name|FTST
argument_list|(
name|OP_FTZERO
argument_list|)
expr_stmt|;
case|case
literal|'s'
case|:
name|FTST
argument_list|(
name|OP_FTSIZE
argument_list|)
expr_stmt|;
case|case
literal|'f'
case|:
name|FTST
argument_list|(
name|OP_FTFILE
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
name|FTST
argument_list|(
name|OP_FTDIR
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
name|FTST
argument_list|(
name|OP_FTLINK
argument_list|)
expr_stmt|;
case|case
literal|'p'
case|:
name|FTST
argument_list|(
name|OP_FTPIPE
argument_list|)
expr_stmt|;
case|case
literal|'S'
case|:
name|FTST
argument_list|(
name|OP_FTSOCK
argument_list|)
expr_stmt|;
case|case
literal|'u'
case|:
name|FTST
argument_list|(
name|OP_FTSUID
argument_list|)
expr_stmt|;
case|case
literal|'g'
case|:
name|FTST
argument_list|(
name|OP_FTSGID
argument_list|)
expr_stmt|;
case|case
literal|'k'
case|:
name|FTST
argument_list|(
name|OP_FTSVTX
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|FTST
argument_list|(
name|OP_FTBLK
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|FTST
argument_list|(
name|OP_FTCHR
argument_list|)
expr_stmt|;
case|case
literal|'t'
case|:
name|FTST
argument_list|(
name|OP_FTTTY
argument_list|)
expr_stmt|;
case|case
literal|'T'
case|:
name|FTST
argument_list|(
name|OP_FTTEXT
argument_list|)
expr_stmt|;
case|case
literal|'B'
case|:
name|FTST
argument_list|(
name|OP_FTBINARY
argument_list|)
expr_stmt|;
case|case
literal|'M'
case|:
name|gv_fetchpv
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|OP_FTMTIME
argument_list|)
expr_stmt|;
case|case
literal|'A'
case|:
name|gv_fetchpv
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|OP_FTATIME
argument_list|)
expr_stmt|;
case|case
literal|'C'
case|:
name|gv_fetchpv
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|OP_FTCTIME
argument_list|)
expr_stmt|;
default|default:
name|croak
argument_list|(
literal|"Unrecognized file test: -%c"
argument_list|,
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|TERM
argument_list|(
name|POSTDEC
argument_list|)
expr_stmt|;
else|else
name|OPERATOR
argument_list|(
name|PREDEC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|METHOD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
name|OPERATOR
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
else|else
name|TERM
argument_list|(
name|ARROW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Aop
argument_list|(
name|OP_SUBTRACT
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|PL_bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* unary minus */
block|}
case|case
literal|'+'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|TERM
argument_list|(
name|POSTINC
argument_list|)
expr_stmt|;
else|else
name|OPERATOR
argument_list|(
name|PREINC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Aop
argument_list|(
name|OP_ADD
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|PL_bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
case|case
literal|'*'
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_ident
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|PL_tokenbuf
condition|)
name|PREREF
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|PWop
argument_list|(
name|OP_POW
argument_list|)
expr_stmt|;
block|}
name|Mop
argument_list|(
name|OP_MULTIPLY
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
operator|++
name|s
expr_stmt|;
name|Mop
argument_list|(
name|OP_MODULO
argument_list|)
expr_stmt|;
block|}
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final % should be \\% or %name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
name|PL_pending_ident
operator|=
literal|'%'
expr_stmt|;
name|TERM
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
name|s
operator|++
expr_stmt|;
name|BOop
argument_list|(
name|OP_BIT_XOR
argument_list|)
expr_stmt|;
case|case
literal|'['
case|:
name|PL_lex_brackets
operator|++
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'~'
case|:
case|case
literal|','
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|':'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
goto|goto
name|just_a_word
goto|;
block|}
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|||
name|PL_last_uni
operator|==
name|PL_oldoldbufptr
condition|)
name|PL_oldbufptr
operator|=
name|PL_oldoldbufptr
expr_stmt|;
comment|/* allow print(STDOUT 123) */
else|else
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|TOKEN
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|PL_curcop
operator|->
name|cop_line
operator|<
name|PL_copline
condition|)
name|PL_copline
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|')'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PREBLOCK
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|']'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<=
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Unmatched right bracket"
argument_list|)
expr_stmt|;
else|else
operator|--
name|PL_lex_brackets
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
condition|)
block|{
if|if
condition|(
name|PL_lex_brackets
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'['
operator|&&
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'-'
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|'>'
operator|)
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
block|}
block|}
name|TERM
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
name|leftbracket
label|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|>
literal|100
condition|)
block|{
name|char
modifier|*
name|newlb
init|=
name|Renew
argument_list|(
name|PL_lex_brackstack
argument_list|,
name|PL_lex_brackets
operator|+
literal|1
argument_list|,
name|char
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlb
operator|!=
name|PL_lex_brackstack
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|newlb
argument_list|)
expr_stmt|;
name|PL_lex_brackstack
operator|=
name|newlb
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|PL_expect
condition|)
block|{
case|case
name|XTERM
case|:
if|if
condition|(
name|PL_lex_formbrack
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|PRETERMBLOCK
argument_list|(
name|DO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
condition|)
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XTERM
expr_stmt|;
else|else
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
case|case
name|XOPERATOR
case|:
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|==
literal|'-'
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\t'
operator|)
condition|)
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|isIDFIRST
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
name|d
operator|=
name|scan_word
argument_list|(
name|d
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\t'
operator|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'}'
condition|)
block|{
name|char
name|minus
init|=
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
decl_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
operator|+
name|minus
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus
condition|)
name|force_next
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FALL THROUGH */
case|case
name|XBLOCK
case|:
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XSTATE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
break|break;
case|case
name|XTERMBLOCK
case|:
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
break|break;
default|default:
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
condition|)
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XTERM
expr_stmt|;
else|else
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
comment|/* This hack serves to disambiguate a pair of curlies 		 * as being a block or an anon hash.  Normally, expectation 		 * determines that, but in cases where we're not in a 		 * position to expect anything in particular (like inside 		 * eval"") we have to resolve the ambiguity.  This code 		 * covers the case where the first term in the curlies is a 		 * quoted string.  Most other cases need to be explicitly 		 * disambiguated by prepending a `+' before the opening 		 * curly in order to force resolution as an anon hash. 		 * 		 * XXX should probably propagate the outer expectation 		 * into eval"" to rely less on this hack, but that could 		 * potentially break current behavior of eval"". 		 * GSAR 97-07-21 		 */
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|*
name|s
operator|==
literal|'"'
operator|||
operator|*
name|s
operator|==
literal|'`'
condition|)
block|{
comment|/* common case: get past first string, handling escapes */
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
operator|&&
operator|*
name|t
operator|!=
operator|*
name|s
condition|;
control|)
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'\\'
operator|||
operator|*
name|t
operator|==
operator|*
name|s
operator|)
condition|)
name|t
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
operator|++
name|t
operator|<
name|PL_bufend
operator|&&
operator|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|t
operator|==
literal|'q'
operator|||
operator|*
name|t
operator|==
literal|'x'
operator|)
operator|&&
operator|++
name|t
operator|<
name|PL_bufend
operator|&&
operator|!
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
name|open
decl_stmt|,
name|close
decl_stmt|,
name|term
decl_stmt|;
name|I32
name|brackets
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|term
operator|=
operator|*
name|t
expr_stmt|;
name|open
operator|=
name|term
expr_stmt|;
if|if
condition|(
name|term
operator|&&
operator|(
name|tmps
operator|=
name|strchr
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|tmps
index|[
literal|5
index|]
expr_stmt|;
name|close
operator|=
name|term
expr_stmt|;
if|if
condition|(
name|open
operator|==
name|close
condition|)
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
operator|&&
name|t
operator|+
literal|1
operator|<
name|PL_bufend
operator|&&
name|open
operator|!=
literal|'\\'
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|open
condition|)
break|break;
block|}
else|else
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
operator|&&
name|t
operator|+
literal|1
operator|<
name|PL_bufend
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|close
operator|&&
operator|--
name|brackets
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|open
condition|)
name|brackets
operator|++
expr_stmt|;
block|}
block|}
name|t
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|PL_bufend
operator|&&
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
block|}
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* if comma follows first term, call it an anon hash */
comment|/* XXX it could be a comma expression with loop modifiers */
if|if
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
operator|(
operator|(
operator|*
name|t
operator|==
literal|','
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'q'
operator|||
operator|!
name|isLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'='
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
condition|)
name|OPERATOR
argument_list|(
name|HASHBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XREF
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
else|else
block|{
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|-
literal|1
index|]
operator|=
name|XSTATE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
block|}
break|break;
block|}
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'#'
condition|)
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
comment|/* invalidate current command line number */
name|TOKEN
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
name|rightbracket
label|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<=
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Unmatched right bracket"
argument_list|)
expr_stmt|;
else|else
name|PL_expect
operator|=
operator|(
name|expectation
operator|)
name|PL_lex_brackstack
index|[
operator|--
name|PL_lex_brackets
index|]
expr_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|<
name|PL_lex_formbrack
condition|)
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
condition|)
block|{
if|if
condition|(
name|PL_lex_brackets
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PL_lex_fakebrack
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
comment|/* ignore fake brackets */
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPENDMAYBE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|'['
operator|&&
operator|*
name|s
operator|!=
literal|'{'
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_lex_brackets
operator|<
name|PL_lex_fakebrack
condition|)
block|{
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_lex_fakebrack
operator|=
literal|0
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
comment|/* ignore fake brackets */
block|}
name|force_next
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'&'
condition|)
name|AOPERATOR
argument_list|(
name|ANDAND
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|PL_bufptr
operator|==
name|PL_linestart
condition|)
block|{
name|PL_curcop
operator|->
name|cop_line
operator|--
expr_stmt|;
name|warn
argument_list|(
name|warn_nosemi
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
block|}
name|BAop
argument_list|(
name|OP_BIT_AND
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|scan_ident
argument_list|(
name|s
operator|-
literal|1
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|PL_tokenbuf
condition|)
block|{
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_ident
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
block|}
else|else
name|PREREF
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
operator|(
name|OPpENTERSUB_AMPER
operator|<<
literal|8
operator|)
expr_stmt|;
name|TERM
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'|'
condition|)
name|AOPERATOR
argument_list|(
name|OROR
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|BOop
argument_list|(
name|OP_BIT_OR
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Eop
argument_list|(
name|OP_EQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|OPERATOR
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|PMop
argument_list|(
name|OP_MATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|tmp
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"+-*/%.^&|<"
argument_list|,
name|tmp
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Reversed %c= operator"
argument_list|,
operator|(
name|int
operator|)
name|tmp
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|isALPHA
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|(
name|s
operator|==
name|PL_linestart
operator|+
literal|1
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|d
operator|=
name|PL_bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"=cut"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|d
expr_stmt|;
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
goto|goto
name|retry
goto|;
block|}
name|s
operator|=
name|PL_bufend
expr_stmt|;
name|PL_doextract
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|PL_lex_brackets
operator|<
name|PL_lex_formbrack
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|;
name|t
operator|++
control|)
empty_stmt|;
else|#
directive|else
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
operator|||
operator|*
name|t
operator|==
literal|'\r'
condition|;
name|t
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
operator|||
operator|*
name|t
operator|==
literal|'#'
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|PL_expect
operator|=
name|XBLOCK
expr_stmt|;
goto|goto
name|leftbracket
goto|;
block|}
block|}
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|ASSIGNOP
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Eop
argument_list|(
name|OP_NE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|PMop
argument_list|(
name|OP_NOT
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
operator|!
name|strchr
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
name|s
operator|=
name|scan_heredoc
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|scan_inputsymbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'<'
condition|)
name|SHop
argument_list|(
name|OP_LEFT_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|Eop
argument_list|(
name|OP_NCMP
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_LE
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_LT
argument_list|)
expr_stmt|;
case|case
literal|'>'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|SHop
argument_list|(
name|OP_RIGHT_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|Rop
argument_list|(
name|OP_GE
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|Rop
argument_list|(
name|OP_GT
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
name|CLINE
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
block|}
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|isALPHA
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"_{$:"
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Array length"
argument_list|,
name|PL_bufptr
argument_list|)
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
name|PREREF
argument_list|(
name|DOLSHARP
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|PL_pending_ident
operator|=
literal|'#'
expr_stmt|;
name|TOKEN
argument_list|(
name|DOLSHARP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Scalar"
argument_list|,
name|PL_bufptr
argument_list|)
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final $ should be \\$ or $name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
block|}
comment|/* This kludge not intended to be bulletproof. */
if|if
condition|(
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'['
operator|&&
operator|!
name|PL_tokenbuf
index|[
literal|2
index|]
condition|)
block|{
name|yylval
operator|.
name|opval
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
operator|(
name|IV
operator|)
name|PL_compiling
operator|.
name|cop_arybase
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_ARYBASE
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_expect
operator|!=
name|XREF
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|)
operator|&&
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
operator|||
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'$'
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|','
condition|)
block|{
name|PL_bufptr
operator|=
name|skipspace
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|PL_bufend
operator|&&
operator|*
name|t
operator|!=
literal|']'
condition|)
name|t
operator|++
expr_stmt|;
name|warn
argument_list|(
literal|"Multidimensional syntax %.*s not supported"
argument_list|,
operator|(
name|t
operator|-
name|PL_bufptr
operator|)
operator|+
literal|1
argument_list|,
name|PL_bufptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|strEQ
argument_list|(
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
literal|"SIG"
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'}'
argument_list|)
operator|)
operator|&&
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|t
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
for|for
control|(
name|t
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|scan_word
argument_list|(
name|t
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|';'
operator|&&
name|perl_get_cv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|)
condition|)
name|warn
argument_list|(
literal|"You need to quote \"%s\""
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
operator|&&
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
name|bool
name|islop
init|=
operator|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|islop
operator|||
name|PL_last_lop_op
operator|==
name|OP_GREPSTART
condition|)
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"$@\"'`q"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh "foo" */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"&*<%"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|isIDFIRST
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh&sub */
elseif|else
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|keyword
argument_list|(
name|tmpbuf
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* binary operators exclude handle interpretations */
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
operator|-
name|KEY_x
case|:
case|case
operator|-
name|KEY_eq
case|:
case|case
operator|-
name|KEY_ne
case|:
case|case
operator|-
name|KEY_gt
case|:
case|case
operator|-
name|KEY_lt
case|:
case|case
operator|-
name|KEY_ge
case|:
case|case
operator|-
name|KEY_le
case|:
case|case
operator|-
name|KEY_cmp
case|:
break|break;
default|default:
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh length() */
break|break;
block|}
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh subr() */
block|}
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh 3 */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh .3 */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"/?-+"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
operator|!
name|isSPACE
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* e.g. print $fh -1 */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'<'
operator|&&
operator|!
name|isSPACE
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'='
condition|)
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
comment|/* print $fh<<"EOF" */
block|}
name|PL_pending_ident
operator|=
literal|'$'
expr_stmt|;
name|TOKEN
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Array"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|s
operator|=
name|scan_ident
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|PL_tokenbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_tokenbuf
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|PL_bufend
condition|)
name|yyerror
argument_list|(
literal|"Final @ should be \\@ or @name"
argument_list|)
expr_stmt|;
name|PREREF
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_expect
operator|!=
name|XREF
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|)
operator|&&
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PL_tokenbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
comment|/* Warn about @ where they meant $. */
if|if
condition|(
name|PL_dowarn
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|s
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|t
argument_list|)
operator|||
name|strchr
argument_list|(
literal|" \t$#+-'\""
argument_list|,
operator|*
name|t
argument_list|)
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'}'
operator|||
operator|*
name|t
operator|==
literal|']'
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|PL_bufptr
operator|=
name|skipspace
argument_list|(
name|PL_bufptr
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Scalar value %.*s better written as $%.*s"
argument_list|,
name|t
operator|-
name|PL_bufptr
argument_list|,
name|PL_bufptr
argument_list|,
name|t
operator|-
name|PL_bufptr
operator|-
literal|1
argument_list|,
name|PL_bufptr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|PL_pending_ident
operator|=
literal|'@'
expr_stmt|;
name|TERM
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
comment|/* may either be division or pattern */
case|case
literal|'?'
case|:
comment|/* may either be conditional or pattern */
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
block|{
comment|/* Disable warning on "study /blah/" */
if|if
condition|(
name|PL_oldoldbufptr
operator|==
name|PL_last_uni
operator|&&
operator|(
operator|*
name|PL_last_uni
operator|!=
literal|'s'
operator|||
name|s
operator|-
name|PL_last_uni
operator|<
literal|5
operator|||
name|memNE
argument_list|(
name|PL_last_uni
argument_list|,
literal|"study"
argument_list|,
literal|5
argument_list|)
operator|||
name|isALNUM
argument_list|(
name|PL_last_uni
index|[
literal|5
index|]
argument_list|)
operator|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_MATCH
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'/'
condition|)
name|Mop
argument_list|(
name|OP_DIVIDE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'.'
case|:
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
else|#
directive|else
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\r'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\n'
operator|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|s
operator|==
name|PL_linestart
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
goto|goto
name|rightbracket
goto|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
operator|||
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OPf_SPECIAL
expr_stmt|;
block|}
else|else
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|DOTDOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|Aop
argument_list|(
name|OP_CONCAT
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|s
operator|=
name|scan_num
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
else|else
name|no_op
argument_list|(
literal|"String"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'"'
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_lex_formbrack
operator|&&
name|PL_lex_brackets
operator|==
name|PL_lex_formbrack
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|depcom
argument_list|()
expr_stmt|;
return|return
literal|','
return|;
comment|/* grandfather non-comma-format format */
block|}
else|else
name|no_op
argument_list|(
literal|"String"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
for|for
control|(
name|d
operator|=
name|SvPV
argument_list|(
name|PL_lex_stuff
argument_list|,
name|len
argument_list|)
init|;
name|len
condition|;
name|len
operator|--
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|||
operator|*
name|d
operator|==
literal|'@'
operator|||
operator|*
name|d
operator|==
literal|'\\'
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|OP_STRINGIFY
expr_stmt|;
break|break;
block|}
block|}
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'`'
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Backticks"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_BACKTICK
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|PL_lex_inwhat
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Can't use \\%c to mean $%c in expression"
argument_list|,
operator|*
name|s
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|no_op
argument_list|(
literal|"Backslash"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|REFGEN
argument_list|)
expr_stmt|;
case|case
literal|'x'
case|:
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|Mop
argument_list|(
name|OP_REPEAT
argument_list|)
expr_stmt|;
block|}
goto|goto
name|keylookup
goto|;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
name|keylookup
label|:
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* Some keywords can be followed by any delimiter, including ':' */
name|tmp
operator|=
operator|(
name|len
operator|==
literal|1
operator|&&
name|strchr
argument_list|(
literal|"msyq"
argument_list|,
name|PL_tokenbuf
index|[
literal|0
index|]
argument_list|)
operator|||
name|len
operator|==
literal|2
operator|&&
operator|(
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|PL_tokenbuf
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|PL_tokenbuf
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|strchr
argument_list|(
literal|"qwxr"
argument_list|,
name|PL_tokenbuf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* x::* is just a word, unless x is "CORE" */
if|if
condition|(
operator|!
name|tmp
operator|&&
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|strNE
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|"CORE"
argument_list|)
condition|)
goto|goto
name|just_a_word
goto|;
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
comment|/* no comments skipped here, or s### is misparsed */
comment|/* Is this a label? */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|d
operator|<
name|PL_bufend
operator|&&
operator|*
name|d
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|d
operator|+
literal|1
operator|)
operator|!=
literal|':'
condition|)
block|{
name|s
operator|=
name|d
operator|+
literal|1
expr_stmt|;
name|yylval
operator|.
name|pval
operator|=
name|savepv
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|CLINE
expr_stmt|;
name|TOKEN
argument_list|(
name|LABEL
argument_list|)
expr_stmt|;
block|}
comment|/* Check for keywords */
name|tmp
operator|=
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Is this a word before a => operator? */
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|CLINE
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
name|TERM
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
block|{
comment|/* second-class keyword? */
name|GV
modifier|*
name|ogv
init|=
name|Nullgv
decl_stmt|;
comment|/* override (winner) */
name|GV
modifier|*
name|hgv
init|=
name|Nullgv
decl_stmt|;
comment|/* hidden (loser) */
if|if
condition|(
name|PL_expect
operator|!=
name|XOPERATOR
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|':'
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|':'
operator|)
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
operator|)
operator|&&
operator|(
name|cv
operator|=
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
name|ogv
operator|=
name|gv
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CvMETHOD
argument_list|(
name|cv
argument_list|)
condition|)
name|hgv
operator|=
name|gv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ogv
operator|&&
operator|(
name|gvp
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|PL_globalstash
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|(
name|gv
operator|=
operator|*
name|gvp
operator|)
operator|!=
operator|(
name|GV
operator|*
operator|)
operator|&
name|PL_sv_undef
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|ogv
operator|=
name|gv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ogv
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* overridden by import or by GLOBAL */
block|}
elseif|else
if|if
condition|(
name|gv
operator|&&
operator|!
name|gvp
operator|&&
operator|-
name|tmp
operator|==
name|KEY_lock
comment|/* XXX generalizable kludge */
operator|&&
operator|!
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
literal|"Thread.pm"
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* any sub overrides "weak" keyword */
block|}
else|else
block|{
comment|/* no override */
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|hgv
operator|&&
name|tmp
operator|!=
name|KEY_x
operator|&&
name|tmp
operator|!=
name|KEY_CORE
condition|)
comment|/* never ambiguous */
name|warn
argument_list|(
literal|"Ambiguous call resolved as CORE::%s(), %s"
argument_list|,
name|GvENAME
argument_list|(
name|hgv
argument_list|)
argument_list|,
literal|"qualify as such or use&"
argument_list|)
expr_stmt|;
block|}
block|}
name|reserved_word
label|:
switch|switch
condition|(
name|tmp
condition|)
block|{
default|default:
comment|/* not a keyword */
name|just_a_word
label|:
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
name|lastchar
init|=
operator|(
name|PL_bufptr
operator|==
name|PL_oldoldbufptr
condition|?
literal|0
else|:
name|PL_bufptr
index|[
operator|-
literal|1
index|]
operator|)
decl_stmt|;
comment|/* Get the rest if it looks like a package qualifier */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|STRLEN
name|morelen
decl_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
operator|-
name|len
argument_list|,
name|TRUE
argument_list|,
operator|&
name|morelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|morelen
condition|)
name|croak
argument_list|(
literal|"Bad name after %s%s"
argument_list|,
name|PL_tokenbuf
argument_list|,
operator|*
name|s
operator|==
literal|'\''
condition|?
literal|"'"
else|:
literal|"::"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|morelen
expr_stmt|;
block|}
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
block|{
if|if
condition|(
name|PL_bufptr
operator|==
name|PL_linestart
condition|)
block|{
name|PL_curcop
operator|->
name|cop_line
operator|--
expr_stmt|;
name|warn
argument_list|(
name|warn_nosemi
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
block|}
else|else
name|no_op
argument_list|(
literal|"Bareword"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a subroutine with this name in current package, 		   unless name is "Foo::", in which case Foo is a bearword 		   (and a package name). */
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|PL_tokenbuf
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|PL_tokenbuf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVHV
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Bareword \"%s\" refers to nonexistent package"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|PL_tokenbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gv
operator|=
name|Nullgv
expr_stmt|;
name|gvp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
block|}
comment|/* if we saw a global override before, get the right name */
if|if
condition|(
name|gvp
condition|)
block|{
name|sv
operator|=
name|newSVpv
argument_list|(
literal|"CORE::GLOBAL::"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|sv
operator|=
name|newSVpv
argument_list|(
name|PL_tokenbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Presume this is going to be a bareword of some sort. */
name|CLINE
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
name|OPpCONST_BARE
expr_stmt|;
comment|/* And if "Foo::", then that's what it certainly is. */
if|if
condition|(
name|len
condition|)
goto|goto
name|safe_bareword
goto|;
comment|/* See if it's the indirect object for a list operator. */
if|if
condition|(
name|PL_oldoldbufptr
operator|&&
name|PL_oldoldbufptr
operator|<
name|PL_bufptr
operator|&&
operator|(
name|PL_oldoldbufptr
operator|==
name|PL_last_lop
operator|||
name|PL_oldoldbufptr
operator|==
name|PL_last_uni
operator|)
operator|&&
comment|/* NO SKIPSPACE BEFORE HERE! */
operator|(
name|PL_expect
operator|==
name|XREF
operator|||
operator|(
operator|(
name|opargs
index|[
name|PL_last_lop_op
index|]
operator|>>
name|OASHIFT
operator|)
operator|&
literal|7
operator|)
operator|==
name|OA_FILEREF
operator|||
operator|(
name|PL_last_lop_op
operator|==
name|OP_ENTERSUB
operator|&&
name|PL_last_proto
operator|&&
name|PL_last_proto
index|[
name|PL_last_proto
index|[
literal|0
index|]
operator|==
literal|';'
condition|?
literal|1
else|:
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
name|bool
name|immediate_paren
init|=
operator|*
name|s
operator|==
literal|'('
decl_stmt|;
comment|/* (Now we can afford to cross potential line boundary.) */
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Two barewords in a row may indicate method call. */
if|if
condition|(
operator|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|tmp
operator|=
name|intuit_method
argument_list|(
name|s
argument_list|,
name|gv
argument_list|)
operator|)
condition|)
return|return
name|tmp
return|;
comment|/* If not a declared subroutine, it's an indirect object. */
comment|/* (But it's an indir obj regardless for sort.) */
if|if
condition|(
operator|(
name|PL_last_lop_op
operator|==
name|OP_SORT
operator|||
operator|(
operator|!
name|immediate_paren
operator|&&
operator|(
operator|!
name|gv
operator|||
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|PL_last_lop_op
operator|!=
name|OP_MAPSTART
operator|&&
name|PL_last_lop_op
operator|!=
name|OP_GREPSTART
operator|)
condition|)
block|{
name|PL_expect
operator|=
operator|(
name|PL_last_lop
operator|==
name|PL_oldoldbufptr
operator|)
condition|?
name|XTERM
else|:
name|XOPERATOR
expr_stmt|;
goto|goto
name|bareword
goto|;
block|}
block|}
comment|/* If followed by a paren, it's certainly a subroutine. */
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|CLINE
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
operator|&&
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
name|PL_last_proto
operator|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\t'
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|')'
operator|&&
operator|(
name|sv
operator|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|d
operator|+
literal|1
expr_stmt|;
goto|goto
name|its_constant
goto|;
block|}
block|}
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
name|PL_expect
operator|=
name|XOPERATOR
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_ENTERSUB
expr_stmt|;
name|TOKEN
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
block|}
comment|/* If followed by var or block, call it a method (unless sub) */
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'$'
operator|||
operator|*
name|s
operator|==
literal|'{'
operator|)
operator|&&
operator|(
operator|!
name|gv
operator|||
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_METHOD
expr_stmt|;
name|PREBLOCK
argument_list|(
name|METHOD
argument_list|)
expr_stmt|;
block|}
comment|/* If followed by a bareword, see if it looks like indir obj. */
if|if
condition|(
operator|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|tmp
operator|=
name|intuit_method
argument_list|(
name|s
argument_list|,
name|gv
argument_list|)
operator|)
condition|)
return|return
name|tmp
return|;
comment|/* Not a method, so call it a subroutine (if defined) */
if|if
condition|(
name|gv
operator|&&
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|lastchar
operator|==
literal|'-'
condition|)
name|warn
argument_list|(
literal|"Ambiguous use of -%s resolved as -&%s()"
argument_list|,
name|PL_tokenbuf
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_ENTERSUB
expr_stmt|;
comment|/* Check for a constant sub */
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sv
operator|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|its_constant
label|:
name|SvREFCNT_dec
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|yylval
operator|.
name|opval
operator|)
operator|->
name|op_sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
name|TOKEN
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve to GV now. */
name|op_free
argument_list|(
name|yylval
operator|.
name|opval
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|opval
operator|=
name|newCVREF
argument_list|(
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_ENTERSUB
expr_stmt|;
comment|/* Is there a prototype? */
if|if
condition|(
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|PL_last_proto
operator|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|TERM
argument_list|(
name|FUNC0SUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|PL_last_proto
argument_list|,
literal|"$"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|UNIOPSUB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|PL_last_proto
operator|==
literal|'&'
operator|&&
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"__ANON__"
argument_list|)
expr_stmt|;
name|PREBLOCK
argument_list|(
name|LSTOPSUB
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|PL_last_proto
operator|=
name|NULL
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|yylval
operator|.
name|opval
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|NOAMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_hints
operator|&
name|HINT_STRICT_SUBS
operator|&&
name|lastchar
operator|!=
literal|'-'
operator|&&
name|strnNE
argument_list|(
name|s
argument_list|,
literal|"->"
argument_list|,
literal|2
argument_list|)
operator|&&
name|PL_last_lop_op
operator|!=
name|OP_TRUNCATE
operator|&&
comment|/* S/F prototype in opcode.pl */
name|PL_last_lop_op
operator|!=
name|OP_ACCEPT
operator|&&
name|PL_last_lop_op
operator|!=
name|OP_PIPE_OP
operator|&&
name|PL_last_lop_op
operator|!=
name|OP_SOCKPAIR
operator|&&
operator|!
operator|(
name|PL_last_lop_op
operator|==
name|OP_ENTERSUB
operator|&&
name|PL_last_proto
operator|&&
name|PL_last_proto
index|[
name|PL_last_proto
index|[
literal|0
index|]
operator|==
literal|';'
condition|?
literal|1
else|:
literal|0
index|]
operator|==
literal|'*'
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Bareword \"%s\" not allowed while \"strict subs\" in use"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
operator|++
name|PL_error_count
expr_stmt|;
block|}
comment|/* Call it a bare word */
name|bareword
label|:
if|if
condition|(
name|PL_dowarn
condition|)
block|{
if|if
condition|(
name|lastchar
operator|!=
literal|'-'
condition|)
block|{
for|for
control|(
name|d
operator|=
name|PL_tokenbuf
init|;
operator|*
name|d
operator|&&
name|isLOWER
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
name|warn
argument_list|(
name|warn_reserved
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|safe_bareword
label|:
if|if
condition|(
name|lastchar
operator|&&
name|strchr
argument_list|(
literal|"*%&"
argument_list|,
name|lastchar
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Operator or semicolon missing before %c%s"
argument_list|,
name|lastchar
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Ambiguous use of %c resolved as operator %c"
argument_list|,
name|lastchar
argument_list|,
name|lastchar
argument_list|)
expr_stmt|;
block|}
name|TOKEN
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
case|case
name|KEY___FILE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVsv
argument_list|(
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___LINE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___PACKAGE__
case|:
name|yylval
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
operator|(
name|PL_curstash
condition|?
name|newSVsv
argument_list|(
name|PL_curstname
argument_list|)
else|:
operator|&
name|PL_sv_undef
operator|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|THING
argument_list|)
expr_stmt|;
case|case
name|KEY___DATA__
case|:
case|case
name|KEY___END__
case|:
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|PL_rsfp
operator|&&
operator|(
operator|!
name|PL_in_eval
operator|||
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'D'
operator|)
condition|)
block|{
name|char
modifier|*
name|pname
init|=
literal|"main"
decl_stmt|;
if|if
condition|(
name|PL_tokenbuf
index|[
literal|2
index|]
operator|==
literal|'D'
condition|)
name|pname
operator|=
name|HvNAME
argument_list|(
name|PL_curstash
condition|?
name|PL_curstash
else|:
name|PL_defstash
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|form
argument_list|(
literal|"%s::DATA"
argument_list|,
name|pname
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GvIO
argument_list|(
name|gv
argument_list|)
condition|)
name|GvIOp
argument_list|(
name|gv
argument_list|)
operator|=
name|newIO
argument_list|()
expr_stmt|;
name|IoIFP
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
name|PL_rsfp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
block|{
name|int
name|fd
init|=
name|PerlIO_fileno
argument_list|(
name|PL_rsfp
argument_list|)
decl_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>=
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Mark this internal pseudo-handle as clean */
name|IoFLAGS
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator||=
name|IOf_UNTAINT
expr_stmt|;
if|if
condition|(
name|PL_preprocess
condition|)
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|PerlIO
operator|*
operator|)
name|PL_rsfp
operator|==
name|PerlIO_stdin
argument_list|()
condition|)
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
literal|'-'
expr_stmt|;
else|else
name|IoTYPE
argument_list|(
name|GvIOp
argument_list|(
name|gv
argument_list|)
argument_list|)
operator|=
literal|'<'
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
goto|goto
name|fake_eof
goto|;
block|}
case|case
name|KEY_AUTOLOAD
case|:
case|case
name|KEY_DESTROY
case|:
case|case
name|KEY_BEGIN
case|:
case|case
name|KEY_END
case|:
case|case
name|KEY_INIT
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
goto|goto
name|really_sub
goto|;
block|}
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_CORE
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|keyword
argument_list|(
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
goto|goto
name|reserved_word
goto|;
block|}
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_abs
case|:
name|UNI
argument_list|(
name|OP_ABS
argument_list|)
expr_stmt|;
case|case
name|KEY_alarm
case|:
name|UNI
argument_list|(
name|OP_ALARM
argument_list|)
expr_stmt|;
case|case
name|KEY_accept
case|:
name|LOP
argument_list|(
name|OP_ACCEPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_and
case|:
name|OPERATOR
argument_list|(
name|ANDOP
argument_list|)
expr_stmt|;
case|case
name|KEY_atan2
case|:
name|LOP
argument_list|(
name|OP_ATAN2
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_bind
case|:
name|LOP
argument_list|(
name|OP_BIND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_binmode
case|:
name|UNI
argument_list|(
name|OP_BINMODE
argument_list|)
expr_stmt|;
case|case
name|KEY_bless
case|:
name|LOP
argument_list|(
name|OP_BLESS
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chop
case|:
name|UNI
argument_list|(
name|OP_CHOP
argument_list|)
expr_stmt|;
case|case
name|KEY_continue
case|:
name|PREBLOCK
argument_list|(
name|CONTINUE
argument_list|)
expr_stmt|;
case|case
name|KEY_chdir
case|:
operator|(
name|void
operator|)
name|gv_fetchpv
argument_list|(
literal|"ENV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
comment|/* may use HOME */
name|UNI
argument_list|(
name|OP_CHDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_close
case|:
name|UNI
argument_list|(
name|OP_CLOSE
argument_list|)
expr_stmt|;
case|case
name|KEY_closedir
case|:
name|UNI
argument_list|(
name|OP_CLOSEDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_cmp
case|:
name|Eop
argument_list|(
name|OP_SCMP
argument_list|)
expr_stmt|;
case|case
name|KEY_caller
case|:
name|UNI
argument_list|(
name|OP_CALLER
argument_list|)
expr_stmt|;
case|case
name|KEY_crypt
case|:
ifdef|#
directive|ifdef
name|FCRYPT
if|if
condition|(
operator|!
name|PL_cryptseen
operator|++
condition|)
name|init_des
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|LOP
argument_list|(
name|OP_CRYPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chmod
case|:
if|if
condition|(
name|PL_dowarn
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'('
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|!=
literal|'0'
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|yywarn
argument_list|(
literal|"chmod: mode argument is missing initial 0"
argument_list|)
expr_stmt|;
block|}
name|LOP
argument_list|(
name|OP_CHMOD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chown
case|:
name|LOP
argument_list|(
name|OP_CHOWN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_connect
case|:
name|LOP
argument_list|(
name|OP_CONNECT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_chr
case|:
name|UNI
argument_list|(
name|OP_CHR
argument_list|)
expr_stmt|;
case|case
name|KEY_cos
case|:
name|UNI
argument_list|(
name|OP_COS
argument_list|)
expr_stmt|;
case|case
name|KEY_chroot
case|:
name|UNI
argument_list|(
name|OP_CHROOT
argument_list|)
expr_stmt|;
case|case
name|KEY_do
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
name|PRETERMBLOCK
argument_list|(
name|DO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\''
condition|)
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|DO
argument_list|)
expr_stmt|;
case|case
name|KEY_die
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|LOP
argument_list|(
name|OP_DIE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_defined
case|:
name|UNI
argument_list|(
name|OP_DEFINED
argument_list|)
expr_stmt|;
case|case
name|KEY_delete
case|:
name|UNI
argument_list|(
name|OP_DELETE
argument_list|)
expr_stmt|;
case|case
name|KEY_dbmopen
case|:
name|gv_fetchpv
argument_list|(
literal|"AnyDBM_File::ISA"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_DBMOPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_dbmclose
case|:
name|UNI
argument_list|(
name|OP_DBMCLOSE
argument_list|)
expr_stmt|;
case|case
name|KEY_dump
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_DUMP
argument_list|)
expr_stmt|;
case|case
name|KEY_else
case|:
name|PREBLOCK
argument_list|(
name|ELSE
argument_list|)
expr_stmt|;
case|case
name|KEY_elsif
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|ELSIF
argument_list|)
expr_stmt|;
case|case
name|KEY_eq
case|:
name|Eop
argument_list|(
name|OP_SEQ
argument_list|)
expr_stmt|;
case|case
name|KEY_exists
case|:
name|UNI
argument_list|(
name|OP_EXISTS
argument_list|)
expr_stmt|;
case|case
name|KEY_exit
case|:
name|UNI
argument_list|(
name|OP_EXIT
argument_list|)
expr_stmt|;
case|case
name|KEY_eval
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|)
condition|?
name|XTERMBLOCK
else|:
name|XTERM
expr_stmt|;
name|UNIBRACK
argument_list|(
name|OP_ENTEREVAL
argument_list|)
expr_stmt|;
case|case
name|KEY_eof
case|:
name|UNI
argument_list|(
name|OP_EOF
argument_list|)
expr_stmt|;
case|case
name|KEY_exp
case|:
name|UNI
argument_list|(
name|OP_EXP
argument_list|)
expr_stmt|;
case|case
name|KEY_each
case|:
name|UNI
argument_list|(
name|OP_EACH
argument_list|)
expr_stmt|;
case|case
name|KEY_exec
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_EXEC
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_endhostent
case|:
name|FUN0
argument_list|(
name|OP_EHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endnetent
case|:
name|FUN0
argument_list|(
name|OP_ENETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endservent
case|:
name|FUN0
argument_list|(
name|OP_ESERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endprotoent
case|:
name|FUN0
argument_list|(
name|OP_EPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endpwent
case|:
name|FUN0
argument_list|(
name|OP_EPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_endgrent
case|:
name|FUN0
argument_list|(
name|OP_EGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_for
case|:
case|case
name|KEY_foreach
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_expect
operator|==
name|XSTATE
operator|&&
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|PL_bufend
operator|-
name|p
operator|)
operator|>=
literal|3
operator|&&
name|strnEQ
argument_list|(
name|p
argument_list|,
literal|"my"
argument_list|,
literal|2
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Missing $ on loop variable"
argument_list|)
expr_stmt|;
block|}
name|OPERATOR
argument_list|(
name|FOR
argument_list|)
expr_stmt|;
case|case
name|KEY_formline
case|:
name|LOP
argument_list|(
name|OP_FORMLINE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_fork
case|:
name|FUN0
argument_list|(
name|OP_FORK
argument_list|)
expr_stmt|;
case|case
name|KEY_fcntl
case|:
name|LOP
argument_list|(
name|OP_FCNTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_fileno
case|:
name|UNI
argument_list|(
name|OP_FILENO
argument_list|)
expr_stmt|;
case|case
name|KEY_flock
case|:
name|LOP
argument_list|(
name|OP_FLOCK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_gt
case|:
name|Rop
argument_list|(
name|OP_SGT
argument_list|)
expr_stmt|;
case|case
name|KEY_ge
case|:
name|Rop
argument_list|(
name|OP_SGE
argument_list|)
expr_stmt|;
case|case
name|KEY_grep
case|:
name|LOP
argument_list|(
name|OP_GREPSTART
argument_list|,
operator|*
name|s
operator|==
literal|'('
condition|?
name|XTERM
else|:
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_goto
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_GOTO
argument_list|)
expr_stmt|;
case|case
name|KEY_gmtime
case|:
name|UNI
argument_list|(
name|OP_GMTIME
argument_list|)
expr_stmt|;
case|case
name|KEY_getc
case|:
name|UNI
argument_list|(
name|OP_GETC
argument_list|)
expr_stmt|;
case|case
name|KEY_getppid
case|:
name|FUN0
argument_list|(
name|OP_GETPPID
argument_list|)
expr_stmt|;
case|case
name|KEY_getpgrp
case|:
name|UNI
argument_list|(
name|OP_GETPGRP
argument_list|)
expr_stmt|;
case|case
name|KEY_getpriority
case|:
name|LOP
argument_list|(
name|OP_GETPRIORITY
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotobyname
case|:
name|UNI
argument_list|(
name|OP_GPBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotobynumber
case|:
name|LOP
argument_list|(
name|OP_GPBYNUMBER
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getprotoent
case|:
name|FUN0
argument_list|(
name|OP_GPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwent
case|:
name|FUN0
argument_list|(
name|OP_GPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwnam
case|:
name|UNI
argument_list|(
name|OP_GPWNAM
argument_list|)
expr_stmt|;
case|case
name|KEY_getpwuid
case|:
name|UNI
argument_list|(
name|OP_GPWUID
argument_list|)
expr_stmt|;
case|case
name|KEY_getpeername
case|:
name|UNI
argument_list|(
name|OP_GETPEERNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostbyname
case|:
name|UNI
argument_list|(
name|OP_GHBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostbyaddr
case|:
name|LOP
argument_list|(
name|OP_GHBYADDR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_gethostent
case|:
name|FUN0
argument_list|(
name|OP_GHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetbyname
case|:
name|UNI
argument_list|(
name|OP_GNBYNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetbyaddr
case|:
name|LOP
argument_list|(
name|OP_GNBYADDR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getnetent
case|:
name|FUN0
argument_list|(
name|OP_GNETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getservbyname
case|:
name|LOP
argument_list|(
name|OP_GSBYNAME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getservbyport
case|:
name|LOP
argument_list|(
name|OP_GSBYPORT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getservent
case|:
name|FUN0
argument_list|(
name|OP_GSERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getsockname
case|:
name|UNI
argument_list|(
name|OP_GETSOCKNAME
argument_list|)
expr_stmt|;
case|case
name|KEY_getsockopt
case|:
name|LOP
argument_list|(
name|OP_GSOCKOPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrent
case|:
name|FUN0
argument_list|(
name|OP_GGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrnam
case|:
name|UNI
argument_list|(
name|OP_GGRNAM
argument_list|)
expr_stmt|;
case|case
name|KEY_getgrgid
case|:
name|UNI
argument_list|(
name|OP_GGRGID
argument_list|)
expr_stmt|;
case|case
name|KEY_getlogin
case|:
name|FUN0
argument_list|(
name|OP_GETLOGIN
argument_list|)
expr_stmt|;
case|case
name|KEY_glob
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_GLOB
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_hex
case|:
name|UNI
argument_list|(
name|OP_HEX
argument_list|)
expr_stmt|;
case|case
name|KEY_if
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|IF
argument_list|)
expr_stmt|;
case|case
name|KEY_index
case|:
name|LOP
argument_list|(
name|OP_INDEX
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_int
case|:
name|UNI
argument_list|(
name|OP_INT
argument_list|)
expr_stmt|;
case|case
name|KEY_ioctl
case|:
name|LOP
argument_list|(
name|OP_IOCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_join
case|:
name|LOP
argument_list|(
name|OP_JOIN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_keys
case|:
name|UNI
argument_list|(
name|OP_KEYS
argument_list|)
expr_stmt|;
case|case
name|KEY_kill
case|:
name|LOP
argument_list|(
name|OP_KILL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_last
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_LAST
argument_list|)
expr_stmt|;
case|case
name|KEY_lc
case|:
name|UNI
argument_list|(
name|OP_LC
argument_list|)
expr_stmt|;
case|case
name|KEY_lcfirst
case|:
name|UNI
argument_list|(
name|OP_LCFIRST
argument_list|)
expr_stmt|;
case|case
name|KEY_local
case|:
name|OPERATOR
argument_list|(
name|LOCAL
argument_list|)
expr_stmt|;
case|case
name|KEY_length
case|:
name|UNI
argument_list|(
name|OP_LENGTH
argument_list|)
expr_stmt|;
case|case
name|KEY_lt
case|:
name|Rop
argument_list|(
name|OP_SLT
argument_list|)
expr_stmt|;
case|case
name|KEY_le
case|:
name|Rop
argument_list|(
name|OP_SLE
argument_list|)
expr_stmt|;
case|case
name|KEY_localtime
case|:
name|UNI
argument_list|(
name|OP_LOCALTIME
argument_list|)
expr_stmt|;
case|case
name|KEY_log
case|:
name|UNI
argument_list|(
name|OP_LOG
argument_list|)
expr_stmt|;
case|case
name|KEY_link
case|:
name|LOP
argument_list|(
name|OP_LINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_listen
case|:
name|LOP
argument_list|(
name|OP_LISTEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_lock
case|:
name|UNI
argument_list|(
name|OP_LOCK
argument_list|)
expr_stmt|;
case|case
name|KEY_lstat
case|:
name|UNI
argument_list|(
name|OP_LSTAT
argument_list|)
expr_stmt|;
case|case
name|KEY_m
case|:
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_MATCH
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_map
case|:
name|LOP
argument_list|(
name|OP_MAPSTART
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_mkdir
case|:
name|LOP
argument_list|(
name|OP_MKDIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgctl
case|:
name|LOP
argument_list|(
name|OP_MSGCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgget
case|:
name|LOP
argument_list|(
name|OP_MSGGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgrcv
case|:
name|LOP
argument_list|(
name|OP_MSGRCV
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_msgsnd
case|:
name|LOP
argument_list|(
name|OP_MSGSND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_my
case|:
name|PL_in_my
operator|=
name|TRUE
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
sizeof|sizeof
name|PL_tokenbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|PL_in_my_stash
operator|=
name|gv_stashpv
argument_list|(
name|PL_tokenbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_in_my_stash
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|1024
index|]
decl_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"No such class %.1000s"
argument_list|,
name|PL_tokenbuf
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|OPERATOR
argument_list|(
name|MY
argument_list|)
expr_stmt|;
case|case
name|KEY_next
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_NEXT
argument_list|)
expr_stmt|;
case|case
name|KEY_ne
case|:
name|Eop
argument_list|(
name|OP_SNE
argument_list|)
expr_stmt|;
case|case
name|KEY_no
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XSTATE
condition|)
name|yyerror
argument_list|(
literal|"\"no\" not allowed in expression"
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|OPERATOR
argument_list|(
name|USE
argument_list|)
expr_stmt|;
case|case
name|KEY_not
case|:
name|OPERATOR
argument_list|(
name|NOTOP
argument_list|)
expr_stmt|;
case|case
name|KEY_open
case|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|d
operator|=
name|s
init|;
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
name|t
operator|=
name|skipspace
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"|&*+-=!?:."
argument_list|,
operator|*
name|t
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Precedence problem: open %.*s should be open(%.*s)"
argument_list|,
name|d
operator|-
name|s
argument_list|,
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|LOP
argument_list|(
name|OP_OPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_or
case|:
name|yylval
operator|.
name|ival
operator|=
name|OP_OR
expr_stmt|;
name|OPERATOR
argument_list|(
name|OROP
argument_list|)
expr_stmt|;
case|case
name|KEY_ord
case|:
name|UNI
argument_list|(
name|OP_ORD
argument_list|)
expr_stmt|;
case|case
name|KEY_oct
case|:
name|UNI
argument_list|(
name|OP_OCT
argument_list|)
expr_stmt|;
case|case
name|KEY_opendir
case|:
name|LOP
argument_list|(
name|OP_OPEN_DIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_print
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_PRINT
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_printf
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_PRTF
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_prototype
case|:
name|UNI
argument_list|(
name|OP_PROTOTYPE
argument_list|)
expr_stmt|;
case|case
name|KEY_push
case|:
name|LOP
argument_list|(
name|OP_PUSH
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_pop
case|:
name|UNI
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
case|case
name|KEY_pos
case|:
name|UNI
argument_list|(
name|OP_POS
argument_list|)
expr_stmt|;
case|case
name|KEY_pack
case|:
name|LOP
argument_list|(
name|OP_PACK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_package
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
case|case
name|KEY_pipe
case|:
name|LOP
argument_list|(
name|OP_PIPE_OP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_q
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_CONST
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_quotemeta
case|:
name|UNI
argument_list|(
name|OP_QUOTEMETA
argument_list|)
expr_stmt|;
case|case
name|KEY_qw
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|SvLEN
argument_list|(
name|PL_lex_stuff
argument_list|)
condition|)
block|{
name|d
operator|=
name|SvPV_force
argument_list|(
name|PL_lex_stuff
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|d
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|','
condition|)
block|{
name|warn
argument_list|(
literal|"Possible attempt to separate words with commas"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'#'
condition|)
block|{
name|warn
argument_list|(
literal|"Possible attempt to put comments in qw() list"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|force_next
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|tokeq
argument_list|(
name|PL_lex_stuff
argument_list|)
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_SPLIT
expr_stmt|;
name|CLINE
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
name|PL_last_lop
operator|=
name|PL_oldbufptr
expr_stmt|;
name|PL_last_lop_op
operator|=
name|OP_SPLIT
expr_stmt|;
return|return
name|FUNC
return|;
case|case
name|KEY_qq
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_STRINGIFY
expr_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|==
literal|'\''
condition|)
name|SvIVX
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* qq'$foo' should intepolate */
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_qr
case|:
name|s
operator|=
name|scan_pat
argument_list|(
name|s
argument_list|,
name|OP_QR
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_qx
case|:
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|missingterm
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_BACKTICK
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_return
case|:
name|OLDLOP
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
case|case
name|KEY_require
case|:
operator|*
name|PL_tokenbuf
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|PL_tokenbuf
argument_list|)
condition|)
name|gv_stashpvn
argument_list|(
name|PL_tokenbuf
argument_list|,
name|strlen
argument_list|(
name|PL_tokenbuf
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
condition|)
name|yyerror
argument_list|(
literal|"<> should be quotes"
argument_list|)
expr_stmt|;
name|UNI
argument_list|(
name|OP_REQUIRE
argument_list|)
expr_stmt|;
case|case
name|KEY_reset
case|:
name|UNI
argument_list|(
name|OP_RESET
argument_list|)
expr_stmt|;
case|case
name|KEY_redo
case|:
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOOPX
argument_list|(
name|OP_REDO
argument_list|)
expr_stmt|;
case|case
name|KEY_rename
case|:
name|LOP
argument_list|(
name|OP_RENAME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_rand
case|:
name|UNI
argument_list|(
name|OP_RAND
argument_list|)
expr_stmt|;
case|case
name|KEY_rmdir
case|:
name|UNI
argument_list|(
name|OP_RMDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_rindex
case|:
name|LOP
argument_list|(
name|OP_RINDEX
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_read
case|:
name|LOP
argument_list|(
name|OP_READ
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_readdir
case|:
name|UNI
argument_list|(
name|OP_READDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_readline
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|UNI
argument_list|(
name|OP_READLINE
argument_list|)
expr_stmt|;
case|case
name|KEY_readpipe
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|UNI
argument_list|(
name|OP_BACKTICK
argument_list|)
expr_stmt|;
case|case
name|KEY_rewinddir
case|:
name|UNI
argument_list|(
name|OP_REWINDDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_recv
case|:
name|LOP
argument_list|(
name|OP_RECV
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_reverse
case|:
name|LOP
argument_list|(
name|OP_REVERSE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_readlink
case|:
name|UNI
argument_list|(
name|OP_READLINK
argument_list|)
expr_stmt|;
case|case
name|KEY_ref
case|:
name|UNI
argument_list|(
name|OP_REF
argument_list|)
expr_stmt|;
case|case
name|KEY_s
case|:
name|s
operator|=
name|scan_subst
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylval
operator|.
name|opval
condition|)
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|TOKEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force error */
case|case
name|KEY_chomp
case|:
name|UNI
argument_list|(
name|OP_CHOMP
argument_list|)
expr_stmt|;
case|case
name|KEY_scalar
case|:
name|UNI
argument_list|(
name|OP_SCALAR
argument_list|)
expr_stmt|;
case|case
name|KEY_select
case|:
name|LOP
argument_list|(
name|OP_SELECT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_seek
case|:
name|LOP
argument_list|(
name|OP_SEEK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semctl
case|:
name|LOP
argument_list|(
name|OP_SEMCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semget
case|:
name|LOP
argument_list|(
name|OP_SEMGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_semop
case|:
name|LOP
argument_list|(
name|OP_SEMOP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_send
case|:
name|LOP
argument_list|(
name|OP_SEND
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setpgrp
case|:
name|LOP
argument_list|(
name|OP_SETPGRP
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setpriority
case|:
name|LOP
argument_list|(
name|OP_SETPRIORITY
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sethostent
case|:
name|UNI
argument_list|(
name|OP_SHOSTENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setnetent
case|:
name|UNI
argument_list|(
name|OP_SNETENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setservent
case|:
name|UNI
argument_list|(
name|OP_SSERVENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setprotoent
case|:
name|UNI
argument_list|(
name|OP_SPROTOENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setpwent
case|:
name|FUN0
argument_list|(
name|OP_SPWENT
argument_list|)
expr_stmt|;
case|case
name|KEY_setgrent
case|:
name|FUN0
argument_list|(
name|OP_SGRENT
argument_list|)
expr_stmt|;
case|case
name|KEY_seekdir
case|:
name|LOP
argument_list|(
name|OP_SEEKDIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_setsockopt
case|:
name|LOP
argument_list|(
name|OP_SSOCKOPT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shift
case|:
name|UNI
argument_list|(
name|OP_SHIFT
argument_list|)
expr_stmt|;
case|case
name|KEY_shmctl
case|:
name|LOP
argument_list|(
name|OP_SHMCTL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmget
case|:
name|LOP
argument_list|(
name|OP_SHMGET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmread
case|:
name|LOP
argument_list|(
name|OP_SHMREAD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shmwrite
case|:
name|LOP
argument_list|(
name|OP_SHMWRITE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_shutdown
case|:
name|LOP
argument_list|(
name|OP_SHUTDOWN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sin
case|:
name|UNI
argument_list|(
name|OP_SIN
argument_list|)
expr_stmt|;
case|case
name|KEY_sleep
case|:
name|UNI
argument_list|(
name|OP_SLEEP
argument_list|)
expr_stmt|;
case|case
name|KEY_socket
case|:
name|LOP
argument_list|(
name|OP_SOCKET
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_socketpair
case|:
name|LOP
argument_list|(
name|OP_SOCKPAIR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sort
case|:
name|checkcomma
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
literal|"subroutine name"
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|')'
condition|)
comment|/* probably a close */
name|croak
argument_list|(
literal|"sort is now a reserved word"
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|OP_SORT
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_split
case|:
name|LOP
argument_list|(
name|OP_SPLIT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sprintf
case|:
name|LOP
argument_list|(
name|OP_SPRINTF
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_splice
case|:
name|LOP
argument_list|(
name|OP_SPLICE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sqrt
case|:
name|UNI
argument_list|(
name|OP_SQRT
argument_list|)
expr_stmt|;
case|case
name|KEY_srand
case|:
name|UNI
argument_list|(
name|OP_SRAND
argument_list|)
expr_stmt|;
case|case
name|KEY_stat
case|:
name|UNI
argument_list|(
name|OP_STAT
argument_list|)
expr_stmt|;
case|case
name|KEY_study
case|:
name|PL_sawstudy
operator|++
expr_stmt|;
name|UNI
argument_list|(
name|OP_STUDY
argument_list|)
expr_stmt|;
case|case
name|KEY_substr
case|:
name|LOP
argument_list|(
name|OP_SUBSTR
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_format
case|:
case|case
name|KEY_sub
case|:
name|really_sub
label|:
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'\''
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|char
name|tmpbuf
index|[
sizeof|sizeof
name|PL_tokenbuf
index|]
decl_stmt|;
name|PL_expect
operator|=
name|XBLOCK
expr_stmt|;
name|d
operator|=
name|scan_word
argument_list|(
name|s
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|tmpbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
else|else
block|{
name|sv_setsv
argument_list|(
name|PL_subname
argument_list|,
name|PL_curstname
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_subname
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_subname
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_expect
operator|=
name|XTERMBLOCK
expr_stmt|;
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
name|KEY_format
condition|)
block|{
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|PL_lex_formbrack
operator|=
name|PL_lex_brackets
operator|+
literal|1
expr_stmt|;
name|OPERATOR
argument_list|(
name|FORMAT
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a prototype */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Prototype not terminated"
argument_list|)
expr_stmt|;
block|}
comment|/* strip spaces */
name|d
operator|=
name|SvPVX
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|d
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|d
index|[
name|tmp
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|d
index|[
name|tmp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|PL_lex_stuff
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|PL_nexttoke
operator|++
expr_stmt|;
name|PL_nextval
index|[
literal|1
index|]
operator|=
name|PL_nextval
index|[
literal|0
index|]
expr_stmt|;
name|PL_nexttype
index|[
literal|1
index|]
operator|=
name|PL_nexttype
index|[
literal|0
index|]
expr_stmt|;
name|PL_nextval
index|[
literal|0
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_nexttype
index|[
literal|0
index|]
operator|=
name|THING
expr_stmt|;
if|if
condition|(
name|PL_nexttoke
operator|==
literal|1
condition|)
block|{
name|PL_lex_defer
operator|=
name|PL_lex_state
expr_stmt|;
name|PL_lex_expect
operator|=
name|PL_expect
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_KNOWNEXT
expr_stmt|;
block|}
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|SvPV
argument_list|(
name|PL_subname
argument_list|,
name|n_a
argument_list|)
operator|==
literal|'?'
condition|)
block|{
name|sv_setpv
argument_list|(
name|PL_subname
argument_list|,
literal|"__ANON__"
argument_list|)
expr_stmt|;
name|TOKEN
argument_list|(
name|ANONSUB
argument_list|)
expr_stmt|;
block|}
name|PREBLOCK
argument_list|(
name|SUB
argument_list|)
expr_stmt|;
case|case
name|KEY_system
case|:
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|OP_SYSTEM
argument_list|,
name|XREF
argument_list|)
expr_stmt|;
case|case
name|KEY_symlink
case|:
name|LOP
argument_list|(
name|OP_SYMLINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_syscall
case|:
name|LOP
argument_list|(
name|OP_SYSCALL
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysopen
case|:
name|LOP
argument_list|(
name|OP_SYSOPEN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysseek
case|:
name|LOP
argument_list|(
name|OP_SYSSEEK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_sysread
case|:
name|LOP
argument_list|(
name|OP_SYSREAD
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_syswrite
case|:
name|LOP
argument_list|(
name|OP_SYSWRITE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_tr
case|:
name|s
operator|=
name|scan_trans
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|KEY_tell
case|:
name|UNI
argument_list|(
name|OP_TELL
argument_list|)
expr_stmt|;
case|case
name|KEY_telldir
case|:
name|UNI
argument_list|(
name|OP_TELLDIR
argument_list|)
expr_stmt|;
case|case
name|KEY_tie
case|:
name|LOP
argument_list|(
name|OP_TIE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_tied
case|:
name|UNI
argument_list|(
name|OP_TIED
argument_list|)
expr_stmt|;
case|case
name|KEY_time
case|:
name|FUN0
argument_list|(
name|OP_TIME
argument_list|)
expr_stmt|;
case|case
name|KEY_times
case|:
name|FUN0
argument_list|(
name|OP_TMS
argument_list|)
expr_stmt|;
case|case
name|KEY_truncate
case|:
name|LOP
argument_list|(
name|OP_TRUNCATE
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_uc
case|:
name|UNI
argument_list|(
name|OP_UC
argument_list|)
expr_stmt|;
case|case
name|KEY_ucfirst
case|:
name|UNI
argument_list|(
name|OP_UCFIRST
argument_list|)
expr_stmt|;
case|case
name|KEY_untie
case|:
name|UNI
argument_list|(
name|OP_UNTIE
argument_list|)
expr_stmt|;
case|case
name|KEY_until
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNTIL
argument_list|)
expr_stmt|;
case|case
name|KEY_unless
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNLESS
argument_list|)
expr_stmt|;
case|case
name|KEY_unlink
case|:
name|LOP
argument_list|(
name|OP_UNLINK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_undef
case|:
name|UNI
argument_list|(
name|OP_UNDEF
argument_list|)
expr_stmt|;
case|case
name|KEY_unpack
case|:
name|LOP
argument_list|(
name|OP_UNPACK
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_utime
case|:
name|LOP
argument_list|(
name|OP_UTIME
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_umask
case|:
if|if
condition|(
name|PL_dowarn
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
name|d
operator|<
name|PL_bufend
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'('
operator|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|!=
literal|'0'
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|yywarn
argument_list|(
literal|"umask: argument is missing initial 0"
argument_list|)
expr_stmt|;
block|}
name|UNI
argument_list|(
name|OP_UMASK
argument_list|)
expr_stmt|;
case|case
name|KEY_unshift
case|:
name|LOP
argument_list|(
name|OP_UNSHIFT
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_use
case|:
if|if
condition|(
name|PL_expect
operator|!=
name|XSTATE
condition|)
name|yyerror
argument_list|(
literal|"\"use\" not allowed in expression"
argument_list|)
expr_stmt|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|(
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
operator|,
operator|*
name|s
operator|==
literal|';'
operator|)
condition|)
block|{
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
name|Nullop
expr_stmt|;
name|force_next
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s
operator|=
name|force_word
argument_list|(
name|s
argument_list|,
name|WORD
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|force_version
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ival
operator|=
literal|1
expr_stmt|;
name|OPERATOR
argument_list|(
name|USE
argument_list|)
expr_stmt|;
case|case
name|KEY_values
case|:
name|UNI
argument_list|(
name|OP_VALUES
argument_list|)
expr_stmt|;
case|case
name|KEY_vec
case|:
name|PL_sawvec
operator|=
name|TRUE
expr_stmt|;
name|LOP
argument_list|(
name|OP_VEC
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_while
case|:
name|yylval
operator|.
name|ival
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|WHILE
argument_list|)
expr_stmt|;
case|case
name|KEY_warn
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|LOP
argument_list|(
name|OP_WARN
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_wait
case|:
name|FUN0
argument_list|(
name|OP_WAIT
argument_list|)
expr_stmt|;
case|case
name|KEY_waitpid
case|:
name|LOP
argument_list|(
name|OP_WAITPID
argument_list|,
name|XTERM
argument_list|)
expr_stmt|;
case|case
name|KEY_wantarray
case|:
name|FUN0
argument_list|(
name|OP_WANTARRAY
argument_list|)
expr_stmt|;
case|case
name|KEY_write
case|:
ifdef|#
directive|ifdef
name|EBCDIC
block|{
specifier|static
name|char
name|ctl_l
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|ctl_l
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ctl_l
index|[
literal|0
index|]
operator|=
name|toCTRL
argument_list|(
literal|'L'
argument_list|)
expr_stmt|;
name|gv_fetchpv
argument_list|(
name|ctl_l
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gv_fetchpv
argument_list|(
literal|"\f"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* Make sure $^L is defined */
endif|#
directive|endif
name|UNI
argument_list|(
name|OP_ENTERWRITE
argument_list|)
expr_stmt|;
case|case
name|KEY_x
case|:
if|if
condition|(
name|PL_expect
operator|==
name|XOPERATOR
condition|)
name|Mop
argument_list|(
name|OP_REPEAT
argument_list|)
expr_stmt|;
name|check_uni
argument_list|()
expr_stmt|;
goto|goto
name|just_a_word
goto|;
case|case
name|KEY_xor
case|:
name|yylval
operator|.
name|ival
operator|=
name|OP_XOR
expr_stmt|;
name|OPERATOR
argument_list|(
name|OROP
argument_list|)
expr_stmt|;
case|case
name|KEY_y
case|:
name|s
operator|=
name|scan_trans
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|sublex_start
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|I32
name|keyword
parameter_list|(
specifier|register
name|char
modifier|*
name|d
parameter_list|,
name|I32
name|len
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'_'
case|:
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__FILE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___FILE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__LINE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___LINE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__PACKAGE__"
argument_list|)
condition|)
return|return
operator|-
name|KEY___PACKAGE__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__DATA__"
argument_list|)
condition|)
return|return
name|KEY___DATA__
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__END__"
argument_list|)
condition|)
return|return
name|KEY___END__
return|;
block|}
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"AUTOLOAD"
argument_list|)
condition|)
return|return
name|KEY_AUTOLOAD
return|;
break|break;
case|case
literal|'a'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"and"
argument_list|)
condition|)
return|return
operator|-
name|KEY_and
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"abs"
argument_list|)
condition|)
return|return
operator|-
name|KEY_abs
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"alarm"
argument_list|)
condition|)
return|return
operator|-
name|KEY_alarm
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"atan2"
argument_list|)
condition|)
return|return
operator|-
name|KEY_atan2
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"accept"
argument_list|)
condition|)
return|return
operator|-
name|KEY_accept
return|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
return|return
name|KEY_BEGIN
return|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"bless"
argument_list|)
condition|)
return|return
operator|-
name|KEY_bless
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"bind"
argument_list|)
condition|)
return|return
operator|-
name|KEY_bind
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"binmode"
argument_list|)
condition|)
return|return
operator|-
name|KEY_binmode
return|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"CORE"
argument_list|)
condition|)
return|return
operator|-
name|KEY_CORE
return|;
break|break;
case|case
literal|'c'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cmp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_cmp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cos"
argument_list|)
condition|)
return|return
operator|-
name|KEY_cos
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chop"
argument_list|)
condition|)
return|return
name|KEY_chop
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"close"
argument_list|)
condition|)
return|return
operator|-
name|KEY_close
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chdir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chomp"
argument_list|)
condition|)
return|return
name|KEY_chomp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chmod"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chmod
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chown"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chown
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"crypt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_crypt
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chroot"
argument_list|)
condition|)
return|return
operator|-
name|KEY_chroot
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"caller"
argument_list|)
condition|)
return|return
operator|-
name|KEY_caller
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"connect"
argument_list|)
condition|)
return|return
operator|-
name|KEY_connect
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"closedir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_closedir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"continue"
argument_list|)
condition|)
return|return
operator|-
name|KEY_continue
return|;
break|break;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"DESTROY"
argument_list|)
condition|)
return|return
name|KEY_DESTROY
return|;
break|break;
case|case
literal|'d'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"do"
argument_list|)
condition|)
return|return
name|KEY_do
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"die"
argument_list|)
condition|)
return|return
operator|-
name|KEY_die
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dump"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dump
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"delete"
argument_list|)
condition|)
return|return
name|KEY_delete
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"defined"
argument_list|)
condition|)
return|return
name|KEY_defined
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmopen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dbmopen
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmclose"
argument_list|)
condition|)
return|return
operator|-
name|KEY_dbmclose
return|;
break|break;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"EQ"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_eq
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"END"
argument_list|)
condition|)
return|return
name|KEY_END
return|;
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eq"
argument_list|)
condition|)
return|return
operator|-
name|KEY_eq
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eof"
argument_list|)
condition|)
return|return
operator|-
name|KEY_eof
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exp
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"else"
argument_list|)
condition|)
return|return
name|KEY_else
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exit"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exit
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eval"
argument_list|)
condition|)
return|return
name|KEY_eval
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exec"
argument_list|)
condition|)
return|return
operator|-
name|KEY_exec
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"each"
argument_list|)
condition|)
return|return
name|KEY_each
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elsif"
argument_list|)
condition|)
return|return
name|KEY_elsif
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exists"
argument_list|)
condition|)
return|return
name|KEY_exists
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elseif"
argument_list|)
condition|)
name|warn
argument_list|(
literal|"elseif should be elsif"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endgrent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endgrent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endpwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endpwent
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endnetent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endnetent
return|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endhostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endhostent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endservent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endservent
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endprotoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_endprotoent
return|;
break|break;
block|}
break|break;
case|case
literal|'f'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"for"
argument_list|)
condition|)
return|return
name|KEY_for
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fork"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fork
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fcntl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fcntl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"flock"
argument_list|)
condition|)
return|return
operator|-
name|KEY_flock
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"format"
argument_list|)
condition|)
return|return
name|KEY_format
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fileno"
argument_list|)
condition|)
return|return
operator|-
name|KEY_fileno
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"foreach"
argument_list|)
condition|)
return|return
name|KEY_foreach
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"formline"
argument_list|)
condition|)
return|return
operator|-
name|KEY_formline
return|;
break|break;
block|}
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GT"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_gt
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_ge
return|;
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"get"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|d
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'p'
condition|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ppid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getppid
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pgrp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpgrp
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwnam"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwnam
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwuid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpwuid
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"peername"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpeername
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotoent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"priority"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getpriority
return|;
break|break;
case|case
literal|14
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotobyname
return|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobynumber"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getprotobynumber
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyaddr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostbyaddr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gethostent
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyaddr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetbyaddr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getnetent
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservbyname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyport"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservbyport
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getservent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockname"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getsockname
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockopt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getsockopt
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grnam"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrnam
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grgid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getgrgid
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"login"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getlogin
return|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"c"
argument_list|)
condition|)
return|return
operator|-
name|KEY_getc
return|;
break|break;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ge"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ge
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grep"
argument_list|)
condition|)
return|return
name|KEY_grep
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"goto"
argument_list|)
condition|)
return|return
name|KEY_goto
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"glob"
argument_list|)
condition|)
return|return
name|KEY_glob
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gmtime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_gmtime
return|;
break|break;
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hex"
argument_list|)
condition|)
return|return
operator|-
name|KEY_hex
return|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"INIT"
argument_list|)
condition|)
return|return
name|KEY_INIT
return|;
break|break;
case|case
literal|'i'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"if"
argument_list|)
condition|)
return|return
name|KEY_if
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
operator|-
name|KEY_int
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"index"
argument_list|)
condition|)
return|return
operator|-
name|KEY_index
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ioctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ioctl
return|;
break|break;
block|}
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"join"
argument_list|)
condition|)
return|return
operator|-
name|KEY_join
return|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"keys"
argument_list|)
condition|)
return|return
name|KEY_keys
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"kill"
argument_list|)
condition|)
return|return
operator|-
name|KEY_kill
return|;
block|}
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LT"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_lt
return|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_le
return|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"le"
argument_list|)
condition|)
return|return
operator|-
name|KEY_le
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lc"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lc
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"log"
argument_list|)
condition|)
return|return
operator|-
name|KEY_log
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"last"
argument_list|)
condition|)
return|return
name|KEY_last
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"link"
argument_list|)
condition|)
return|return
operator|-
name|KEY_link
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lock"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lock
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"local"
argument_list|)
condition|)
return|return
name|KEY_local
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lstat"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lstat
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"length"
argument_list|)
condition|)
return|return
operator|-
name|KEY_length
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"listen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_listen
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lcfirst"
argument_list|)
condition|)
return|return
operator|-
name|KEY_lcfirst
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"localtime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_localtime
return|;
break|break;
block|}
break|break;
case|case
literal|'m'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
return|return
name|KEY_m
return|;
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"my"
argument_list|)
condition|)
return|return
name|KEY_my
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"map"
argument_list|)
condition|)
return|return
name|KEY_map
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"mkdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_mkdir
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgget
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgrcv"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgrcv
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgsnd"
argument_list|)
condition|)
return|return
operator|-
name|KEY_msgsnd
return|;
break|break;
block|}
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"NE"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
name|KEY_ne
return|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"next"
argument_list|)
condition|)
return|return
name|KEY_next
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ne"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ne
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"not"
argument_list|)
condition|)
return|return
operator|-
name|KEY_not
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"no"
argument_list|)
condition|)
return|return
name|KEY_no
return|;
break|break;
case|case
literal|'o'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"or"
argument_list|)
condition|)
return|return
operator|-
name|KEY_or
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ord"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ord
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"oct"
argument_list|)
condition|)
return|return
operator|-
name|KEY_oct
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"our"
argument_list|)
condition|)
block|{
name|deprecate
argument_list|(
literal|"reserved word \"our\""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"open"
argument_list|)
condition|)
return|return
operator|-
name|KEY_open
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"opendir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_opendir
return|;
break|break;
block|}
break|break;
case|case
literal|'p'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pop"
argument_list|)
condition|)
return|return
name|KEY_pop
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pos"
argument_list|)
condition|)
return|return
name|KEY_pos
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"push"
argument_list|)
condition|)
return|return
name|KEY_push
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pack"
argument_list|)
condition|)
return|return
operator|-
name|KEY_pack
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pipe"
argument_list|)
condition|)
return|return
operator|-
name|KEY_pipe
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"print"
argument_list|)
condition|)
return|return
name|KEY_print
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"printf"
argument_list|)
condition|)
return|return
name|KEY_printf
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"package"
argument_list|)
condition|)
return|return
name|KEY_package
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"prototype"
argument_list|)
condition|)
return|return
name|KEY_prototype
return|;
block|}
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|len
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"q"
argument_list|)
condition|)
return|return
name|KEY_q
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qr"
argument_list|)
condition|)
return|return
name|KEY_qr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qq"
argument_list|)
condition|)
return|return
name|KEY_qq
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qw"
argument_list|)
condition|)
return|return
name|KEY_qw
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qx"
argument_list|)
condition|)
return|return
name|KEY_qx
return|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"quotemeta"
argument_list|)
condition|)
return|return
operator|-
name|KEY_quotemeta
return|;
break|break;
case|case
literal|'r'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ref"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ref
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"read"
argument_list|)
condition|)
return|return
operator|-
name|KEY_read
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rand"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rand
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"recv"
argument_list|)
condition|)
return|return
operator|-
name|KEY_recv
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"redo"
argument_list|)
condition|)
return|return
name|KEY_redo
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rmdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rmdir
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reset"
argument_list|)
condition|)
return|return
operator|-
name|KEY_reset
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"return"
argument_list|)
condition|)
return|return
name|KEY_return
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rename"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rename
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rindex"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rindex
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"require"
argument_list|)
condition|)
return|return
operator|-
name|KEY_require
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reverse"
argument_list|)
condition|)
return|return
operator|-
name|KEY_reverse
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readdir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readlink
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readline"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readline
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readpipe"
argument_list|)
condition|)
return|return
operator|-
name|KEY_readpipe
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rewinddir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_rewinddir
return|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
return|return
name|KEY_s
return|;
case|case
literal|'c'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"scalar"
argument_list|)
condition|)
return|return
name|KEY_scalar
return|;
break|break;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seek"
argument_list|)
condition|)
return|return
operator|-
name|KEY_seek
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"send"
argument_list|)
condition|)
return|return
operator|-
name|KEY_send
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semop"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semop
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"select"
argument_list|)
condition|)
return|return
operator|-
name|KEY_select
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_semget
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpgrp"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpgrp
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seekdir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_seekdir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpwent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpwent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setgrent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setgrent
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setnetent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setnetent
return|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setsockopt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setsockopt
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sethostent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sethostent
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setservent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setservent
return|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpriority"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setpriority
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setprotoent"
argument_list|)
condition|)
return|return
operator|-
name|KEY_setprotoent
return|;
break|break;
block|}
break|break;
case|case
literal|'h'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shift"
argument_list|)
condition|)
return|return
name|KEY_shift
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmctl"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmctl
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmget"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmget
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmread"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmread
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmwrite"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shmwrite
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shutdown"
argument_list|)
condition|)
return|return
operator|-
name|KEY_shutdown
return|;
break|break;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sin"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sin
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sleep"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sleep
return|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sort"
argument_list|)
condition|)
return|return
name|KEY_sort
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socket"
argument_list|)
condition|)
return|return
operator|-
name|KEY_socket
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socketpair"
argument_list|)
condition|)
return|return
operator|-
name|KEY_socketpair
return|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"split"
argument_list|)
condition|)
return|return
name|KEY_split
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sprintf"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sprintf
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"splice"
argument_list|)
condition|)
return|return
name|KEY_splice
return|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sqrt"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sqrt
return|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"srand"
argument_list|)
condition|)
return|return
operator|-
name|KEY_srand
return|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"stat"
argument_list|)
condition|)
return|return
operator|-
name|KEY_stat
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"study"
argument_list|)
condition|)
return|return
name|KEY_study
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"substr"
argument_list|)
condition|)
return|return
operator|-
name|KEY_substr
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sub"
argument_list|)
condition|)
return|return
name|KEY_sub
return|;
break|break;
case|case
literal|'y'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"system"
argument_list|)
condition|)
return|return
operator|-
name|KEY_system
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"symlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_symlink
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syscall"
argument_list|)
condition|)
return|return
operator|-
name|KEY_syscall
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysopen"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysopen
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysread"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysread
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysseek"
argument_list|)
condition|)
return|return
operator|-
name|KEY_sysseek
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syswrite"
argument_list|)
condition|)
return|return
operator|-
name|KEY_syswrite
return|;
break|break;
block|}
break|break;
block|}
break|break;
case|case
literal|'t'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tr"
argument_list|)
condition|)
return|return
name|KEY_tr
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tie"
argument_list|)
condition|)
return|return
name|KEY_tie
return|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tell"
argument_list|)
condition|)
return|return
operator|-
name|KEY_tell
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tied"
argument_list|)
condition|)
return|return
name|KEY_tied
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"time"
argument_list|)
condition|)
return|return
operator|-
name|KEY_time
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"times"
argument_list|)
condition|)
return|return
operator|-
name|KEY_times
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"telldir"
argument_list|)
condition|)
return|return
operator|-
name|KEY_telldir
return|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"truncate"
argument_list|)
condition|)
return|return
operator|-
name|KEY_truncate
return|;
break|break;
block|}
break|break;
case|case
literal|'u'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"uc"
argument_list|)
condition|)
return|return
operator|-
name|KEY_uc
return|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"use"
argument_list|)
condition|)
return|return
name|KEY_use
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"undef"
argument_list|)
condition|)
return|return
name|KEY_undef
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"until"
argument_list|)
condition|)
return|return
name|KEY_until
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"untie"
argument_list|)
condition|)
return|return
name|KEY_untie
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"utime"
argument_list|)
condition|)
return|return
operator|-
name|KEY_utime
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"umask"
argument_list|)
condition|)
return|return
operator|-
name|KEY_umask
return|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unless"
argument_list|)
condition|)
return|return
name|KEY_unless
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unpack"
argument_list|)
condition|)
return|return
operator|-
name|KEY_unpack
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unlink"
argument_list|)
condition|)
return|return
operator|-
name|KEY_unlink
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unshift"
argument_list|)
condition|)
return|return
name|KEY_unshift
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ucfirst"
argument_list|)
condition|)
return|return
operator|-
name|KEY_ucfirst
return|;
break|break;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"values"
argument_list|)
condition|)
return|return
operator|-
name|KEY_values
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"vec"
argument_list|)
condition|)
return|return
operator|-
name|KEY_vec
return|;
break|break;
case|case
literal|'w'
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"warn"
argument_list|)
condition|)
return|return
operator|-
name|KEY_warn
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wait"
argument_list|)
condition|)
return|return
operator|-
name|KEY_wait
return|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"while"
argument_list|)
condition|)
return|return
name|KEY_while
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"write"
argument_list|)
condition|)
return|return
operator|-
name|KEY_write
return|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"waitpid"
argument_list|)
condition|)
return|return
operator|-
name|KEY_waitpid
return|;
break|break;
case|case
literal|9
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wantarray"
argument_list|)
condition|)
return|return
operator|-
name|KEY_wantarray
return|;
break|break;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|-
name|KEY_x
return|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"xor"
argument_list|)
condition|)
return|return
operator|-
name|KEY_xor
return|;
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
name|KEY_y
return|;
break|break;
case|case
literal|'z'
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|checkcomma
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|what
parameter_list|)
block|{
name|char
modifier|*
name|w
decl_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|*
name|s
operator|==
literal|' '
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* XXX gotta be a better way */
name|int
name|level
init|=
literal|1
decl_stmt|;
for|for
control|(
name|w
operator|=
name|s
operator|+
literal|2
init|;
operator|*
name|w
operator|&&
name|level
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|w
operator|==
literal|'('
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|w
operator|==
literal|')'
condition|)
operator|--
name|level
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|w
condition|)
for|for
control|(
init|;
operator|*
name|w
operator|&&
name|isSPACE
argument_list|(
operator|*
name|w
argument_list|)
condition|;
name|w
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|w
operator|||
operator|!
name|strchr
argument_list|(
literal|";|})]oaiuw!="
argument_list|,
operator|*
name|w
argument_list|)
condition|)
comment|/* an advisory hack only... */
name|warn
argument_list|(
literal|"%s (...) interpreted as function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|w
operator|=
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|int
name|kw
decl_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|kw
operator|=
name|keyword
argument_list|(
name|w
argument_list|,
name|s
operator|-
name|w
argument_list|)
operator|||
name|perl_get_cv
argument_list|(
name|w
argument_list|,
name|FALSE
argument_list|)
operator|!=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|kw
condition|)
return|return;
name|croak
argument_list|(
literal|"No comma allowed after %s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|SV
modifier|*
name|new_constant
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|SV
modifier|*
name|pv
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|HV
modifier|*
name|table
init|=
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
decl_stmt|;
comment|/* ^H */
name|BINOP
name|myop
decl_stmt|;
name|SV
modifier|*
name|res
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|SV
modifier|*
modifier|*
name|cvp
decl_stmt|;
name|SV
modifier|*
name|cv
decl_stmt|,
modifier|*
name|typesv
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
block|{
name|yyerror
argument_list|(
literal|"%^H is not defined"
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
name|cvp
operator|=
name|hv_fetch
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvp
operator|||
operator|!
name|SvOK
argument_list|(
operator|*
name|cvp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$^H{%s} is not defined"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Parent created it permanently */
name|cv
operator|=
operator|*
name|cvp
expr_stmt|;
if|if
condition|(
operator|!
name|pv
condition|)
name|pv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|typesv
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|typesv
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|myop
argument_list|,
literal|1
argument_list|,
name|BINOP
argument_list|)
expr_stmt|;
name|myop
operator|.
name|op_last
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
name|myop
operator|.
name|op_flags
operator|=
name|OPf_WANT_SCALAR
operator||
name|OPf_STACKED
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_OVERLOAD
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|PL_op
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|pp_pushmark
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|typesv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|PL_op
operator|=
name|pp_entersub
argument_list|(
name|ARGS
argument_list|)
condition|)
name|CALLRUNOPS
argument_list|()
expr_stmt|;
name|LEAVE
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|res
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Call to&{$^H{%s}} did not return a defined value"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|SvREFCNT_inc
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_word
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|STRLEN
name|destlen
parameter_list|,
name|int
name|allow_package
parameter_list|,
name|STRLEN
modifier|*
name|slp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|dest
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
init|=
name|d
operator|+
name|destlen
operator|-
literal|3
decl_stmt|;
comment|/* two-character token, ending NUL */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|ident_too_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|&&
name|allow_package
operator|&&
name|isIDFIRST
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|allow_package
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'$'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|slp
operator|=
name|d
operator|-
name|dest
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_ident
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
specifier|register
name|char
modifier|*
name|send
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|STRLEN
name|destlen
parameter_list|,
name|I32
name|ck_uni
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|bracket
init|=
literal|0
decl_stmt|;
name|char
name|funny
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|PL_lex_brackets
operator|==
literal|0
condition|)
name|PL_lex_fakebrack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
name|e
operator|=
name|d
operator|+
name|destlen
operator|-
literal|3
expr_stmt|;
comment|/* two-character token, ending NUL */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|ident_too_long
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|ident_too_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
operator|&&
name|isIDFIRST
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|':'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
if|if
condition|(
name|PL_lex_state
operator|!=
name|LEX_NORMAL
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPENDMAYBE
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|isALNUM
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"${"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
condition|)
name|deprecate
argument_list|(
literal|"\"$$<digit>\" to mean \"${$}<digit>\""
argument_list|)
expr_stmt|;
else|else
return|return
name|s
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|bracket
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ck_uni
condition|)
name|check_uni
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'^'
operator|&&
operator|*
name|s
operator|&&
operator|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"[\\]^_?"
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
operator|*
name|d
operator|=
name|toCTRL
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bracket
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|char
name|ch
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|' '
operator|&&
name|ch
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|d
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isIDFIRST
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|&&
name|strNE
argument_list|(
name|dest
argument_list|,
literal|"sub"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|keyword
argument_list|(
name|dest
argument_list|,
name|d
operator|-
name|dest
argument_list|)
condition|)
block|{
name|char
modifier|*
name|brack
init|=
operator|*
name|s
operator|==
literal|'['
condition|?
literal|"[...]"
else|:
literal|"{...}"
decl_stmt|;
name|warn
argument_list|(
literal|"Ambiguous use of %c{%s%s} resolved to %c%s%s"
argument_list|,
name|funny
argument_list|,
name|dest
argument_list|,
name|brack
argument_list|,
name|funny
argument_list|,
name|dest
argument_list|,
name|brack
argument_list|)
expr_stmt|;
block|}
name|PL_lex_fakebrack
operator|=
name|PL_lex_brackets
operator|+
literal|1
expr_stmt|;
name|bracket
operator|++
expr_stmt|;
name|PL_lex_brackstack
index|[
name|PL_lex_brackets
operator|++
index|]
operator|=
name|XOPERATOR
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
operator|&&
operator|!
name|PL_lex_brackets
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
if|if
condition|(
name|funny
operator|==
literal|'#'
condition|)
name|funny
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|PL_lex_state
operator|==
name|LEX_NORMAL
operator|&&
operator|(
name|keyword
argument_list|(
name|dest
argument_list|,
name|d
operator|-
name|dest
argument_list|)
operator|||
name|perl_get_cv
argument_list|(
name|dest
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Ambiguous use of %c{%s} resolved to %c%s"
argument_list|,
name|funny
argument_list|,
name|dest
argument_list|,
name|funny
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|bracket
expr_stmt|;
comment|/* let the parser handle it */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_INTERPNORMAL
operator|&&
operator|!
name|PL_lex_brackets
operator|&&
operator|!
name|intuit_more
argument_list|(
name|s
argument_list|)
condition|)
name|PL_lex_state
operator|=
name|LEX_INTERPEND
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|pmflag
parameter_list|(
name|U16
modifier|*
name|pmfl
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'i'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_FOLD
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'g'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_GLOBAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_CONTINUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'o'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_KEEP
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'m'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_MULTILINE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'s'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_SINGLELINE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'x'
condition|)
operator|*
name|pmfl
operator||=
name|PMf_EXTENDED
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_pat
parameter_list|(
name|char
modifier|*
name|start
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Search pattern not terminated"
argument_list|)
expr_stmt|;
block|}
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|newPMOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_multi_open
operator|==
literal|'?'
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_ONCE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_QR
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"iomsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|pm
operator|->
name|op_pmpermflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|pm
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_MATCH
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_subst
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|I32
name|first_start
decl_stmt|;
name|I32
name|es
init|=
literal|0
decl_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Substitution pattern not terminated"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|PL_multi_open
condition|)
name|s
operator|--
expr_stmt|;
name|first_start
operator|=
name|PL_multi_start
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
if|if
condition|(
name|PL_lex_repl
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Substitution replacement not terminated"
argument_list|)
expr_stmt|;
block|}
name|PL_multi_start
operator|=
name|first_start
expr_stmt|;
comment|/* so whole substitution is taken together */
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|newPMOP
argument_list|(
name|OP_SUBST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|es
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|pmflag
argument_list|(
operator|&
name|pm
operator|->
name|op_pmflags
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|es
condition|)
block|{
name|SV
modifier|*
name|repl
decl_stmt|;
name|PL_super_bufptr
operator|=
name|s
expr_stmt|;
name|PL_super_bufend
operator|=
name|PL_bufend
expr_stmt|;
name|PL_multi_end
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_EVAL
expr_stmt|;
name|repl
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|es
operator|--
operator|>
literal|0
condition|)
name|sv_catpv
argument_list|(
name|repl
argument_list|,
name|es
condition|?
literal|"eval "
else|:
literal|"do "
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|repl
argument_list|,
literal|"{ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|repl
argument_list|,
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|repl
argument_list|,
literal|" };"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SvCOMPILED_on
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|repl
expr_stmt|;
block|}
name|pm
operator|->
name|op_pmpermflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|pm
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_SUBST
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_trans
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|short
modifier|*
name|tbl
decl_stmt|;
name|I32
name|squash
decl_stmt|;
name|I32
name|Delete
decl_stmt|;
name|I32
name|complement
decl_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Transliteration pattern not terminated"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|PL_multi_open
condition|)
name|s
operator|--
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|PL_lex_stuff
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_stuff
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|Nullsv
expr_stmt|;
if|if
condition|(
name|PL_lex_repl
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_lex_repl
argument_list|)
expr_stmt|;
name|PL_lex_repl
operator|=
name|Nullsv
expr_stmt|;
name|croak
argument_list|(
literal|"Transliteration replacement not terminated"
argument_list|)
expr_stmt|;
block|}
name|New
argument_list|(
literal|803
argument_list|,
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|o
operator|=
name|newPVOP
argument_list|(
name|OP_TRANS
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbl
argument_list|)
expr_stmt|;
name|complement
operator|=
name|Delete
operator|=
name|squash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'c'
operator|||
operator|*
name|s
operator|==
literal|'d'
operator|||
operator|*
name|s
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'c'
condition|)
name|complement
operator|=
name|OPpTRANS_COMPLEMENT
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
condition|)
name|Delete
operator|=
name|OPpTRANS_DELETE
expr_stmt|;
else|else
name|squash
operator|=
name|OPpTRANS_SQUASH
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|o
operator|->
name|op_private
operator|=
name|Delete
operator||
name|squash
operator||
name|complement
expr_stmt|;
name|PL_lex_op
operator|=
name|o
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_TRANS
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_heredoc
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|herewas
decl_stmt|;
name|I32
name|op_type
init|=
name|OP_SCALAR
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|SV
modifier|*
name|tmpstr
decl_stmt|;
name|char
name|term
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|peek
decl_stmt|;
name|int
name|outer
init|=
operator|(
name|PL_rsfp
operator|&&
operator|!
operator|(
name|PL_lex_inwhat
operator|==
name|OP_SCALAR
operator|)
operator|)
decl_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|outer
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|peek
operator|=
name|s
init|;
operator|*
name|peek
operator|==
literal|' '
operator|||
operator|*
name|peek
operator|==
literal|'\t'
condition|;
name|peek
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|peek
operator|&&
name|strchr
argument_list|(
literal|"`'\""
argument_list|,
operator|*
name|peek
argument_list|)
condition|)
block|{
name|s
operator|=
name|peek
expr_stmt|;
name|term
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|delimcpy
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|term
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|d
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|s
operator|++
operator|,
name|term
operator|=
literal|'\''
expr_stmt|;
else|else
name|term
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|deprecate
argument_list|(
literal|"bare<< to mean<<\"\""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|>=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|1
condition|)
name|croak
argument_list|(
literal|"Delimiter for here document is too long"
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|d
operator|-
name|PL_tokenbuf
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
name|d
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|char
modifier|*
name|olds
init|=
name|s
decl_stmt|;
name|s
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\r'
condition|)
block|{
comment|/* \015\013 on a mac? */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|PL_bufend
operator|=
name|d
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|PL_bufend
operator|-
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|olds
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|outer
operator|||
operator|!
operator|(
name|d
operator|=
name|ninstr
argument_list|(
name|s
argument_list|,
name|PL_bufend
argument_list|,
name|d
argument_list|,
name|d
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|herewas
operator|=
name|newSVpv
argument_list|(
name|s
argument_list|,
name|PL_bufend
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|--
operator|,
name|herewas
operator|=
name|newSVpv
argument_list|(
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
name|SvCUR
argument_list|(
name|herewas
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|NEWSV
argument_list|(
literal|87
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|tmpstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\''
condition|)
block|{
name|op_type
operator|=
name|OP_CONST
expr_stmt|;
name|SvIVX
argument_list|(
name|tmpstr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|term
operator|==
literal|'`'
condition|)
block|{
name|op_type
operator|=
name|OP_BACKTICK
expr_stmt|;
name|SvIVX
argument_list|(
name|tmpstr
argument_list|)
operator|=
literal|'\\'
expr_stmt|;
block|}
name|CLINE
expr_stmt|;
name|PL_multi_start
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|PL_multi_open
operator|=
name|PL_multi_close
operator|=
literal|'<'
expr_stmt|;
name|term
operator|=
operator|*
name|PL_tokenbuf
expr_stmt|;
if|if
condition|(
name|PL_lex_inwhat
operator|==
name|OP_SUBST
operator|&&
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|char
modifier|*
name|bufptr
init|=
name|PL_super_bufptr
decl_stmt|;
name|char
modifier|*
name|bufend
init|=
name|PL_super_bufend
decl_stmt|;
name|char
modifier|*
name|olds
init|=
name|s
operator|-
name|SvCUR
argument_list|(
name|herewas
argument_list|)
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|bufptr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|bufend
expr_stmt|;
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
operator|(
operator|*
name|s
operator|!=
name|term
operator|||
name|memNE
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_multi_start
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|sv_setpvn
argument_list|(
name|herewas
argument_list|,
name|bufptr
argument_list|,
name|d
operator|-
name|bufptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|sv_catpvn
argument_list|(
name|herewas
argument_list|,
name|s
argument_list|,
name|bufend
operator|-
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bufptr
argument_list|,
name|SvPVX
argument_list|(
name|herewas
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|olds
expr_stmt|;
goto|goto
name|retval
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|outer
condition|)
block|{
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
operator|&&
operator|(
operator|*
name|s
operator|!=
name|term
operator|||
name|memNE
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
name|PL_bufend
condition|)
block|{
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_multi_start
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
comment|/* the preceding stmt passes a newline */
name|sv_catpvn
argument_list|(
name|herewas
argument_list|,
name|s
argument_list|,
name|PL_bufend
operator|-
name|s
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|PL_linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* avoid "uninitialized" warning */
while|while
condition|(
name|s
operator|>=
name|PL_bufend
condition|)
block|{
comment|/* multiple line string? */
if|if
condition|(
operator|!
name|outer
operator|||
operator|!
operator|(
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_multi_start
expr_stmt|;
name|missingterm
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
block|}
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
if|if
condition|(
name|PL_bufend
operator|-
name|PL_linestart
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|PL_bufend
index|[
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|PL_bufend
operator|--
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_linestr
argument_list|,
name|PL_bufend
operator|-
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufend
operator|-
name|PL_linestart
operator|==
literal|1
operator|&&
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|PL_bufend
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|88
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|term
operator|&&
name|memEQ
argument_list|(
name|s
argument_list|,
name|PL_tokenbuf
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|s
operator|=
name|PL_bufend
operator|-
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
name|sv_catsv
argument_list|(
name|PL_linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|PL_bufend
expr_stmt|;
name|sv_catsv
argument_list|(
name|tmpstr
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|++
expr_stmt|;
name|retval
label|:
name|PL_multi_end
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|tmpstr
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|herewas
argument_list|)
expr_stmt|;
name|PL_lex_stuff
operator|=
name|tmpstr
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|op_type
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* scan_inputsymbol    takes: current position in input buffer    returns: new position in input buffer    side-effects: yylval and lex_op are set.     This code handles:<>		read from ARGV<FH> 	read from filehandle<pkg::FH>	read from package qualified filehandle<pkg'FH>	read from package qualified filehandle<$fh>	read from filehandle in $fh<*.h>	filename glob  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|scan_inputsymbol
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in buffer */
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
comment|/* start of temp holding space */
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
expr_stmt|;
comment|/* end of temp holding space */
name|s
operator|=
name|delimcpy
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|PL_bufend
argument_list|,
literal|'>'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* extract until> */
comment|/* die if we didn't have space for the contents of the<>,        or if it didn't end     */
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|PL_tokenbuf
condition|)
name|croak
argument_list|(
literal|"Excessively long<> operator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|PL_bufend
condition|)
name|croak
argument_list|(
literal|"Unterminated<> operator"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* check for<$fh>        Remember, only scalar variables are interpreted as filehandles by        this code.  Anything more complex (e.g.,<$fh{$num}>) will be        treated as a glob() call.        This code makes use of the fact that except for the $ at the front,        a scalar variable and a filehandle look the same.     */
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
condition|)
name|d
operator|++
expr_stmt|;
comment|/* allow<Pkg'VALUE> or<Pkg::VALUE> */
while|while
condition|(
operator|*
name|d
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'\''
operator|||
operator|*
name|d
operator|==
literal|':'
operator|)
condition|)
name|d
operator|++
expr_stmt|;
comment|/* If we've tried to read what we allow filehandles to look like, and        there's still text left, then it must be a glob() and not a getline.        Use scan_str to pull out the stuff between the<> and treat it        as nothing more than a string.     */
if|if
condition|(
name|d
operator|-
name|PL_tokenbuf
operator|!=
name|len
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|OP_GLOB
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|s
operator|=
name|scan_str
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|croak
argument_list|(
literal|"Glob not terminated"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
comment|/* we're in a filehandle read situation */
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
comment|/* turn<> into<ARGV> */
if|if
condition|(
operator|!
name|len
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"ARGV"
argument_list|)
expr_stmt|;
comment|/* if<$fh>, create the ops to turn the variable into a 	   filehandle 	*/
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
condition|)
block|{
name|I32
name|tmp
decl_stmt|;
comment|/* try to find it in the pad for this block, otherwise find 	       add symbol table ops 	    */
if|if
condition|(
operator|(
name|tmp
operator|=
name|pad_findmy
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|OP
modifier|*
name|o
init|=
name|newOP
argument_list|(
name|OP_PADSV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|tmp
expr_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
decl_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
literal|0
argument_list|,
name|newUNOP
argument_list|(
name|OP_RV2SV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* we created the ops in lex_op, so make yylval.ival a null op */
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
block|}
comment|/* If it's none of the above, it must be a literal filehandle 	   (<Foo::BAR> or<FOO>) so build a simple readline OP */
else|else
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|d
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
decl_stmt|;
name|PL_lex_op
operator|=
operator|(
name|OP
operator|*
operator|)
name|newUNOP
argument_list|(
name|OP_READLINE
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|OP_NULL
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* scan_str    takes: start position in buffer    returns: position to continue reading from buffer    side-effects: multi_start, multi_close, lex_repl or lex_stuff, and    	updates the read buffer.     This subroutine pulls a string out of the input.  It is called for:    	q		single quotes		q(literal text) 	'		single quotes		'literal text' 	qq		double quotes		qq(interpolate $here please) 	"		double quotes		"interpolate $here please" 	qx		backticks		qx(/bin/ls -l) 	`		backticks		`/bin/ls -l` 	qw		quote words		@EXPORT_OK = qw( func() $spam ) 	m//		regexp match		m/this/ 	s///		regexp substitute	s/this/that/ 	tr///		string transliterate	tr/this/that/ 	y///		string transliterate	y/this/that/ 	($*@)		sub prototypes		sub foo ($)<>		readline or globs<FOO>,<>,<$fh>, or<*.c> 	    In most of these cases (all but<>, patterns and transliterate)    yylex() calls scan_str().  m// makes yylex() call scan_pat() which    calls scan_str().  s/// makes yylex() call scan_subst() which calls    scan_str().  tr/// and y/// make yylex() call scan_trans() which    calls scan_str().           It skips whitespace before the string starts, and treats the first    character as the delimiter.  If the delimiter is one of ([{< then    the corresponding "close" character )]}> is used as the closing    delimiter.  It allows quoting of delimiters, and if the string has    balanced delimiters ([{<>}]) it allows nesting.     The lexer always reads these strings into lex_stuff, except in the    case of the operators which take *two* arguments (s/// and tr///)    when it checks to see if lex_stuff is full (presumably with the 1st    arg to s or tr) and if so puts the string into lex_repl.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|scan_str
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
comment|/* scalar value: string */
name|char
modifier|*
name|tmps
decl_stmt|;
comment|/* temp string, used for delimiter matching */
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in the buffer */
specifier|register
name|char
name|term
decl_stmt|;
comment|/* terminating character */
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
comment|/* current position in the sv's data */
name|I32
name|brackets
init|=
literal|1
decl_stmt|;
comment|/* bracket nesting level */
comment|/* skip space before the delimiter */
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* mark where we are, in case we need to report errors */
name|CLINE
expr_stmt|;
comment|/* after skipping whitespace, the next character is the terminator */
name|term
operator|=
operator|*
name|s
expr_stmt|;
comment|/* mark where we are */
name|PL_multi_start
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|PL_multi_open
operator|=
name|term
expr_stmt|;
comment|/* find corresponding closing delimiter */
if|if
condition|(
name|term
operator|&&
operator|(
name|tmps
operator|=
name|strchr
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|tmps
index|[
literal|5
index|]
expr_stmt|;
name|PL_multi_close
operator|=
name|term
expr_stmt|;
comment|/* create a new SV to hold the contents.  87 is leak category, I'm        assuming.  79 is the SV's initial length.  What a random number. */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|87
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|term
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
comment|/* move past delimiter and try to read a complete string */
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* extend sv if need be */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
operator|(
name|PL_bufend
operator|-
name|s
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* set 'to' to the next character in the sv's string */
name|to
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* if open delimiter is the close delimiter read unbridle */
if|if
condition|(
name|PL_multi_open
operator|==
name|PL_multi_close
condition|)
block|{
for|for
control|(
init|;
name|s
operator|<
name|PL_bufend
condition|;
name|s
operator|++
operator|,
name|to
operator|++
control|)
block|{
comment|/* embedded newlines increment the current line number */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|PL_rsfp
condition|)
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
comment|/* handle quoted delimiters */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|PL_bufend
operator|&&
name|term
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
name|term
condition|)
name|s
operator|++
expr_stmt|;
comment|/* any other quotes are simply copied straight through */
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* terminate when run out of buffer (the for() condition), or 		   have found the terminator */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|term
condition|)
break|break;
operator|*
name|to
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
comment|/* if the terminator isn't the same as the start character (e.g., 	   matched brackets), we have to allow more in the quoting, and 	   be prepared for nested brackets. 	*/
else|else
block|{
comment|/* read until we run out of string, or we find the terminator */
for|for
control|(
init|;
name|s
operator|<
name|PL_bufend
condition|;
name|s
operator|++
operator|,
name|to
operator|++
control|)
block|{
comment|/* embedded newlines increment the line count */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|PL_rsfp
condition|)
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
comment|/* backslashes can escape the open or closing characters */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|PL_bufend
condition|)
block|{
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|PL_multi_open
operator|)
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|PL_multi_close
operator|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* allow nested opens and closes */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|PL_multi_close
operator|&&
operator|--
name|brackets
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|PL_multi_open
condition|)
name|brackets
operator|++
expr_stmt|;
operator|*
name|to
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
comment|/* terminate the copied string and update the sv's end-of-string */
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * this next chunk reads more into the buffer if we're not done yet 	 */
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
break|break;
comment|/* handle case where we are done yet :-) */
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
if|if
condition|(
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|to
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|to
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|to
index|[
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|to
operator|--
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|to
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|1
operator|&&
name|to
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|to
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
comment|/* if we're out of file, or a read fails, bail and reset the current 	   line marker so we can report where the unterminated string began 	*/
if|if
condition|(
operator|!
name|PL_rsfp
operator|||
operator|!
operator|(
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|s
operator|=
name|PL_linestart
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|sv_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_multi_start
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/* we read a line, so increment our line counter */
name|PL_curcop
operator|->
name|cop_line
operator|++
expr_stmt|;
comment|/* update debugger info */
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|88
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
comment|/* having changed the buffer, we must update PL_bufend */
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
block|}
comment|/* at this point, we have successfully read the delimited string */
name|PL_multi_end
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* if we allocated too much space, give some back */
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|5
operator|<
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/* decide whether this is the first or second quoted string we've read        for this op     */
if|if
condition|(
name|PL_lex_stuff
condition|)
name|PL_lex_repl
operator|=
name|sv
expr_stmt|;
else|else
name|PL_lex_stuff
operator|=
name|sv
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*   scan_num   takes: pointer to position in buffer   returns: pointer to new position in buffer   side-effects: builds ops for the constant in yylval.op    Read a number in any of the formats that Perl accepts:    0(x[0-7A-F]+)|([0-7]+)   [\d_]+(\.[\d_]*)?[Ee](\d+)    Underbars (_) are allowed in decimal numbers.  If -w is on,   underbars before a decimal point must be at three digit intervals.    Like most scan_ routines, it uses the PL_tokenbuf buffer to hold the   thing it reads.    If it reads a number without a decimal point or an exponent, it will   try converting the number to an integer and see if it can do so   without loss of precision. */
end_comment

begin_function
name|char
modifier|*
name|scan_num
parameter_list|(
name|char
modifier|*
name|start
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
comment|/* current position in buffer */
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
comment|/* destination in temp buffer */
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
comment|/* end of temp buffer */
name|I32
name|tryiv
decl_stmt|;
comment|/* used to see if it can be an int */
name|double
name|value
decl_stmt|;
comment|/* number read, as a double */
name|SV
modifier|*
name|sv
decl_stmt|;
comment|/* place to put the converted number */
name|I32
name|floatit
decl_stmt|;
comment|/* boolean: int or float? */
name|char
modifier|*
name|lastub
init|=
literal|0
decl_stmt|;
comment|/* position of last underbar */
specifier|static
name|char
name|number_too_long
index|[]
init|=
literal|"Number too long"
decl_stmt|;
comment|/* We use the first character to decide what type of number this is */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
name|croak
argument_list|(
literal|"panic: scan_num"
argument_list|)
expr_stmt|;
comment|/* if it starts with a 0, it could be an octal number, a decimal in        0.13 disguise, or a hexadecimal number.     */
case|case
literal|'0'
case|:
block|{
comment|/* variables: 	     u		holds the "number so far" 	     shift	the power of 2 of the base (hex == 4, octal == 3) 	     overflowed	was the number more than we can hold?  	     Shift is used when we add a digit.  It also serves as an "are 	     we in octal or hex?" indicator to disallow hex characters when 	     in octal mode. 	   */
name|UV
name|u
decl_stmt|;
name|I32
name|shift
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
comment|/* check for hex */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* check for a decimal in disguise */
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
goto|goto
name|decimal
goto|;
comment|/* so it must be octal */
else|else
name|shift
operator|=
literal|3
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
comment|/* read the rest of the octal number */
for|for
control|(
init|;
condition|;
control|)
block|{
name|UV
name|n
decl_stmt|,
name|b
decl_stmt|;
comment|/* n is used in the overflow test, b is the digit we're adding on */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* if we don't mention it, we're done */
default|default:
goto|goto
name|out
goto|;
comment|/* _ are ignored */
case|case
literal|'_'
case|:
name|s
operator|++
expr_stmt|;
break|break;
comment|/* 8 and 9 are not octal */
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
name|yyerror
argument_list|(
literal|"Illegal octal digit"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
comment|/* octal digits */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|b
operator|=
operator|*
name|s
operator|++
operator|&
literal|15
expr_stmt|;
comment|/* ASCII digit -> value of digit */
goto|goto
name|digit
goto|;
comment|/* hex digits */
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
comment|/* make sure they said 0x */
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
goto|goto
name|out
goto|;
name|b
operator|=
operator|(
operator|*
name|s
operator|++
operator|&
literal|7
operator|)
operator|+
literal|9
expr_stmt|;
comment|/* Prepare to put the digit we have onto the end 		       of the number so far.  We check for overflows. 		    */
name|digit
label|:
name|n
operator|=
name|u
operator|<<
name|shift
expr_stmt|;
comment|/* make room for the digit */
if|if
condition|(
operator|!
name|overflowed
operator|&&
operator|(
name|n
operator|>>
name|shift
operator|)
operator|!=
name|u
operator|&&
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_NEW_BINARY
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Integer overflow in %s number"
argument_list|,
operator|(
name|shift
operator|==
literal|4
operator|)
condition|?
literal|"hex"
else|:
literal|"octal"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
block|}
name|u
operator|=
name|n
operator||
name|b
expr_stmt|;
comment|/* add the digit to the end */
break|break;
block|}
block|}
comment|/* if we get here, we had success: make a scalar value from 	     the number. 	  */
name|out
label|:
name|sv
operator|=
name|NEWSV
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_NEW_BINARY
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|,
literal|"binary"
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*       handle decimal numbers.       we're also sent here when we read a 0 as the first digit     */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|decimal
label|:
name|d
operator|=
name|PL_tokenbuf
expr_stmt|;
name|e
operator|=
name|PL_tokenbuf
operator|+
sizeof|sizeof
name|PL_tokenbuf
operator|-
literal|6
expr_stmt|;
comment|/* room for various punctuation */
name|floatit
operator|=
name|FALSE
expr_stmt|;
comment|/* read next group of digits and _ and copy into d */
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
comment|/* skip underscores, checking for misplaced ones  	       if -w is on 	    */
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|lastub
operator|&&
name|s
operator|-
name|lastub
operator|!=
literal|3
condition|)
name|warn
argument_list|(
literal|"Misplaced _ in number"
argument_list|)
expr_stmt|;
name|lastub
operator|=
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* check for end of fixed-length buffer */
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|number_too_long
argument_list|)
expr_stmt|;
comment|/* if we're ok, copy the character */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* final misplaced underbar check */
if|if
condition|(
name|PL_dowarn
operator|&&
name|lastub
operator|&&
name|s
operator|-
name|lastub
operator|!=
literal|3
condition|)
name|warn
argument_list|(
literal|"Misplaced _ in number"
argument_list|)
expr_stmt|;
comment|/* read a decimal portion if there is one.  avoid 	   3..5 being interpreted as the number 3. followed 	   by .5 	*/
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|floatit
operator|=
name|TRUE
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* copy, ignoring underbars, until we run out of 	       digits.  Note: no misplaced underbar checks! 	    */
for|for
control|(
init|;
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|;
name|s
operator|++
control|)
block|{
comment|/* fixed length buffer check */
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|number_too_long
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'_'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
comment|/* read exponent part, if present */
if|if
condition|(
operator|*
name|s
operator|&&
name|strchr
argument_list|(
literal|"eE"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"+-0123456789"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|floatit
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* regardless of whether user said 3E5 or 3e5, use lower 'e' */
operator|*
name|d
operator|++
operator|=
literal|'e'
expr_stmt|;
comment|/* At least some Mach atof()s don't grok 'E' */
comment|/* allow positive or negative exponent */
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* read digits of exponent (no underbars :-) */
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|croak
argument_list|(
name|number_too_long
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/* terminate the string */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
comment|/* make an sv from the string */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset numeric locale in case we were earlier left in Swaziland */
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|value
operator|=
name|atof
argument_list|(
name|PL_tokenbuf
argument_list|)
expr_stmt|;
comment|/*  	   See if we can make do with an integer value without loss of 	   precision.  We use I_V to cast to an int, because some 	   compilers have issues.  Then we try casting it back and see 	   if it was the same.  We only do this if we know we 	   specifically read an integer.  	   Note: if floatit is true, then we don't need to do the 	   conversion at all. 	*/
name|tryiv
operator|=
name|I_V
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|floatit
operator|&&
operator|(
name|double
operator|)
name|tryiv
operator|==
name|value
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|tryiv
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatit
condition|?
operator|(
name|PL_hints
operator|&
name|HINT_NEW_FLOAT
operator|)
else|:
operator|(
name|PL_hints
operator|&
name|HINT_NEW_INTEGER
operator|)
condition|)
name|sv
operator|=
name|new_constant
argument_list|(
name|PL_tokenbuf
argument_list|,
name|d
operator|-
name|PL_tokenbuf
argument_list|,
operator|(
name|floatit
condition|?
literal|"float"
else|:
literal|"integer"
operator|)
argument_list|,
name|sv
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* make the op for the constant and return */
name|yylval
operator|.
name|opval
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|scan_formline
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|eol
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|SV
modifier|*
name|stuff
init|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|needargs
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|!
name|needargs
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|||
operator|*
name|s
operator|==
literal|'}'
condition|)
block|{
comment|/*SUPPRESS 530*/
ifdef|#
directive|ifdef
name|PERL_STRICT_CR
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|;
name|t
operator|++
control|)
empty_stmt|;
else|#
directive|else
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
operator|||
operator|*
name|t
operator|==
literal|'\r'
condition|;
name|t
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
operator|||
name|t
operator|==
name|PL_bufend
condition|)
break|break;
block|}
if|if
condition|(
name|PL_in_eval
operator|&&
operator|!
name|PL_rsfp
condition|)
block|{
name|eol
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
operator|++
condition|)
name|eol
operator|=
name|PL_bufend
expr_stmt|;
block|}
else|else
name|eol
operator|=
name|PL_bufend
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'#'
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
operator|<
name|eol
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'~'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'~'
operator|&&
name|SvCUR
argument_list|(
name|stuff
argument_list|)
condition|)
block|{
name|needargs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|enough
goto|;
comment|/* ~~ must be first line in formline */
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'@'
operator|||
operator|*
name|t
operator|==
literal|'^'
condition|)
name|needargs
operator|=
name|TRUE
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|stuff
argument_list|,
name|s
argument_list|,
name|eol
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|eol
expr_stmt|;
if|if
condition|(
name|PL_rsfp
condition|)
block|{
name|s
operator|=
name|filter_gets
argument_list|(
name|PL_linestr
argument_list|,
name|PL_rsfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_oldoldbufptr
operator|=
name|PL_oldbufptr
operator|=
name|PL_bufptr
operator|=
name|PL_linestart
operator|=
name|SvPVX
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_bufend
operator|=
name|PL_bufptr
operator|+
name|SvCUR
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
name|PL_bufptr
expr_stmt|;
name|yyerror
argument_list|(
literal|"Format not terminated"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|incline
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|enough
label|:
if|if
condition|(
name|SvCUR
argument_list|(
name|stuff
argument_list|)
condition|)
block|{
name|PL_expect
operator|=
name|XTERM
expr_stmt|;
if|if
condition|(
name|needargs
condition|)
block|{
name|PL_lex_state
operator|=
name|LEX_NORMAL
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|force_next
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
else|else
name|PL_lex_state
operator|=
name|LEX_FORMLINE
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|opval
operator|=
operator|(
name|OP
operator|*
operator|)
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|force_next
argument_list|(
name|THING
argument_list|)
expr_stmt|;
name|PL_nextval
index|[
name|PL_nexttoke
index|]
operator|.
name|ival
operator|=
name|OP_FORMLINE
expr_stmt|;
name|force_next
argument_list|(
name|LSTOP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SvREFCNT_dec
argument_list|(
name|stuff
argument_list|)
expr_stmt|;
name|PL_lex_formbrack
operator|=
literal|0
expr_stmt|;
name|PL_bufptr
operator|=
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|set_csh
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
operator|!
name|PL_cshlen
condition|)
name|PL_cshlen
operator|=
name|strlen
argument_list|(
name|PL_cshname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|I32
name|start_subparse
parameter_list|(
name|I32
name|is_format
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|oldsavestack_ix
init|=
name|PL_savestack_ix
decl_stmt|;
name|CV
modifier|*
name|outsidecv
init|=
name|PL_compcv
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
if|if
condition|(
name|PL_compcv
condition|)
block|{
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|PL_compcv
argument_list|)
operator|==
name|SVt_PVCV
argument_list|)
expr_stmt|;
block|}
name|save_I32
argument_list|(
operator|&
name|PL_subline
argument_list|)
expr_stmt|;
name|save_item
argument_list|(
name|PL_subname
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_padix
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_pad_reset_pending
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|is_format
condition|?
name|SVt_PVFM
else|:
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|PL_compcv
argument_list|)
operator||=
name|flags
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
name|PL_subline
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|outsidecv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|oldsavestack_ix
return|;
block|}
end_function

begin_function
name|int
name|yywarn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
operator|--
name|PL_error_count
expr_stmt|;
name|PL_in_eval
operator||=
literal|2
expr_stmt|;
name|yyerror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PL_in_eval
operator|&=
operator|~
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|yyerror
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|context
init|=
name|NULL
decl_stmt|;
name|int
name|contlen
init|=
operator|-
literal|1
decl_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|yychar
operator|||
operator|(
name|yychar
operator|==
literal|';'
operator|&&
operator|!
name|PL_rsfp
operator|)
condition|)
name|where
operator|=
literal|"at EOF"
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_bufptr
operator|>
name|PL_oldoldbufptr
operator|&&
name|PL_bufptr
operator|-
name|PL_oldoldbufptr
operator|<
literal|200
operator|&&
name|PL_oldoldbufptr
operator|!=
name|PL_oldbufptr
operator|&&
name|PL_oldbufptr
operator|!=
name|PL_bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_oldoldbufptr
argument_list|)
condition|)
name|PL_oldoldbufptr
operator|++
expr_stmt|;
name|context
operator|=
name|PL_oldoldbufptr
expr_stmt|;
name|contlen
operator|=
name|PL_bufptr
operator|-
name|PL_oldoldbufptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_bufptr
operator|>
name|PL_oldbufptr
operator|&&
name|PL_bufptr
operator|-
name|PL_oldbufptr
operator|<
literal|200
operator|&&
name|PL_oldbufptr
operator|!=
name|PL_bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_oldbufptr
argument_list|)
condition|)
name|PL_oldbufptr
operator|++
expr_stmt|;
name|context
operator|=
name|PL_oldbufptr
expr_stmt|;
name|contlen
operator|=
name|PL_bufptr
operator|-
name|PL_oldbufptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yychar
operator|>
literal|255
condition|)
name|where
operator|=
literal|"next token ???"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|yychar
operator|&
literal|127
operator|)
operator|==
literal|127
condition|)
block|{
if|if
condition|(
name|PL_lex_state
operator|==
name|LEX_NORMAL
operator|||
operator|(
name|PL_lex_state
operator|==
name|LEX_KNOWNEXT
operator|&&
name|PL_lex_defer
operator|==
name|LEX_NORMAL
operator|)
condition|)
name|where
operator|=
literal|"at end of line"
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_lex_inpat
condition|)
name|where
operator|=
literal|"within pattern"
expr_stmt|;
else|else
name|where
operator|=
literal|"within string"
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|where_sv
init|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
literal|"next char "
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|32
condition|)
name|sv_catpvf
argument_list|(
name|where_sv
argument_list|,
literal|"^%c"
argument_list|,
name|toCTRL
argument_list|(
name|yychar
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isPRINT_LC
argument_list|(
name|yychar
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|where_sv
argument_list|,
literal|"%c"
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
else|else
name|sv_catpvf
argument_list|(
name|where_sv
argument_list|,
literal|"\\%03o"
argument_list|,
name|yychar
operator|&
literal|255
argument_list|)
expr_stmt|;
name|where
operator|=
name|SvPVX
argument_list|(
name|where_sv
argument_list|)
expr_stmt|;
block|}
name|msg
operator|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|" at %_ line %ld, "
argument_list|,
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|"near \"%.*s\"\n"
argument_list|,
name|contlen
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|"%s\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_multi_start
operator|<
name|PL_multi_end
operator|&&
call|(
name|U32
call|)
argument_list|(
name|PL_curcop
operator|->
name|cop_line
operator|-
name|PL_multi_end
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|"  (Might be a runaway multi-line %c%c string starting on line %ld)\n"
argument_list|,
operator|(
name|int
operator|)
name|PL_multi_open
argument_list|,
operator|(
name|int
operator|)
name|PL_multi_close
argument_list|,
operator|(
name|long
operator|)
name|PL_multi_start
argument_list|)
expr_stmt|;
name|PL_multi_end
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|PL_in_eval
operator|&
literal|2
condition|)
name|warn
argument_list|(
literal|"%_"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_in_eval
condition|)
name|sv_catsv
argument_list|(
name|ERRSV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|PerlIO_write
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|PL_error_count
operator|>=
literal|10
condition|)
name|croak
argument_list|(
literal|"%_ has too many errors.\n"
argument_list|,
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_in_my
operator|=
literal|0
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

