begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    pp_ctl.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * Now far ahead the Road has gone,  * And I must follow, if I can,  * Pursuing it with eager feet,  * Until it joins some larger way  * Where many paths and errands meet.  * And whither then?  I cannot say.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_PP_CTL_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|WORD_ALIGN
value|sizeof(U16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOCATCH
parameter_list|(
name|o
parameter_list|)
value|((CATCH_GET == TRUE) ? docatch(o) : (o))
end_define

begin_function_decl
specifier|static
name|I32
name|sortcv
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|sortcv_stacked
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|sortcv_xsub
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|sv_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|sv_i_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|amagic_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|amagic_i_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|amagic_cmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|amagic_cmp_locale
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|run_user_filter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_function_decl
specifier|static
name|I32
name|sv_cmp_static
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|I32
name|sv_cmp_locale_static
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sv_cmp_static
value|Perl_sv_cmp
end_define

begin_define
define|#
directive|define
name|sv_cmp_locale_static
value|Perl_sv_cmp_locale
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_wantarray
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
switch|switch
condition|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
condition|)
block|{
case|case
name|G_ARRAY
case|:
name|RETPUSHYES
expr_stmt|;
case|case
name|G_SCALAR
case|:
name|RETPUSHNO
expr_stmt|;
default|default:
name|RETPUSHUNDEF
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcmaybe
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcreset
argument_list|)
end_macro

begin_block
block|{
comment|/* XXXX Should store the old value to allow for tie/overload - and        restore in regcomp, where marked with XXXX. */
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcomp
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|cLOGOP
operator|->
name|op_other
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|SV
modifier|*
name|tmpstr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
name|Null
argument_list|(
name|MAGIC
operator|*
argument_list|)
decl_stmt|;
name|tmpstr
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mg
condition|)
block|{
name|regexp
modifier|*
name|re
init|=
operator|(
name|regexp
operator|*
operator|)
name|mg
operator|->
name|mg_obj
decl_stmt|;
name|ReREFCNT_dec
argument_list|(
name|pm
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|ReREFCNT_inc
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|SvPV
argument_list|(
name|tmpstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Check against the last compiled regexp. */
if|if
condition|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|||
operator|!
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
operator|||
name|pm
operator|->
name|op_pmregexp
operator|->
name|prelen
operator|!=
name|len
operator|||
name|memNE
argument_list|(
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|,
name|t
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|op_pmregexp
condition|)
block|{
name|ReREFCNT_dec
argument_list|(
name|pm
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|Null
argument_list|(
name|REGEXP
operator|*
argument_list|)
expr_stmt|;
comment|/* crucial if regcomp aborts */
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
name|PL_reginterp_cnt
operator|=
name|I32_MAX
expr_stmt|;
comment|/* Mark as safe.  */
name|pm
operator|->
name|op_pmflags
operator|=
name|pm
operator|->
name|op_pmpermflags
expr_stmt|;
comment|/* reset case sensitivity */
if|if
condition|(
name|DO_UTF8
argument_list|(
name|tmpstr
argument_list|)
condition|)
name|pm
operator|->
name|op_pmdynflags
operator||=
name|PMdf_UTF8
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|CALLREGCOMP
argument_list|(
argument|aTHX_ t
argument_list|,
argument|t + len
argument_list|,
argument|pm
argument_list|)
expr_stmt|;
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
comment|/* XXXX Be extra paranoid - needed 					   inside tie/overload accessors.  */
block|}
block|}
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
if|if
condition|(
name|PL_tainting
condition|)
block|{
if|if
condition|(
name|PL_tainted
condition|)
name|pm
operator|->
name|op_pmdynflags
operator||=
name|PMdf_TAINTED
expr_stmt|;
else|else
name|pm
operator|->
name|op_pmdynflags
operator|&=
operator|~
name|PMdf_TAINTED
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|->
name|prelen
operator|&&
name|PL_curpm
condition|)
name|pm
operator|=
name|PL_curpm
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
literal|"\\s+"
argument_list|,
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|)
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_WHITE
expr_stmt|;
comment|/* XXX runtime compiled output needs to move to the pad */
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
condition|)
block|{
name|pm
operator|->
name|op_private
operator|&=
operator|~
name|OPpRUNTIME
expr_stmt|;
comment|/* no point compiling again */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
comment|/* XXX can't change the optree at runtime either */
name|cLOGOP
operator|->
name|op_first
operator|->
name|op_next
operator|=
name|PL_op
operator|->
name|op_next
expr_stmt|;
endif|#
directive|endif
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_substcont
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|cLOGOP
operator|->
name|op_other
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
init|=
operator|&
name|cxstack
index|[
name|cxstack_ix
index|]
decl_stmt|;
specifier|register
name|SV
modifier|*
name|dstr
init|=
name|cx
operator|->
name|sb_dstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|cx
operator|->
name|sb_s
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
init|=
name|cx
operator|->
name|sb_m
decl_stmt|;
name|char
modifier|*
name|orig
init|=
name|cx
operator|->
name|sb_orig
decl_stmt|;
specifier|register
name|REGEXP
modifier|*
name|rx
init|=
name|cx
operator|->
name|sb_rx
decl_stmt|;
name|rxres_restore
argument_list|(
operator|&
name|cx
operator|->
name|sb_rxres
argument_list|,
name|rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|->
name|sb_iters
operator|++
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|sb_iters
operator|>
name|cx
operator|->
name|sb_maxiters
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Substitution loop"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cx
operator|->
name|sb_rxtainted
operator|&
literal|2
operator|)
operator|&&
name|SvTAINTED
argument_list|(
name|TOPs
argument_list|)
condition|)
name|cx
operator|->
name|sb_rxtainted
operator||=
literal|2
expr_stmt|;
name|sv_catsv
argument_list|(
name|dstr
argument_list|,
name|POPs
argument_list|)
expr_stmt|;
comment|/* Are we done */
if|if
condition|(
name|cx
operator|->
name|sb_once
operator|||
operator|!
name|CALLREGEXEC
argument_list|(
argument|aTHX_ rx
argument_list|,
argument|s
argument_list|,
argument|cx->sb_strend
argument_list|,
argument|orig
argument_list|,
argument|s == m
argument_list|,
argument|cx->sb_targ
argument_list|,
argument|NULL
argument_list|,
argument|((cx->sb_rflags& REXEC_COPY_STR) 				      ? (REXEC_IGNOREPOS|REXEC_NOT_FIRST) 				      : (REXEC_COPY_STR|REXEC_IGNOREPOS|REXEC_NOT_FIRST))
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|targ
init|=
name|cx
operator|->
name|sb_targ
decl_stmt|;
name|bool
name|isutf8
decl_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|cx
operator|->
name|sb_strend
operator|-
name|s
argument_list|)
expr_stmt|;
name|cx
operator|->
name|sb_rxtainted
operator||=
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|targ
argument_list|)
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|targ
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|targ
argument_list|,
name|SvCUR
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|targ
argument_list|,
name|SvLEN
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|isutf8
operator|=
name|DO_UTF8
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_free
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|cx
operator|->
name|sb_rxtainted
operator|&
literal|1
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|sb_iters
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|isutf8
condition|)
name|SvUTF8_on
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|cx
operator|->
name|sb_rxtainted
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|cx
operator|->
name|sb_oldsave
argument_list|)
expr_stmt|;
name|POPSUBST
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|pm
operator|->
name|op_next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|rx
argument_list|)
operator|&&
name|rx
operator|->
name|subbeg
operator|!=
name|orig
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
name|cx
operator|->
name|sb_orig
operator|=
name|orig
operator|=
name|rx
operator|->
name|subbeg
expr_stmt|;
name|s
operator|=
name|orig
operator|+
operator|(
name|m
operator|-
name|s
operator|)
expr_stmt|;
name|cx
operator|->
name|sb_strend
operator|=
name|s
operator|+
operator|(
name|cx
operator|->
name|sb_strend
operator|-
name|m
operator|)
expr_stmt|;
block|}
name|cx
operator|->
name|sb_m
operator|=
name|m
operator|=
name|rx
operator|->
name|startp
index|[
literal|0
index|]
operator|+
name|orig
expr_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|cx
operator|->
name|sb_s
operator|=
name|rx
operator|->
name|endp
index|[
literal|0
index|]
operator|+
name|orig
expr_stmt|;
block|{
comment|/* Update the pos() information. */
name|SV
modifier|*
name|sv
init|=
name|cx
operator|->
name|sb_targ
decl_stmt|;
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|I32
name|i
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVMG
condition|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'g'
argument_list|)
operator|)
condition|)
block|{
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'g'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|m
operator|-
name|orig
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_pos_b2u
argument_list|(
name|sv
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
name|i
expr_stmt|;
block|}
name|cx
operator|->
name|sb_rxtainted
operator||=
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|rxres_save
argument_list|(
operator|&
name|cx
operator|->
name|sb_rxres
argument_list|,
name|rx
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|pm
operator|->
name|op_pmreplstart
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|Perl_rxres_save
parameter_list|(
name|pTHX_
name|void
modifier|*
modifier|*
name|rsp
parameter_list|,
name|REGEXP
modifier|*
name|rx
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
name|U32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|p
index|[
literal|1
index|]
operator|<
name|rx
operator|->
name|nparens
condition|)
block|{
name|i
operator|=
literal|6
operator|+
name|rx
operator|->
name|nparens
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|New
argument_list|(
literal|501
argument_list|,
name|p
argument_list|,
name|i
argument_list|,
name|UV
argument_list|)
expr_stmt|;
else|else
name|Renew
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|UV
argument_list|)
expr_stmt|;
operator|*
name|rsp
operator|=
operator|(
name|void
operator|*
operator|)
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|PTR2UV
argument_list|(
name|RX_MATCH_COPIED
argument_list|(
name|rx
argument_list|)
condition|?
name|rx
operator|->
name|subbeg
else|:
name|Nullch
argument_list|)
expr_stmt|;
name|RX_MATCH_COPIED_off
argument_list|(
name|rx
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rx
operator|->
name|nparens
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PTR2UV
argument_list|(
name|rx
operator|->
name|subbeg
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|sublen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|startp
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|endp
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_rxres_restore
parameter_list|(
name|pTHX_
name|void
modifier|*
modifier|*
name|rsp
parameter_list|,
name|REGEXP
modifier|*
name|rx
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
name|U32
name|i
decl_stmt|;
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|rx
argument_list|)
condition|)
name|Safefree
argument_list|(
name|rx
operator|->
name|subbeg
argument_list|)
expr_stmt|;
name|RX_MATCH_COPIED_set
argument_list|(
name|rx
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|rx
operator|->
name|nparens
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|rx
operator|->
name|subbeg
operator|=
name|INT2PTR
argument_list|(
name|char
operator|*
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|rx
operator|->
name|sublen
operator|=
call|(
name|I32
call|)
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
operator|++
name|i
control|)
block|{
name|rx
operator|->
name|startp
index|[
name|i
index|]
operator|=
call|(
name|I32
call|)
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|rx
operator|->
name|endp
index|[
name|i
index|]
operator|=
call|(
name|I32
call|)
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_rxres_free
parameter_list|(
name|pTHX_
name|void
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|Safefree
argument_list|(
name|INT2PTR
argument_list|(
name|char
operator|*
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|rsp
operator|=
name|Null
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_formline
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
name|tmpForm
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|U16
modifier|*
name|fpc
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|I32
name|arg
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|item
decl_stmt|;
name|I32
name|itemsize
decl_stmt|;
name|I32
name|fieldsize
decl_stmt|;
name|I32
name|lines
init|=
literal|0
decl_stmt|;
name|bool
name|chopspace
init|=
operator|(
name|strchr
argument_list|(
name|PL_chopset
argument_list|,
literal|' '
argument_list|)
operator|!=
name|Nullch
operator|)
decl_stmt|;
name|char
modifier|*
name|chophere
decl_stmt|;
name|char
modifier|*
name|linemark
decl_stmt|;
name|NV
name|value
decl_stmt|;
name|bool
name|gotsome
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|STRLEN
name|fudge
init|=
name|SvCUR
argument_list|(
name|tmpForm
argument_list|)
operator|*
operator|(
name|IN_BYTE
condition|?
literal|1
else|:
literal|3
operator|)
operator|+
literal|1
decl_stmt|;
name|bool
name|item_is_utf
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|SvMAGICAL
argument_list|(
name|tmpForm
argument_list|)
operator|||
operator|!
name|SvCOMPILED
argument_list|(
name|tmpForm
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|tmpForm
argument_list|)
condition|)
block|{
name|SvREADONLY_off
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
name|doparseform
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
block|}
else|else
name|doparseform
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
block|}
name|SvPV_force
argument_list|(
name|PL_formtarget
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvGROW
argument_list|(
name|PL_formtarget
argument_list|,
name|len
operator|+
name|fudge
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX SvCUR bad */
name|t
operator|+=
name|len
expr_stmt|;
name|f
operator|=
name|SvPV
argument_list|(
name|tmpForm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* need to jump to the next word */
name|s
operator|=
name|f
operator|+
name|len
operator|+
name|WORD_ALIGN
operator|-
name|SvCUR
argument_list|(
name|tmpForm
argument_list|)
operator|%
name|WORD_ALIGN
expr_stmt|;
name|fpc
operator|=
operator|(
name|U16
operator|*
operator|)
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DEBUG_f
argument_list|(
argument|{ 	    char *name =
literal|"???"
argument|; 	    arg = -
literal|1
argument|; 	    switch (*fpc) { 	    case FF_LITERAL:	arg = fpc[
literal|1
argument|]; name =
literal|"LITERAL"
argument|;	break; 	    case FF_BLANK:	arg = fpc[
literal|1
argument|]; name =
literal|"BLANK"
argument|;	break; 	    case FF_SKIP:	arg = fpc[
literal|1
argument|]; name =
literal|"SKIP"
argument|;	break; 	    case FF_FETCH:	arg = fpc[
literal|1
argument|]; name =
literal|"FETCH"
argument|;	break; 	    case FF_DECIMAL:	arg = fpc[
literal|1
argument|]; name =
literal|"DECIMAL"
argument|;	break;  	    case FF_CHECKNL:	name =
literal|"CHECKNL"
argument|;	break; 	    case FF_CHECKCHOP:	name =
literal|"CHECKCHOP"
argument|;	break; 	    case FF_SPACE:	name =
literal|"SPACE"
argument|;		break; 	    case FF_HALFSPACE:	name =
literal|"HALFSPACE"
argument|;	break; 	    case FF_ITEM:	name =
literal|"ITEM"
argument|;		break; 	    case FF_CHOP:	name =
literal|"CHOP"
argument|;		break; 	    case FF_LINEGLOB:	name =
literal|"LINEGLOB"
argument|;	break; 	    case FF_NEWLINE:	name =
literal|"NEWLINE"
argument|;	break; 	    case FF_MORE:	name =
literal|"MORE"
argument|;		break; 	    case FF_LINEMARK:	name =
literal|"LINEMARK"
argument|;	break; 	    case FF_END:	name =
literal|"END"
argument|;		break; 	    } 	    if (arg>=
literal|0
argument|) 		PerlIO_printf(Perl_debug_log,
literal|"%-16s%ld\n"
argument|, name, (long) arg); 	    else 		PerlIO_printf(Perl_debug_log,
literal|"%-16s\n"
argument|, name); 	}
argument_list|)
switch|switch
condition|(
operator|*
name|fpc
operator|++
condition|)
block|{
case|case
name|FF_LINEMARK
case|:
name|linemark
operator|=
name|t
expr_stmt|;
name|lines
operator|++
expr_stmt|;
name|gotsome
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FF_LITERAL
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
while|while
condition|(
name|arg
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
break|break;
case|case
name|FF_SKIP
case|:
name|f
operator|+=
operator|*
name|fpc
operator|++
expr_stmt|;
break|break;
case|case
name|FF_FETCH
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
name|f
operator|+=
name|arg
expr_stmt|;
name|fieldsize
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
name|sv
operator|=
operator|*
operator|++
name|MARK
expr_stmt|;
else|else
block|{
name|sv
operator|=
operator|&
name|PL_sv_no
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Not enough format arguments"
argument_list|)
empty_stmt|;
block|}
break|break;
case|case
name|FF_CHECKNL
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|itemsize
operator|=
name|sv_len_utf8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemsize
operator|!=
name|len
condition|)
block|{
name|I32
name|itembytes
decl_stmt|;
if|if
condition|(
name|itemsize
operator|>
name|fieldsize
condition|)
block|{
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|itembytes
operator|=
name|itemsize
expr_stmt|;
name|sv_pos_u2b
argument_list|(
name|sv
argument_list|,
operator|&
name|itembytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|itembytes
operator|=
name|len
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itembytes
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
name|item_is_utf
operator|=
name|TRUE
expr_stmt|;
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
name|sv_pos_b2u
argument_list|(
name|sv
argument_list|,
operator|&
name|itemsize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|item_is_utf
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|itemsize
operator|>
name|fieldsize
condition|)
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
break|break;
case|case
name|FF_CHECKCHOP
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|DO_UTF8
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|itemsize
operator|=
name|sv_len_utf8
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemsize
operator|!=
name|len
condition|)
block|{
name|I32
name|itembytes
decl_stmt|;
if|if
condition|(
name|itemsize
operator|<=
name|fieldsize
condition|)
block|{
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
block|{
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|++
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|itembytes
operator|=
name|itemsize
expr_stmt|;
name|sv_pos_u2b
argument_list|(
name|sv
argument_list|,
operator|&
name|itembytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itembytes
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|||
operator|(
name|s
operator|==
name|send
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|chopspace
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|PL_chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|itemsize
operator|=
name|chophere
operator|-
name|item
expr_stmt|;
name|sv_pos_b2u
argument_list|(
name|sv
argument_list|,
operator|&
name|itemsize
argument_list|)
expr_stmt|;
block|}
name|item_is_utf
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|item_is_utf
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|itemsize
operator|<=
name|fieldsize
condition|)
block|{
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
block|{
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|++
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|||
operator|(
name|s
operator|==
name|send
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|chopspace
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|PL_chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|itemsize
operator|=
name|chophere
operator|-
name|item
expr_stmt|;
block|}
break|break;
case|case
name|FF_SPACE
case|:
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_HALFSPACE
case|:
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|arg
operator|/=
literal|2
expr_stmt|;
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_ITEM
case|:
name|arg
operator|=
name|itemsize
expr_stmt|;
name|s
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|item_is_utf
condition|)
block|{
while|while
condition|(
name|arg
operator|--
condition|)
block|{
if|if
condition|(
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
literal|7
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|6
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|4
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|&
operator|~
literal|31
operator|)
condition|)
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
break|break;
block|}
while|while
condition|(
name|arg
operator|--
condition|)
block|{
ifdef|#
directive|ifdef
name|EBCDIC
name|int
name|ch
init|=
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|iscntrl
argument_list|(
name|ch
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|&
operator|~
literal|31
operator|)
condition|)
endif|#
directive|endif
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_CHOP
case|:
name|s
operator|=
name|chophere
expr_stmt|;
if|if
condition|(
name|chopspace
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|sv_chop
argument_list|(
name|sv
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|FF_LINEGLOB
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
name|item_is_utf
operator|=
name|FALSE
expr_stmt|;
comment|/* XXX is this correct? */
if|if
condition|(
name|itemsize
condition|)
block|{
name|gotsome
operator|=
name|TRUE
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|send
condition|)
name|itemsize
operator|--
expr_stmt|;
else|else
name|lines
operator|++
expr_stmt|;
block|}
block|}
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_formtarget
argument_list|,
name|item
argument_list|,
name|itemsize
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|PL_formtarget
argument_list|,
name|SvCUR
argument_list|(
name|PL_formtarget
argument_list|)
operator|+
name|fudge
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_formtarget
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FF_DECIMAL
case|:
comment|/* If the field is marked with ^ and the value is undefined, 	       blank it out. */
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|&
literal|512
operator|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|arg
operator|=
name|fieldsize
expr_stmt|;
while|while
condition|(
name|arg
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
name|gotsome
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|SvNV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Formats aren't yet marked for locales, so assume "yes". */
block|{
name|STORE_NUMERIC_STANDARD_SET_LOCAL
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
if|if
condition|(
name|arg
operator|&
literal|256
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%#*.*"
name|PERL_PRIfldbl
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
operator|(
name|int
operator|)
name|arg
operator|&
literal|255
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%*.0"
name|PERL_PRIfldbl
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|arg
operator|&
literal|256
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%#*.*f"
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
operator|(
name|int
operator|)
name|arg
operator|&
literal|255
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%*.0f"
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|RESTORE_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
block|}
name|t
operator|+=
name|fieldsize
expr_stmt|;
break|break;
case|case
name|FF_NEWLINE
case|:
name|f
operator|++
expr_stmt|;
while|while
condition|(
name|t
operator|--
operator|>
name|linemark
operator|&&
operator|*
name|t
operator|==
literal|' '
condition|)
empty_stmt|;
name|t
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
name|FF_BLANK
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
if|if
condition|(
name|gotsome
condition|)
block|{
if|if
condition|(
name|arg
condition|)
block|{
comment|/* repeat until fields exhausted? */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|lines
operator|+=
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|==
literal|200
condition|)
block|{
name|arg
operator|=
name|t
operator|-
name|linemark
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|linemark
argument_list|,
name|linemark
operator|-
name|arg
argument_list|,
name|arg
argument_list|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Runaway format"
argument_list|)
expr_stmt|;
block|}
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|=
name|lines
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETURNOP
argument_list|(
name|cLISTOP
operator|->
name|op_first
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|linemark
expr_stmt|;
name|lines
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|FF_MORE
case|:
name|s
operator|=
name|chophere
expr_stmt|;
name|send
operator|=
name|item
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|chopspace
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|s
operator|<
name|send
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|s
operator|=
name|t
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
condition|)
block|{
while|while
condition|(
name|s
operator|>
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
operator|&&
name|isSPACE
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|s
operator|--
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
break|break;
case|case
name|FF_END
case|:
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|+=
name|lines
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_grepstart
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|src
decl_stmt|;
if|if
condition|(
name|PL_stack_base
operator|+
operator|*
name|PL_markstack_ptr
operator|==
name|SP
condition|)
block|{
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
if|if
condition|(
name|GIMME_V
operator|==
name|G_SCALAR
condition|)
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|PL_op
operator|->
name|op_next
operator|->
name|op_next
argument_list|)
expr_stmt|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
operator|*
name|PL_markstack_ptr
operator|+
literal|1
expr_stmt|;
name|pp_pushmark
argument_list|()
expr_stmt|;
comment|/* push dst */
name|pp_pushmark
argument_list|()
expr_stmt|;
comment|/* push src */
name|ENTER
expr_stmt|;
comment|/* enter outer scope */
name|SAVETMPS
expr_stmt|;
comment|/* SAVE_DEFSV does *not* suffice here for USE_THREADS */
name|SAVESPTR
argument_list|(
name|DEFSV
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
comment|/* enter inner scope */
name|SAVEVPTR
argument_list|(
name|PL_curpm
argument_list|)
expr_stmt|;
name|src
operator|=
name|PL_stack_base
index|[
operator|*
name|PL_markstack_ptr
index|]
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|src
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_MAPSTART
condition|)
name|pp_pushmark
argument_list|()
expr_stmt|;
comment|/* push top */
return|return
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|PL_op
operator|->
name|op_next
operator|)
operator|->
name|op_other
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_mapstart
argument_list|)
end_macro

begin_block
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"panic: mapstart"
argument_list|)
expr_stmt|;
comment|/* uses grepstart */
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_mapwhile
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|items
init|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
operator|*
name|PL_markstack_ptr
decl_stmt|;
comment|/* how many new items */
name|I32
name|count
decl_stmt|;
name|I32
name|shift
decl_stmt|;
name|SV
modifier|*
modifier|*
name|src
decl_stmt|;
name|SV
modifier|*
modifier|*
name|dst
decl_stmt|;
comment|/* first, move source pointer to the next item in the source list */
operator|++
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if there are new items, push them into the destination list */
if|if
condition|(
name|items
condition|)
block|{
comment|/* might need to make room back there first */
if|if
condition|(
name|items
operator|>
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
condition|)
block|{
comment|/* XXX this implementation is very pessimal because the stack 	     * is repeatedly extended for every set of items.  Is possible 	     * to do this without any stack extension or copying at all 	     * by maintaining a separate list over which the map iterates 	     * (like foreach does). --gsar */
comment|/* everything in the stack after the destination list moves 	     * towards the end the stack by the amount of room needed */
name|shift
operator|=
name|items
operator|-
operator|(
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
comment|/* items to shift up (accounting for the moved source pointer) */
name|count
operator|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
operator|(
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* This optimization is by Ben Tilly and it does 	     * things differently from what Sarathy (gsar) 	     * is describing.  The downside of this optimization is 	     * that leaves "holes" (uninitialized and hopefully unused areas) 	     * to the Perl stack, but on the other hand this 	     * shouldn't be a problem.  If Sarathy's idea gets 	     * implemented, this optimization should become 	     * irrelevant.  --jhi */
if|if
condition|(
name|shift
operator|<
name|count
condition|)
name|shift
operator|=
name|count
expr_stmt|;
comment|/* Avoid shifting too often --Ben Tilly */
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|src
operator|=
name|SP
expr_stmt|;
name|dst
operator|=
operator|(
name|SP
operator|+=
name|shift
operator|)
expr_stmt|;
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|+=
name|shift
expr_stmt|;
operator|*
name|PL_markstack_ptr
operator|+=
name|shift
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
comment|/* copy the new items down to the destination list */
name|dst
operator|=
name|PL_stack_base
operator|+
operator|(
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
operator|+=
name|items
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
operator|*
name|dst
operator|--
operator|=
name|SvTEMP
argument_list|(
name|TOPs
argument_list|)
condition|?
name|POPs
else|:
name|sv_mortalcopy
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
comment|/* exit inner scope */
comment|/* All done yet? */
if|if
condition|(
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|>
operator|*
name|PL_markstack_ptr
condition|)
block|{
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop top */
name|LEAVE
expr_stmt|;
comment|/* exit outer scope */
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop src */
name|items
operator|=
operator|--
operator|*
name|PL_markstack_ptr
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop dst */
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|dTARGET
expr_stmt|;
name|XPUSHi
argument_list|(
name|items
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|SP
operator|+=
name|items
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|src
decl_stmt|;
name|ENTER
expr_stmt|;
comment|/* enter inner scope */
name|SAVEVPTR
argument_list|(
name|PL_curpm
argument_list|)
expr_stmt|;
comment|/* set $_ to the new source item */
name|src
operator|=
name|PL_stack_base
index|[
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|src
expr_stmt|;
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_sort
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|up
decl_stmt|;
name|SV
modifier|*
modifier|*
name|myorigmark
init|=
name|ORIGMARK
decl_stmt|;
specifier|register
name|I32
name|max
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME
decl_stmt|;
name|OP
modifier|*
name|nextop
init|=
name|PL_op
operator|->
name|op_next
decl_stmt|;
name|I32
name|overloading
init|=
literal|0
decl_stmt|;
name|bool
name|hasargs
init|=
name|FALSE
decl_stmt|;
name|I32
name|is_xsub
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|ENTER
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_sortcop
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOP
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* pass pushmark */
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* pass rv2gv */
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* pass leave */
name|PL_sortcop
operator|=
name|kid
operator|->
name|op_next
expr_stmt|;
name|stash
operator|=
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cv
operator|=
name|sv_2cv
argument_list|(
operator|*
operator|++
name|MARK
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|proto
init|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|&&
name|strEQ
argument_list|(
name|proto
argument_list|,
literal|"$$"
argument_list|)
condition|)
block|{
name|hasargs
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|cv
operator|&&
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cv
operator|&&
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|is_xsub
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gv
condition|)
block|{
name|SV
modifier|*
name|tmpstr
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"Undefined sort subroutine \"%s\" called"
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Undefined subroutine in sort"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_xsub
condition|)
name|PL_sortcop
operator|=
operator|(
name|OP
operator|*
operator|)
name|cv
expr_stmt|;
else|else
block|{
name|PL_sortcop
operator|=
name|CvSTART
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_ppaddr
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|PL_sortcop
operator|=
name|Nullop
expr_stmt|;
name|stash
operator|=
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
name|up
operator|=
name|myorigmark
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
comment|/* This may or may not shift down one here. */
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|(
operator|*
name|up
operator|=
operator|*
operator|++
name|MARK
operator|)
condition|)
block|{
comment|/* Weed out nulls. */
name|SvTEMP_off
argument_list|(
operator|*
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_sortcop
operator|&&
operator|!
name|SvPOK
argument_list|(
operator|*
name|up
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
operator|*
name|up
argument_list|)
condition|)
name|overloading
operator|=
literal|1
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sv_2pv
argument_list|(
operator|*
name|up
argument_list|,
operator|&
name|n_a
argument_list|)
expr_stmt|;
block|}
name|up
operator|++
expr_stmt|;
block|}
block|}
name|max
operator|=
operator|--
name|up
operator|-
name|myorigmark
expr_stmt|;
if|if
condition|(
name|PL_sortcop
condition|)
block|{
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|SAVETMPS
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_SORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasargs
operator|&&
operator|!
name|is_xsub
condition|)
block|{
if|if
condition|(
name|PL_sortstash
operator|!=
name|stash
operator|||
operator|!
name|PL_firstgv
operator|||
operator|!
name|PL_secondgv
condition|)
block|{
name|SAVESPTR
argument_list|(
name|PL_firstgv
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_secondgv
argument_list|)
expr_stmt|;
name|PL_firstgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"a"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|PL_secondgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"b"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|PL_sortstash
operator|=
name|stash
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_lock
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_firstgv
argument_list|)
expr_stmt|;
name|sv_lock
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_secondgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|PL_firstgv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|PL_secondgv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_NULL
argument_list|,
name|PL_stack_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
block|{
name|cx
operator|->
name|cx_type
operator|=
name|CXt_SUB
expr_stmt|;
name|cx
operator|->
name|blk_gimme
operator|=
name|G_SCALAR
expr_stmt|;
name|PUSHSUB
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
comment|/* in preparation for POPSUB */
block|}
name|PL_sortcxix
operator|=
name|cxstack_ix
expr_stmt|;
if|if
condition|(
name|hasargs
operator|&&
operator|!
name|is_xsub
condition|)
block|{
comment|/* This is mostly copied from pp_entersub */
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|cx
operator|->
name|blk_sub
operator|.
name|oldcurpad
operator|=
name|PL_curpad
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
operator|=
name|av
expr_stmt|;
block|}
name|qsortsv
argument_list|(
operator|(
name|myorigmark
operator|+
literal|1
operator|)
argument_list|,
name|max
argument_list|,
name|is_xsub
condition|?
name|sortcv_xsub
else|:
name|hasargs
condition|?
name|sortcv_stacked
else|:
name|sortcv
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|=
name|newsp
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|MEXTEND
argument_list|(
name|SP
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Can't afford stack realloc on signal. */
name|qsortsv
argument_list|(
name|ORIGMARK
operator|+
literal|1
argument_list|,
name|max
argument_list|,
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpSORT_NUMERIC
operator|)
condition|?
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpSORT_INTEGER
operator|)
condition|?
operator|(
name|overloading
condition|?
name|amagic_i_ncmp
else|:
name|sv_i_ncmp
operator|)
else|:
operator|(
name|overloading
condition|?
name|amagic_ncmp
else|:
name|sv_ncmp
operator|)
operator|)
else|:
operator|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
operator|(
name|overloading
condition|?
name|amagic_cmp_locale
else|:
name|sv_cmp_locale_static
operator|)
else|:
operator|(
name|overloading
condition|?
name|amagic_cmp
else|:
name|sv_cmp_static
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpSORT_REVERSE
condition|)
block|{
name|SV
modifier|*
modifier|*
name|p
init|=
name|ORIGMARK
operator|+
literal|1
decl_stmt|;
name|SV
modifier|*
modifier|*
name|q
init|=
name|ORIGMARK
operator|+
name|max
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|SV
modifier|*
name|tmp
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
name|LEAVE
expr_stmt|;
name|PL_stack_sp
operator|=
name|ORIGMARK
operator|+
name|max
expr_stmt|;
return|return
name|nextop
return|;
block|}
end_block

begin_comment
comment|/* Range stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_range
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
return|return
name|NORMAL
return|;
if|if
condition|(
name|SvTRUEx
argument_list|(
name|PAD_SV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
condition|)
return|return
name|cLOGOP
operator|->
name|op_other
return|;
else|else
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_flip
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|RETURNOP
argument_list|(
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|targ
init|=
name|PAD_SV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
decl_stmt|;
name|int
name|flip
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpFLIP_LINENUM
condition|)
block|{
name|struct
name|io
modifier|*
name|gp_io
decl_stmt|;
name|flip
operator|=
name|PL_last_in_gv
operator|&&
operator|(
name|gp_io
operator|=
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
operator|)
operator|&&
name|SvIV
argument_list|(
name|sv
argument_list|)
operator|==
operator|(
name|IV
operator|)
name|IoLINES
argument_list|(
name|gp_io
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flip
operator|=
name|SvTRUE
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flip
condition|)
block|{
name|sv_setiv
argument_list|(
name|PAD_SV
argument_list|(
name|cUNOP
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|sv_setiv
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|sv_setiv
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|--
expr_stmt|;
name|RETURNOP
argument_list|(
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
block|}
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_flop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|dPOPPOPssrl
expr_stmt|;
specifier|register
name|I32
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|max
decl_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|left
argument_list|)
condition|)
name|mg_get
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|right
argument_list|)
condition|)
name|mg_get
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|left
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|right
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|right
argument_list|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|left
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|left
argument_list|)
operator|!=
literal|'0'
operator|&&
name|looks_like_number
argument_list|(
name|right
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|right
argument_list|)
operator|!=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|SvNV
argument_list|(
name|left
argument_list|)
operator|<
name|IV_MIN
operator|||
name|SvNV
argument_list|(
name|right
argument_list|)
operator|>
name|IV_MAX
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Range iterator outside integer range"
argument_list|)
expr_stmt|;
name|i
operator|=
name|SvIV
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|max
operator|=
name|SvIV
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>=
name|i
condition|)
block|{
name|j
operator|=
name|max
operator|-
name|i
operator|+
literal|1
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|i
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|final
init|=
name|sv_mortalcopy
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|STRLEN
name|len
decl_stmt|,
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|final
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|<=
name|len
condition|)
block|{
name|XPUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|tmps
argument_list|)
condition|)
break|break;
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|targ
init|=
name|PAD_SV
argument_list|(
name|cUNOP
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
decl_stmt|;
name|sv_inc
argument_list|(
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpFLIP_LINENUM
operator|)
condition|?
operator|(
name|PL_last_in_gv
operator|&&
name|SvIV
argument_list|(
name|sv
argument_list|)
operator|==
operator|(
name|IV
operator|)
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
operator|)
else|:
name|SvTRUE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_setiv
argument_list|(
name|PAD_SV
argument_list|(
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|targ
argument_list|,
literal|"E0"
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Control. */
end_comment

begin_function
name|STATIC
name|I32
name|S_dopoptolabel
parameter_list|(
name|pTHX_
name|char
modifier|*
name|label
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cxstack_ix
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting substitution via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting subroutine via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_FORMAT
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting format via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting eval via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting pseudo-block via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|CXt_LOOP
case|:
if|if
condition|(
operator|!
name|cx
operator|->
name|blk_loop
operator|.
name|label
operator|||
name|strNE
argument_list|(
name|label
argument_list|,
name|cx
operator|->
name|blk_loop
operator|.
name|label
argument_list|)
condition|)
block|{
name|DEBUG_l
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"(Skipping label #%ld %s)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|cx
operator|->
name|blk_loop
operator|.
name|label
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG_l
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"(Found label #%ld %s)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|I32
name|Perl_dowantarray
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|I32
name|gimme
init|=
name|block_gimme
argument_list|()
decl_stmt|;
return|return
operator|(
name|gimme
operator|==
name|G_VOID
operator|)
condition|?
name|G_SCALAR
else|:
name|gimme
return|;
block|}
end_function

begin_function
name|I32
name|Perl_block_gimme
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|I32
name|cxix
decl_stmt|;
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
return|return
name|G_VOID
return|;
switch|switch
condition|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
condition|)
block|{
case|case
name|G_VOID
case|:
return|return
name|G_VOID
return|;
case|case
name|G_SCALAR
case|:
return|return
name|G_SCALAR
return|;
case|case
name|G_ARRAY
case|:
return|return
name|G_ARRAY
return|;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: bad gimme: %d\n"
argument_list|,
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|I32
name|Perl_is_lvalue_sub
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|I32
name|cxix
decl_stmt|;
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cxix
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* We should only be called from inside subs */
if|if
condition|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|lval
operator|&&
name|CvLVALUE
argument_list|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
argument_list|)
condition|)
return|return
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|lval
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_dopoptosub
parameter_list|(
name|pTHX_
name|I32
name|startingblock
parameter_list|)
block|{
return|return
name|dopoptosub_at
argument_list|(
name|cxstack
argument_list|,
name|startingblock
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_dopoptosub_at
parameter_list|(
name|pTHX_
name|PERL_CONTEXT
modifier|*
name|cxstk
parameter_list|,
name|I32
name|startingblock
parameter_list|)
block|{
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstk
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
name|CXt_EVAL
case|:
case|case
name|CXt_SUB
case|:
case|case
name|CXt_FORMAT
case|:
name|DEBUG_l
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"(Found sub #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_dopoptoeval
parameter_list|(
name|pTHX_
name|I32
name|startingblock
parameter_list|)
block|{
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
name|CXt_EVAL
case|:
name|DEBUG_l
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"(Found eval #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_dopoptoloop
parameter_list|(
name|pTHX_
name|I32
name|startingblock
parameter_list|)
block|{
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting substitution via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting subroutine via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_FORMAT
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting format via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting eval via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_EXITING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXITING
argument_list|,
literal|"Exiting pseudo-block via %s"
argument_list|,
argument|PL_op_name[PL_op->op_type]
argument_list|)
empty_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|CXt_LOOP
case|:
name|DEBUG_l
argument_list|(
name|Perl_deb
argument_list|(
name|aTHX_
literal|"(Found loop #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|Perl_dounwind
parameter_list|(
name|pTHX_
name|I32
name|cxix
parameter_list|)
block|{
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
decl_stmt|;
while|while
condition|(
name|cxstack_ix
operator|>
name|cxix
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|cx
operator|=
operator|&
name|cxstack
index|[
name|cxstack_ix
index|]
expr_stmt|;
name|DEBUG_l
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Unwinding block %ld, type %s\n"
argument_list|,
operator|(
name|long
operator|)
name|cxstack_ix
argument_list|,
name|PL_block_type
index|[
name|CxTYPE
argument_list|(
name|cx
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: we don't need to restore the base context info till the end. */
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
name|POPSUBST
argument_list|(
name|cx
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not break */
case|case
name|CXt_SUB
case|:
name|POPSUB
argument_list|(
name|cx
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|LEAVESUB
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_LOOP
case|:
name|POPLOOP
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
break|break;
case|case
name|CXt_FORMAT
case|:
name|POPFORMAT
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
block|}
name|cxstack_ix
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_qerror
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|PL_in_eval
condition|)
name|sv_catsv
argument_list|(
name|ERRSV
argument_list|,
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_errors
condition|)
name|sv_catsv
argument_list|(
name|PL_errors
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
name|Perl_warn
argument_list|(
name|aTHX_
literal|"%"
name|SVf
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|++
name|PL_error_count
expr_stmt|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_die_where
parameter_list|(
name|pTHX_
name|char
modifier|*
name|message
parameter_list|,
name|STRLEN
name|msglen
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
if|if
condition|(
name|message
condition|)
block|{
if|if
condition|(
name|PL_in_eval
operator|&
name|EVAL_KEEPERR
condition|)
block|{
specifier|static
name|char
name|prefix
index|[]
init|=
literal|"\t(in cleanup) "
decl_stmt|;
name|SV
modifier|*
name|err
init|=
name|ERRSV
decl_stmt|;
name|char
modifier|*
name|e
init|=
name|Nullch
decl_stmt|;
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|err
argument_list|)
condition|)
name|sv_setpv
argument_list|(
name|err
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvCUR
argument_list|(
name|err
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|+
name|msglen
operator|-
literal|1
condition|)
block|{
name|e
operator|=
name|SvPV
argument_list|(
name|err
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|e
operator|+=
name|n_a
operator|-
name|msglen
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|!=
operator|*
name|message
operator|||
name|strNE
argument_list|(
name|e
argument_list|,
name|message
argument_list|)
condition|)
name|e
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|SvGROW
argument_list|(
name|err
argument_list|,
name|SvCUR
argument_list|(
name|err
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|+
name|msglen
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|err
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|err
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
condition|)
block|{
name|STRLEN
name|start
init|=
name|SvCUR
argument_list|(
name|err
argument_list|)
operator|-
name|msglen
operator|-
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
decl_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
argument|SvPVX(err)+start
argument_list|)
empty_stmt|;
block|}
block|}
block|}
else|else
name|sv_setpvn
argument_list|(
name|ERRSV
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
else|else
name|message
operator|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cxix
operator|=
name|dopoptoeval
argument_list|(
name|cxstack_ix
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|PL_curstackinfo
operator|->
name|si_prev
condition|)
block|{
name|dounwind
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|>=
literal|0
condition|)
block|{
name|I32
name|optype
decl_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|!=
name|CXt_EVAL
condition|)
block|{
name|PerlIO_write
argument_list|(
name|Perl_error_log
argument_list|,
literal|"panic: die "
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|PerlIO_write
argument_list|(
name|Perl_error_log
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|PL_stack_sp
operator|=
name|newsp
expr_stmt|;
name|LEAVE
expr_stmt|;
comment|/* LEAVE could clobber PL_curcop (see save_re_context()) 	     * XXX it might be better to find a way to avoid messing with 	     * PL_curcop in save_re_context() instead, but this is a more 	     * minimal fix --GSAR */
name|PL_curcop
operator|=
name|cx
operator|->
name|blk_oldcop
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"%sCompilation failed in require"
argument_list|,
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Unknown error\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|pop_return
argument_list|()
return|;
block|}
block|}
if|if
condition|(
operator|!
name|message
condition|)
name|message
operator|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|USE_SFIO
comment|/* SFIO can really mess with your errno */
name|int
name|e
init|=
name|errno
decl_stmt|;
endif|#
directive|endif
name|PerlIO
modifier|*
name|serr
init|=
name|Perl_error_log
decl_stmt|;
name|PerlIO_write
argument_list|(
name|serr
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|serr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SFIO
name|errno
operator|=
name|e
expr_stmt|;
endif|#
directive|endif
block|}
name|my_failure_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_xor
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvTRUE
argument_list|(
name|left
argument_list|)
operator|!=
name|SvTRUE
argument_list|(
name|right
argument_list|)
condition|)
name|RETSETYES
expr_stmt|;
else|else
name|RETSETNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_andassign
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
operator|!
name|SvTRUE
argument_list|(
name|TOPs
argument_list|)
condition|)
name|RETURN
expr_stmt|;
else|else
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_orassign
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
if|if
condition|(
name|SvTRUE
argument_list|(
name|TOPs
argument_list|)
condition|)
name|RETURN
expr_stmt|;
else|else
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_caller
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|I32
name|cxix
init|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|ccstack
init|=
name|cxstack
decl_stmt|;
name|PERL_SI
modifier|*
name|top_si
init|=
name|PL_curstackinfo
decl_stmt|;
name|I32
name|dbcxix
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|char
modifier|*
name|stashname
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MAXARG
condition|)
name|count
operator|=
name|POPi
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* we may be in a higher stacklevel, so dig down deeper */
while|while
condition|(
name|cxix
operator|<
literal|0
operator|&&
name|top_si
operator|->
name|si_type
operator|!=
name|PERLSI_MAIN
condition|)
block|{
name|top_si
operator|=
name|top_si
operator|->
name|si_prev
expr_stmt|;
name|ccstack
operator|=
name|top_si
operator|->
name|si_cxstack
expr_stmt|;
name|cxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|top_si
operator|->
name|si_cxix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|PL_DBsub
operator|&&
name|cxix
operator|>=
literal|0
operator|&&
name|ccstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
operator|==
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|--
condition|)
break|break;
name|cxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|cxix
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cx
operator|=
operator|&
name|ccstack
index|[
name|cxix
index|]
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|||
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_FORMAT
condition|)
block|{
name|dbcxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|cxix
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the 	   field below is defined for any cx. */
if|if
condition|(
name|PL_DBsub
operator|&&
name|dbcxix
operator|>=
literal|0
operator|&&
name|ccstack
index|[
name|dbcxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
operator|==
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
condition|)
name|cx
operator|=
operator|&
name|ccstack
index|[
name|dbcxix
index|]
expr_stmt|;
block|}
name|stashname
operator|=
name|CopSTASHPV
argument_list|(
name|cx
operator|->
name|blk_oldcop
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
operator|!
name|stashname
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|dTARGET
expr_stmt|;
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|stashname
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stashname
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|stashname
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|CopFILE
argument_list|(
name|cx
operator|->
name|blk_oldcop
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|cx
operator|->
name|blk_oldcop
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MAXARG
condition|)
name|RETURN
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|||
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_FORMAT
condition|)
block|{
comment|/* So is ccstack[dbcxix]. */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|CvGV
argument_list|(
name|ccstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
argument_list|)
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|"(eval)"
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimme
operator|=
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_gimme
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|gimme
operator|&
name|G_ARRAY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
block|{
comment|/* eval STRING */
if|if
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
operator|==
name|OP_ENTEREVAL
condition|)
block|{
name|PUSHs
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|cur_text
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
block|}
comment|/* require */
elseif|else
if|if
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_namesv
condition|)
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_namesv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
block|}
comment|/* eval BLOCK (try blocks have old_namesv == 0) */
else|else
block|{
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|&&
name|CopSTASH_eq
argument_list|(
name|PL_curcop
argument_list|,
name|PL_debstash
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|ary
init|=
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
decl_stmt|;
name|int
name|off
init|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|ary
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PL_dbargs
condition|)
block|{
name|GV
modifier|*
name|tmpgv
decl_stmt|;
name|PL_dbargs
operator|=
name|GvAV
argument_list|(
name|gv_AVadd
argument_list|(
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"DB::args"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|tmpgv
argument_list|)
expr_stmt|;
name|AvREAL_off
argument_list|(
name|PL_dbargs
argument_list|)
expr_stmt|;
comment|/* XXX should be REIFY (see av.h) */
block|}
if|if
condition|(
name|AvMAX
argument_list|(
name|PL_dbargs
argument_list|)
operator|<
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
condition|)
name|av_extend
argument_list|(
name|PL_dbargs
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvALLOC
argument_list|(
name|ary
argument_list|)
argument_list|,
name|AvARRAY
argument_list|(
name|PL_dbargs
argument_list|)
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
operator|+
name|off
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|PL_dbargs
argument_list|)
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
expr_stmt|;
block|}
comment|/* XXX only hints propagated via op_private are currently      * visible (others are not easily accessible, since they      * use the global PL_hints) */
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_oldcop
operator|->
name|op_private
operator|&
name|HINT_PRIVATE_MASK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|SV
modifier|*
name|mask
decl_stmt|;
name|SV
modifier|*
name|old_warnings
init|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_warnings
decl_stmt|;
if|if
condition|(
name|old_warnings
operator|==
name|pWARN_NONE
operator|||
operator|(
name|old_warnings
operator|==
name|pWARN_STD
operator|&&
operator|(
name|PL_dowarn
operator|&
name|G_WARN_ON
operator|)
operator|==
literal|0
operator|)
condition|)
name|mask
operator|=
name|newSVpvn
argument_list|(
name|WARN_NONEstring
argument_list|,
name|WARNsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|old_warnings
operator|==
name|pWARN_ALL
operator|||
operator|(
name|old_warnings
operator|==
name|pWARN_STD
operator|&&
name|PL_dowarn
operator|&
name|G_WARN_ON
operator|)
condition|)
name|mask
operator|=
name|newSVpvn
argument_list|(
name|WARN_ALLstring
argument_list|,
name|WARNsize
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|newSVsv
argument_list|(
name|old_warnings
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_reset
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|tmps
operator|=
literal|""
expr_stmt|;
else|else
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|sv_reset
argument_list|(
name|tmps
argument_list|,
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lineseq
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_dbstate
argument_list|)
end_macro

begin_block
block|{
name|PL_curcop
operator|=
operator|(
name|COP
operator|*
operator|)
name|PL_op
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each statement is presumed innocent */
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
expr_stmt|;
name|FREETMPS
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|||
name|SvIV
argument_list|(
name|PL_DBsingle
argument_list|)
operator|||
name|SvIV
argument_list|(
name|PL_DBsignal
argument_list|)
operator|||
name|SvIV
argument_list|(
name|PL_DBtrace
argument_list|)
condition|)
block|{
name|dSP
expr_stmt|;
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|G_ARRAY
decl_stmt|;
name|I32
name|hasargs
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|gv
operator|=
name|PL_DBgv
expr_stmt|;
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"No DB::DB routine defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|>=
literal|1
operator|&&
operator|!
operator|(
name|PL_debug
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|)
condition|)
comment|/* don't do recursive DB::DB call */
return|return
name|NORMAL
return|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_debug
argument_list|)
expr_stmt|;
name|SAVESTACK_POS
argument_list|()
expr_stmt|;
name|PL_debug
operator|=
literal|0
expr_stmt|;
name|hasargs
operator|=
literal|0
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_SUB
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHSUB
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scope
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_enteriter
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|U32
name|cxtype
init|=
name|CXt_LOOP
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|void
modifier|*
name|iterdata
decl_stmt|;
endif|#
directive|endif
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|svp
operator|=
operator|&
name|THREADSV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
expr_stmt|;
comment|/* per-thread variable */
name|SAVEGENERICSV
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|PL_op
operator|->
name|op_targ
condition|)
block|{
ifndef|#
directive|ifndef
name|USE_ITHREADS
name|svp
operator|=
operator|&
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
expr_stmt|;
comment|/* "my" variable */
name|SAVESPTR
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
else|#
directive|else
name|SAVEPADSV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|iterdata
operator|=
operator|(
name|void
operator|*
operator|)
name|PL_op
operator|->
name|op_targ
expr_stmt|;
name|cxtype
operator||=
name|CXp_PADVAR
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|POPs
decl_stmt|;
name|svp
operator|=
operator|&
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
comment|/* symbol table variable */
name|SAVEGENERICSV
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|iterdata
operator|=
operator|(
name|void
operator|*
operator|)
name|gv
expr_stmt|;
endif|#
directive|endif
block|}
name|ENTER
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|cxtype
argument_list|,
name|SP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|PUSHLOOP
argument_list|(
name|cx
argument_list|,
name|iterdata
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUSHLOOP
argument_list|(
name|cx
argument_list|,
name|svp
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|!=
name|SVt_PVAV
condition|)
block|{
name|dPOPss
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|||
name|SvNIOKp
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|'0'
operator|&&
name|looks_like_number
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|!=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|<
name|IV_MIN
operator|||
name|SvNV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|>=
name|IV_MAX
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Range iterator outside integer range"
argument_list|)
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|iterix
operator|=
name|SvIV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|itermax
operator|=
name|SvIV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
expr_stmt|;
block|}
else|else
name|cx
operator|->
name|blk_loop
operator|.
name|iterlval
operator|=
name|newSVsv
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
operator|=
name|PL_curstack
expr_stmt|;
name|AvFILLp
argument_list|(
name|PL_curstack
argument_list|)
operator|=
name|SP
operator|-
name|PL_stack_base
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|iterix
operator|=
name|MARK
operator|-
name|PL_stack_base
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_enterloop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|ENTER
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_LOOP
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHLOOP
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_leaveloop
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|mark
operator|=
name|newsp
expr_stmt|;
name|newsp
operator|=
name|PL_stack_base
operator|+
name|cx
operator|->
name|blk_loop
operator|.
name|resetsp
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
empty_stmt|;
comment|/* do nothing */
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|mark
operator|<
name|SP
condition|)
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|mark
operator|<
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|SP
operator|=
name|newsp
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|POPLOOP
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* Stack values are safe: release loop vars ... */
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_return
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|bool
name|popsub2
init|=
name|FALSE
decl_stmt|;
name|bool
name|clear_errsv
init|=
name|FALSE
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|optype
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
condition|)
block|{
if|if
condition|(
name|cxstack_ix
operator|==
name|PL_sortcxix
operator|||
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
operator|<=
name|PL_sortcxix
condition|)
block|{
if|if
condition|(
name|cxstack_ix
operator|>
name|PL_sortcxix
condition|)
name|dounwind
argument_list|(
name|PL_sortcxix
argument_list|)
expr_stmt|;
name|AvARRAY
argument_list|(
name|PL_curstack
argument_list|)
index|[
literal|1
index|]
operator|=
operator|*
name|SP
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't return outside a subroutine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUB
case|:
name|popsub2
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
if|if
condition|(
operator|!
operator|(
name|PL_in_eval
operator|&
name|EVAL_KEEPERR
operator|)
condition|)
name|clear_errsv
operator|=
name|TRUE
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTRYBLOCK
argument_list|(
name|cx
argument_list|)
condition|)
break|break;
name|lex_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
operator|&&
operator|(
name|MARK
operator|==
name|SP
operator|||
operator|(
name|gimme
operator|==
name|G_SCALAR
operator|&&
operator|!
name|SvTRUE
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Unassume the success we assumed earlier. */
name|SV
modifier|*
name|nsv
init|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_namesv
decl_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|nsv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|nsv
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"%s did not return a true value"
argument_list|,
name|SvPVX
argument_list|(
name|nsv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CXt_FORMAT
case|:
name|POPFORMAT
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DIE
argument_list|(
name|aTHX_
literal|"panic: return"
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
if|if
condition|(
name|popsub2
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
operator|&&
name|CvDEPTH
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|SvTEMP
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
name|SvREFCNT_inc
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|sv_2mortal
argument_list|(
operator|*
name|newsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv
operator|=
name|SvREFCNT_inc
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
comment|/* FREETMPS could clobber it */
name|FREETMPS
expr_stmt|;
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
operator|(
name|SvTEMP
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
condition|?
operator|*
name|SP
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
operator|(
name|popsub2
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|MARK
argument_list|)
operator|)
condition|?
operator|*
name|MARK
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|PL_stack_sp
operator|=
name|newsp
expr_stmt|;
comment|/* Stack values are safe: */
if|if
condition|(
name|popsub2
condition|)
block|{
name|POPSUB
argument_list|(
name|cx
argument_list|,
name|sv
argument_list|)
expr_stmt|;
comment|/* release CV and @_ ... */
block|}
else|else
name|sv
operator|=
name|Nullsv
expr_stmt|;
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
name|LEAVESUB
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_errsv
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|pop_return
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_last
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|pop2
init|=
literal|0
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|OP
modifier|*
name|nextop
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't \"last\" outside a loop block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Label not found for \"last %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|mark
operator|=
name|newsp
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_LOOP
case|:
name|pop2
operator|=
name|CXt_LOOP
expr_stmt|;
name|newsp
operator|=
name|PL_stack_base
operator|+
name|cx
operator|->
name|blk_loop
operator|.
name|resetsp
expr_stmt|;
name|nextop
operator|=
name|cx
operator|->
name|blk_loop
operator|.
name|last_op
operator|->
name|op_next
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
name|pop2
operator|=
name|CXt_SUB
expr_stmt|;
name|nextop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|nextop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
break|break;
case|case
name|CXt_FORMAT
case|:
name|POPFORMAT
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|nextop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
break|break;
default|default:
name|DIE
argument_list|(
name|aTHX_
literal|"panic: last"
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
operator|*
operator|++
name|newsp
operator|=
operator|(
operator|(
name|pop2
operator|==
name|CXt_SUB
operator|)
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
condition|?
operator|*
name|SP
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
operator|(
operator|(
name|pop2
operator|==
name|CXt_SUB
operator|)
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|MARK
argument_list|)
operator|)
condition|?
operator|*
name|MARK
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|SP
operator|=
name|newsp
expr_stmt|;
name|PUTBACK
expr_stmt|;
comment|/* Stack values are safe: */
switch|switch
condition|(
name|pop2
condition|)
block|{
case|case
name|CXt_LOOP
case|:
name|POPLOOP
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* release loop vars ... */
name|LEAVE
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
name|POPSUB
argument_list|(
name|cx
argument_list|,
name|sv
argument_list|)
expr_stmt|;
comment|/* release CV and @_ ... */
break|break;
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
name|LEAVESUB
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|nextop
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_next
argument_list|)
end_macro

begin_block
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|inner
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't \"next\" outside a loop block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Label not found for \"next %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
comment|/* clear off anything above the scope we're re-entering, but      * save the rest until after a possible continue block */
name|inner
operator|=
name|PL_scopestack_ix
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_scopestack_ix
operator|<
name|inner
condition|)
name|leave_scope
argument_list|(
name|PL_scopestack
index|[
name|PL_scopestack_ix
index|]
argument_list|)
expr_stmt|;
return|return
name|cx
operator|->
name|blk_loop
operator|.
name|next_op
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_redo
argument_list|)
end_macro

begin_block
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|oldsave
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't \"redo\" outside a loop block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Label not found for \"redo %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
operator|-
literal|1
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
return|return
name|cx
operator|->
name|blk_loop
operator|.
name|redo_op
return|;
block|}
end_block

begin_function
name|STATIC
name|OP
modifier|*
name|S_dofindlabel
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|OP
modifier|*
modifier|*
name|opstack
parameter_list|,
name|OP
modifier|*
modifier|*
name|oplimit
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
modifier|*
name|ops
init|=
name|opstack
decl_stmt|;
specifier|static
name|char
name|too_deep
index|[]
init|=
literal|"Target of goto is too deeply nested"
decl_stmt|;
if|if
condition|(
name|ops
operator|>=
name|oplimit
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ too_deep
argument_list|)
empty_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVELOOP
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVETRY
condition|)
block|{
operator|*
name|ops
operator|++
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|ops
operator|>=
name|oplimit
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ too_deep
argument_list|)
empty_stmt|;
block|}
operator|*
name|ops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
comment|/* First try all the kids at this level, since that's likeliest. */
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
operator|)
operator|&&
name|kCOP
operator|->
name|cop_label
operator|&&
name|strEQ
argument_list|(
name|kCOP
operator|->
name|cop_label
argument_list|,
name|label
argument_list|)
condition|)
return|return
name|kid
return|;
block|}
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|==
name|PL_lastgotoprobe
condition|)
continue|continue;
if|if
condition|(
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
operator|)
operator|&&
operator|(
name|ops
operator|==
name|opstack
operator|||
operator|(
name|ops
index|[
operator|-
literal|1
index|]
operator|->
name|op_type
operator|!=
name|OP_NEXTSTATE
operator|&&
name|ops
index|[
operator|-
literal|1
index|]
operator|->
name|op_type
operator|!=
name|OP_DBSTATE
operator|)
operator|)
condition|)
operator|*
name|ops
operator|++
operator|=
name|kid
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|dofindlabel
argument_list|(
name|kid
argument_list|,
name|label
argument_list|,
name|ops
argument_list|,
name|oplimit
argument_list|)
operator|)
condition|)
return|return
name|o
return|;
block|}
block|}
operator|*
name|ops
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_dump
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_goto
argument_list|()
return|;
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_goto
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|OP
modifier|*
name|retop
init|=
literal|0
decl_stmt|;
name|I32
name|ix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
define|#
directive|define
name|GOTO_DEPTH
value|64
name|OP
modifier|*
name|enterops
index|[
name|GOTO_DEPTH
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|do_dump
init|=
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_DUMP
operator|)
decl_stmt|;
specifier|static
name|char
name|must_have_label
index|[]
init|=
literal|"goto must have label"
decl_stmt|;
name|label
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
comment|/* This egregious kludge implements goto&subroutine */
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
operator|(
name|CV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|I32
name|items
init|=
literal|0
decl_stmt|;
name|I32
name|oldsave
decl_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|&&
operator|!
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|CvGV
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|GV
modifier|*
name|autogv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
comment|/* autoloaded stub? */
if|if
condition|(
name|cv
operator|!=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
goto|goto
name|retry
goto|;
name|autogv
operator|=
name|gv_autoload4
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|autogv
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|autogv
argument_list|)
operator|)
condition|)
goto|goto
name|retry
goto|;
name|tmpstr
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"Goto undefined subroutine&%s"
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DIE
argument_list|(
name|aTHX_
literal|"Goto undefined subroutine"
argument_list|)
expr_stmt|;
block|}
comment|/* First do some returnish stuff. */
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't goto subroutine outside a subroutine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
operator|&&
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
operator|==
name|OP_ENTEREVAL
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't goto subroutine from an eval-string"
argument_list|)
expr_stmt|;
name|mark
operator|=
name|PL_stack_sp
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
comment|/* put @_ back onto stack */
name|AV
modifier|*
name|av
init|=
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
decl_stmt|;
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PL_stack_sp
operator|++
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
name|items
argument_list|)
expr_stmt|;
comment|/* @_ could have been extended. */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|PL_stack_sp
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|+=
name|items
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
name|SvREFCNT_dec
argument_list|(
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* abandon @_ if it got reified */
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sv_2mortal
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
comment|/* delay until return */
name|av
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_extend
argument_list|(
name|av
argument_list|,
name|items
operator|-
literal|1
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
operator|(
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
operator|=
name|av
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
comment|/* put GvAV(defgv) back onto stack */
name|AV
modifier|*
name|av
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|av
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PL_stack_sp
operator|++
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
name|items
argument_list|)
expr_stmt|;
comment|/* @_ could have been extended. */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|PL_stack_sp
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|+=
name|items
expr_stmt|;
block|}
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
operator|!
operator|(
name|CvDEPTH
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
operator|-
literal|1
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
comment|/* Now do some callish stuff. */
name|SAVETMPS
expr_stmt|;
if|if
condition|(
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PERL_XSUB_OLDSTYLE
if|if
condition|(
name|CvOLDSTYLE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|I32
function_decl|(
modifier|*
name|fp3
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
while|while
condition|(
name|SP
operator|>
name|mark
condition|)
block|{
name|SP
index|[
literal|1
index|]
operator|=
name|SP
index|[
literal|0
index|]
expr_stmt|;
name|SP
operator|--
expr_stmt|;
block|}
name|fp3
operator|=
operator|(
name|I32
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
operator|)
name|CvXSUB
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|items
operator|=
call|(
modifier|*
name|fp3
call|)
argument_list|(
name|CvXSUBANY
argument_list|(
name|cv
argument_list|)
operator|.
name|any_i32
argument_list|,
name|mark
operator|-
name|PL_stack_base
operator|+
literal|1
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|SP
operator|=
name|PL_stack_base
operator|+
name|items
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PERL_XSUB_OLDSTYLE */
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|PL_stack_sp
operator|--
expr_stmt|;
comment|/* There is no cv arg. */
comment|/* Push a mark for the start of arglist */
name|PUSHMARK
argument_list|(
name|mark
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
operator|(
operator|*
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
operator|(
name|aTHXo_
name|cv
operator|)
expr_stmt|;
comment|/* Pop the current context like a decent sub should */
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
comment|/* Do _not_ use PUTBACK, keep the XSUB's return stack! */
block|}
name|LEAVE
expr_stmt|;
return|return
name|pop_return
argument_list|()
return|;
block|}
else|else
block|{
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
block|{
name|PL_in_eval
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_in_eval
expr_stmt|;
name|PL_eval_root
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_eval_root
expr_stmt|;
name|cx
operator|->
name|cx_type
operator|=
name|CXt_SUB
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|=
literal|0
expr_stmt|;
block|}
name|cx
operator|->
name|blk_sub
operator|.
name|cv
operator|=
name|cv
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* save temporaries on recursion? */
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|==
literal|100
operator|&&
name|ckWARN
argument_list|(
name|WARN_RECURSION
argument_list|)
condition|)
name|sub_crush_depth
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|>
name|AvFILLp
argument_list|(
name|padlist
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|newpad
init|=
name|newAV
argument_list|()
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldpad
init|=
name|AvARRAY
argument_list|(
name|svp
index|[
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|I32
name|ix
init|=
name|AvFILLp
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|I32
name|names_fill
init|=
name|AvFILLp
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|svp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
name|names_fill
operator|>=
name|ix
operator|&&
name|svp
index|[
name|ix
index|]
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVX
argument_list|(
name|svp
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|SvFLAGS
argument_list|(
name|svp
index|[
name|ix
index|]
argument_list|)
operator|&
name|SVf_FAKE
operator|)
operator|||
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
comment|/* outer lexical or anon code */
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|oldpad
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* our own lexical */
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_PADGV
argument_list|(
name|oldpad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADCONST
argument_list|(
name|oldpad
index|[
name|ix
index|]
argument_list|)
condition|)
block|{
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|oldpad
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
name|AV
modifier|*
name|av
init|=
name|newAV
argument_list|()
decl_stmt|;
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|newpad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
block|}
name|av_store
argument_list|(
name|padlist
argument_list|,
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newpad
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|padlist
argument_list|)
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
operator|!
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
decl_stmt|;
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|items
condition|)
block|{
comment|/* Mark is at the end of the stack. */
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|items
expr_stmt|;
name|PUTBACK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
if|if
condition|(
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
endif|#
directive|endif
comment|/* USE_THREADS */
block|{
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|cx
operator|->
name|blk_sub
operator|.
name|oldcurpad
operator|=
name|PL_curpad
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
operator|=
name|av
expr_stmt|;
operator|++
name|mark
expr_stmt|;
if|if
condition|(
name|items
operator|>=
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
condition|)
block|{
name|ary
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|!=
name|ary
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
if|if
condition|(
name|items
operator|>=
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|items
operator|-
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|ary
argument_list|,
name|items
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
name|ary
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
block|}
name|Copy
argument_list|(
name|mark
argument_list|,
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|items
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
operator|!
name|AvREAL
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|mark
condition|)
name|SvTEMP_off
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|mark
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PERLDB_SUB
condition|)
block|{
comment|/* Checking curstash breaks DProf. */
comment|/* 		     * We do not care about using sv to call CV; 		     * it's for informational purposes only. 		     */
name|SV
modifier|*
name|sv
init|=
name|GvSV
argument_list|(
name|PL_DBsub
argument_list|)
decl_stmt|;
name|CV
modifier|*
name|gotocv
decl_stmt|;
if|if
condition|(
name|PERLDB_SUB_NN
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|PTR2IV
argument_list|(
name|cv
argument_list|)
expr_stmt|;
comment|/* Already upgraded, saved */
block|}
else|else
block|{
name|save_item
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PERLDB_GOTO
operator|&&
operator|(
name|gotocv
operator|=
name|get_cv
argument_list|(
literal|"DB::goto"
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|PL_stack_sp
argument_list|)
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gotocv
argument_list|,
name|G_SCALAR
operator||
name|G_NODEBUG
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|--
expr_stmt|;
block|}
block|}
name|RETURNOP
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|label
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|do_dump
operator|||
operator|*
name|label
operator|)
condition|)
name|DIE
argument_list|(
argument|aTHX_ must_have_label
argument_list|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
if|if
condition|(
operator|!
name|do_dump
condition|)
name|DIE
argument_list|(
argument|aTHX_ must_have_label
argument_list|)
empty_stmt|;
block|}
else|else
name|label
operator|=
name|cPVOP
operator|->
name|op_pv
expr_stmt|;
if|if
condition|(
name|label
operator|&&
operator|*
name|label
condition|)
block|{
name|OP
modifier|*
name|gotoprobe
init|=
literal|0
decl_stmt|;
comment|/* find label */
name|PL_lastgotoprobe
operator|=
literal|0
expr_stmt|;
operator|*
name|enterops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|cxstack_ix
init|;
name|ix
operator|>=
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|ix
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_EVAL
case|:
name|gotoprobe
operator|=
name|PL_eval_root
expr_stmt|;
comment|/* XXX not good for nested eval */
break|break;
case|case
name|CXt_LOOP
case|:
name|gotoprobe
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|op_sibling
expr_stmt|;
break|break;
case|case
name|CXt_SUBST
case|:
continue|continue;
case|case
name|CXt_BLOCK
case|:
if|if
condition|(
name|ix
condition|)
name|gotoprobe
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|op_sibling
expr_stmt|;
else|else
name|gotoprobe
operator|=
name|PL_main_root
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
condition|)
block|{
name|gotoprobe
operator|=
name|CvROOT
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|CXt_FORMAT
case|:
case|case
name|CXt_NULL
case|:
name|DIE
argument_list|(
name|aTHX_
literal|"Can't \"goto\" out of a pseudo block"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|ix
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"panic: goto"
argument_list|)
expr_stmt|;
name|gotoprobe
operator|=
name|PL_main_root
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotoprobe
condition|)
block|{
name|retop
operator|=
name|dofindlabel
argument_list|(
name|gotoprobe
argument_list|,
name|label
argument_list|,
name|enterops
argument_list|,
name|enterops
operator|+
name|GOTO_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|retop
condition|)
break|break;
block|}
name|PL_lastgotoprobe
operator|=
name|gotoprobe
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retop
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't find label %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* pop unwanted frames */
if|if
condition|(
name|ix
operator|<
name|cxstack_ix
condition|)
block|{
name|I32
name|oldsave
decl_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
name|dounwind
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
block|}
comment|/* push wanted frames */
if|if
condition|(
operator|*
name|enterops
operator|&&
name|enterops
index|[
literal|1
index|]
condition|)
block|{
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|enterops
index|[
name|ix
index|]
condition|;
name|ix
operator|++
control|)
block|{
name|PL_op
operator|=
name|enterops
index|[
name|ix
index|]
expr_stmt|;
comment|/* Eventually we may want to stack the needed arguments 		 * for each op.  For now, we punt on the hard ones. */
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_ENTERITER
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Can't \"goto\" into the middle of a foreach loop"
argument_list|)
expr_stmt|;
name|CALL_FPTR
function_decl|(
name|PL_op
operator|->
name|op_ppaddr
function_decl|)
parameter_list|(
name|aTHX
parameter_list|)
function_decl|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_dump
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|retop
condition|)
name|retop
operator|=
name|PL_main_start
expr_stmt|;
endif|#
directive|endif
name|PL_restartop
operator|=
name|retop
expr_stmt|;
name|PL_do_undump
operator|=
name|TRUE
expr_stmt|;
name|my_unexec
argument_list|()
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
comment|/* hmm, must be GNU unexec().. */
name|PL_do_undump
operator|=
name|FALSE
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|retop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_exit
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|I32
name|anum
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|anum
operator|=
name|SvIVx
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|anum
operator|==
literal|1
operator|&&
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpEXIT_VMSISH
operator|)
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|PL_exit_flags
operator||=
name|PERL_EXIT_EXPECTED
expr_stmt|;
name|my_exit
argument_list|(
name|anum
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_macro
name|PP
argument_list|(
argument|pp_nswitch
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
name|NV
name|value
init|=
name|SvNVx
argument_list|(
name|GvSV
argument_list|(
name|cCOP
operator|->
name|cop_gv
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|I32
name|match
init|=
name|I_32
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|NV
operator|)
name|match
operator|)
operator|>
name|value
condition|)
operator|--
name|match
expr_stmt|;
comment|/* was fractional--truncate other way */
block|}
name|match
operator|-=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_offset
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|>
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
condition|)
name|match
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
expr_stmt|;
name|PL_op
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_next
index|[
name|match
index|]
expr_stmt|;
name|RETURNOP
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_cswitch
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|I32
name|match
decl_stmt|;
if|if
condition|(
name|PL_multiline
condition|)
name|PL_op
operator|=
name|PL_op
operator|->
name|op_next
expr_stmt|;
comment|/* can't assume anything */
else|else
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|match
operator|=
operator|*
operator|(
name|SvPVx
argument_list|(
name|GvSV
argument_list|(
name|cCOP
operator|->
name|cop_gv
argument_list|)
argument_list|,
name|n_a
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
name|match
operator|-=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_offset
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|>
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
condition|)
name|match
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
expr_stmt|;
name|PL_op
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_next
index|[
name|match
index|]
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Eval. */
end_comment

begin_function
name|STATIC
name|void
name|S_save_lines
parameter_list|(
name|pTHX_
name|AV
modifier|*
name|array
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|I32
name|line
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|s
operator|&&
name|s
operator|<
name|send
condition|)
block|{
name|SV
modifier|*
name|tmpstr
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|tmpstr
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|++
expr_stmt|;
else|else
name|t
operator|=
name|send
expr_stmt|;
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|array
argument_list|,
name|line
operator|++
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
end_ifdef

begin_function
name|STATIC
name|void
modifier|*
name|S_docatch_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
return|return
name|docatch_body
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
modifier|*
name|S_docatch_body
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_docatch
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
specifier|volatile
name|PERL_SI
modifier|*
name|cursi
init|=
name|PL_curstackinfo
decl_stmt|;
name|dJMPENV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|assert
argument_list|(
name|CATCH_GET
operator|==
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_op
operator|=
name|o
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_docatch_body)
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|docatch_body
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
operator|&&
name|cursi
operator|==
name|PL_curstackinfo
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
comment|/* FALL THROUGH */
default|default:
name|JMPENV_POP
expr_stmt|;
name|PL_op
operator|=
name|oldop
expr_stmt|;
name|JMPENV_JUMP
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|JMPENV_POP
expr_stmt|;
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|Nullop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_sv_compile_2op
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|OP
modifier|*
modifier|*
name|startop
parameter_list|,
name|char
modifier|*
name|code
parameter_list|,
name|AV
modifier|*
modifier|*
name|avp
parameter_list|)
comment|/* sv Text to convert to OP tree. */
comment|/* startop op_free() this to undo. */
comment|/* code Short string id of the caller. */
block|{
name|dSP
expr_stmt|;
comment|/* Make POPBLOCK work. */
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
init|=
literal|0
decl_stmt|;
comment|/* SUSPECT - INITIALZE TO WHAT?  NI-S */
name|I32
name|optype
decl_stmt|;
name|OP
name|dummy
decl_stmt|;
name|OP
modifier|*
name|rop
decl_stmt|;
name|char
name|tbuf
index|[
name|TYPE_DIGITS
argument_list|(
name|long
argument_list|)
operator|+
literal|12
operator|+
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|tmpbuf
init|=
name|tbuf
decl_stmt|;
name|char
modifier|*
name|safestr
decl_stmt|;
name|ENTER
expr_stmt|;
name|lex_start
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SAVETMPS
expr_stmt|;
comment|/* switch to eval mode */
if|if
condition|(
name|PL_curcop
operator|==
operator|&
name|PL_compiling
condition|)
block|{
name|SAVECOPSTASH_FREE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopSTASH_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|PL_curstash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PERLDB_NAMEEVAL
operator|&&
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"_<(%.10seval %lu)[%s:%"
argument|IVdf
literal|"]"
argument_list|,
argument|code
argument_list|,
argument|(unsigned long)++PL_evalseq
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(IV)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
name|tmpbuf
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"_<(%.10s_eval %lu)"
argument_list|,
name|code
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|++
name|PL_evalseq
argument_list|)
expr_stmt|;
name|SAVECOPFILE_FREE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopFILE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|tmpbuf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up        deleting the eval's FILEGV from the stash before gv_check() runs        (i.e. before run-time proper). To work around the coredump that        ensues, we always turn GvMULTI_on for any globals that were        introduced within evals. See force_ident(). GSAR 96-10-12 */
name|safestr
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|SAVEDELETE
argument_list|(
name|PL_defstash
argument_list|,
name|safestr
argument_list|,
name|strlen
argument_list|(
name|safestr
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OP_IN_REGISTER
name|PL_opsave
operator|=
name|op
expr_stmt|;
else|#
directive|else
name|SAVEVPTR
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_hints
operator|=
literal|0
expr_stmt|;
name|PL_op
operator|=
operator|&
name|dummy
expr_stmt|;
name|PL_op
operator|->
name|op_type
operator|=
name|OP_ENTEREVAL
expr_stmt|;
name|PL_op
operator|->
name|op_flags
operator|=
literal|0
expr_stmt|;
comment|/* Avoid uninit warning. */
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_EVAL
operator||
operator|(
name|PL_curcop
operator|==
operator|&
name|PL_compiling
condition|?
literal|0
else|:
name|CXp_REAL
operator|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|Nullgv
argument_list|)
expr_stmt|;
name|rop
operator|=
name|doeval
argument_list|(
name|G_SCALAR
argument_list|,
name|startop
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
operator|(
operator|*
name|startop
operator|)
operator|->
name|op_type
operator|=
name|OP_NULL
expr_stmt|;
operator|(
operator|*
name|startop
operator|)
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
name|lex_end
argument_list|()
expr_stmt|;
operator|*
name|avp
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|==
operator|&
name|PL_compiling
condition|)
name|PL_compiling
operator|.
name|op_private
operator|=
name|PL_hints
expr_stmt|;
ifdef|#
directive|ifdef
name|OP_IN_REGISTER
name|op
operator|=
name|PL_opsave
expr_stmt|;
endif|#
directive|endif
return|return
name|rop
return|;
block|}
end_function

begin_comment
comment|/* With USE_THREADS, eval_owner must be held on entry to doeval */
end_comment

begin_function
name|STATIC
name|OP
modifier|*
name|S_doeval
parameter_list|(
name|pTHX_
name|int
name|gimme
parameter_list|,
name|OP
modifier|*
modifier|*
name|startop
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|OP
modifier|*
name|saveop
init|=
name|PL_op
decl_stmt|;
name|CV
modifier|*
name|caller
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|PL_in_eval
operator|=
operator|(
operator|(
name|saveop
operator|&&
name|saveop
operator|->
name|op_type
operator|==
name|OP_REQUIRE
operator|)
condition|?
operator|(
name|EVAL_INREQUIRE
operator||
operator|(
name|PL_in_eval
operator|&
name|EVAL_INEVAL
operator|)
operator|)
else|:
name|EVAL_INEVAL
operator|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
comment|/* set up a scratch pad */
name|SAVEI32
argument_list|(
name|PL_padix
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|caller
operator|=
name|PL_compcv
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cxstack_ix
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|PERL_CONTEXT
modifier|*
name|cx
init|=
operator|&
name|cxstack
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
break|break;
elseif|else
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|||
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_FORMAT
condition|)
block|{
name|caller
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|cv
expr_stmt|;
break|break;
block|}
block|}
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvEVAL_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
if|if
condition|(
operator|!
name|saveop
operator|||
operator|(
name|saveop
operator|->
name|op_type
operator|!=
name|OP_REQUIRE
operator|&&
name|saveop
operator|->
name|op_type
operator|!=
name|OP_DOFILE
operator|)
condition|)
block|{
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|caller
argument_list|)
expr_stmt|;
block|}
name|SAVEMORTALIZESV
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
comment|/* must remain until end of current statement */
comment|/* make sure we compile in the right package */
if|if
condition|(
name|CopSTASH_ne
argument_list|(
name|PL_curcop
argument_list|,
name|PL_curstash
argument_list|)
condition|)
block|{
name|SAVESPTR
argument_list|(
name|PL_curstash
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_error_count
argument_list|)
expr_stmt|;
comment|/* try to compile it */
name|PL_eval_root
operator|=
name|Nullop
expr_stmt|;
name|PL_error_count
operator|=
literal|0
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_curcop
operator|->
name|cop_arybase
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|newSVpvn
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveop
operator|&&
name|saveop
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
name|PL_in_eval
operator||=
name|EVAL_KEEPERR
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
operator|||
name|PL_error_count
operator|||
operator|!
name|PL_eval_root
condition|)
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
init|=
literal|0
decl_stmt|;
comment|/* Might be reset by POPEVAL. */
name|STRLEN
name|n_a
decl_stmt|;
name|PL_op
operator|=
name|saveop
expr_stmt|;
if|if
condition|(
name|PL_eval_root
condition|)
block|{
name|op_free
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
if|if
condition|(
operator|!
name|startop
condition|)
block|{
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
block|}
name|lex_end
argument_list|()
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|DIE
argument_list|(
name|aTHX_
literal|"%sCompilation failed in require"
argument_list|,
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Unknown error\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startop
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%sCompilation failed in regexp"
argument_list|,
operator|(
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Unknown error\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|startop
condition|)
block|{
operator|*
name|startop
operator|=
name|PL_eval_root
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
block|}
else|else
name|SAVEFREEOP
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|&
name|G_VOID
condition|)
name|scalarvoid
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|&
name|G_ARRAY
condition|)
name|list
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_eval
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Register with debugger: */
if|if
condition|(
name|PERLDB_INTER
operator|&&
name|saveop
operator|->
name|op_type
operator|==
name|OP_REQUIRE
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|get_cv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|CopFILEGV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* compiled okay, so do it */
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
name|PL_op
operator|=
name|saveop
expr_stmt|;
comment|/* The caller may need it. */
name|PL_lex_state
operator|=
name|LEX_NOTPARSING
expr_stmt|;
comment|/* $^S needs this. */
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|RETURNOP
argument_list|(
name|PL_eval_start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|PerlIO
modifier|*
name|S_doopen_pmc
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|STRLEN
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|PerlIO
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|namelen
operator|>
literal|3
operator|&&
name|strEQ
argument_list|(
name|name
operator|+
name|namelen
operator|-
literal|3
argument_list|,
literal|".pm"
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|pmcsv
init|=
name|Perl_newSVpvf
argument_list|(
name|aTHX_
literal|"%s%c"
argument_list|,
name|name
argument_list|,
literal|'c'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pmc
init|=
name|SvPV_nolen
argument_list|(
name|pmcsv
argument_list|)
decl_stmt|;
name|Stat_t
name|pmstat
decl_stmt|;
name|Stat_t
name|pmcstat
decl_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|pmc
argument_list|,
operator|&
name|pmcstat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|name
argument_list|,
operator|&
name|pmstat
argument_list|)
operator|<
literal|0
operator|||
name|pmstat
operator|.
name|st_mtime
operator|<
name|pmcstat
operator|.
name|st_mtime
condition|)
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|pmc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
name|SvREFCNT_dec
argument_list|(
name|pmcsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_require
argument_list|)
end_macro

begin_block
block|{
name|dSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|tryname
decl_stmt|;
name|SV
modifier|*
name|namesv
init|=
name|Nullsv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|gimme
init|=
name|G_SCALAR
decl_stmt|;
name|PerlIO
modifier|*
name|tryrsfp
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|int
name|filter_has_file
init|=
literal|0
decl_stmt|;
name|GV
modifier|*
name|filter_child_proc
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|filter_state
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|filter_sub
init|=
literal|0
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvNOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* require v5.6.1 */
name|UV
name|rev
init|=
literal|0
decl_stmt|,
name|ver
init|=
literal|0
decl_stmt|,
name|sver
init|=
literal|0
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|U8
modifier|*
name|s
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|U8
modifier|*
name|end
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|<
name|end
condition|)
block|{
name|rev
operator|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|end
operator|-
name|s
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|end
condition|)
block|{
name|ver
operator|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|end
operator|-
name|s
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|end
condition|)
name|sver
operator|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|end
operator|-
name|s
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PERL_REVISION
operator|<
name|rev
operator|||
operator|(
name|PERL_REVISION
operator|==
name|rev
operator|&&
operator|(
name|PERL_VERSION
operator|<
name|ver
operator|||
operator|(
name|PERL_VERSION
operator|==
name|ver
operator|&&
name|PERL_SUBVERSION
operator|<
name|sver
operator|)
operator|)
operator|)
condition|)
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Perl v%"
name|UVuf
literal|".%"
name|UVuf
literal|".%"
name|UVuf
literal|" required--this is only "
literal|"v%d.%d.%d, stopped"
argument_list|,
name|rev
argument_list|,
name|ver
argument_list|,
name|sver
argument_list|,
name|PERL_REVISION
argument_list|,
name|PERL_VERSION
argument_list|,
name|PERL_SUBVERSION
argument_list|)
expr_stmt|;
block|}
name|RETPUSHYES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* require 5.005_03 */
if|if
condition|(
operator|(
name|NV
operator|)
name|PERL_REVISION
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_VERSION
operator|/
operator|(
name|NV
operator|)
literal|1000
operator|)
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_SUBVERSION
operator|/
operator|(
name|NV
operator|)
literal|1000000
operator|)
operator|+
literal|0.00000099
operator|<
name|SvNV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|NV
name|nrev
init|=
name|SvNV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|UV
name|rev
init|=
operator|(
name|UV
operator|)
name|nrev
decl_stmt|;
name|NV
name|nver
init|=
operator|(
name|nrev
operator|-
name|rev
operator|)
operator|*
literal|1000
decl_stmt|;
name|UV
name|ver
init|=
call|(
name|UV
call|)
argument_list|(
name|nver
operator|+
literal|0.0009
argument_list|)
decl_stmt|;
name|NV
name|nsver
init|=
operator|(
name|nver
operator|-
name|ver
operator|)
operator|*
literal|1000
decl_stmt|;
name|UV
name|sver
init|=
call|(
name|UV
call|)
argument_list|(
name|nsver
operator|+
literal|0.0009
argument_list|)
decl_stmt|;
comment|/* help out with the "use 5.6" confusion */
if|if
condition|(
name|sver
operator|==
literal|0
operator|&&
operator|(
name|rev
operator|>
literal|5
operator|||
operator|(
name|rev
operator|==
literal|5
operator|&&
name|ver
operator|>=
literal|100
operator|)
operator|)
condition|)
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Perl v%"
name|UVuf
literal|".%"
name|UVuf
literal|".%"
name|UVuf
literal|" required--"
literal|"this is only v%d.%d.%d, stopped"
literal|" (did you mean v%"
name|UVuf
literal|".%"
name|UVuf
literal|".0?)"
argument_list|,
name|rev
argument_list|,
name|ver
argument_list|,
name|sver
argument_list|,
name|PERL_REVISION
argument_list|,
name|PERL_VERSION
argument_list|,
name|PERL_SUBVERSION
argument_list|,
name|rev
argument_list|,
name|ver
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DIE
argument_list|(
name|aTHX_
literal|"Perl v%"
name|UVuf
literal|".%"
name|UVuf
literal|".%"
name|UVuf
literal|" required--"
literal|"this is only v%d.%d.%d, stopped"
argument_list|,
name|rev
argument_list|,
name|ver
argument_list|,
name|sver
argument_list|,
name|PERL_REVISION
argument_list|,
name|PERL_VERSION
argument_list|,
name|PERL_SUBVERSION
argument_list|)
expr_stmt|;
block|}
block|}
name|RETPUSHYES
expr_stmt|;
block|}
block|}
name|name
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|&&
name|len
operator|>
literal|0
operator|&&
operator|*
name|name
operator|)
condition|)
name|DIE
argument_list|(
name|aTHX_
literal|"Null filename used"
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"require"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_REQUIRE
operator|&&
operator|(
name|svp
operator|=
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
name|RETPUSHYES
expr_stmt|;
comment|/* prepare to compile file */
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
if|if
condition|(
name|PERL_FILE_IS_ABSOLUTE
argument_list|(
name|name
argument_list|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|':'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|':'
operator|&&
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|tryname
operator|=
name|name
expr_stmt|;
name|tryrsfp
operator|=
name|doopen_pmc
argument_list|(
name|name
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
comment|/* We consider paths of the form :a:b ambiguous and interpret them first 	   as global then as local 	*/
if|if
condition|(
operator|!
name|tryrsfp
operator|&&
operator|*
name|name
operator|==
literal|':'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|':'
operator|&&
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
literal|':'
argument_list|)
condition|)
goto|goto
name|trylocal
goto|;
block|}
else|else
name|trylocal
label|:
block|{
else|#
directive|else
if|if
condition|(
name|PERL_FILE_IS_ABSOLUTE
argument_list|(
name|name
argument_list|)
operator|||
operator|(
operator|*
name|name
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
block|{
name|tryname
operator|=
name|name
expr_stmt|;
name|tryrsfp
operator|=
name|doopen_pmc
argument_list|(
name|name
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|AV
modifier|*
name|ar
init|=
name|GvAVn
argument_list|(
name|PL_incgv
argument_list|)
decl_stmt|;
name|I32
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
modifier|*
name|unixname
decl_stmt|;
if|if
condition|(
operator|(
name|unixname
operator|=
name|tounixspec
argument_list|(
name|name
argument_list|,
name|Nullch
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
endif|#
directive|endif
block|{
name|namesv
operator|=
name|NEWSV
argument_list|(
literal|806
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILL
argument_list|(
name|ar
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|SV
modifier|*
name|dirsv
init|=
operator|*
name|av_fetch
argument_list|(
name|ar
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|dirsv
argument_list|)
condition|)
block|{
name|int
name|count
decl_stmt|;
name|SV
modifier|*
name|loader
init|=
name|dirsv
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|loader
argument_list|)
argument_list|)
operator|==
name|SVt_PVAV
condition|)
block|{
name|loader
operator|=
operator|*
name|av_fetch
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|SvRV
argument_list|(
name|loader
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ namesv
argument_list|,
literal|"/loader/0x%"
argument|UVxf
literal|"/%s"
argument_list|,
argument|PTR2UV(SvANY(loader))
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|tryname
operator|=
name|SvPVX
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
name|tryrsfp
operator|=
literal|0
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|dirsv
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|sv_isobject
argument_list|(
name|loader
argument_list|)
condition|)
name|count
operator|=
name|call_method
argument_list|(
literal|"INC"
argument_list|,
name|G_ARRAY
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|call_sv
argument_list|(
name|loader
argument_list|,
name|G_ARRAY
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|arg
decl_stmt|;
name|SP
operator|-=
name|count
operator|-
literal|1
expr_stmt|;
name|arg
operator|=
name|SP
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|arg
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|arg
operator|=
name|SvRV
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|IO
modifier|*
name|io
init|=
name|GvIO
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|arg
argument_list|)
decl_stmt|;
operator|++
name|filter_has_file
expr_stmt|;
if|if
condition|(
name|io
condition|)
block|{
name|tryrsfp
operator|=
name|IoIFP
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_PIPE
condition|)
block|{
comment|/* reading from a child process doesn't 				       nest -- when returning from reading 				       the inner module, the outer one is 				       unreadable (closed?)  I've tried to 				       save the gv to manage the lifespan of 				       the pipe, but this didn't help. XXX */
name|filter_child_proc
operator|=
operator|(
name|GV
operator|*
operator|)
name|arg
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|filter_child_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|&&
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|!=
name|IoIFP
argument_list|(
name|io
argument_list|)
condition|)
block|{
name|PerlIO_close
argument_list|(
name|IoOFP
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IoIFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
name|IoOFP
argument_list|(
name|io
argument_list|)
operator|=
name|Nullfp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|count
condition|)
block|{
name|arg
operator|=
name|SP
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|arg
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|filter_sub
operator|=
name|arg
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|filter_sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|count
condition|)
block|{
name|filter_state
operator|=
name|SP
index|[
name|i
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|filter_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tryrsfp
operator|==
literal|0
condition|)
block|{
name|tryrsfp
operator|=
name|PerlIO_open
argument_list|(
literal|"/dev/null"
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PUTBACK
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|tryrsfp
condition|)
block|{
break|break;
block|}
name|filter_has_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filter_child_proc
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_child_proc
argument_list|)
expr_stmt|;
name|filter_child_proc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|filter_state
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_state
argument_list|)
expr_stmt|;
name|filter_state
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|filter_sub
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_sub
argument_list|)
expr_stmt|;
name|filter_sub
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|dir
init|=
name|SvPVx
argument_list|(
name|dirsv
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ namesv
argument_list|,
literal|"%s%s"
argument_list|,
argument|MacPerl_CanonDir(dir, buf)
argument_list|,
argument|name+(name[
literal|0
argument|] ==
literal|':'
argument|)
argument_list|)
empty_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
name|char
modifier|*
name|unixdir
decl_stmt|;
if|if
condition|(
operator|(
name|unixdir
operator|=
name|tounixpath
argument_list|(
name|dir
argument_list|,
name|Nullch
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
continue|continue;
name|sv_setpv
argument_list|(
name|namesv
argument_list|,
name|unixdir
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|namesv
argument_list|,
name|unixname
argument_list|)
expr_stmt|;
else|#
directive|else
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ namesv
argument_list|,
literal|"%s/%s"
argument_list|,
argument|dir
argument_list|,
argument|name
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|TAINT_PROPER
argument_list|(
literal|"require"
argument_list|)
expr_stmt|;
name|tryname
operator|=
name|SvPVX
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
block|{
comment|/* Convert slashes in the name part, but not the directory part, to colons */
name|char
modifier|*
name|colon
decl_stmt|;
for|for
control|(
name|colon
operator|=
name|tryname
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
init|;
name|colon
operator|=
name|strchr
argument_list|(
name|colon
argument_list|,
literal|'/'
argument_list|)
condition|;
control|)
operator|*
name|colon
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
endif|#
directive|endif
name|tryrsfp
operator|=
name|doopen_pmc
argument_list|(
name|tryname
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryrsfp
condition|)
block|{
if|if
condition|(
name|tryname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tryname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|tryname
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|SAVECOPFILE_FREE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopFILE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|tryrsfp
condition|?
name|tryname
else|:
name|name
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tryrsfp
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_REQUIRE
condition|)
block|{
name|char
modifier|*
name|msgstr
init|=
name|name
decl_stmt|;
if|if
condition|(
name|namesv
condition|)
block|{
comment|/* did we lookup @INC? */
name|SV
modifier|*
name|msg
init|=
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|msgstr
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|dirmsgsv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|ar
init|=
name|GvAVn
argument_list|(
name|PL_incgv
argument_list|)
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|sv_catpvn
argument_list|(
name|msg
argument_list|,
literal|" in @INC"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|".h "
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (change .h to .ph maybe?)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|".ph "
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (did you run h2ph?)"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (@INC contains:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILL
argument_list|(
name|ar
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|dir
init|=
name|SvPVx
argument_list|(
operator|*
name|av_fetch
argument_list|(
name|ar
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ dirmsgsv
argument_list|,
literal|" %s"
argument_list|,
argument|dir
argument_list|)
empty_stmt|;
name|sv_catsv
argument_list|(
name|msg
argument_list|,
name|dirmsgsv
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|msg
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|dirmsgsv
argument_list|)
expr_stmt|;
name|msgstr
operator|=
name|SvPV_nolen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|DIE
argument_list|(
name|aTHX_
literal|"Can't locate %s"
argument_list|,
name|msgstr
argument_list|)
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
else|else
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
comment|/* Assume success here to prevent recursive requirement. */
operator|(
name|void
operator|)
name|hv_store
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|newSVpv
argument_list|(
name|CopFILE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|lex_start
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEGENERICSV
argument_list|(
name|PL_rsfp_filters
argument_list|)
expr_stmt|;
name|PL_rsfp_filters
operator|=
name|Nullav
expr_stmt|;
name|PL_rsfp
operator|=
name|tryrsfp
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
literal|0
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&
name|G_WARN_ALL_ON
condition|)
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_dowarn
operator|&
name|G_WARN_ALL_OFF
condition|)
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_NONE
expr_stmt|;
else|else
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_STD
expr_stmt|;
if|if
condition|(
name|filter_sub
operator|||
name|filter_child_proc
condition|)
block|{
name|SV
modifier|*
name|datasv
init|=
name|filter_add
argument_list|(
name|run_user_filter
argument_list|,
name|Nullsv
argument_list|)
decl_stmt|;
name|IoLINES
argument_list|(
name|datasv
argument_list|)
operator|=
name|filter_has_file
expr_stmt|;
name|IoFMT_GV
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|filter_child_proc
expr_stmt|;
name|IoTOP_GV
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|filter_state
expr_stmt|;
name|IoBOTTOM_GV
argument_list|(
name|datasv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|filter_sub
expr_stmt|;
block|}
comment|/* switch to eval mode */
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_EVAL
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
name|name
argument_list|,
name|Nullgv
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_owner
operator|&&
name|PL_eval_owner
operator|!=
name|thr
condition|)
while|while
condition|(
name|PL_eval_owner
condition|)
name|COND_WAIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|,
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|DOCATCH
argument_list|(
name|doeval
argument_list|(
name|G_SCALAR
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
name|PP
argument_list|(
argument|pp_dofile
argument_list|)
block|{
return|return
name|pp_require
argument_list|()
return|;
block|}
name|PP
argument_list|(
argument|pp_entereval
argument_list|)
block|{
name|dSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|dPOPss
expr_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|,
name|was
init|=
name|PL_sub_generation
decl_stmt|;
name|char
name|tbuf
index|[
name|TYPE_DIGITS
argument_list|(
name|long
argument_list|)
operator|+
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|tmpbuf
init|=
name|tbuf
decl_stmt|;
name|char
modifier|*
name|safestr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|OP
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
operator|||
operator|!
name|len
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"eval"
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|lex_start
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SAVETMPS
expr_stmt|;
comment|/* switch to eval mode */
if|if
condition|(
name|PERLDB_NAMEEVAL
operator|&&
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"_<(eval %lu)[%s:%"
argument|IVdf
literal|"]"
argument_list|,
argument|(unsigned long)++PL_evalseq
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(IV)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
name|tmpbuf
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"_<(eval %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|++
name|PL_evalseq
argument_list|)
expr_stmt|;
name|SAVECOPFILE_FREE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopFILE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|tmpbuf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up        deleting the eval's FILEGV from the stash before gv_check() runs        (i.e. before run-time proper). To work around the coredump that        ensues, we always turn GvMULTI_on for any globals that were        introduced within evals. See force_ident(). GSAR 96-10-12 */
name|safestr
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|SAVEDELETE
argument_list|(
name|PL_defstash
argument_list|,
name|safestr
argument_list|,
name|strlen
argument_list|(
name|safestr
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
name|PL_op
operator|->
name|op_targ
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
if|if
condition|(
name|specialWARN
argument_list|(
name|PL_curcop
operator|->
name|cop_warnings
argument_list|)
condition|)
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|PL_curcop
operator|->
name|cop_warnings
expr_stmt|;
else|else
block|{
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|newSVsv
argument_list|(
name|PL_curcop
operator|->
name|cop_warnings
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
block|}
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
operator|(
name|CXt_EVAL
operator||
name|CXp_REAL
operator|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|Nullgv
argument_list|)
expr_stmt|;
comment|/* prepare to compile string */
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|save_lines
argument_list|(
name|CopFILEAV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_owner
operator|&&
name|PL_eval_owner
operator|!=
name|thr
condition|)
while|while
condition|(
name|PL_eval_owner
condition|)
name|COND_WAIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|,
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|ret
operator|=
name|doeval
argument_list|(
name|gimme
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_INTER
operator|&&
name|was
operator|!=
name|PL_sub_generation
comment|/* Some subs defined here. */
operator|&&
name|ret
operator|!=
name|PL_op
operator|->
name|op_next
condition|)
block|{
comment|/* Successive compilation. */
name|strcpy
argument_list|(
name|safestr
argument_list|,
literal|"_<(eval )"
argument_list|)
expr_stmt|;
comment|/* Anything fake and short. */
block|}
return|return
name|DOCATCH
argument_list|(
name|ret
argument_list|)
return|;
block|}
name|PP
argument_list|(
argument|pp_leaveeval
argument_list|)
block|{
name|dSP
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|OP
modifier|*
name|retop
decl_stmt|;
name|U8
name|save_flags
init|=
name|PL_op
operator|->
name|op_flags
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|retop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|MARK
operator|=
name|newsp
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|newsp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&
name|SVs_TEMP
condition|)
operator|*
name|MARK
operator|=
name|TOPs
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
name|sv_mortalcopy
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEXTEND
argument_list|(
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
else|else
block|{
comment|/* in case LEAVE wipes old return values */
for|for
control|(
name|mark
operator|=
name|newsp
operator|+
literal|1
init|;
name|mark
operator|<=
name|SP
condition|;
name|mark
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|mark
argument_list|)
operator|&
name|SVs_TEMP
operator|)
condition|)
block|{
operator|*
name|mark
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* Don't pop $1 et al till now */
ifdef|#
directive|ifdef
name|DEBUGGING
name|assert
argument_list|(
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lex_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
operator|&&
operator|!
operator|(
name|gimme
operator|==
name|G_SCALAR
condition|?
name|SvTRUE
argument_list|(
operator|*
name|SP
argument_list|)
else|:
name|SP
operator|>
name|newsp
operator|)
condition|)
block|{
comment|/* Unassume the success we assumed earlier. */
name|SV
modifier|*
name|nsv
init|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_namesv
decl_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|nsv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|nsv
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|retop
operator|=
name|Perl_die
argument_list|(
name|aTHX_
literal|"%s did not return a true value"
argument_list|,
name|SvPVX
argument_list|(
name|nsv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* die_where() did LEAVE, or we won't be here */
block|}
else|else
block|{
name|LEAVE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|save_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|retop
argument_list|)
expr_stmt|;
block|}
name|PP
argument_list|(
argument|pp_entertry
argument_list|)
block|{
name|dSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|push_return
argument_list|(
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
operator|(
name|CXt_EVAL
operator||
name|CXp_TRYBLOCK
operator|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|PL_op
expr_stmt|;
comment|/* Only needed so that goto works right. */
name|PL_in_eval
operator|=
name|EVAL_INEVAL
expr_stmt|;
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
return|return
name|DOCATCH
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
return|;
block|}
name|PP
argument_list|(
argument|pp_leavetry
argument_list|)
block|{
name|dSP
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|SP
operator|=
name|newsp
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|newsp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_TEMP
operator|)
condition|)
operator|*
name|MARK
operator|=
name|TOPs
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
name|sv_mortalcopy
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEXTEND
argument_list|(
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
else|else
block|{
comment|/* in case LEAVE wipes old return values */
for|for
control|(
name|mark
operator|=
name|newsp
operator|+
literal|1
init|;
name|mark
operator|<=
name|SP
condition|;
name|mark
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|mark
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_TEMP
operator|)
operator|)
condition|)
block|{
operator|*
name|mark
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* Don't pop $1 et al till now */
name|LEAVE
expr_stmt|;
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
name|STATIC
name|void
name|S_doparseform
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|base
decl_stmt|;
specifier|register
name|I32
name|skipspaces
init|=
literal|0
decl_stmt|;
name|bool
name|noblank
decl_stmt|;
name|bool
name|repeat
decl_stmt|;
name|bool
name|postspace
init|=
name|FALSE
decl_stmt|;
name|U16
modifier|*
name|fops
decl_stmt|;
specifier|register
name|U16
modifier|*
name|fpc
decl_stmt|;
name|U16
modifier|*
name|linepc
decl_stmt|;
specifier|register
name|I32
name|arg
decl_stmt|;
name|bool
name|ischop
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Null picture in formline"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|804
argument_list|,
name|fops
argument_list|,
operator|(
name|send
operator|-
name|s
operator|)
operator|*
literal|3
operator|+
literal|10
argument_list|,
name|U16
argument_list|)
expr_stmt|;
comment|/* Almost certainly too long... */
name|fpc
operator|=
name|fops
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|linepc
operator|=
name|fpc
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEMARK
expr_stmt|;
name|noblank
operator|=
name|repeat
operator|=
name|FALSE
expr_stmt|;
name|base
operator|=
name|s
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<=
name|send
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
default|default:
name|skipspaces
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'~'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
name|repeat
operator|=
name|TRUE
expr_stmt|;
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
block|}
name|noblank
operator|=
name|TRUE
expr_stmt|;
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|skipspaces
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
case|case
literal|0
case|:
name|arg
operator|=
name|s
operator|-
name|base
expr_stmt|;
name|skipspaces
operator|++
expr_stmt|;
name|arg
operator|-=
name|skipspaces
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|postspace
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_SPACE
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LITERAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
name|postspace
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|send
condition|)
name|skipspaces
operator|--
expr_stmt|;
if|if
condition|(
name|skipspaces
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_SKIP
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|skipspaces
expr_stmt|;
block|}
name|skipspaces
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|send
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_NEWLINE
expr_stmt|;
if|if
condition|(
name|noblank
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_BLANK
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
name|arg
operator|=
name|fpc
operator|-
name|linepc
operator|+
literal|1
expr_stmt|;
else|else
name|arg
operator|=
literal|0
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|linepc
operator|=
name|fpc
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEMARK
expr_stmt|;
name|noblank
operator|=
name|repeat
operator|=
name|FALSE
expr_stmt|;
name|base
operator|=
name|s
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'@'
case|:
case|case
literal|'^'
case|:
name|ischop
operator|=
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'^'
expr_stmt|;
if|if
condition|(
name|postspace
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_SPACE
expr_stmt|;
name|postspace
operator|=
name|FALSE
expr_stmt|;
block|}
name|arg
operator|=
operator|(
name|s
operator|-
name|base
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_LITERAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
name|base
operator|=
name|s
operator|-
literal|1
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_FETCH
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|s
operator|++
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEGLOB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|||
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|)
condition|)
block|{
name|arg
operator|=
name|ischop
condition|?
literal|512
else|:
literal|0
expr_stmt|;
name|base
operator|=
name|s
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|f
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
name|arg
operator||=
literal|256
operator|+
operator|(
name|s
operator|-
name|f
operator|)
expr_stmt|;
block|}
operator|*
name|fpc
operator|++
operator|=
name|s
operator|-
name|base
expr_stmt|;
comment|/* fieldsize for FETCH */
operator|*
name|fpc
operator|++
operator|=
name|FF_DECIMAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|I32
name|prespace
init|=
literal|0
decl_stmt|;
name|bool
name|ismore
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'>'
condition|)
empty_stmt|;
name|prespace
operator|=
name|FF_SPACE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'|'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'|'
condition|)
empty_stmt|;
name|prespace
operator|=
name|FF_HALFSPACE
expr_stmt|;
name|postspace
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
condition|)
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'<'
condition|)
empty_stmt|;
name|postspace
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|ismore
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|fpc
operator|++
operator|=
name|s
operator|-
name|base
expr_stmt|;
comment|/* fieldsize for FETCH */
operator|*
name|fpc
operator|++
operator|=
name|ischop
condition|?
name|FF_CHECKCHOP
else|:
name|FF_CHECKNL
expr_stmt|;
if|if
condition|(
name|prespace
condition|)
operator|*
name|fpc
operator|++
operator|=
name|prespace
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_ITEM
expr_stmt|;
if|if
condition|(
name|ismore
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_MORE
expr_stmt|;
if|if
condition|(
name|ischop
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_CHOP
expr_stmt|;
block|}
name|base
operator|=
name|s
expr_stmt|;
name|skipspaces
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|fpc
operator|++
operator|=
name|FF_END
expr_stmt|;
name|arg
operator|=
name|fpc
operator|-
name|fops
expr_stmt|;
block|{
comment|/* need to jump to the next word */
name|int
name|z
decl_stmt|;
name|z
operator|=
name|WORD_ALIGN
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|%
name|WORD_ALIGN
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|z
operator|+
name|arg
operator|*
sizeof|sizeof
argument_list|(
name|U16
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|z
expr_stmt|;
block|}
name|Copy
argument_list|(
name|fops
argument_list|,
name|s
argument_list|,
name|arg
argument_list|,
name|U16
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|fops
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'f'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvCOMPILED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
comment|/*  * The rest of this file was derived from source code contributed  * by Tom Horsley.  *  * NOTE: this code was derived from Tom Horsley's qsort replacement  * and should not be confused with the original code.  */
comment|/* Copyright (C) Tom Horsley, 1997. All rights reserved.     Permission granted to distribute under the same terms as perl which are    (briefly):      This program is free software; you can redistribute it and/or modify     it under the terms of either:  	a) the GNU General Public License as published by the Free 	Software Foundation; either version 1, or (at your option) any 	later version, or  	b) the "Artistic License" which comes with this Kit.     Details on the perl license can be found in the perl source code which    may be located via the www.perl.com web page.     This is the most wonderfulest possible qsort I can come up with (and    still be mostly portable) My (limited) tests indicate it consistently    does about 20% fewer calls to compare than does the qsort in the Visual    C++ library, other vendors may vary.     Some of the ideas in here can be found in "Algorithms" by Sedgewick,    others I invented myself (or more likely re-invented since they seemed    pretty obvious once I watched the algorithm operate for a while).     Most of this code was written while watching the Marlins sweep the Giants    in the 1997 National League Playoffs - no Braves fans allowed to use this    code (just kidding :-).     I realize that if I wanted to be true to the perl tradition, the only    comment in this file would be something like:     ...they shuffled back towards the rear of the line. 'No, not at the    rear!'  the slave-driver shouted. 'Three files up. And stay there...     However, I really needed to violate that tradition just so I could keep    track of what happens myself, not to mention some poor fool trying to    understand this years from now :-). */
comment|/* ********************************************************** Configuration */
ifndef|#
directive|ifndef
name|QSORT_ORDER_GUESS
define|#
directive|define
name|QSORT_ORDER_GUESS
value|2
comment|/* Select doubling version of the netBSD trick */
endif|#
directive|endif
comment|/* QSORT_MAX_STACK is the largest number of partitions that can be stacked up for    future processing - a good max upper bound is log base 2 of memory size    (32 on 32 bit machines, 64 on 64 bit machines, etc). In reality can    safely be smaller than that since the program is taking up some space and    most operating systems only let you grab some subset of contiguous    memory (not to mention that you are normally sorting data larger than    1 byte element size :-). */
ifndef|#
directive|ifndef
name|QSORT_MAX_STACK
define|#
directive|define
name|QSORT_MAX_STACK
value|32
endif|#
directive|endif
comment|/* QSORT_BREAK_EVEN is the size of the largest partition we should insertion sort.    Anything bigger and we use qsort. If you make this too small, the qsort    will probably break (or become less efficient), because it doesn't expect    the middle element of a partition to be the same as the right or left -    you have been warned). */
ifndef|#
directive|ifndef
name|QSORT_BREAK_EVEN
define|#
directive|define
name|QSORT_BREAK_EVEN
value|6
endif|#
directive|endif
comment|/* ************************************************************* Data Types */
comment|/* hold left and right index values of a partition waiting to be sorted (the    partition includes both left and right - right is NOT one past the end or    anything like that). */
struct|struct
name|partition_stack_entry
block|{
name|int
name|left
decl_stmt|;
name|int
name|right
decl_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|int
name|qsort_break_even
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
comment|/* ******************************************************* Shorthand Macros */
comment|/* Note that these macros will be used from inside the qsort function where    we happen to know that the variable 'elt_size' contains the size of an    array element and the variable 'temp' points to enough space to hold a    temp element and the variable 'array' points to the array being sorted    and 'compare' is the pointer to the compare routine.     Also note that there are very many highly architecture specific ways    these might be sped up, but this is simply the most generally portable    code I could think of. */
comment|/* Return< 0 == 0 or> 0 as the value of elt1 is< elt2, == elt2,> elt2 */
define|#
directive|define
name|qsort_cmp
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|)
define|\
value|((*compare)(aTHXo_ array[elt1], array[elt2]))
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
define|#
directive|define
name|QSORT_NOTICE_SWAP
value|swapped++;
else|#
directive|else
define|#
directive|define
name|QSORT_NOTICE_SWAP
endif|#
directive|endif
comment|/* swaps contents of array elements elt1, elt2. */
define|#
directive|define
name|qsort_swap
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|)
define|\
value|STMT_START { \       QSORT_NOTICE_SWAP \       temp = array[elt1]; \       array[elt1] = array[elt2]; \       array[elt2] = temp; \    } STMT_END
comment|/* rotate contents of elt1, elt2, elt3 such that elt1 gets elt2, elt2 gets    elt3 and elt3 gets elt1. */
define|#
directive|define
name|qsort_rotate
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|,
name|elt3
parameter_list|)
define|\
value|STMT_START { \       QSORT_NOTICE_SWAP \       temp = array[elt1]; \       array[elt1] = array[elt2]; \       array[elt2] = array[elt3]; \       array[elt3] = temp; \    } STMT_END
comment|/* ************************************************************ Debug stuff */
ifdef|#
directive|ifdef
name|QSORT_DEBUG
specifier|static
name|void
name|break_here
parameter_list|()
block|{
return|return;
comment|/* good place to set a breakpoint */
block|}
define|#
directive|define
name|qsort_assert
parameter_list|(
name|t
parameter_list|)
value|(void)( (t) || (break_here(), 0) )
specifier|static
name|void
name|doqsort_all_asserts
parameter_list|(
name|void
modifier|*
name|array
parameter_list|,
name|size_t
name|num_elts
parameter_list|,
name|size_t
name|elt_size
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|elt1
parameter_list|,
specifier|const
name|void
modifier|*
name|elt2
parameter_list|)
parameter_list|,
name|int
name|pc_left
parameter_list|,
name|int
name|pc_right
parameter_list|,
name|int
name|u_left
parameter_list|,
name|int
name|u_right
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|u_right
operator|<
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_right
operator|<
name|u_left
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|u_right
operator|+
literal|1
init|;
name|i
operator|<
name|pc_left
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|pc_left
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|pc_left
init|;
name|i
operator|<
name|pc_right
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|pc_right
operator|+
literal|1
init|;
name|i
operator|<
name|u_left
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|i
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|qsort_all_asserts
parameter_list|(
name|PC_LEFT
parameter_list|,
name|PC_RIGHT
parameter_list|,
name|U_LEFT
parameter_list|,
name|U_RIGHT
parameter_list|)
define|\
value|doqsort_all_asserts(array, num_elts, elt_size, compare, \                  PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT)
else|#
directive|else
define|#
directive|define
name|qsort_assert
parameter_list|(
name|t
parameter_list|)
value|((void)0)
define|#
directive|define
name|qsort_all_asserts
parameter_list|(
name|PC_LEFT
parameter_list|,
name|PC_RIGHT
parameter_list|,
name|U_LEFT
parameter_list|,
name|U_RIGHT
parameter_list|)
value|((void)0)
endif|#
directive|endif
comment|/* ****************************************************************** qsort */
name|STATIC
name|void
name|S_qsortsv
parameter_list|(
name|pTHX_
name|SV
modifier|*
modifier|*
name|array
parameter_list|,
name|size_t
name|num_elts
parameter_list|,
name|SVCOMPARE_t
name|compare
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|temp
decl_stmt|;
name|struct
name|partition_stack_entry
name|partition_stack
index|[
name|QSORT_MAX_STACK
index|]
decl_stmt|;
name|int
name|next_stack_entry
init|=
literal|0
decl_stmt|;
name|int
name|part_left
decl_stmt|;
name|int
name|part_right
decl_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|int
name|qsort_break_even
decl_stmt|;
name|int
name|swapped
decl_stmt|;
endif|#
directive|endif
comment|/* Make sure we actually have work to do.    */
if|if
condition|(
name|num_elts
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
comment|/* Setup the initial partition definition and fall into the sorting loop    */
name|part_left
operator|=
literal|0
expr_stmt|;
name|part_right
operator|=
call|(
name|int
call|)
argument_list|(
name|num_elts
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|QSORT_BREAK_EVEN
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|qsort_break_even
value|QSORT_BREAK_EVEN
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|>=
name|qsort_break_even
condition|)
block|{
comment|/* OK, this is gonna get hairy, so lets try to document all the             concepts and abbreviations and variables and what they keep             track of:              pc: pivot chunk - the set of array elements we accumulate in the                 middle of the partition, all equal in value to the original                 pivot element selected. The pc is defined by:                  pc_left - the leftmost array index of the pc                 pc_right - the rightmost array index of the pc                  we start with pc_left == pc_right and only one element                 in the pivot chunk (but it can grow during the scan).              u:  uncompared elements - the set of elements in the partition                 we have not yet compared to the pivot value. There are two                 uncompared sets during the scan - one to the left of the pc                 and one to the right.                  u_right - the rightmost index of the left side's uncompared set                 u_left - the leftmost index of the right side's uncompared set                  The leftmost index of the left sides's uncompared set                 doesn't need its own variable because it is always defined                 by the leftmost edge of the whole partition (part_left). The                 same goes for the rightmost edge of the right partition                 (part_right).                  We know there are no uncompared elements on the left once we                 get u_right< part_left and no uncompared elements on the                 right once u_left> part_right. When both these conditions                 are met, we have completed the scan of the partition.                  Any elements which are between the pivot chunk and the                 uncompared elements should be less than the pivot value on                 the left side and greater than the pivot value on the right                 side (in fact, the goal of the whole algorithm is to arrange                 for that to be true and make the groups of less-than and                 greater-then elements into new partitions to sort again).              As you marvel at the complexity of the code and wonder why it             has to be so confusing. Consider some of the things this level             of confusion brings:              Once I do a compare, I squeeze every ounce of juice out of it. I             never do compare calls I don't have to do, and I certainly never             do redundant calls.              I also never swap any elements unless I can prove there is a             good reason. Many sort algorithms will swap a known value with             an uncompared value just to get things in the right place (or             avoid complexity :-), but that uncompared value, once it gets             compared, may then have to be swapped again. A lot of the             complexity of this code is due to the fact that it never swaps             anything except compared values, and it only swaps them when the             compare shows they are out of position.          */
name|int
name|pc_left
decl_stmt|,
name|pc_right
decl_stmt|;
name|int
name|u_right
decl_stmt|,
name|u_left
decl_stmt|;
name|int
name|s
decl_stmt|;
name|pc_left
operator|=
operator|(
operator|(
name|part_left
operator|+
name|part_right
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|pc_right
operator|=
name|pc_left
expr_stmt|;
name|u_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
name|u_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
comment|/* Qsort works best when the pivot value is also the median value             in the partition (unfortunately you can't find the median value             without first sorting :-), so to give the algorithm a helping             hand, we pick 3 elements and sort them and use the median value             of that tiny set as the pivot value.              Some versions of qsort like to use the left middle and right as             the 3 elements to sort so they can insure the ends of the             partition will contain values which will stop the scan in the             compare loop, but when you have to call an arbitrarily complex             routine to do a compare, its really better to just keep track of             array index values to know when you hit the edge of the             partition and avoid the extra compare. An even better reason to             avoid using a compare call is the fact that you can drop off the             edge of the array if someone foolishly provides you with an             unstable compare function that doesn't always provide consistent             results.              So, since it is simpler for us to compare the three adjacent             elements in the middle of the partition, those are the ones we             pick here (conveniently pointed at by u_right, pc_left, and             u_left). The values of the left, center, and right elements             are refered to as l c and r in the following comments.          */
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|swapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l< c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
comment|/* if l< c, c< r - already in order - nothing to do */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l< c, c == r - already in order, pc grows */
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
comment|/* l< c, c> r - need to know more */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l< c, c> r, l< r - swap c& r to get ordered */
name|qsort_swap
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l< c, c> r, l == r - swap c&r, grow pc */
name|qsort_swap
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l< c, c> r, l> r - make lcr into rlc to get ordered */
name|qsort_rotate
argument_list|(
name|pc_left
argument_list|,
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l == c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l == c, c< r - already in order, grow pc */
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l == c, c == r - already in order, grow pc both ways */
operator|--
name|pc_left
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l == c, c> r - swap l& r, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* l> c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l> c, c< r - need to know more */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l> c, c< r, l< r - swap l& c to get ordered */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l> c, c< r, l == r - swap l& c, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l> c, c< r, l> r - rotate lcr into crl to order */
name|qsort_rotate
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l> c, c == r - swap ends, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l> c, c> r - swap ends to get in order */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We now know the 3 middle elements have been compared and             arranged in the desired order, so we can shrink the uncompared             sets on both sides          */
operator|--
name|u_right
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
comment|/* The above massive nested if was the simple part :-). We now have             the middle 3 elements ordered and we need to scan through the             uncompared sets on either side, swapping elements that are on             the wrong side or simply shuffling equal elements around to get             all equal elements into the pivot chunk.          */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|still_work_on_left
decl_stmt|;
name|int
name|still_work_on_right
decl_stmt|;
comment|/* Scan the uncompared values on the left. If I find a value                equal to the pivot value, move it over so it is adjacent to                the pivot chunk and expand the pivot chunk. If I find a value                less than the pivot value, then just leave it - its already                on the correct side of the partition. If I find a greater                value, then stop the scan.             */
while|while
condition|(
operator|(
name|still_work_on_left
operator|=
operator|(
name|u_right
operator|>=
name|part_left
operator|)
operator|)
condition|)
block|{
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|--
name|u_right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
operator|--
name|pc_left
expr_stmt|;
if|if
condition|(
name|pc_left
operator|!=
name|u_right
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
block|}
operator|--
name|u_right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|qsort_assert
argument_list|(
name|u_right
operator|<
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|u_right
operator|+
literal|1
argument_list|,
name|pc_left
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do a mirror image scan of uncompared values on the right             */
while|while
condition|(
operator|(
name|still_work_on_right
operator|=
operator|(
name|u_left
operator|<=
name|part_right
operator|)
operator|)
condition|)
block|{
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|++
name|u_left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
operator|++
name|pc_right
expr_stmt|;
if|if
condition|(
name|pc_right
operator|!=
name|u_left
condition|)
block|{
name|qsort_swap
argument_list|(
name|pc_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
block|}
operator|++
name|u_left
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|qsort_assert
argument_list|(
name|u_left
operator|>
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|u_left
operator|-
literal|1
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_work_on_left
condition|)
block|{
comment|/* I know I have a value on the left side which needs to be                   on the right side, but I need to know more to decide                   exactly the best thing to do with it.                */
if|if
condition|(
name|still_work_on_right
condition|)
block|{
comment|/* I know I have values on both side which are out of                      position. This is a big win because I kill two birds                      with one swap (so to speak). I can advance the                      uncompared pointers on both sides after swapping both                      of them into the right place.                   */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|u_right
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I have an out of position value on the left, but the                      right is fully scanned, so I "slide" the pivot chunk                      and any less-than values left one to make room for the                      greater value over on the right. If the out of position                      value is immediately adjacent to the pivot chunk (there                      are no less-than values), I can do that with a swap,                      otherwise, I have to rotate one of the less than values                      into the former position of the out of position value                      and the right end of the pivot chunk into the left end                      (got all that?).                   */
operator|--
name|pc_left
expr_stmt|;
if|if
condition|(
name|pc_left
operator|==
name|u_right
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
operator|-
literal|1
argument_list|,
name|u_left
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qsort_rotate
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|,
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
operator|-
literal|1
argument_list|,
name|u_left
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|--
name|pc_right
expr_stmt|;
operator|--
name|u_right
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|still_work_on_right
condition|)
block|{
comment|/* Mirror image of complex case above: I have an out of                   position value on the right, but the left is fully                   scanned, so I need to shuffle things around to make room                   for the right value on the left.                */
operator|++
name|pc_right
expr_stmt|;
if|if
condition|(
name|pc_right
operator|==
name|u_left
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_left
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
operator|+
literal|1
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qsort_rotate
argument_list|(
name|pc_right
argument_list|,
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
operator|+
literal|1
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
operator|++
name|pc_left
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
block|}
else|else
block|{
comment|/* No more scanning required on either side of partition,                   break out of loop and figure out next set of partitions                */
break|break;
block|}
block|}
comment|/* The elements in the pivot chunk are now in the right place. They             will never move or be compared again. All I have to do is decide             what to do with the stuff to the left and right of the pivot             chunk.              Notes on the QSORT_ORDER_GUESS ifdef code:              1. If I just built these partitions without swapping any (or                very many) elements, there is a chance that the elements are                already ordered properly (being properly ordered will                certainly result in no swapping, but the converse can't be                proved :-).              2. A (properly written) insertion sort will run faster on                already ordered data than qsort will.              3. Perhaps there is some way to make a good guess about                switching to an insertion sort earlier than partition size 6                (for instance - we could save the partition size on the stack                and increase the size each time we find we didn't swap, thus                switching to insertion sort earlier for partitions with a                history of not swapping).              4. Naturally, if I just switch right away, it will make                artificial benchmarks with pure ascending (or descending)                data look really good, but is that a good reason in general?                Hard to say...          */
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
if|if
condition|(
name|swapped
operator|<
literal|3
condition|)
block|{
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|1
name|qsort_break_even
operator|=
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|2
name|qsort_break_even
operator|*=
literal|2
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|3
name|int
name|prev_break
init|=
name|qsort_break_even
decl_stmt|;
name|qsort_break_even
operator|*=
name|qsort_break_even
expr_stmt|;
if|if
condition|(
name|qsort_break_even
operator|<
name|prev_break
condition|)
block|{
name|qsort_break_even
operator|=
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|qsort_break_even
operator|=
name|QSORT_BREAK_EVEN
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|part_left
operator|<
name|pc_left
condition|)
block|{
comment|/* There are elements on the left which need more processing.                Check the right as well before deciding what to do.             */
if|if
condition|(
name|pc_right
operator|<
name|part_right
condition|)
block|{
comment|/* We have two partitions to be sorted. Stack the biggest one                   and process the smallest one on the next iteration. This                   minimizes the stack height by insuring that any additional                   stack entries must come from the smallest partition which                   (because it is smallest) will have the fewest                   opportunities to generate additional stack entries.                */
if|if
condition|(
operator|(
name|part_right
operator|-
name|pc_right
operator|)
operator|>
operator|(
name|pc_left
operator|-
name|part_left
operator|)
condition|)
block|{
comment|/* stack the right partition, process the left */
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
operator|=
name|part_right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
operator|=
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
name|part_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* stack the left partition, process the right */
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
operator|=
name|part_left
expr_stmt|;
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
operator|=
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
name|part_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
block|}
name|qsort_assert
argument_list|(
name|next_stack_entry
operator|<
name|QSORT_MAX_STACK
argument_list|)
expr_stmt|;
operator|++
name|next_stack_entry
expr_stmt|;
block|}
else|else
block|{
comment|/* The elements on the left are the only remaining elements                   that need sorting, arrange for them to be processed as the                   next partition.                */
name|part_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc_right
operator|<
name|part_right
condition|)
block|{
comment|/* There is only one chunk on the right to be sorted, make it                the new partition and loop back around.             */
name|part_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This whole partition wound up in the pivot chunk, so                we need to get a new partition off the stack.             */
if|if
condition|(
name|next_stack_entry
operator|==
literal|0
condition|)
block|{
comment|/* the stack is empty - we are done */
break|break;
block|}
operator|--
name|next_stack_entry
expr_stmt|;
name|part_left
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
expr_stmt|;
name|part_right
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* This partition is too small to fool with qsort complexity, just             do an ordinary insertion sort to minimize overhead.          */
name|int
name|i
decl_stmt|;
comment|/* Assume 1st element is in right place already, and start checking             at 2nd element to see where it should be inserted.          */
for|for
control|(
name|i
operator|=
name|part_left
operator|+
literal|1
init|;
name|i
operator|<=
name|part_right
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Scan (backwards - just in case 'i' is already in right place)                through the elements already sorted to see if the ith element                belongs ahead of one of them.             */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
name|part_left
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* i belongs right after j                   */
break|break;
block|}
block|}
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
comment|/* Looks like we really need to move some things                */
name|int
name|k
decl_stmt|;
name|temp
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|-
literal|1
init|;
name|k
operator|>=
name|j
condition|;
operator|--
name|k
control|)
name|array
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|array
index|[
name|k
index|]
expr_stmt|;
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* That partition is now sorted, grab the next one, or get out             of the loop if there aren't any more.          */
if|if
condition|(
name|next_stack_entry
operator|==
literal|0
condition|)
block|{
comment|/* the stack is empty - we are done */
break|break;
block|}
operator|--
name|next_stack_entry
expr_stmt|;
name|part_left
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
expr_stmt|;
name|part_right
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Believe it or not, the array is sorted at this point! */
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
undef|#
directive|undef
name|this
define|#
directive|define
name|this
value|pPerl
include|#
directive|include
file|"XSUB.h"
endif|#
directive|endif
specifier|static
name|I32
name|sortcv
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|I32
name|oldsaveix
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|oldscopeix
init|=
name|PL_scopestack_ix
decl_stmt|;
name|I32
name|result
decl_stmt|;
name|GvSV
argument_list|(
name|PL_firstgv
argument_list|)
operator|=
name|a
expr_stmt|;
name|GvSV
argument_list|(
name|PL_secondgv
argument_list|)
operator|=
name|b
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
expr_stmt|;
name|PL_op
operator|=
name|PL_sortcop
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_stack_sp
operator|!=
name|PL_stack_base
operator|+
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return single value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvNIOKp
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return a numeric value"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SvIV
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
expr_stmt|;
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscopeix
condition|)
block|{
name|LEAVE
expr_stmt|;
block|}
name|leave_scope
argument_list|(
name|oldsaveix
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|static
name|I32
name|sortcv_stacked
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|I32
name|oldsaveix
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|oldscopeix
init|=
name|PL_scopestack_ix
decl_stmt|;
name|I32
name|result
decl_stmt|;
name|AV
modifier|*
name|av
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|av
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|<
literal|1
condition|)
block|{
name|SV
modifier|*
modifier|*
name|ary
init|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
decl_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|!=
name|ary
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
if|if
condition|(
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|<
literal|1
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|ary
argument_list|,
literal|2
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
block|}
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
literal|1
expr_stmt|;
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|AvARRAY
argument_list|(
name|av
argument_list|)
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
expr_stmt|;
name|PL_op
operator|=
name|PL_sortcop
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_stack_sp
operator|!=
name|PL_stack_base
operator|+
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return single value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvNIOKp
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return a numeric value"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SvIV
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
expr_stmt|;
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscopeix
condition|)
block|{
name|LEAVE
expr_stmt|;
block|}
name|leave_scope
argument_list|(
name|oldsaveix
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|static
name|I32
name|sortcv_xsub
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|I32
name|oldsaveix
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|oldscopeix
init|=
name|PL_scopestack_ix
decl_stmt|;
name|I32
name|result
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
operator|(
name|CV
operator|*
operator|)
name|PL_sortcop
decl_stmt|;
name|SP
operator|=
name|PL_stack_base
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
operator|++
name|SP
operator|=
name|a
expr_stmt|;
operator|*
operator|++
name|SP
operator|=
name|b
expr_stmt|;
name|PUTBACK
expr_stmt|;
operator|(
name|void
operator|)
operator|(
operator|*
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
operator|(
name|aTHXo_
name|cv
operator|)
expr_stmt|;
if|if
condition|(
name|PL_stack_sp
operator|!=
name|PL_stack_base
operator|+
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return single value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvNIOKp
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Sort subroutine didn't return a numeric value"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SvIV
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
expr_stmt|;
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscopeix
condition|)
block|{
name|LEAVE
expr_stmt|;
block|}
name|leave_scope
argument_list|(
name|oldsaveix
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|static
name|I32
name|sv_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|NV
name|nv1
init|=
name|SvNV
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|NV
name|nv2
init|=
name|SvNV
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
name|nv1
operator|<
name|nv2
condition|?
operator|-
literal|1
else|:
name|nv1
operator|>
name|nv2
condition|?
literal|1
else|:
literal|0
return|;
block|}
specifier|static
name|I32
name|sv_i_ncmp
parameter_list|(
name|pTHXo_
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|IV
name|iv1
init|=
name|SvIV
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|IV
name|iv2
init|=
name|SvIV
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
name|iv1
operator|<
name|iv2
condition|?
operator|-
literal|1
else|:
name|iv1
operator|>
name|iv2
condition|?
literal|1
else|:
literal|0
return|;
block|}
define|#
directive|define
name|tryCALL_AMAGICbin
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|meth
parameter_list|,
name|svp
parameter_list|)
value|STMT_START { \ 	  *svp = Nullsv;				\           if (PL_amagic_generation) { \ 	    if (SvAMAGIC(left)||SvAMAGIC(right))\ 		*svp = amagic_call(left, \ 				   right, \ 				   CAT2(meth,_amg), \ 				   0); \ 	  } \ 	} STMT_END
specifier|static
name|I32
name|amagic_ncmp
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|a
parameter_list|,
specifier|register
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|ncmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|NV
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_ncmp
argument_list|(
argument|aTHXo_ a
argument_list|,
argument|b
argument_list|)
return|;
block|}
specifier|static
name|I32
name|amagic_i_ncmp
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|a
parameter_list|,
specifier|register
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|ncmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|NV
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_i_ncmp
argument_list|(
argument|aTHXo_ a
argument_list|,
argument|b
argument_list|)
return|;
block|}
specifier|static
name|I32
name|amagic_cmp
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|scmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|NV
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_cmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
specifier|static
name|I32
name|amagic_cmp_locale
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|scmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|NV
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_cmp_locale
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
specifier|static
name|I32
name|run_user_filter
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|SV
modifier|*
name|datasv
init|=
name|FILTER_DATA
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|int
name|filter_has_file
init|=
name|IoLINES
argument_list|(
name|datasv
argument_list|)
decl_stmt|;
name|GV
modifier|*
name|filter_child_proc
init|=
operator|(
name|GV
operator|*
operator|)
name|IoFMT_GV
argument_list|(
name|datasv
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|filter_state
init|=
operator|(
name|SV
operator|*
operator|)
name|IoTOP_GV
argument_list|(
name|datasv
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|filter_sub
init|=
operator|(
name|SV
operator|*
operator|)
name|IoBOTTOM_GV
argument_list|(
name|datasv
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* I was having segfault trouble under Linux 2.2.5 after a        parse error occured.  (Had to hack around it with a test        for PL_error_count == 0.)  Solaris doesn't segfault --        not sure where the trouble is yet.  XXX */
if|if
condition|(
name|filter_has_file
condition|)
block|{
name|len
operator|=
name|FILTER_READ
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|buf_sv
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filter_sub
operator|&&
name|len
operator|>=
literal|0
condition|)
block|{
name|dSP
expr_stmt|;
name|int
name|count
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVE_DEFSV
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|buf_sv
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|maxlen
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_state
condition|)
block|{
name|PUSHs
argument_list|(
name|filter_state
argument_list|)
expr_stmt|;
block|}
name|PUTBACK
expr_stmt|;
name|count
operator|=
name|call_sv
argument_list|(
name|filter_sub
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|SV
modifier|*
name|out
init|=
name|POPs
decl_stmt|;
if|if
condition|(
name|SvOK
argument_list|(
name|out
argument_list|)
condition|)
block|{
name|len
operator|=
name|SvIV
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|PUTBACK
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|IoLINES
argument_list|(
name|datasv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filter_child_proc
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_child_proc
argument_list|)
expr_stmt|;
name|IoFMT_GV
argument_list|(
name|datasv
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
block|}
if|if
condition|(
name|filter_state
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_state
argument_list|)
expr_stmt|;
name|IoTOP_GV
argument_list|(
name|datasv
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
block|}
if|if
condition|(
name|filter_sub
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|filter_sub
argument_list|)
expr_stmt|;
name|IoBOTTOM_GV
argument_list|(
name|datasv
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
block|}
name|filter_del
argument_list|(
name|run_user_filter
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
specifier|static
name|I32
name|sv_cmp_locale_static
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
return|return
name|sv_cmp_locale
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
specifier|static
name|I32
name|sv_cmp_static
parameter_list|(
name|pTHXo_
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
return|return
name|sv_cmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_OBJECT */
end_comment

end_unit

