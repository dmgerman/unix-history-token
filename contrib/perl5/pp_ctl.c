begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    pp_ctl.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * Now far ahead the Road has gone,  * And I must follow, if I can,  * Pursuing it with eager feet,  * Until it joins some larger way  * Where many paths and errands meet.  * And whither then?  I cannot say.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|WORD_ALIGN
value|sizeof(U16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOCATCH
parameter_list|(
name|o
parameter_list|)
value|((CATCH_GET == TRUE) ? docatch(o) : (o))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|CALLOP
value|this->*PL_op
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CALLOP
value|*PL_op
end_define

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|docatch
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|dofindlabel
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|,
name|char
operator|*
name|label
operator|,
name|OP
operator|*
operator|*
name|opstack
operator|,
name|OP
operator|*
operator|*
name|oplimit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doparseform
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|dopoptoeval
name|_
argument_list|(
operator|(
name|I32
name|startingblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|dopoptolabel
name|_
argument_list|(
operator|(
name|char
operator|*
name|label
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|dopoptoloop
name|_
argument_list|(
operator|(
name|I32
name|startingblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|dopoptosub
name|_
argument_list|(
operator|(
name|I32
name|startingblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|dopoptosub_at
name|_
argument_list|(
operator|(
name|PERL_CONTEXT
operator|*
name|cxstk
operator|,
name|I32
name|startingblock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_lines
name|_
argument_list|(
operator|(
name|AV
operator|*
name|array
operator|,
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|sortcv
name|_
argument_list|(
operator|(
name|SV
operator|*
name|a
operator|,
name|SV
operator|*
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|qsortsv
name|_
argument_list|(
operator|(
name|SV
operator|*
operator|*
name|array
operator|,
name|size_t
name|num_elts
operator|,
name|I32
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|SV
operator|*
name|a
argument_list|,
name|SV
operator|*
name|b
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|doeval
name|_
argument_list|(
operator|(
name|int
name|gimme
operator|,
name|OP
operator|*
operator|*
name|startop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|PP
argument_list|(
argument|pp_wantarray
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|RETPUSHUNDEF
expr_stmt|;
switch|switch
condition|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
condition|)
block|{
case|case
name|G_ARRAY
case|:
name|RETPUSHYES
expr_stmt|;
case|case
name|G_SCALAR
case|:
name|RETPUSHNO
expr_stmt|;
default|default:
name|RETPUSHUNDEF
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcmaybe
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcreset
argument_list|)
end_macro

begin_block
block|{
comment|/* XXXX Should store the old value to allow for tie/overload - and        restore in regcomp, where marked with XXXX. */
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_regcomp
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|cLOGOP
operator|->
name|op_other
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|SV
modifier|*
name|tmpstr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
name|Null
argument_list|(
name|MAGIC
operator|*
argument_list|)
decl_stmt|;
name|tmpstr
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|tmpstr
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|SvRV
argument_list|(
name|tmpstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mg
condition|)
block|{
name|regexp
modifier|*
name|re
init|=
operator|(
name|regexp
operator|*
operator|)
name|mg
operator|->
name|mg_obj
decl_stmt|;
name|ReREFCNT_dec
argument_list|(
name|pm
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|ReREFCNT_inc
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|SvPV
argument_list|(
name|tmpstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Check against the last compiled regexp. */
if|if
condition|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|||
operator|!
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
operator|||
name|pm
operator|->
name|op_pmregexp
operator|->
name|prelen
operator|!=
name|len
operator|||
name|memNE
argument_list|(
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|,
name|t
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|op_pmregexp
condition|)
block|{
name|ReREFCNT_dec
argument_list|(
name|pm
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|Null
argument_list|(
name|REGEXP
operator|*
argument_list|)
expr_stmt|;
comment|/* crucial if regcomp aborts */
block|}
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
name|PL_reginterp_cnt
operator|=
name|I32_MAX
expr_stmt|;
comment|/* Mark as safe.  */
name|pm
operator|->
name|op_pmflags
operator|=
name|pm
operator|->
name|op_pmpermflags
expr_stmt|;
comment|/* reset case sensitivity */
name|pm
operator|->
name|op_pmregexp
operator|=
name|CALLREGCOMP
argument_list|(
name|t
argument_list|,
name|t
operator|+
name|len
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
comment|/* XXXX Be extra paranoid - needed 					   inside tie/overload accessors.  */
block|}
block|}
ifndef|#
directive|ifndef
name|INCOMPLETE_TAINTS
if|if
condition|(
name|PL_tainting
condition|)
block|{
if|if
condition|(
name|PL_tainted
condition|)
name|pm
operator|->
name|op_pmdynflags
operator||=
name|PMdf_TAINTED
expr_stmt|;
else|else
name|pm
operator|->
name|op_pmdynflags
operator|&=
operator|~
name|PMdf_TAINTED
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|->
name|prelen
operator|&&
name|PL_curpm
condition|)
name|pm
operator|=
name|PL_curpm
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
literal|"\\s+"
argument_list|,
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|)
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_WHITE
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
condition|)
block|{
name|pm
operator|->
name|op_private
operator|&=
operator|~
name|OPpRUNTIME
expr_stmt|;
comment|/* no point compiling again */
name|cLOGOP
operator|->
name|op_first
operator|->
name|op_next
operator|=
name|PL_op
operator|->
name|op_next
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_substcont
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|cLOGOP
operator|->
name|op_other
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
init|=
operator|&
name|cxstack
index|[
name|cxstack_ix
index|]
decl_stmt|;
specifier|register
name|SV
modifier|*
name|dstr
init|=
name|cx
operator|->
name|sb_dstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|cx
operator|->
name|sb_s
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
init|=
name|cx
operator|->
name|sb_m
decl_stmt|;
name|char
modifier|*
name|orig
init|=
name|cx
operator|->
name|sb_orig
decl_stmt|;
specifier|register
name|REGEXP
modifier|*
name|rx
init|=
name|cx
operator|->
name|sb_rx
decl_stmt|;
name|rxres_restore
argument_list|(
operator|&
name|cx
operator|->
name|sb_rxres
argument_list|,
name|rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|->
name|sb_iters
operator|++
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|sb_iters
operator|>
name|cx
operator|->
name|sb_maxiters
condition|)
name|DIE
argument_list|(
literal|"Substitution loop"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cx
operator|->
name|sb_rxtainted
operator|&
literal|2
operator|)
operator|&&
name|SvTAINTED
argument_list|(
name|TOPs
argument_list|)
condition|)
name|cx
operator|->
name|sb_rxtainted
operator||=
literal|2
expr_stmt|;
name|sv_catsv
argument_list|(
name|dstr
argument_list|,
name|POPs
argument_list|)
expr_stmt|;
comment|/* Are we done */
if|if
condition|(
name|cx
operator|->
name|sb_once
operator|||
operator|!
name|CALLREGEXEC
argument_list|(
name|rx
argument_list|,
name|s
argument_list|,
name|cx
operator|->
name|sb_strend
argument_list|,
name|orig
argument_list|,
name|s
operator|==
name|m
argument_list|,
name|Nullsv
argument_list|,
name|NULL
argument_list|,
name|cx
operator|->
name|sb_safebase
condition|?
literal|0
else|:
name|REXEC_COPY_STR
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|targ
init|=
name|cx
operator|->
name|sb_targ
decl_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|cx
operator|->
name|sb_strend
operator|-
name|s
argument_list|)
expr_stmt|;
name|cx
operator|->
name|sb_rxtainted
operator||=
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|targ
argument_list|)
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|targ
argument_list|)
operator|=
name|SvPVX
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|targ
argument_list|,
name|SvCUR
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|targ
argument_list|,
name|SvLEN
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_free
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|cx
operator|->
name|sb_rxtainted
operator|&
literal|1
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|sb_iters
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|TAINT_IF
argument_list|(
name|cx
operator|->
name|sb_rxtainted
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|cx
operator|->
name|sb_oldsave
argument_list|)
expr_stmt|;
name|POPSUBST
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|pm
operator|->
name|op_next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rx
operator|->
name|subbase
operator|&&
name|rx
operator|->
name|subbase
operator|!=
name|orig
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
name|cx
operator|->
name|sb_orig
operator|=
name|orig
operator|=
name|rx
operator|->
name|subbase
expr_stmt|;
name|s
operator|=
name|orig
operator|+
operator|(
name|m
operator|-
name|s
operator|)
expr_stmt|;
name|cx
operator|->
name|sb_strend
operator|=
name|s
operator|+
operator|(
name|cx
operator|->
name|sb_strend
operator|-
name|m
operator|)
expr_stmt|;
block|}
name|cx
operator|->
name|sb_m
operator|=
name|m
operator|=
name|rx
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|cx
operator|->
name|sb_s
operator|=
name|rx
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
name|cx
operator|->
name|sb_rxtainted
operator||=
name|RX_MATCH_TAINTED
argument_list|(
name|rx
argument_list|)
expr_stmt|;
name|rxres_save
argument_list|(
operator|&
name|cx
operator|->
name|sb_rxres
argument_list|,
name|rx
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|pm
operator|->
name|op_pmreplstart
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|rxres_save
parameter_list|(
name|void
modifier|*
modifier|*
name|rsp
parameter_list|,
name|REGEXP
modifier|*
name|rx
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
name|U32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|p
index|[
literal|1
index|]
operator|<
name|rx
operator|->
name|nparens
condition|)
block|{
name|i
operator|=
literal|6
operator|+
name|rx
operator|->
name|nparens
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|New
argument_list|(
literal|501
argument_list|,
name|p
argument_list|,
name|i
argument_list|,
name|UV
argument_list|)
expr_stmt|;
else|else
name|Renew
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|UV
argument_list|)
expr_stmt|;
operator|*
name|rsp
operator|=
operator|(
name|void
operator|*
operator|)
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|subbase
expr_stmt|;
name|rx
operator|->
name|subbase
operator|=
name|Nullch
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rx
operator|->
name|nparens
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|subbeg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|subend
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|startp
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|UV
operator|)
name|rx
operator|->
name|endp
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rxres_restore
parameter_list|(
name|void
modifier|*
modifier|*
name|rsp
parameter_list|,
name|REGEXP
modifier|*
name|rx
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
name|U32
name|i
decl_stmt|;
name|Safefree
argument_list|(
name|rx
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|rx
operator|->
name|subbase
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|rx
operator|->
name|nparens
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|rx
operator|->
name|subbeg
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|++
operator|)
expr_stmt|;
name|rx
operator|->
name|subend
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|++
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rx
operator|->
name|nparens
condition|;
operator|++
name|i
control|)
block|{
name|rx
operator|->
name|startp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|++
operator|)
expr_stmt|;
name|rx
operator|->
name|endp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rxres_free
parameter_list|(
name|void
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|UV
modifier|*
name|p
init|=
operator|(
name|UV
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|Safefree
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|rsp
operator|=
name|Null
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_formline
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
name|tmpForm
init|=
operator|*
operator|++
name|MARK
decl_stmt|;
specifier|register
name|U16
modifier|*
name|fpc
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|I32
name|arg
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|item
decl_stmt|;
name|I32
name|itemsize
decl_stmt|;
name|I32
name|fieldsize
decl_stmt|;
name|I32
name|lines
init|=
literal|0
decl_stmt|;
name|bool
name|chopspace
init|=
operator|(
name|strchr
argument_list|(
name|PL_chopset
argument_list|,
literal|' '
argument_list|)
operator|!=
name|Nullch
operator|)
decl_stmt|;
name|char
modifier|*
name|chophere
decl_stmt|;
name|char
modifier|*
name|linemark
decl_stmt|;
name|double
name|value
decl_stmt|;
name|bool
name|gotsome
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|SvMAGICAL
argument_list|(
name|tmpForm
argument_list|)
operator|||
operator|!
name|SvCOMPILED
argument_list|(
name|tmpForm
argument_list|)
condition|)
block|{
name|SvREADONLY_off
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
name|doparseform
argument_list|(
name|tmpForm
argument_list|)
expr_stmt|;
block|}
name|SvPV_force
argument_list|(
name|PL_formtarget
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvGROW
argument_list|(
name|PL_formtarget
argument_list|,
name|len
operator|+
name|SvCUR
argument_list|(
name|tmpForm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX SvCUR bad */
name|t
operator|+=
name|len
expr_stmt|;
name|f
operator|=
name|SvPV
argument_list|(
name|tmpForm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* need to jump to the next word */
name|s
operator|=
name|f
operator|+
name|len
operator|+
name|WORD_ALIGN
operator|-
name|SvCUR
argument_list|(
name|tmpForm
argument_list|)
operator|%
name|WORD_ALIGN
expr_stmt|;
name|fpc
operator|=
operator|(
name|U16
operator|*
operator|)
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DEBUG_f
argument_list|(
argument|{ 	    char *name =
literal|"???"
argument|; 	    arg = -
literal|1
argument|; 	    switch (*fpc) { 	    case FF_LITERAL:	arg = fpc[
literal|1
argument|]; name =
literal|"LITERAL"
argument|;	break; 	    case FF_BLANK:	arg = fpc[
literal|1
argument|]; name =
literal|"BLANK"
argument|;	break; 	    case FF_SKIP:	arg = fpc[
literal|1
argument|]; name =
literal|"SKIP"
argument|;	break; 	    case FF_FETCH:	arg = fpc[
literal|1
argument|]; name =
literal|"FETCH"
argument|;	break; 	    case FF_DECIMAL:	arg = fpc[
literal|1
argument|]; name =
literal|"DECIMAL"
argument|;	break;  	    case FF_CHECKNL:	name =
literal|"CHECKNL"
argument|;	break; 	    case FF_CHECKCHOP:	name =
literal|"CHECKCHOP"
argument|;	break; 	    case FF_SPACE:	name =
literal|"SPACE"
argument|;		break; 	    case FF_HALFSPACE:	name =
literal|"HALFSPACE"
argument|;	break; 	    case FF_ITEM:	name =
literal|"ITEM"
argument|;		break; 	    case FF_CHOP:	name =
literal|"CHOP"
argument|;		break; 	    case FF_LINEGLOB:	name =
literal|"LINEGLOB"
argument|;	break; 	    case FF_NEWLINE:	name =
literal|"NEWLINE"
argument|;	break; 	    case FF_MORE:	name =
literal|"MORE"
argument|;		break; 	    case FF_LINEMARK:	name =
literal|"LINEMARK"
argument|;	break; 	    case FF_END:	name =
literal|"END"
argument|;		break; 	    } 	    if (arg>=
literal|0
argument|) 		PerlIO_printf(PerlIO_stderr(),
literal|"%-16s%ld\n"
argument|, name, (long) arg); 	    else 		PerlIO_printf(PerlIO_stderr(),
literal|"%-16s\n"
argument|, name); 	}
argument_list|)
switch|switch
condition|(
operator|*
name|fpc
operator|++
condition|)
block|{
case|case
name|FF_LINEMARK
case|:
name|linemark
operator|=
name|t
expr_stmt|;
name|lines
operator|++
expr_stmt|;
name|gotsome
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|FF_LITERAL
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
while|while
condition|(
name|arg
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
break|break;
case|case
name|FF_SKIP
case|:
name|f
operator|+=
operator|*
name|fpc
operator|++
expr_stmt|;
break|break;
case|case
name|FF_FETCH
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
name|f
operator|+=
name|arg
expr_stmt|;
name|fieldsize
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
name|sv
operator|=
operator|*
operator|++
name|MARK
expr_stmt|;
else|else
block|{
name|sv
operator|=
operator|&
name|PL_sv_no
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Not enough format arguments"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FF_CHECKNL
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|itemsize
operator|>
name|fieldsize
condition|)
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
break|break;
case|case
name|FF_CHECKCHOP
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|itemsize
operator|<=
name|fieldsize
condition|)
block|{
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
block|{
name|itemsize
operator|=
name|s
operator|-
name|item
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|++
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|itemsize
operator|=
name|fieldsize
expr_stmt|;
name|send
operator|=
name|chophere
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|||
operator|(
name|s
operator|==
name|send
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|chopspace
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|&
operator|~
literal|31
condition|)
name|gotsome
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|PL_chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|itemsize
operator|=
name|chophere
operator|-
name|item
expr_stmt|;
block|}
break|break;
case|case
name|FF_SPACE
case|:
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_HALFSPACE
case|:
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|arg
operator|/=
literal|2
expr_stmt|;
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_ITEM
case|:
name|arg
operator|=
name|itemsize
expr_stmt|;
name|s
operator|=
name|item
expr_stmt|;
while|while
condition|(
name|arg
operator|--
condition|)
block|{
ifdef|#
directive|ifdef
name|EBCDIC
name|int
name|ch
init|=
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|iscntrl
argument_list|(
name|ch
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|&
operator|~
literal|31
operator|)
condition|)
endif|#
directive|endif
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|FF_CHOP
case|:
name|s
operator|=
name|chophere
expr_stmt|;
if|if
condition|(
name|chopspace
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|sv_chop
argument_list|(
name|sv
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|FF_LINEGLOB
case|:
name|item
operator|=
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|itemsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|itemsize
condition|)
block|{
name|gotsome
operator|=
name|TRUE
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|itemsize
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|send
condition|)
name|itemsize
operator|--
expr_stmt|;
else|else
name|lines
operator|++
expr_stmt|;
block|}
block|}
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|PL_formtarget
argument_list|,
name|item
argument_list|,
name|itemsize
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|PL_formtarget
argument_list|,
name|SvCUR
argument_list|(
name|PL_formtarget
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|tmpForm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|PL_formtarget
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FF_DECIMAL
case|:
comment|/* If the field is marked with ^ and the value is undefined, 	       blank it out. */
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|&
literal|512
operator|)
operator|&&
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|arg
operator|=
name|fieldsize
expr_stmt|;
while|while
condition|(
name|arg
operator|--
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
name|gotsome
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|SvNV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Formats aren't yet marked for locales, so assume "yes". */
name|SET_NUMERIC_LOCAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|&
literal|256
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%#*.*f"
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
operator|(
name|int
operator|)
name|arg
operator|&
literal|255
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%*.0f"
argument_list|,
operator|(
name|int
operator|)
name|fieldsize
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|t
operator|+=
name|fieldsize
expr_stmt|;
break|break;
case|case
name|FF_NEWLINE
case|:
name|f
operator|++
expr_stmt|;
while|while
condition|(
name|t
operator|--
operator|>
name|linemark
operator|&&
operator|*
name|t
operator|==
literal|' '
condition|)
empty_stmt|;
name|t
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
name|FF_BLANK
case|:
name|arg
operator|=
operator|*
name|fpc
operator|++
expr_stmt|;
if|if
condition|(
name|gotsome
condition|)
block|{
if|if
condition|(
name|arg
condition|)
block|{
comment|/* repeat until fields exhausted? */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|lines
operator|+=
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|==
literal|200
condition|)
block|{
name|arg
operator|=
name|t
operator|-
name|linemark
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|linemark
argument_list|,
name|linemark
operator|-
name|arg
argument_list|,
name|arg
argument_list|)
condition|)
name|DIE
argument_list|(
literal|"Runaway format"
argument_list|)
expr_stmt|;
block|}
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|=
name|lines
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETURNOP
argument_list|(
name|cLISTOP
operator|->
name|op_first
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|linemark
expr_stmt|;
name|lines
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|FF_MORE
case|:
name|s
operator|=
name|chophere
expr_stmt|;
name|send
operator|=
name|item
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|chopspace
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|s
operator|<
name|send
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|arg
operator|=
name|fieldsize
operator|-
name|itemsize
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|fieldsize
operator|-=
name|arg
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|s
operator|=
name|t
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
condition|)
block|{
while|while
condition|(
name|s
operator|>
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
operator|&&
name|isSPACE
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|s
operator|--
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
break|break;
case|case
name|FF_END
case|:
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_formtarget
argument_list|,
name|t
operator|-
name|SvPVX
argument_list|(
name|PL_formtarget
argument_list|)
argument_list|)
expr_stmt|;
name|FmLINES
argument_list|(
name|PL_formtarget
argument_list|)
operator|+=
name|lines
expr_stmt|;
name|SP
operator|=
name|ORIGMARK
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_grepstart
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|SV
modifier|*
name|src
decl_stmt|;
if|if
condition|(
name|PL_stack_base
operator|+
operator|*
name|PL_markstack_ptr
operator|==
name|SP
condition|)
block|{
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
if|if
condition|(
name|GIMME_V
operator|==
name|G_SCALAR
condition|)
name|XPUSHs
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|PL_op
operator|->
name|op_next
operator|->
name|op_next
argument_list|)
expr_stmt|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
operator|*
name|PL_markstack_ptr
operator|+
literal|1
expr_stmt|;
name|pp_pushmark
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
comment|/* push dst */
name|pp_pushmark
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
comment|/* push src */
name|ENTER
expr_stmt|;
comment|/* enter outer scope */
name|SAVETMPS
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
comment|/* SAVE_DEFSV does *not* suffice here */
name|save_sptr
argument_list|(
operator|&
name|THREADSV
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|PL_defgv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|ENTER
expr_stmt|;
comment|/* enter inner scope */
name|SAVESPTR
argument_list|(
name|PL_curpm
argument_list|)
expr_stmt|;
name|src
operator|=
name|PL_stack_base
index|[
operator|*
name|PL_markstack_ptr
index|]
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|src
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_MAPSTART
condition|)
name|pp_pushmark
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
comment|/* push top */
return|return
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|PL_op
operator|->
name|op_next
operator|)
operator|->
name|op_other
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_mapstart
argument_list|)
end_macro

begin_block
block|{
name|DIE
argument_list|(
literal|"panic: mapstart"
argument_list|)
expr_stmt|;
comment|/* uses grepstart */
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_mapwhile
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|I32
name|diff
init|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
operator|*
name|PL_markstack_ptr
decl_stmt|;
name|I32
name|count
decl_stmt|;
name|I32
name|shift
decl_stmt|;
name|SV
modifier|*
modifier|*
name|src
decl_stmt|;
name|SV
modifier|*
modifier|*
name|dst
decl_stmt|;
operator|++
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|diff
operator|>
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
condition|)
block|{
name|shift
operator|=
name|diff
operator|-
operator|(
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|count
operator|=
operator|(
name|SP
operator|-
name|PL_stack_base
operator|)
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|+
literal|2
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|src
operator|=
name|SP
expr_stmt|;
name|dst
operator|=
operator|(
name|SP
operator|+=
name|shift
operator|)
expr_stmt|;
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|+=
name|shift
expr_stmt|;
operator|*
name|PL_markstack_ptr
operator|+=
name|shift
expr_stmt|;
while|while
condition|(
operator|--
name|count
condition|)
operator|*
name|dst
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
block|}
name|dst
operator|=
name|PL_stack_base
operator|+
operator|(
name|PL_markstack_ptr
index|[
operator|-
literal|2
index|]
operator|+=
name|diff
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|diff
expr_stmt|;
while|while
condition|(
operator|--
name|diff
condition|)
operator|*
name|dst
operator|--
operator|=
name|SvTEMP
argument_list|(
name|TOPs
argument_list|)
condition|?
name|POPs
else|:
name|sv_mortalcopy
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
comment|/* exit inner scope */
comment|/* All done yet? */
if|if
condition|(
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
operator|>
operator|*
name|PL_markstack_ptr
condition|)
block|{
name|I32
name|items
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop top */
name|LEAVE
expr_stmt|;
comment|/* exit outer scope */
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop src */
name|items
operator|=
operator|--
operator|*
name|PL_markstack_ptr
operator|-
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|POPMARK
expr_stmt|;
comment|/* pop dst */
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|dTARGET
expr_stmt|;
name|XPUSHi
argument_list|(
name|items
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|SP
operator|+=
name|items
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|src
decl_stmt|;
name|ENTER
expr_stmt|;
comment|/* enter inner scope */
name|SAVESPTR
argument_list|(
name|PL_curpm
argument_list|)
expr_stmt|;
name|src
operator|=
name|PL_stack_base
index|[
name|PL_markstack_ptr
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|src
expr_stmt|;
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|tryCALL_AMAGICbin
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|meth
parameter_list|,
name|svp
parameter_list|)
value|STMT_START { \ 	  *svp = Nullsv;				\           if (PL_amagic_generation) { \ 	    if (SvAMAGIC(left)||SvAMAGIC(right))\ 		*svp = amagic_call(left, \ 				   right, \ 				   CAT2(meth,_amg), \ 				   0); \ 	  } \ 	} STMT_END
end_define

begin_function
name|STATIC
name|I32
name|amagic_cmp
parameter_list|(
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|scmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|double
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_cmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|amagic_cmp_locale
parameter_list|(
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|tryCALL_AMAGICbin
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|,
name|scmp
argument_list|,
operator|&
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpsv
condition|)
block|{
name|double
name|d
decl_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|tmpsv
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|SvIVX
argument_list|(
name|tmpsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|i
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|d
operator|=
name|SvNV
argument_list|(
name|tmpsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|d
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
return|return
name|sv_cmp_locale
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_sort
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|dORIGMARK
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|up
decl_stmt|;
name|SV
modifier|*
modifier|*
name|myorigmark
init|=
name|ORIGMARK
decl_stmt|;
specifier|register
name|I32
name|max
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME
decl_stmt|;
name|OP
modifier|*
name|nextop
init|=
name|PL_op
operator|->
name|op_next
decl_stmt|;
name|I32
name|overloading
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|SP
operator|=
name|MARK
expr_stmt|;
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|ENTER
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_sortcop
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOP
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* pass pushmark */
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* pass rv2gv */
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* pass leave */
name|PL_sortcop
operator|=
name|kid
operator|->
name|op_next
expr_stmt|;
name|stash
operator|=
name|PL_curcop
operator|->
name|cop_stash
expr_stmt|;
block|}
else|else
block|{
name|cv
operator|=
name|sv_2cv
argument_list|(
operator|*
operator|++
name|MARK
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cv
operator|&&
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|gv
condition|)
block|{
name|SV
modifier|*
name|tmpstr
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
name|DIE
argument_list|(
literal|"Xsub \"%s\" called in sort"
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
literal|"Undefined sort subroutine \"%s\" called"
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cv
condition|)
block|{
if|if
condition|(
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
name|DIE
argument_list|(
literal|"Xsub called in sort"
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
literal|"Undefined subroutine in sort"
argument_list|)
expr_stmt|;
block|}
name|DIE
argument_list|(
literal|"Not a CODE reference in sort"
argument_list|)
expr_stmt|;
block|}
name|PL_sortcop
operator|=
name|CvSTART
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_ppaddr
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PL_sortcop
operator|=
name|Nullop
expr_stmt|;
name|stash
operator|=
name|PL_curcop
operator|->
name|cop_stash
expr_stmt|;
block|}
name|up
operator|=
name|myorigmark
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
comment|/* This may or may not shift down one here. */
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|*
name|up
operator|=
operator|*
operator|++
name|MARK
condition|)
block|{
comment|/* Weed out nulls. */
name|SvTEMP_off
argument_list|(
operator|*
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_sortcop
operator|&&
operator|!
name|SvPOK
argument_list|(
operator|*
name|up
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvAMAGIC
argument_list|(
operator|*
name|up
argument_list|)
condition|)
name|overloading
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|STRLEN
name|n_a
decl_stmt|;
operator|(
name|void
operator|)
name|sv_2pv
argument_list|(
operator|*
name|up
argument_list|,
operator|&
name|n_a
argument_list|)
expr_stmt|;
block|}
block|}
name|up
operator|++
expr_stmt|;
block|}
block|}
name|max
operator|=
operator|--
name|up
operator|-
name|myorigmark
expr_stmt|;
if|if
condition|(
name|PL_sortcop
condition|)
block|{
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|SAVETMPS
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_SORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_sortstash
operator|!=
name|stash
condition|)
block|{
name|PL_firstgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"a"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|PL_secondgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"b"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|PL_sortstash
operator|=
name|stash
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|PL_firstgv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|PL_secondgv
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_NULL
argument_list|,
name|PL_stack_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
block|{
name|bool
name|hasargs
init|=
name|FALSE
decl_stmt|;
name|cx
operator|->
name|cx_type
operator|=
name|CXt_SUB
expr_stmt|;
name|cx
operator|->
name|blk_gimme
operator|=
name|G_SCALAR
expr_stmt|;
name|PUSHSUB
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
comment|/* in preparation for POPSUB */
block|}
name|PL_sortcxix
operator|=
name|cxstack_ix
expr_stmt|;
name|qsortsv
argument_list|(
operator|(
name|myorigmark
operator|+
literal|1
operator|)
argument_list|,
name|max
argument_list|,
name|FUNC_NAME_TO_PTR
argument_list|(
name|sortcv
argument_list|)
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|max
operator|>
literal|1
condition|)
block|{
name|MEXTEND
argument_list|(
name|SP
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Can't afford stack realloc on signal. */
name|qsortsv
argument_list|(
name|ORIGMARK
operator|+
literal|1
argument_list|,
name|max
argument_list|,
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpLOCALE
operator|)
condition|?
operator|(
name|overloading
condition|?
name|FUNC_NAME_TO_PTR
argument_list|(
name|amagic_cmp_locale
argument_list|)
else|:
name|FUNC_NAME_TO_PTR
argument_list|(
name|sv_cmp_locale
argument_list|)
operator|)
else|:
operator|(
name|overloading
condition|?
name|FUNC_NAME_TO_PTR
argument_list|(
name|amagic_cmp
argument_list|)
else|:
name|FUNC_NAME_TO_PTR
argument_list|(
name|sv_cmp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LEAVE
expr_stmt|;
name|PL_stack_sp
operator|=
name|ORIGMARK
operator|+
name|max
expr_stmt|;
return|return
name|nextop
return|;
block|}
end_block

begin_comment
comment|/* Range stuff. */
end_comment

begin_macro
name|PP
argument_list|(
argument|pp_range
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
return|return
name|cCONDOP
operator|->
name|op_true
return|;
return|return
name|SvTRUEx
argument_list|(
name|PAD_SV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
argument_list|)
condition|?
name|cCONDOP
operator|->
name|op_false
else|:
name|cCONDOP
operator|->
name|op_true
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_flip
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|RETURNOP
argument_list|(
operator|(
operator|(
name|CONDOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|targ
init|=
name|PAD_SV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpFLIP_LINENUM
operator|)
condition|?
operator|(
name|PL_last_in_gv
operator|&&
name|SvIV
argument_list|(
name|sv
argument_list|)
operator|==
operator|(
name|IV
operator|)
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
operator|)
else|:
name|SvTRUE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_setiv
argument_list|(
name|PAD_SV
argument_list|(
name|cUNOP
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|sv_setiv
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
else|else
block|{
name|sv_setiv
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|--
expr_stmt|;
name|RETURNOP
argument_list|(
operator|(
operator|(
name|CONDOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_false
argument_list|)
expr_stmt|;
block|}
block|}
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_flop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
name|GIMME
operator|==
name|G_ARRAY
condition|)
block|{
name|dPOPPOPssrl
expr_stmt|;
specifier|register
name|I32
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|max
decl_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|left
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|left
argument_list|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|left
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|left
argument_list|)
operator|!=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|SvNV
argument_list|(
name|left
argument_list|)
operator|<
name|IV_MIN
operator|||
name|SvNV
argument_list|(
name|right
argument_list|)
operator|>
name|IV_MAX
condition|)
name|croak
argument_list|(
literal|"Range iterator outside integer range"
argument_list|)
expr_stmt|;
name|i
operator|=
name|SvIV
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|max
operator|=
name|SvIV
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>=
name|i
condition|)
block|{
name|j
operator|=
name|max
operator|-
name|i
operator|+
literal|1
expr_stmt|;
name|EXTEND_MORTAL
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|i
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|final
init|=
name|sv_mortalcopy
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|tmps
init|=
name|SvPV
argument_list|(
name|final
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|sv
operator|=
name|sv_mortalcopy
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|<=
name|len
condition|)
block|{
name|XPUSHs
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|tmps
argument_list|)
condition|)
break|break;
name|sv
operator|=
name|sv_2mortal
argument_list|(
name|newSVsv
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|dTOPss
expr_stmt|;
name|SV
modifier|*
name|targ
init|=
name|PAD_SV
argument_list|(
name|cUNOP
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
decl_stmt|;
name|sv_inc
argument_list|(
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_op
operator|->
name|op_private
operator|&
name|OPpFLIP_LINENUM
operator|)
condition|?
operator|(
name|PL_last_in_gv
operator|&&
name|SvIV
argument_list|(
name|sv
argument_list|)
operator|==
operator|(
name|IV
operator|)
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
operator|)
else|:
name|SvTRUE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_setiv
argument_list|(
name|PAD_SV
argument_list|(
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cUNOP
operator|->
name|op_first
operator|)
operator|->
name|op_first
operator|->
name|op_targ
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|targ
argument_list|,
literal|"E0"
argument_list|)
expr_stmt|;
block|}
name|SETs
argument_list|(
name|targ
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Control. */
end_comment

begin_function
name|STATIC
name|I32
name|dopoptolabel
parameter_list|(
name|char
modifier|*
name|label
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cxstack_ix
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting substitution via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting subroutine via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting eval via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting pseudo-block via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|CXt_LOOP
case|:
if|if
condition|(
operator|!
name|cx
operator|->
name|blk_loop
operator|.
name|label
operator|||
name|strNE
argument_list|(
name|label
argument_list|,
name|cx
operator|->
name|blk_loop
operator|.
name|label
argument_list|)
condition|)
block|{
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"(Skipping label #%ld %s)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|cx
operator|->
name|blk_loop
operator|.
name|label
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"(Found label #%ld %s)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|I32
name|dowantarray
parameter_list|(
name|void
parameter_list|)
block|{
name|I32
name|gimme
init|=
name|block_gimme
argument_list|()
decl_stmt|;
return|return
operator|(
name|gimme
operator|==
name|G_VOID
operator|)
condition|?
name|G_SCALAR
else|:
name|gimme
return|;
block|}
end_function

begin_function
name|I32
name|block_gimme
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
return|return
name|G_VOID
return|;
switch|switch
condition|(
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
condition|)
block|{
case|case
name|G_VOID
case|:
return|return
name|G_VOID
return|;
case|case
name|G_SCALAR
case|:
return|return
name|G_SCALAR
return|;
case|case
name|G_ARRAY
case|:
return|return
name|G_ARRAY
return|;
default|default:
name|croak
argument_list|(
literal|"panic: bad gimme: %d\n"
argument_list|,
name|cxstack
index|[
name|cxix
index|]
operator|.
name|blk_gimme
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|STATIC
name|I32
name|dopoptosub
parameter_list|(
name|I32
name|startingblock
parameter_list|)
block|{
name|dTHR
expr_stmt|;
return|return
name|dopoptosub_at
argument_list|(
name|cxstack
argument_list|,
name|startingblock
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|dopoptosub_at
parameter_list|(
name|PERL_CONTEXT
modifier|*
name|cxstk
parameter_list|,
name|I32
name|startingblock
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstk
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
name|CXt_EVAL
case|:
case|case
name|CXt_SUB
case|:
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"(Found sub #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|dopoptoeval
parameter_list|(
name|I32
name|startingblock
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
name|CXt_EVAL
case|:
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"(Found eval #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|dopoptoloop
parameter_list|(
name|I32
name|startingblock
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|startingblock
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting substitution via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting subroutine via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting eval via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Exiting pseudo-block via %s"
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|CXt_LOOP
case|:
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"(Found loop #%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|dounwind
parameter_list|(
name|I32
name|cxix
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|optype
decl_stmt|;
while|while
condition|(
name|cxstack_ix
operator|>
name|cxix
condition|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|cxstack_ix
index|]
expr_stmt|;
name|DEBUG_l
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Unwinding block %ld, type %s\n"
argument_list|,
operator|(
name|long
operator|)
name|cxstack_ix
argument_list|,
name|block_type
index|[
name|CxTYPE
argument_list|(
name|cx
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: we don't need to restore the base context info till the end. */
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUBST
case|:
name|POPSUBST
argument_list|(
name|cx
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not break */
case|case
name|CXt_SUB
case|:
name|POPSUB
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_LOOP
case|:
name|POPLOOP
argument_list|(
name|cx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXt_NULL
case|:
break|break;
block|}
name|cxstack_ix
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|die_where
parameter_list|(
name|char
modifier|*
name|message
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
if|if
condition|(
name|message
condition|)
block|{
if|if
condition|(
name|PL_in_eval
operator|&
literal|4
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|STRLEN
name|klen
init|=
name|strlen
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|svp
operator|=
name|hv_fetch
argument_list|(
name|ERRHV
argument_list|,
name|message
argument_list|,
name|klen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
block|{
if|if
condition|(
operator|!
name|SvIOK
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
block|{
specifier|static
name|char
name|prefix
index|[]
init|=
literal|"\t(in cleanup) "
decl_stmt|;
name|SV
modifier|*
name|err
init|=
name|ERRSV
decl_stmt|;
name|sv_upgrade
argument_list|(
operator|*
name|svp
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|err
argument_list|)
condition|)
name|sv_setpv
argument_list|(
name|err
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|err
argument_list|,
name|SvCUR
argument_list|(
name|err
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|+
name|klen
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|err
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|err
argument_list|,
name|message
argument_list|,
name|klen
argument_list|)
expr_stmt|;
block|}
name|sv_inc
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
name|message
operator|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cxix
operator|=
name|dopoptoeval
argument_list|(
name|cxstack_ix
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|PL_curstackinfo
operator|->
name|si_prev
condition|)
block|{
name|dounwind
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|>=
literal|0
condition|)
block|{
name|I32
name|optype
decl_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|!=
name|CXt_EVAL
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"panic: die %s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|PL_stack_sp
operator|=
name|newsp
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|DIE
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Compilation failed in require"
argument_list|)
expr_stmt|;
block|}
return|return
name|pop_return
argument_list|()
return|;
block|}
block|}
if|if
condition|(
operator|!
name|message
condition|)
name|message
operator|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|PerlIO_flush
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|)
expr_stmt|;
name|my_failure_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_xor
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dPOPTOPssrl
expr_stmt|;
if|if
condition|(
name|SvTRUE
argument_list|(
name|left
argument_list|)
operator|!=
name|SvTRUE
argument_list|(
name|right
argument_list|)
condition|)
name|RETSETYES
expr_stmt|;
else|else
name|RETSETNO
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_andassign
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
operator|!
name|SvTRUE
argument_list|(
name|TOPs
argument_list|)
condition|)
name|RETURN
expr_stmt|;
else|else
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_orassign
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
if|if
condition|(
name|SvTRUE
argument_list|(
name|TOPs
argument_list|)
condition|)
name|RETURN
expr_stmt|;
else|else
name|RETURNOP
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_caller
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|I32
name|cxix
init|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|ccstack
init|=
name|cxstack
decl_stmt|;
name|PERL_SI
modifier|*
name|top_si
init|=
name|PL_curstackinfo
decl_stmt|;
name|I32
name|dbcxix
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MAXARG
condition|)
name|count
operator|=
name|POPi
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* we may be in a higher stacklevel, so dig down deeper */
while|while
condition|(
name|cxix
operator|<
literal|0
operator|&&
name|top_si
operator|->
name|si_type
operator|!=
name|PERLSI_MAIN
condition|)
block|{
name|top_si
operator|=
name|top_si
operator|->
name|si_prev
expr_stmt|;
name|ccstack
operator|=
name|top_si
operator|->
name|si_cxstack
expr_stmt|;
name|cxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|top_si
operator|->
name|si_cxix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
if|if
condition|(
name|PL_DBsub
operator|&&
name|cxix
operator|>=
literal|0
operator|&&
name|ccstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
operator|==
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|--
condition|)
break|break;
name|cxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|cxix
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cx
operator|=
operator|&
name|ccstack
index|[
name|cxix
index|]
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
condition|)
block|{
name|dbcxix
operator|=
name|dopoptosub_at
argument_list|(
name|ccstack
argument_list|,
name|cxix
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the 	   field below is defined for any cx. */
if|if
condition|(
name|PL_DBsub
operator|&&
name|dbcxix
operator|>=
literal|0
operator|&&
name|ccstack
index|[
name|dbcxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
operator|==
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
condition|)
name|cx
operator|=
operator|&
name|ccstack
index|[
name|dbcxix
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GIMME
operator|!=
name|G_ARRAY
condition|)
block|{
name|hv
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_stash
expr_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
block|{
name|dTARGET
expr_stmt|;
name|sv_setpv
argument_list|(
name|TARG
argument_list|,
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|TARG
argument_list|)
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
name|hv
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_stash
expr_stmt|;
if|if
condition|(
operator|!
name|hv
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|HvNAME
argument_list|(
name|hv
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|SvPVX
argument_list|(
name|GvSV
argument_list|(
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_filegv
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_line
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MAXARG
condition|)
name|RETURN
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
condition|)
block|{
comment|/* So is ccstack[dbcxix]. */
name|sv
operator|=
name|NEWSV
argument_list|(
literal|49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|CvGV
argument_list|(
name|ccstack
index|[
name|cxix
index|]
operator|.
name|blk_sub
operator|.
name|cv
argument_list|)
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
literal|"(eval)"
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimme
operator|=
operator|(
name|I32
operator|)
name|cx
operator|->
name|blk_gimme
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
else|else
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSViv
argument_list|(
name|gimme
operator|&
name|G_ARRAY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
operator|==
name|OP_ENTEREVAL
condition|)
block|{
name|PUSHs
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|cur_text
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_name
condition|)
block|{
comment|/* Try blocks have old_name == 0. */
comment|/* Require, put the name. */
name|PUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|&&
name|PL_curcop
operator|->
name|cop_stash
operator|==
name|PL_debstash
condition|)
block|{
name|AV
modifier|*
name|ary
init|=
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
decl_stmt|;
name|int
name|off
init|=
name|AvARRAY
argument_list|(
name|ary
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|ary
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PL_dbargs
condition|)
block|{
name|GV
modifier|*
name|tmpgv
decl_stmt|;
name|PL_dbargs
operator|=
name|GvAV
argument_list|(
name|gv_AVadd
argument_list|(
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"DB::args"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|tmpgv
argument_list|)
expr_stmt|;
name|AvREAL_off
argument_list|(
name|PL_dbargs
argument_list|)
expr_stmt|;
comment|/* XXX Should be REIFY */
block|}
if|if
condition|(
name|AvMAX
argument_list|(
name|PL_dbargs
argument_list|)
operator|<
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
condition|)
name|av_extend
argument_list|(
name|PL_dbargs
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvALLOC
argument_list|(
name|ary
argument_list|)
argument_list|,
name|AvARRAY
argument_list|(
name|PL_dbargs
argument_list|)
argument_list|,
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
literal|1
operator|+
name|off
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|PL_dbargs
argument_list|)
operator|=
name|AvFILLp
argument_list|(
name|ary
argument_list|)
operator|+
name|off
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|I32
name|sortcv
parameter_list|(
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|oldsaveix
init|=
name|PL_savestack_ix
decl_stmt|;
name|I32
name|oldscopeix
init|=
name|PL_scopestack_ix
decl_stmt|;
name|I32
name|result
decl_stmt|;
name|GvSV
argument_list|(
name|PL_firstgv
argument_list|)
operator|=
name|a
expr_stmt|;
name|GvSV
argument_list|(
name|PL_secondgv
argument_list|)
operator|=
name|b
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
expr_stmt|;
name|PL_op
operator|=
name|PL_sortcop
expr_stmt|;
name|CALLRUNOPS
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_stack_sp
operator|!=
name|PL_stack_base
operator|+
literal|1
condition|)
name|croak
argument_list|(
literal|"Sort subroutine didn't return single value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvNIOKp
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Sort subroutine didn't return a numeric value"
argument_list|)
expr_stmt|;
name|result
operator|=
name|SvIV
argument_list|(
operator|*
name|PL_stack_sp
argument_list|)
expr_stmt|;
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscopeix
condition|)
block|{
name|LEAVE
expr_stmt|;
block|}
name|leave_scope
argument_list|(
name|oldsaveix
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_reset
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|tmps
operator|=
literal|""
expr_stmt|;
else|else
name|tmps
operator|=
name|POPpx
expr_stmt|;
name|sv_reset
argument_list|(
name|tmps
argument_list|,
name|PL_curcop
operator|->
name|cop_stash
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_lineseq
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_dbstate
argument_list|)
end_macro

begin_block
block|{
name|PL_curcop
operator|=
operator|(
name|COP
operator|*
operator|)
name|PL_op
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each statement is presumed innocent */
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
expr_stmt|;
name|FREETMPS
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_private
operator|||
name|SvIV
argument_list|(
name|PL_DBsingle
argument_list|)
operator|||
name|SvIV
argument_list|(
name|PL_DBsignal
argument_list|)
operator|||
name|SvIV
argument_list|(
name|PL_DBtrace
argument_list|)
condition|)
block|{
name|djSP
expr_stmt|;
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|G_ARRAY
decl_stmt|;
name|I32
name|hasargs
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|gv
operator|=
name|PL_DBgv
expr_stmt|;
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
name|DIE
argument_list|(
literal|"No DB::DB routine defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|>=
literal|1
operator|&&
operator|!
operator|(
name|PL_debug
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|)
condition|)
comment|/* don't do recursive DB::DB call */
return|return
name|NORMAL
return|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_debug
argument_list|)
expr_stmt|;
name|SAVESTACK_POS
argument_list|()
expr_stmt|;
name|PL_debug
operator|=
literal|0
expr_stmt|;
name|hasargs
operator|=
literal|0
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_SUB
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHSUB
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|RETURNOP
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_scope
argument_list|)
end_macro

begin_block
block|{
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_enteriter
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|dTHR
expr_stmt|;
name|svp
operator|=
operator|&
name|THREADSV
argument_list|(
name|PL_op
operator|->
name|op_targ
argument_list|)
expr_stmt|;
comment|/* per-thread variable */
name|SAVEGENERICSV
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|PL_op
operator|->
name|op_targ
condition|)
block|{
name|svp
operator|=
operator|&
name|PL_curpad
index|[
name|PL_op
operator|->
name|op_targ
index|]
expr_stmt|;
comment|/* "my" variable */
name|SAVESPTR
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svp
operator|=
operator|&
name|GvSV
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|POPs
argument_list|)
expr_stmt|;
comment|/* symbol table variable */
name|SAVEGENERICSV
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ENTER
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_LOOP
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHLOOP
argument_list|(
name|cx
argument_list|,
name|svp
argument_list|,
name|MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|!=
name|SVt_PVAV
condition|)
block|{
name|dPOPss
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
operator|||
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|<
name|IV_MIN
operator|||
name|SvNV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
operator|>=
name|IV_MAX
condition|)
name|croak
argument_list|(
literal|"Range iterator outside integer range"
argument_list|)
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|iterix
operator|=
name|SvIV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|itermax
operator|=
name|SvIV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
argument_list|)
expr_stmt|;
block|}
else|else
name|cx
operator|->
name|blk_loop
operator|.
name|iterlval
operator|=
name|newSVsv
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cx
operator|->
name|blk_loop
operator|.
name|iterary
operator|=
name|PL_curstack
expr_stmt|;
name|AvFILLp
argument_list|(
name|PL_curstack
argument_list|)
operator|=
name|SP
operator|-
name|PL_stack_base
expr_stmt|;
name|cx
operator|->
name|blk_loop
operator|.
name|iterix
operator|=
name|MARK
operator|-
name|PL_stack_base
expr_stmt|;
block|}
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_enterloop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|ENTER
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_LOOP
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHLOOP
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_leaveloop
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|struct
name|block_loop
name|cxloop
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|mark
operator|=
name|newsp
expr_stmt|;
name|POPLOOP1
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* Delay POPLOOP2 until stack values are safe */
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
empty_stmt|;
comment|/* do nothing */
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|mark
operator|<
name|SP
condition|)
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|mark
operator|<
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
operator|++
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|SP
operator|=
name|newsp
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|POPLOOP2
argument_list|()
expr_stmt|;
comment|/* Stack values are safe: release loop vars ... */
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return
name|NORMAL
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_return
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|dMARK
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|struct
name|block_sub
name|cxsub
decl_stmt|;
name|bool
name|popsub2
init|=
name|FALSE
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|optype
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
condition|)
block|{
if|if
condition|(
name|cxstack_ix
operator|==
name|PL_sortcxix
operator|||
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
operator|<=
name|PL_sortcxix
condition|)
block|{
if|if
condition|(
name|cxstack_ix
operator|>
name|PL_sortcxix
condition|)
name|dounwind
argument_list|(
name|PL_sortcxix
argument_list|)
expr_stmt|;
name|AvARRAY
argument_list|(
name|PL_curstack
argument_list|)
index|[
literal|1
index|]
operator|=
operator|*
name|SP
expr_stmt|;
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Can't return outside a subroutine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_SUB
case|:
name|POPSUB1
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* Delay POPSUB2 until stack values are safe */
name|popsub2
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
operator|&&
operator|(
name|MARK
operator|==
name|SP
operator|||
operator|(
name|gimme
operator|==
name|G_SCALAR
operator|&&
operator|!
name|SvTRUE
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Unassume the success we assumed earlier. */
name|char
modifier|*
name|name
init|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_name
decl_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
literal|"%s did not return a true value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|DIE
argument_list|(
literal|"panic: return"
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
block|{
if|if
condition|(
name|popsub2
condition|)
block|{
if|if
condition|(
name|cxsub
operator|.
name|cv
operator|&&
name|CvDEPTH
argument_list|(
name|cxsub
operator|.
name|cv
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|SvTEMP
argument_list|(
name|TOPs
argument_list|)
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
name|SvREFCNT_inc
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|sv_2mortal
argument_list|(
operator|*
name|newsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FREETMPS
expr_stmt|;
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
operator|(
name|SvTEMP
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
condition|?
operator|*
name|SP
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
operator|(
name|popsub2
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|MARK
argument_list|)
operator|)
condition|?
operator|*
name|MARK
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|PL_stack_sp
operator|=
name|newsp
expr_stmt|;
comment|/* Stack values are safe: */
if|if
condition|(
name|popsub2
condition|)
block|{
name|POPSUB2
argument_list|()
expr_stmt|;
comment|/* release CV and @_ ... */
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
return|return
name|pop_return
argument_list|()
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_last
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|struct
name|block_loop
name|cxloop
decl_stmt|;
name|struct
name|block_sub
name|cxsub
decl_stmt|;
name|I32
name|pop2
init|=
literal|0
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|OP
modifier|*
name|nextop
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
init|=
name|PL_stack_base
operator|+
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Can't \"last\" outside a block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Label not found for \"last %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_LOOP
case|:
name|POPLOOP1
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* Delay POPLOOP2 until stack values are safe */
name|pop2
operator|=
name|CXt_LOOP
expr_stmt|;
name|nextop
operator|=
name|cxloop
operator|.
name|last_op
operator|->
name|op_next
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
name|POPSUB1
argument_list|(
name|cx
argument_list|)
expr_stmt|;
comment|/* Delay POPSUB2 until stack values are safe */
name|pop2
operator|=
name|CXt_SUB
expr_stmt|;
name|nextop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
break|break;
case|case
name|CXt_EVAL
case|:
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|nextop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
break|break;
default|default:
name|DIE
argument_list|(
literal|"panic: last"
argument_list|)
expr_stmt|;
block|}
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
if|if
condition|(
name|MARK
operator|<
name|SP
condition|)
operator|*
operator|++
name|newsp
operator|=
operator|(
operator|(
name|pop2
operator|==
name|CXt_SUB
operator|)
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|SP
argument_list|)
operator|)
condition|?
operator|*
name|SP
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|SP
argument_list|)
expr_stmt|;
else|else
operator|*
operator|++
name|newsp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
while|while
condition|(
operator|++
name|MARK
operator|<=
name|SP
condition|)
block|{
operator|*
operator|++
name|newsp
operator|=
operator|(
operator|(
name|pop2
operator|==
name|CXt_SUB
operator|)
operator|&&
name|SvTEMP
argument_list|(
operator|*
name|MARK
argument_list|)
operator|)
condition|?
operator|*
name|MARK
else|:
name|sv_mortalcopy
argument_list|(
operator|*
name|MARK
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
name|SP
operator|=
name|newsp
expr_stmt|;
name|PUTBACK
expr_stmt|;
comment|/* Stack values are safe: */
switch|switch
condition|(
name|pop2
condition|)
block|{
case|case
name|CXt_LOOP
case|:
name|POPLOOP2
argument_list|()
expr_stmt|;
comment|/* release loop vars ... */
name|LEAVE
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
name|POPSUB2
argument_list|()
expr_stmt|;
comment|/* release CV and @_ ... */
break|break;
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* ... and pop $1 et al */
name|LEAVE
expr_stmt|;
return|return
name|nextop
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_next
argument_list|)
end_macro

begin_block
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|oldsave
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Can't \"next\" outside a block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Label not found for \"next %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
operator|-
literal|1
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
return|return
name|cx
operator|->
name|blk_loop
operator|.
name|next_op
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_redo
argument_list|)
end_macro

begin_block
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|oldsave
decl_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
name|cxix
operator|=
name|dopoptoloop
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Can't \"redo\" outside a block"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxix
operator|=
name|dopoptolabel
argument_list|(
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Label not found for \"redo %s\""
argument_list|,
name|cPVOP
operator|->
name|op_pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
operator|-
literal|1
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
return|return
name|cx
operator|->
name|blk_loop
operator|.
name|redo_op
return|;
block|}
end_block

begin_function
name|STATIC
name|OP
modifier|*
name|dofindlabel
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|OP
modifier|*
modifier|*
name|opstack
parameter_list|,
name|OP
modifier|*
modifier|*
name|oplimit
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
modifier|*
name|ops
init|=
name|opstack
decl_stmt|;
specifier|static
name|char
name|too_deep
index|[]
init|=
literal|"Target of goto is too deeply nested"
decl_stmt|;
if|if
condition|(
name|ops
operator|>=
name|oplimit
condition|)
name|croak
argument_list|(
name|too_deep
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVELOOP
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVETRY
condition|)
block|{
operator|*
name|ops
operator|++
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|ops
operator|>=
name|oplimit
condition|)
name|croak
argument_list|(
name|too_deep
argument_list|)
expr_stmt|;
block|}
operator|*
name|ops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|dTHR
expr_stmt|;
comment|/* First try all the kids at this level, since that's likeliest. */
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
operator|)
operator|&&
name|kCOP
operator|->
name|cop_label
operator|&&
name|strEQ
argument_list|(
name|kCOP
operator|->
name|cop_label
argument_list|,
name|label
argument_list|)
condition|)
return|return
name|kid
return|;
block|}
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|==
name|PL_lastgotoprobe
condition|)
continue|continue;
if|if
condition|(
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
operator|)
operator|&&
operator|(
name|ops
operator|==
name|opstack
operator|||
operator|(
name|ops
index|[
operator|-
literal|1
index|]
operator|->
name|op_type
operator|!=
name|OP_NEXTSTATE
operator|&&
name|ops
index|[
operator|-
literal|1
index|]
operator|->
name|op_type
operator|!=
name|OP_DBSTATE
operator|)
operator|)
condition|)
operator|*
name|ops
operator|++
operator|=
name|kid
expr_stmt|;
if|if
condition|(
name|o
operator|=
name|dofindlabel
argument_list|(
name|kid
argument_list|,
name|label
argument_list|,
name|ops
argument_list|,
name|oplimit
argument_list|)
condition|)
return|return
name|o
return|;
block|}
block|}
operator|*
name|ops
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_dump
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_goto
argument_list|(
name|ARGS
argument_list|)
return|;
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_goto
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|OP
modifier|*
name|retop
init|=
literal|0
decl_stmt|;
name|I32
name|ix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
define|#
directive|define
name|GOTO_DEPTH
value|64
name|OP
modifier|*
name|enterops
index|[
name|GOTO_DEPTH
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|do_dump
init|=
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_DUMP
operator|)
decl_stmt|;
name|label
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|POPs
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
comment|/* This egregious kludge implements goto&subroutine */
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|I32
name|cxix
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
operator|(
name|CV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|I32
name|items
init|=
literal|0
decl_stmt|;
name|I32
name|oldsave
decl_stmt|;
name|int
name|arg_was_real
init|=
literal|0
decl_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|&&
operator|!
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|CvGV
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|GV
modifier|*
name|autogv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
name|SV
modifier|*
name|tmpstr
decl_stmt|;
comment|/* autoloaded stub? */
if|if
condition|(
name|cv
operator|!=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
goto|goto
name|retry
goto|;
name|autogv
operator|=
name|gv_autoload4
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|autogv
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|autogv
argument_list|)
operator|)
condition|)
goto|goto
name|retry
goto|;
name|tmpstr
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
literal|"Goto undefined subroutine&%s"
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DIE
argument_list|(
literal|"Goto undefined subroutine"
argument_list|)
expr_stmt|;
block|}
comment|/* First do some returnish stuff. */
name|cxix
operator|=
name|dopoptosub
argument_list|(
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
literal|0
condition|)
name|DIE
argument_list|(
literal|"Can't goto subroutine outside a subroutine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxix
operator|<
name|cxstack_ix
condition|)
name|dounwind
argument_list|(
name|cxix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
operator|&&
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
operator|==
name|OP_ENTEREVAL
condition|)
name|DIE
argument_list|(
literal|"Can't goto subroutine from an eval-string"
argument_list|)
expr_stmt|;
name|mark
operator|=
name|PL_stack_sp
expr_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
comment|/* put @_ back onto stack */
name|AV
modifier|*
name|av
init|=
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
decl_stmt|;
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PL_stack_sp
operator|++
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
name|items
argument_list|)
expr_stmt|;
comment|/* @_ could have been extended. */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|PL_stack_sp
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|+=
name|items
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
name|SvREFCNT_dec
argument_list|(
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|AvREAL
argument_list|(
name|av
argument_list|)
condition|)
block|{
name|arg_was_real
operator|=
literal|1
expr_stmt|;
name|AvREAL_off
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* so av_clear() won't clobber elts */
block|}
name|av_clear
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
comment|/* put GvAV(defgv) back onto stack */
name|AV
modifier|*
name|av
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av
operator|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|av
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|PL_stack_sp
operator|++
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
name|items
argument_list|)
expr_stmt|;
comment|/* @_ could have been extended. */
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|PL_stack_sp
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|+=
name|items
expr_stmt|;
block|}
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
operator|&&
operator|!
operator|(
name|CvDEPTH
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
operator|-
literal|1
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
comment|/* Now do some callish stuff. */
name|SAVETMPS
expr_stmt|;
if|if
condition|(
name|CvXSUB
argument_list|(
name|cv
argument_list|)
condition|)
block|{
if|if
condition|(
name|CvOLDSTYLE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|I32
argument_list|(
argument|*fp3
argument_list|)
name|_
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|SP
operator|>
name|mark
condition|)
block|{
name|SP
index|[
literal|1
index|]
operator|=
name|SP
index|[
literal|0
index|]
expr_stmt|;
name|SP
operator|--
expr_stmt|;
block|}
name|fp3
operator|=
operator|(
name|I32
argument_list|(
argument|*
argument_list|)
name|_
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
operator|)
name|CvXSUB
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|items
operator|=
call|(
modifier|*
name|fp3
call|)
argument_list|(
name|CvXSUBANY
argument_list|(
name|cv
argument_list|)
operator|.
name|any_i32
argument_list|,
name|mark
operator|-
name|PL_stack_base
operator|+
literal|1
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|SP
operator|=
name|PL_stack_base
operator|+
name|items
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|PL_stack_sp
operator|--
expr_stmt|;
comment|/* There is no cv arg. */
comment|/* Push a mark for the start of arglist */
name|PUSHMARK
argument_list|(
name|mark
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
operator|(
operator|*
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
operator|(
name|cv
name|_PERL_OBJECT_THIS
operator|)
expr_stmt|;
comment|/* Pop the current context like a decent sub should */
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
comment|/* Do _not_ use PUTBACK, keep the XSUB's return stack! */
block|}
name|LEAVE
expr_stmt|;
return|return
name|pop_return
argument_list|()
return|;
block|}
else|else
block|{
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
block|{
name|PL_in_eval
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_in_eval
expr_stmt|;
name|PL_eval_root
operator|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_eval_root
expr_stmt|;
name|cx
operator|->
name|cx_type
operator|=
name|CXt_SUB
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
operator|=
literal|0
expr_stmt|;
block|}
name|cx
operator|->
name|blk_sub
operator|.
name|cv
operator|=
name|cv
expr_stmt|;
name|cx
operator|->
name|blk_sub
operator|.
name|olddepth
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* save temporaries on recursion? */
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|==
literal|100
operator|&&
name|PL_dowarn
condition|)
name|sub_crush_depth
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|>
name|AvFILLp
argument_list|(
name|padlist
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|newpad
init|=
name|newAV
argument_list|()
decl_stmt|;
name|SV
modifier|*
modifier|*
name|oldpad
init|=
name|AvARRAY
argument_list|(
name|svp
index|[
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|I32
name|ix
init|=
name|AvFILLp
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|svp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
name|svp
index|[
name|ix
index|]
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVX
argument_list|(
name|svp
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|SvFLAGS
argument_list|(
name|svp
index|[
name|ix
index|]
argument_list|)
operator|&
name|SVf_FAKE
operator|)
operator|||
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
comment|/* outer lexical or anon code */
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|oldpad
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* our own lexical */
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|av_store
argument_list|(
name|newpad
argument_list|,
name|ix
argument_list|,
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
name|AV
modifier|*
name|av
init|=
name|newAV
argument_list|()
decl_stmt|;
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|newpad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
block|}
name|av_store
argument_list|(
name|padlist
argument_list|,
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newpad
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|padlist
argument_list|)
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
operator|!
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
block|{
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
decl_stmt|;
name|items
operator|=
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|items
condition|)
block|{
comment|/* Mark is at the end of the stack. */
name|EXTEND
argument_list|(
name|SP
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|SP
operator|+
literal|1
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|SP
operator|+=
name|items
expr_stmt|;
name|PUTBACK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|svp
index|[
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
if|if
condition|(
name|cx
operator|->
name|blk_sub
operator|.
name|hasargs
condition|)
endif|#
directive|endif
comment|/* USE_THREADS */
block|{
name|AV
modifier|*
name|av
init|=
operator|(
name|AV
operator|*
operator|)
name|PL_curpad
index|[
literal|0
index|]
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ary
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_THREADS
name|cx
operator|->
name|blk_sub
operator|.
name|savearray
operator|=
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|PL_defgv
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|av
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|cx
operator|->
name|blk_sub
operator|.
name|argarray
operator|=
name|av
expr_stmt|;
operator|++
name|mark
expr_stmt|;
if|if
condition|(
name|items
operator|>=
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
condition|)
block|{
name|ary
operator|=
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|!=
name|ary
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+=
name|AvARRAY
argument_list|(
name|av
argument_list|)
operator|-
name|AvALLOC
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
if|if
condition|(
name|items
operator|>=
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|+
literal|1
condition|)
block|{
name|AvMAX
argument_list|(
name|av
argument_list|)
operator|=
name|items
operator|-
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|ary
argument_list|,
name|items
operator|+
literal|1
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvALLOC
argument_list|(
name|av
argument_list|)
operator|=
name|ary
expr_stmt|;
name|SvPVX
argument_list|(
name|av
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|ary
expr_stmt|;
block|}
block|}
name|Copy
argument_list|(
name|mark
argument_list|,
name|AvARRAY
argument_list|(
name|av
argument_list|)
argument_list|,
name|items
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
name|AvFILLp
argument_list|(
name|av
argument_list|)
operator|=
name|items
operator|-
literal|1
expr_stmt|;
comment|/* preserve @_ nature */
if|if
condition|(
name|arg_was_real
condition|)
block|{
name|AvREIFY_off
argument_list|(
name|av
argument_list|)
expr_stmt|;
name|AvREAL_on
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|mark
condition|)
name|SvTEMP_off
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|mark
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PERLDB_SUB
condition|)
block|{
comment|/* Checking curstash breaks DProf. */
comment|/* 		     * We do not care about using sv to call CV; 		     * it's for informational purposes only. 		     */
name|SV
modifier|*
name|sv
init|=
name|GvSV
argument_list|(
name|PL_DBsub
argument_list|)
decl_stmt|;
name|CV
modifier|*
name|gotocv
decl_stmt|;
if|if
condition|(
name|PERLDB_SUB_NN
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|IV
operator|)
name|cv
expr_stmt|;
comment|/* Already upgraded, saved */
block|}
else|else
block|{
name|save_item
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PERLDB_GOTO
operator|&&
operator|(
name|gotocv
operator|=
name|perl_get_cv
argument_list|(
literal|"DB::goto"
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|PUSHMARK
argument_list|(
name|PL_stack_sp
argument_list|)
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gotocv
argument_list|,
name|G_SCALAR
operator||
name|G_NODEBUG
argument_list|)
expr_stmt|;
name|PL_stack_sp
operator|--
expr_stmt|;
block|}
block|}
name|RETURNOP
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|label
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_op
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
block|{
if|if
condition|(
operator|!
name|do_dump
condition|)
name|DIE
argument_list|(
literal|"goto must have label"
argument_list|)
expr_stmt|;
block|}
else|else
name|label
operator|=
name|cPVOP
operator|->
name|op_pv
expr_stmt|;
if|if
condition|(
name|label
operator|&&
operator|*
name|label
condition|)
block|{
name|OP
modifier|*
name|gotoprobe
init|=
literal|0
decl_stmt|;
comment|/* find label */
name|PL_lastgotoprobe
operator|=
literal|0
expr_stmt|;
operator|*
name|enterops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|cxstack_ix
init|;
name|ix
operator|>=
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|ix
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
case|case
name|CXt_EVAL
case|:
name|gotoprobe
operator|=
name|PL_eval_root
expr_stmt|;
comment|/* XXX not good for nested eval */
break|break;
case|case
name|CXt_LOOP
case|:
name|gotoprobe
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|op_sibling
expr_stmt|;
break|break;
case|case
name|CXt_SUBST
case|:
continue|continue;
case|case
name|CXt_BLOCK
case|:
if|if
condition|(
name|ix
condition|)
name|gotoprobe
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|op_sibling
expr_stmt|;
else|else
name|gotoprobe
operator|=
name|PL_main_root
expr_stmt|;
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
condition|)
block|{
name|gotoprobe
operator|=
name|CvROOT
argument_list|(
name|cx
operator|->
name|blk_sub
operator|.
name|cv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|CXt_NULL
case|:
name|DIE
argument_list|(
literal|"Can't \"goto\" outside a block"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|ix
condition|)
name|DIE
argument_list|(
literal|"panic: goto"
argument_list|)
expr_stmt|;
name|gotoprobe
operator|=
name|PL_main_root
expr_stmt|;
break|break;
block|}
name|retop
operator|=
name|dofindlabel
argument_list|(
name|gotoprobe
argument_list|,
name|label
argument_list|,
name|enterops
argument_list|,
name|enterops
operator|+
name|GOTO_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|retop
condition|)
break|break;
name|PL_lastgotoprobe
operator|=
name|gotoprobe
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retop
condition|)
name|DIE
argument_list|(
literal|"Can't find label %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* pop unwanted frames */
if|if
condition|(
name|ix
operator|<
name|cxstack_ix
condition|)
block|{
name|I32
name|oldsave
decl_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
name|dounwind
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|TOPBLOCK
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|oldsave
operator|=
name|PL_scopestack
index|[
name|PL_scopestack_ix
index|]
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
block|}
comment|/* push wanted frames */
if|if
condition|(
operator|*
name|enterops
operator|&&
name|enterops
index|[
literal|1
index|]
condition|)
block|{
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|enterops
index|[
name|ix
index|]
condition|;
name|ix
operator|++
control|)
block|{
name|PL_op
operator|=
name|enterops
index|[
name|ix
index|]
expr_stmt|;
comment|/* Eventually we may want to stack the needed arguments 		 * for each op.  For now, we punt on the hard ones. */
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_ENTERITER
condition|)
name|DIE
argument_list|(
literal|"Can't \"goto\" into the middle of a foreach loop"
argument_list|,
name|label
argument_list|)
expr_stmt|;
call|(
name|CALLOP
operator|->
name|op_ppaddr
call|)
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_dump
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|retop
condition|)
name|retop
operator|=
name|PL_main_start
expr_stmt|;
endif|#
directive|endif
name|PL_restartop
operator|=
name|retop
expr_stmt|;
name|PL_do_undump
operator|=
name|TRUE
expr_stmt|;
name|my_unexec
argument_list|()
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
comment|/* hmm, must be GNU unexec().. */
name|PL_do_undump
operator|=
name|FALSE
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|retop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_exit
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|I32
name|anum
decl_stmt|;
if|if
condition|(
name|MAXARG
operator|<
literal|1
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|anum
operator|=
name|SvIVx
argument_list|(
name|POPs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMSISH_EXIT
if|if
condition|(
name|anum
operator|==
literal|1
operator|&&
name|VMSISH_EXIT
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|my_exit
argument_list|(
name|anum
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_macro
name|PP
argument_list|(
argument|pp_nswitch
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
name|double
name|value
init|=
name|SvNVx
argument_list|(
name|GvSV
argument_list|(
name|cCOP
operator|->
name|cop_gv
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|I32
name|match
init|=
name|I_32
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|match
operator|)
operator|>
name|value
condition|)
operator|--
name|match
expr_stmt|;
comment|/* was fractional--truncate other way */
block|}
name|match
operator|-=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_offset
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|>
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
condition|)
name|match
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
expr_stmt|;
name|PL_op
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_next
index|[
name|match
index|]
expr_stmt|;
name|RETURNOP
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_cswitch
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|I32
name|match
decl_stmt|;
if|if
condition|(
name|PL_multiline
condition|)
name|PL_op
operator|=
name|PL_op
operator|->
name|op_next
expr_stmt|;
comment|/* can't assume anything */
else|else
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|match
operator|=
operator|*
operator|(
name|SvPVx
argument_list|(
name|GvSV
argument_list|(
name|cCOP
operator|->
name|cop_gv
argument_list|)
argument_list|,
name|n_a
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
name|match
operator|-=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_offset
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|>
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
condition|)
name|match
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_max
expr_stmt|;
name|PL_op
operator|=
name|cCOP
operator|->
name|uop
operator|.
name|scop
operator|.
name|scop_next
index|[
name|match
index|]
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Eval. */
end_comment

begin_function
name|STATIC
name|void
name|save_lines
parameter_list|(
name|AV
modifier|*
name|array
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|I32
name|line
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|s
operator|&&
name|s
operator|<
name|send
condition|)
block|{
name|SV
modifier|*
name|tmpstr
init|=
name|NEWSV
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|tmpstr
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|++
expr_stmt|;
else|else
name|t
operator|=
name|send
expr_stmt|;
name|sv_setpvn
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|array
argument_list|,
name|line
operator|++
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|docatch
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
name|dJMPENV
expr_stmt|;
name|PL_op
operator|=
name|o
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|assert
argument_list|(
name|CATCH_GET
operator|==
name|TRUE
argument_list|)
expr_stmt|;
name|DEBUG_l
argument_list|(
name|deb
argument_list|(
literal|"Setting up local jumplevel %p, was %p\n"
argument_list|,
operator|&
name|cur_env
argument_list|,
name|PL_top_env
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
default|default:
comment|/* topmost level handles it */
name|pass_the_buck
label|:
name|JMPENV_POP
expr_stmt|;
name|PL_op
operator|=
name|oldop
expr_stmt|;
name|JMPENV_JUMP
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|3
case|:
if|if
condition|(
operator|!
name|PL_restartop
condition|)
goto|goto
name|pass_the_buck
goto|;
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|0
case|:
name|CALLRUNOPS
argument_list|()
expr_stmt|;
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|Nullop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|sv_compile_2op
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|OP
modifier|*
modifier|*
name|startop
parameter_list|,
name|char
modifier|*
name|code
parameter_list|,
name|AV
modifier|*
modifier|*
name|avp
parameter_list|)
comment|/* sv Text to convert to OP tree. */
comment|/* startop op_free() this to undo. */
comment|/* code Short string id of the caller. */
block|{
name|dSP
expr_stmt|;
comment|/* Make POPBLOCK work. */
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
init|=
literal|0
decl_stmt|;
comment|/* SUSPECT - INITIALZE TO WHAT?  NI-S */
name|I32
name|optype
decl_stmt|;
name|OP
name|dummy
decl_stmt|;
name|OP
modifier|*
name|oop
init|=
name|PL_op
decl_stmt|,
modifier|*
name|rop
decl_stmt|;
name|char
name|tmpbuf
index|[
name|TYPE_DIGITS
argument_list|(
name|long
argument_list|)
operator|+
literal|12
operator|+
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|safestr
decl_stmt|;
name|ENTER
expr_stmt|;
name|lex_start
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SAVETMPS
expr_stmt|;
comment|/* switch to eval mode */
if|if
condition|(
name|PL_curcop
operator|==
operator|&
name|PL_compiling
condition|)
block|{
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_stash
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_stash
operator|=
name|PL_curstash
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|SAVEI16
argument_list|(
name|PL_compiling
operator|.
name|cop_line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"_<(%.10s_eval %lu)"
argument_list|,
name|code
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|++
name|PL_evalseq
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_filegv
operator|=
name|gv_fetchfile
argument_list|(
name|tmpbuf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_line
operator|=
literal|1
expr_stmt|;
comment|/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up        deleting the eval's FILEGV from the stash before gv_check() runs        (i.e. before run-time proper). To work around the coredump that        ensues, we always turn GvMULTI_on for any globals that were        introduced within evals. See force_ident(). GSAR 96-10-12 */
name|safestr
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|SAVEDELETE
argument_list|(
name|PL_defstash
argument_list|,
name|safestr
argument_list|,
name|strlen
argument_list|(
name|safestr
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OP_IN_REGISTER
name|PL_opsave
operator|=
name|op
expr_stmt|;
else|#
directive|else
name|SAVEPPTR
argument_list|(
name|PL_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_hints
operator|=
literal|0
expr_stmt|;
name|PL_op
operator|=
operator|&
name|dummy
expr_stmt|;
name|PL_op
operator|->
name|op_type
operator|=
literal|0
expr_stmt|;
comment|/* Avoid uninit warning. */
name|PL_op
operator|->
name|op_flags
operator|=
literal|0
expr_stmt|;
comment|/* Avoid uninit warning. */
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_EVAL
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|rop
operator|=
name|doeval
argument_list|(
name|G_SCALAR
argument_list|,
name|startop
argument_list|)
expr_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
operator|(
operator|*
name|startop
operator|)
operator|->
name|op_type
operator|=
name|OP_NULL
expr_stmt|;
operator|(
operator|*
name|startop
operator|)
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
name|lex_end
argument_list|()
expr_stmt|;
operator|*
name|avp
operator|=
operator|(
name|AV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
ifdef|#
directive|ifdef
name|OP_IN_REGISTER
name|op
operator|=
name|PL_opsave
expr_stmt|;
endif|#
directive|endif
return|return
name|rop
return|;
block|}
end_function

begin_comment
comment|/* With USE_THREADS, eval_owner must be held on entry to doeval */
end_comment

begin_function
name|STATIC
name|OP
modifier|*
name|doeval
parameter_list|(
name|int
name|gimme
parameter_list|,
name|OP
modifier|*
modifier|*
name|startop
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|OP
modifier|*
name|saveop
init|=
name|PL_op
decl_stmt|;
name|HV
modifier|*
name|newstash
decl_stmt|;
name|CV
modifier|*
name|caller
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|PL_in_eval
operator|=
literal|1
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
comment|/* set up a scratch pad */
name|SAVEI32
argument_list|(
name|PL_padix
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|caller
operator|=
name|PL_compcv
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cxstack_ix
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|PERL_CONTEXT
modifier|*
name|cx
init|=
operator|&
name|cxstack
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_EVAL
condition|)
break|break;
elseif|else
if|if
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
operator|==
name|CXt_SUB
condition|)
block|{
name|caller
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|cv
expr_stmt|;
break|break;
block|}
block|}
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvEVAL_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
if|if
condition|(
operator|!
name|saveop
operator|||
name|saveop
operator|->
name|op_type
operator|!=
name|OP_REQUIRE
condition|)
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|caller
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
comment|/* make sure we compile in the right package */
name|newstash
operator|=
name|PL_curcop
operator|->
name|cop_stash
expr_stmt|;
if|if
condition|(
name|PL_curstash
operator|!=
name|newstash
condition|)
block|{
name|SAVESPTR
argument_list|(
name|PL_curstash
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|newstash
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
comment|/* try to compile it */
name|PL_eval_root
operator|=
name|Nullop
expr_stmt|;
name|PL_error_count
operator|=
literal|0
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_curcop
operator|->
name|cop_arybase
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|newSVpv
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveop
operator|&&
name|saveop
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
name|PL_in_eval
operator||=
literal|4
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
operator|||
name|PL_error_count
operator|||
operator|!
name|PL_eval_root
condition|)
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
init|=
literal|0
decl_stmt|;
comment|/* Might be reset by POPEVAL. */
name|STRLEN
name|n_a
decl_stmt|;
name|PL_op
operator|=
name|saveop
expr_stmt|;
if|if
condition|(
name|PL_eval_root
condition|)
block|{
name|op_free
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
if|if
condition|(
operator|!
name|startop
condition|)
block|{
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
block|}
name|lex_end
argument_list|()
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|DIE
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Compilation failed in require"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startop
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|PL_curpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"%sCompilation failed in regexp"
argument_list|,
operator|(
operator|*
name|msg
condition|?
name|msg
else|:
literal|"Unknown error\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|RETPUSHUNDEF
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|startop
condition|)
block|{
operator|*
name|startop
operator|=
name|PL_eval_root
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
block|}
else|else
name|SAVEFREEOP
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|&
name|G_VOID
condition|)
name|scalarvoid
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|&
name|G_ARRAY
condition|)
name|list
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_eval
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Register with debugger: */
if|if
condition|(
name|PERLDB_INTER
operator|&&
name|saveop
operator|->
name|op_type
operator|==
name|OP_REQUIRE
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|perl_get_cv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* compiled okay, so do it */
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SP
operator|=
name|PL_stack_base
operator|+
name|POPMARK
expr_stmt|;
comment|/* pop original mark */
name|PL_op
operator|=
name|saveop
expr_stmt|;
comment|/* The caller may need it. */
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
literal|0
expr_stmt|;
name|COND_SIGNAL
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|RETURNOP
argument_list|(
name|PL_eval_start
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|PP
argument_list|(
argument|pp_require
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|tryname
decl_stmt|;
name|SV
modifier|*
name|namesv
init|=
name|Nullsv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|gimme
init|=
name|G_SCALAR
decl_stmt|;
name|PerlIO
modifier|*
name|tryrsfp
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
if|if
condition|(
name|SvNIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
if|if
condition|(
name|atof
argument_list|(
name|PL_patchlevel
argument_list|)
operator|+
literal|0.00000999
operator|<
name|SvNV
argument_list|(
name|sv
argument_list|)
condition|)
name|DIE
argument_list|(
literal|"Perl %s required--this is only version %s, stopped"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|RETPUSHYES
expr_stmt|;
block|}
name|name
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|&&
name|len
operator|>
literal|0
operator|&&
operator|*
name|name
operator|)
condition|)
name|DIE
argument_list|(
literal|"Null filename used"
argument_list|)
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"require"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_REQUIRE
operator|&&
operator|(
name|svp
operator|=
name|hv_fetch
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
name|RETPUSHYES
expr_stmt|;
comment|/* prepare to compile file */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|||
operator|(
operator|*
name|name
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|DOSISH
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
comment|/* UNC path */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
operator|||
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|name
operator|==
literal|'['
operator|||
operator|*
name|name
operator|==
literal|'<'
operator|)
operator|&&
operator|(
name|isALNUM
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"$-_]>"
argument_list|,
name|name
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|tryname
operator|=
name|name
expr_stmt|;
name|tryrsfp
operator|=
name|PerlIO_open
argument_list|(
name|name
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AV
modifier|*
name|ar
init|=
name|GvAVn
argument_list|(
name|PL_incgv
argument_list|)
decl_stmt|;
name|I32
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
modifier|*
name|unixname
decl_stmt|;
if|if
condition|(
operator|(
name|unixname
operator|=
name|tounixspec
argument_list|(
name|name
argument_list|,
name|Nullch
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
endif|#
directive|endif
block|{
name|namesv
operator|=
name|NEWSV
argument_list|(
literal|806
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILL
argument_list|(
name|ar
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|dir
init|=
name|SvPVx
argument_list|(
operator|*
name|av_fetch
argument_list|(
name|ar
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
modifier|*
name|unixdir
decl_stmt|;
if|if
condition|(
operator|(
name|unixdir
operator|=
name|tounixpath
argument_list|(
name|dir
argument_list|,
name|Nullch
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
continue|continue;
name|sv_setpv
argument_list|(
name|namesv
argument_list|,
name|unixdir
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|namesv
argument_list|,
name|unixname
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_setpvf
argument_list|(
name|namesv
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAINT_PROPER
argument_list|(
literal|"require"
argument_list|)
expr_stmt|;
name|tryname
operator|=
name|SvPVX
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
name|tryrsfp
operator|=
name|PerlIO_open
argument_list|(
name|tryname
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryrsfp
condition|)
block|{
if|if
condition|(
name|tryname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tryname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|tryname
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_filegv
operator|=
name|gv_fetchfile
argument_list|(
name|tryrsfp
condition|?
name|tryname
else|:
name|name
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tryrsfp
condition|)
block|{
if|if
condition|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_REQUIRE
condition|)
block|{
name|SV
modifier|*
name|msg
init|=
name|sv_2mortal
argument_list|(
name|newSVpvf
argument_list|(
literal|"Can't locate %s in @INC"
argument_list|,
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|dirmsgsv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|ar
init|=
name|GvAVn
argument_list|(
name|PL_incgv
argument_list|)
decl_stmt|;
name|I32
name|i
decl_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|".h "
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (change .h to .ph maybe?)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|".ph "
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (did you run h2ph?)"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" (@INC contains:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILL
argument_list|(
name|ar
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|dir
init|=
name|SvPVx
argument_list|(
operator|*
name|av_fetch
argument_list|(
name|ar
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|sv_setpvf
argument_list|(
name|dirmsgsv
argument_list|,
literal|" %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|msg
argument_list|,
name|dirmsgsv
argument_list|)
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|msg
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|dirmsgsv
argument_list|)
expr_stmt|;
name|DIE
argument_list|(
literal|"%_"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|RETPUSHUNDEF
expr_stmt|;
block|}
else|else
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
comment|/* Assume success here to prevent recursive requirement. */
operator|(
name|void
operator|)
name|hv_store
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|newSVsv
argument_list|(
name|GvSV
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|lex_start
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEGENERICSV
argument_list|(
name|PL_rsfp_filters
argument_list|)
expr_stmt|;
name|PL_rsfp_filters
operator|=
name|Nullav
expr_stmt|;
name|PL_rsfp
operator|=
name|tryrsfp
expr_stmt|;
name|name
operator|=
name|savepv
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
literal|0
expr_stmt|;
comment|/* switch to eval mode */
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_EVAL
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
name|name
argument_list|,
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|SAVEI16
argument_list|(
name|PL_compiling
operator|.
name|cop_line
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_line
operator|=
literal|0
expr_stmt|;
name|PUTBACK
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_owner
operator|&&
name|PL_eval_owner
operator|!=
name|thr
condition|)
while|while
condition|(
name|PL_eval_owner
condition|)
name|COND_WAIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|,
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|DOCATCH
argument_list|(
name|doeval
argument_list|(
name|G_SCALAR
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_dofile
argument_list|)
end_macro

begin_block
block|{
return|return
name|pp_require
argument_list|(
name|ARGS
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_entereval
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|dPOPss
expr_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|,
name|was
init|=
name|PL_sub_generation
decl_stmt|;
name|char
name|tmpbuf
index|[
name|TYPE_DIGITS
argument_list|(
name|long
argument_list|)
operator|+
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|safestr
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|OP
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
operator|||
operator|!
name|len
condition|)
name|RETPUSHUNDEF
expr_stmt|;
name|TAINT_PROPER
argument_list|(
literal|"eval"
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|lex_start
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SAVETMPS
expr_stmt|;
comment|/* switch to eval mode */
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"_<(eval %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|++
name|PL_evalseq
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_filegv
operator|=
name|gv_fetchfile
argument_list|(
name|tmpbuf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_line
operator|=
literal|1
expr_stmt|;
comment|/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up        deleting the eval's FILEGV from the stash before gv_check() runs        (i.e. before run-time proper). To work around the coredump that        ensues, we always turn GvMULTI_on for any globals that were        introduced within evals. See force_ident(). GSAR 96-10-12 */
name|safestr
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|SAVEDELETE
argument_list|(
name|PL_defstash
argument_list|,
name|safestr
argument_list|,
name|strlen
argument_list|(
name|safestr
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
name|PL_op
operator|->
name|op_targ
expr_stmt|;
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
operator|(
name|CXt_EVAL
operator||
name|CXp_REAL
operator|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
comment|/* prepare to compile string */
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|save_lines
argument_list|(
name|GvAV
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
argument_list|,
name|PL_linestr
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_owner
operator|&&
name|PL_eval_owner
operator|!=
name|thr
condition|)
while|while
condition|(
name|PL_eval_owner
condition|)
name|COND_WAIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|,
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|PL_eval_owner
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|ret
operator|=
name|doeval
argument_list|(
name|gimme
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_INTER
operator|&&
name|was
operator|!=
name|PL_sub_generation
comment|/* Some subs defined here. */
operator|&&
name|ret
operator|!=
name|PL_op
operator|->
name|op_next
condition|)
block|{
comment|/* Successive compilation. */
name|strcpy
argument_list|(
name|safestr
argument_list|,
literal|"_<(eval )"
argument_list|)
expr_stmt|;
comment|/* Anything fake and short. */
block|}
return|return
name|DOCATCH
argument_list|(
name|ret
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_leaveeval
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|OP
modifier|*
name|retop
decl_stmt|;
name|U8
name|save_flags
init|=
name|PL_op
operator|->
name|op_flags
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|retop
operator|=
name|pop_return
argument_list|()
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|MARK
operator|=
name|newsp
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|newsp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&
name|SVs_TEMP
condition|)
operator|*
name|MARK
operator|=
name|TOPs
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
name|sv_mortalcopy
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEXTEND
argument_list|(
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in case LEAVE wipes old return values */
for|for
control|(
name|mark
operator|=
name|newsp
operator|+
literal|1
init|;
name|mark
operator|<=
name|SP
condition|;
name|mark
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|mark
argument_list|)
operator|&
name|SVs_TEMP
operator|)
condition|)
block|{
operator|*
name|mark
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* Don't pop $1 et al till now */
comment|/*      * Closures mentioned at top level of eval cannot be referenced      * again, and their presence indirectly causes a memory leak.      * (Note that the fact that compcv and friends are still set here      * is, AFAIK, an accident.)  --Chip      */
if|if
condition|(
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|I32
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|ix
operator|>=
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|sv
init|=
name|svp
index|[
name|ix
index|]
decl_stmt|;
if|if
condition|(
name|sv
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|'&'
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|svp
index|[
name|ix
index|]
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|sv
operator|=
name|PL_curpad
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|CvCLONE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|sv
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
block|}
else|else
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|sv
expr_stmt|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|assert
argument_list|(
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CvDEPTH
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lex_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|OP_REQUIRE
operator|&&
operator|!
operator|(
name|gimme
operator|==
name|G_SCALAR
condition|?
name|SvTRUE
argument_list|(
operator|*
name|SP
argument_list|)
else|:
name|SP
operator|>
name|newsp
operator|)
condition|)
block|{
comment|/* Unassume the success we assumed earlier. */
name|char
modifier|*
name|name
init|=
name|cx
operator|->
name|blk_eval
operator|.
name|old_name
decl_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|GvHVn
argument_list|(
name|PL_incgv
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|retop
operator|=
name|die
argument_list|(
literal|"%s did not return a true value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* die_where() did LEAVE, or we won't be here */
block|}
else|else
block|{
name|LEAVE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|save_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|RETURNOP
argument_list|(
name|retop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_entertry
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|push_return
argument_list|(
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
name|CXt_EVAL
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|PL_op
expr_stmt|;
comment|/* Only needed so that goto works right. */
name|PL_in_eval
operator|=
literal|1
expr_stmt|;
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
return|return
name|DOCATCH
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
return|;
block|}
end_block

begin_macro
name|PP
argument_list|(
argument|pp_leavetry
argument_list|)
end_macro

begin_block
block|{
name|djSP
expr_stmt|;
specifier|register
name|SV
modifier|*
modifier|*
name|mark
decl_stmt|;
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_VOID
condition|)
name|SP
operator|=
name|newsp
expr_stmt|;
elseif|else
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
name|MARK
operator|=
name|newsp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|MARK
operator|<=
name|SP
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|TOPs
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_TEMP
operator|)
condition|)
operator|*
name|MARK
operator|=
name|TOPs
expr_stmt|;
else|else
operator|*
name|MARK
operator|=
name|sv_mortalcopy
argument_list|(
name|TOPs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MEXTEND
argument_list|(
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|MARK
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
name|SP
operator|=
name|MARK
expr_stmt|;
block|}
else|else
block|{
comment|/* in case LEAVE wipes old return values */
for|for
control|(
name|mark
operator|=
name|newsp
operator|+
literal|1
init|;
name|mark
operator|<=
name|SP
condition|;
name|mark
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|mark
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_TEMP
operator|)
operator|)
condition|)
block|{
operator|*
name|mark
operator|=
name|sv_mortalcopy
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
name|TAINT_NOT
expr_stmt|;
comment|/* Each item is independent */
block|}
block|}
block|}
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
comment|/* Don't pop $1 et al till now */
name|LEAVE
expr_stmt|;
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RETURN
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|void
name|doparseform
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|base
decl_stmt|;
specifier|register
name|I32
name|skipspaces
init|=
literal|0
decl_stmt|;
name|bool
name|noblank
decl_stmt|;
name|bool
name|repeat
decl_stmt|;
name|bool
name|postspace
init|=
name|FALSE
decl_stmt|;
name|U16
modifier|*
name|fops
decl_stmt|;
specifier|register
name|U16
modifier|*
name|fpc
decl_stmt|;
name|U16
modifier|*
name|linepc
decl_stmt|;
specifier|register
name|I32
name|arg
decl_stmt|;
name|bool
name|ischop
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|croak
argument_list|(
literal|"Null picture in formline"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|804
argument_list|,
name|fops
argument_list|,
operator|(
name|send
operator|-
name|s
operator|)
operator|*
literal|3
operator|+
literal|10
argument_list|,
name|U16
argument_list|)
expr_stmt|;
comment|/* Almost certainly too long... */
name|fpc
operator|=
name|fops
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|linepc
operator|=
name|fpc
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEMARK
expr_stmt|;
name|noblank
operator|=
name|repeat
operator|=
name|FALSE
expr_stmt|;
name|base
operator|=
name|s
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<=
name|send
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
default|default:
name|skipspaces
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'~'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
name|repeat
operator|=
name|TRUE
expr_stmt|;
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
block|}
name|noblank
operator|=
name|TRUE
expr_stmt|;
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|skipspaces
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
case|case
literal|0
case|:
name|arg
operator|=
name|s
operator|-
name|base
expr_stmt|;
name|skipspaces
operator|++
expr_stmt|;
name|arg
operator|-=
name|skipspaces
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|postspace
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_SPACE
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LITERAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
name|postspace
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|send
condition|)
name|skipspaces
operator|--
expr_stmt|;
if|if
condition|(
name|skipspaces
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_SKIP
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|skipspaces
expr_stmt|;
block|}
name|skipspaces
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|send
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_NEWLINE
expr_stmt|;
if|if
condition|(
name|noblank
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_BLANK
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
name|arg
operator|=
name|fpc
operator|-
name|linepc
operator|+
literal|1
expr_stmt|;
else|else
name|arg
operator|=
literal|0
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
name|linepc
operator|=
name|fpc
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEMARK
expr_stmt|;
name|noblank
operator|=
name|repeat
operator|=
name|FALSE
expr_stmt|;
name|base
operator|=
name|s
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'@'
case|:
case|case
literal|'^'
case|:
name|ischop
operator|=
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'^'
expr_stmt|;
if|if
condition|(
name|postspace
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_SPACE
expr_stmt|;
name|postspace
operator|=
name|FALSE
expr_stmt|;
block|}
name|arg
operator|=
operator|(
name|s
operator|-
name|base
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
operator|*
name|fpc
operator|++
operator|=
name|FF_LITERAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
name|base
operator|=
name|s
operator|-
literal|1
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_FETCH
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|s
operator|++
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_LINEGLOB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|||
operator|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|)
condition|)
block|{
name|arg
operator|=
name|ischop
condition|?
literal|512
else|:
literal|0
expr_stmt|;
name|base
operator|=
name|s
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|f
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
name|arg
operator||=
literal|256
operator|+
operator|(
name|s
operator|-
name|f
operator|)
expr_stmt|;
block|}
operator|*
name|fpc
operator|++
operator|=
name|s
operator|-
name|base
expr_stmt|;
comment|/* fieldsize for FETCH */
operator|*
name|fpc
operator|++
operator|=
name|FF_DECIMAL
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|I32
name|prespace
init|=
literal|0
decl_stmt|;
name|bool
name|ismore
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'>'
condition|)
empty_stmt|;
name|prespace
operator|=
name|FF_SPACE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'|'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'|'
condition|)
empty_stmt|;
name|prespace
operator|=
name|FF_HALFSPACE
expr_stmt|;
name|postspace
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'<'
condition|)
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'<'
condition|)
empty_stmt|;
name|postspace
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|ismore
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|fpc
operator|++
operator|=
name|s
operator|-
name|base
expr_stmt|;
comment|/* fieldsize for FETCH */
operator|*
name|fpc
operator|++
operator|=
name|ischop
condition|?
name|FF_CHECKCHOP
else|:
name|FF_CHECKNL
expr_stmt|;
if|if
condition|(
name|prespace
condition|)
operator|*
name|fpc
operator|++
operator|=
name|prespace
expr_stmt|;
operator|*
name|fpc
operator|++
operator|=
name|FF_ITEM
expr_stmt|;
if|if
condition|(
name|ismore
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_MORE
expr_stmt|;
if|if
condition|(
name|ischop
condition|)
operator|*
name|fpc
operator|++
operator|=
name|FF_CHOP
expr_stmt|;
block|}
name|base
operator|=
name|s
expr_stmt|;
name|skipspaces
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|fpc
operator|++
operator|=
name|FF_END
expr_stmt|;
name|arg
operator|=
name|fpc
operator|-
name|fops
expr_stmt|;
block|{
comment|/* need to jump to the next word */
name|int
name|z
decl_stmt|;
name|z
operator|=
name|WORD_ALIGN
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|%
name|WORD_ALIGN
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|z
operator|+
name|arg
operator|*
sizeof|sizeof
argument_list|(
name|U16
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|z
expr_stmt|;
block|}
name|Copy
argument_list|(
name|fops
argument_list|,
name|s
argument_list|,
name|arg
argument_list|,
name|U16
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|fops
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'f'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvCOMPILED_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The rest of this file was derived from source code contributed  * by Tom Horsley.  *  * NOTE: this code was derived from Tom Horsley's qsort replacement  * and should not be confused with the original code.  */
end_comment

begin_comment
comment|/* Copyright (C) Tom Horsley, 1997. All rights reserved.     Permission granted to distribute under the same terms as perl which are    (briefly):      This program is free software; you can redistribute it and/or modify     it under the terms of either:  	a) the GNU General Public License as published by the Free 	Software Foundation; either version 1, or (at your option) any 	later version, or  	b) the "Artistic License" which comes with this Kit.     Details on the perl license can be found in the perl source code which    may be located via the www.perl.com web page.     This is the most wonderfulest possible qsort I can come up with (and    still be mostly portable) My (limited) tests indicate it consistently    does about 20% fewer calls to compare than does the qsort in the Visual    C++ library, other vendors may vary.     Some of the ideas in here can be found in "Algorithms" by Sedgewick,    others I invented myself (or more likely re-invented since they seemed    pretty obvious once I watched the algorithm operate for a while).     Most of this code was written while watching the Marlins sweep the Giants    in the 1997 National League Playoffs - no Braves fans allowed to use this    code (just kidding :-).     I realize that if I wanted to be true to the perl tradition, the only    comment in this file would be something like:     ...they shuffled back towards the rear of the line. 'No, not at the    rear!'  the slave-driver shouted. 'Three files up. And stay there...     However, I really needed to violate that tradition just so I could keep    track of what happens myself, not to mention some poor fool trying to    understand this years from now :-). */
end_comment

begin_comment
comment|/* ********************************************************** Configuration */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|QSORT_ORDER_GUESS
end_ifndef

begin_define
define|#
directive|define
name|QSORT_ORDER_GUESS
value|2
end_define

begin_comment
comment|/* Select doubling version of the netBSD trick */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_MAX_STACK is the largest number of partitions that can be stacked up for    future processing - a good max upper bound is log base 2 of memory size    (32 on 32 bit machines, 64 on 64 bit machines, etc). In reality can    safely be smaller than that since the program is taking up some space and    most operating systems only let you grab some subset of contiguous    memory (not to mention that you are normally sorting data larger than    1 byte element size :-). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|QSORT_MAX_STACK
end_ifndef

begin_define
define|#
directive|define
name|QSORT_MAX_STACK
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_BREAK_EVEN is the size of the largest partition we should insertion sort.    Anything bigger and we use qsort. If you make this too small, the qsort    will probably break (or become less efficient), because it doesn't expect    the middle element of a partition to be the same as the right or left -    you have been warned). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|QSORT_BREAK_EVEN
end_ifndef

begin_define
define|#
directive|define
name|QSORT_BREAK_EVEN
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************* Data Types */
end_comment

begin_comment
comment|/* hold left and right index values of a partition waiting to be sorted (the    partition includes both left and right - right is NOT one past the end or    anything like that). */
end_comment

begin_struct
struct|struct
name|partition_stack_entry
block|{
name|int
name|left
decl_stmt|;
name|int
name|right
decl_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|int
name|qsort_break_even
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* ******************************************************* Shorthand Macros */
end_comment

begin_comment
comment|/* Note that these macros will be used from inside the qsort function where    we happen to know that the variable 'elt_size' contains the size of an    array element and the variable 'temp' points to enough space to hold a    temp element and the variable 'array' points to the array being sorted    and 'compare' is the pointer to the compare routine.     Also note that there are very many highly architecture specific ways    these might be sped up, but this is simply the most generally portable    code I could think of. */
end_comment

begin_comment
comment|/* Return< 0 == 0 or> 0 as the value of elt1 is< elt2, == elt2,> elt2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|qsort_cmp
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|)
define|\
value|((this->*compare)(array[elt1], array[elt2]))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|qsort_cmp
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|)
define|\
value|((*compare)(array[elt1], array[elt2]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
end_ifdef

begin_define
define|#
directive|define
name|QSORT_NOTICE_SWAP
value|swapped++;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|QSORT_NOTICE_SWAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* swaps contents of array elements elt1, elt2. */
end_comment

begin_define
define|#
directive|define
name|qsort_swap
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|)
define|\
value|STMT_START { \       QSORT_NOTICE_SWAP \       temp = array[elt1]; \       array[elt1] = array[elt2]; \       array[elt2] = temp; \    } STMT_END
end_define

begin_comment
comment|/* rotate contents of elt1, elt2, elt3 such that elt1 gets elt2, elt2 gets    elt3 and elt3 gets elt1. */
end_comment

begin_define
define|#
directive|define
name|qsort_rotate
parameter_list|(
name|elt1
parameter_list|,
name|elt2
parameter_list|,
name|elt3
parameter_list|)
define|\
value|STMT_START { \       QSORT_NOTICE_SWAP \       temp = array[elt1]; \       array[elt1] = array[elt2]; \       array[elt2] = array[elt3]; \       array[elt3] = temp; \    } STMT_END
end_define

begin_comment
comment|/* ************************************************************ Debug stuff */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|break_here
parameter_list|()
block|{
return|return;
comment|/* good place to set a breakpoint */
block|}
end_function

begin_define
define|#
directive|define
name|qsort_assert
parameter_list|(
name|t
parameter_list|)
value|(void)( (t) || (break_here(), 0) )
end_define

begin_function
specifier|static
name|void
name|doqsort_all_asserts
parameter_list|(
name|void
modifier|*
name|array
parameter_list|,
name|size_t
name|num_elts
parameter_list|,
name|size_t
name|elt_size
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|elt1
parameter_list|,
specifier|const
name|void
modifier|*
name|elt2
parameter_list|)
parameter_list|,
name|int
name|pc_left
parameter_list|,
name|int
name|pc_right
parameter_list|,
name|int
name|u_left
parameter_list|,
name|int
name|u_right
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|u_right
operator|<
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_right
operator|<
name|u_left
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|u_right
operator|+
literal|1
init|;
name|i
operator|<
name|pc_left
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|pc_left
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|pc_left
init|;
name|i
operator|<
name|pc_right
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|pc_right
operator|+
literal|1
init|;
name|i
operator|<
name|u_left
condition|;
operator|++
name|i
control|)
block|{
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|i
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|qsort_all_asserts
parameter_list|(
name|PC_LEFT
parameter_list|,
name|PC_RIGHT
parameter_list|,
name|U_LEFT
parameter_list|,
name|U_RIGHT
parameter_list|)
define|\
value|doqsort_all_asserts(array, num_elts, elt_size, compare, \                  PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|qsort_assert
parameter_list|(
name|t
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|qsort_all_asserts
parameter_list|(
name|PC_LEFT
parameter_list|,
name|PC_RIGHT
parameter_list|,
name|U_LEFT
parameter_list|,
name|U_RIGHT
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ****************************************************************** qsort */
end_comment

begin_function
name|STATIC
name|void
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|qsortsv
parameter_list|(
name|SV
modifier|*
modifier|*
name|array
parameter_list|,
name|size_t
name|num_elts
parameter_list|,
name|SVCOMPARE
name|compare
parameter_list|)
else|#
directive|else
function|qsortsv
parameter_list|(
name|SV
modifier|*
modifier|*
name|array
parameter_list|,
name|size_t
name|num_elts
parameter_list|,
name|I32
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
name|SV
modifier|*
name|a
parameter_list|,
name|SV
modifier|*
name|b
parameter_list|)
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|SV
modifier|*
name|temp
decl_stmt|;
name|struct
name|partition_stack_entry
name|partition_stack
index|[
name|QSORT_MAX_STACK
index|]
decl_stmt|;
name|int
name|next_stack_entry
init|=
literal|0
decl_stmt|;
name|int
name|part_left
decl_stmt|;
name|int
name|part_right
decl_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|int
name|qsort_break_even
decl_stmt|;
name|int
name|swapped
decl_stmt|;
endif|#
directive|endif
comment|/* Make sure we actually have work to do.    */
if|if
condition|(
name|num_elts
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
comment|/* Setup the initial partition definition and fall into the sorting loop    */
name|part_left
operator|=
literal|0
expr_stmt|;
name|part_right
operator|=
call|(
name|int
call|)
argument_list|(
name|num_elts
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|QSORT_BREAK_EVEN
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|qsort_break_even
value|QSORT_BREAK_EVEN
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|>=
name|qsort_break_even
condition|)
block|{
comment|/* OK, this is gonna get hairy, so lets try to document all the             concepts and abbreviations and variables and what they keep             track of:              pc: pivot chunk - the set of array elements we accumulate in the                 middle of the partition, all equal in value to the original                 pivot element selected. The pc is defined by:                  pc_left - the leftmost array index of the pc                 pc_right - the rightmost array index of the pc                  we start with pc_left == pc_right and only one element                 in the pivot chunk (but it can grow during the scan).              u:  uncompared elements - the set of elements in the partition                 we have not yet compared to the pivot value. There are two                 uncompared sets during the scan - one to the left of the pc                 and one to the right.                  u_right - the rightmost index of the left side's uncompared set                 u_left - the leftmost index of the right side's uncompared set                  The leftmost index of the left sides's uncompared set                 doesn't need its own variable because it is always defined                 by the leftmost edge of the whole partition (part_left). The                 same goes for the rightmost edge of the right partition                 (part_right).                  We know there are no uncompared elements on the left once we                 get u_right< part_left and no uncompared elements on the                 right once u_left> part_right. When both these conditions                 are met, we have completed the scan of the partition.                  Any elements which are between the pivot chunk and the                 uncompared elements should be less than the pivot value on                 the left side and greater than the pivot value on the right                 side (in fact, the goal of the whole algorithm is to arrange                 for that to be true and make the groups of less-than and                 greater-then elements into new partitions to sort again).              As you marvel at the complexity of the code and wonder why it             has to be so confusing. Consider some of the things this level             of confusion brings:              Once I do a compare, I squeeze every ounce of juice out of it. I             never do compare calls I don't have to do, and I certainly never             do redundant calls.              I also never swap any elements unless I can prove there is a             good reason. Many sort algorithms will swap a known value with             an uncompared value just to get things in the right place (or             avoid complexity :-), but that uncompared value, once it gets             compared, may then have to be swapped again. A lot of the             complexity of this code is due to the fact that it never swaps             anything except compared values, and it only swaps them when the             compare shows they are out of position.          */
name|int
name|pc_left
decl_stmt|,
name|pc_right
decl_stmt|;
name|int
name|u_right
decl_stmt|,
name|u_left
decl_stmt|;
name|int
name|s
decl_stmt|;
name|pc_left
operator|=
operator|(
operator|(
name|part_left
operator|+
name|part_right
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|pc_right
operator|=
name|pc_left
expr_stmt|;
name|u_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
name|u_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
comment|/* Qsort works best when the pivot value is also the median value             in the partition (unfortunately you can't find the median value             without first sorting :-), so to give the algorithm a helping             hand, we pick 3 elements and sort them and use the median value             of that tiny set as the pivot value.              Some versions of qsort like to use the left middle and right as             the 3 elements to sort so they can insure the ends of the             partition will contain values which will stop the scan in the             compare loop, but when you have to call an arbitrarily complex             routine to do a compare, its really better to just keep track of             array index values to know when you hit the edge of the             partition and avoid the extra compare. An even better reason to             avoid using a compare call is the fact that you can drop off the             edge of the array if someone foolishly provides you with an             unstable compare function that doesn't always provide consistent             results.              So, since it is simpler for us to compare the three adjacent             elements in the middle of the partition, those are the ones we             pick here (conveniently pointed at by u_right, pc_left, and             u_left). The values of the left, center, and right elements             are refered to as l c and r in the following comments.          */
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|swapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l< c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
comment|/* if l< c, c< r - already in order - nothing to do */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l< c, c == r - already in order, pc grows */
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
comment|/* l< c, c> r - need to know more */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l< c, c> r, l< r - swap c& r to get ordered */
name|qsort_swap
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l< c, c> r, l == r - swap c&r, grow pc */
name|qsort_swap
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l< c, c> r, l> r - make lcr into rlc to get ordered */
name|qsort_rotate
argument_list|(
name|pc_left
argument_list|,
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l == c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l == c, c< r - already in order, grow pc */
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l == c, c == r - already in order, grow pc both ways */
operator|--
name|pc_left
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l == c, c> r - swap l& r, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* l> c */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l> c, c< r - need to know more */
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* l> c, c< r, l< r - swap l& c to get ordered */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l> c, c< r, l == r - swap l& c, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
operator|++
name|pc_right
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l> c, c< r, l> r - rotate lcr into crl to order */
name|qsort_rotate
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
comment|/* l> c, c == r - swap ends, grow pc */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|pc_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l> c, c> r - swap ends to get in order */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We now know the 3 middle elements have been compared and             arranged in the desired order, so we can shrink the uncompared             sets on both sides          */
operator|--
name|u_right
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
comment|/* The above massive nested if was the simple part :-). We now have             the middle 3 elements ordered and we need to scan through the             uncompared sets on either side, swapping elements that are on             the wrong side or simply shuffling equal elements around to get             all equal elements into the pivot chunk.          */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|still_work_on_left
decl_stmt|;
name|int
name|still_work_on_right
decl_stmt|;
comment|/* Scan the uncompared values on the left. If I find a value                equal to the pivot value, move it over so it is adjacent to                the pivot chunk and expand the pivot chunk. If I find a value                less than the pivot value, then just leave it - its already                on the correct side of the partition. If I find a greater                value, then stop the scan.             */
while|while
condition|(
name|still_work_on_left
operator|=
operator|(
name|u_right
operator|>=
name|part_left
operator|)
condition|)
block|{
name|s
operator|=
name|qsort_cmp
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|--
name|u_right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
operator|--
name|pc_left
expr_stmt|;
if|if
condition|(
name|pc_left
operator|!=
name|u_right
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
block|}
operator|--
name|u_right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|qsort_assert
argument_list|(
name|u_right
operator|<
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|u_right
operator|+
literal|1
argument_list|,
name|pc_left
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do a mirror image scan of uncompared values on the right             */
while|while
condition|(
name|still_work_on_right
operator|=
operator|(
name|u_left
operator|<=
name|part_right
operator|)
condition|)
block|{
name|s
operator|=
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|++
name|u_left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
operator|++
name|pc_right
expr_stmt|;
if|if
condition|(
name|pc_right
operator|!=
name|u_left
condition|)
block|{
name|qsort_swap
argument_list|(
name|pc_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
block|}
operator|++
name|u_left
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|qsort_assert
argument_list|(
name|u_left
operator|>
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|pc_left
operator|<=
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_right
argument_list|,
name|u_left
operator|-
literal|1
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|qsort_assert
argument_list|(
name|qsort_cmp
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_work_on_left
condition|)
block|{
comment|/* I know I have a value on the left side which needs to be                   on the right side, but I need to know more to decide                   exactly the best thing to do with it.                */
if|if
condition|(
name|still_work_on_right
condition|)
block|{
comment|/* I know I have values on both side which are out of                      position. This is a big win because I kill two birds                      with one swap (so to speak). I can advance the                      uncompared pointers on both sides after swapping both                      of them into the right place.                   */
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
operator|--
name|u_right
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
argument_list|,
name|u_left
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I have an out of position value on the left, but the                      right is fully scanned, so I "slide" the pivot chunk                      and any less-than values left one to make room for the                      greater value over on the right. If the out of position                      value is immediately adjacent to the pivot chunk (there                      are no less-than values), I can do that with a swap,                      otherwise, I have to rotate one of the less than values                      into the former position of the out of position value                      and the right end of the pivot chunk into the left end                      (got all that?).                   */
operator|--
name|pc_left
expr_stmt|;
if|if
condition|(
name|pc_left
operator|==
name|u_right
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_right
argument_list|,
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
operator|-
literal|1
argument_list|,
name|u_left
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qsort_rotate
argument_list|(
name|u_right
argument_list|,
name|pc_left
argument_list|,
name|pc_right
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
argument_list|,
name|pc_right
operator|-
literal|1
argument_list|,
name|u_left
argument_list|,
name|u_right
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|--
name|pc_right
expr_stmt|;
operator|--
name|u_right
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|still_work_on_right
condition|)
block|{
comment|/* Mirror image of complex case above: I have an out of                   position value on the right, but the left is fully                   scanned, so I need to shuffle things around to make room                   for the right value on the left.                */
operator|++
name|pc_right
expr_stmt|;
if|if
condition|(
name|pc_right
operator|==
name|u_left
condition|)
block|{
name|qsort_swap
argument_list|(
name|u_left
argument_list|,
name|pc_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
operator|+
literal|1
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qsort_rotate
argument_list|(
name|pc_right
argument_list|,
name|pc_left
argument_list|,
name|u_left
argument_list|)
expr_stmt|;
name|qsort_all_asserts
argument_list|(
name|pc_left
operator|+
literal|1
argument_list|,
name|pc_right
argument_list|,
name|u_left
operator|+
literal|1
argument_list|,
name|u_right
argument_list|)
expr_stmt|;
block|}
operator|++
name|pc_left
expr_stmt|;
operator|++
name|u_left
expr_stmt|;
block|}
else|else
block|{
comment|/* No more scanning required on either side of partition,                   break out of loop and figure out next set of partitions                */
break|break;
block|}
block|}
comment|/* The elements in the pivot chunk are now in the right place. They             will never move or be compared again. All I have to do is decide             what to do with the stuff to the left and right of the pivot             chunk.              Notes on the QSORT_ORDER_GUESS ifdef code:              1. If I just built these partitions without swapping any (or                very many) elements, there is a chance that the elements are                already ordered properly (being properly ordered will                certainly result in no swapping, but the converse can't be                proved :-).              2. A (properly written) insertion sort will run faster on                already ordered data than qsort will.              3. Perhaps there is some way to make a good guess about                switching to an insertion sort earlier than partition size 6                (for instance - we could save the partition size on the stack                and increase the size each time we find we didn't swap, thus                switching to insertion sort earlier for partitions with a                history of not swapping).              4. Naturally, if I just switch right away, it will make                artificial benchmarks with pure ascending (or descending)                data look really good, but is that a good reason in general?                Hard to say...          */
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
if|if
condition|(
name|swapped
operator|<
literal|3
condition|)
block|{
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|1
name|qsort_break_even
operator|=
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|2
name|qsort_break_even
operator|*=
literal|2
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|QSORT_ORDER_GUESS
operator|==
literal|3
name|int
name|prev_break
init|=
name|qsort_break_even
decl_stmt|;
name|qsort_break_even
operator|*=
name|qsort_break_even
expr_stmt|;
if|if
condition|(
name|qsort_break_even
operator|<
name|prev_break
condition|)
block|{
name|qsort_break_even
operator|=
operator|(
name|part_right
operator|-
name|part_left
operator|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|qsort_break_even
operator|=
name|QSORT_BREAK_EVEN
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|part_left
operator|<
name|pc_left
condition|)
block|{
comment|/* There are elements on the left which need more processing.                Check the right as well before deciding what to do.             */
if|if
condition|(
name|pc_right
operator|<
name|part_right
condition|)
block|{
comment|/* We have two partitions to be sorted. Stack the biggest one                   and process the smallest one on the next iteration. This                   minimizes the stack height by insuring that any additional                   stack entries must come from the smallest partition which                   (because it is smallest) will have the fewest                   opportunities to generate additional stack entries.                */
if|if
condition|(
operator|(
name|part_right
operator|-
name|pc_right
operator|)
operator|>
operator|(
name|pc_left
operator|-
name|part_left
operator|)
condition|)
block|{
comment|/* stack the right partition, process the left */
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
operator|=
name|part_right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
operator|=
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
name|part_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* stack the left partition, process the right */
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
operator|=
name|part_left
expr_stmt|;
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
operator|=
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
name|part_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
block|}
name|qsort_assert
argument_list|(
name|next_stack_entry
operator|<
name|QSORT_MAX_STACK
argument_list|)
expr_stmt|;
operator|++
name|next_stack_entry
expr_stmt|;
block|}
else|else
block|{
comment|/* The elements on the left are the only remaining elements                   that need sorting, arrange for them to be processed as the                   next partition.                */
name|part_right
operator|=
name|pc_left
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc_right
operator|<
name|part_right
condition|)
block|{
comment|/* There is only one chunk on the right to be sorted, make it                the new partition and loop back around.             */
name|part_left
operator|=
name|pc_right
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This whole partition wound up in the pivot chunk, so                we need to get a new partition off the stack.             */
if|if
condition|(
name|next_stack_entry
operator|==
literal|0
condition|)
block|{
comment|/* the stack is empty - we are done */
break|break;
block|}
operator|--
name|next_stack_entry
expr_stmt|;
name|part_left
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
expr_stmt|;
name|part_right
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* This partition is too small to fool with qsort complexity, just             do an ordinary insertion sort to minimize overhead.          */
name|int
name|i
decl_stmt|;
comment|/* Assume 1st element is in right place already, and start checking             at 2nd element to see where it should be inserted.          */
for|for
control|(
name|i
operator|=
name|part_left
operator|+
literal|1
init|;
name|i
operator|<=
name|part_right
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Scan (backwards - just in case 'i' is already in right place)                through the elements already sorted to see if the ith element                belongs ahead of one of them.             */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
name|part_left
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
name|qsort_cmp
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* i belongs right after j                   */
break|break;
block|}
block|}
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
comment|/* Looks like we really need to move some things                */
name|int
name|k
decl_stmt|;
name|temp
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|-
literal|1
init|;
name|k
operator|>=
name|j
condition|;
operator|--
name|k
control|)
name|array
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|array
index|[
name|k
index|]
expr_stmt|;
name|array
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* That partition is now sorted, grab the next one, or get out             of the loop if there aren't any more.          */
if|if
condition|(
name|next_stack_entry
operator|==
literal|0
condition|)
block|{
comment|/* the stack is empty - we are done */
break|break;
block|}
operator|--
name|next_stack_entry
expr_stmt|;
name|part_left
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|left
expr_stmt|;
name|part_right
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|right
expr_stmt|;
ifdef|#
directive|ifdef
name|QSORT_ORDER_GUESS
name|qsort_break_even
operator|=
name|partition_stack
index|[
name|next_stack_entry
index|]
operator|.
name|qsort_break_even
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Believe it or not, the array is sorted at this point! */
block|}
end_function

end_unit

