begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    util.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "Very useful, no doubt, that was to Saruman; yet it seems that he was  * not content."  --Gandalf  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_UTIL_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_ERR
end_ifndef

begin_define
define|#
directive|define
name|SIG_ERR
value|((Sighandler_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_VFORK
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put this after #includes because fork and vfork prototypes may    conflict. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VFORK
end_ifndef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_WAIT
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_LOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FLUSH
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_decl_stmt
name|long
name|xcount
index|[
name|MAXXCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastxcount
index|[
name|MAXXCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|xycount
index|[
name|MAXXCOUNT
index|]
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastxycount
index|[
name|MAXXCOUNT
index|]
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FD_CLOEXEC
argument_list|)
end_if

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_comment
comment|/* NeXT needs this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* paranoid version of system's malloc() */
end_comment

begin_comment
comment|/* NOTE:  Do not call the next three routines directly.  Use the macros  * in handy.h, so that we can easily redefine everything to do tracking of  * allocated hunks back to the original New to track down any memory leaks.  * XXX This advice seems to be widely ignored :-(   --AD  August 1996.  */
end_comment

begin_function
name|Malloc_t
name|Perl_safesysmalloc
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|Malloc_t
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|Perl_error_log
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|Perl_croak_nocontext
argument_list|(
literal|"panic: malloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|PerlMem_malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* malloc(0) is NASTY on our system */
name|PERL_ALLOC_CHECK
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05ld) malloc %ld bytes\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|Perl_error_log
argument_list|,
argument|PL_no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* paranoid version of system's realloc() */
end_comment

begin_function
name|Malloc_t
name|Perl_safesysrealloc
parameter_list|(
name|Malloc_t
name|where
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|Malloc_t
name|ptr
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDARD_C
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_REALLOC_PROTOTYPE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PERL_MICRO
argument_list|)
name|Malloc_t
name|PerlMem_realloc
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* !defined(STANDARD_C)&& !defined(HAS_REALLOC_PROTOTYPE) */
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|Perl_error_log
argument_list|,
literal|"Reallocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|safesysfree
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|where
condition|)
return|return
name|safesysmalloc
argument_list|(
name|size
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|Perl_croak_nocontext
argument_list|(
literal|"panic: realloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|PerlMem_realloc
argument_list|(
name|where
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|PERL_ALLOC_CHECK
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05ld) rfree\n"
argument_list|,
name|PTR2UV
argument_list|(
name|where
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_an
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05ld) realloc %ld bytes\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|Perl_error_log
argument_list|,
argument|PL_no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* safe version of system's free() */
end_comment

begin_function
name|Free_t
name|Perl_safesysfree
parameter_list|(
name|Malloc_t
name|where
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
name|dTHX
expr_stmt|;
endif|#
directive|endif
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05ld) free\n"
argument_list|,
name|PTR2UV
argument_list|(
name|where
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_an
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
condition|)
block|{
comment|/*SUPPRESS 701*/
name|PerlMem_free
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* safe version of system's calloc() */
end_comment

begin_function
name|Malloc_t
name|Perl_safesyscalloc
parameter_list|(
name|MEM_SIZE
name|count
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|Malloc_t
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|*
name|count
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|Perl_error_log
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
argument|size * count
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
operator|||
operator|(
name|long
operator|)
name|count
operator|<
literal|0
condition|)
name|Perl_croak_nocontext
argument_list|(
literal|"panic: calloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|*=
name|count
expr_stmt|;
name|ptr
operator|=
name|PerlMem_malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* malloc(0) is NASTY on our system */
name|PERL_ALLOC_CHECK
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|": (%05ld) calloc %ld x %ld bytes\n"
argument_list|,
name|PTR2UV
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|Perl_error_log
argument_list|,
argument|PL_no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_struct
struct|struct
name|mem_test_strut
block|{
union|union
block|{
name|long
name|type
decl_stmt|;
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|long
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ALIGN
value|sizeof(struct mem_test_strut)
end_define

begin_define
define|#
directive|define
name|sizeof_chunk
parameter_list|(
name|ch
parameter_list|)
value|(((struct mem_test_strut*) (ch))->size)
end_define

begin_define
define|#
directive|define
name|typeof_chunk
parameter_list|(
name|ch
parameter_list|)
define|\
value|(((struct mem_test_strut*) (ch))->u.c[0] + ((struct mem_test_strut*) (ch))->u.c[1]*100)
end_define

begin_define
define|#
directive|define
name|set_typeof_chunk
parameter_list|(
name|ch
parameter_list|,
name|t
parameter_list|)
define|\
value|(((struct mem_test_strut*) (ch))->u.c[0] = t % 100, ((struct mem_test_strut*) (ch))->u.c[1] = t / 100)
end_define

begin_define
define|#
directive|define
name|SIZE_TO_Y
parameter_list|(
name|size
parameter_list|)
value|( (size)> MAXY_SIZE				\ 			  ? MAXYCOUNT - 1 				\ 			  : ( (size)> 40 				\ 			      ? ((size) - 1)/8 + 5			\ 			      : ((size) - 1)/4))
end_define

begin_function
name|Malloc_t
name|Perl_safexmalloc
parameter_list|(
name|I32
name|x
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|safemalloc
argument_list|(
name|size
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xcount
index|[
name|x
index|]
operator|+=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|set_typeof_chunk
argument_list|(
name|where
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|where
operator|+
name|ALIGN
argument_list|)
return|;
block|}
end_function

begin_function
name|Malloc_t
name|Perl_safexrealloc
parameter_list|(
name|Malloc_t
name|wh
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|wh
decl_stmt|;
if|if
condition|(
operator|!
name|wh
condition|)
return|return
name|safexmalloc
argument_list|(
literal|0
argument_list|,
name|size
argument_list|)
return|;
block|{
name|MEM_SIZE
name|old
init|=
name|sizeof_chunk
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|typeof_chunk
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|saferealloc
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|,
name|size
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xycount
index|[
name|t
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|old
argument_list|)
index|]
operator|--
expr_stmt|;
name|xycount
index|[
name|t
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|xcount
index|[
name|t
index|]
operator|+=
name|size
operator|-
name|old
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|new
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|new
operator|+
name|ALIGN
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|Perl_safexfree
parameter_list|(
name|Malloc_t
name|wh
parameter_list|)
block|{
name|I32
name|x
decl_stmt|;
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|wh
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|where
condition|)
return|return;
name|where
operator|-=
name|ALIGN
expr_stmt|;
name|size
operator|=
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|x
operator|=
name|where
index|[
literal|0
index|]
operator|+
literal|100
operator|*
name|where
index|[
literal|1
index|]
expr_stmt|;
name|xcount
index|[
name|x
index|]
operator|-=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|--
expr_stmt|;
name|safefree
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Malloc_t
name|Perl_safexcalloc
parameter_list|(
name|I32
name|x
parameter_list|,
name|MEM_SIZE
name|count
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|safexmalloc
argument_list|(
name|x
argument_list|,
name|size
operator|*
name|count
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xcount
index|[
name|x
index|]
operator|+=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|where
operator|+
name|ALIGN
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
name|set_typeof_chunk
argument_list|(
name|where
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|where
operator|+
name|ALIGN
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_xstat
parameter_list|(
name|pTHX_
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|I32
name|subtot
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
name|subtot
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|xcount
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
name|subtot
index|[
name|j
index|]
operator|+=
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|?
name|xcount
index|[
name|i
index|]
comment|/* Have something */
else|:
operator|(
name|flag
operator|==
literal|2
condition|?
name|xcount
index|[
name|i
index|]
operator|!=
name|lastxcount
index|[
name|i
index|]
comment|/* Changed */
else|:
name|xcount
index|[
name|i
index|]
operator|>
name|lastxcount
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* Growed */
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%2d %02d %7ld "
argument_list|,
name|i
operator|/
literal|100
argument_list|,
name|i
operator|%
literal|100
argument_list|,
name|flag
operator|==
literal|2
condition|?
name|xcount
index|[
name|i
index|]
operator|-
name|lastxcount
index|[
name|i
index|]
else|:
name|xcount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastxcount
index|[
name|i
index|]
operator|=
name|xcount
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|flag
operator|==
literal|0
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
comment|/* Have something */
else|:
operator|(
name|flag
operator|==
literal|2
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
comment|/* Changed */
else|:
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|>
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
condition|)
block|{
comment|/* Growed */
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%3ld "
argument_list|,
name|flag
operator|==
literal|2
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|-
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
else|:
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  . "
argument_list|,
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
operator|!=
literal|2
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Total %7ld "
argument_list|,
name|total
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|subtot
index|[
name|j
index|]
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%3ld "
argument_list|,
name|subtot
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  . "
argument_list|)
expr_stmt|;
block|}
block|}
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEAKTEST */
end_comment

begin_comment
comment|/* copy a string up to some (non-backslashed) delimiter, if any */
end_comment

begin_function
name|char
modifier|*
name|Perl_delimcpy
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
name|char
modifier|*
name|toend
parameter_list|,
specifier|register
name|char
modifier|*
name|from
parameter_list|,
specifier|register
name|char
modifier|*
name|fromend
parameter_list|,
specifier|register
name|int
name|delim
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|I32
name|tolen
decl_stmt|;
for|for
control|(
name|tolen
operator|=
literal|0
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|++
operator|,
name|tolen
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
name|delim
condition|)
name|from
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
name|tolen
operator|++
expr_stmt|;
name|from
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
name|delim
condition|)
break|break;
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|retlen
operator|=
name|tolen
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* return ptr to little string in big string, NULL if not found */
end_comment

begin_comment
comment|/* This routine was donated by Corey Satten. */
end_comment

begin_function
name|char
modifier|*
name|Perl_instr
parameter_list|(
name|pTHX_
specifier|register
specifier|const
name|char
modifier|*
name|big
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|little
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|little
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
while|while
condition|(
operator|*
name|big
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
operator|*
name|s
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|x
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|-
literal|1
operator|)
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* same as instr but allow embedded nulls */
end_comment

begin_function
name|char
modifier|*
name|Perl_ninstr
parameter_list|(
name|pTHX_
specifier|register
specifier|const
name|char
modifier|*
name|big
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|bigend
parameter_list|,
specifier|const
name|char
modifier|*
name|little
parameter_list|,
specifier|const
name|char
modifier|*
name|lend
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>=
name|littleend
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
if|if
condition|(
name|bigend
operator|-
name|big
operator|<
name|littleend
operator|-
name|little
condition|)
return|return
name|Nullch
return|;
name|bigend
operator|-=
name|littleend
operator|-
name|little
operator|++
expr_stmt|;
while|while
condition|(
name|big
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|-
literal|1
operator|)
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* reverse of the above--find last substring */
end_comment

begin_function
name|char
modifier|*
name|Perl_rninstr
parameter_list|(
name|pTHX_
specifier|register
specifier|const
name|char
modifier|*
name|big
parameter_list|,
specifier|const
name|char
modifier|*
name|bigend
parameter_list|,
specifier|const
name|char
modifier|*
name|little
parameter_list|,
specifier|const
name|char
modifier|*
name|lend
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|bigbeg
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>=
name|littleend
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
return|;
name|bigbeg
operator|=
name|big
expr_stmt|;
name|big
operator|=
name|bigend
operator|-
operator|(
name|littleend
operator|-
name|little
operator|++
operator|)
expr_stmt|;
while|while
condition|(
name|big
operator|>=
name|bigbeg
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|--
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
literal|2
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
literal|1
operator|)
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/*  * Set up for a new ctype locale.  */
end_comment

begin_function
name|void
name|Perl_new_ctype
parameter_list|(
name|pTHX_
name|char
modifier|*
name|newctype
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isUPPER_LC
argument_list|(
name|i
argument_list|)
condition|)
name|PL_fold_locale
index|[
name|i
index|]
operator|=
name|toLOWER_LC
argument_list|(
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isLOWER_LC
argument_list|(
name|i
argument_list|)
condition|)
name|PL_fold_locale
index|[
name|i
index|]
operator|=
name|toUPPER_LC
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|PL_fold_locale
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
block|}
end_function

begin_comment
comment|/*  * Standardize the locale name from a string returned by 'setlocale'.  *  * The standard return value of setlocale() is either  * (1) "xx_YY" if the first argument of setlocale() is not LC_ALL  * (2) "xa_YY xb_YY ..." if the first argument of setlocale() is LC_ALL  *     (the space-separated values represent the various sublocales,  *      in some unspecificed order)  *  * In some platforms it has a form like "LC_SOMETHING=Lang_Country.866\n",  * which is harmful for further use of the string in setlocale().  *  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_stdize_locale
parameter_list|(
name|pTHX_
name|char
modifier|*
name|locs
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|bool
name|okay
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|locs
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|okay
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|strchr
argument_list|(
name|t
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|u
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|STRLEN
name|len
init|=
name|u
operator|-
name|s
decl_stmt|;
name|Move
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|locs
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|locs
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|okay
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|okay
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't fix broken locale name \"%s\""
argument_list|,
name|locs
argument_list|)
expr_stmt|;
return|return
name|locs
return|;
block|}
end_function

begin_comment
comment|/*  * Set up for a new collation locale.  */
end_comment

begin_function
name|void
name|Perl_new_collate
parameter_list|(
name|pTHX_
name|char
modifier|*
name|newcoll
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
name|newcoll
condition|)
block|{
if|if
condition|(
name|PL_collation_name
condition|)
block|{
operator|++
name|PL_collation_ix
expr_stmt|;
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|NULL
expr_stmt|;
block|}
name|PL_collation_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_collxfrm_base
operator|=
literal|0
expr_stmt|;
name|PL_collxfrm_mult
operator|=
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|PL_collation_name
operator|||
name|strNE
argument_list|(
name|PL_collation_name
argument_list|,
name|newcoll
argument_list|)
condition|)
block|{
operator|++
name|PL_collation_ix
expr_stmt|;
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|stdize_locale
argument_list|(
name|savepv
argument_list|(
name|newcoll
argument_list|)
argument_list|)
expr_stmt|;
name|PL_collation_standard
operator|=
operator|(
name|strEQ
argument_list|(
name|newcoll
argument_list|,
literal|"C"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|newcoll
argument_list|,
literal|"POSIX"
argument_list|)
operator|)
expr_stmt|;
block|{
comment|/*  2: at most so many chars ('a', 'b'). */
comment|/* 50: surely no system expands a char more. */
define|#
directive|define
name|XFRMBUFSIZE
value|(2 * 50)
name|char
name|xbuf
index|[
name|XFRMBUFSIZE
index|]
decl_stmt|;
name|Size_t
name|fa
init|=
name|strxfrm
argument_list|(
name|xbuf
argument_list|,
literal|"a"
argument_list|,
name|XFRMBUFSIZE
argument_list|)
decl_stmt|;
name|Size_t
name|fb
init|=
name|strxfrm
argument_list|(
name|xbuf
argument_list|,
literal|"ab"
argument_list|,
name|XFRMBUFSIZE
argument_list|)
decl_stmt|;
name|SSize_t
name|mult
init|=
name|fb
operator|-
name|fa
decl_stmt|;
if|if
condition|(
name|mult
operator|<
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"strxfrm() gets absurd"
argument_list|)
expr_stmt|;
name|PL_collxfrm_base
operator|=
operator|(
name|fa
operator|>
name|mult
operator|)
condition|?
operator|(
name|fa
operator|-
name|mult
operator|)
else|:
literal|0
expr_stmt|;
name|PL_collxfrm_mult
operator|=
name|mult
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
block|}
end_function

begin_function
name|void
name|Perl_set_numeric_radix
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
ifdef|#
directive|ifdef
name|HAS_LOCALECONV
name|struct
name|lconv
modifier|*
name|lc
decl_stmt|;
name|lc
operator|=
name|localeconv
argument_list|()
expr_stmt|;
if|if
condition|(
name|lc
operator|&&
name|lc
operator|->
name|decimal_point
condition|)
block|{
if|if
condition|(
name|lc
operator|->
name|decimal_point
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|lc
operator|->
name|decimal_point
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_numeric_radix_sv
argument_list|)
expr_stmt|;
name|PL_numeric_radix_sv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_numeric_radix_sv
condition|)
name|sv_setpv
argument_list|(
name|PL_numeric_radix_sv
argument_list|,
name|lc
operator|->
name|decimal_point
argument_list|)
expr_stmt|;
else|else
name|PL_numeric_radix_sv
operator|=
name|newSVpv
argument_list|(
name|lc
operator|->
name|decimal_point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|PL_numeric_radix_sv
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAS_LOCALECONV */
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_comment
comment|/*  * Set up for a new numeric locale.  */
end_comment

begin_function
name|void
name|Perl_new_numeric
parameter_list|(
name|pTHX_
name|char
modifier|*
name|newnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|newnum
condition|)
block|{
if|if
condition|(
name|PL_numeric_name
condition|)
block|{
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|NULL
expr_stmt|;
block|}
name|PL_numeric_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|PL_numeric_name
operator|||
name|strNE
argument_list|(
name|PL_numeric_name
argument_list|,
name|newnum
argument_list|)
condition|)
block|{
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|stdize_locale
argument_list|(
name|savepv
argument_list|(
name|newnum
argument_list|)
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
operator|(
name|strEQ
argument_list|(
name|newnum
argument_list|,
literal|"C"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|newnum
argument_list|,
literal|"POSIX"
argument_list|)
operator|)
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
name|set_numeric_radix
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_function
name|void
name|Perl_set_numeric_standard
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|PL_numeric_standard
condition|)
block|{
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_numeric_local
operator|=
name|FALSE
expr_stmt|;
name|set_numeric_radix
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_function
name|void
name|Perl_set_numeric_local
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|PL_numeric_local
condition|)
block|{
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
name|FALSE
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
name|set_numeric_radix
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_comment
comment|/*  * Initialize locale awareness.  */
end_comment

begin_function
name|int
name|Perl_init_i18nl10n
parameter_list|(
name|pTHX_
name|int
name|printwarn
parameter_list|)
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
comment|/* returns      *    1 = set ok or not applicable,      *    0 = fallback to C locale,      *   -1 = fallback to C locale failed      */
if|#
directive|if
name|defined
argument_list|(
name|USE_LOCALE
argument_list|)
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|char
modifier|*
name|curctype
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|char
modifier|*
name|curcoll
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|char
modifier|*
name|curnum
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
ifdef|#
directive|ifdef
name|__GLIBC__
name|char
modifier|*
name|language
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LANGUAGE"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|lc_all
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lang
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LANG"
argument_list|)
decl_stmt|;
name|bool
name|setlocale_failure
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE_ENVIRON_REQUIRED
comment|/*      * Ultrix setlocale(..., "") fails if there are no environment      * variables from which to get a locale name.      */
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
name|lang
condition|)
block|{
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
else|else
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|setlocale_failure
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
operator|(
name|curctype
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curctype
operator|=
name|savepv
argument_list|(
name|curctype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
operator|(
name|curcoll
operator|=
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_COLLATE"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curcoll
operator|=
name|savepv
argument_list|(
name|curcoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
operator|(
name|curnum
operator|=
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_NUMERIC"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curnum
operator|=
name|savepv
argument_list|(
name|curnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
endif|#
directive|endif
comment|/* LC_ALL */
endif|#
directive|endif
comment|/* !LOCALE_ENVIRON_REQUIRED */
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
operator|!
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* LC_ALL */
if|if
condition|(
operator|!
name|setlocale_failure
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
operator|(
name|curctype
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curctype
operator|=
name|savepv
argument_list|(
name|curctype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
operator|(
name|curcoll
operator|=
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curcoll
operator|=
name|savepv
argument_list|(
name|curcoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
operator|(
name|curnum
operator|=
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
else|else
name|curnum
operator|=
name|savepv
argument_list|(
name|curnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
if|if
condition|(
name|setlocale_failure
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|locwarn
init|=
operator|(
name|printwarn
operator|>
literal|1
operator|||
operator|(
name|printwarn
operator|&&
operator|(
operator|!
operator|(
name|p
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_BADLANG"
argument_list|)
operator|)
operator|||
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|locwarn
condition|)
block|{
ifdef|#
directive|ifdef
name|LC_ALL
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Setting locale failed.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !LC_ALL */
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Setting locale failed for the categories:\n\t"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
name|curctype
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"LC_CTYPE "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
name|curcoll
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"LC_COLLATE "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|curnum
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"LC_NUMERIC "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LC_ALL */
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Please check that your locale settings:\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GLIBC__
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\tLANGUAGE = %c%s%c,\n"
argument_list|,
name|language
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|language
condition|?
name|language
else|:
literal|"unset"
argument_list|,
name|language
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\tLC_ALL = %c%s%c,\n"
argument_list|,
name|lc_all
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|lc_all
condition|?
name|lc_all
else|:
literal|"unset"
argument_list|,
name|lc_all
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_ENVIRON_ARRAY
argument_list|)
block|{
name|char
modifier|*
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|environ
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
operator|*
name|e
argument_list|,
literal|"LC_"
argument_list|,
literal|3
argument_list|)
operator|&&
name|strnNE
argument_list|(
operator|*
name|e
argument_list|,
literal|"LC_ALL="
argument_list|,
literal|7
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|e
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\t%.*s = \"%s\",\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|e
argument_list|)
argument_list|,
operator|*
name|e
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\t(possibly more locale environment variables)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"\tLANG = %c%s%c\n"
argument_list|,
name|lang
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|lang
condition|?
name|lang
else|:
literal|"unset"
argument_list|,
name|lang
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"    are supported and installed on your system.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
condition|)
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Falling back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Failed to fall back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! LC_ALL */
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
operator|||
operator|!
operator|(
name|curctype
operator|||
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
operator|||
operator|!
operator|(
name|curcoll
operator|||
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
operator|||
operator|!
operator|(
name|curnum
operator|||
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
condition|)
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"perl: warning: Cannot fall back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! LC_ALL */
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|curctype
operator|=
name|savepv
argument_list|(
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|Nullch
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|curcoll
operator|=
name|savepv
argument_list|(
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
name|Nullch
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|curnum
operator|=
name|savepv
argument_list|(
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
name|Nullch
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|new_ctype
argument_list|(
name|curctype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|new_collate
argument_list|(
name|curcoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|new_numeric
argument_list|(
name|curnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
endif|#
directive|endif
comment|/* USE_LOCALE */
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
name|curctype
operator|!=
name|NULL
condition|)
name|Safefree
argument_list|(
name|curctype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
name|curcoll
operator|!=
name|NULL
condition|)
name|Safefree
argument_list|(
name|curcoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
name|curnum
operator|!=
name|NULL
condition|)
name|Safefree
argument_list|(
name|curnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Backwards compatibility. */
end_comment

begin_function
name|int
name|Perl_init_i18nl14n
parameter_list|(
name|pTHX_
name|int
name|printwarn
parameter_list|)
block|{
return|return
name|init_i18nl10n
argument_list|(
name|printwarn
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
end_ifdef

begin_comment
comment|/*  * mem_collxfrm() is a bit like strxfrm() but with two important  * differences. First, it handles embedded NULs. Second, it allocates  * a bit more memory than needed for the transformed data itself.  * The real transformed data begins at offset sizeof(collationix).  * Please see sv_collxfrm() to see how this is used.  */
end_comment

begin_function
name|char
modifier|*
name|Perl_mem_collxfrm
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
modifier|*
name|xlen
parameter_list|)
block|{
name|char
modifier|*
name|xbuf
decl_stmt|;
name|STRLEN
name|xAlloc
decl_stmt|,
name|xin
decl_stmt|,
name|xout
decl_stmt|;
comment|/* xalloc is a reserved word in VC */
comment|/* the first sizeof(collationix) bytes are used by sv_collxfrm(). */
comment|/* the +1 is for the terminating NUL. */
name|xAlloc
operator|=
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
operator|+
name|PL_collxfrm_base
operator|+
operator|(
name|PL_collxfrm_mult
operator|*
name|len
operator|)
operator|+
literal|1
expr_stmt|;
name|New
argument_list|(
literal|171
argument_list|,
name|xbuf
argument_list|,
name|xAlloc
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbuf
condition|)
goto|goto
name|bad
goto|;
operator|*
operator|(
name|U32
operator|*
operator|)
name|xbuf
operator|=
name|PL_collation_ix
expr_stmt|;
name|xout
operator|=
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
expr_stmt|;
for|for
control|(
name|xin
operator|=
literal|0
init|;
name|xin
operator|<
name|len
condition|;
control|)
block|{
name|SSize_t
name|xused
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xused
operator|=
name|strxfrm
argument_list|(
name|xbuf
operator|+
name|xout
argument_list|,
name|s
operator|+
name|xin
argument_list|,
name|xAlloc
operator|-
name|xout
argument_list|)
expr_stmt|;
if|if
condition|(
name|xused
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xused
operator|<
name|xAlloc
operator|-
name|xout
condition|)
break|break;
name|xAlloc
operator|=
operator|(
literal|2
operator|*
name|xAlloc
operator|)
operator|+
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|xbuf
argument_list|,
name|xAlloc
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbuf
condition|)
goto|goto
name|bad
goto|;
block|}
name|xin
operator|+=
name|strlen
argument_list|(
name|s
operator|+
name|xin
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xout
operator|+=
name|xused
expr_stmt|;
comment|/* Embedded NULs are understood but silently skipped 	 * because they make no sense in locale collation. */
block|}
name|xbuf
index|[
name|xout
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|xlen
operator|=
name|xout
operator|-
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
expr_stmt|;
return|return
name|xbuf
return|;
name|bad
label|:
name|Safefree
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
operator|*
name|xlen
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOCALE_COLLATE */
end_comment

begin_define
define|#
directive|define
name|FBM_TABLE_OFFSET
value|2
end_define

begin_comment
comment|/* Number of bytes between EOS and table*/
end_comment

begin_comment
comment|/* As a space optimization, we do not compile tables for strings of length    0 and 1, and for strings of length 2 unless FBMcf_TAIL.  These are    special-cased in fbm_instr().     If FBMcf_TAIL, the table is created as if the string has a trailing \n. */
end_comment

begin_comment
comment|/* =for apidoc fbm_compile  Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.  =cut */
end_comment

begin_function
name|void
name|Perl_fbm_compile
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
specifier|register
name|U8
modifier|*
name|table
decl_stmt|;
specifier|register
name|U32
name|i
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|I32
name|rarest
init|=
literal|0
decl_stmt|;
name|U32
name|frequency
init|=
literal|256
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FBMcf_TAIL
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Taken into account in fbm_instr() */
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVBM
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
comment|/* TAIL might be on on a zero-length string. */
return|return;
if|if
condition|(
name|len
operator|>
literal|2
condition|)
block|{
name|U8
name|mlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
name|mlen
operator|=
literal|255
expr_stmt|;
else|else
name|mlen
operator|=
operator|(
name|U8
operator|)
name|len
expr_stmt|;
name|Sv_Grow
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|256
operator|+
name|FBM_TABLE_OFFSET
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|len
operator|+
name|FBM_TABLE_OFFSET
operator|)
expr_stmt|;
name|s
operator|=
name|table
operator|-
literal|1
operator|-
name|FBM_TABLE_OFFSET
expr_stmt|;
comment|/* last char */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|table
argument_list|,
name|mlen
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|table
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|U8
operator|)
name|flags
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
name|s
operator|-
name|mlen
operator|+
literal|1
expr_stmt|;
comment|/* first char (maybe) */
while|while
condition|(
name|s
operator|>=
name|sb
condition|)
block|{
if|if
condition|(
name|table
index|[
operator|*
name|s
index|]
operator|==
name|mlen
condition|)
name|table
index|[
operator|*
name|s
index|]
operator|=
operator|(
name|U8
operator|)
name|i
expr_stmt|;
name|s
operator|--
operator|,
name|i
operator|++
expr_stmt|;
block|}
block|}
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'B'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* deep magic */
name|SvVALID_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
expr_stmt|;
comment|/* deeper magic */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PL_freq
index|[
name|s
index|[
name|i
index|]
index|]
operator|<
name|frequency
condition|)
block|{
name|rarest
operator|=
name|i
expr_stmt|;
name|frequency
operator|=
name|PL_freq
index|[
name|s
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
name|BmRARE
argument_list|(
name|sv
argument_list|)
operator|=
name|s
index|[
name|rarest
index|]
expr_stmt|;
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
operator|=
name|rarest
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|sv
argument_list|)
operator|=
literal|100
expr_stmt|;
comment|/* Initial value */
if|if
condition|(
name|flags
operator|&
name|FBMcf_TAIL
condition|)
name|SvTAIL_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"rarest char %c at %d\n"
argument_list|,
name|BmRARE
argument_list|(
name|sv
argument_list|)
argument_list|,
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If SvTAIL(littlestr), it has a fake '\n' at end. */
end_comment

begin_comment
comment|/* If SvTAIL is actually due to \Z or \z, this gives false positives    if multiline */
end_comment

begin_comment
comment|/* =for apidoc fbm_instr  Returns the location of the SV in the string delimited by C<str> and C<strend>.  It returns C<Nullch> if the string can't be found.  The C<sv> does not have to be fbm_compiled, but the search will not be as fast then.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_fbm_instr
parameter_list|(
name|pTHX_
name|unsigned
name|char
modifier|*
name|big
parameter_list|,
specifier|register
name|unsigned
name|char
modifier|*
name|bigend
parameter_list|,
name|SV
modifier|*
name|littlestr
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|l
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|SvPV
argument_list|(
name|littlestr
argument_list|,
name|l
argument_list|)
decl_stmt|;
specifier|register
name|STRLEN
name|littlelen
init|=
name|l
decl_stmt|;
specifier|register
name|I32
name|multiline
init|=
name|flags
operator|&
name|FBMrf_MULTILINE
decl_stmt|;
if|if
condition|(
name|bigend
operator|-
name|big
operator|<
name|littlelen
condition|)
block|{
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|(
name|bigend
operator|-
name|big
operator|==
name|littlelen
operator|-
literal|1
operator|)
operator|&&
operator|(
name|littlelen
operator|==
literal|1
operator|||
operator|(
operator|*
name|big
operator|==
operator|*
name|little
operator|&&
name|memEQ
argument_list|(
name|big
argument_list|,
name|little
argument_list|,
name|littlelen
operator|-
literal|1
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
return|return
name|Nullch
return|;
block|}
if|if
condition|(
name|littlelen
operator|<=
literal|2
condition|)
block|{
comment|/* Special-cased */
if|if
condition|(
name|littlelen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|!
name|multiline
condition|)
block|{
comment|/* Anchor only! */
comment|/* Know that bigend != big.  */
if|if
condition|(
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|bigend
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
return|;
block|}
name|s
operator|=
name|big
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bigend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|little
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
return|;
return|return
name|Nullch
return|;
block|}
if|if
condition|(
operator|!
name|littlelen
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
comment|/* Cannot be SvTAIL! */
comment|/* littlelen is 2 */
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|!
name|multiline
condition|)
block|{
if|if
condition|(
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|bigend
index|[
operator|-
literal|2
index|]
operator|==
operator|*
name|little
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
operator|-
literal|2
return|;
if|if
condition|(
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|little
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
operator|-
literal|1
return|;
return|return
name|Nullch
return|;
block|}
block|{
comment|/* This should be better than FBM if c1 == c2, and almost 	       as good otherwise: maybe better since we do less indirection. 	       And we save a lot of memory by caching no table. */
specifier|register
name|unsigned
name|char
name|c1
init|=
name|little
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c2
init|=
name|little
index|[
literal|1
index|]
decl_stmt|;
name|s
operator|=
name|big
operator|+
literal|1
expr_stmt|;
name|bigend
operator|--
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
while|while
condition|(
name|s
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|c1
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
operator|-
literal|1
return|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|next_chars
label|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|c1
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|bigend
condition|)
goto|goto
name|check_1char_anchor
goto|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
name|c2
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
else|else
block|{
name|s
operator|++
expr_stmt|;
goto|goto
name|next_chars
goto|;
block|}
block|}
else|else
name|s
operator|+=
literal|2
expr_stmt|;
block|}
goto|goto
name|check_1char_anchor
goto|;
block|}
comment|/* Now c1 == c2 */
while|while
condition|(
name|s
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|c1
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
name|c1
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
operator|-
literal|1
return|;
if|if
condition|(
name|s
operator|==
name|bigend
condition|)
goto|goto
name|check_1char_anchor
goto|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
name|c1
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|s
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|check_1char_anchor
label|:
comment|/* One char and anchor! */
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|(
operator|*
name|bigend
operator|==
operator|*
name|little
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
return|;
comment|/* bigend is already decremented. */
return|return
name|Nullch
return|;
block|}
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|!
name|multiline
condition|)
block|{
comment|/* tail anchored? */
name|s
operator|=
name|bigend
operator|-
name|littlelen
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|big
operator|&&
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
operator|*
name|s
operator|==
operator|*
name|little
comment|/* Automatically of length> 2 */
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
operator|+
literal|1
argument_list|,
name|littlelen
operator|-
literal|2
argument_list|)
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
comment|/* how sweet it is */
block|}
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
operator|*
name|little
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
operator|+
literal|1
argument_list|,
name|littlelen
operator|-
literal|2
argument_list|)
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|s
operator|+
literal|1
return|;
comment|/* how sweet it is */
block|}
return|return
name|Nullch
return|;
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|littlestr
argument_list|)
operator|!=
name|SVt_PVBM
operator|||
operator|!
name|SvVALID
argument_list|(
name|littlestr
argument_list|)
condition|)
block|{
name|char
modifier|*
name|b
init|=
name|ninstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|big
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bigend
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
operator|+
name|littlelen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|&&
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
condition|)
block|{
comment|/* Automatically multiline!  */
comment|/* Chop \n from littlestr: */
name|s
operator|=
name|bigend
operator|-
name|littlelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|little
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
operator|+
literal|1
argument_list|,
name|littlelen
operator|-
literal|2
argument_list|)
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
return|return
name|Nullch
return|;
block|}
return|return
name|b
return|;
block|}
block|{
comment|/* Do actual FBM.  */
specifier|register
name|unsigned
name|char
modifier|*
name|table
init|=
name|little
operator|+
name|littlelen
operator|+
name|FBM_TABLE_OFFSET
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|oldlittle
decl_stmt|;
if|if
condition|(
name|littlelen
operator|>
name|bigend
operator|-
name|big
condition|)
return|return
name|Nullch
return|;
operator|--
name|littlelen
expr_stmt|;
comment|/* Last char found by table lookup */
name|s
operator|=
name|big
operator|+
name|littlelen
expr_stmt|;
name|little
operator|+=
name|littlelen
expr_stmt|;
comment|/* last char */
name|oldlittle
operator|=
name|little
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
block|{
specifier|register
name|I32
name|tmp
decl_stmt|;
name|top2
label|:
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|(
name|tmp
operator|=
name|table
index|[
operator|*
name|s
index|]
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERRIGOR
if|if
condition|(
name|bigend
operator|-
name|s
operator|>
name|tmp
condition|)
block|{
name|s
operator|+=
name|tmp
expr_stmt|;
goto|goto
name|top2
goto|;
block|}
name|s
operator|+=
name|tmp
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|s
operator|+=
name|tmp
operator|)
operator|<
name|bigend
condition|)
goto|goto
name|top2
goto|;
endif|#
directive|endif
goto|goto
name|check_end
goto|;
block|}
else|else
block|{
comment|/* less expensive than calling strncmp() */
specifier|register
name|unsigned
name|char
modifier|*
name|olds
init|=
name|s
decl_stmt|;
name|tmp
operator|=
name|littlelen
expr_stmt|;
while|while
condition|(
name|tmp
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|s
operator|==
operator|*
operator|--
name|little
condition|)
continue|continue;
name|s
operator|=
name|olds
operator|+
literal|1
expr_stmt|;
comment|/* here we pay the price for failure */
name|little
operator|=
name|oldlittle
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
comment|/* fake up continue to outer loop */
goto|goto
name|top2
goto|;
goto|goto
name|check_end
goto|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
block|}
name|check_end
label|:
if|if
condition|(
name|s
operator|==
name|bigend
operator|&&
operator|(
name|table
index|[
operator|-
literal|1
index|]
operator|&
name|FBMcf_TAIL
operator|)
operator|&&
name|memEQ
argument_list|(
name|bigend
operator|-
name|littlelen
argument_list|,
name|oldlittle
operator|-
name|littlelen
argument_list|,
name|littlelen
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
operator|-
name|littlelen
return|;
return|return
name|Nullch
return|;
block|}
block|}
end_function

begin_comment
comment|/* start_shift, end_shift are positive quantities which give offsets    of ends of some substring of bigstr.    If `last' we want the last occurence.    old_posp is the way of communication between consequent calls if    the next call needs to find the .     The initial *old_posp should be -1.     Note that we take into account SvTAIL, so one can get extra    optimizations if _ALL flag is set.  */
end_comment

begin_comment
comment|/* If SvTAIL is actually due to \Z or \z, this gives false positives    if PL_multiline.  In fact if !PL_multiline the autoritative answer    is not supported yet. */
end_comment

begin_function
name|char
modifier|*
name|Perl_screaminstr
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|bigstr
parameter_list|,
name|SV
modifier|*
name|littlestr
parameter_list|,
name|I32
name|start_shift
parameter_list|,
name|I32
name|end_shift
parameter_list|,
name|I32
modifier|*
name|old_posp
parameter_list|,
name|I32
name|last
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|I32
name|pos
decl_stmt|;
specifier|register
name|I32
name|previous
decl_stmt|;
specifier|register
name|I32
name|first
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
decl_stmt|;
specifier|register
name|I32
name|stop_pos
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|littleend
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|old_posp
operator|==
operator|-
literal|1
condition|?
operator|(
name|pos
operator|=
name|PL_screamfirst
index|[
name|BmRARE
argument_list|(
name|littlestr
argument_list|)
index|]
operator|)
operator|<
literal|0
else|:
operator|(
operator|(
operator|(
name|pos
operator|=
operator|*
name|old_posp
operator|)
operator|,
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cant_find
label|:
if|if
condition|(
name|BmRARE
argument_list|(
name|littlestr
argument_list|)
operator|==
literal|'\n'
operator|&&
name|BmPREVIOUS
argument_list|(
name|littlestr
argument_list|)
operator|==
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
operator|-
literal|1
condition|)
block|{
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
operator|)
expr_stmt|;
name|littleend
operator|=
name|little
operator|+
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
goto|goto
name|check_tail
goto|;
block|}
return|return
name|Nullch
return|;
block|}
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
operator|)
expr_stmt|;
name|littleend
operator|=
name|little
operator|+
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
comment|/* The value of pos we can start at: */
name|previous
operator|=
name|BmPREVIOUS
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|big
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|)
expr_stmt|;
comment|/* The value of pos we can stop at: */
name|stop_pos
operator|=
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|-
name|end_shift
operator|-
operator|(
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
operator|-
literal|1
operator|-
name|previous
operator|)
expr_stmt|;
if|if
condition|(
name|previous
operator|+
name|start_shift
operator|>
name|stop_pos
condition|)
block|{
if|if
condition|(
name|previous
operator|+
name|start_shift
operator|==
name|stop_pos
operator|+
literal|1
condition|)
comment|/* A fake '\n'? */
goto|goto
name|check_tail
goto|;
return|return
name|Nullch
return|;
block|}
while|while
condition|(
name|pos
operator|<
name|previous
operator|+
name|start_shift
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
operator|)
condition|)
goto|goto
name|cant_find
goto|;
block|}
ifdef|#
directive|ifdef
name|POINTERRIGOR
do|do
block|{
if|if
condition|(
name|pos
operator|>=
name|stop_pos
condition|)
break|break;
if|if
condition|(
name|big
index|[
name|pos
operator|-
name|previous
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|-
name|previous
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
block|{
operator|*
name|old_posp
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|-
name|previous
operator|)
return|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
condition|)
do|;
return|return
operator|(
name|last
operator|&&
name|found
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
operator|(
operator|*
name|old_posp
operator|)
operator|-
name|previous
operator|)
else|:
name|Nullch
return|;
else|#
directive|else
comment|/* !POINTERRIGOR */
name|big
operator|-=
name|previous
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pos
operator|>=
name|stop_pos
condition|)
break|break;
if|if
condition|(
name|big
index|[
name|pos
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
block|{
operator|*
name|old_posp
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|)
return|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
condition|)
do|;
if|if
condition|(
name|last
operator|&&
name|found
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
operator|(
operator|*
name|old_posp
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* POINTERRIGOR */
name|check_tail
label|:
if|if
condition|(
operator|!
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|||
operator|(
name|end_shift
operator|>
literal|0
operator|)
condition|)
return|return
name|Nullch
return|;
comment|/* Ignore the trailing "\n".  This code is not microoptimized */
name|big
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|)
expr_stmt|;
name|stop_pos
operator|=
name|littleend
operator|-
name|little
expr_stmt|;
comment|/* Actual littlestr len */
if|if
condition|(
name|stop_pos
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
name|big
operator|-=
name|stop_pos
expr_stmt|;
if|if
condition|(
operator|*
name|big
operator|==
name|first
operator|&&
operator|(
operator|(
name|stop_pos
operator|==
literal|1
operator|)
operator|||
name|memEQ
argument_list|(
name|big
operator|+
literal|1
argument_list|,
name|little
argument_list|,
name|stop_pos
operator|-
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
return|return
name|Nullch
return|;
block|}
end_function

begin_function
name|I32
name|Perl_ibcmp
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|&&
operator|*
name|a
operator|!=
name|PL_fold
index|[
operator|*
name|b
index|]
condition|)
return|return
literal|1
return|;
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|I32
name|Perl_ibcmp_locale
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|&&
operator|*
name|a
operator|!=
name|PL_fold_locale
index|[
operator|*
name|b
index|]
condition|)
return|return
literal|1
return|;
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* copy a string to a safe spot */
end_comment

begin_comment
comment|/* =for apidoc savepv  Copy a string to a safe spot.  This does not use an SV.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_savepv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|902
argument_list|,
name|newaddr
argument_list|,
name|strlen
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newaddr
argument_list|,
name|sv
argument_list|)
expr_stmt|;
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* same thing but with a known length */
end_comment

begin_comment
comment|/* =for apidoc savepvn  Copy a string to a safe spot.  The C<len> indicates number of bytes to copy.  This does not use an SV.  =cut */
end_comment

begin_function
name|char
modifier|*
name|Perl_savepvn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sv
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|903
argument_list|,
name|newaddr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|sv
argument_list|,
name|newaddr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* might not be null terminated */
name|newaddr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* is now */
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* the SV for Perl_form() and mess() is not kept in an arena */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|S_mess_alloc
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|XPVMG
modifier|*
name|any
decl_stmt|;
if|if
condition|(
operator|!
name|PL_dirty
condition|)
return|return
name|sv_2mortal
argument_list|(
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|PL_mess_sv
condition|)
return|return
name|PL_mess_sv
return|;
comment|/* Create as PVMG now, to avoid any upgrading later */
name|New
argument_list|(
literal|905
argument_list|,
name|sv
argument_list|,
literal|1
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|905
argument_list|,
name|any
argument_list|,
literal|1
argument_list|,
name|XPVMG
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVt_PVMG
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|any
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|/* practically infinite */
name|PL_mess_sv
operator|=
name|sv
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|char
modifier|*
name|Perl_form_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|retval
operator|=
name|vform
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_function
name|char
modifier|*
name|Perl_form
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|retval
operator|=
name|vform
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_vform
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|mess_alloc
argument_list|()
decl_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|Perl_mess_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|SV
modifier|*
name|retval
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|retval
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_function
name|SV
modifier|*
name|Perl_mess
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|SV
modifier|*
name|retval
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|retval
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_vmess
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|mess_alloc
argument_list|()
decl_stmt|;
specifier|static
name|char
name|dgd
index|[]
init|=
literal|" during global destruction.\n"
decl_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|||
operator|*
operator|(
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|" at %s line %"
argument|IVdf
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(IV)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
if|if
condition|(
name|GvIO
argument_list|(
name|PL_last_in_gv
argument_list|)
operator|&&
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|line_mode
init|=
operator|(
name|RsSIMPLE
argument_list|(
name|PL_rs
argument_list|)
operator|&&
name|SvCUR
argument_list|(
name|PL_rs
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|SvPVX
argument_list|(
name|PL_rs
argument_list|)
operator|==
literal|'\n'
operator|)
decl_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|",<%s> %s %"
argument|IVdf
argument_list|,
argument|PL_last_in_gv == PL_argvgv ?
literal|""
argument|: GvNAME(PL_last_in_gv)
argument_list|,
argument|line_mode ?
literal|"line"
argument|:
literal|"chunk"
argument_list|,
argument|(IV)IoLINES(GvIOp(PL_last_in_gv))
argument_list|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|thr
operator|->
name|tid
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|" thread %ld"
argument_list|,
argument|thr->tid
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PL_dirty
condition|?
name|dgd
else|:
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_vdie
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|int
name|was_in_eval
init|=
name|PL_in_eval
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|SV
modifier|*
name|msv
decl_stmt|;
name|STRLEN
name|msglen
decl_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%p: die: curstack = %p, mainstack = %p\n"
argument_list|,
name|thr
argument_list|,
name|PL_curstack
argument_list|,
name|PL_mainstack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|msv
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_errors
operator|&&
name|SvCUR
argument_list|(
name|PL_errors
argument_list|)
condition|)
block|{
name|sv_catsv
argument_list|(
name|PL_errors
argument_list|,
name|msv
argument_list|)
expr_stmt|;
name|message
operator|=
name|SvPV
argument_list|(
name|PL_errors
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_errors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|message
operator|=
name|SvPV
argument_list|(
name|msv
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|=
name|Nullch
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%p: die: message = %s\ndiehook = %p\n"
argument_list|,
name|thr
argument_list|,
name|message
argument_list|,
name|PL_diehook
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_diehook
condition|)
block|{
comment|/* sv_2cv might call Perl_croak() */
name|SV
modifier|*
name|olddiehook
init|=
name|PL_diehook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|olddiehook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|save_re_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
name|msg
operator|=
name|newSVpvn
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|ERRSV
expr_stmt|;
block|}
name|PUSHSTACKi
argument_list|(
name|PERLSI_DIEHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
name|PL_restartop
operator|=
name|die_where
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%p: die: restartop = %p, was_in_eval = %d, top_env = %p\n"
argument_list|,
name|thr
argument_list|,
name|PL_restartop
argument_list|,
name|was_in_eval
argument_list|,
name|PL_top_env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|PL_restartop
operator|&&
name|was_in_eval
operator|)
operator|||
name|PL_top_env
operator|->
name|je_prev
condition|)
name|JMPENV_JUMP
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|PL_restartop
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|OP
modifier|*
name|Perl_die_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|o
operator|=
name|vdie
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_function
name|OP
modifier|*
name|Perl_die
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|o
operator|=
name|vdie
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|void
name|Perl_vcroak
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|SV
modifier|*
name|msv
decl_stmt|;
name|STRLEN
name|msglen
decl_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|msv
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_errors
operator|&&
name|SvCUR
argument_list|(
name|PL_errors
argument_list|)
condition|)
block|{
name|sv_catsv
argument_list|(
name|PL_errors
argument_list|,
name|msv
argument_list|)
expr_stmt|;
name|message
operator|=
name|SvPV
argument_list|(
name|PL_errors
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_errors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|message
operator|=
name|SvPV
argument_list|(
name|msv
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|=
name|Nullch
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"croak: 0x%"
name|UVxf
literal|" %s"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_diehook
condition|)
block|{
comment|/* sv_2cv might call Perl_croak() */
name|SV
modifier|*
name|olddiehook
init|=
name|PL_diehook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|olddiehook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|save_re_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
name|msg
operator|=
name|newSVpvn
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|ERRSV
expr_stmt|;
block|}
name|PUSHSTACKi
argument_list|(
name|PERLSI_DIEHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|PL_restartop
operator|=
name|die_where
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|JMPENV_JUMP
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|{
ifdef|#
directive|ifdef
name|USE_SFIO
comment|/* SFIO can really mess with your errno */
name|int
name|e
init|=
name|errno
decl_stmt|;
endif|#
directive|endif
name|PerlIO
modifier|*
name|serr
init|=
name|Perl_error_log
decl_stmt|;
name|PerlIO_write
argument_list|(
name|serr
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|serr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SFIO
name|errno
operator|=
name|e
expr_stmt|;
endif|#
directive|endif
block|}
name|my_failure_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|void
name|Perl_croak_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vcroak
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_comment
comment|/* =for apidoc croak  This is the XSUB-writer's interface to Perl's C<die> function. Normally use this function the same way you use the C C<printf> function.  See C<warn>.  If you want to throw an exception object, assign the object to C<$@> and then pass C<Nullch> to croak():     errsv = get_sv("@", TRUE);    sv_setsv(errsv, exception_object);    croak(Nullch);  =cut */
end_comment

begin_function
name|void
name|Perl_croak
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vcroak
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_vwarn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|SV
modifier|*
name|msv
decl_stmt|;
name|STRLEN
name|msglen
decl_stmt|;
name|msv
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|message
operator|=
name|SvPV
argument_list|(
name|msv
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_warnhook
condition|)
block|{
comment|/* sv_2cv might call Perl_warn() */
name|SV
modifier|*
name|oldwarnhook
init|=
name|PL_warnhook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_warnhook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|oldwarnhook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|save_re_context
argument_list|()
expr_stmt|;
name|msg
operator|=
name|newSVpvn
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_WARNHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return;
block|}
block|}
block|{
name|PerlIO
modifier|*
name|serr
init|=
name|Perl_error_log
decl_stmt|;
name|PerlIO_write
argument_list|(
name|serr
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
name|DEBUG_L
argument_list|(
operator|*
name|message
operator|==
literal|'!'
condition|?
operator|(
name|xstat
argument_list|(
name|message
index|[
literal|1
index|]
operator|==
literal|'!'
condition|?
operator|(
name|message
index|[
literal|2
index|]
operator|==
literal|'!'
condition|?
literal|2
else|:
literal|1
operator|)
else|:
literal|0
argument_list|)
operator|,
literal|0
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|serr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|void
name|Perl_warn_nocontext
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vwarn
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_comment
comment|/* =for apidoc warn  This is the XSUB-writer's interface to Perl's C<warn> function.  Use this function the same way you use the C C<printf> function.  See C<croak>.  =cut */
end_comment

begin_function
name|void
name|Perl_warn
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vwarn
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_function
name|void
name|Perl_warner_nocontext
parameter_list|(
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vwarner
argument_list|(
name|err
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_CONTEXT */
end_comment

begin_function
name|void
name|Perl_warner
parameter_list|(
name|pTHX_
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vwarner
argument_list|(
name|err
argument_list|,
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_vwarner
parameter_list|(
name|pTHX_
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|SV
modifier|*
name|msv
decl_stmt|;
name|STRLEN
name|msglen
decl_stmt|;
name|msv
operator|=
name|vmess
argument_list|(
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|message
operator|=
name|SvPV
argument_list|(
name|msv
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckDEAD
argument_list|(
name|err
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"croak: 0x%"
name|UVxf
literal|" %s"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|PL_diehook
condition|)
block|{
comment|/* sv_2cv might call Perl_croak() */
name|SV
modifier|*
name|olddiehook
init|=
name|PL_diehook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|olddiehook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|save_re_context
argument_list|()
expr_stmt|;
name|msg
operator|=
name|newSVpvn
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_DIEHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|PL_restartop
operator|=
name|die_where
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|JMPENV_JUMP
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|{
name|PerlIO
modifier|*
name|serr
init|=
name|Perl_error_log
decl_stmt|;
name|PerlIO_write
argument_list|(
name|serr
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|serr
argument_list|)
expr_stmt|;
block|}
name|my_failure_exit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_warnhook
condition|)
block|{
comment|/* sv_2cv might call Perl_warn() */
name|SV
modifier|*
name|oldwarnhook
init|=
name|PL_warnhook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_warnhook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|oldwarnhook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|save_re_context
argument_list|()
expr_stmt|;
name|msg
operator|=
name|newSVpvn
argument_list|(
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_WARNHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return;
block|}
block|}
block|{
name|PerlIO
modifier|*
name|serr
init|=
name|Perl_error_log
decl_stmt|;
name|PerlIO_write
argument_list|(
name|serr
argument_list|,
name|message
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
name|DEBUG_L
argument_list|(
operator|*
name|message
operator|==
literal|'!'
condition|?
operator|(
name|xstat
argument_list|(
name|message
index|[
literal|1
index|]
operator|==
literal|'!'
condition|?
operator|(
name|message
index|[
literal|2
index|]
operator|==
literal|'!'
condition|?
literal|2
else|:
literal|1
operator|)
else|:
literal|0
argument_list|)
operator|,
literal|0
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|serr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ENVIRON_ARRAY
end_ifdef

begin_comment
comment|/* VMS' and EPOC's my_setenv() is in vms.c and epoc.c */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_function
name|void
name|Perl_my_setenv
parameter_list|(
name|pTHX_
name|char
modifier|*
name|nam
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PERL_USE_SAFE_PUTENV
comment|/* most putenv()s leak, so we manipulate environ directly */
specifier|register
name|I32
name|i
init|=
name|setenv_getix
argument_list|(
name|nam
argument_list|)
decl_stmt|;
comment|/* where does it go? */
if|if
condition|(
name|environ
operator|==
name|PL_origenviron
condition|)
block|{
comment|/* need we copy environment? */
name|I32
name|j
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmpenv
decl_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|max
operator|=
name|i
init|;
name|environ
index|[
name|max
index|]
condition|;
name|max
operator|++
control|)
empty_stmt|;
name|tmpenv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|safesysmalloc
argument_list|(
operator|(
name|max
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
block|{
comment|/* copy environment */
name|tmpenv
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|safesysmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|environ
index|[
name|j
index|]
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpenv
index|[
name|j
index|]
argument_list|,
name|environ
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|tmpenv
index|[
name|max
index|]
operator|=
name|Nullch
expr_stmt|;
name|environ
operator|=
name|tmpenv
expr_stmt|;
comment|/* tell exec where it is now */
block|}
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|safesysfree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|environ
index|[
name|i
index|]
condition|)
block|{
name|environ
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|environ
index|[
name|i
index|]
condition|)
block|{
comment|/* does not exist yet */
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|safesysrealloc
argument_list|(
name|environ
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|environ
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|Nullch
expr_stmt|;
comment|/* make sure it's null terminated */
block|}
else|else
name|safesysfree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|environ
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|safesysmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* all that work just for this */
else|#
directive|else
comment|/* PERL_USE_SAFE_PUTENV */
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|setenv
argument_list|(
name|nam
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|new_env
decl_stmt|;
name|new_env
operator|=
operator|(
name|char
operator|*
operator|)
name|safesysmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new_env
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* all that work just for this */
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|new_env
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __CYGWIN__ */
endif|#
directive|endif
comment|/* PERL_USE_SAFE_PUTENV */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN32 */
end_comment

begin_function
name|void
name|Perl_my_setenv
parameter_list|(
name|pTHX_
name|char
modifier|*
name|nam
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|envstr
decl_stmt|;
name|STRLEN
name|len
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|val
operator|=
literal|""
expr_stmt|;
block|}
name|len
operator|+=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|904
argument_list|,
name|envstr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlEnv_putenv
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_function
name|I32
name|Perl_setenv_getix
parameter_list|(
name|pTHX_
name|char
modifier|*
name|nam
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|WIN32
name|strnicmp
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|,
name|len
argument_list|)
operator|==
literal|0
else|#
directive|else
name|strnEQ
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|,
name|len
argument_list|)
endif|#
directive|endif
operator|&&
name|environ
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
literal|'='
condition|)
break|break;
comment|/* strnEQ must come first to avoid */
block|}
comment|/* potential SEGV's */
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VMS&& !EPOC*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNLINK_ALL_VERSIONS
end_ifdef

begin_function
name|I32
name|Perl_unlnk
parameter_list|(
name|pTHX_
name|char
modifier|*
name|f
parameter_list|)
comment|/* unlink all versions of a file */
block|{
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|PerlLIO_unlink
argument_list|(
name|f
argument_list|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is a drop-in replacement for bcopy() */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BCOPY
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SAFE_BCOPY
argument_list|)
end_if

begin_function
name|char
modifier|*
name|Perl_my_bcopy
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|-
name|to
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
else|else
block|{
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
operator|(
operator|--
name|to
operator|)
operator|=
operator|*
operator|(
operator|--
name|from
operator|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is a drop-in replacement for memset() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_MEMSET
end_ifndef

begin_function
name|void
modifier|*
name|Perl_my_memset
parameter_list|(
specifier|register
name|char
modifier|*
name|loc
parameter_list|,
specifier|register
name|I32
name|ch
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|loc
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|loc
operator|++
operator|=
name|ch
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is a drop-in replacement for bzero() */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BZERO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_MEMSET
argument_list|)
end_if

begin_function
name|char
modifier|*
name|Perl_my_bzero
parameter_list|(
specifier|register
name|char
modifier|*
name|loc
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|loc
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|loc
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is a drop-in replacement for memcmp() */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MEMCMP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SANE_MEMCMP
argument_list|)
end_if

begin_function
name|I32
name|Perl_my_memcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|tmp
operator|=
operator|*
name|a
operator|++
operator|-
operator|*
name|b
operator|++
condition|)
return|return
name|tmp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_MEMCMP || !HAS_SANE_MEMCMP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VPRINTF
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CHAR_VSPRINTF
end_ifdef

begin_function
name|char
modifier|*
else|#
directive|else
name|int
endif|#
directive|endif
name|vsprintf
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|char
modifier|*
name|args
parameter_list|)
block|{
name|FILE
name|fakebuf
decl_stmt|;
name|fakebuf
operator|.
name|_ptr
operator|=
name|dest
expr_stmt|;
name|fakebuf
operator|.
name|_cnt
operator|=
literal|32767
expr_stmt|;
ifndef|#
directive|ifndef
name|_IOSTRG
define|#
directive|define
name|_IOSTRG
value|0
endif|#
directive|endif
name|fakebuf
operator|.
name|_flag
operator|=
name|_IOWRT
operator||
name|_IOSTRG
expr_stmt|;
name|_doprnt
argument_list|(
name|pat
argument_list|,
name|args
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
comment|/* what a kludge */
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CHAR_VSPRINTF
return|return
operator|(
name|dest
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
comment|/* perl doesn't use return value */
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_VPRINTF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MYSWAP
end_ifdef

begin_if
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x4321
end_if

begin_function
name|short
name|Perl_my_swap
parameter_list|(
name|pTHX_
name|short
name|s
parameter_list|)
block|{
if|#
directive|if
operator|(
name|BYTEORDER
operator|&
literal|1
operator|)
operator|==
literal|0
name|short
name|result
decl_stmt|;
name|result
operator|=
operator|(
operator|(
name|s
operator|&
literal|255
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|255
operator|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
name|s
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|Perl_my_htonl
parameter_list|(
name|pTHX_
name|long
name|l
parameter_list|)
block|{
union|union
block|{
name|long
name|result
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|result
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|I32
name|o
decl_stmt|;
specifier|register
name|I32
name|s
decl_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|=
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|255
expr_stmt|;
block|}
return|return
name|u
operator|.
name|result
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|Perl_my_ntohl
parameter_list|(
name|pTHX_
name|long
name|l
parameter_list|)
block|{
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|l
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|I32
name|o
decl_stmt|;
specifier|register
name|I32
name|s
decl_stmt|;
name|u
operator|.
name|l
operator|=
name|l
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|l
operator||=
operator|(
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|&
literal|255
operator|)
operator|<<
name|s
expr_stmt|;
block|}
return|return
name|l
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYTEORDER != 0x4321 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYSWAP */
end_comment

begin_comment
comment|/*  * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.  * If these functions are defined,  * the BYTEORDER is neither 0x1234 nor 0x4321.  * However, this is not assumed.  * -DWS  */
end_comment

begin_define
define|#
directive|define
name|HTOV
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (register type n)					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register I32 i;					\ 	    register I32 s;					\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		u.c[i] = (n>> s)& 0xFF;			\ 	    }							\ 	    return u.value;					\ 	}
end_define

begin_define
define|#
directive|define
name|VTOH
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (register type n)					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register I32 i;					\ 	    register I32 s;					\ 	    u.value = n;					\ 	    n = 0;						\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		n += (u.c[i]& 0xFF)<< s;			\ 	    }							\ 	    return n;						\ 	}
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovs
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovl
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohs
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohl
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS' my_popen() is in VMS.c, same with OS/2. */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPEN_VM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
end_if

begin_function
name|PerlIO
modifier|*
name|Perl_my_popen
parameter_list|(
name|pTHX_
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|I32
name|This
decl_stmt|,
name|that
decl_stmt|;
specifier|register
name|Pid_t
name|pid
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|doexec
init|=
name|strNE
argument_list|(
name|cmd
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
name|I32
name|did_pipes
init|=
literal|0
decl_stmt|;
name|int
name|pp
index|[
literal|2
index|]
decl_stmt|;
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|doexec
condition|)
block|{
return|return
name|my_syspopen
argument_list|(
argument|aTHX_ cmd
argument_list|,
argument|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
name|This
operator|=
operator|(
operator|*
name|mode
operator|==
literal|'w'
operator|)
expr_stmt|;
name|that
operator|=
operator|!
name|This
expr_stmt|;
if|if
condition|(
name|doexec
operator|&&
name|PL_tainting
condition|)
block|{
name|taint_env
argument_list|()
expr_stmt|;
name|taint_proper
argument_list|(
literal|"Insecure %s%s"
argument_list|,
literal|"EXEC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Nullfp
return|;
if|if
condition|(
name|doexec
operator|&&
name|PerlProc_pipe
argument_list|(
name|pp
argument_list|)
operator|>=
literal|0
condition|)
name|did_pipes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
operator|(
name|doexec
condition|?
name|vfork
argument_list|()
else|:
name|fork
argument_list|()
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|p
index|[
name|This
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_pipes
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doexec
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't fork"
argument_list|)
expr_stmt|;
return|return
name|Nullfp
return|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|GV
modifier|*
name|tmpgv
decl_stmt|;
undef|#
directive|undef
name|THIS
undef|#
directive|undef
name|THAT
define|#
directive|define
name|THIS
value|that
define|#
directive|define
name|THAT
value|This
name|PerlLIO_close
argument_list|(
name|p
index|[
name|THAT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_pipes
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fcntl
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|p
index|[
name|THIS
index|]
operator|!=
operator|(
operator|*
name|mode
operator|==
literal|'r'
operator|)
condition|)
block|{
name|PerlLIO_dup2
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|,
operator|*
name|mode
operator|==
literal|'r'
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OS2
if|if
condition|(
name|doexec
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|int
name|fd
decl_stmt|;
ifndef|#
directive|ifndef
name|NOFILE
define|#
directive|define
name|NOFILE
value|20
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
name|PL_maxsysfd
operator|+
literal|1
init|;
name|fd
operator|<
name|NOFILE
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|fd
operator|!=
name|pp
index|[
literal|1
index|]
condition|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_exec3
argument_list|(
name|cmd
argument_list|,
name|pp
index|[
literal|1
index|]
argument_list|,
name|did_pipes
argument_list|)
expr_stmt|;
comment|/* may or may not use the shell */
name|PerlProc__exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined OS2 */
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|(
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"$"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
operator|)
condition|)
name|sv_setiv
argument_list|(
name|GvSV
argument_list|(
name|tmpgv
argument_list|)
argument_list|,
name|PerlProc_getpid
argument_list|()
argument_list|)
expr_stmt|;
name|PL_forkprocess
operator|=
literal|0
expr_stmt|;
name|hv_clear
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
comment|/* we have no children */
return|return
name|Nullfp
return|;
undef|#
directive|undef
name|THIS
undef|#
directive|undef
name|THAT
block|}
name|do_execfree
argument_list|()
expr_stmt|;
comment|/* free any memory malloced by child on vfork */
name|PerlLIO_close
argument_list|(
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_pipes
condition|)
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|that
index|]
operator|<
name|p
index|[
name|This
index|]
condition|)
block|{
name|PerlLIO_dup2
argument_list|(
name|p
index|[
name|This
index|]
argument_list|,
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|p
index|[
name|This
index|]
argument_list|)
expr_stmt|;
name|p
index|[
name|This
index|]
operator|=
name|p
index|[
name|that
index|]
expr_stmt|;
block|}
name|LOCK_FDPID_MUTEX
expr_stmt|;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|p
index|[
name|This
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|UNLOCK_FDPID_MUTEX
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pid
expr_stmt|;
name|PL_forkprocess
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|did_pipes
operator|&&
name|pid
operator|>
literal|0
condition|)
block|{
name|int
name|errkid
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|n1
decl_stmt|;
while|while
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|n1
operator|=
name|PerlLIO_read
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|errkid
operator|)
operator|+
name|n
operator|)
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|<=
literal|0
condition|)
break|break;
name|n
operator|+=
name|n1
expr_stmt|;
block|}
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|did_pipes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* Error */
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: kid popen errno read"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|errkid
expr_stmt|;
comment|/* Propagate errno from kid */
return|return
name|Nullfp
return|;
block|}
block|}
if|if
condition|(
name|did_pipes
condition|)
name|PerlLIO_close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|PerlIO_fdopen
argument_list|(
name|p
index|[
name|This
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
end_if

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|PerlIO
modifier|*
name|Perl_my_popen
parameter_list|(
name|pTHX_
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
comment|/* Needs work for PerlIO ! */
comment|/* used 0 for 2nd parameter to PerlIO-exportFILE; apparently not used */
name|PERL_FLUSHALL_FOR_CHILD
expr_stmt|;
return|return
name|popen
argument_list|(
name|PerlIO_exportFILE
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DUMP_FDS
end_ifdef

begin_function
name|void
name|Perl_dump_fds
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|32
condition|;
name|fd
operator|++
control|)
block|{
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpstatbuf
argument_list|)
operator|>=
literal|0
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMP_FDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_DUP2
end_ifndef

begin_function
name|int
name|dup2
parameter_list|(
name|int
name|oldfd
parameter_list|,
name|int
name|newfd
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_DUPFD
argument_list|)
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|PerlLIO_close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|oldfd
argument_list|,
name|F_DUPFD
argument_list|,
name|newfd
argument_list|)
return|;
else|#
directive|else
define|#
directive|define
name|DUP2_MAX_FDS
value|256
name|int
name|fdtmp
index|[
name|DUP2_MAX_FDS
index|]
decl_stmt|;
name|I32
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|PerlLIO_close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
comment|/* good enough for low fd's... */
while|while
condition|(
operator|(
name|fd
operator|=
name|PerlLIO_dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
operator|&&
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fdx
operator|>=
name|DUP2_MAX_FDS
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
block|}
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|PerlLIO_close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SIGACTION
end_ifdef

begin_function
name|Sighandler_t
name|Perl_rsignal
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_RESTART
name|act
operator|.
name|sa_flags
operator||=
name|SA_RESTART
expr_stmt|;
comment|/* SVR4, 4.3+BSD */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_NOCLDWAIT
if|if
condition|(
name|signo
operator|==
name|SIGCHLD
operator|&&
name|handler
operator|==
operator|(
name|Sighandler_t
operator|)
name|SIG_IGN
condition|)
name|act
operator|.
name|sa_flags
operator||=
name|SA_NOCLDWAIT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SIG_ERR
return|;
else|else
return|return
name|oact
operator|.
name|sa_handler
return|;
block|}
end_function

begin_function
name|Sighandler_t
name|Perl_rsignal_state
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|)
block|{
name|struct
name|sigaction
name|oact
decl_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SIG_ERR
return|;
else|else
return|return
name|oact
operator|.
name|sa_handler
return|;
block|}
end_function

begin_function
name|int
name|Perl_rsignal_save
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_RESTART
name|act
operator|.
name|sa_flags
operator||=
name|SA_RESTART
expr_stmt|;
comment|/* SVR4, 4.3+BSD */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_NOCLDWAIT
if|if
condition|(
name|signo
operator|==
name|SIGCHLD
operator|&&
name|handler
operator|==
operator|(
name|Sighandler_t
operator|)
name|SIG_IGN
condition|)
name|act
operator|.
name|sa_flags
operator||=
name|SA_NOCLDWAIT
expr_stmt|;
endif|#
directive|endif
return|return
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|save
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|Perl_rsignal_restore
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
return|return
name|sigaction
argument_list|(
name|signo
argument_list|,
name|save
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAS_SIGACTION */
end_comment

begin_function
name|Sighandler_t
name|Perl_rsignal
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|)
block|{
return|return
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|handler
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sig_trapped
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Signal_t
name|sig_trap
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|sig_trapped
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Sighandler_t
name|Perl_rsignal_state
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|)
block|{
name|Sighandler_t
name|oldsig
decl_stmt|;
name|sig_trapped
operator|=
literal|0
expr_stmt|;
name|oldsig
operator|=
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|sig_trap
argument_list|)
expr_stmt|;
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_trapped
condition|)
name|PerlProc_kill
argument_list|(
name|PerlProc_getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
name|oldsig
return|;
block|}
end_function

begin_function
name|int
name|Perl_rsignal_save
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
operator|*
name|save
operator|=
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|handler
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|save
operator|==
name|SIG_ERR
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|Perl_rsignal_restore
parameter_list|(
name|pTHX_
name|int
name|signo
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
return|return
operator|(
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
operator|*
name|save
argument_list|)
operator|==
name|SIG_ERR
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_SIGACTION */
end_comment

begin_comment
comment|/* VMS' my_pclose() is in VMS.c; same with OS/2 */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPEN_VM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
end_if

begin_function
name|I32
name|Perl_my_pclose
parameter_list|(
name|pTHX_
name|PerlIO
modifier|*
name|ptr
parameter_list|)
block|{
name|Sigsave_t
name|hstat
decl_stmt|,
name|istat
decl_stmt|,
name|qstat
decl_stmt|;
name|int
name|status
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|Pid_t
name|pid
decl_stmt|;
name|Pid_t
name|pid2
decl_stmt|;
name|bool
name|close_failed
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|saved_vaxc_errno
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
name|int
name|saved_win32_errno
decl_stmt|;
endif|#
directive|endif
name|LOCK_FDPID_MUTEX
expr_stmt|;
name|svp
operator|=
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|PerlIO_fileno
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|UNLOCK_FDPID_MUTEX
expr_stmt|;
name|pid
operator|=
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Opened by popen. */
return|return
name|my_syspclose
argument_list|(
name|ptr
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|close_failed
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|ptr
argument_list|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|saved_vaxc_errno
operator|=
name|vaxc$errno
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
name|saved_win32_errno
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|UTS
if|if
condition|(
name|PerlProc_kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|pid
operator|)
return|;
block|}
comment|/* HOM 12/23/91 */
endif|#
directive|endif
name|rsignal_save
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|istat
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|qstat
argument_list|)
expr_stmt|;
do|do
block|{
name|pid2
operator|=
name|wait4pid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid2
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
name|rsignal_restore
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
name|rsignal_restore
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|istat
argument_list|)
expr_stmt|;
name|rsignal_restore
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_failed
condition|)
block|{
name|SETERRNO
argument_list|(
name|saved_errno
argument_list|,
name|saved_vaxc_errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|pid2
operator|<
literal|0
condition|?
name|pid2
else|:
name|status
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|errno
operator|=
literal|0
operator|,
name|status
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
end_if

begin_function
name|I32
name|Perl_wait4pid
parameter_list|(
name|pTHX_
name|Pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|statusp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|char
name|spid
index|[
name|TYPE_CHARS
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_WAITPID_RUNTIME
argument_list|)
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|pid
argument_list|)
expr_stmt|;
name|svp
operator|=
name|hv_fetch
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
operator|*
name|statusp
operator|=
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
else|else
block|{
name|HE
modifier|*
name|entry
decl_stmt|;
name|hv_iterinit
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|hv_iternext
argument_list|(
name|PL_pidstatus
argument_list|)
operator|)
condition|)
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|hv_iterkey
argument_list|(
name|entry
argument_list|,
operator|(
name|I32
operator|*
operator|)
name|statusp
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
name|hv_iterval
argument_list|(
name|PL_pidstatus
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|statusp
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_WAITPID
ifdef|#
directive|ifdef
name|HAS_WAITPID_RUNTIME
if|if
condition|(
operator|!
name|HAS_WAITPID_RUNTIME
condition|)
goto|goto
name|hard_way
goto|;
endif|#
directive|endif
return|return
name|PerlProc_waitpid
argument_list|(
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
return|return
name|wait4
argument_list|(
operator|(
name|pid
operator|==
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|,
name|Null
argument_list|(
expr|struct
name|rusage
operator|*
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_WAITPID_RUNTIME
argument_list|)
name|hard_way
label|:
block|{
name|I32
name|result
decl_stmt|;
if|if
condition|(
name|flags
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't do waitpid with flags"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|result
operator|=
name|PerlProc_wait
argument_list|(
name|statusp
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|pid
operator|>
literal|0
operator|&&
name|result
operator|>=
literal|0
condition|)
name|pidgone
argument_list|(
name|result
argument_list|,
operator|*
name|statusp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
operator|*
name|statusp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH || OS2 || WIN32 */
end_comment

begin_function
name|void
comment|/*SUPPRESS 590*/
name|Perl_pidgone
parameter_list|(
name|pTHX_
name|Pid_t
name|pid
parameter_list|,
name|int
name|status
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
name|spid
index|[
name|TYPE_CHARS
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%"
name|IVdf
argument_list|,
operator|(
name|IV
operator|)
name|pid
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|*
name|hv_fetch
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|status
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
end_if

begin_function_decl
name|int
name|pclose
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_FORK
end_ifdef

begin_decl_stmt
name|int
comment|/* Cannot prototype with I32 					   in os2ish.h. */
name|my_syspclose
argument_list|(
name|PerlIO
operator|*
name|ptr
argument_list|)
else|#
directive|else
name|I32
name|Perl_my_pclose
argument_list|(
name|pTHX_
name|PerlIO
operator|*
name|ptr
argument_list|)
endif|#
directive|endif
block|{
comment|/* Needs work for PerlIO ! */
name|FILE
modifier|*
name|f
init|=
name|PerlIO_findFILE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|I32
name|result
init|=
name|pclose
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DJGPP
argument_list|)
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
expr_stmt|;
endif|#
directive|endif
name|PerlIO_releaseFILE
argument_list|(
name|ptr
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|Perl_repeatcpy
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|I32
name|len
parameter_list|,
specifier|register
name|I32
name|count
parameter_list|)
block|{
specifier|register
name|I32
name|todo
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|frombase
init|=
name|from
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
specifier|register
specifier|const
name|char
name|c
init|=
operator|*
name|from
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|todo
operator|=
name|len
init|;
name|todo
operator|>
literal|0
condition|;
name|todo
operator|--
control|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
name|from
operator|=
name|frombase
expr_stmt|;
block|}
block|}
end_function

begin_function
name|U32
name|Perl_cast_ulong
parameter_list|(
name|pTHX_
name|NV
name|f
parameter_list|)
block|{
name|long
name|along
decl_stmt|;
if|#
directive|if
name|CASTFLAGS
operator|&
literal|2
define|#
directive|define
name|BIGDOUBLE
value|2147483648.0
if|if
condition|(
name|f
operator|>=
name|BIGDOUBLE
condition|)
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
name|f
operator|-
call|(
name|long
call|)
argument_list|(
name|f
operator|/
name|BIGDOUBLE
argument_list|)
operator|*
name|BIGDOUBLE
argument_list|)
operator||
literal|0x80000000
return|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|>=
literal|0.0
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|f
return|;
name|along
operator|=
operator|(
name|long
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|along
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BIGDOUBLE
end_undef

begin_comment
comment|/* Unfortunately, on some systems the cast_uv() function doesn't    work with the system-supplied definition of ULONG_MAX.  The    comparison  (f>= ULONG_MAX) always comes out true.  It must be a    problem with the compiler constant folding.     In any case, this workaround should be fine on any two's complement    system.  If it's not, supply a '-DMY_ULONG_MAX=whatever' in your    ccflags. 	       --Andy Dougherty<doughera@lafcol.lafayette.edu> */
end_comment

begin_comment
comment|/* Code modified to prefer proper named type ranges, I32, IV, or UV, instead    of LONG_(MIN/MAX).                            -- Kenneth Albanowski<kjahds@kjahds.com> */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|MY_UV_MAX
value|((UV)IV_MAX * (UV)2 + (UV)1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|I32
name|Perl_cast_i32
parameter_list|(
name|pTHX_
name|NV
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|>=
name|I32_MAX
condition|)
return|return
operator|(
name|I32
operator|)
name|I32_MAX
return|;
if|if
condition|(
name|f
operator|<=
name|I32_MIN
condition|)
return|return
operator|(
name|I32
operator|)
name|I32_MIN
return|;
return|return
operator|(
name|I32
operator|)
name|f
return|;
block|}
end_function

begin_function
name|IV
name|Perl_cast_iv
parameter_list|(
name|pTHX_
name|NV
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|>=
name|IV_MAX
condition|)
block|{
name|UV
name|uv
decl_stmt|;
if|if
condition|(
name|f
operator|>=
operator|(
name|NV
operator|)
name|UV_MAX
condition|)
return|return
operator|(
name|IV
operator|)
name|UV_MAX
return|;
name|uv
operator|=
operator|(
name|UV
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|IV
operator|)
name|uv
return|;
block|}
if|if
condition|(
name|f
operator|<=
name|IV_MIN
condition|)
return|return
operator|(
name|IV
operator|)
name|IV_MIN
return|;
return|return
operator|(
name|IV
operator|)
name|f
return|;
block|}
end_function

begin_function
name|UV
name|Perl_cast_uv
parameter_list|(
name|pTHX_
name|NV
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|>=
name|MY_UV_MAX
condition|)
return|return
operator|(
name|UV
operator|)
name|MY_UV_MAX
return|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|IV
name|iv
decl_stmt|;
if|if
condition|(
name|f
operator|<
name|IV_MIN
condition|)
return|return
operator|(
name|UV
operator|)
name|IV_MIN
return|;
name|iv
operator|=
operator|(
name|IV
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|UV
operator|)
name|iv
return|;
block|}
return|return
operator|(
name|UV
operator|)
name|f
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_RENAME
end_ifndef

begin_function
name|I32
name|Perl_same_dirent
parameter_list|(
name|pTHX_
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|)
block|{
name|char
modifier|*
name|fa
init|=
name|strrchr
argument_list|(
name|a
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fb
init|=
name|strrchr
argument_list|(
name|b
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf1
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf2
decl_stmt|;
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|fa
condition|)
name|fa
operator|++
expr_stmt|;
else|else
name|fa
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|fb
condition|)
name|fb
operator|++
expr_stmt|;
else|else
name|fb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fa
operator|==
name|a
condition|)
name|sv_setpv
argument_list|(
name|tmpsv
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|tmpsv
argument_list|,
name|a
argument_list|,
name|fa
operator|-
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|tmpsv
argument_list|)
argument_list|,
operator|&
name|tmpstatbuf1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fb
operator|==
name|b
condition|)
name|sv_setpv
argument_list|(
name|tmpsv
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|tmpsv
argument_list|,
name|b
argument_list|,
name|fb
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|tmpsv
argument_list|)
argument_list|,
operator|&
name|tmpstatbuf2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|tmpstatbuf1
operator|.
name|st_dev
operator|==
name|tmpstatbuf2
operator|.
name|st_dev
operator|&&
name|tmpstatbuf1
operator|.
name|st_ino
operator|==
name|tmpstatbuf2
operator|.
name|st_ino
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_RENAME */
end_comment

begin_function
name|NV
name|Perl_scan_bin
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|NV
name|rnv
init|=
literal|0.0
decl_stmt|;
specifier|register
name|UV
name|ruv
init|=
literal|0
decl_stmt|;
specifier|register
name|bool
name|seenb
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|==
literal|'0'
operator|||
operator|*
name|s
operator|==
literal|'1'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
operator|&&
name|len
operator|&&
operator|*
name|retlen
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'0'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'1'
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seenb
operator|==
name|FALSE
operator|&&
operator|*
name|s
operator|==
literal|'b'
operator|&&
name|ruv
operator|==
literal|0
condition|)
block|{
comment|/* Disallow 0bbb0b0bbb... */
name|seenb
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DIGIT
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DIGIT
argument_list|,
literal|"Illegal binary digit '%c' ignored"
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
specifier|register
name|UV
name|xuv
init|=
name|ruv
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|xuv
operator|>>
literal|1
operator|)
operator|!=
name|ruv
condition|)
block|{
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_OVERFLOW
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_OVERFLOW
argument_list|,
literal|"Integer overflow in binary number"
argument_list|)
empty_stmt|;
block|}
else|else
name|ruv
operator|=
name|xuv
operator||
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overflowed
condition|)
block|{
name|rnv
operator|*=
literal|2
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent an UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply rnv by the 	     * right amount. */
name|rnv
operator|+=
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|rnv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|ruv
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PORTABLE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PORTABLE
argument_list|,
literal|"Binary number> 0b11111111111111111111111111111111 non-portable"
argument_list|)
empty_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|rnv
return|;
block|}
end_function

begin_function
name|NV
name|Perl_scan_oct
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|NV
name|rnv
init|=
literal|0.0
decl_stmt|;
specifier|register
name|UV
name|ruv
init|=
literal|0
decl_stmt|;
specifier|register
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
operator|&&
name|len
operator|&&
operator|*
name|retlen
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|<=
literal|'7'
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* Allow \octal to work the DWIM way (that is, stop scanning 		 * as soon as non-octal characters are seen, complain only iff 		 * someone seems to want to use the digits eight and nine). */
if|if
condition|(
operator|*
name|s
operator|==
literal|'8'
operator|||
operator|*
name|s
operator|==
literal|'9'
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DIGIT
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DIGIT
argument_list|,
literal|"Illegal octal digit '%c' ignored"
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
specifier|register
name|UV
name|xuv
init|=
name|ruv
operator|<<
literal|3
decl_stmt|;
if|if
condition|(
operator|(
name|xuv
operator|>>
literal|3
operator|)
operator|!=
name|ruv
condition|)
block|{
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_OVERFLOW
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_OVERFLOW
argument_list|,
literal|"Integer overflow in octal number"
argument_list|)
empty_stmt|;
block|}
else|else
name|ruv
operator|=
name|xuv
operator||
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overflowed
condition|)
block|{
name|rnv
operator|*=
literal|8.0
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent an UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply rnv by the 	     * right amount of 8-tuples. */
name|rnv
operator|+=
call|(
name|NV
call|)
argument_list|(
operator|*
name|s
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|rnv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|ruv
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PORTABLE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PORTABLE
argument_list|,
literal|"Octal number> 037777777777 non-portable"
argument_list|)
empty_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|rnv
return|;
block|}
end_function

begin_function
name|NV
name|Perl_scan_hex
parameter_list|(
name|pTHX_
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|NV
name|rnv
init|=
literal|0.0
decl_stmt|;
specifier|register
name|UV
name|ruv
init|=
literal|0
decl_stmt|;
specifier|register
name|bool
name|seenx
init|=
name|FALSE
decl_stmt|;
specifier|register
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|hexdigit
decl_stmt|;
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|hexdigit
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_hexdigit
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hexdigit
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
operator|&&
name|len
operator|&&
operator|*
name|retlen
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|hexdigit
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_hexdigit
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seenx
operator|==
name|FALSE
operator|&&
operator|*
name|s
operator|==
literal|'x'
operator|&&
name|ruv
operator|==
literal|0
condition|)
block|{
comment|/* Disallow 0xxx0x0xxx... */
name|seenx
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DIGIT
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DIGIT
argument_list|,
literal|"Illegal hexadecimal digit '%c' ignored"
argument_list|,
argument|*s
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
specifier|register
name|UV
name|xuv
init|=
name|ruv
operator|<<
literal|4
decl_stmt|;
if|if
condition|(
operator|(
name|xuv
operator|>>
literal|4
operator|)
operator|!=
name|ruv
condition|)
block|{
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_OVERFLOW
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_OVERFLOW
argument_list|,
literal|"Integer overflow in hexadecimal number"
argument_list|)
empty_stmt|;
block|}
else|else
name|ruv
operator|=
name|xuv
operator||
operator|(
operator|(
name|hexdigit
operator|-
name|PL_hexdigit
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overflowed
condition|)
block|{
name|rnv
operator|*=
literal|16.0
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent an UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply rnv by the 	     * right amount of 16-tuples. */
name|rnv
operator|+=
call|(
name|NV
call|)
argument_list|(
operator|(
name|hexdigit
operator|-
name|PL_hexdigit
operator|)
operator|&
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|overflowed
condition|)
name|rnv
operator|=
operator|(
name|NV
operator|)
name|ruv
expr_stmt|;
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|rnv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|ruv
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PORTABLE
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PORTABLE
argument_list|,
literal|"Hexadecimal number> 0xffffffff non-portable"
argument_list|)
empty_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|rnv
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Perl_find_script
parameter_list|(
name|pTHX_
name|char
modifier|*
name|scriptname
parameter_list|,
name|bool
name|dosearch
parameter_list|,
name|char
modifier|*
modifier|*
name|search_ext
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|xfound
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|xfailed
init|=
name|Nullch
decl_stmt|;
name|char
name|tmpbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|atarist
argument_list|)
define|#
directive|define
name|SEARCH_EXTS
value|".bat", ".cmd", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS2
define|#
directive|define
name|SEARCH_EXTS
value|".cmd", ".btm", ".bat", ".pl", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
define|#
directive|define
name|SEARCH_EXTS
value|".pl", ".com", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
comment|/* additional extensions to try in each dir if scriptname not found */
ifdef|#
directive|ifdef
name|SEARCH_EXTS
name|char
modifier|*
name|exts
index|[]
init|=
block|{
name|SEARCH_EXTS
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|ext
init|=
name|search_ext
condition|?
name|search_ext
else|:
name|exts
decl_stmt|;
name|int
name|extidx
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|curext
init|=
name|Nullch
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|MAX_EXT_LEN
value|0
endif|#
directive|endif
comment|/*      * If dosearch is true and if scriptname does not contain path      * delimiters, search the PATH for scriptname.      *      * If SEARCH_EXTS is also defined, will look for each      * scriptname{SEARCH_EXTS} whenever scriptname is not found      * while searching the PATH.      *      * Assuming SEARCH_EXTS is C<".foo",".bar",NULL>, PATH search      * proceeds as follows:      *   If DOSISH or VMSISH:      *     + look for ./scriptname{,.foo,.bar}      *     + search the PATH for scriptname{,.foo,.bar}      *      *   If !DOSISH:      *     + look *only* in the PATH for scriptname{,.foo,.bar} (note      *       this will not look in '.' if it's not in the PATH)      */
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
ifdef|#
directive|ifdef
name|ALWAYS_DEFTYPES
name|len
operator|=
name|strlen
argument_list|(
name|scriptname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|==
literal|1
operator|&&
operator|*
name|scriptname
operator|==
literal|'-'
operator|)
operator|&&
name|scriptname
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|int
name|hasdir
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|deftypes
init|=
literal|1
decl_stmt|;
name|bool
name|seen_dot
init|=
literal|1
decl_stmt|;
name|hasdir
operator|=
operator|!
name|dosearch
operator|||
operator|(
name|strpbrk
argument_list|(
name|scriptname
argument_list|,
literal|":[</"
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dosearch
condition|)
block|{
name|int
name|hasdir
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|deftypes
init|=
literal|1
decl_stmt|;
name|bool
name|seen_dot
init|=
literal|1
decl_stmt|;
name|hasdir
operator|=
operator|(
name|strpbrk
argument_list|(
name|scriptname
argument_list|,
literal|":[</"
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The first time through, just add SEARCH_EXTS to whatever we 	 * already have, so we can check for default file types. */
while|while
condition|(
name|deftypes
operator|||
operator|(
operator|!
name|hasdir
operator|&&
name|my_trnlnm
argument_list|(
literal|"DCL$PATH"
argument_list|,
name|tmpbuf
argument_list|,
name|idx
operator|++
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|deftypes
condition|)
block|{
name|deftypes
operator|=
literal|0
expr_stmt|;
operator|*
name|tmpbuf
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|scriptname
argument_list|)
operator|+
name|MAX_EXT_LEN
operator|)
operator|>=
sizeof|sizeof
name|tmpbuf
condition|)
continue|continue;
comment|/* don't search dir with too-long name */
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !VMS */
ifdef|#
directive|ifdef
name|DOSISH
if|if
condition|(
name|strEQ
argument_list|(
name|scriptname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|dosearch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dosearch
condition|)
block|{
comment|/* Look in '.' first. */
name|char
modifier|*
name|cur
init|=
name|scriptname
decl_stmt|;
ifdef|#
directive|ifdef
name|SEARCH_EXTS
if|if
condition|(
operator|(
name|curext
operator|=
name|strrchr
argument_list|(
name|scriptname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
comment|/* possible current ext */
while|while
condition|(
name|ext
index|[
name|i
index|]
condition|)
if|if
condition|(
name|strEQ
argument_list|(
name|ext
index|[
name|i
operator|++
index|]
argument_list|,
name|curext
argument_list|)
condition|)
block|{
name|extidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* already has an ext */
break|break;
block|}
do|do
block|{
endif|#
directive|endif
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Looking for %s\n"
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|cur
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|dosearch
operator|=
literal|0
expr_stmt|;
name|scriptname
operator|=
name|cur
expr_stmt|;
ifdef|#
directive|ifdef
name|SEARCH_EXTS
break|break;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SEARCH_EXTS
if|if
condition|(
name|cur
operator|==
name|scriptname
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|scriptname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|MAX_EXT_LEN
operator|+
literal|1
operator|>=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
condition|)
break|break;
name|cur
operator|=
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|extidx
operator|>=
literal|0
operator|&&
name|ext
index|[
name|extidx
index|]
comment|/* try an extension? */
operator|&&
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|ext
index|[
name|extidx
operator|++
index|]
argument_list|)
condition|)
do|;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
if|if
condition|(
name|dosearch
operator|&&
operator|!
name|strchr
argument_list|(
name|scriptname
argument_list|,
literal|':'
argument_list|)
operator|&&
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"Commands"
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|dosearch
operator|&&
operator|!
name|strchr
argument_list|(
name|scriptname
argument_list|,
literal|'/'
argument_list|)
ifdef|#
directive|ifdef
name|DOSISH
operator|&&
operator|!
name|strchr
argument_list|(
name|scriptname
argument_list|,
literal|'\\'
argument_list|)
endif|#
directive|endif
operator|&&
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|bool
name|seen_dot
init|=
literal|0
decl_stmt|;
name|PL_bufend
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|s
operator|=
name|delimcpy
argument_list|(
name|tmpbuf
argument_list|,
name|tmpbuf
operator|+
sizeof|sizeof
name|tmpbuf
argument_list|,
name|s
argument_list|,
name|PL_bufend
argument_list|,
literal|','
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|DOSISH
argument_list|)
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|*
name|s
ifdef|#
directive|ifdef
name|atarist
operator|&&
operator|*
name|s
operator|!=
literal|','
endif|#
directive|endif
operator|&&
operator|*
name|s
operator|!=
literal|';'
condition|;
name|len
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|tmpbuf
condition|)
name|tmpbuf
index|[
name|len
index|]
operator|=
operator|*
name|s
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|tmpbuf
condition|)
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
comment|/* ! (atarist || DOSISH) */
name|s
operator|=
name|delimcpy
argument_list|(
name|tmpbuf
argument_list|,
name|tmpbuf
operator|+
sizeof|sizeof
name|tmpbuf
argument_list|,
name|s
argument_list|,
name|PL_bufend
argument_list|,
literal|':'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! (atarist || DOSISH) */
endif|#
directive|endif
comment|/* MACOS_TRADITIONAL */
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|scriptname
argument_list|)
operator|+
name|MAX_EXT_LEN
operator|>=
sizeof|sizeof
name|tmpbuf
condition|)
continue|continue;
comment|/* don't search dir with too-long name */
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
if|if
condition|(
name|len
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|len
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINT__
argument_list|)
operator|||
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\\'
endif|#
directive|endif
condition|)
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|tmpbuf
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|seen_dot
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !VMS */
ifdef|#
directive|ifdef
name|SEARCH_EXTS
name|len
operator|=
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|extidx
operator|>
literal|0
condition|)
comment|/* reset after previous loop */
name|extidx
operator|=
literal|0
expr_stmt|;
do|do
block|{
endif|#
directive|endif
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Looking for %s\n"
argument_list|,
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PerlLIO_stat
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SEARCH_EXTS
block|}
do|while
condition|(
name|retval
operator|<
literal|0
comment|/* not there */
operator|&&
name|extidx
operator|>=
literal|0
operator|&&
name|ext
index|[
name|extidx
index|]
comment|/* try an extension? */
operator|&&
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|ext
index|[
name|extidx
operator|++
index|]
argument_list|)
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|S_ISREG
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|cando
argument_list|(
name|S_IRUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
operator|&&
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|xfound
operator|=
name|tmpbuf
expr_stmt|;
comment|/* bingo! */
break|break;
block|}
if|if
condition|(
operator|!
name|xfailed
condition|)
name|xfailed
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DOSISH
if|if
condition|(
operator|!
name|xfound
operator|&&
operator|!
name|seen_dot
operator|&&
operator|!
name|xfailed
operator|&&
operator|(
name|PerlLIO_stat
argument_list|(
name|scriptname
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
endif|#
directive|endif
name|seen_dot
operator|=
literal|1
expr_stmt|;
comment|/* Disable message. */
if|if
condition|(
operator|!
name|xfound
condition|)
block|{
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* do or die? */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't %s %s%s%s"
argument_list|,
operator|(
name|xfailed
condition|?
literal|"execute"
else|:
literal|"find"
operator|)
argument_list|,
operator|(
name|xfailed
condition|?
name|xfailed
else|:
name|scriptname
operator|)
argument_list|,
operator|(
name|xfailed
condition|?
literal|""
else|:
literal|" on PATH"
operator|)
argument_list|,
operator|(
name|xfailed
operator|||
name|seen_dot
operator|)
condition|?
literal|""
else|:
literal|", '.' not in PATH"
argument_list|)
expr_stmt|;
block|}
name|scriptname
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|xfailed
condition|)
name|Safefree
argument_list|(
name|xfailed
argument_list|)
expr_stmt|;
name|scriptname
operator|=
name|xfound
expr_stmt|;
block|}
return|return
operator|(
name|scriptname
condition|?
name|savepv
argument_list|(
name|scriptname
argument_list|)
else|:
name|Nullch
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|PERL_GET_CONTEXT_DEFINED
name|void
modifier|*
name|Perl_get_context
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
ifdef|#
directive|ifdef
name|OLD_PTHREADS_API
name|pthread_addr_t
name|t
decl_stmt|;
if|if
condition|(
name|pthread_getspecific
argument_list|(
name|PL_thr_key
argument_list|,
operator|&
name|t
argument_list|)
condition|)
name|Perl_croak_nocontext
argument_list|(
literal|"panic: pthread_getspecific"
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|t
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|I_MACH_CTHREADS
return|return
operator|(
name|void
operator|*
operator|)
name|cthread_data
argument_list|(
name|cthread_self
argument_list|()
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|void
operator|*
operator|)
name|pthread_getspecific
argument_list|(
name|PL_thr_key
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
return|return
operator|(
name|void
operator|*
operator|)
name|NULL
return|;
endif|#
directive|endif
block|}
name|void
name|Perl_set_context
parameter_list|(
name|void
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
ifdef|#
directive|ifdef
name|I_MACH_CTHREADS
name|cthread_set_data
argument_list|(
name|cthread_self
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pthread_setspecific
argument_list|(
name|PL_thr_key
argument_list|,
name|t
argument_list|)
condition|)
name|Perl_croak_nocontext
argument_list|(
literal|"panic: pthread_setspecific"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* !PERL_GET_CONTEXT_DEFINED */
ifdef|#
directive|ifdef
name|USE_THREADS
ifdef|#
directive|ifdef
name|FAKE_THREADS
comment|/* Very simplistic scheduler for now */
name|void
name|schedule
parameter_list|(
name|void
parameter_list|)
block|{
name|thr
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
block|}
name|void
name|Perl_cond_init
parameter_list|(
name|pTHX_
name|perl_cond
modifier|*
name|cp
parameter_list|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|Perl_cond_signal
parameter_list|(
name|pTHX_
name|perl_cond
modifier|*
name|cp
parameter_list|)
block|{
name|perl_os_thread
name|t
decl_stmt|;
name|perl_cond
name|cond
init|=
operator|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return;
name|t
operator|=
name|cond
operator|->
name|thread
expr_stmt|;
comment|/* Insert t in the runnable queue just ahead of us */
name|t
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|=
name|t
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
literal|0
expr_stmt|;
comment|/* Remove from the wait queue */
operator|*
name|cp
operator|=
name|cond
operator|->
name|next
expr_stmt|;
name|Safefree
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
name|void
name|Perl_cond_broadcast
parameter_list|(
name|pTHX_
name|perl_cond
modifier|*
name|cp
parameter_list|)
block|{
name|perl_os_thread
name|t
decl_stmt|;
name|perl_cond
name|cond
decl_stmt|,
name|cond_next
decl_stmt|;
for|for
control|(
name|cond
operator|=
operator|*
name|cp
init|;
name|cond
condition|;
name|cond
operator|=
name|cond_next
control|)
block|{
name|t
operator|=
name|cond
operator|->
name|thread
expr_stmt|;
comment|/* Insert t in the runnable queue just ahead of us */
name|t
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|=
name|t
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
literal|0
expr_stmt|;
comment|/* Remove from the wait queue */
name|cond_next
operator|=
name|cond
operator|->
name|next
expr_stmt|;
name|Safefree
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|Perl_cond_wait
parameter_list|(
name|pTHX_
name|perl_cond
modifier|*
name|cp
parameter_list|)
block|{
name|perl_cond
name|cond
decl_stmt|;
if|if
condition|(
name|thr
operator|->
name|i
operator|.
name|next_run
operator|==
name|thr
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: perl_cond_wait called by last runnable thread"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|cond
argument_list|,
literal|1
argument_list|,
expr|struct
name|perl_wait_queue
argument_list|)
expr_stmt|;
name|cond
operator|->
name|thread
operator|=
name|thr
expr_stmt|;
name|cond
operator|->
name|next
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
name|cond
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
name|cond
expr_stmt|;
comment|/* Remove ourselves from runnable queue */
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
operator|->
name|i
operator|.
name|prev_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|prev_run
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FAKE_THREADS */
name|MAGIC
modifier|*
name|Perl_condpair_magic
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|condpair_t
modifier|*
name|cp
decl_stmt|;
name|New
argument_list|(
literal|53
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|,
name|condpair_t
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|cp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|cp
operator|->
name|owner_cond
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cond
argument_list|)
expr_stmt|;
name|cp
operator|->
name|owner
operator|=
literal|0
expr_stmt|;
name|LOCK_CRED_MUTEX
expr_stmt|;
comment|/* XXX need separate mutex? */
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
condition|)
block|{
comment|/* someone else beat us to initialising it */
name|UNLOCK_CRED_MUTEX
expr_stmt|;
comment|/* XXX need separate mutex? */
name|MUTEX_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|owner_cond
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|cond
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'m'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
sizeof|sizeof
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|UNLOCK_CRED_MUTEX
expr_stmt|;
comment|/* XXX need separate mutex? */
name|DEBUG_S
argument_list|(
argument|WITH_THR(PerlIO_printf(Perl_debug_log,
literal|"%p: condpair_magic %p\n"
argument|, thr, sv));
argument_list|)
block|}
block|}
return|return
name|mg
return|;
block|}
name|SV
modifier|*
name|Perl_sv_lock
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|osv
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|osv
decl_stmt|;
name|LOCK_SV_LOCK_MUTEX
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|mg
operator|=
name|condpair_magic
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|==
name|thr
condition|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|MgOWNER
argument_list|(
name|mg
argument_list|)
condition|)
name|COND_WAIT
argument_list|(
name|MgOWNERCONDP
argument_list|(
name|mg
argument_list|)
argument_list|,
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|MgOWNER
argument_list|(
name|mg
argument_list|)
operator|=
name|thr
expr_stmt|;
name|DEBUG_S
argument_list|(
argument|PerlIO_printf(Perl_debug_log,
literal|"0x%"
argument|UVxf
literal|": Perl_lock lock 0x%"
argument|UVxf
literal|"\n"
argument|, 			      PTR2UV(thr), PTR2UV(sv));
argument_list|)
name|MUTEX_UNLOCK
argument_list|(
name|MgMUTEXP
argument_list|(
name|mg
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEDESTRUCTOR_X
argument_list|(
name|Perl_unlock_condpair
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_SV_LOCK_MUTEX
expr_stmt|;
return|return
name|sv
return|;
block|}
comment|/*  * Make a new perl thread structure using t as a prototype. Some of the  * fields for the new thread are copied from the prototype thread, t,  * so t should not be running in perl at the time this function is  * called. The use by ext/Thread/Thread.xs in core perl (where t is the  * thread calling new_struct_thread) clearly satisfies this constraint.  */
name|struct
name|perl_thread
modifier|*
name|Perl_new_struct_thread
parameter_list|(
name|pTHX_
name|struct
name|perl_thread
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
name|struct
name|perl_thread
modifier|*
name|thr
decl_stmt|;
endif|#
directive|endif
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|sv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
argument_list|)
expr_stmt|;
name|thr
operator|=
operator|(
name|Thread
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|memset
argument_list|(
name|thr
argument_list|,
literal|0xab
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
argument_list|)
expr_stmt|;
name|PL_markstack
operator|=
literal|0
expr_stmt|;
name|PL_scopestack
operator|=
literal|0
expr_stmt|;
name|PL_savestack
operator|=
literal|0
expr_stmt|;
name|PL_retstack
operator|=
literal|0
expr_stmt|;
name|PL_dirty
operator|=
literal|0
expr_stmt|;
name|PL_localizing
operator|=
literal|0
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|,
literal|1
argument_list|,
name|HE
argument_list|)
expr_stmt|;
name|PL_efloatbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|PL_efloatsize
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|Zero
argument_list|(
name|thr
argument_list|,
literal|1
argument_list|,
expr|struct
name|perl_thread
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|thr
operator|->
name|oursv
operator|=
name|sv
expr_stmt|;
name|init_stacks
argument_list|()
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|thr
operator|->
name|interp
operator|=
name|t
operator|->
name|interp
expr_stmt|;
name|thr
operator|->
name|cvcache
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|threadsv
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|specific
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|errsv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thr
operator|->
name|flags
operator|=
name|THRf_R_JOINABLE
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|JMPENV_BOOTSTRAP
expr_stmt|;
name|PL_in_eval
operator|=
name|EVAL_NULL
expr_stmt|;
comment|/* ~(EVAL_INEVAL|EVAL_WARNONLY|EVAL_KEEPERR|EVAL_INREQUIRE) */
name|PL_restartop
operator|=
literal|0
expr_stmt|;
name|PL_statname
operator|=
name|NEWSV
argument_list|(
literal|66
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_errors
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_maxscream
operator|=
operator|-
literal|1
expr_stmt|;
name|PL_regcompp
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_pregcomp
argument_list|)
expr_stmt|;
name|PL_regexecp
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_regexec_flags
argument_list|)
expr_stmt|;
name|PL_regint_start
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_re_intuit_start
argument_list|)
expr_stmt|;
name|PL_regint_string
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_re_intuit_string
argument_list|)
expr_stmt|;
name|PL_regfree
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_pregfree
argument_list|)
expr_stmt|;
name|PL_regindent
operator|=
literal|0
expr_stmt|;
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
name|PL_lastscream
operator|=
name|Nullsv
expr_stmt|;
name|PL_screamfirst
operator|=
literal|0
expr_stmt|;
name|PL_screamnext
operator|=
literal|0
expr_stmt|;
name|PL_reg_start_tmp
operator|=
literal|0
expr_stmt|;
name|PL_reg_start_tmpl
operator|=
literal|0
expr_stmt|;
name|PL_reg_poscache
operator|=
name|Nullch
expr_stmt|;
comment|/* parent thread's data needs to be locked while we make copy */
name|MUTEX_LOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|PL_protect
operator|=
name|t
operator|->
name|Tprotect
expr_stmt|;
endif|#
directive|endif
name|PL_curcop
operator|=
name|t
operator|->
name|Tcurcop
expr_stmt|;
comment|/* XXX As good a guess as any? */
name|PL_defstash
operator|=
name|t
operator|->
name|Tdefstash
expr_stmt|;
comment|/* XXX maybe these should */
name|PL_curstash
operator|=
name|t
operator|->
name|Tcurstash
expr_stmt|;
comment|/* always be set to main? */
name|PL_tainted
operator|=
name|t
operator|->
name|Ttainted
expr_stmt|;
name|PL_curpm
operator|=
name|t
operator|->
name|Tcurpm
expr_stmt|;
comment|/* XXX No PMOP ref count */
name|PL_nrs
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Tnrs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|t
operator|->
name|Tnrs
condition|?
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
else|:
name|Nullsv
expr_stmt|;
name|PL_last_in_gv
operator|=
name|Nullgv
expr_stmt|;
name|PL_ofslen
operator|=
name|t
operator|->
name|Tofslen
expr_stmt|;
name|PL_ofs
operator|=
name|savepvn
argument_list|(
name|t
operator|->
name|Tofs
argument_list|,
name|PL_ofslen
argument_list|)
expr_stmt|;
name|PL_defoutgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|t
operator|->
name|Tdefoutgv
argument_list|)
expr_stmt|;
name|PL_chopset
operator|=
name|t
operator|->
name|Tchopset
expr_stmt|;
name|PL_bodytarget
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Tbodytarget
argument_list|)
expr_stmt|;
name|PL_toptarget
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Ttoptarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tformtarget
operator|==
name|t
operator|->
name|Ttoptarget
condition|)
name|PL_formtarget
operator|=
name|PL_toptarget
expr_stmt|;
else|else
name|PL_formtarget
operator|=
name|PL_bodytarget
expr_stmt|;
comment|/* Initialise all per-thread SVs that the template thread used */
name|svp
operator|=
name|AvARRAY
argument_list|(
name|t
operator|->
name|threadsv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILLp
argument_list|(
name|t
operator|->
name|threadsv
argument_list|)
condition|;
name|i
operator|++
operator|,
name|svp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVsv
argument_list|(
operator|*
name|svp
argument_list|)
decl_stmt|;
name|av_store
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|i
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_threadsv_names
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"new_struct_thread: copied threadsv %"
name|IVdf
literal|" %p->%p\n"
argument_list|,
operator|(
name|IV
operator|)
name|i
argument_list|,
name|t
argument_list|,
name|thr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|thr
operator|->
name|threadsvp
operator|=
name|AvARRAY
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|PL_nthreads
operator|++
expr_stmt|;
name|thr
operator|->
name|tid
operator|=
operator|++
name|PL_threadnum
expr_stmt|;
name|thr
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|thr
operator|->
name|prev
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|next
operator|->
name|prev
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
comment|/* done copying parent's state */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_THREAD_INTERN
name|Perl_init_thread_intern
argument_list|(
name|thr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_THREAD_INTERN */
return|return
name|thr
return|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|#
directive|if
name|defined
argument_list|(
name|HUGE_VAL
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HUGE_VALL
argument_list|)
operator|)
comment|/*  * This hack is to force load of "huge" support from libm.a  * So it is in perl for (say) POSIX to use.   * Needed for SunOS with Sun's 'acc' for example.  */
name|NV
name|Perl_huge
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HUGE_VALL
argument_list|)
return|return
name|HUGE_VALL
return|;
endif|#
directive|endif
return|return
name|HUGE_VAL
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_GLOBAL_STRUCT
name|struct
name|perl_vars
modifier|*
name|Perl_GetVars
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
operator|&
name|PL_Vars
return|;
block|}
endif|#
directive|endif
name|char
modifier|*
modifier|*
name|Perl_get_op_names
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
name|PL_op_name
return|;
block|}
name|char
modifier|*
modifier|*
name|Perl_get_op_descs
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
name|PL_op_desc
return|;
block|}
name|char
modifier|*
name|Perl_get_no_modify
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|PL_no_modify
return|;
block|}
name|U32
modifier|*
name|Perl_get_opargs
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
name|PL_opargs
return|;
block|}
name|PPADDR_t
modifier|*
name|Perl_get_ppaddr
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
operator|&
name|PL_ppaddr
return|;
block|}
ifndef|#
directive|ifndef
name|HAS_GETENV_LEN
name|char
modifier|*
name|Perl_getenv_len
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|env_elem
parameter_list|,
name|unsigned
name|long
modifier|*
name|len
parameter_list|)
block|{
name|char
modifier|*
name|env_trans
init|=
name|PerlEnv_getenv
argument_list|(
name|env_elem
argument_list|)
decl_stmt|;
if|if
condition|(
name|env_trans
condition|)
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|env_trans
argument_list|)
expr_stmt|;
return|return
name|env_trans
return|;
block|}
endif|#
directive|endif
name|MGVTBL
modifier|*
name|Perl_get_vtbl
parameter_list|(
name|pTHX_
name|int
name|vtbl_id
parameter_list|)
block|{
name|MGVTBL
modifier|*
name|result
init|=
name|Null
argument_list|(
name|MGVTBL
operator|*
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|vtbl_id
condition|)
block|{
case|case
name|want_vtbl_sv
case|:
name|result
operator|=
operator|&
name|PL_vtbl_sv
expr_stmt|;
break|break;
case|case
name|want_vtbl_env
case|:
name|result
operator|=
operator|&
name|PL_vtbl_env
expr_stmt|;
break|break;
case|case
name|want_vtbl_envelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_envelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_sig
case|:
name|result
operator|=
operator|&
name|PL_vtbl_sig
expr_stmt|;
break|break;
case|case
name|want_vtbl_sigelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_sigelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_pack
case|:
name|result
operator|=
operator|&
name|PL_vtbl_pack
expr_stmt|;
break|break;
case|case
name|want_vtbl_packelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_packelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_dbline
case|:
name|result
operator|=
operator|&
name|PL_vtbl_dbline
expr_stmt|;
break|break;
case|case
name|want_vtbl_isa
case|:
name|result
operator|=
operator|&
name|PL_vtbl_isa
expr_stmt|;
break|break;
case|case
name|want_vtbl_isaelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_isaelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_arylen
case|:
name|result
operator|=
operator|&
name|PL_vtbl_arylen
expr_stmt|;
break|break;
case|case
name|want_vtbl_glob
case|:
name|result
operator|=
operator|&
name|PL_vtbl_glob
expr_stmt|;
break|break;
case|case
name|want_vtbl_mglob
case|:
name|result
operator|=
operator|&
name|PL_vtbl_mglob
expr_stmt|;
break|break;
case|case
name|want_vtbl_nkeys
case|:
name|result
operator|=
operator|&
name|PL_vtbl_nkeys
expr_stmt|;
break|break;
case|case
name|want_vtbl_taint
case|:
name|result
operator|=
operator|&
name|PL_vtbl_taint
expr_stmt|;
break|break;
case|case
name|want_vtbl_substr
case|:
name|result
operator|=
operator|&
name|PL_vtbl_substr
expr_stmt|;
break|break;
case|case
name|want_vtbl_vec
case|:
name|result
operator|=
operator|&
name|PL_vtbl_vec
expr_stmt|;
break|break;
case|case
name|want_vtbl_pos
case|:
name|result
operator|=
operator|&
name|PL_vtbl_pos
expr_stmt|;
break|break;
case|case
name|want_vtbl_bm
case|:
name|result
operator|=
operator|&
name|PL_vtbl_bm
expr_stmt|;
break|break;
case|case
name|want_vtbl_fm
case|:
name|result
operator|=
operator|&
name|PL_vtbl_fm
expr_stmt|;
break|break;
case|case
name|want_vtbl_uvar
case|:
name|result
operator|=
operator|&
name|PL_vtbl_uvar
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|want_vtbl_mutex
case|:
name|result
operator|=
operator|&
name|PL_vtbl_mutex
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|want_vtbl_defelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_defelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_regexp
case|:
name|result
operator|=
operator|&
name|PL_vtbl_regexp
expr_stmt|;
break|break;
case|case
name|want_vtbl_regdata
case|:
name|result
operator|=
operator|&
name|PL_vtbl_regdata
expr_stmt|;
break|break;
case|case
name|want_vtbl_regdatum
case|:
name|result
operator|=
operator|&
name|PL_vtbl_regdatum
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
case|case
name|want_vtbl_collxfrm
case|:
name|result
operator|=
operator|&
name|PL_vtbl_collxfrm
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|want_vtbl_amagic
case|:
name|result
operator|=
operator|&
name|PL_vtbl_amagic
expr_stmt|;
break|break;
case|case
name|want_vtbl_amagicelem
case|:
name|result
operator|=
operator|&
name|PL_vtbl_amagicelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_backref
case|:
name|result
operator|=
operator|&
name|PL_vtbl_backref
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FFLUSH_NULL
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS__FWALK
argument_list|)
specifier|static
name|int
name|S_fflush
argument_list|(
name|FILE
operator|*
name|fp
argument_list|)
decl_stmt|;
specifier|static
name|int
name|S_fflush
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
return|return
name|fflush
argument_list|(
name|fp
argument_list|)
return|;
block|}
endif|#
directive|endif
name|I32
name|Perl_my_fflush_all
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|FFLUSH_NULL
argument_list|)
return|return
name|PerlIO_flush
argument_list|(
name|NULL
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS__FWALK
argument_list|)
comment|/* undocumented, unprototyped, but very useful BSDism */
specifier|extern
name|void
name|_fwalk
argument_list|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|_fwalk
argument_list|(
operator|&
name|S_fflush
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
name|long
name|open_max
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FFLUSH_ALL
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_STDIO_STREAM_ARRAY
argument_list|)
ifdef|#
directive|ifdef
name|PERL_FFLUSH_ALL_FOPEN_MAX
name|open_max
operator|=
name|PERL_FFLUSH_ALL_FOPEN_MAX
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS_SYSCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
name|open_max
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|FOPEN_MAX
name|open_max
operator|=
name|FOPEN_MAX
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OPEN_MAX
name|open_max
operator|=
name|OPEN_MAX
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_NFILE
name|open_max
operator|=
name|_NFILE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|open_max
operator|>
literal|0
condition|)
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|open_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STDIO_STREAM_ARRAY
index|[
name|i
index|]
operator|.
name|_file
operator|>=
literal|0
operator|&&
name|STDIO_STREAM_ARRAY
index|[
name|i
index|]
operator|.
name|_file
operator|<
name|open_max
operator|&&
name|STDIO_STREAM_ARRAY
index|[
name|i
index|]
operator|.
name|_flag
condition|)
name|PerlIO_flush
argument_list|(
operator|&
name|STDIO_STREAM_ARRAY
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|SETERRNO
argument_list|(
name|EBADF
argument_list|,
name|RMS$_IFI
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|NV
name|Perl_my_atof
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|NV
name|x
init|=
literal|0.0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_LOCALE
operator|)
operator|&&
name|PL_numeric_local
condition|)
block|{
name|NV
name|y
decl_stmt|;
name|Perl_atof2
argument_list|(
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|Perl_atof2
argument_list|(
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|SET_NUMERIC_LOCAL
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|<
literal|0.0
operator|&&
name|y
operator|<
name|x
operator|)
operator|||
operator|(
name|y
operator|>
literal|0.0
operator|&&
name|y
operator|>
name|x
operator|)
condition|)
return|return
name|y
return|;
block|}
else|else
name|Perl_atof2
argument_list|(
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|Perl_atof2
argument_list|(
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|x
return|;
block|}
name|void
name|Perl_report_evil_fh
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|,
name|IO
modifier|*
name|io
parameter_list|,
name|I32
name|op
parameter_list|)
block|{
name|char
modifier|*
name|vile
decl_stmt|;
name|I32
name|warn_type
decl_stmt|;
name|char
modifier|*
name|func
init|=
name|op
operator|==
name|OP_READLINE
condition|?
literal|"readline"
else|:
comment|/* "<HANDLE>" not nice */
name|op
operator|==
name|OP_LEAVEWRITE
condition|?
literal|"write"
else|:
comment|/* "write exit" not nice */
name|PL_op_desc
index|[
name|op
index|]
decl_stmt|;
name|char
modifier|*
name|pars
init|=
name|OP_IS_FILETEST
argument_list|(
name|op
argument_list|)
condition|?
literal|""
else|:
literal|"()"
decl_stmt|;
name|char
modifier|*
name|type
init|=
name|OP_IS_SOCKET
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|io
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_SOCKET
operator|)
condition|?
literal|"socket"
else|:
literal|"filehandle"
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|io
operator|&&
name|IoTYPE
argument_list|(
name|io
argument_list|)
operator|==
name|IoTYPE_CLOSED
condition|)
block|{
name|vile
operator|=
literal|"closed"
expr_stmt|;
name|warn_type
operator|=
name|WARN_CLOSED
expr_stmt|;
block|}
else|else
block|{
name|vile
operator|=
literal|"unopened"
expr_stmt|;
name|warn_type
operator|=
name|WARN_UNOPENED
expr_stmt|;
block|}
if|if
condition|(
name|gv
operator|&&
name|isGV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname4
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ warn_type
argument_list|,
literal|"%s%s on %s %s %s"
argument_list|,
argument|func
argument_list|,
argument|pars
argument_list|,
argument|vile
argument_list|,
argument|type
argument_list|,
argument|name
argument_list|)
empty_stmt|;
if|if
condition|(
name|io
operator|&&
name|IoDIRP
argument_list|(
name|io
argument_list|)
operator|&&
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_FAKE_DIRP
operator|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ warn_type
argument_list|,
literal|"\t(Are you trying to call %s%s on dirhandle %s?)\n"
argument_list|,
argument|func
argument_list|,
argument|pars
argument_list|,
argument|name
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ warn_type
argument_list|,
literal|"%s%s on %s %s"
argument_list|,
argument|func
argument_list|,
argument|pars
argument_list|,
argument|vile
argument_list|,
argument|type
argument_list|)
empty_stmt|;
if|if
condition|(
name|io
operator|&&
name|IoDIRP
argument_list|(
name|io
argument_list|)
operator|&&
operator|!
operator|(
name|IoFLAGS
argument_list|(
name|io
argument_list|)
operator|&
name|IOf_FAKE_DIRP
operator|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ warn_type
argument_list|,
literal|"\t(Are you trying to call %s%s on dirhandle?)\n"
argument_list|,
argument|func
argument_list|,
argument|pars
argument_list|)
empty_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|EBCDIC
comment|/* in ASCII order, not that it matters */
specifier|static
specifier|const
name|char
name|controllablechars
index|[]
init|=
literal|"?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
decl_stmt|;
name|int
name|Perl_ebcdic_control
parameter_list|(
name|pTHX_
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>
literal|'a'
condition|)
block|{
name|char
modifier|*
name|ctlp
decl_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|toupper
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctlp
operator|=
name|strchr
argument_list|(
name|controllablechars
argument_list|,
name|ch
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Perl_die
argument_list|(
name|aTHX_
literal|"unrecognised control character '%c'\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|==
name|controllablechars
condition|)
return|return
operator|(
literal|'\177'
operator|)
return|;
comment|/* DEL */
else|else
return|return
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|ctlp
operator|-
name|controllablechars
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Want uncontrol */
if|if
condition|(
name|ch
operator|==
literal|'\177'
operator|||
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|'?'
operator|)
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\157'
condition|)
return|return
operator|(
literal|'\177'
operator|)
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\174'
condition|)
return|return
operator|(
literal|'\000'
operator|)
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'^'
condition|)
comment|/* '\137' in 1047, '\260' in 819 */
return|return
operator|(
literal|'\036'
operator|)
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\155'
condition|)
return|return
operator|(
literal|'\037'
operator|)
return|;
elseif|else
if|if
condition|(
literal|0
operator|<
name|ch
operator|&&
name|ch
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|controllablechars
argument_list|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|controllablechars
index|[
name|ch
operator|+
literal|1
index|]
operator|)
return|;
else|else
name|Perl_die
argument_list|(
name|aTHX_
literal|"invalid control request: '\\%03o'\n"
argument_list|,
name|ch
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

