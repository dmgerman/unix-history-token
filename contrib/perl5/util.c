begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    util.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "Very useful, no doubt, that was to Saruman; yet it seems that he was  * not content."  --Gandalf  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_ERR
end_ifndef

begin_define
define|#
directive|define
name|SIG_ERR
value|((Sighandler_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_VFORK
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put this after #includes because fork and vfork prototypes may    conflict. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VFORK
end_ifndef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_WAIT
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FLUSH
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|xstat
name|_
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|xcount
index|[
name|MAXXCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastxcount
index|[
name|MAXXCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|xycount
index|[
name|MAXXCOUNT
index|]
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastxycount
index|[
name|MAXXCOUNT
index|]
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MYMALLOC
end_ifndef

begin_comment
comment|/* paranoid version of malloc */
end_comment

begin_comment
comment|/* NOTE:  Do not call the next three routines directly.  Use the macros  * in handy.h, so that we can easily redefine everything to do tracking of  * allocated hunks back to the original New to track down any memory leaks.  * XXX This advice seems to be widely ignored :-(   --AD  August 1996.  */
end_comment

begin_function
name|Malloc_t
name|safemalloc
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|Malloc_t
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|PerlIO_stderr()
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"panic: malloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|PerlMem_malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* malloc(0) is NASTY on our system */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%x: (%05d) malloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05d) malloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|PerlIO_stderr()
argument_list|,
argument|no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* paranoid version of realloc */
end_comment

begin_function
name|Malloc_t
name|saferealloc
parameter_list|(
name|Malloc_t
name|where
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|Malloc_t
name|ptr
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDARD_C
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_REALLOC_PROTOTYPE
argument_list|)
name|Malloc_t
name|PerlMem_realloc
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* !defined(STANDARD_C)&& !defined(HAS_REALLOC_PROTOTYPE) */
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|PerlIO_stderr()
argument_list|,
literal|"Reallocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|safefree
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|where
condition|)
return|return
name|safemalloc
argument_list|(
name|size
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"panic: realloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|PerlMem_realloc
argument_list|(
name|where
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
name|DEBUG_m
argument_list|(
argument|{ 	PerlIO_printf(Perl_debug_log,
literal|"0x%x: (%05d) rfree\n"
argument|,where,PL_an++); 	PerlIO_printf(Perl_debug_log,
literal|"0x%x: (%05d) realloc %ld bytes\n"
argument|,ptr,PL_an++,(long)size);     }
argument_list|)
else|#
directive|else
name|DEBUG_m
argument_list|(
argument|{ 	PerlIO_printf(Perl_debug_log,
literal|"0x%lx: (%05d) rfree\n"
argument|,where,PL_an++); 	PerlIO_printf(Perl_debug_log,
literal|"0x%lx: (%05d) realloc %ld bytes\n"
argument|,ptr,PL_an++,(long)size);     }
argument_list|)
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|PerlIO_stderr()
argument_list|,
argument|no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* safe version of free */
end_comment

begin_function
name|Free_t
name|safefree
parameter_list|(
name|Malloc_t
name|where
parameter_list|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%x: (%05d) free\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|where
argument_list|,
name|PL_an
operator|++
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05d) free\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|where
argument_list|,
name|PL_an
operator|++
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|where
condition|)
block|{
comment|/*SUPPRESS 701*/
name|PerlMem_free
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* safe version of calloc */
end_comment

begin_function
name|Malloc_t
name|safecalloc
parameter_list|(
name|MEM_SIZE
name|count
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|Malloc_t
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|size
operator|*
name|count
operator|>
literal|0xffff
condition|)
block|{
name|PerlIO_printf
argument_list|(
argument|PerlIO_stderr()
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
argument|size * count
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
operator|||
operator|(
name|long
operator|)
name|count
operator|<
literal|0
condition|)
name|croak
argument_list|(
literal|"panic: calloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|*=
name|count
expr_stmt|;
name|ptr
operator|=
name|PerlMem_malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* malloc(0) is NASTY on our system */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%x: (%05d) calloc %ld  x %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_m
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx: (%05d) calloc %ld x %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|PL_an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
elseif|else
if|if
condition|(
name|PL_nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|PerlIO_puts
argument_list|(
argument|PerlIO_stderr()
argument_list|,
argument|no_mem
argument_list|)
name|FLUSH
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MYMALLOC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_struct
struct|struct
name|mem_test_strut
block|{
union|union
block|{
name|long
name|type
decl_stmt|;
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|long
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ALIGN
value|sizeof(struct mem_test_strut)
end_define

begin_define
define|#
directive|define
name|sizeof_chunk
parameter_list|(
name|ch
parameter_list|)
value|(((struct mem_test_strut*) (ch))->size)
end_define

begin_define
define|#
directive|define
name|typeof_chunk
parameter_list|(
name|ch
parameter_list|)
define|\
value|(((struct mem_test_strut*) (ch))->u.c[0] + ((struct mem_test_strut*) (ch))->u.c[1]*100)
end_define

begin_define
define|#
directive|define
name|set_typeof_chunk
parameter_list|(
name|ch
parameter_list|,
name|t
parameter_list|)
define|\
value|(((struct mem_test_strut*) (ch))->u.c[0] = t % 100, ((struct mem_test_strut*) (ch))->u.c[1] = t / 100)
end_define

begin_define
define|#
directive|define
name|SIZE_TO_Y
parameter_list|(
name|size
parameter_list|)
value|( (size)> MAXY_SIZE				\ 			  ? MAXYCOUNT - 1 				\ 			  : ( (size)> 40 				\ 			      ? ((size) - 1)/8 + 5			\ 			      : ((size) - 1)/4))
end_define

begin_function
name|Malloc_t
name|safexmalloc
parameter_list|(
name|I32
name|x
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|safemalloc
argument_list|(
name|size
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xcount
index|[
name|x
index|]
operator|+=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|set_typeof_chunk
argument_list|(
name|where
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|where
operator|+
name|ALIGN
argument_list|)
return|;
block|}
end_function

begin_function
name|Malloc_t
name|safexrealloc
parameter_list|(
name|Malloc_t
name|wh
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|wh
decl_stmt|;
if|if
condition|(
operator|!
name|wh
condition|)
return|return
name|safexmalloc
argument_list|(
literal|0
argument_list|,
name|size
argument_list|)
return|;
block|{
name|MEM_SIZE
name|old
init|=
name|sizeof_chunk
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|typeof_chunk
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|saferealloc
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|,
name|size
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xycount
index|[
name|t
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|old
argument_list|)
index|]
operator|--
expr_stmt|;
name|xycount
index|[
name|t
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|xcount
index|[
name|t
index|]
operator|+=
name|size
operator|-
name|old
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|new
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|new
operator|+
name|ALIGN
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|safexfree
parameter_list|(
name|Malloc_t
name|wh
parameter_list|)
block|{
name|I32
name|x
decl_stmt|;
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|wh
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|where
condition|)
return|return;
name|where
operator|-=
name|ALIGN
expr_stmt|;
name|size
operator|=
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|x
operator|=
name|where
index|[
literal|0
index|]
operator|+
literal|100
operator|*
name|where
index|[
literal|1
index|]
expr_stmt|;
name|xcount
index|[
name|x
index|]
operator|-=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|--
expr_stmt|;
name|safefree
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Malloc_t
name|safexcalloc
parameter_list|(
name|I32
name|x
parameter_list|,
name|MEM_SIZE
name|count
parameter_list|,
name|MEM_SIZE
name|size
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|where
init|=
operator|(
name|char
operator|*
operator|)
name|safexmalloc
argument_list|(
name|x
argument_list|,
name|size
operator|*
name|count
operator|+
name|ALIGN
argument_list|)
decl_stmt|;
name|xcount
index|[
name|x
index|]
operator|+=
name|size
expr_stmt|;
name|xycount
index|[
name|x
index|]
index|[
name|SIZE_TO_Y
argument_list|(
name|size
argument_list|)
index|]
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|where
operator|+
name|ALIGN
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
name|set_typeof_chunk
argument_list|(
name|where
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sizeof_chunk
argument_list|(
name|where
argument_list|)
operator|=
name|size
expr_stmt|;
return|return
call|(
name|Malloc_t
call|)
argument_list|(
name|where
operator|+
name|ALIGN
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xstat
parameter_list|(
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|I32
name|subtot
index|[
name|MAXYCOUNT
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
name|subtot
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"   Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXXCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|xcount
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
name|subtot
index|[
name|j
index|]
operator|+=
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|?
name|xcount
index|[
name|i
index|]
comment|/* Have something */
else|:
operator|(
name|flag
operator|==
literal|2
condition|?
name|xcount
index|[
name|i
index|]
operator|!=
name|lastxcount
index|[
name|i
index|]
comment|/* Changed */
else|:
name|xcount
index|[
name|i
index|]
operator|>
name|lastxcount
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* Growed */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%2d %02d %7ld "
argument_list|,
name|i
operator|/
literal|100
argument_list|,
name|i
operator|%
literal|100
argument_list|,
name|flag
operator|==
literal|2
condition|?
name|xcount
index|[
name|i
index|]
operator|-
name|lastxcount
index|[
name|i
index|]
else|:
name|xcount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastxcount
index|[
name|i
index|]
operator|=
name|xcount
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|flag
operator|==
literal|0
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
comment|/* Have something */
else|:
operator|(
name|flag
operator|==
literal|2
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
comment|/* Changed */
else|:
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|>
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
condition|)
block|{
comment|/* Growed */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%3ld "
argument_list|,
name|flag
operator|==
literal|2
condition|?
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|-
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
else|:
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|lastxycount
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"  . "
argument_list|,
name|xycount
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
operator|!=
literal|2
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"Total %7ld "
argument_list|,
name|total
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXYCOUNT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|subtot
index|[
name|j
index|]
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%3ld "
argument_list|,
name|subtot
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"  . "
argument_list|)
expr_stmt|;
block|}
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEAKTEST */
end_comment

begin_comment
comment|/* copy a string up to some (non-backslashed) delimiter, if any */
end_comment

begin_function
name|char
modifier|*
name|delimcpy
parameter_list|(
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
name|char
modifier|*
name|toend
parameter_list|,
specifier|register
name|char
modifier|*
name|from
parameter_list|,
specifier|register
name|char
modifier|*
name|fromend
parameter_list|,
specifier|register
name|int
name|delim
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|I32
name|tolen
decl_stmt|;
for|for
control|(
name|tolen
operator|=
literal|0
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|++
operator|,
name|tolen
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
name|delim
condition|)
name|from
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
name|tolen
operator|++
expr_stmt|;
name|from
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
name|delim
condition|)
break|break;
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|<
name|toend
condition|)
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|retlen
operator|=
name|tolen
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* return ptr to little string in big string, NULL if not found */
end_comment

begin_comment
comment|/* This routine was donated by Corey Satten. */
end_comment

begin_function
name|char
modifier|*
name|instr
parameter_list|(
specifier|register
name|char
modifier|*
name|big
parameter_list|,
specifier|register
name|char
modifier|*
name|little
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|little
condition|)
return|return
name|big
return|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|big
return|;
while|while
condition|(
operator|*
name|big
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
operator|*
name|s
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|x
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
name|big
operator|-
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* same as instr but allow embedded nulls */
end_comment

begin_function
name|char
modifier|*
name|ninstr
parameter_list|(
specifier|register
name|char
modifier|*
name|big
parameter_list|,
specifier|register
name|char
modifier|*
name|bigend
parameter_list|,
name|char
modifier|*
name|little
parameter_list|,
name|char
modifier|*
name|lend
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>=
name|littleend
condition|)
return|return
name|big
return|;
if|if
condition|(
name|bigend
operator|-
name|big
operator|<
name|littleend
operator|-
name|little
condition|)
return|return
name|Nullch
return|;
name|bigend
operator|-=
name|littleend
operator|-
name|little
operator|++
expr_stmt|;
while|while
condition|(
name|big
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
name|big
operator|-
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* reverse of the above--find last substring */
end_comment

begin_function
name|char
modifier|*
name|rninstr
parameter_list|(
specifier|register
name|char
modifier|*
name|big
parameter_list|,
name|char
modifier|*
name|bigend
parameter_list|,
name|char
modifier|*
name|little
parameter_list|,
name|char
modifier|*
name|lend
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|bigbeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|I32
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>=
name|littleend
condition|)
return|return
name|bigend
return|;
name|bigbeg
operator|=
name|big
expr_stmt|;
name|big
operator|=
name|bigend
operator|-
operator|(
name|littleend
operator|-
name|little
operator|++
operator|)
expr_stmt|;
while|while
condition|(
name|big
operator|>=
name|bigbeg
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|--
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
literal|2
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
name|big
operator|+
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/*  * Set up for a new ctype locale.  */
end_comment

begin_function
name|void
name|perl_new_ctype
parameter_list|(
name|char
modifier|*
name|newctype
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isUPPER_LC
argument_list|(
name|i
argument_list|)
condition|)
name|fold_locale
index|[
name|i
index|]
operator|=
name|toLOWER_LC
argument_list|(
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isLOWER_LC
argument_list|(
name|i
argument_list|)
condition|)
name|fold_locale
index|[
name|i
index|]
operator|=
name|toUPPER_LC
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|fold_locale
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
block|}
end_function

begin_comment
comment|/*  * Set up for a new collation locale.  */
end_comment

begin_function
name|void
name|perl_new_collate
parameter_list|(
name|char
modifier|*
name|newcoll
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
name|newcoll
condition|)
block|{
if|if
condition|(
name|PL_collation_name
condition|)
block|{
operator|++
name|PL_collation_ix
expr_stmt|;
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|NULL
expr_stmt|;
name|PL_collation_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_collxfrm_base
operator|=
literal|0
expr_stmt|;
name|PL_collxfrm_mult
operator|=
literal|2
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|PL_collation_name
operator|||
name|strNE
argument_list|(
name|PL_collation_name
argument_list|,
name|newcoll
argument_list|)
condition|)
block|{
operator|++
name|PL_collation_ix
expr_stmt|;
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|savepv
argument_list|(
name|newcoll
argument_list|)
expr_stmt|;
name|PL_collation_standard
operator|=
operator|(
name|strEQ
argument_list|(
name|newcoll
argument_list|,
literal|"C"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|newcoll
argument_list|,
literal|"POSIX"
argument_list|)
operator|)
expr_stmt|;
block|{
comment|/*  2: at most so many chars ('a', 'b'). */
comment|/* 50: surely no system expands a char more. */
define|#
directive|define
name|XFRMBUFSIZE
value|(2 * 50)
name|char
name|xbuf
index|[
name|XFRMBUFSIZE
index|]
decl_stmt|;
name|Size_t
name|fa
init|=
name|strxfrm
argument_list|(
name|xbuf
argument_list|,
literal|"a"
argument_list|,
name|XFRMBUFSIZE
argument_list|)
decl_stmt|;
name|Size_t
name|fb
init|=
name|strxfrm
argument_list|(
name|xbuf
argument_list|,
literal|"ab"
argument_list|,
name|XFRMBUFSIZE
argument_list|)
decl_stmt|;
name|SSize_t
name|mult
init|=
name|fb
operator|-
name|fa
decl_stmt|;
if|if
condition|(
name|mult
operator|<
literal|1
condition|)
name|croak
argument_list|(
literal|"strxfrm() gets absurd"
argument_list|)
expr_stmt|;
name|PL_collxfrm_base
operator|=
operator|(
name|fa
operator|>
name|mult
operator|)
condition|?
operator|(
name|fa
operator|-
name|mult
operator|)
else|:
literal|0
expr_stmt|;
name|PL_collxfrm_mult
operator|=
name|mult
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
block|}
end_function

begin_comment
comment|/*  * Set up for a new numeric locale.  */
end_comment

begin_function
name|void
name|perl_new_numeric
parameter_list|(
name|char
modifier|*
name|newnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|newnum
condition|)
block|{
if|if
condition|(
name|PL_numeric_name
condition|)
block|{
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|NULL
expr_stmt|;
name|PL_numeric_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|PL_numeric_name
operator|||
name|strNE
argument_list|(
name|PL_numeric_name
argument_list|,
name|newnum
argument_list|)
condition|)
block|{
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|savepv
argument_list|(
name|newnum
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
operator|(
name|strEQ
argument_list|(
name|newnum
argument_list|,
literal|"C"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|newnum
argument_list|,
literal|"POSIX"
argument_list|)
operator|)
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_function
name|void
name|perl_set_numeric_standard
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|PL_numeric_standard
condition|)
block|{
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
name|TRUE
expr_stmt|;
name|PL_numeric_local
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_function
name|void
name|perl_set_numeric_local
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|PL_numeric_local
condition|)
block|{
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_standard
operator|=
name|FALSE
expr_stmt|;
name|PL_numeric_local
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
end_function

begin_comment
comment|/*  * Initialize locale awareness.  */
end_comment

begin_function
name|int
name|perl_init_i18nl10n
parameter_list|(
name|int
name|printwarn
parameter_list|)
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
comment|/* returns      *    1 = set ok or not applicable,      *    0 = fallback to C locale,      *   -1 = fallback to C locale failed      */
ifdef|#
directive|ifdef
name|USE_LOCALE
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|char
modifier|*
name|curctype
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|char
modifier|*
name|curcoll
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|char
modifier|*
name|curnum
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
ifdef|#
directive|ifdef
name|__GLIBC__
name|char
modifier|*
name|language
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LANGUAGE"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|lc_all
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lang
init|=
name|PerlEnv_getenv
argument_list|(
literal|"LANG"
argument_list|)
decl_stmt|;
name|bool
name|setlocale_failure
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE_ENVIRON_REQUIRED
comment|/*      * Ultrix setlocale(..., "") fails if there are no environment      * variables from which to get a locale name.      */
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
name|lang
condition|)
block|{
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
condition|)
name|done
operator|=
name|TRUE
expr_stmt|;
else|else
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|setlocale_failure
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
operator|(
name|curctype
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
operator|(
name|curcoll
operator|=
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_COLLATE"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
operator|(
name|curnum
operator|=
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
operator|(
operator|!
name|done
operator|&&
operator|(
name|lang
operator|||
name|PerlEnv_getenv
argument_list|(
literal|"LC_NUMERIC"
argument_list|)
operator|)
operator|)
condition|?
literal|""
else|:
name|Nullch
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
endif|#
directive|endif
comment|/* LC_ALL */
endif|#
directive|endif
comment|/* !LOCALE_ENVIRON_REQUIRED */
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
operator|!
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* LC_ALL */
if|if
condition|(
operator|!
name|setlocale_failure
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
operator|(
name|curctype
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
operator|(
name|curcoll
operator|=
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
operator|(
name|curnum
operator|=
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
name|setlocale_failure
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
if|if
condition|(
name|setlocale_failure
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|locwarn
init|=
operator|(
name|printwarn
operator|>
literal|1
operator|||
name|printwarn
operator|&&
operator|(
operator|!
operator|(
name|p
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_BADLANG"
argument_list|)
operator|)
operator|||
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|locwarn
condition|)
block|{
ifdef|#
directive|ifdef
name|LC_ALL
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Setting locale failed.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !LC_ALL */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Setting locale failed for the categories:\n\t"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
if|if
condition|(
operator|!
name|curctype
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"LC_CTYPE "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
if|if
condition|(
operator|!
name|curcoll
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"LC_COLLATE "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
if|if
condition|(
operator|!
name|curnum
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"LC_NUMERIC "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LC_ALL */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Please check that your locale settings:\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GLIBC__
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\tLANGUAGE = %c%s%c,\n"
argument_list|,
name|language
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|language
condition|?
name|language
else|:
literal|"unset"
argument_list|,
name|language
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\tLC_ALL = %c%s%c,\n"
argument_list|,
name|lc_all
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|lc_all
condition|?
name|lc_all
else|:
literal|"unset"
argument_list|,
name|lc_all
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|environ
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
operator|*
name|e
argument_list|,
literal|"LC_"
argument_list|,
literal|3
argument_list|)
operator|&&
name|strnNE
argument_list|(
operator|*
name|e
argument_list|,
literal|"LC_ALL="
argument_list|,
literal|7
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|e
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\t%.*s = \"%s\",\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|e
argument_list|)
argument_list|,
operator|*
name|e
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\tLANG = %c%s%c\n"
argument_list|,
name|lang
condition|?
literal|'"'
else|:
literal|'('
argument_list|,
name|lang
condition|?
name|lang
else|:
literal|"unset"
argument_list|,
name|lang
condition|?
literal|'"'
else|:
literal|')'
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"    are supported and installed on your system.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LC_ALL
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
condition|)
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Falling back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Failed to fall back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! LC_ALL */
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
operator|||
operator|!
operator|(
name|curctype
operator|||
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
operator|||
operator|!
operator|(
name|curcoll
operator|||
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
operator|||
operator|!
operator|(
name|curnum
operator|||
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|"C"
argument_list|)
operator|)
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
condition|)
block|{
if|if
condition|(
name|locwarn
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"perl: warning: Cannot fall back to the standard locale (\"C\").\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! LC_ALL */
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|curctype
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|curcoll
operator|=
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|curnum
operator|=
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
block|}
ifdef|#
directive|ifdef
name|USE_LOCALE_CTYPE
name|perl_new_ctype
argument_list|(
name|curctype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_CTYPE */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|perl_new_collate
argument_list|(
name|curcoll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|perl_new_numeric
argument_list|(
name|curnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
endif|#
directive|endif
comment|/* USE_LOCALE */
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Backwards compatibility. */
end_comment

begin_function
name|int
name|perl_init_i18nl14n
parameter_list|(
name|int
name|printwarn
parameter_list|)
block|{
return|return
name|perl_init_i18nl10n
argument_list|(
name|printwarn
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
end_ifdef

begin_comment
comment|/*  * mem_collxfrm() is a bit like strxfrm() but with two important  * differences. First, it handles embedded NULs. Second, it allocates  * a bit more memory than needed for the transformed data itself.  * The real transformed data begins at offset sizeof(collationix).  * Please see sv_collxfrm() to see how this is used.  */
end_comment

begin_function
name|char
modifier|*
name|mem_collxfrm
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
modifier|*
name|xlen
parameter_list|)
block|{
name|char
modifier|*
name|xbuf
decl_stmt|;
name|STRLEN
name|xAlloc
decl_stmt|,
name|xin
decl_stmt|,
name|xout
decl_stmt|;
comment|/* xalloc is a reserved word in VC */
comment|/* the first sizeof(collationix) bytes are used by sv_collxfrm(). */
comment|/* the +1 is for the terminating NUL. */
name|xAlloc
operator|=
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
operator|+
name|PL_collxfrm_base
operator|+
operator|(
name|PL_collxfrm_mult
operator|*
name|len
operator|)
operator|+
literal|1
expr_stmt|;
name|New
argument_list|(
literal|171
argument_list|,
name|xbuf
argument_list|,
name|xAlloc
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbuf
condition|)
goto|goto
name|bad
goto|;
operator|*
operator|(
name|U32
operator|*
operator|)
name|xbuf
operator|=
name|PL_collation_ix
expr_stmt|;
name|xout
operator|=
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
expr_stmt|;
for|for
control|(
name|xin
operator|=
literal|0
init|;
name|xin
operator|<
name|len
condition|;
control|)
block|{
name|SSize_t
name|xused
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xused
operator|=
name|strxfrm
argument_list|(
name|xbuf
operator|+
name|xout
argument_list|,
name|s
operator|+
name|xin
argument_list|,
name|xAlloc
operator|-
name|xout
argument_list|)
expr_stmt|;
if|if
condition|(
name|xused
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xused
operator|<
name|xAlloc
operator|-
name|xout
condition|)
break|break;
name|xAlloc
operator|=
operator|(
literal|2
operator|*
name|xAlloc
operator|)
operator|+
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|xbuf
argument_list|,
name|xAlloc
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbuf
condition|)
goto|goto
name|bad
goto|;
block|}
name|xin
operator|+=
name|strlen
argument_list|(
name|s
operator|+
name|xin
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xout
operator|+=
name|xused
expr_stmt|;
comment|/* Embedded NULs are understood but silently skipped 	 * because they make no sense in locale collation. */
block|}
name|xbuf
index|[
name|xout
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|xlen
operator|=
name|xout
operator|-
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
expr_stmt|;
return|return
name|xbuf
return|;
name|bad
label|:
name|Safefree
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
operator|*
name|xlen
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOCALE_COLLATE */
end_comment

begin_function
name|void
name|fbm_compile
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|U32
name|flags
comment|/* not used yet */
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|s
decl_stmt|;
specifier|register
name|U8
modifier|*
name|table
decl_stmt|;
specifier|register
name|U32
name|i
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|I32
name|rarest
init|=
literal|0
decl_stmt|;
name|U32
name|frequency
init|=
literal|256
decl_stmt|;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVBM
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
operator|||
name|len
operator|==
literal|0
condition|)
comment|/* TAIL might be on on a zero-length string. */
return|return;
comment|/* can't have offsets that big */
if|if
condition|(
name|len
operator|>
literal|2
condition|)
block|{
name|Sv_Grow
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|258
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|len
operator|+
literal|1
operator|)
expr_stmt|;
name|s
operator|=
name|table
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|table
index|[
name|i
index|]
operator|=
name|len
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|>=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|table
index|[
operator|*
name|s
index|]
operator|==
name|len
condition|)
name|table
index|[
operator|*
name|s
index|]
operator|=
name|i
expr_stmt|;
name|s
operator|--
operator|,
name|i
operator|++
expr_stmt|;
block|}
block|}
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'B'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* deep magic */
name|SvVALID_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|)
expr_stmt|;
comment|/* deeper magic */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
index|[
name|s
index|[
name|i
index|]
index|]
operator|<
name|frequency
condition|)
block|{
name|rarest
operator|=
name|i
expr_stmt|;
name|frequency
operator|=
name|freq
index|[
name|s
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
name|BmRARE
argument_list|(
name|sv
argument_list|)
operator|=
name|s
index|[
name|rarest
index|]
expr_stmt|;
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
operator|=
name|rarest
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"rarest char %c at %d\n"
argument_list|,
name|BmRARE
argument_list|(
name|sv
argument_list|)
argument_list|,
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|fbm_instr
parameter_list|(
name|unsigned
name|char
modifier|*
name|big
parameter_list|,
specifier|register
name|unsigned
name|char
modifier|*
name|bigend
parameter_list|,
name|SV
modifier|*
name|littlestr
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
specifier|register
name|I32
name|littlelen
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|table
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|olds
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|oldlittle
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|littlestr
argument_list|)
operator|!=
name|SVt_PVBM
operator|||
operator|!
name|SvVALID
argument_list|(
name|littlestr
argument_list|)
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|l
init|=
name|SvPV
argument_list|(
name|littlestr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
condition|)
block|{
comment|/* Can be only 0-len constant 					   substr => we can ignore SvVALID */
if|if
condition|(
name|PL_multiline
condition|)
block|{
name|char
modifier|*
name|t
init|=
literal|"\n"
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ninstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|big
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bigend
argument_list|,
name|t
argument_list|,
name|t
operator|+
name|len
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
block|}
if|if
condition|(
name|bigend
operator|>
name|big
operator|&&
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|bigend
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|char
operator|*
operator|)
name|bigend
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
block|}
return|return
name|ninstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|big
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bigend
argument_list|,
name|l
argument_list|,
name|l
operator|+
name|len
argument_list|)
return|;
block|}
name|littlelen
operator|=
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|&&
operator|!
name|PL_multiline
condition|)
block|{
comment|/* tail anchored? */
if|if
condition|(
name|littlelen
operator|>
name|bigend
operator|-
name|big
condition|)
return|return
name|Nullch
return|;
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|s
operator|=
name|bigend
operator|-
name|littlelen
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|big
operator|&&
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|little
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
argument_list|,
name|littlelen
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
operator|-
literal|1
return|;
comment|/* how sweet it is */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|little
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little
argument_list|,
name|littlelen
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
comment|/* how sweet it is */
return|return
name|Nullch
return|;
block|}
if|if
condition|(
name|littlelen
operator|<=
literal|2
condition|)
block|{
name|unsigned
name|char
name|c1
init|=
operator|(
name|unsigned
name|char
operator|)
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
operator|(
name|unsigned
name|char
operator|)
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
comment|/* This may do extra comparisons if littlelen == 2, but this 	   should be hidden in the noise since we do less indirection. */
name|s
operator|=
name|big
expr_stmt|;
name|bigend
operator|-=
name|littlelen
expr_stmt|;
while|while
condition|(
name|s
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|c1
operator|&&
operator|(
name|littlelen
operator|==
literal|1
operator|||
name|s
index|[
literal|1
index|]
operator|==
name|c2
operator|)
operator|&&
operator|(
operator|!
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
operator|||
name|s
operator|==
name|bigend
operator|||
name|s
index|[
name|littlelen
index|]
operator|==
literal|'\n'
operator|)
condition|)
comment|/* Automatically multiline */
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
name|s
operator|++
expr_stmt|;
block|}
return|return
name|Nullch
return|;
block|}
name|table
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
operator|+
name|littlelen
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|--
name|littlelen
operator|>=
name|bigend
operator|-
name|big
condition|)
return|return
name|Nullch
return|;
name|s
operator|=
name|big
operator|+
name|littlelen
expr_stmt|;
name|oldlittle
operator|=
name|little
operator|=
name|table
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
block|{
name|top2
label|:
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmp
operator|=
name|table
index|[
operator|*
name|s
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERRIGOR
if|if
condition|(
name|bigend
operator|-
name|s
operator|>
name|tmp
condition|)
block|{
name|s
operator|+=
name|tmp
expr_stmt|;
goto|goto
name|top2
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|s
operator|+=
name|tmp
operator|)
operator|<
name|bigend
condition|)
goto|goto
name|top2
goto|;
endif|#
directive|endif
return|return
name|Nullch
return|;
block|}
else|else
block|{
name|tmp
operator|=
name|littlelen
expr_stmt|;
comment|/* less expensive than calling strncmp() */
name|olds
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|tmp
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|s
operator|==
operator|*
operator|--
name|little
condition|)
continue|continue;
name|differ
label|:
name|s
operator|=
name|olds
operator|+
literal|1
expr_stmt|;
comment|/* here we pay the price for failure */
name|little
operator|=
name|oldlittle
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
comment|/* fake up continue to outer loop */
goto|goto
name|top2
goto|;
return|return
name|Nullch
return|;
block|}
if|if
condition|(
name|SvTAIL
argument_list|(
name|littlestr
argument_list|)
comment|/* automatically multiline */
operator|&&
name|olds
operator|+
literal|1
operator|!=
name|bigend
operator|&&
name|olds
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
goto|goto
name|differ
goto|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* start_shift, end_shift are positive quantities which give offsets    of ends of some substring of bigstr.    If `last' we want the last occurence.    old_posp is the way of communication between consequent calls if    the next call needs to find the .     The initial *old_posp should be -1.    Note that we do not take into account SvTAIL, so it may give wrong    positives if _ALL flag is set.  */
end_comment

begin_function
name|char
modifier|*
name|screaminstr
parameter_list|(
name|SV
modifier|*
name|bigstr
parameter_list|,
name|SV
modifier|*
name|littlestr
parameter_list|,
name|I32
name|start_shift
parameter_list|,
name|I32
name|end_shift
parameter_list|,
name|I32
modifier|*
name|old_posp
parameter_list|,
name|I32
name|last
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|I32
name|pos
decl_stmt|;
specifier|register
name|I32
name|previous
decl_stmt|;
specifier|register
name|I32
name|first
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
decl_stmt|;
specifier|register
name|I32
name|stop_pos
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|littleend
decl_stmt|;
name|I32
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|old_posp
operator|==
operator|-
literal|1
condition|?
operator|(
name|pos
operator|=
name|PL_screamfirst
index|[
name|BmRARE
argument_list|(
name|littlestr
argument_list|)
index|]
operator|)
operator|<
literal|0
else|:
operator|(
operator|(
operator|(
name|pos
operator|=
operator|*
name|old_posp
operator|)
operator|,
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|Nullch
return|;
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|littlestr
argument_list|)
operator|)
expr_stmt|;
name|littleend
operator|=
name|little
operator|+
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
comment|/* The value of pos we can start at: */
name|previous
operator|=
name|BmPREVIOUS
argument_list|(
name|littlestr
argument_list|)
expr_stmt|;
name|big
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|)
expr_stmt|;
comment|/* The value of pos we can stop at: */
name|stop_pos
operator|=
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|-
name|end_shift
operator|-
operator|(
name|SvCUR
argument_list|(
name|littlestr
argument_list|)
operator|-
literal|1
operator|-
name|previous
operator|)
expr_stmt|;
if|if
condition|(
name|previous
operator|+
name|start_shift
operator|>
name|stop_pos
condition|)
return|return
name|Nullch
return|;
while|while
condition|(
name|pos
operator|<
name|previous
operator|+
name|start_shift
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
operator|)
condition|)
return|return
name|Nullch
return|;
block|}
ifdef|#
directive|ifdef
name|POINTERRIGOR
do|do
block|{
if|if
condition|(
name|pos
operator|>=
name|stop_pos
condition|)
break|break;
if|if
condition|(
name|big
index|[
name|pos
operator|-
name|previous
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|-
name|previous
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
block|{
operator|*
name|old_posp
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|-
name|previous
operator|)
return|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
condition|)
do|;
return|return
operator|(
name|last
operator|&&
name|found
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
operator|(
operator|*
name|old_posp
operator|)
operator|-
name|previous
operator|)
else|:
name|Nullch
return|;
else|#
directive|else
comment|/* !POINTERRIGOR */
name|big
operator|-=
name|previous
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pos
operator|>=
name|stop_pos
condition|)
break|break;
if|if
condition|(
name|big
index|[
name|pos
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
block|{
operator|*
name|old_posp
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|)
return|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pos
operator|+=
name|PL_screamnext
index|[
name|pos
index|]
condition|)
do|;
return|return
operator|(
name|last
operator|&&
name|found
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
operator|(
operator|*
name|old_posp
operator|)
operator|)
else|:
name|Nullch
return|;
endif|#
directive|endif
comment|/* POINTERRIGOR */
block|}
end_function

begin_function
name|I32
name|ibcmp
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|&&
operator|*
name|a
operator|!=
name|fold
index|[
operator|*
name|b
index|]
condition|)
return|return
literal|1
return|;
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|I32
name|ibcmp_locale
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|&&
operator|*
name|a
operator|!=
name|fold_locale
index|[
operator|*
name|b
index|]
condition|)
return|return
literal|1
return|;
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* copy a string to a safe spot */
end_comment

begin_function
name|char
modifier|*
name|savepv
parameter_list|(
name|char
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|902
argument_list|,
name|newaddr
argument_list|,
name|strlen
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newaddr
argument_list|,
name|sv
argument_list|)
expr_stmt|;
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* same thing but with a known length */
end_comment

begin_function
name|char
modifier|*
name|savepvn
parameter_list|(
name|char
modifier|*
name|sv
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|903
argument_list|,
name|newaddr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|sv
argument_list|,
name|newaddr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* might not be null terminated */
name|newaddr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* is now */
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* the SV for form() and mess() is not kept in an arena */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|mess_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|XPVMG
modifier|*
name|any
decl_stmt|;
comment|/* Create as PVMG now, to avoid any upgrading later */
name|New
argument_list|(
literal|905
argument_list|,
name|sv
argument_list|,
literal|1
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|905
argument_list|,
name|any
argument_list|,
literal|1
argument_list|,
name|XPVMG
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVt_PVMG
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|any
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|/* practically infinite */
return|return
name|sv
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|form
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_mess_sv
condition|)
name|PL_mess_sv
operator|=
name|mess_alloc
argument_list|()
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|PL_mess_sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|PL_mess_sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mess
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|static
name|char
name|dgd
index|[]
init|=
literal|" during global destruction.\n"
decl_stmt|;
if|if
condition|(
operator|!
name|PL_mess_sv
condition|)
name|PL_mess_sv
operator|=
name|mess_alloc
argument_list|()
expr_stmt|;
name|sv
operator|=
name|PL_mess_sv
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|||
operator|*
operator|(
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_dirty
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|dgd
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PL_curcop
operator|->
name|cop_line
condition|)
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|" at %_ line %ld"
argument_list|,
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIO
argument_list|(
name|PL_last_in_gv
argument_list|)
operator|&&
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|line_mode
init|=
operator|(
name|RsSIMPLE
argument_list|(
name|PL_rs
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|PL_rs
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|SvPVX
argument_list|(
name|PL_rs
argument_list|)
operator|==
literal|'\n'
operator|)
decl_stmt|;
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|",<%s> %s %ld"
argument_list|,
name|PL_last_in_gv
operator|==
name|PL_argvgv
condition|?
literal|""
else|:
name|GvNAME
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|,
name|line_mode
condition|?
literal|"line"
else|:
literal|"chunk"
argument_list|,
operator|(
name|long
operator|)
name|IoLINES
argument_list|(
name|GvIOp
argument_list|(
name|PL_last_in_gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|die
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|int
name|was_in_eval
init|=
name|PL_in_eval
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%p: die: curstack = %p, mainstack = %p\n"
argument_list|,
name|thr
argument_list|,
name|PL_curstack
argument_list|,
name|PL_mainstack
argument_list|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|message
operator|=
name|pat
condition|?
name|mess
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
else|:
name|Nullch
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%p: die: message = %s\ndiehook = %p\n"
argument_list|,
name|thr
argument_list|,
name|message
argument_list|,
name|PL_diehook
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_diehook
condition|)
block|{
comment|/* sv_2cv might call croak() */
name|SV
modifier|*
name|olddiehook
init|=
name|PL_diehook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|olddiehook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
name|msg
operator|=
name|newSVpv
argument_list|(
name|message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
name|ERRSV
expr_stmt|;
block|}
name|PUSHSTACKi
argument_list|(
name|PERLSI_DIEHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
name|PL_restartop
operator|=
name|die_where
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%p: die: restartop = %p, was_in_eval = %d, top_env = %p\n"
argument_list|,
name|thr
argument_list|,
name|PL_restartop
argument_list|,
name|was_in_eval
argument_list|,
name|PL_top_env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|PL_restartop
operator|&&
name|was_in_eval
operator|)
operator|||
name|PL_top_env
operator|->
name|je_prev
condition|)
name|JMPENV_JUMP
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|PL_restartop
return|;
block|}
end_function

begin_function
name|void
name|croak
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|message
operator|=
name|mess
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"croak: 0x%lx %s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_diehook
condition|)
block|{
comment|/* sv_2cv might call croak() */
name|SV
modifier|*
name|olddiehook
init|=
name|PL_diehook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|olddiehook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|msg
operator|=
name|newSVpv
argument_list|(
name|message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_DIEHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|PL_restartop
operator|=
name|die_where
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|JMPENV_JUMP
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|)
expr_stmt|;
name|my_failure_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|message
operator|=
name|mess
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_warnhook
condition|)
block|{
comment|/* sv_2cv might call warn() */
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|oldwarnhook
init|=
name|PL_warnhook
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_warnhook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|Nullsv
expr_stmt|;
name|cv
operator|=
name|sv_2cv
argument_list|(
name|oldwarnhook
argument_list|,
operator|&
name|stash
argument_list|,
operator|&
name|gv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
operator|!
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|msg
decl_stmt|;
name|ENTER
expr_stmt|;
name|msg
operator|=
name|newSVpv
argument_list|(
name|message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_WARNHOOK
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
return|return;
block|}
block|}
name|PerlIO_puts
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
name|DEBUG_L
argument_list|(
operator|*
name|message
operator|==
literal|'!'
condition|?
operator|(
name|xstat
argument_list|(
name|message
index|[
literal|1
index|]
operator|==
literal|'!'
condition|?
operator|(
name|message
index|[
literal|2
index|]
operator|==
literal|'!'
condition|?
literal|2
else|:
literal|1
operator|)
else|:
literal|0
argument_list|)
operator|,
literal|0
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|PerlIO_flush
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_comment
comment|/* VMS' my_setenv() is in VMS.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_function
name|void
name|my_setenv
parameter_list|(
name|char
modifier|*
name|nam
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
specifier|register
name|I32
name|i
init|=
name|setenv_getix
argument_list|(
name|nam
argument_list|)
decl_stmt|;
comment|/* where does it go? */
if|if
condition|(
name|environ
operator|==
name|PL_origenviron
condition|)
block|{
comment|/* need we copy environment? */
name|I32
name|j
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmpenv
decl_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|max
operator|=
name|i
init|;
name|environ
index|[
name|max
index|]
condition|;
name|max
operator|++
control|)
empty_stmt|;
name|New
argument_list|(
literal|901
argument_list|,
name|tmpenv
argument_list|,
name|max
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
comment|/* copy environment */
name|tmpenv
index|[
name|j
index|]
operator|=
name|savepv
argument_list|(
name|environ
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|tmpenv
index|[
name|max
index|]
operator|=
name|Nullch
expr_stmt|;
name|environ
operator|=
name|tmpenv
expr_stmt|;
comment|/* tell exec where it is now */
block|}
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|Safefree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|environ
index|[
name|i
index|]
condition|)
block|{
name|environ
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|environ
index|[
name|i
index|]
condition|)
block|{
comment|/* does not exist yet */
name|Renew
argument_list|(
name|environ
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* just expand it a bit */
name|environ
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|Nullch
expr_stmt|;
comment|/* make sure it's null terminated */
block|}
else|else
name|Safefree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|904
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* all that work just for this */
else|#
directive|else
comment|/* MS-DOS requires environment variable names to be in uppercase */
comment|/* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but      * some utilities and applications may break because they only look      * for upper case strings. (Fixed strupr() bug here.)]      */
name|strcpy
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|strupr
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|environ
index|[
name|i
index|]
operator|+
name|strlen
argument_list|(
name|nam
argument_list|)
argument_list|,
literal|"=%s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if WIN32 */
end_comment

begin_function
name|void
name|my_setenv
parameter_list|(
name|char
modifier|*
name|nam
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WIN32_RTL_ENV
specifier|register
name|char
modifier|*
name|envstr
decl_stmt|;
name|STRLEN
name|namlen
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
decl_stmt|;
name|STRLEN
name|vallen
decl_stmt|;
name|char
modifier|*
name|oldstr
init|=
name|environ
index|[
name|setenv_getix
argument_list|(
name|nam
argument_list|)
index|]
decl_stmt|;
comment|/* putenv() has totally broken semantics in both the Borland      * and Microsoft CRTLs.  They either store the passed pointer in      * the environment without making a copy, or make a copy and don't      * free it. And on top of that, they dont free() old entries that      * are being replaced/deleted.  This means the caller must      * free any old entries somehow, or we end up with a memory      * leak every time my_setenv() is called.  One might think      * one could directly manipulate environ[], like the UNIX code      * above, but direct changes to environ are not allowed when      * calling putenv(), since the RTLs maintain an internal      * *copy* of environ[]. Bad, bad, *bad* stink.      * GSAR 97-06-07      */
if|if
condition|(
operator|!
name|val
condition|)
block|{
if|if
condition|(
operator|!
name|oldstr
condition|)
return|return;
name|val
operator|=
literal|""
expr_stmt|;
name|vallen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|vallen
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|904
argument_list|,
name|envstr
argument_list|,
name|namlen
operator|+
name|vallen
operator|+
literal|3
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlEnv_putenv
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstr
condition|)
name|Safefree
argument_list|(
name|oldstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_MSC_VER
name|Safefree
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
comment|/* MSVCRT leaks without this */
endif|#
directive|endif
else|#
directive|else
comment|/* !USE_WIN32_RTL_ENV */
specifier|register
name|char
modifier|*
name|envstr
decl_stmt|;
name|STRLEN
name|len
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|val
operator|=
literal|""
expr_stmt|;
block|}
name|len
operator|+=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|904
argument_list|,
name|envstr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlEnv_putenv
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_function
name|I32
name|setenv_getix
parameter_list|(
name|char
modifier|*
name|nam
parameter_list|)
block|{
specifier|register
name|I32
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|WIN32
name|strnicmp
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|,
name|len
argument_list|)
operator|==
literal|0
else|#
directive|else
name|strnEQ
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|,
name|len
argument_list|)
endif|#
directive|endif
operator|&&
name|environ
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
literal|'='
condition|)
break|break;
comment|/* strnEQ must come first to avoid */
block|}
comment|/* potential SEGV's */
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNLINK_ALL_VERSIONS
end_ifdef

begin_function
name|I32
name|unlnk
parameter_list|(
name|f
parameter_list|)
comment|/* unlink all versions of a file */
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|PerlLIO_unlink
argument_list|(
name|f
argument_list|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BCOPY
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SAFE_BCOPY
argument_list|)
end_if

begin_function
name|char
modifier|*
name|my_bcopy
parameter_list|(
specifier|register
name|char
modifier|*
name|from
parameter_list|,
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
name|I32
name|len
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|-
name|to
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
else|else
block|{
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
operator|(
operator|--
name|to
operator|)
operator|=
operator|*
operator|(
operator|--
name|from
operator|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_MEMSET
end_ifndef

begin_function
name|void
modifier|*
name|my_memset
parameter_list|(
name|loc
parameter_list|,
name|ch
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
specifier|register
name|I32
name|ch
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|retval
init|=
name|loc
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|loc
operator|++
operator|=
name|ch
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BZERO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_MEMSET
argument_list|)
end_if

begin_function
name|char
modifier|*
name|my_bzero
parameter_list|(
name|loc
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|retval
init|=
name|loc
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|loc
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MEMCMP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SANE_MEMCMP
argument_list|)
end_if

begin_function
name|I32
name|my_memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
specifier|register
name|I32
name|len
decl_stmt|;
block|{
specifier|register
name|U8
modifier|*
name|a
init|=
operator|(
name|U8
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|U8
modifier|*
name|b
init|=
operator|(
name|U8
operator|*
operator|)
name|s2
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|tmp
operator|=
operator|*
name|a
operator|++
operator|-
operator|*
name|b
operator|++
condition|)
return|return
name|tmp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_MEMCMP || !HAS_SANE_MEMCMP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VPRINTF
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CHAR_VSPRINTF
end_ifdef

begin_function
name|char
modifier|*
else|#
directive|else
name|int
endif|#
directive|endif
name|vsprintf
parameter_list|(
name|dest
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|FILE
name|fakebuf
decl_stmt|;
name|fakebuf
operator|.
name|_ptr
operator|=
name|dest
expr_stmt|;
name|fakebuf
operator|.
name|_cnt
operator|=
literal|32767
expr_stmt|;
ifndef|#
directive|ifndef
name|_IOSTRG
define|#
directive|define
name|_IOSTRG
value|0
endif|#
directive|endif
name|fakebuf
operator|.
name|_flag
operator|=
name|_IOWRT
operator||
name|_IOSTRG
expr_stmt|;
name|_doprnt
argument_list|(
name|pat
argument_list|,
name|args
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
comment|/* what a kludge */
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CHAR_VSPRINTF
return|return
operator|(
name|dest
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
comment|/* perl doesn't use return value */
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_VPRINTF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MYSWAP
end_ifdef

begin_if
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x4321
end_if

begin_function
name|short
name|my_swap
parameter_list|(
name|short
name|s
parameter_list|)
block|{
if|#
directive|if
operator|(
name|BYTEORDER
operator|&
literal|1
operator|)
operator|==
literal|0
name|short
name|result
decl_stmt|;
name|result
operator|=
operator|(
operator|(
name|s
operator|&
literal|255
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|255
operator|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
name|s
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|my_htonl
parameter_list|(
name|long
name|l
parameter_list|)
block|{
union|union
block|{
name|long
name|result
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|result
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|croak
argument_list|(
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|I32
name|o
decl_stmt|;
specifier|register
name|I32
name|s
decl_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|=
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|255
expr_stmt|;
block|}
return|return
name|u
operator|.
name|result
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|my_ntohl
parameter_list|(
name|long
name|l
parameter_list|)
block|{
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|l
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|croak
argument_list|(
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|I32
name|o
decl_stmt|;
specifier|register
name|I32
name|s
decl_stmt|;
name|u
operator|.
name|l
operator|=
name|l
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|l
operator||=
operator|(
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|&
literal|255
operator|)
operator|<<
name|s
expr_stmt|;
block|}
return|return
name|l
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYTEORDER != 0x4321 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYSWAP */
end_comment

begin_comment
comment|/*  * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.  * If these functions are defined,  * the BYTEORDER is neither 0x1234 nor 0x4321.  * However, this is not assumed.  * -DWS  */
end_comment

begin_define
define|#
directive|define
name|HTOV
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (n)						\ 	register type n;					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register I32 i;					\ 	    register I32 s;					\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		u.c[i] = (n>> s)& 0xFF;			\ 	    }							\ 	    return u.value;					\ 	}
end_define

begin_define
define|#
directive|define
name|VTOH
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (n)						\ 	register type n;					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register I32 i;					\ 	    register I32 s;					\ 	    u.value = n;					\ 	    n = 0;						\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		n += (u.c[i]& 0xFF)<< s;			\ 	    }							\ 	    return n;						\ 	}
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovs
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovl
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohs
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohl
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS' my_popen() is in VMS.c, same with OS/2. */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_function
name|PerlIO
modifier|*
name|my_popen
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|I32
name|This
decl_stmt|,
name|that
decl_stmt|;
specifier|register
name|I32
name|pid
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|doexec
init|=
name|strNE
argument_list|(
name|cmd
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|doexec
condition|)
block|{
return|return
name|my_syspopen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
return|;
block|}
endif|#
directive|endif
name|This
operator|=
operator|(
operator|*
name|mode
operator|==
literal|'w'
operator|)
expr_stmt|;
name|that
operator|=
operator|!
name|This
expr_stmt|;
if|if
condition|(
name|doexec
operator|&&
name|PL_tainting
condition|)
block|{
name|taint_env
argument_list|()
expr_stmt|;
name|taint_proper
argument_list|(
literal|"Insecure %s%s"
argument_list|,
literal|"EXEC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PerlProc_pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Nullfp
return|;
while|while
condition|(
operator|(
name|pid
operator|=
operator|(
name|doexec
condition|?
name|vfork
argument_list|()
else|:
name|fork
argument_list|()
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|p
index|[
name|This
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doexec
condition|)
name|croak
argument_list|(
literal|"Can't fork"
argument_list|)
expr_stmt|;
return|return
name|Nullfp
return|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|GV
modifier|*
name|tmpgv
decl_stmt|;
undef|#
directive|undef
name|THIS
undef|#
directive|undef
name|THAT
define|#
directive|define
name|THIS
value|that
define|#
directive|define
name|THAT
value|This
name|PerlLIO_close
argument_list|(
name|p
index|[
name|THAT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|THIS
index|]
operator|!=
operator|(
operator|*
name|mode
operator|==
literal|'r'
operator|)
condition|)
block|{
name|PerlLIO_dup2
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|,
operator|*
name|mode
operator|==
literal|'r'
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doexec
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|int
name|fd
decl_stmt|;
ifndef|#
directive|ifndef
name|NOFILE
define|#
directive|define
name|NOFILE
value|20
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
name|PL_maxsysfd
operator|+
literal|1
init|;
name|fd
operator|<
name|NOFILE
condition|;
name|fd
operator|++
control|)
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* may or may not use the shell */
name|PerlProc__exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmpgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"$"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
condition|)
name|sv_setiv
argument_list|(
name|GvSV
argument_list|(
name|tmpgv
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|PL_forkprocess
operator|=
literal|0
expr_stmt|;
name|hv_clear
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
comment|/* we have no children */
return|return
name|Nullfp
return|;
undef|#
directive|undef
name|THIS
undef|#
directive|undef
name|THAT
block|}
name|do_execfree
argument_list|()
expr_stmt|;
comment|/* free any memory malloced by child on vfork */
name|PerlLIO_close
argument_list|(
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|that
index|]
operator|<
name|p
index|[
name|This
index|]
condition|)
block|{
name|PerlLIO_dup2
argument_list|(
name|p
index|[
name|This
index|]
argument_list|,
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
name|PerlLIO_close
argument_list|(
name|p
index|[
name|This
index|]
argument_list|)
expr_stmt|;
name|p
index|[
name|This
index|]
operator|=
name|p
index|[
name|that
index|]
expr_stmt|;
block|}
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|p
index|[
name|This
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pid
expr_stmt|;
name|PL_forkprocess
operator|=
name|pid
expr_stmt|;
return|return
name|PerlIO_fdopen
argument_list|(
name|p
index|[
name|This
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
end_if

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|PerlIO
modifier|*
name|my_popen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
comment|/* Needs work for PerlIO ! */
comment|/* used 0 for 2nd parameter to PerlIO-exportFILE; apparently not used */
return|return
name|popen
argument_list|(
name|PerlIO_exportFILE
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DUMP_FDS
end_ifdef

begin_function
name|void
name|dump_fds
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|32
condition|;
name|fd
operator|++
control|)
block|{
if|if
condition|(
name|PerlLIO_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpstatbuf
argument_list|)
operator|>=
literal|0
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|" %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DUMP_FDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_DUP2
end_ifndef

begin_function
name|int
name|dup2
parameter_list|(
name|oldfd
parameter_list|,
name|newfd
parameter_list|)
name|int
name|oldfd
decl_stmt|;
name|int
name|newfd
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_DUPFD
argument_list|)
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|PerlLIO_close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|oldfd
argument_list|,
name|F_DUPFD
argument_list|,
name|newfd
argument_list|)
return|;
else|#
directive|else
define|#
directive|define
name|DUP2_MAX_FDS
value|256
name|int
name|fdtmp
index|[
name|DUP2_MAX_FDS
index|]
decl_stmt|;
name|I32
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|PerlLIO_close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
comment|/* good enough for low fd's... */
while|while
condition|(
operator|(
name|fd
operator|=
name|PerlLIO_dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
operator|&&
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fdx
operator|>=
name|DUP2_MAX_FDS
condition|)
block|{
name|PerlLIO_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
block|}
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|PerlLIO_close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SIGACTION
end_ifdef

begin_function
name|Sighandler_t
name|rsignal
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_RESTART
name|act
operator|.
name|sa_flags
operator||=
name|SA_RESTART
expr_stmt|;
comment|/* SVR4, 4.3+BSD */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_NOCLDWAIT
if|if
condition|(
name|signo
operator|==
name|SIGCHLD
operator|&&
name|handler
operator|==
operator|(
name|Sighandler_t
operator|)
name|SIG_IGN
condition|)
name|act
operator|.
name|sa_flags
operator||=
name|SA_NOCLDWAIT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SIG_ERR
return|;
else|else
return|return
name|oact
operator|.
name|sa_handler
return|;
block|}
end_function

begin_function
name|Sighandler_t
name|rsignal_state
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|struct
name|sigaction
name|oact
decl_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|oact
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SIG_ERR
return|;
else|else
return|return
name|oact
operator|.
name|sa_handler
return|;
block|}
end_function

begin_function
name|int
name|rsignal_save
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_RESTART
name|act
operator|.
name|sa_flags
operator||=
name|SA_RESTART
expr_stmt|;
comment|/* SVR4, 4.3+BSD */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_NOCLDWAIT
if|if
condition|(
name|signo
operator|==
name|SIGCHLD
operator|&&
name|handler
operator|==
operator|(
name|Sighandler_t
operator|)
name|SIG_IGN
condition|)
name|act
operator|.
name|sa_flags
operator||=
name|SA_NOCLDWAIT
expr_stmt|;
endif|#
directive|endif
return|return
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|save
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|rsignal_restore
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
return|return
name|sigaction
argument_list|(
name|signo
argument_list|,
name|save
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAS_SIGACTION */
end_comment

begin_function
name|Sighandler_t
name|rsignal
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|)
block|{
return|return
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|handler
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sig_trapped
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Signal_t
name|sig_trap
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|sig_trapped
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Sighandler_t
name|rsignal_state
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|Sighandler_t
name|oldsig
decl_stmt|;
name|sig_trapped
operator|=
literal|0
expr_stmt|;
name|oldsig
operator|=
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|sig_trap
argument_list|)
expr_stmt|;
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig_trapped
condition|)
name|PerlProc_kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
name|oldsig
return|;
block|}
end_function

begin_function
name|int
name|rsignal_save
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sighandler_t
name|handler
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
operator|*
name|save
operator|=
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
name|handler
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|save
operator|==
name|SIG_ERR
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rsignal_restore
parameter_list|(
name|int
name|signo
parameter_list|,
name|Sigsave_t
modifier|*
name|save
parameter_list|)
block|{
return|return
operator|(
name|PerlProc_signal
argument_list|(
name|signo
argument_list|,
operator|*
name|save
argument_list|)
operator|==
name|SIG_ERR
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_SIGACTION */
end_comment

begin_comment
comment|/* VMS' my_pclose() is in VMS.c; same with OS/2 */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_FORK
argument_list|)
operator|||
name|defined
argument_list|(
name|AMIGAOS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_function
name|I32
name|my_pclose
parameter_list|(
name|PerlIO
modifier|*
name|ptr
parameter_list|)
block|{
name|Sigsave_t
name|hstat
decl_stmt|,
name|istat
decl_stmt|,
name|qstat
decl_stmt|;
name|int
name|status
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|pid2
decl_stmt|;
name|bool
name|close_failed
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|saved_vaxc_errno
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
name|int
name|saved_win32_errno
decl_stmt|;
endif|#
directive|endif
name|svp
operator|=
name|av_fetch
argument_list|(
name|PL_fdpid
argument_list|,
name|PerlIO_fileno
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pid
operator|=
operator|(
name|int
operator|)
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Opened by popen. */
return|return
name|my_syspclose
argument_list|(
name|ptr
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|close_failed
operator|=
operator|(
name|PerlIO_close
argument_list|(
name|ptr
argument_list|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|saved_vaxc_errno
operator|=
name|vaxc$errno
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
name|saved_win32_errno
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|UTS
if|if
condition|(
name|PerlProc_kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|pid
operator|)
return|;
block|}
comment|/* HOM 12/23/91 */
endif|#
directive|endif
name|rsignal_save
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|istat
argument_list|)
expr_stmt|;
name|rsignal_save
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|,
operator|&
name|qstat
argument_list|)
expr_stmt|;
do|do
block|{
name|pid2
operator|=
name|wait4pid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid2
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
name|rsignal_restore
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|hstat
argument_list|)
expr_stmt|;
name|rsignal_restore
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|istat
argument_list|)
expr_stmt|;
name|rsignal_restore
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_failed
condition|)
block|{
name|SETERRNO
argument_list|(
name|saved_errno
argument_list|,
name|saved_vaxc_errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|pid2
operator|<
literal|0
condition|?
name|pid2
else|:
name|status
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|errno
operator|=
literal|0
operator|,
name|status
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_function
name|I32
name|wait4pid
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
modifier|*
name|statusp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|char
name|spid
index|[
name|TYPE_CHARS
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|svp
operator|=
name|hv_fetch
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
operator|*
name|statusp
operator|=
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
else|else
block|{
name|HE
modifier|*
name|entry
decl_stmt|;
name|hv_iterinit
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|=
name|hv_iternext
argument_list|(
name|PL_pidstatus
argument_list|)
condition|)
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|hv_iterkey
argument_list|(
name|entry
argument_list|,
operator|(
name|I32
operator|*
operator|)
name|statusp
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
name|hv_iterval
argument_list|(
name|PL_pidstatus
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|statusp
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hv_delete
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAS_WAITPID
ifdef|#
directive|ifdef
name|HAS_WAITPID_RUNTIME
if|if
condition|(
operator|!
name|HAS_WAITPID_RUNTIME
condition|)
goto|goto
name|hard_way
goto|;
endif|#
directive|endif
return|return
name|PerlProc_waitpid
argument_list|(
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
return|return
name|wait4
argument_list|(
operator|(
name|pid
operator|==
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|,
name|Null
argument_list|(
expr|struct
name|rusage
operator|*
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_WAITPID_RUNTIME
argument_list|)
name|hard_way
label|:
block|{
name|I32
name|result
decl_stmt|;
if|if
condition|(
name|flags
condition|)
name|croak
argument_list|(
literal|"Can't do waitpid with flags"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|result
operator|=
name|PerlProc_wait
argument_list|(
name|statusp
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|pid
operator|>
literal|0
operator|&&
name|result
operator|>=
literal|0
condition|)
name|pidgone
argument_list|(
name|result
argument_list|,
operator|*
name|statusp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
operator|*
name|statusp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH || OS2 || WIN32 */
end_comment

begin_function
name|void
comment|/*SUPPRESS 590*/
name|pidgone
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|status
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
name|spid
index|[
name|TYPE_CHARS
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|*
name|hv_fetch
argument_list|(
name|PL_pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|status
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
end_if

begin_function_decl
name|int
name|pclose
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_FORK
end_ifdef

begin_function
name|int
comment|/* Cannot prototype with I32 					   in os2ish.h. */
name|my_syspclose
parameter_list|(
name|ptr
parameter_list|)
else|#
directive|else
function|I32 my_pclose
parameter_list|(
name|ptr
parameter_list|)
endif|#
directive|endif
name|PerlIO
modifier|*
name|ptr
decl_stmt|;
block|{
comment|/* Needs work for PerlIO ! */
name|FILE
modifier|*
name|f
init|=
name|PerlIO_findFILE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|I32
name|result
init|=
name|pclose
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|PerlIO_releaseFILE
argument_list|(
name|ptr
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|repeatcpy
parameter_list|(
specifier|register
name|char
modifier|*
name|to
parameter_list|,
specifier|register
name|char
modifier|*
name|from
parameter_list|,
name|I32
name|len
parameter_list|,
specifier|register
name|I32
name|count
parameter_list|)
block|{
specifier|register
name|I32
name|todo
decl_stmt|;
specifier|register
name|char
modifier|*
name|frombase
init|=
name|from
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|from
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|todo
operator|=
name|len
init|;
name|todo
operator|>
literal|0
condition|;
name|todo
operator|--
control|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
name|from
operator|=
name|frombase
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CASTNEGFLOAT
end_ifndef

begin_function
name|U32
name|cast_ulong
parameter_list|(
name|f
parameter_list|)
name|double
name|f
decl_stmt|;
block|{
name|long
name|along
decl_stmt|;
if|#
directive|if
name|CASTFLAGS
operator|&
literal|2
define|#
directive|define
name|BIGDOUBLE
value|2147483648.0
if|if
condition|(
name|f
operator|>=
name|BIGDOUBLE
condition|)
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
name|f
operator|-
call|(
name|long
call|)
argument_list|(
name|f
operator|/
name|BIGDOUBLE
argument_list|)
operator|*
name|BIGDOUBLE
argument_list|)
operator||
literal|0x80000000
return|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|>=
literal|0.0
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|f
return|;
name|along
operator|=
operator|(
name|long
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|along
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BIGDOUBLE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CASTI32
end_ifndef

begin_comment
comment|/* Unfortunately, on some systems the cast_uv() function doesn't    work with the system-supplied definition of ULONG_MAX.  The    comparison  (f>= ULONG_MAX) always comes out true.  It must be a    problem with the compiler constant folding.     In any case, this workaround should be fine on any two's complement    system.  If it's not, supply a '-DMY_ULONG_MAX=whatever' in your    ccflags. 	       --Andy Dougherty<doughera@lafcol.lafayette.edu> */
end_comment

begin_comment
comment|/* Code modified to prefer proper named type ranges, I32, IV, or UV, instead    of LONG_(MIN/MAX).                            -- Kenneth Albanowski<kjahds@kjahds.com> */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|MY_UV_MAX
value|((UV)IV_MAX * (UV)2 + (UV)1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|I32
name|cast_i32
parameter_list|(
name|f
parameter_list|)
name|double
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|>=
name|I32_MAX
condition|)
return|return
operator|(
name|I32
operator|)
name|I32_MAX
return|;
if|if
condition|(
name|f
operator|<=
name|I32_MIN
condition|)
return|return
operator|(
name|I32
operator|)
name|I32_MIN
return|;
return|return
operator|(
name|I32
operator|)
name|f
return|;
block|}
end_function

begin_function
name|IV
name|cast_iv
parameter_list|(
name|f
parameter_list|)
name|double
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|>=
name|IV_MAX
condition|)
return|return
operator|(
name|IV
operator|)
name|IV_MAX
return|;
if|if
condition|(
name|f
operator|<=
name|IV_MIN
condition|)
return|return
operator|(
name|IV
operator|)
name|IV_MIN
return|;
return|return
operator|(
name|IV
operator|)
name|f
return|;
block|}
end_function

begin_function
name|UV
name|cast_uv
parameter_list|(
name|f
parameter_list|)
name|double
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|>=
name|MY_UV_MAX
condition|)
return|return
operator|(
name|UV
operator|)
name|MY_UV_MAX
return|;
return|return
operator|(
name|UV
operator|)
name|f
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_RENAME
end_ifndef

begin_function
name|I32
name|same_dirent
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|fa
init|=
name|strrchr
argument_list|(
name|a
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fb
init|=
name|strrchr
argument_list|(
name|b
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf1
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf2
decl_stmt|;
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
if|if
condition|(
name|fa
condition|)
name|fa
operator|++
expr_stmt|;
else|else
name|fa
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|fb
condition|)
name|fb
operator|++
expr_stmt|;
else|else
name|fb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fa
operator|==
name|a
condition|)
name|sv_setpv
argument_list|(
name|tmpsv
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|tmpsv
argument_list|,
name|a
argument_list|,
name|fa
operator|-
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|tmpsv
argument_list|)
argument_list|,
operator|&
name|tmpstatbuf1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fb
operator|==
name|b
condition|)
name|sv_setpv
argument_list|(
name|tmpsv
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|tmpsv
argument_list|,
name|b
argument_list|,
name|fb
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|SvPVX
argument_list|(
name|tmpsv
argument_list|)
argument_list|,
operator|&
name|tmpstatbuf2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|tmpstatbuf1
operator|.
name|st_dev
operator|==
name|tmpstatbuf2
operator|.
name|st_dev
operator|&&
name|tmpstatbuf1
operator|.
name|st_ino
operator|==
name|tmpstatbuf2
operator|.
name|st_ino
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_RENAME */
end_comment

begin_function
name|UV
name|scan_oct
parameter_list|(
name|char
modifier|*
name|start
parameter_list|,
name|I32
name|len
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|UV
name|retval
init|=
literal|0
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|len
operator|&&
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
specifier|register
name|UV
name|n
init|=
name|retval
operator|<<
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|overflowed
operator|&&
operator|(
name|n
operator|>>
literal|3
operator|)
operator|!=
name|retval
condition|)
block|{
name|warn
argument_list|(
literal|"Integer overflow in octal number"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
block|}
name|retval
operator|=
name|n
operator||
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|PL_dowarn
operator|&&
name|len
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'8'
operator|||
operator|*
name|s
operator|==
literal|'9'
operator|)
condition|)
name|warn
argument_list|(
literal|"Illegal octal digit ignored"
argument_list|)
expr_stmt|;
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|UV
name|scan_hex
parameter_list|(
name|char
modifier|*
name|start
parameter_list|,
name|I32
name|len
parameter_list|,
name|I32
modifier|*
name|retlen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|UV
name|retval
init|=
literal|0
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|s
decl_stmt|;
specifier|register
name|UV
name|n
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|&&
operator|*
name|s
condition|)
block|{
name|tmp
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_hexdigit
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'_'
operator|||
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'x'
operator|&&
name|retval
operator|==
literal|0
operator|)
condition|)
continue|continue;
else|else
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Illegal hex digit ignored"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|n
operator|=
name|retval
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|overflowed
operator|&&
operator|(
name|n
operator|>>
literal|4
operator|)
operator|!=
name|retval
condition|)
block|{
name|warn
argument_list|(
literal|"Integer overflow in hex number"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
block|}
name|retval
operator|=
name|n
operator||
operator|(
operator|(
name|tmp
operator|-
name|PL_hexdigit
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|find_script
parameter_list|(
name|char
modifier|*
name|scriptname
parameter_list|,
name|bool
name|dosearch
parameter_list|,
name|char
modifier|*
modifier|*
name|search_ext
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|xfound
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|xfailed
init|=
name|Nullch
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|I32
name|len
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|atarist
argument_list|)
define|#
directive|define
name|SEARCH_EXTS
value|".bat", ".cmd", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS2
define|#
directive|define
name|SEARCH_EXTS
value|".cmd", ".btm", ".bat", ".pl", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
define|#
directive|define
name|SEARCH_EXTS
value|".pl", ".com", NULL
define|#
directive|define
name|MAX_EXT_LEN
value|4
endif|#
directive|endif
comment|/* additional extensions to try in each dir if scriptname not found */
ifdef|#
directive|ifdef
name|SEARCH_EXTS
name|char
modifier|*
name|exts
index|[]
init|=
block|{
name|SEARCH_EXTS
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|ext
init|=
name|search_ext
condition|?
name|search_ext
else|:
name|exts
decl_stmt|;
name|int
name|extidx
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|curext
init|=
name|Nullch
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|MAX_EXT_LEN
value|0
endif|#
directive|endif
comment|/*      * If dosearch is true and if scriptname does not contain path      * delimiters, search the PATH for scriptname.      *      * If SEARCH_EXTS is also defined, will look for each      * scriptname{SEARCH_EXTS} whenever scriptname is not found      * while searching the PATH.      *      * Assuming SEARCH_EXTS is C<".foo",".bar",NULL>, PATH search      * proceeds as follows:      *   If DOSISH or VMSISH:      *     + look for ./scriptname{,.foo,.bar}      *     + search the PATH for scriptname{,.foo,.bar}      *      *   If !DOSISH:      *     + look *only* in the PATH for scriptname{,.foo,.bar} (note      *       this will not look in '.' if it's not in the PATH)      */
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
ifdef|#
directive|ifdef
name|ALWAYS_DEFTYPES
name|len
operator|=
name|strlen
argument_list|(
name|scriptname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|==
literal|1
operator|&&
operator|*
name|scriptname
operator|==
literal|'-'
operator|)
operator|&&
name|scriptname
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|int
name|hasdir
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|deftypes
init|=
literal|1
decl_stmt|;
name|bool
name|seen_dot
init|=
literal|1
decl_stmt|;
name|hasdir
operator|=
operator|!
name|dosearch
operator|||
operator|(
name|strpbrk
argument_list|(
name|scriptname
argument_list|,
literal|":[</"
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dosearch
condition|)
block|{
name|int
name|hasdir
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|deftypes
init|=
literal|1
decl_stmt|;
name|bool
name|seen_dot
init|=
literal|1
decl_stmt|;
name|hasdir
operator|=
operator|(
name|strpbrk
argument_list|(
name|scriptname
argument_list|,
literal|":[</"
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The first time through, just add SEARCH_EXTS to whatever we 	 * already have, so we can check for default file types. */
while|while
condition|(
name|deftypes
operator|||
operator|(
operator|!
name|hasdir
operator|&&
name|my_trnlnm
argument_list|(
literal|"DCL$PATH"
argument_list|,
name|tmpbuf
argument_list|,
name|idx
operator|++
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|deftypes
condition|)
block|{
name|deftypes
operator|=
literal|0
expr_stmt|;
operator|*
name|tmpbuf
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|scriptname
argument_list|)
operator|+
name|MAX_EXT_LEN
operator|)
operator|>=
sizeof|sizeof
name|tmpbuf
condition|)
continue|continue;
comment|/* don't search dir with too-long name */
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !VMS */
ifdef|#
directive|ifdef
name|DOSISH
if|if
condition|(
name|strEQ
argument_list|(
name|scriptname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|dosearch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dosearch
condition|)
block|{
comment|/* Look in '.' first. */
name|char
modifier|*
name|cur
init|=
name|scriptname
decl_stmt|;
ifdef|#
directive|ifdef
name|SEARCH_EXTS
if|if
condition|(
operator|(
name|curext
operator|=
name|strrchr
argument_list|(
name|scriptname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
comment|/* possible current ext */
while|while
condition|(
name|ext
index|[
name|i
index|]
condition|)
if|if
condition|(
name|strEQ
argument_list|(
name|ext
index|[
name|i
operator|++
index|]
argument_list|,
name|curext
argument_list|)
condition|)
block|{
name|extidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* already has an ext */
break|break;
block|}
do|do
block|{
endif|#
directive|endif
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Looking for %s\n"
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PerlLIO_stat
argument_list|(
name|cur
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|dosearch
operator|=
literal|0
expr_stmt|;
name|scriptname
operator|=
name|cur
expr_stmt|;
ifdef|#
directive|ifdef
name|SEARCH_EXTS
break|break;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SEARCH_EXTS
if|if
condition|(
name|cur
operator|==
name|scriptname
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|scriptname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|MAX_EXT_LEN
operator|+
literal|1
operator|>=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
condition|)
break|break;
name|cur
operator|=
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|extidx
operator|>=
literal|0
operator|&&
name|ext
index|[
name|extidx
index|]
comment|/* try an extension? */
operator|&&
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|ext
index|[
name|extidx
operator|++
index|]
argument_list|)
condition|)
do|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
name|dosearch
operator|&&
operator|!
name|strchr
argument_list|(
name|scriptname
argument_list|,
literal|'/'
argument_list|)
ifdef|#
directive|ifdef
name|DOSISH
operator|&&
operator|!
name|strchr
argument_list|(
name|scriptname
argument_list|,
literal|'\\'
argument_list|)
endif|#
directive|endif
operator|&&
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
condition|)
block|{
name|bool
name|seen_dot
init|=
literal|0
decl_stmt|;
name|PL_bufend
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|PL_bufend
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|DOSISH
argument_list|)
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|*
name|s
ifdef|#
directive|ifdef
name|atarist
operator|&&
operator|*
name|s
operator|!=
literal|','
endif|#
directive|endif
operator|&&
operator|*
name|s
operator|!=
literal|';'
condition|;
name|len
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|tmpbuf
condition|)
name|tmpbuf
index|[
name|len
index|]
operator|=
operator|*
name|s
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|tmpbuf
condition|)
name|tmpbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
comment|/* ! (atarist || DOSISH) */
name|s
operator|=
name|delimcpy
argument_list|(
name|tmpbuf
argument_list|,
name|tmpbuf
operator|+
sizeof|sizeof
name|tmpbuf
argument_list|,
name|s
argument_list|,
name|PL_bufend
argument_list|,
literal|':'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! (atarist || DOSISH) */
if|if
condition|(
name|s
operator|<
name|PL_bufend
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|scriptname
argument_list|)
operator|+
name|MAX_EXT_LEN
operator|>=
sizeof|sizeof
name|tmpbuf
condition|)
continue|continue;
comment|/* don't search dir with too-long name */
if|if
condition|(
name|len
if|#
directive|if
name|defined
argument_list|(
name|atarist
argument_list|)
operator|||
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|tmpbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\\'
endif|#
directive|endif
condition|)
name|tmpbuf
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|tmpbuf
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|seen_dot
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !VMS */
ifdef|#
directive|ifdef
name|SEARCH_EXTS
name|len
operator|=
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|extidx
operator|>
literal|0
condition|)
comment|/* reset after previous loop */
name|extidx
operator|=
literal|0
expr_stmt|;
do|do
block|{
endif|#
directive|endif
name|DEBUG_p
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Looking for %s\n"
argument_list|,
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PerlLIO_stat
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SEARCH_EXTS
block|}
do|while
condition|(
name|retval
operator|<
literal|0
comment|/* not there */
operator|&&
name|extidx
operator|>=
literal|0
operator|&&
name|ext
index|[
name|extidx
index|]
comment|/* try an extension? */
operator|&&
name|strcpy
argument_list|(
name|tmpbuf
operator|+
name|len
argument_list|,
name|ext
index|[
name|extidx
operator|++
index|]
argument_list|)
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|S_ISREG
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|cando
argument_list|(
name|S_IRUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
ifndef|#
directive|ifndef
name|DOSISH
operator|&&
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|xfound
operator|=
name|tmpbuf
expr_stmt|;
comment|/* bingo! */
break|break;
block|}
if|if
condition|(
operator|!
name|xfailed
condition|)
name|xfailed
operator|=
name|savepv
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DOSISH
if|if
condition|(
operator|!
name|xfound
operator|&&
operator|!
name|seen_dot
operator|&&
operator|!
name|xfailed
operator|&&
operator|(
name|PerlLIO_stat
argument_list|(
name|scriptname
argument_list|,
operator|&
name|PL_statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|PL_statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
endif|#
directive|endif
name|seen_dot
operator|=
literal|1
expr_stmt|;
comment|/* Disable message. */
if|if
condition|(
operator|!
name|xfound
condition|)
block|{
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* do or die? */
name|croak
argument_list|(
literal|"Can't %s %s%s%s"
argument_list|,
operator|(
name|xfailed
condition|?
literal|"execute"
else|:
literal|"find"
operator|)
argument_list|,
operator|(
name|xfailed
condition|?
name|xfailed
else|:
name|scriptname
operator|)
argument_list|,
operator|(
name|xfailed
condition|?
literal|""
else|:
literal|" on PATH"
operator|)
argument_list|,
operator|(
name|xfailed
operator|||
name|seen_dot
operator|)
condition|?
literal|""
else|:
literal|", '.' not in PATH"
argument_list|)
expr_stmt|;
block|}
name|scriptname
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|xfailed
condition|)
name|Safefree
argument_list|(
name|xfailed
argument_list|)
expr_stmt|;
name|scriptname
operator|=
name|xfound
expr_stmt|;
block|}
return|return
operator|(
name|scriptname
condition|?
name|savepv
argument_list|(
name|scriptname
argument_list|)
else|:
name|Nullch
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
ifdef|#
directive|ifdef
name|FAKE_THREADS
comment|/* Very simplistic scheduler for now */
name|void
name|schedule
parameter_list|(
name|void
parameter_list|)
block|{
name|thr
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
block|}
name|void
name|perl_cond_init
parameter_list|(
name|cp
parameter_list|)
name|perl_cond
modifier|*
name|cp
decl_stmt|;
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|perl_cond_signal
parameter_list|(
name|cp
parameter_list|)
name|perl_cond
modifier|*
name|cp
decl_stmt|;
block|{
name|perl_os_thread
name|t
decl_stmt|;
name|perl_cond
name|cond
init|=
operator|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return;
name|t
operator|=
name|cond
operator|->
name|thread
expr_stmt|;
comment|/* Insert t in the runnable queue just ahead of us */
name|t
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|=
name|t
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
literal|0
expr_stmt|;
comment|/* Remove from the wait queue */
operator|*
name|cp
operator|=
name|cond
operator|->
name|next
expr_stmt|;
name|Safefree
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
name|void
name|perl_cond_broadcast
parameter_list|(
name|cp
parameter_list|)
name|perl_cond
modifier|*
name|cp
decl_stmt|;
block|{
name|perl_os_thread
name|t
decl_stmt|;
name|perl_cond
name|cond
decl_stmt|,
name|cond_next
decl_stmt|;
for|for
control|(
name|cond
operator|=
operator|*
name|cp
init|;
name|cond
condition|;
name|cond
operator|=
name|cond_next
control|)
block|{
name|t
operator|=
name|cond
operator|->
name|thread
expr_stmt|;
comment|/* Insert t in the runnable queue just ahead of us */
name|t
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|next_run
operator|=
name|t
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
literal|0
expr_stmt|;
comment|/* Remove from the wait queue */
name|cond_next
operator|=
name|cond
operator|->
name|next
expr_stmt|;
name|Safefree
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|perl_cond_wait
parameter_list|(
name|cp
parameter_list|)
name|perl_cond
modifier|*
name|cp
decl_stmt|;
block|{
name|perl_cond
name|cond
decl_stmt|;
if|if
condition|(
name|thr
operator|->
name|i
operator|.
name|next_run
operator|==
name|thr
condition|)
name|croak
argument_list|(
literal|"panic: perl_cond_wait called by last runnable thread"
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|cond
argument_list|,
literal|1
argument_list|,
expr|struct
name|perl_wait_queue
argument_list|)
expr_stmt|;
name|cond
operator|->
name|thread
operator|=
name|thr
expr_stmt|;
name|cond
operator|->
name|next
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
name|cond
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|wait_queue
operator|=
name|cond
expr_stmt|;
comment|/* Remove ourselves from runnable queue */
name|thr
operator|->
name|i
operator|.
name|next_run
operator|->
name|i
operator|.
name|prev_run
operator|=
name|thr
operator|->
name|i
operator|.
name|prev_run
expr_stmt|;
name|thr
operator|->
name|i
operator|.
name|prev_run
operator|->
name|i
operator|.
name|next_run
operator|=
name|thr
operator|->
name|i
operator|.
name|next_run
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FAKE_THREADS */
ifdef|#
directive|ifdef
name|OLD_PTHREADS_API
name|struct
name|perl_thread
modifier|*
name|getTHR
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|pthread_addr_t
name|t
decl_stmt|;
if|if
condition|(
name|pthread_getspecific
argument_list|(
name|PL_thr_key
argument_list|,
operator|&
name|t
argument_list|)
condition|)
name|croak
argument_list|(
literal|"panic: pthread_getspecific"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|perl_thread
operator|*
operator|)
name|t
return|;
block|}
endif|#
directive|endif
comment|/* OLD_PTHREADS_API */
name|MAGIC
modifier|*
name|condpair_magic
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|condpair_t
modifier|*
name|cp
decl_stmt|;
name|New
argument_list|(
literal|53
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|,
name|condpair_t
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|cp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|cp
operator|->
name|owner_cond
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cond
argument_list|)
expr_stmt|;
name|cp
operator|->
name|owner
operator|=
literal|0
expr_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
condition|)
block|{
comment|/* someone else beat us to initialising it */
name|UNLOCK_SV_MUTEX
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|owner_cond
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|cp
operator|->
name|cond
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_magic
argument_list|(
name|sv
argument_list|,
name|Nullsv
argument_list|,
literal|'m'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
sizeof|sizeof
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
name|DEBUG_S
argument_list|(
argument|WITH_THR(PerlIO_printf(PerlIO_stderr(),
literal|"%p: condpair_magic %p\n"
argument|, thr, sv));
argument_list|)
block|}
block|}
return|return
name|mg
return|;
block|}
comment|/*  * Make a new perl thread structure using t as a prototype. Some of the  * fields for the new thread are copied from the prototype thread, t,  * so t should not be running in perl at the time this function is  * called. The use by ext/Thread/Thread.xs in core perl (where t is the  * thread calling new_struct_thread) clearly satisfies this constraint.  */
name|struct
name|perl_thread
modifier|*
name|new_struct_thread
parameter_list|(
name|struct
name|perl_thread
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|perl_thread
modifier|*
name|thr
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|sv
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
argument_list|)
expr_stmt|;
name|thr
operator|=
operator|(
name|Thread
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|memset
argument_list|(
name|thr
argument_list|,
literal|0xab
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perl_thread
argument_list|)
argument_list|)
expr_stmt|;
name|PL_markstack
operator|=
literal|0
expr_stmt|;
name|PL_scopestack
operator|=
literal|0
expr_stmt|;
name|PL_savestack
operator|=
literal|0
expr_stmt|;
name|PL_retstack
operator|=
literal|0
expr_stmt|;
name|PL_dirty
operator|=
literal|0
expr_stmt|;
name|PL_localizing
operator|=
literal|0
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|,
literal|1
argument_list|,
name|HE
argument_list|)
expr_stmt|;
else|#
directive|else
name|Zero
argument_list|(
name|thr
argument_list|,
literal|1
argument_list|,
expr|struct
name|perl_thread
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|thr
operator|->
name|oursv
operator|=
name|sv
expr_stmt|;
name|init_stacks
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|thr
operator|->
name|cvcache
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|threadsv
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|specific
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|errsv
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thr
operator|->
name|errhv
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|thr
operator|->
name|flags
operator|=
name|THRf_R_JOINABLE
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* top_env needs to be non-zero. It points to an area        in which longjmp() stuff is stored, as C callstack        info there at least is thread specific this has to        be per-thread. Otherwise a 'die' in a thread gives        that thread the C stack of last thread to do an eval {}!        See comments in scope.h            Initialize top entry (as in perl.c for main thread)      */
name|PL_start_env
operator|.
name|je_prev
operator|=
name|NULL
expr_stmt|;
name|PL_start_env
operator|.
name|je_ret
operator|=
operator|-
literal|1
expr_stmt|;
name|PL_start_env
operator|.
name|je_mustcatch
operator|=
name|TRUE
expr_stmt|;
name|PL_top_env
operator|=
operator|&
name|PL_start_env
expr_stmt|;
name|PL_in_eval
operator|=
name|FALSE
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
name|PL_statname
operator|=
name|NEWSV
argument_list|(
literal|66
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_maxscream
operator|=
operator|-
literal|1
expr_stmt|;
name|PL_regcompp
operator|=
name|FUNC_NAME_TO_PTR
argument_list|(
name|pregcomp
argument_list|)
expr_stmt|;
name|PL_regexecp
operator|=
name|FUNC_NAME_TO_PTR
argument_list|(
name|regexec_flags
argument_list|)
expr_stmt|;
name|PL_regindent
operator|=
literal|0
expr_stmt|;
name|PL_reginterp_cnt
operator|=
literal|0
expr_stmt|;
name|PL_lastscream
operator|=
name|Nullsv
expr_stmt|;
name|PL_screamfirst
operator|=
literal|0
expr_stmt|;
name|PL_screamnext
operator|=
literal|0
expr_stmt|;
name|PL_reg_start_tmp
operator|=
literal|0
expr_stmt|;
name|PL_reg_start_tmpl
operator|=
literal|0
expr_stmt|;
comment|/* parent thread's data needs to be locked while we make copy */
name|MUTEX_LOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
name|t
operator|->
name|Tcurcop
expr_stmt|;
comment|/* XXX As good a guess as any? */
name|PL_defstash
operator|=
name|t
operator|->
name|Tdefstash
expr_stmt|;
comment|/* XXX maybe these should */
name|PL_curstash
operator|=
name|t
operator|->
name|Tcurstash
expr_stmt|;
comment|/* always be set to main? */
name|PL_tainted
operator|=
name|t
operator|->
name|Ttainted
expr_stmt|;
name|PL_curpm
operator|=
name|t
operator|->
name|Tcurpm
expr_stmt|;
comment|/* XXX No PMOP ref count */
name|PL_nrs
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Tnrs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|PL_last_in_gv
operator|=
name|Nullgv
expr_stmt|;
name|PL_ofslen
operator|=
name|t
operator|->
name|Tofslen
expr_stmt|;
name|PL_ofs
operator|=
name|savepvn
argument_list|(
name|t
operator|->
name|Tofs
argument_list|,
name|PL_ofslen
argument_list|)
expr_stmt|;
name|PL_defoutgv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|t
operator|->
name|Tdefoutgv
argument_list|)
expr_stmt|;
name|PL_chopset
operator|=
name|t
operator|->
name|Tchopset
expr_stmt|;
name|PL_formtarget
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Tformtarget
argument_list|)
expr_stmt|;
name|PL_bodytarget
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Tbodytarget
argument_list|)
expr_stmt|;
name|PL_toptarget
operator|=
name|newSVsv
argument_list|(
name|t
operator|->
name|Ttoptarget
argument_list|)
expr_stmt|;
comment|/* Initialise all per-thread SVs that the template thread used */
name|svp
operator|=
name|AvARRAY
argument_list|(
name|t
operator|->
name|threadsv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|AvFILLp
argument_list|(
name|t
operator|->
name|threadsv
argument_list|)
condition|;
name|i
operator|++
operator|,
name|svp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVsv
argument_list|(
operator|*
name|svp
argument_list|)
decl_stmt|;
name|av_store
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|i
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_threadsv_names
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"new_struct_thread: copied threadsv %d %p->%p\n"
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
name|thr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|thr
operator|->
name|threadsvp
operator|=
name|AvARRAY
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|)
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|PL_nthreads
operator|++
expr_stmt|;
name|thr
operator|->
name|tid
operator|=
operator|++
name|PL_threadnum
expr_stmt|;
name|thr
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|thr
operator|->
name|prev
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|thr
expr_stmt|;
name|thr
operator|->
name|next
operator|->
name|prev
operator|=
name|thr
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
comment|/* done copying parent's state */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_THREAD_INTERN
name|init_thread_intern
argument_list|(
name|thr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_THREAD_INTERN */
return|return
name|thr
return|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|HUGE_VAL
comment|/*  * This hack is to force load of "huge" support from libm.a  * So it is in perl for (say) POSIX to use.   * Needed for SunOS with Sun's 'acc' for example.  */
name|double
name|Perl_huge
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|HUGE_VAL
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_GLOBAL_STRUCT
name|struct
name|perl_vars
modifier|*
name|Perl_GetVars
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|PL_Vars
return|;
block|}
endif|#
directive|endif
name|char
modifier|*
modifier|*
name|get_op_names
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|op_name
return|;
block|}
name|char
modifier|*
modifier|*
name|get_op_descs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|op_desc
return|;
block|}
name|char
modifier|*
name|get_no_modify
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|no_modify
return|;
block|}
name|U32
modifier|*
name|get_opargs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|opargs
return|;
block|}
name|SV
modifier|*
modifier|*
name|get_specialsv_list
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|PL_specialsv_list
return|;
block|}
name|MGVTBL
modifier|*
name|get_vtbl
parameter_list|(
name|int
name|vtbl_id
parameter_list|)
block|{
name|MGVTBL
modifier|*
name|result
init|=
name|Null
argument_list|(
name|MGVTBL
operator|*
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|vtbl_id
condition|)
block|{
case|case
name|want_vtbl_sv
case|:
name|result
operator|=
operator|&
name|vtbl_sv
expr_stmt|;
break|break;
case|case
name|want_vtbl_env
case|:
name|result
operator|=
operator|&
name|vtbl_env
expr_stmt|;
break|break;
case|case
name|want_vtbl_envelem
case|:
name|result
operator|=
operator|&
name|vtbl_envelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_sig
case|:
name|result
operator|=
operator|&
name|vtbl_sig
expr_stmt|;
break|break;
case|case
name|want_vtbl_sigelem
case|:
name|result
operator|=
operator|&
name|vtbl_sigelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_pack
case|:
name|result
operator|=
operator|&
name|vtbl_pack
expr_stmt|;
break|break;
case|case
name|want_vtbl_packelem
case|:
name|result
operator|=
operator|&
name|vtbl_packelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_dbline
case|:
name|result
operator|=
operator|&
name|vtbl_dbline
expr_stmt|;
break|break;
case|case
name|want_vtbl_isa
case|:
name|result
operator|=
operator|&
name|vtbl_isa
expr_stmt|;
break|break;
case|case
name|want_vtbl_isaelem
case|:
name|result
operator|=
operator|&
name|vtbl_isaelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_arylen
case|:
name|result
operator|=
operator|&
name|vtbl_arylen
expr_stmt|;
break|break;
case|case
name|want_vtbl_glob
case|:
name|result
operator|=
operator|&
name|vtbl_glob
expr_stmt|;
break|break;
case|case
name|want_vtbl_mglob
case|:
name|result
operator|=
operator|&
name|vtbl_mglob
expr_stmt|;
break|break;
case|case
name|want_vtbl_nkeys
case|:
name|result
operator|=
operator|&
name|vtbl_nkeys
expr_stmt|;
break|break;
case|case
name|want_vtbl_taint
case|:
name|result
operator|=
operator|&
name|vtbl_taint
expr_stmt|;
break|break;
case|case
name|want_vtbl_substr
case|:
name|result
operator|=
operator|&
name|vtbl_substr
expr_stmt|;
break|break;
case|case
name|want_vtbl_vec
case|:
name|result
operator|=
operator|&
name|vtbl_vec
expr_stmt|;
break|break;
case|case
name|want_vtbl_pos
case|:
name|result
operator|=
operator|&
name|vtbl_pos
expr_stmt|;
break|break;
case|case
name|want_vtbl_bm
case|:
name|result
operator|=
operator|&
name|vtbl_bm
expr_stmt|;
break|break;
case|case
name|want_vtbl_fm
case|:
name|result
operator|=
operator|&
name|vtbl_fm
expr_stmt|;
break|break;
case|case
name|want_vtbl_uvar
case|:
name|result
operator|=
operator|&
name|vtbl_uvar
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|want_vtbl_mutex
case|:
name|result
operator|=
operator|&
name|vtbl_mutex
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|want_vtbl_defelem
case|:
name|result
operator|=
operator|&
name|vtbl_defelem
expr_stmt|;
break|break;
case|case
name|want_vtbl_regexp
case|:
name|result
operator|=
operator|&
name|vtbl_regexp
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
case|case
name|want_vtbl_collxfrm
case|:
name|result
operator|=
operator|&
name|vtbl_collxfrm
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|want_vtbl_amagic
case|:
name|result
operator|=
operator|&
name|vtbl_amagic
expr_stmt|;
break|break;
case|case
name|want_vtbl_amagicelem
case|:
name|result
operator|=
operator|&
name|vtbl_amagicelem
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

