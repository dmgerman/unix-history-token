begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    op.c  *  *    Copyright (c) 1991-1997, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "You see: Mr. Drogo, he married poor Miss Primula Brandybuck.  She was  * our Mr. Bilbo's first cousin on the mother's side (her mother being the  * youngest of the Old Took's daughters); and Mr. Drogo was his second  * cousin.  So Mr. Frodo is his first *and* second cousin, once removed  * either way, as the saying is, if you follow me."  --the Gaffer  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|CHECKCALL
value|this->*check
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECKCALL
value|*check
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In the following definition, the ", Nullop" is just to make the compiler  * think the expression is of the right type: croak actually does a Siglongjmp.  */
end_comment

begin_define
define|#
directive|define
name|CHECKOP
parameter_list|(
name|type
parameter_list|,
name|o
parameter_list|)
define|\
value|((PL_op_mask&& PL_op_mask[type])					\      ? ( op_free((OP*)o),					\ 	 croak("%s trapped by operation mask", op_desc[type]),	\ 	 Nullop )						\      : (CHECKCALL[type])((OP*)o))
end_define

begin_decl_stmt
specifier|static
name|bool
name|scalar_mod_type
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|,
name|I32
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|I32
name|list_assignment
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_type
name|_
argument_list|(
operator|(
name|I32
name|n
operator|,
name|char
operator|*
name|t
operator|,
name|char
operator|*
name|name
operator|,
name|OP
operator|*
name|kid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|modkids
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|,
name|I32
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|no_fh_allowed
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|scalarboolean
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|too_few_arguments
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|too_many_arguments
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|null
name|_
argument_list|(
operator|(
name|OP
operator|*
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PADOFFSET
name|pad_findlex
name|_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|PADOFFSET
name|newoff
operator|,
name|U32
name|seq
operator|,
name|CV
operator|*
name|startcv
operator|,
name|I32
name|cx_ix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|newDEFSVOP
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OP
modifier|*
name|new_logop
name|_
argument_list|(
operator|(
name|I32
name|type
operator|,
name|I32
name|flags
operator|,
name|OP
operator|*
operator|*
name|firstp
operator|,
name|OP
operator|*
operator|*
name|otherp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|char
modifier|*
name|gv_ename
parameter_list|(
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname3
argument_list|(
name|tmpsv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
return|return
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|PL_na
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|no_fh_allowed
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Missing comma after first argument to %s function"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|too_few_arguments
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Not enough arguments for %s"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|too_many_arguments
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Too many arguments for %s"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|bad_type
parameter_list|(
name|I32
name|n
parameter_list|,
name|char
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|OP
modifier|*
name|kid
parameter_list|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Type of arg %d to %s must be %s (not %s)"
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|name
argument_list|,
name|t
argument_list|,
name|op_desc
index|[
name|kid
operator|->
name|op_type
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assertref
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|int
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_AELEM
operator|&&
name|type
operator|!=
name|OP_HELEM
operator|&&
name|type
operator|!=
name|OP_GELEM
condition|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Can't use subscript on %s"
argument_list|,
name|op_desc
index|[
name|type
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_ENTERSUB
operator|||
name|type
operator|==
name|OP_RV2HV
operator|||
name|type
operator|==
name|OP_PADHV
condition|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|msg
init|=
name|sv_2mortal
argument_list|(
name|newSVpvf
argument_list|(
literal|"(Did you mean $ or @ instead of %c?)\n"
argument_list|,
name|type
operator|==
name|OP_ENTERSUB
condition|?
literal|'&'
else|:
literal|'%'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_in_eval
operator|&
literal|2
condition|)
name|warn
argument_list|(
literal|"%_"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_in_eval
condition|)
name|sv_catsv
argument_list|(
name|GvSV
argument_list|(
name|PL_errgv
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|PerlIO_write
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
name|SvPVX
argument_list|(
name|msg
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* "register" allocation */
end_comment

begin_function
name|PADOFFSET
name|pad_allocmy
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|PADOFFSET
name|off
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|isALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isPRINT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|name
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|toCTRL
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
block|}
name|croak
argument_list|(
literal|"Can't use global %s in \"my\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_dowarn
operator|&&
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|off
operator|>
name|PL_comppad_name_floor
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|999999999
comment|/* var is in open scope */
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"\"my\" variable %s masks earlier declaration in same scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|off
operator|=
name|pad_alloc
argument_list|(
name|OP_PADSV
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|1102
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_in_my_stash
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|!=
literal|'$'
condition|)
name|croak
argument_list|(
literal|"Can't declare class for non-scalar %s in \"my\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SvOBJECT_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_in_my_stash
argument_list|)
expr_stmt|;
name|PL_sv_objcount
operator|++
expr_stmt|;
block|}
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|off
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|double
operator|)
literal|999999999
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Not yet introduced--see newSTATEOP */
if|if
condition|(
operator|!
name|PL_min_intro_pending
condition|)
name|PL_min_intro_pending
operator|=
name|off
expr_stmt|;
name|PL_max_intro_pending
operator|=
name|off
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|off
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|off
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
name|off
index|]
argument_list|)
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_function
name|STATIC
name|PADOFFSET
name|pad_findlex
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|PADOFFSET
name|newoff
parameter_list|,
name|U32
name|seq
parameter_list|,
name|CV
modifier|*
name|startcv
parameter_list|,
name|I32
name|cx_ix
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|I32
name|off
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|int
name|saweval
decl_stmt|;
for|for
control|(
name|cv
operator|=
name|startcv
init|;
name|cv
condition|;
name|cv
operator|=
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
control|)
block|{
name|AV
modifier|*
name|curlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|curlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|curname
decl_stmt|;
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
continue|continue;
name|curname
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|svp
expr_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|curname
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|curname
argument_list|)
init|;
name|off
operator|>
literal|0
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|seq
operator|<=
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|seq
operator|>
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|I32
name|depth
decl_stmt|;
name|AV
modifier|*
name|oldpad
decl_stmt|;
name|SV
modifier|*
name|oldsv
decl_stmt|;
name|depth
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|depth
condition|)
block|{
if|if
condition|(
name|newoff
condition|)
block|{
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
continue|continue;
return|return
literal|0
return|;
comment|/* don't clone from inactive stack frame */
block|}
name|depth
operator|=
literal|1
expr_stmt|;
block|}
name|oldpad
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|curlist
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|oldsv
operator|=
operator|*
name|av_fetch
argument_list|(
name|oldpad
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newoff
condition|)
block|{
comment|/* Not a mere clone operation. */
name|SV
modifier|*
name|namesv
init|=
name|NEWSV
argument_list|(
literal|1103
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|newoff
operator|=
name|pad_alloc
argument_list|(
name|OP_PADSV
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|namesv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|namesv
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|newoff
argument_list|,
name|namesv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|namesv
argument_list|)
operator|=
operator|(
name|double
operator|)
name|PL_curcop
operator|->
name|cop_seq
expr_stmt|;
name|SvIVX
argument_list|(
name|namesv
argument_list|)
operator|=
literal|999999999
expr_stmt|;
comment|/* A ref, intro immediately */
name|SvFAKE_on
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
comment|/* A ref, not a real var */
if|if
condition|(
name|CvANON
argument_list|(
name|PL_compcv
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|PL_compcv
argument_list|)
operator|==
name|SVt_PVFM
condition|)
block|{
comment|/* "It's closures all the way down." */
name|CvCLONE_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|==
name|startcv
condition|)
block|{
if|if
condition|(
name|CvANON
argument_list|(
name|PL_compcv
argument_list|)
condition|)
name|oldsv
operator|=
name|Nullsv
expr_stmt|;
comment|/* no need to keep ref */
block|}
else|else
block|{
name|CV
modifier|*
name|bcv
decl_stmt|;
for|for
control|(
name|bcv
operator|=
name|startcv
init|;
name|bcv
operator|&&
name|bcv
operator|!=
name|cv
operator|&&
operator|!
name|CvCLONE
argument_list|(
name|bcv
argument_list|)
condition|;
name|bcv
operator|=
name|CvOUTSIDE
argument_list|(
name|bcv
argument_list|)
control|)
block|{
if|if
condition|(
name|CvANON
argument_list|(
name|bcv
argument_list|)
condition|)
name|CvCLONE_on
argument_list|(
name|bcv
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|CvUNIQUE
argument_list|(
name|cv
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Variable \"%s\" may be unavailable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|CvUNIQUE
argument_list|(
name|cv
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Variable \"%s\" will not stay shared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|newoff
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|oldsv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newoff
return|;
block|}
block|}
block|}
comment|/* Nothing in current lexical context--try eval's context, if any.      * This is necessary to let the perldb get at lexically scoped variables.      * XXX This will also probably interact badly with eval tree caching.      */
name|saweval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cx_ix
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|cx
operator|->
name|cx_type
condition|)
block|{
default|default:
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|saweval
condition|)
block|{
name|seq
operator|=
name|cxstack
index|[
name|saweval
index|]
operator|.
name|blk_oldcop
operator|->
name|cop_seq
expr_stmt|;
return|return
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|newoff
argument_list|,
name|seq
argument_list|,
name|PL_main_cv
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|CXt_EVAL
case|:
switch|switch
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
condition|)
block|{
case|case
name|OP_ENTEREVAL
case|:
name|saweval
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|OP_REQUIRE
case|:
comment|/* require must have its own scope */
return|return
literal|0
return|;
block|}
break|break;
case|case
name|CXt_SUB
case|:
if|if
condition|(
operator|!
name|saweval
condition|)
return|return
literal|0
return|;
name|cv
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|cv
expr_stmt|;
if|if
condition|(
name|PL_debstash
operator|&&
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|==
name|PL_debstash
condition|)
block|{
comment|/* ignore DB'* scope */
name|saweval
operator|=
name|i
expr_stmt|;
comment|/* so we know where we were called from */
continue|continue;
block|}
name|seq
operator|=
name|cxstack
index|[
name|saweval
index|]
operator|.
name|blk_oldcop
operator|->
name|cop_seq
expr_stmt|;
return|return
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|newoff
argument_list|,
name|seq
argument_list|,
name|cv
argument_list|,
name|i
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|PADOFFSET
name|pad_findmy
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|off
decl_stmt|;
name|I32
name|pendoff
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|U32
name|seq
init|=
name|PL_cop_seqmax
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
comment|/*      * Special case to get lexical (and hence per-thread) @_.      * XXX I need to find out how to tell at parse-time whether use      * of @_ should refer to a lexical (from a sub) or defgv (global      * scope and maybe weird sub-ish things like formats). See      * startsub in perly.y.  It's possible that @_ could be lexical      * (at least from subs) even in non-threaded perl.      */
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"@_"
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* success. (NOT_IN_PAD indicates failure) */
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* The one we're looking for is probably just before comppad_name_fill. */
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|off
operator|>
literal|0
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
operator|!
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|seq
operator|<=
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|seq
operator|>
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
condition|)
return|return
operator|(
name|PADOFFSET
operator|)
name|off
return|;
name|pendoff
operator|=
name|off
expr_stmt|;
comment|/* this pending def. will override import */
block|}
block|}
comment|/* See if it's in a nested scope */
name|off
operator|=
name|pad_findlex
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|seq
argument_list|,
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
name|cxstack_ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
comment|/* If there is a pending local definition, this new alias must die */
if|if
condition|(
name|pendoff
condition|)
name|SvIVX
argument_list|(
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
index|[
name|off
index|]
argument_list|)
operator|=
name|seq
expr_stmt|;
return|return
name|off
return|;
comment|/* pad_findlex returns 0 for failure...*/
block|}
return|return
name|NOT_IN_PAD
return|;
comment|/* ...but we return NOT_IN_PAD for failure */
block|}
end_function

begin_function
name|void
name|pad_leavemy
parameter_list|(
name|I32
name|fill
parameter_list|)
block|{
name|I32
name|off
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_min_intro_pending
operator|&&
name|fill
operator|<
name|PL_min_intro_pending
condition|)
block|{
for|for
control|(
name|off
operator|=
name|PL_max_intro_pending
init|;
name|off
operator|>=
name|PL_min_intro_pending
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
condition|)
name|warn
argument_list|(
literal|"%s never introduced"
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* "Deintroduce" my variables that are leaving with this scope. */
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|off
operator|>
name|fill
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|999999999
condition|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|PL_cop_seqmax
expr_stmt|;
block|}
block|}
end_function

begin_function
name|PADOFFSET
name|pad_alloc
parameter_list|(
name|I32
name|optype
parameter_list|,
name|U32
name|tmptype
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|retval
decl_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|croak
argument_list|(
literal|"panic: pad_alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_pad_reset_pending
condition|)
name|pad_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmptype
operator|&
name|SVs_PADMY
condition|)
block|{
do|do
block|{
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad
argument_list|,
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SvPADBUSY
argument_list|(
name|sv
argument_list|)
condition|)
do|;
comment|/* need a fresh one */
name|retval
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
modifier|*
name|names
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SSize_t
name|names_fill
init|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	     * "foreach" index vars temporarily become aliases to non-"my" 	     * values.  Thus we must skip, not just pad values that are 	     * marked as current pad values, but also those with names. 	     */
if|if
condition|(
operator|++
name|PL_padix
operator|<=
name|names_fill
operator|&&
operator|(
name|sv
operator|=
name|names
index|[
name|PL_padix
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
condition|)
continue|continue;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad
argument_list|,
name|PL_padix
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_PADMY
operator|)
operator|)
condition|)
break|break;
block|}
name|retval
operator|=
name|PL_padix
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|tmptype
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx Pad 0x%lx alloc %ld for %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|,
name|op_name
index|[
name|optype
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%lx alloc %ld for %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|,
name|op_name
index|[
name|optype
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
operator|(
name|PADOFFSET
operator|)
name|retval
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|pad_sv
parameter_list|(
name|PADOFFSET
name|po
parameter_list|)
block|{
name|dTHR
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx Pad 0x%lx sv %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|po
condition|)
name|croak
argument_list|(
literal|"panic: pad_sv po"
argument_list|)
expr_stmt|;
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%lx sv %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|PL_curpad
index|[
name|po
index|]
return|;
comment|/* eventually we'll turn this into a macro */
block|}
end_function

begin_function
name|void
name|pad_free
parameter_list|(
name|PADOFFSET
name|po
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_curpad
condition|)
return|return;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|croak
argument_list|(
literal|"panic: pad_free curpad"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|po
condition|)
name|croak
argument_list|(
literal|"panic: pad_free po"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx Pad 0x%lx free %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%lx free %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|PL_curpad
index|[
name|po
index|]
operator|&&
name|PL_curpad
index|[
name|po
index|]
operator|!=
operator|&
name|PL_sv_undef
condition|)
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|I32
operator|)
name|po
operator|<
name|PL_padix
condition|)
name|PL_padix
operator|=
name|po
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pad_swipe
parameter_list|(
name|PADOFFSET
name|po
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|croak
argument_list|(
literal|"panic: pad_swipe curpad"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|po
condition|)
name|croak
argument_list|(
literal|"panic: pad_swipe po"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx Pad 0x%lx swipe %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%lx swipe %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|,
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|po
index|]
operator|=
name|NEWSV
argument_list|(
literal|1107
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|I32
operator|)
name|po
operator|<
name|PL_padix
condition|)
name|PL_padix
operator|=
name|po
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX pad_reset() is currently disabled because it results in serious bugs.  * It causes pad temp TARGs to be shared between OPs. Since TARGs are pushed  * on the stack by OPs that use them, there are several ways to get an alias  * to  a shared TARG.  Such an alias will change randomly and unpredictably.  * We avoid doing this until we can think of a Better Way.  * GSAR 97-10-29 */
end_comment

begin_function
name|void
name|pad_reset
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_BROKEN_PAD_RESET
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|po
decl_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|croak
argument_list|(
literal|"panic: pad_reset curpad"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx Pad 0x%lx reset\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|thr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%lx reset\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PL_curpad
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|!
name|PL_tainting
condition|)
block|{
comment|/* Can't mix tainted and non-tainted temporaries. */
for|for
control|(
name|po
operator|=
name|AvMAX
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|po
operator|>
name|PL_padix_floor
condition|;
name|po
operator|--
control|)
block|{
if|if
condition|(
name|PL_curpad
index|[
name|po
index|]
operator|&&
operator|!
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
condition|)
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
block|}
name|PL_padix
operator|=
name|PL_padix_floor
expr_stmt|;
block|}
endif|#
directive|endif
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_THREADS
end_ifdef

begin_comment
comment|/* find_threadsv is not reentrant */
end_comment

begin_function
name|PADOFFSET
name|find_threadsv
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|PADOFFSET
name|key
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
comment|/* We currently only handle names of a single character */
name|p
operator|=
name|strchr
argument_list|(
name|PL_threadsv_names
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NOT_IN_PAD
return|;
name|key
operator|=
name|p
operator|-
name|PL_threadsv_names
expr_stmt|;
name|svp
operator|=
name|av_fetch
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|key
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svp
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|av_store
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|key
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|thr
operator|->
name|threadsvp
operator|=
name|AvARRAY
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|)
expr_stmt|;
comment|/* 	 * Some magic variables used to be automagically initialised 	 * in gv_fetchpv. Those which are now per-thread magicals get 	 * initialised here instead. 	 */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'_'
case|:
break|break;
case|case
literal|';'
case|:
name|sv_setpv
argument_list|(
name|sv
argument_list|,
literal|"\034"
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'`'
case|:
case|case
literal|'\''
case|:
name|PL_sawampersand
operator|=
name|TRUE
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
comment|/* XXX %! tied to Errno.pm needs to be added here. 	 * See gv_fetchpv(). */
comment|/* case '!': */
default|default:
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"find_threadsv: new SV %p for $%s%c\n"
argument_list|,
name|sv
argument_list|,
operator|(
operator|*
name|name
operator|<
literal|32
operator|)
condition|?
literal|"^"
else|:
literal|""
argument_list|,
operator|(
operator|*
name|name
operator|<
literal|32
operator|)
condition|?
name|toCTRL
argument_list|(
operator|*
name|name
argument_list|)
else|:
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_THREADS */
end_comment

begin_comment
comment|/* Destructor */
end_comment

begin_function
name|void
name|op_free
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|,
modifier|*
name|nextkid
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_seq
operator|==
operator|(
name|U16
operator|)
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|nextkid
control|)
block|{
name|nextkid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
comment|/* Get before next freeing kid */
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
name|o
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* Was holding old type, if any. */
break|break;
case|case
name|OP_ENTEREVAL
case|:
name|o
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* Was holding hints. */
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|OP_ENTERITER
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_THREADSV
case|:
name|o
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* Was holding index into thr->threadsv AV. */
break|break;
endif|#
directive|endif
comment|/* USE_THREADS */
default|default:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|)
operator|||
operator|(
name|check
index|[
name|o
operator|->
name|op_type
index|]
operator|!=
name|FUNC_NAME_TO_PTR
argument_list|(
name|ck_ftst
argument_list|)
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_GVSV
case|:
case|case
name|OP_GV
case|:
case|case
name|OP_AELEMFAST
case|:
name|SvREFCNT_dec
argument_list|(
name|cGVOPo
operator|->
name|op_gv
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
name|Safefree
argument_list|(
name|cCOPo
operator|->
name|cop_label
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|cCOPo
operator|->
name|cop_filegv
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CONST
case|:
name|SvREFCNT_dec
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_GOTO
case|:
case|case
name|OP_NEXT
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REDO
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
operator|(
name|OPf_SPECIAL
operator||
name|OPf_STACKED
operator||
name|OPf_KIDS
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_TRANS
case|:
name|Safefree
argument_list|(
name|cPVOPo
operator|->
name|op_pv
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SUBST
case|:
name|op_free
argument_list|(
name|cPMOPo
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_PUSHRE
case|:
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
name|ReREFCNT_dec
argument_list|(
name|cPMOPo
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|o
operator|->
name|op_targ
operator|>
literal|0
condition|)
name|pad_free
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|null
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|!=
name|OP_NULL
operator|&&
name|o
operator|->
name|op_type
operator|!=
name|OP_THREADSV
operator|&&
name|o
operator|->
name|op_targ
operator|>
literal|0
condition|)
name|pad_free
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|o
operator|->
name|op_type
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_NULL
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Contextualizers */
end_comment

begin_define
define|#
directive|define
name|LINKLIST
parameter_list|(
name|o
parameter_list|)
value|((o)->op_next ? (o)->op_next : linklist((OP*)o))
end_define

begin_function
name|OP
modifier|*
name|linklist
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_next
condition|)
return|return
name|o
operator|->
name|op_next
return|;
comment|/* establish postfix order */
if|if
condition|(
name|cUNOPo
operator|->
name|op_first
condition|)
block|{
name|o
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|kid
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|kid
operator|->
name|op_sibling
argument_list|)
expr_stmt|;
else|else
name|kid
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
block|}
block|}
else|else
name|o
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
return|return
name|o
operator|->
name|op_next
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|scalarkids
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|scalarboolean
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|o
operator|->
name|op_type
operator|==
name|OP_SASSIGN
operator|&&
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|dTHR
expr_stmt|;
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
if|if
condition|(
name|PL_copline
operator|!=
name|NOLINE
condition|)
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|warn
argument_list|(
literal|"Found = in conditional, should be =="
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|scalar
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
comment|/* assumes no premature commitment */
if|if
condition|(
operator|!
name|o
operator|||
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
return|return
name|o
return|;
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_SCALAR
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_REPEAT
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
name|OPpREPEAT_DOLIST
condition|)
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cBINOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|scalar
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SPLIT
case|:
if|if
condition|(
operator|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|)
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|!
name|kPMOP
operator|->
name|op_pmreplroot
condition|)
name|deprecate
argument_list|(
literal|"implicit split to @_"
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_NULL
case|:
default|default:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
while|while
condition|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|scalarvoid
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|char
modifier|*
name|useless
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
comment|/* assumes no premature commitment */
if|if
condition|(
operator|!
name|o
operator|||
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_LIST
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
return|return
name|o
return|;
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_VOID
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
default|default:
if|if
condition|(
operator|!
operator|(
name|opargs
index|[
name|o
operator|->
name|op_type
index|]
operator|&
name|OA_FOLDCONST
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_REPEAT
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
break|break;
goto|goto
name|func_ops
goto|;
case|case
name|OP_SUBSTR
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|==
literal|4
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_GVSV
case|:
case|case
name|OP_WANTARRAY
case|:
case|case
name|OP_GV
case|:
case|case
name|OP_PADSV
case|:
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
case|case
name|OP_PADANY
case|:
case|case
name|OP_AV2ARYLEN
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFGEN
case|:
case|case
name|OP_SREFGEN
case|:
case|case
name|OP_DEFINED
case|:
case|case
name|OP_HEX
case|:
case|case
name|OP_OCT
case|:
case|case
name|OP_LENGTH
case|:
case|case
name|OP_VEC
case|:
case|case
name|OP_INDEX
case|:
case|case
name|OP_RINDEX
case|:
case|case
name|OP_SPRINTF
case|:
case|case
name|OP_AELEM
case|:
case|case
name|OP_AELEMFAST
case|:
case|case
name|OP_ASLICE
case|:
case|case
name|OP_HELEM
case|:
case|case
name|OP_HSLICE
case|:
case|case
name|OP_UNPACK
case|:
case|case
name|OP_PACK
case|:
case|case
name|OP_JOIN
case|:
case|case
name|OP_LSLICE
case|:
case|case
name|OP_ANONLIST
case|:
case|case
name|OP_ANONHASH
case|:
case|case
name|OP_SORT
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_RANGE
case|:
case|case
name|OP_FLIP
case|:
case|case
name|OP_FLOP
case|:
case|case
name|OP_CALLER
case|:
case|case
name|OP_FILENO
case|:
case|case
name|OP_EOF
case|:
case|case
name|OP_TELL
case|:
case|case
name|OP_GETSOCKNAME
case|:
case|case
name|OP_GETPEERNAME
case|:
case|case
name|OP_READLINK
case|:
case|case
name|OP_TELLDIR
case|:
case|case
name|OP_GETPPID
case|:
case|case
name|OP_GETPGRP
case|:
case|case
name|OP_GETPRIORITY
case|:
case|case
name|OP_TIME
case|:
case|case
name|OP_TMS
case|:
case|case
name|OP_LOCALTIME
case|:
case|case
name|OP_GMTIME
case|:
case|case
name|OP_GHBYNAME
case|:
case|case
name|OP_GHBYADDR
case|:
case|case
name|OP_GHOSTENT
case|:
case|case
name|OP_GNBYNAME
case|:
case|case
name|OP_GNBYADDR
case|:
case|case
name|OP_GNETENT
case|:
case|case
name|OP_GPBYNAME
case|:
case|case
name|OP_GPBYNUMBER
case|:
case|case
name|OP_GPROTOENT
case|:
case|case
name|OP_GSBYNAME
case|:
case|case
name|OP_GSBYPORT
case|:
case|case
name|OP_GSERVENT
case|:
case|case
name|OP_GPWNAM
case|:
case|case
name|OP_GPWUID
case|:
case|case
name|OP_GGRNAM
case|:
case|case
name|OP_GGRGID
case|:
case|case
name|OP_GETLOGIN
case|:
name|func_ops
label|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
condition|)
name|useless
operator|=
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
expr_stmt|;
break|break;
case|case
name|OP_RV2GV
case|:
case|case
name|OP_RV2SV
case|:
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
operator|&&
operator|(
operator|!
name|o
operator|->
name|op_sibling
operator|||
name|o
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_READLINE
operator|)
condition|)
name|useless
operator|=
literal|"a variable"
expr_stmt|;
break|break;
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
argument_list|)
expr_stmt|;
comment|/* for warning below */
break|break;
case|case
name|OP_CONST
case|:
name|sv
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
block|{
name|useless
operator|=
literal|"a constant"
expr_stmt|;
if|if
condition|(
name|SvNIOK
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|==
literal|0.0
operator|||
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|==
literal|1.0
operator|)
condition|)
name|useless
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"di"
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"ds"
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"ig"
argument_list|,
literal|2
argument_list|)
condition|)
name|useless
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* don't execute a constant */
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* don't even remember it */
break|break;
case|case
name|OP_POSTINC
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PREINC
expr_stmt|;
comment|/* pre-increment is faster */
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PREINC
index|]
expr_stmt|;
break|break;
case|case
name|OP_POSTDEC
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PREDEC
expr_stmt|;
comment|/* pre-decrement is faster */
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PREDEC
index|]
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NULL
case|:
if|if
condition|(
name|o
operator|->
name|op_targ
operator|==
name|OP_NEXTSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_DBSTATE
condition|)
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
argument_list|)
expr_stmt|;
comment|/* for warning below */
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_ENTERTRY
case|:
case|case
name|OP_ENTER
case|:
case|case
name|OP_SCALAR
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
case|case
name|OP_LEAVELOOP
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ENTEREVAL
case|:
name|scalarkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REQUIRE
case|:
comment|/* all requires must return a boolean value */
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
case|case
name|OP_SPLIT
case|:
if|if
condition|(
operator|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|)
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|!
name|kPMOP
operator|->
name|op_pmreplroot
condition|)
name|deprecate
argument_list|(
literal|"implicit split to @_"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|useless
operator|&&
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Useless use of %s in void context"
argument_list|,
name|useless
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|listkids
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|list
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
comment|/* assumes no premature commitment */
if|if
condition|(
operator|!
name|o
operator|||
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
return|return
name|o
return|;
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_LIST
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_FLOP
case|:
case|case
name|OP_REPEAT
case|:
name|list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|o
operator|->
name|op_next
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_FLOP
condition|)
block|{
name|list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
return|return
name|gen_constant_list
argument_list|(
name|o
argument_list|)
return|;
block|}
case|case
name|OP_LIST
case|:
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
while|while
condition|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LINESEQ
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REQUIRE
case|:
comment|/* all requires must return a boolean value */
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|scalarseq
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVETRY
condition|)
block|{
name|dTHR
expr_stmt|;
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
block|{
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
block|}
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_PARENS
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_BLOCK_SCOPE
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_PARENS
expr_stmt|;
block|}
else|else
name|o
operator|=
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|modkids
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|mod
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|OP
modifier|*
name|kid
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_UNDEF
case|:
name|PL_modcount
operator|++
expr_stmt|;
return|return
name|o
return|;
case|case
name|OP_CONST
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpCONST_ARYBASE
operator|)
operator|)
condition|)
goto|goto
name|nomod
goto|;
if|if
condition|(
name|PL_eval_start
operator|&&
name|PL_eval_start
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|PL_compiling
operator|.
name|cop_arybase
operator|=
operator|(
name|I32
operator|)
name|SvIV
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|PL_eval_start
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|SAVEI32
argument_list|(
name|PL_compiling
operator|.
name|cop_arybase
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_arybase
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
condition|)
goto|goto
name|nomod
goto|;
else|else
name|croak
argument_list|(
literal|"That use of $[ is unsupported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STUB
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
break|break;
goto|goto
name|nomod
goto|;
case|case
name|OP_ENTERSUB
case|:
if|if
condition|(
operator|(
name|type
operator|==
name|OP_UNDEF
operator|||
name|type
operator|==
name|OP_REFGEN
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
comment|/* entersub => rv2cv */
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|assert
argument_list|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_NULL
argument_list|)
expr_stmt|;
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
comment|/* disable pushmark */
break|break;
block|}
comment|/* FALL THROUGH */
default|default:
name|nomod
label|:
comment|/* grep, foreach, subcalls, refgen */
if|if
condition|(
name|type
operator|==
name|OP_GREPSTART
operator|||
name|type
operator|==
name|OP_ENTERSUB
operator|||
name|type
operator|==
name|OP_REFGEN
condition|)
break|break;
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Can't modify %s in %s"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|,
name|type
condition|?
name|op_desc
index|[
name|type
index|]
else|:
literal|"local"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
case|case
name|OP_PREINC
case|:
case|case
name|OP_PREDEC
case|:
case|case
name|OP_POW
case|:
case|case
name|OP_MULTIPLY
case|:
case|case
name|OP_DIVIDE
case|:
case|case
name|OP_MODULO
case|:
case|case
name|OP_REPEAT
case|:
case|case
name|OP_ADD
case|:
case|case
name|OP_SUBTRACT
case|:
case|case
name|OP_CONCAT
case|:
case|case
name|OP_LEFT_SHIFT
case|:
case|case
name|OP_RIGHT_SHIFT
case|:
case|case
name|OP_BIT_AND
case|:
case|case
name|OP_BIT_XOR
case|:
case|case
name|OP_BIT_OR
case|:
case|case
name|OP_I_MULTIPLY
case|:
case|case
name|OP_I_DIVIDE
case|:
case|case
name|OP_I_MODULO
case|:
case|case
name|OP_I_ADD
case|:
case|case
name|OP_I_SUBTRACT
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
goto|goto
name|nomod
goto|;
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
if|if
condition|(
operator|!
name|type
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
name|croak
argument_list|(
literal|"Can't localize through a reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
block|{
name|PL_modcount
operator|=
literal|10000
expr_stmt|;
return|return
name|o
return|;
comment|/* Treat \(@foo) like ordinary list. */
block|}
comment|/* FALL THROUGH */
case|case
name|OP_RV2GV
case|:
if|if
condition|(
name|scalar_mod_type
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|nomod
goto|;
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_AASSIGN
case|:
case|case
name|OP_ASLICE
case|:
case|case
name|OP_HSLICE
case|:
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
case|case
name|OP_REFGEN
case|:
case|case
name|OP_CHOMP
case|:
name|PL_modcount
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|OP_RV2SV
case|:
if|if
condition|(
operator|!
name|type
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
name|croak
argument_list|(
literal|"Can't localize through a reference"
argument_list|)
expr_stmt|;
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_GV
case|:
case|case
name|OP_AV2ARYLEN
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
case|case
name|OP_SASSIGN
case|:
case|case
name|OP_AELEMFAST
case|:
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
name|PL_modcount
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
return|return
name|o
return|;
comment|/* Treat \(@foo) like ordinary list. */
if|if
condition|(
name|scalar_mod_type
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|nomod
goto|;
comment|/* FALL THROUGH */
case|case
name|OP_PADSV
case|:
name|PL_modcount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|croak
argument_list|(
literal|"Can't localize lexical variable %s"
argument_list|,
name|SvPV
argument_list|(
operator|*
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|o
operator|->
name|op_targ
argument_list|,
literal|4
argument_list|)
argument_list|,
name|PL_na
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|OP_THREADSV
case|:
name|PL_modcount
operator|++
expr_stmt|;
comment|/* XXX ??? */
break|break;
endif|#
directive|endif
comment|/* USE_THREADS */
case|case
name|OP_PUSHMARK
case|:
break|break;
case|case
name|OP_KEYS
case|:
if|if
condition|(
name|type
operator|!=
name|OP_SASSIGN
condition|)
goto|goto
name|nomod
goto|;
goto|goto
name|lvalue_func
goto|;
case|case
name|OP_SUBSTR
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|==
literal|4
condition|)
comment|/* don't allow 4 arg substr as lvalue */
goto|goto
name|nomod
goto|;
comment|/* FALL THROUGH */
case|case
name|OP_POS
case|:
case|case
name|OP_VEC
case|:
name|lvalue_func
label|:
name|pad_free
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|PAD_SV
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
argument_list|)
operator|==
name|SVt_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|mod
argument_list|(
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_sibling
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_AELEM
case|:
case|case
name|OP_HELEM
case|:
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_ENTERSUB
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpDEREF
operator|)
operator|)
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_DEFER
expr_stmt|;
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_ENTER
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|mod
argument_list|(
name|cLISTOPo
operator|->
name|op_last
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
if|if
condition|(
name|o
operator|->
name|op_targ
operator|!=
name|OP_LIST
condition|)
block|{
name|mod
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_AASSIGN
operator|||
name|type
operator|==
name|OP_SASSIGN
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
operator||
name|OPf_REF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_SPECIAL
expr_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|OP_GREPSTART
operator|&&
name|type
operator|!=
name|OP_ENTERSUB
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|scalar_mod_type
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
return|return
name|FALSE
return|;
comment|/* FALL THROUGH */
case|case
name|OP_PREINC
case|:
case|case
name|OP_PREDEC
case|:
case|case
name|OP_POSTINC
case|:
case|case
name|OP_POSTDEC
case|:
case|case
name|OP_I_PREINC
case|:
case|case
name|OP_I_PREDEC
case|:
case|case
name|OP_I_POSTINC
case|:
case|case
name|OP_I_POSTDEC
case|:
case|case
name|OP_POW
case|:
case|case
name|OP_MULTIPLY
case|:
case|case
name|OP_DIVIDE
case|:
case|case
name|OP_MODULO
case|:
case|case
name|OP_REPEAT
case|:
case|case
name|OP_ADD
case|:
case|case
name|OP_SUBTRACT
case|:
case|case
name|OP_I_MULTIPLY
case|:
case|case
name|OP_I_DIVIDE
case|:
case|case
name|OP_I_MODULO
case|:
case|case
name|OP_I_ADD
case|:
case|case
name|OP_I_SUBTRACT
case|:
case|case
name|OP_LEFT_SHIFT
case|:
case|case
name|OP_RIGHT_SHIFT
case|:
case|case
name|OP_BIT_AND
case|:
case|case
name|OP_BIT_XOR
case|:
case|case
name|OP_BIT_OR
case|:
case|case
name|OP_CONCAT
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_TRANS
case|:
case|case
name|OP_READ
case|:
case|case
name|OP_SYSREAD
case|:
case|case
name|OP_RECV
case|:
case|case
name|OP_ANDASSIGN
case|:
comment|/* may work later */
case|case
name|OP_ORASSIGN
case|:
comment|/* may work later */
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|refkids
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|ref
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ref
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_ENTERSUB
case|:
if|if
condition|(
operator|(
name|type
operator|==
name|OP_DEFINED
operator|||
name|type
operator|==
name|OP_LOCK
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
comment|/* entersub => rv2cv */
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|assert
argument_list|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_NULL
argument_list|)
expr_stmt|;
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
comment|/* disable pushmark */
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
block|}
break|break;
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|ref
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RV2SV
case|:
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_PADSV
case|:
if|if
condition|(
name|type
operator|==
name|OP_RV2SV
operator|||
name|type
operator|==
name|OP_RV2AV
operator|||
name|type
operator|==
name|OP_RV2HV
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
operator|(
name|type
operator|==
name|OP_RV2AV
condition|?
name|OPpDEREF_AV
else|:
name|type
operator|==
name|OP_RV2HV
condition|?
name|OPpDEREF_HV
else|:
name|OPpDEREF_SV
operator|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
block|}
break|break;
case|case
name|OP_THREADSV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
comment|/* XXX ??? */
break|break;
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_RV2GV
case|:
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
break|break;
case|case
name|OP_SCALAR
case|:
case|case
name|OP_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_AELEM
case|:
case|case
name|OP_HELEM
case|:
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_RV2SV
operator|||
name|type
operator|==
name|OP_RV2AV
operator|||
name|type
operator|==
name|OP_RV2HV
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
operator|(
name|type
operator|==
name|OP_RV2AV
condition|?
name|OPpDEREF_AV
else|:
name|type
operator|==
name|OP_RV2HV
condition|?
name|OPpDEREF_HV
else|:
name|OPpDEREF_SV
operator|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
block|}
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_ENTER
case|:
case|case
name|OP_LIST
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
name|ref
argument_list|(
name|cLISTOPo
operator|->
name|op_last
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|my
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|I32
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
name|type
operator|=
name|o
operator|->
name|op_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|my
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_UNDEF
condition|)
block|{
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|OP_PADSV
operator|&&
name|type
operator|!=
name|OP_PADAV
operator|&&
name|type
operator|!=
name|OP_PADHV
operator|&&
name|type
operator|!=
name|OP_PUSHMARK
condition|)
block|{
name|yyerror
argument_list|(
name|form
argument_list|(
literal|"Can't declare %s in my"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|sawparens
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_PARENS
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|bind_match
parameter_list|(
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|)
condition|)
block|{
name|char
modifier|*
name|desc
init|=
name|op_desc
index|[
operator|(
name|right
operator|->
name|op_type
operator|==
name|OP_SUBST
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
operator|)
condition|?
name|right
operator|->
name|op_type
else|:
name|OP_MATCH
index|]
decl_stmt|;
name|char
modifier|*
name|sample
init|=
operator|(
operator|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|)
condition|?
literal|"@array"
else|:
literal|"%hash"
operator|)
decl_stmt|;
name|warn
argument_list|(
literal|"Applying %s to %s will act on scalar(%s)"
argument_list|,
name|desc
argument_list|,
name|sample
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|->
name|op_type
operator|==
name|OP_MATCH
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_SUBST
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
condition|)
block|{
name|right
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|!=
name|OP_MATCH
condition|)
name|left
operator|=
name|mod
argument_list|(
name|left
argument_list|,
name|right
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
condition|)
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_NULL
argument_list|,
name|OPf_STACKED
argument_list|,
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|prepend_elem
argument_list|(
name|right
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_NOT
condition|)
return|return
name|newUNOP
argument_list|(
name|OP_NOT
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
return|return
name|o
return|;
block|}
else|else
return|return
name|bind_match
argument_list|(
name|type
argument_list|,
name|left
argument_list|,
name|pmruntime
argument_list|(
name|newPMOP
argument_list|(
name|OP_MATCH
argument_list|,
literal|0
argument_list|)
argument_list|,
name|right
argument_list|,
name|Nullop
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|invert
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|o
return|;
comment|/* XXX need to optimize away NOT NOT here?  Or do we let optimizer do it? */
return|return
name|newUNOP
argument_list|(
name|OP_NOT
argument_list|,
name|OPf_SPECIAL
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|scope
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|||
name|PERLDB_NOOPT
operator|||
name|PL_tainting
condition|)
block|{
name|o
operator|=
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|newOP
argument_list|(
name|OP_ENTER
argument_list|,
literal|0
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LEAVE
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_LEAVE
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
condition|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_SCOPE
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_SCOPE
index|]
expr_stmt|;
name|kid
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
operator|(
operator|(
name|COP
operator|*
operator|)
name|kid
operator|)
operator|->
name|cop_filegv
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_SCOPE
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|void
name|save_hints
parameter_list|(
name|void
parameter_list|)
block|{
name|SAVEI32
argument_list|(
name|PL_hints
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
operator|=
name|newHVhv
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|block_start
parameter_list|(
name|int
name|full
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|retval
init|=
name|PL_savestack_ix
decl_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_floor
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
condition|)
block|{
if|if
condition|(
operator|(
name|PL_comppad_name_fill
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|PL_comppad_name_floor
operator|=
name|PL_comppad_name_fill
expr_stmt|;
else|else
name|PL_comppad_name_floor
operator|=
literal|0
expr_stmt|;
block|}
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_padix_floor
argument_list|)
expr_stmt|;
name|PL_padix_floor
operator|=
name|PL_padix
expr_stmt|;
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|&=
operator|~
name|HINT_BLOCK_SCOPE
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|block_end
parameter_list|(
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|seq
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|needblockscope
init|=
name|PL_hints
operator|&
name|HINT_BLOCK_SCOPE
decl_stmt|;
name|OP
modifier|*
name|retval
init|=
name|scalarseq
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|needblockscope
condition|)
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
comment|/* propagate out */
name|pad_leavemy
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|PL_cop_seqmax
operator|++
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|newDEFSVOP
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|OP
modifier|*
name|o
init|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
return|return
name|o
return|;
else|#
directive|else
return|return
name|newSVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|PL_defgv
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* USE_THREADS */
block|}
end_function

begin_function
name|void
name|newPROG
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_in_eval
condition|)
block|{
name|PL_eval_root
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVEEVAL
argument_list|,
operator|(
operator|(
name|PL_in_eval
operator|&
literal|4
operator|)
condition|?
name|OPf_SPECIAL
else|:
literal|0
operator|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|PL_eval_start
operator|=
name|linklist
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|PL_eval_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return;
name|PL_main_root
operator|=
name|scope
argument_list|(
name|sawparens
argument_list|(
name|scalarvoid
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_main_start
operator|=
name|LINKLIST
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|PL_main_start
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
literal|0
expr_stmt|;
comment|/* Register with debugger */
if|if
condition|(
name|PERLDB_INTER
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|perl_get_cv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|localize
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|lex
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
name|list
argument_list|(
name|o
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
name|PL_bufptr
operator|>
name|PL_oldbufptr
operator|&&
name|PL_bufptr
index|[
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|PL_bufptr
init|;
operator|*
name|s
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"@$%, "
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
name|warn
argument_list|(
literal|"Parens missing around \"%s\" list"
argument_list|,
name|lex
condition|?
literal|"my"
else|:
literal|"local"
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_in_my
operator|=
name|FALSE
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
if|if
condition|(
name|lex
condition|)
return|return
name|my
argument_list|(
name|o
argument_list|)
return|;
else|else
return|return
name|mod
argument_list|(
name|o
argument_list|,
name|OP_NULL
argument_list|)
return|;
comment|/* a bit kludgey */
block|}
end_function

begin_function
name|OP
modifier|*
name|jmaybe
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LIST
condition|)
block|{
name|OP
modifier|*
name|o2
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|o2
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o2
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
else|#
directive|else
name|o2
operator|=
name|newSVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|";"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
argument_list|)
operator|,
endif|#
directive|endif
comment|/* USE_THREADS */
name|o
operator|=
name|convert
argument_list|(
name|OP_JOIN
argument_list|,
literal|0
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|o2
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|fold_constants
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|OP
modifier|*
name|curop
decl_stmt|;
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_OTHERINT
operator|)
operator|&&
operator|(
name|PL_hints
operator|&
name|HINT_INTEGER
operator|)
condition|)
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
operator|=
operator|++
operator|(
name|o
operator|->
name|op_type
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_FOLDCONST
operator|)
condition|)
goto|goto
name|nope
goto|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_SPRINTF
case|:
case|case
name|OP_UCFIRST
case|:
case|case
name|OP_LCFIRST
case|:
case|case
name|OP_UC
case|:
case|case
name|OP_LC
case|:
case|case
name|OP_SLT
case|:
case|case
name|OP_SGT
case|:
case|case
name|OP_SLE
case|:
case|case
name|OP_SGE
case|:
case|case
name|OP_SCMP
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
name|PL_error_count
condition|)
goto|goto
name|nope
goto|;
comment|/* Don't try to run w/ errors */
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
init|;
name|curop
operator|!=
name|o
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|!=
name|OP_CONST
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_LIST
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_SCALAR
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_NULL
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_PUSHMARK
condition|)
block|{
goto|goto
name|nope
goto|;
block|}
block|}
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|PL_op
operator|=
name|curop
expr_stmt|;
name|CALLRUNOPS
argument_list|()
expr_stmt|;
name|sv
operator|=
operator|*
operator|(
name|PL_stack_sp
operator|--
operator|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_targ
operator|&&
name|sv
operator|==
name|PAD_SV
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
condition|)
comment|/* grab pad temp? */
name|pad_swipe
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvTEMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* grab mortal temp? */
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_RV2GV
condition|)
return|return
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
return|;
else|else
block|{
comment|/* try to smush double to int, but don't smush -2.0 to -2 */
if|if
condition|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVf_POK
operator|)
operator|)
operator|==
name|SVf_NOK
operator|&&
name|type
operator|!=
name|OP_NEGATE
condition|)
block|{
name|IV
name|iv
init|=
name|SvIV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
name|iv
operator|==
name|SvNV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSViv
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
name|SvIOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* undo SvIV() damage */
block|}
return|return
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
return|;
block|}
name|nope
label|:
if|if
condition|(
operator|!
operator|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_OTHERINT
operator|)
condition|)
return|return
name|o
return|;
if|if
condition|(
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_INTEGER
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_DIVIDE
operator|||
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
return|return
name|o
return|;
for|for
control|(
name|curop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
init|;
name|curop
condition|;
name|curop
operator|=
name|curop
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
continue|continue;
return|return
name|o
return|;
block|}
if|if
condition|(
name|opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_RETINTEGER
condition|)
continue|continue;
return|return
name|o
return|;
block|}
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
operator|++
operator|(
name|o
operator|->
name|op_type
operator|)
index|]
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|gen_constant_list
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|OP
modifier|*
name|curop
decl_stmt|;
name|I32
name|oldtmps_floor
init|=
name|PL_tmps_floor
decl_stmt|;
name|list
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
return|return
name|o
return|;
comment|/* Don't attempt to run with errors */
name|PL_op
operator|=
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|pp_pushmark
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
name|CALLRUNOPS
argument_list|()
expr_stmt|;
name|PL_op
operator|=
name|curop
expr_stmt|;
name|pp_anonlist
argument_list|(
name|ARGS
argument_list|)
expr_stmt|;
name|PL_tmps_floor
operator|=
name|oldtmps_floor
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|curop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|SvREFCNT_inc
argument_list|(
operator|*
name|PL_stack_sp
operator|--
argument_list|)
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|curop
argument_list|)
expr_stmt|;
name|linklist
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|list
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|convert
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
name|last
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_type
operator|!=
name|OP_LIST
condition|)
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
else|else
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_MARK
operator|)
condition|)
name|null
argument_list|(
name|cLISTOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|=
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|o
return|;
if|if
condition|(
name|cLISTOPo
operator|->
name|op_children
operator|<
literal|7
condition|)
block|{
comment|/* XXX do we really need to do this if we're done appending?? */
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|last
operator|=
name|kid
expr_stmt|;
name|cLISTOPo
operator|->
name|op_last
operator|=
name|last
expr_stmt|;
comment|/* in case check substituted last arg */
block|}
return|return
name|fold_constants
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* List constructors */
end_comment

begin_function
name|OP
modifier|*
name|append_elem
parameter_list|(
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
name|first
return|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|!=
name|type
operator|||
name|type
operator|==
name|OP_LIST
operator|&&
name|first
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
return|return
name|newLISTOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
return|;
if|if
condition|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_last
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
else|else
block|{
name|first
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_first
operator|=
name|last
expr_stmt|;
block|}
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_last
operator|=
name|last
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_children
operator|++
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|append_list
parameter_list|(
name|I32
name|type
parameter_list|,
name|LISTOP
modifier|*
name|first
parameter_list|,
name|LISTOP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|first
return|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|prepend_elem
argument_list|(
name|type
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|first
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|last
argument_list|)
return|;
if|if
condition|(
name|last
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|append_elem
argument_list|(
name|type
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|first
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|last
argument_list|)
return|;
name|first
operator|->
name|op_last
operator|->
name|op_sibling
operator|=
name|last
operator|->
name|op_first
expr_stmt|;
name|first
operator|->
name|op_last
operator|=
name|last
operator|->
name|op_last
expr_stmt|;
name|first
operator|->
name|op_children
operator|+=
name|last
operator|->
name|op_children
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|op_children
condition|)
name|last
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|Safefree
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
operator|(
name|OP
operator|*
operator|)
name|first
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|prepend_elem
parameter_list|(
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
name|first
return|;
if|if
condition|(
name|last
operator|->
name|op_type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
comment|/* already a PUSHMARK there */
name|first
operator|->
name|op_sibling
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|last
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_last
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
block|}
name|first
operator|->
name|op_sibling
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
block|}
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_children
operator|++
expr_stmt|;
return|return
name|last
return|;
block|}
return|return
name|newLISTOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Constructors */
end_comment

begin_function
name|OP
modifier|*
name|newNULLLIST
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|force_list
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_type
operator|!=
name|OP_LIST
condition|)
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newLISTOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
name|LISTOP
modifier|*
name|listop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|listop
argument_list|,
literal|1
argument_list|,
name|LISTOP
argument_list|)
expr_stmt|;
name|listop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|listop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|listop
operator|->
name|op_children
operator|=
operator|(
name|first
operator|!=
literal|0
operator|)
operator|+
operator|(
name|last
operator|!=
literal|0
operator|)
expr_stmt|;
name|listop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|last
operator|&&
name|first
condition|)
name|last
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|first
operator|&&
name|last
condition|)
name|first
operator|=
name|last
expr_stmt|;
elseif|else
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
name|listop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|listop
operator|->
name|op_last
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
name|OP
modifier|*
name|pushop
decl_stmt|;
name|pushop
operator|=
name|newOP
argument_list|(
name|OP_PUSHMARK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushop
operator|->
name|op_sibling
operator|=
name|first
expr_stmt|;
name|listop
operator|->
name|op_first
operator|=
name|pushop
expr_stmt|;
name|listop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|listop
operator|->
name|op_last
operator|=
name|pushop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|listop
operator|->
name|op_children
condition|)
name|listop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
return|return
operator|(
name|OP
operator|*
operator|)
name|listop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|o
argument_list|,
literal|1
argument_list|,
name|OP
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|o
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
operator|+
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newUNOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|)
block|{
name|UNOP
modifier|*
name|unop
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_MARK
condition|)
name|first
operator|=
name|force_list
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|unop
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|unop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|unop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|unop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|unop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|unop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|unop
operator|=
operator|(
name|UNOP
operator|*
operator|)
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|unop
argument_list|)
expr_stmt|;
if|if
condition|(
name|unop
operator|->
name|op_next
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|unop
return|;
return|return
name|fold_constants
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|unop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newBINOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
name|BINOP
modifier|*
name|binop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|binop
argument_list|,
literal|1
argument_list|,
name|BINOP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|binop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|binop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|binop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|last
operator|=
name|first
expr_stmt|;
name|binop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|binop
operator|->
name|op_private
operator|=
literal|2
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
block|}
name|binop
operator|=
operator|(
name|BINOP
operator|*
operator|)
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|binop
argument_list|)
expr_stmt|;
if|if
condition|(
name|binop
operator|->
name|op_next
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|binop
return|;
name|binop
operator|->
name|op_last
operator|=
name|last
operator|=
name|binop
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
return|return
name|fold_constants
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|binop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|pmtrans
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|repl
parameter_list|)
block|{
name|SV
modifier|*
name|tstr
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
decl_stmt|;
name|SV
modifier|*
name|rstr
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|repl
operator|)
operator|->
name|op_sv
decl_stmt|;
name|STRLEN
name|tlen
decl_stmt|;
name|STRLEN
name|rlen
decl_stmt|;
specifier|register
name|U8
modifier|*
name|t
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|tstr
argument_list|,
name|tlen
argument_list|)
decl_stmt|;
specifier|register
name|U8
modifier|*
name|r
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|rstr
argument_list|,
name|rlen
argument_list|)
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|j
decl_stmt|;
name|I32
name|Delete
decl_stmt|;
name|I32
name|complement
decl_stmt|;
name|I32
name|squash
decl_stmt|;
specifier|register
name|short
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
operator|(
name|short
operator|*
operator|)
name|cPVOPo
operator|->
name|op_pv
expr_stmt|;
name|complement
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_COMPLEMENT
expr_stmt|;
name|Delete
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_DELETE
expr_stmt|;
name|squash
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_SQUASH
expr_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|Zero
argument_list|(
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|tbl
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|Delete
condition|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rlen
condition|)
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|tbl
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rlen
operator|&&
operator|!
name|Delete
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
name|rlen
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
operator|!
name|squash
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_COUNTONLY
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|Delete
condition|)
block|{
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
operator|--
name|j
expr_stmt|;
block|}
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
name|r
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|repl
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newPMOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|PMOP
modifier|*
name|pmop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|pmop
argument_list|,
literal|1
argument_list|,
name|PMOP
argument_list|)
expr_stmt|;
name|pmop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|pmop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|pmop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|pmop
operator|->
name|op_private
operator|=
literal|0
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_RE_TAINT
condition|)
name|pmop
operator|->
name|op_pmpermflags
operator||=
name|PMf_RETAINT
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|pmop
operator|->
name|op_pmpermflags
operator||=
name|PMf_LOCALE
expr_stmt|;
name|pmop
operator|->
name|op_pmflags
operator|=
name|pmop
operator|->
name|op_pmpermflags
expr_stmt|;
comment|/* link into pm list */
if|if
condition|(
name|type
operator|!=
name|OP_TRANS
operator|&&
name|PL_curstash
condition|)
block|{
name|pmop
operator|->
name|op_pmnext
operator|=
name|HvPMROOT
argument_list|(
name|PL_curstash
argument_list|)
expr_stmt|;
name|HvPMROOT
argument_list|(
name|PL_curstash
argument_list|)
operator|=
name|pmop
expr_stmt|;
block|}
return|return
operator|(
name|OP
operator|*
operator|)
name|pmop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|pmruntime
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|repl
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|LOGOP
modifier|*
name|rcop
decl_stmt|;
name|I32
name|repl_has_vars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_TRANS
condition|)
return|return
name|pmtrans
argument_list|(
name|o
argument_list|,
name|expr
argument_list|,
name|repl
argument_list|)
return|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|o
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|STRLEN
name|plen
decl_stmt|;
name|SV
modifier|*
name|pat
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|SvPV
argument_list|(
name|pat
argument_list|,
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
operator|&&
name|strEQ
argument_list|(
name|p
argument_list|,
literal|" "
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|pat
argument_list|,
literal|"\\s+"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvPV
argument_list|(
name|pat
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_SKIPWHITE
expr_stmt|;
block|}
name|pm
operator|->
name|op_pmregexp
operator|=
name|CALLREGCOMP
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|plen
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
literal|"\\s+"
argument_list|,
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|)
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_WHITE
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
operator|||
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
operator|(
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|?
name|OP_REGCRESET
else|:
name|OP_REGCMAYBE
operator|)
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|rcop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_type
operator|=
name|OP_REGCOMP
expr_stmt|;
name|rcop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_REGCOMP
index|]
expr_stmt|;
name|rcop
operator|->
name|op_first
operator|=
name|scalar
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_flags
operator||=
operator|(
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|?
operator|(
name|OPf_SPECIAL
operator||
name|OPf_KIDS
operator|)
else|:
name|OPf_KIDS
operator|)
expr_stmt|;
name|rcop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|rcop
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
comment|/* establish postfix order */
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
operator|||
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|)
block|{
name|LINKLIST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_next
operator|=
name|expr
expr_stmt|;
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
block|}
else|else
block|{
name|rcop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
block|}
name|prepend_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|rcop
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repl
condition|)
block|{
name|OP
modifier|*
name|curop
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_EVAL
condition|)
name|curop
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
elseif|else
if|if
condition|(
name|repl
operator|->
name|op_type
operator|==
name|OP_THREADSV
operator|&&
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
name|PL_threadsv_names
index|[
name|repl
operator|->
name|op_targ
index|]
argument_list|)
condition|)
block|{
name|curop
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
elseif|else
if|if
condition|(
name|repl
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|curop
operator|=
name|repl
expr_stmt|;
else|else
block|{
name|OP
modifier|*
name|lastop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|repl
argument_list|)
init|;
name|curop
operator|!=
name|repl
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
name|opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_DANGEROUS
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_THREADSV
condition|)
block|{
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
name|curop
operator|->
name|op_private
argument_list|)
condition|)
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
operator|(
name|GVOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_gv
decl_stmt|;
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
operator|*
name|GvENAME
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
break|break;
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|lastop
operator|&&
name|lastop
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
comment|/*funny deref?*/
break|break;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PADSV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
empty_stmt|;
comment|/* Okay here, dangerous in newASSIGNOP */
else|else
break|break;
block|}
name|lastop
operator|=
name|curop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curop
operator|==
name|repl
operator|&&
operator|!
operator|(
name|repl_has_vars
operator|&&
operator|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|||
name|pm
operator|->
name|op_pmregexp
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
operator|)
operator|)
condition|)
block|{
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_CONST
expr_stmt|;
comment|/* const for long enough */
name|pm
operator|->
name|op_pmpermflags
operator||=
name|PMf_CONST
expr_stmt|;
comment|/* const for long enough */
name|prepend_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
name|repl
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|curop
operator|==
name|repl
operator|&&
operator|!
name|pm
operator|->
name|op_pmregexp
condition|)
block|{
comment|/* Has variables. */
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_MAYBE_CONST
expr_stmt|;
name|pm
operator|->
name|op_pmpermflags
operator||=
name|PMf_MAYBE_CONST
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|1101
argument_list|,
name|rcop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_type
operator|=
name|OP_SUBSTCONT
expr_stmt|;
name|rcop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_SUBSTCONT
index|]
expr_stmt|;
name|rcop
operator|->
name|op_first
operator|=
name|scalar
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|rcop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|rcop
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
comment|/* establish postfix order */
name|rcop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|repl
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
name|pm
operator|->
name|op_pmreplroot
operator|=
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|rcop
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmreplstart
operator|=
name|LINKLIST
argument_list|(
name|rcop
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|OP
operator|*
operator|)
name|pm
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newSVOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SVOP
modifier|*
name|svop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|svop
argument_list|,
literal|1
argument_list|,
name|SVOP
argument_list|)
expr_stmt|;
name|svop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|svop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|svop
operator|->
name|op_sv
operator|=
name|sv
expr_stmt|;
name|svop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|svop
expr_stmt|;
name|svop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|svop
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|svop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|svop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newGVOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|GVOP
modifier|*
name|gvop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|gvop
argument_list|,
literal|1
argument_list|,
name|GVOP
argument_list|)
expr_stmt|;
name|gvop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|gvop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|gvop
operator|->
name|op_gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|gvop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|gvop
expr_stmt|;
name|gvop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|gvop
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|gvop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|gvop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newPVOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|pv
parameter_list|)
block|{
name|PVOP
modifier|*
name|pvop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|pvop
argument_list|,
literal|1
argument_list|,
name|PVOP
argument_list|)
expr_stmt|;
name|pvop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|pvop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|pvop
operator|->
name|op_pv
operator|=
name|pv
expr_stmt|;
name|pvop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|pvop
expr_stmt|;
name|pvop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|pvop
argument_list|)
expr_stmt|;
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|pvop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|pvop
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|package
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|save_hptr
argument_list|(
operator|&
name|PL_curstash
argument_list|)
expr_stmt|;
name|save_item
argument_list|(
name|PL_curstname
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|sv
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
name|name
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|gv_stashpvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|PL_curstname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_setpv
argument_list|(
name|PL_curstname
argument_list|,
literal|"<none>"
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|Nullhv
expr_stmt|;
block|}
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utilize
parameter_list|(
name|int
name|aver
parameter_list|,
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|version
parameter_list|,
name|OP
modifier|*
name|id
parameter_list|,
name|OP
modifier|*
name|arg
parameter_list|)
block|{
name|OP
modifier|*
name|pack
decl_stmt|;
name|OP
modifier|*
name|meth
decl_stmt|;
name|OP
modifier|*
name|rqop
decl_stmt|;
name|OP
modifier|*
name|imop
decl_stmt|;
name|OP
modifier|*
name|veop
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|op_type
operator|!=
name|OP_CONST
condition|)
name|croak
argument_list|(
literal|"Module name must be constant"
argument_list|)
expr_stmt|;
name|veop
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|Nullop
condition|)
block|{
name|SV
modifier|*
name|vesv
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|version
operator|)
operator|->
name|op_sv
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|Nullop
operator|&&
operator|!
name|SvNIOK
argument_list|(
name|vesv
argument_list|)
condition|)
block|{
name|arg
operator|=
name|version
expr_stmt|;
block|}
else|else
block|{
name|OP
modifier|*
name|pack
decl_stmt|;
name|OP
modifier|*
name|meth
decl_stmt|;
if|if
condition|(
name|version
operator|->
name|op_type
operator|!=
name|OP_CONST
operator|||
operator|!
name|SvNIOK
argument_list|(
name|vesv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Version number must be constant number"
argument_list|)
expr_stmt|;
comment|/* Make copy of id so we don't free it twice */
name|pack
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVsv
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fake up a method call to VERSION */
name|meth
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|"VERSION"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|veop
operator|=
name|convert
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
operator||
name|OPf_SPECIAL
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|pack
argument_list|,
name|list
argument_list|(
name|version
argument_list|)
argument_list|)
argument_list|,
name|newUNOP
argument_list|(
name|OP_METHOD
argument_list|,
literal|0
argument_list|,
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fake up an import/unimport */
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|op_type
operator|==
name|OP_STUB
condition|)
name|imop
operator|=
name|arg
expr_stmt|;
comment|/* no import on explicit () */
elseif|else
if|if
condition|(
name|SvNIOK
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|imop
operator|=
name|Nullop
expr_stmt|;
comment|/* use 5.0; */
block|}
else|else
block|{
comment|/* Make copy of id so we don't free it twice */
name|pack
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVsv
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
argument_list|)
expr_stmt|;
name|meth
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|aver
condition|?
name|newSVpv
argument_list|(
literal|"import"
argument_list|,
literal|6
argument_list|)
else|:
name|newSVpv
argument_list|(
literal|"unimport"
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|imop
operator|=
name|convert
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
operator||
name|OPf_SPECIAL
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|pack
argument_list|,
name|list
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|newUNOP
argument_list|(
name|OP_METHOD
argument_list|,
literal|0
argument_list|,
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fake up a require */
name|rqop
operator|=
name|newUNOP
argument_list|(
name|OP_REQUIRE
argument_list|,
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Fake up the BEGIN {}, which does its thing immediately. */
name|newSUB
argument_list|(
name|floor
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|"BEGIN"
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|rqop
argument_list|)
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|veop
argument_list|)
argument_list|)
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|imop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newSLICEOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|subscript
parameter_list|,
name|OP
modifier|*
name|listval
parameter_list|)
block|{
return|return
name|newBINOP
argument_list|(
name|OP_LSLICE
argument_list|,
name|flags
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|subscript
argument_list|)
argument_list|)
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|listval
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|list_assignment
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|o
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_COND_EXPR
condition|)
block|{
name|I32
name|t
init|=
name|list_assignment
argument_list|(
name|cCONDOPo
operator|->
name|op_first
operator|->
name|op_sibling
argument_list|)
decl_stmt|;
name|I32
name|f
init|=
name|list_assignment
argument_list|(
name|cCONDOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|->
name|op_sibling
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|f
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|t
operator|||
name|f
condition|)
name|yyerror
argument_list|(
literal|"Assignment to both a list and a scalar"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LIST
operator|||
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_ASLICE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_HSLICE
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_PADHV
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
return|return
name|FALSE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newASSIGNOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|I32
name|optype
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|optype
condition|)
block|{
if|if
condition|(
name|optype
operator|==
name|OP_ANDASSIGN
operator|||
name|optype
operator|==
name|OP_ORASSIGN
condition|)
block|{
return|return
name|newLOGOP
argument_list|(
name|optype
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|optype
argument_list|)
argument_list|,
name|newUNOP
argument_list|(
name|OP_SASSIGN
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newBINOP
argument_list|(
name|optype
argument_list|,
name|OPf_STACKED
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|optype
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|list_assignment
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|PL_modcount
operator|=
literal|0
expr_stmt|;
name|PL_eval_start
operator|=
name|right
expr_stmt|;
comment|/* Grandfathering $[ assignment here.  Bletch.*/
name|left
operator|=
name|mod
argument_list|(
name|left
argument_list|,
name|OP_AASSIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_start
condition|)
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|op_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
block|}
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_AASSIGN
argument_list|,
name|flags
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|left
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|left
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
condition|)
block|{
name|OP
modifier|*
name|curop
decl_stmt|;
name|OP
modifier|*
name|lastop
init|=
name|o
decl_stmt|;
name|PL_generation
operator|++
expr_stmt|;
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
init|;
name|curop
operator|!=
name|o
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
name|opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_DANGEROUS
condition|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
operator|(
name|GVOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_gv
decl_stmt|;
if|if
condition|(
name|gv
operator|==
name|PL_defgv
operator|||
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PADSV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|svp
index|[
name|curop
operator|->
name|op_targ
index|]
decl_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
comment|/* (SvCUR not used any more) */
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
break|break;
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|lastop
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
comment|/* funny deref? */
break|break;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_pmreplroot
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_pmreplroot
decl_stmt|;
if|if
condition|(
name|gv
operator|==
name|PL_defgv
operator|||
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|lastop
operator|=
name|curop
expr_stmt|;
block|}
if|if
condition|(
name|curop
operator|!=
name|o
condition|)
name|o
operator|->
name|op_private
operator|=
name|OPpASSIGN_COMMON
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|&&
name|right
operator|->
name|op_type
operator|==
name|OP_SPLIT
condition|)
block|{
name|OP
modifier|*
name|tmpop
decl_stmt|;
if|if
condition|(
operator|(
name|tmpop
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_first
operator|)
operator|&&
name|tmpop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|tmpop
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|&&
operator|!
operator|(
name|left
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpASSIGN_COMMON
operator|)
condition|)
block|{
name|tmpop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|left
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|tmpop
operator|->
name|op_type
operator|==
name|OP_GV
operator|&&
operator|!
name|pm
operator|->
name|op_pmreplroot
condition|)
block|{
name|pm
operator|->
name|op_pmreplroot
operator|=
operator|(
name|OP
operator|*
operator|)
operator|(
operator|(
name|GVOP
operator|*
operator|)
name|tmpop
operator|)
operator|->
name|op_gv
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_ONCE
expr_stmt|;
name|tmpop
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
comment|/* to list (nulled) */
name|tmpop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|tmpop
operator|)
operator|->
name|op_first
expr_stmt|;
comment|/* to pushmark */
name|tmpop
operator|->
name|op_sibling
operator|=
name|Nullop
expr_stmt|;
comment|/* don't free split */
name|right
operator|->
name|op_next
operator|=
name|tmpop
operator|->
name|op_next
expr_stmt|;
comment|/* fix starting loc */
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* blow off assign */
name|right
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
comment|/* "I don't know and I don't care." */
return|return
name|right
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PL_modcount
operator|<
literal|10000
operator|&&
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_last
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_last
operator|)
operator|->
name|op_sv
decl_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|PL_modcount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|o
return|;
block|}
if|if
condition|(
operator|!
name|right
condition|)
name|right
operator|=
name|newOP
argument_list|(
name|OP_UNDEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|==
name|OP_READLINE
condition|)
block|{
name|right
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
return|return
name|newBINOP
argument_list|(
name|OP_NULL
argument_list|,
name|flags
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|OP_SASSIGN
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|PL_eval_start
operator|=
name|right
expr_stmt|;
comment|/* Grandfathering $[ assignment here.  Bletch.*/
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_SASSIGN
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|OP_SASSIGN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_start
condition|)
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newSTATEOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|U32
name|seq
init|=
name|intro_my
argument_list|()
decl_stmt|;
specifier|register
name|COP
modifier|*
name|cop
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|cop
argument_list|,
literal|1
argument_list|,
name|COP
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curcop
operator|->
name|cop_line
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|cop
operator|->
name|op_type
operator|=
name|OP_DBSTATE
expr_stmt|;
name|cop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_DBSTATE
index|]
expr_stmt|;
block|}
else|else
block|{
name|cop
operator|->
name|op_type
operator|=
name|OP_NEXTSTATE
expr_stmt|;
name|cop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_NEXTSTATE
index|]
expr_stmt|;
block|}
name|cop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|cop
operator|->
name|op_private
operator|=
literal|0
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NATIVE_HINTS
name|cop
operator|->
name|op_private
operator||=
name|NATIVE_HINTS
expr_stmt|;
endif|#
directive|endif
name|cop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|cop
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|cop
operator|->
name|cop_label
operator|=
name|label
expr_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
block|}
name|cop
operator|->
name|cop_seq
operator|=
name|seq
expr_stmt|;
name|cop
operator|->
name|cop_arybase
operator|=
name|PL_curcop
operator|->
name|cop_arybase
expr_stmt|;
if|if
condition|(
name|PL_copline
operator|==
name|NOLINE
condition|)
name|cop
operator|->
name|cop_line
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
else|else
block|{
name|cop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
block|}
name|cop
operator|->
name|cop_filegv
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
expr_stmt|;
name|cop
operator|->
name|cop_stash
operator|=
name|PL_curstash
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|GvAV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|cop
operator|->
name|cop_line
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
name|SvIOK
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvSTASH
argument_list|(
operator|*
name|svp
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|cop
expr_stmt|;
block|}
block|}
return|return
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|cop
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* "Introduce" my variables to visible status. */
end_comment

begin_function
name|U32
name|intro_my
parameter_list|(
name|void
parameter_list|)
block|{
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|PL_min_intro_pending
condition|)
return|return
name|PL_cop_seqmax
return|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PL_min_intro_pending
init|;
name|i
operator|<=
name|PL_max_intro_pending
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|i
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
name|SvIVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|999999999
expr_stmt|;
comment|/* Don't know scope end yet. */
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|double
operator|)
name|PL_cop_seqmax
expr_stmt|;
block|}
block|}
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_comppad_name_fill
operator|=
name|PL_max_intro_pending
expr_stmt|;
comment|/* Needn't search higher */
return|return
name|PL_cop_seqmax
operator|++
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newLOGOP
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|other
parameter_list|)
block|{
return|return
name|new_logop
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|other
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|new_logop
parameter_list|(
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
modifier|*
name|firstp
parameter_list|,
name|OP
modifier|*
modifier|*
name|otherp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|LOGOP
modifier|*
name|logop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|OP
modifier|*
name|first
init|=
operator|*
name|firstp
decl_stmt|;
name|OP
modifier|*
name|other
init|=
operator|*
name|otherp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_XOR
condition|)
comment|/* Not short circuit, but here by precedence. */
return|return
name|newBINOP
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|first
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|other
argument_list|)
argument_list|)
return|;
name|scalarboolean
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* optimize "!a&& b" to "a || b", and "!a || b" to "a&& b" */
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_NOT
operator|&&
operator|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
operator|||
name|type
operator|==
name|OP_OR
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
condition|)
name|type
operator|=
name|OP_OR
expr_stmt|;
else|else
name|type
operator|=
name|OP_AND
expr_stmt|;
name|o
operator|=
name|first
expr_stmt|;
name|first
operator|=
operator|*
name|firstp
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_next
condition|)
name|first
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
name|cUNOPo
operator|->
name|op_first
operator|=
name|Nullop
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|(
name|first
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
name|warn
argument_list|(
literal|"Probable precedence problem on %s"
argument_list|,
name|op_desc
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|OP_AND
operator|)
operator|==
operator|(
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_sv
argument_list|)
operator|)
condition|)
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
operator|*
name|firstp
operator|=
name|Nullop
expr_stmt|;
return|return
name|other
return|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|other
argument_list|)
expr_stmt|;
operator|*
name|otherp
operator|=
name|Nullop
expr_stmt|;
return|return
name|first
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_WANTARRAY
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
condition|)
name|list
argument_list|(
name|other
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_dowarn
operator|&&
operator|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
name|k1
operator|->
name|op_sibling
decl_stmt|;
name|OPCODE
name|warnop
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|first
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
name|warnop
operator|=
name|k2
operator|->
name|op_type
expr_stmt|;
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
name|warnop
operator|=
name|k1
operator|->
name|op_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|warnop
condition|)
block|{
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|warn
argument_list|(
literal|"Value of %s%s can be \"0\"; test with defined()"
argument_list|,
name|op_desc
index|[
name|warnop
index|]
argument_list|,
operator|(
operator|(
name|warnop
operator|==
name|OP_READLINE
operator|||
name|warnop
operator|==
name|OP_GLOB
operator|)
condition|?
literal|" construct"
else|:
literal|"() operator"
operator|)
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|other
condition|)
return|return
name|first
return|;
if|if
condition|(
name|type
operator|==
name|OP_ANDASSIGN
operator|||
name|type
operator|==
name|OP_ORASSIGN
condition|)
name|other
operator|->
name|op_private
operator||=
name|OPpASSIGN_BACKWARDS
expr_stmt|;
comment|/* other is an OP_SASSIGN */
name|Newz
argument_list|(
literal|1101
argument_list|,
name|logop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|logop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|logop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|logop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|logop
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* establish postfix order */
name|logop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|logop
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|other
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|logop
argument_list|)
expr_stmt|;
name|other
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newCONDOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|trueop
parameter_list|,
name|OP
modifier|*
name|falseop
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|CONDOP
modifier|*
name|condop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|falseop
condition|)
return|return
name|newLOGOP
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|trueop
argument_list|)
return|;
if|if
condition|(
operator|!
name|trueop
condition|)
return|return
name|newLOGOP
argument_list|(
name|OP_OR
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|falseop
argument_list|)
return|;
name|scalarboolean
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
return|return
name|trueop
return|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
return|return
name|falseop
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_WANTARRAY
condition|)
block|{
name|list
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
name|scalar
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|1101
argument_list|,
name|condop
argument_list|,
literal|1
argument_list|,
name|CONDOP
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_type
operator|=
name|OP_COND_EXPR
expr_stmt|;
name|condop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_COND_EXPR
index|]
expr_stmt|;
name|condop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|condop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|condop
operator|->
name|op_true
operator|=
name|LINKLIST
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_false
operator|=
name|LINKLIST
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* establish postfix order */
name|condop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|condop
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|trueop
expr_stmt|;
name|trueop
operator|->
name|op_sibling
operator|=
name|falseop
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|condop
argument_list|)
expr_stmt|;
name|trueop
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
name|falseop
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newRANGE
parameter_list|(
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|CONDOP
modifier|*
name|condop
decl_stmt|;
name|OP
modifier|*
name|flip
decl_stmt|;
name|OP
modifier|*
name|flop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|condop
argument_list|,
literal|1
argument_list|,
name|CONDOP
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_type
operator|=
name|OP_RANGE
expr_stmt|;
name|condop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RANGE
index|]
expr_stmt|;
name|condop
operator|->
name|op_first
operator|=
name|left
expr_stmt|;
name|condop
operator|->
name|op_flags
operator|=
name|OPf_KIDS
expr_stmt|;
name|condop
operator|->
name|op_true
operator|=
name|LINKLIST
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_false
operator|=
name|LINKLIST
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|condop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|left
operator|->
name|op_sibling
operator|=
name|right
expr_stmt|;
name|condop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|condop
expr_stmt|;
name|flip
operator|=
name|newUNOP
argument_list|(
name|OP_FLIP
argument_list|,
name|flags
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|condop
argument_list|)
expr_stmt|;
name|flop
operator|=
name|newUNOP
argument_list|(
name|OP_FLOP
argument_list|,
literal|0
argument_list|,
name|flip
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|flop
argument_list|)
expr_stmt|;
name|linklist
argument_list|(
name|flop
argument_list|)
expr_stmt|;
name|left
operator|->
name|op_next
operator|=
name|flip
expr_stmt|;
name|right
operator|->
name|op_next
operator|=
name|flop
expr_stmt|;
name|condop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|OP_RANGE
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PAD_SV
argument_list|(
name|condop
operator|->
name|op_targ
argument_list|)
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|flip
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|OP_RANGE
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PAD_SV
argument_list|(
name|flip
operator|->
name|op_targ
argument_list|)
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|flip
operator|->
name|op_private
operator|=
name|left
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|OPpFLIP_LINENUM
else|:
literal|0
expr_stmt|;
name|flop
operator|->
name|op_private
operator|=
name|right
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|OPpFLIP_LINENUM
else|:
literal|0
expr_stmt|;
name|flip
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
if|if
condition|(
operator|!
name|flip
operator|->
name|op_private
operator|||
operator|!
name|flop
operator|->
name|op_private
condition|)
name|linklist
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* blow off optimizer unless constant */
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newLOOPOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|I32
name|debuggable
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|OP
modifier|*
name|listop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|int
name|once
init|=
name|block
operator|&&
name|block
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|&&
operator|(
name|block
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
operator|||
name|block
operator|->
name|op_type
operator|==
name|OP_NULL
operator|)
decl_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
if|if
condition|(
name|once
operator|&&
name|expr
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|!
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
return|return
name|block
return|;
comment|/* do {} while 0 does once */
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|expr
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
condition|)
block|{
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|newASSIGNOP
argument_list|(
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
operator|(
name|k1
operator|)
condition|?
name|k1
operator|->
name|op_sibling
else|:
name|NULL
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|listop
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|block
argument_list|,
name|newOP
argument_list|(
name|OP_UNSTACK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|new_logop
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
operator|&
name|expr
argument_list|,
operator|&
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|listop
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|listop
operator|)
operator|->
name|op_last
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|once
operator|&&
name|o
operator|!=
name|listop
condition|)
name|o
operator|->
name|op_next
operator|=
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_other
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|listop
condition|)
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* or do {} while 1 loses outer block */
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|=
name|scope
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* suppress POPBLOCK curpm restoration*/
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newWHILEOP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|I32
name|debuggable
parameter_list|,
name|LOOP
modifier|*
name|loop
parameter_list|,
name|I32
name|whileline
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|,
name|OP
modifier|*
name|cont
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|OP
modifier|*
name|redo
decl_stmt|;
name|OP
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|OP
modifier|*
name|listop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|OP
modifier|*
name|condop
decl_stmt|;
if|if
condition|(
name|expr
operator|&&
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|expr
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
operator|)
condition|)
block|{
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|newASSIGNOP
argument_list|(
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|&&
operator|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
operator|(
name|k1
operator|)
condition|?
name|k1
operator|->
name|op_sibling
else|:
name|NULL
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|block
condition|)
name|block
operator|=
name|newOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont
condition|)
name|next
operator|=
name|LINKLIST
argument_list|(
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|cont
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|cont
argument_list|,
name|newOP
argument_list|(
name|OP_UNSTACK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line_t
operator|)
name|whileline
operator|!=
name|NOLINE
condition|)
block|{
name|PL_copline
operator|=
name|whileline
expr_stmt|;
name|cont
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|cont
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|Nullop
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|listop
operator|=
name|append_list
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|LISTOP
operator|*
operator|)
name|block
argument_list|,
operator|(
name|LISTOP
operator|*
operator|)
name|cont
argument_list|)
expr_stmt|;
name|redo
operator|=
name|LINKLIST
argument_list|(
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|PL_copline
operator|=
name|whileline
expr_stmt|;
name|scalar
argument_list|(
name|listop
argument_list|)
expr_stmt|;
name|o
operator|=
name|new_logop
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
operator|&
name|expr
argument_list|,
operator|&
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|expr
operator|&&
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|!
name|SvTRUE
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* oops, it's a while (0) */
name|op_free
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|loop
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
comment|/* listop already freed by new_logop */
block|}
if|if
condition|(
name|listop
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|listop
operator|)
operator|->
name|op_last
operator|->
name|op_next
operator|=
name|condop
operator|=
operator|(
name|o
operator|==
name|listop
condition|?
name|redo
else|:
name|LINKLIST
argument_list|(
name|o
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|next
operator|=
name|condop
expr_stmt|;
block|}
else|else
name|o
operator|=
name|listop
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
block|{
name|Newz
argument_list|(
literal|1101
argument_list|,
name|loop
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
name|loop
operator|->
name|op_type
operator|=
name|OP_ENTERLOOP
expr_stmt|;
name|loop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_ENTERLOOP
index|]
expr_stmt|;
name|loop
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
name|loop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|loop
expr_stmt|;
block|}
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_LEAVELOOP
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|loop
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|loop
operator|->
name|op_redoop
operator|=
name|redo
expr_stmt|;
name|loop
operator|->
name|op_lastop
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|loop
operator|->
name|op_nextop
operator|=
name|next
expr_stmt|;
else|else
name|loop
operator|->
name|op_nextop
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newFOROP
parameter_list|(
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|line_t
name|forline
parameter_list|,
name|OP
modifier|*
name|sv
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|,
name|OP
modifier|*
name|cont
parameter_list|)
block|{
name|LOOP
modifier|*
name|loop
decl_stmt|;
name|OP
modifier|*
name|wop
decl_stmt|;
name|int
name|padoff
init|=
literal|0
decl_stmt|;
name|I32
name|iterflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sv
condition|)
block|{
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
block|{
comment|/* symbol table variable */
name|sv
operator|->
name|op_type
operator|=
name|OP_RV2GV
expr_stmt|;
name|sv
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2GV
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_PADSV
condition|)
block|{
comment|/* private variable */
name|padoff
operator|=
name|sv
operator|->
name|op_targ
expr_stmt|;
name|op_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Nullop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_THREADSV
condition|)
block|{
comment|/* per-thread variable */
name|padoff
operator|=
name|sv
operator|->
name|op_targ
expr_stmt|;
name|iterflags
operator||=
name|OPf_SPECIAL
expr_stmt|;
name|op_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Nullop
expr_stmt|;
block|}
else|else
name|croak
argument_list|(
literal|"Can't use %s for loop variable"
argument_list|,
name|op_desc
index|[
name|sv
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|padoff
operator|=
name|find_threadsv
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_SPECIAL
expr_stmt|;
else|#
directive|else
name|sv
operator|=
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_PADAV
condition|)
block|{
name|expr
operator|=
name|mod
argument_list|(
name|force_list
argument_list|(
name|scalar
argument_list|(
name|ref
argument_list|(
name|expr
argument_list|,
name|OP_ITER
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_STACKED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
operator|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_FLOP
condition|)
block|{
comment|/* Basically turn for($x..$y) into the same as for($x,$y), but we 	 * set the STACKED flag to indicate that these values are to be 	 * treated as min/max values by 'pp_iterinit'. 	 */
name|UNOP
modifier|*
name|flip
init|=
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|)
operator|->
name|op_first
decl_stmt|;
name|CONDOP
modifier|*
name|range
init|=
operator|(
name|CONDOP
operator|*
operator|)
name|flip
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|left
init|=
name|range
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|right
init|=
name|left
operator|->
name|op_sibling
decl_stmt|;
name|LISTOP
modifier|*
name|listop
decl_stmt|;
name|range
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_KIDS
expr_stmt|;
name|range
operator|->
name|op_first
operator|=
name|Nullop
expr_stmt|;
name|listop
operator|=
operator|(
name|LISTOP
operator|*
operator|)
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|listop
operator|->
name|op_first
operator|->
name|op_next
operator|=
name|range
operator|->
name|op_true
expr_stmt|;
name|left
operator|->
name|op_next
operator|=
name|range
operator|->
name|op_false
expr_stmt|;
name|right
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|listop
expr_stmt|;
name|listop
operator|->
name|op_next
operator|=
name|listop
operator|->
name|op_first
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|OP
operator|*
operator|)
operator|(
name|listop
operator|)
expr_stmt|;
name|null
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_STACKED
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|mod
argument_list|(
name|force_list
argument_list|(
name|expr
argument_list|)
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
block|}
name|loop
operator|=
operator|(
name|LOOP
operator|*
operator|)
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ENTERITER
argument_list|,
name|iterflags
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|expr
argument_list|,
name|scalar
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|loop
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
name|loop
operator|->
name|op_targ
operator|=
name|padoff
expr_stmt|;
name|wop
operator|=
name|newWHILEOP
argument_list|(
name|flags
argument_list|,
literal|1
argument_list|,
name|loop
argument_list|,
name|forline
argument_list|,
name|newOP
argument_list|(
name|OP_ITER
argument_list|,
literal|0
argument_list|)
argument_list|,
name|block
argument_list|,
name|cont
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|forline
expr_stmt|;
return|return
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|label
argument_list|,
name|wop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newLOOPEX
parameter_list|(
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|label
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_GOTO
operator|||
name|label
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
comment|/* "last()" means "last" */
if|if
condition|(
name|label
operator|->
name|op_type
operator|==
name|OP_STUB
operator|&&
operator|(
name|label
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|)
condition|)
name|o
operator|=
name|newOP
argument_list|(
name|type
argument_list|,
name|OPf_SPECIAL
argument_list|)
expr_stmt|;
else|else
block|{
name|o
operator|=
name|newPVOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|savepv
argument_list|(
name|label
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|label
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|label
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
condition|)
name|label
operator|=
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|label
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|type
argument_list|,
name|OPf_STACKED
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|void
name|cv_undef
parameter_list|(
name|CV
modifier|*
name|cv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|MUTEX_DESTROY
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|!
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|&&
name|CvROOT
argument_list|(
name|cv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|||
operator|(
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|&&
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|!=
name|thr
operator|)
condition|)
name|croak
argument_list|(
literal|"Can't undef active subroutine"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't undef active subroutine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CvCLONED
argument_list|(
name|cv
argument_list|)
condition|)
name|op_free
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullop
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|SvPOK_off
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
comment|/* forget prototype */
name|CvFLAGS
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
if|if
condition|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
condition|)
block|{
comment|/* may be during global destruction */
if|if
condition|(
name|SvREFCNT
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|AvFILLp
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|,
name|i
operator|--
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|svp
condition|?
operator|*
name|svp
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
continue|continue;
if|if
condition|(
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
condition|)
name|PL_comppad_name
operator|=
name|Nullav
expr_stmt|;
elseif|else
if|if
condition|(
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
condition|)
block|{
name|PL_comppad
operator|=
name|Nullav
expr_stmt|;
name|PL_curpad
operator|=
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullav
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_CLOSURES
end_ifdef

begin_function
name|STATIC
name|void
name|cv_dump
parameter_list|(
name|cv
parameter_list|)
name|CV
modifier|*
name|cv
decl_stmt|;
block|{
name|CV
modifier|*
name|outside
init|=
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|pad_name
decl_stmt|;
name|AV
modifier|*
name|pad
decl_stmt|;
name|SV
modifier|*
modifier|*
name|pname
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ppad
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\tCV=0x%lx (%s), OUTSIDE=0x%lx (%s)\n"
argument_list|,
name|cv
argument_list|,
operator|(
name|CvANON
argument_list|(
name|cv
argument_list|)
condition|?
literal|"ANON"
else|:
operator|(
name|cv
operator|==
name|PL_main_cv
operator|)
condition|?
literal|"MAIN"
else|:
name|CvUNIQUE
argument_list|(
name|outside
argument_list|)
condition|?
literal|"UNIQUE"
else|:
name|CvGV
argument_list|(
name|cv
argument_list|)
condition|?
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
else|:
literal|"UNDEFINED"
operator|)
argument_list|,
name|outside
argument_list|,
operator|(
operator|!
name|outside
condition|?
literal|"null"
else|:
name|CvANON
argument_list|(
name|outside
argument_list|)
condition|?
literal|"ANON"
else|:
operator|(
name|outside
operator|==
name|PL_main_cv
operator|)
condition|?
literal|"MAIN"
else|:
name|CvUNIQUE
argument_list|(
name|outside
argument_list|)
condition|?
literal|"UNIQUE"
else|:
name|CvGV
argument_list|(
name|outside
argument_list|)
condition|?
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|outside
argument_list|)
argument_list|)
else|:
literal|"UNDEFINED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|padlist
condition|)
return|return;
name|pad_name
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|padlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pad
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|padlist
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pname
operator|=
name|AvARRAY
argument_list|(
name|pad_name
argument_list|)
expr_stmt|;
name|ppad
operator|=
name|AvARRAY
argument_list|(
name|pad
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|AvFILLp
argument_list|(
name|pad_name
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\t%4d. 0x%lx (%s\"%s\" %ld-%ld)\n"
argument_list|,
name|ix
argument_list|,
name|ppad
index|[
name|ix
index|]
argument_list|,
name|SvFAKE
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
condition|?
literal|"FAKE "
else|:
literal|""
argument_list|,
name|SvPVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_CLOSURES */
end_comment

begin_function
name|STATIC
name|CV
modifier|*
name|cv_clone2
parameter_list|(
name|CV
modifier|*
name|proto
parameter_list|,
name|CV
modifier|*
name|outside
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|AV
modifier|*
name|av
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|AV
modifier|*
name|protopadlist
init|=
name|CvPADLIST
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|protopad_name
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|protopadlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|protopad
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|protopadlist
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|pname
init|=
name|AvARRAY
argument_list|(
name|protopad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ppad
init|=
name|AvARRAY
argument_list|(
name|protopad
argument_list|)
decl_stmt|;
name|I32
name|fname
init|=
name|AvFILLp
argument_list|(
name|protopad_name
argument_list|)
decl_stmt|;
name|I32
name|fpad
init|=
name|AvFILLp
argument_list|(
name|protopad
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|assert
argument_list|(
operator|!
name|CvUNIQUE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SvTYPE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|CvCLONED_on
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvANON
argument_list|(
name|proto
argument_list|)
condition|)
name|CvANON_on
argument_list|(
name|cv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|CvFILEGV
argument_list|(
name|cv
argument_list|)
operator|=
name|CvFILEGV
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|CvGV
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|=
name|CvSTASH
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|CvROOT
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|CvSTART
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|outside
condition|)
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|outside
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|proto
argument_list|)
condition|)
name|sv_setpvn
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SvPVX
argument_list|(
name|proto
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|fname
init|;
name|ix
operator|>=
literal|0
condition|;
name|ix
operator|--
control|)
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|ix
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|av_fill
argument_list|(
name|PL_comppad
argument_list|,
name|AvFILLp
argument_list|(
name|protopad
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|av
operator|=
name|newAV
argument_list|()
expr_stmt|;
comment|/* will be @_ */
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|fpad
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
init|=
operator|(
name|ix
operator|<=
name|fname
operator|)
condition|?
name|pname
index|[
name|ix
index|]
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
name|namesv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVX
argument_list|(
name|namesv
argument_list|)
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator|&
name|SVf_FAKE
condition|)
block|{
comment|/* lexical from outside? */
name|I32
name|off
init|=
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|ix
argument_list|,
name|SvIVX
argument_list|(
name|namesv
argument_list|)
argument_list|,
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
argument_list|,
name|cxstack_ix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|off
condition|)
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|SvREFCNT_inc
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|!=
name|ix
condition|)
name|croak
argument_list|(
literal|"panic: cv_clone: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* our own lexical */
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
comment|/* anon code -- we'll come back for it */
name|sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
expr_stmt|;
else|else
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPADBUSY
argument_list|(
name|sv
argument_list|)
condition|)
name|SvPADMY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|sv
expr_stmt|;
block|}
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|sv
expr_stmt|;
block|}
block|}
comment|/* Now that vars are all in place, clone nested closures. */
for|for
control|(
name|ix
operator|=
name|fpad
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
init|=
operator|(
name|ix
operator|<=
name|fname
operator|)
condition|?
name|pname
index|[
name|ix
index|]
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
name|namesv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator|&
name|SVf_FAKE
operator|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|namesv
argument_list|)
operator|==
literal|'&'
operator|&&
name|CvCLONE
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
condition|)
block|{
name|CV
modifier|*
name|kid
init|=
name|cv_clone2
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|ppad
index|[
name|ix
index|]
argument_list|,
name|cv
argument_list|)
decl_stmt|;
name|SvREFCNT_dec
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|CvCLONE_on
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|kid
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_CLOSURES
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Cloned inside:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|outside
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  from:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"   to:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LEAVE
expr_stmt|;
return|return
name|cv
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|cv_clone
parameter_list|(
name|CV
modifier|*
name|proto
parameter_list|)
block|{
return|return
name|cv_clone2
argument_list|(
name|proto
argument_list|,
name|CvOUTSIDE
argument_list|(
name|proto
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|cv_ckproto
parameter_list|(
name|CV
modifier|*
name|cv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|p
operator|!=
operator|!
name|SvPOK
argument_list|(
name|cv
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|&&
name|strNE
argument_list|(
name|p
argument_list|,
name|SvPVX
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|msg
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|SV
modifier|*
name|name
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
name|gv_efullname3
argument_list|(
name|name
operator|=
name|sv_newmortal
argument_list|()
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|msg
argument_list|,
literal|"Prototype mismatch:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|" sub %_"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|" (%s)"
argument_list|,
name|SvPVX
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" vs "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
literal|"(%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%_"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|SV
modifier|*
name|cv_const_sv
parameter_list|(
name|CV
modifier|*
name|cv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cv
operator|||
operator|!
name|SvPOK
argument_list|(
name|cv
argument_list|)
operator|||
name|SvCUR
argument_list|(
name|cv
argument_list|)
condition|)
return|return
name|Nullsv
return|;
return|return
name|op_const_sv
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|,
name|cv
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|op_const_sv
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|,
name|CV
modifier|*
name|cv
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
operator|&&
name|cLISTOPo
operator|->
name|op_first
condition|)
name|o
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
for|for
control|(
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|op_next
control|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|sv
operator|&&
name|o
operator|->
name|op_next
operator|==
name|o
condition|)
return|return
name|sv
return|;
if|if
condition|(
name|type
operator|==
name|OP_NEXTSTATE
operator|||
name|type
operator|==
name|OP_NULL
operator|||
name|type
operator|==
name|OP_PUSHMARK
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUB
operator|||
name|type
operator|==
name|OP_RETURN
condition|)
break|break;
if|if
condition|(
name|sv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|type
operator|==
name|OP_CONST
condition|)
name|sv
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_PADSV
operator|&&
name|cv
condition|)
block|{
name|AV
modifier|*
name|padav
init|=
operator|(
name|AV
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|sv
operator|=
name|padav
condition|?
name|AvARRAY
argument_list|(
name|padav
argument_list|)
index|[
name|o
operator|->
name|op_targ
index|]
else|:
name|Nullsv
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|(
operator|!
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|>
literal|1
operator|)
condition|)
return|return
name|Nullsv
return|;
block|}
else|else
return|return
name|Nullsv
return|;
block|}
if|if
condition|(
name|sv
condition|)
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|newSUB
parameter_list|(
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|name
init|=
name|o
condition|?
name|SvPVx
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
else|:
name|Nullch
decl_stmt|;
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
condition|?
name|name
else|:
literal|"__ANON__"
argument_list|,
name|GV_ADDMULTI
operator||
operator|(
name|block
condition|?
literal|0
else|:
name|GV_NOINIT
operator|)
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ps
init|=
name|proto
condition|?
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|proto
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
else|:
name|Nullch
decl_stmt|;
specifier|register
name|CV
modifier|*
name|cv
init|=
literal|0
decl_stmt|;
name|I32
name|ix
decl_stmt|;
if|if
condition|(
name|o
condition|)
name|SAVEFREEOP
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|SAVEFREEOP
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
comment|/* Prototype now, and had 					   maximum a prototype before. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|>
name|SVt_NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|&&
operator|!
operator|(
name|SvIOK
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|&&
name|SvIVX
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|warn
argument_list|(
literal|"Runaway prototype"
argument_list|)
expr_stmt|;
name|cv_ckproto
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|gv
argument_list|,
name|NULL
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
name|sv_setpv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
else|else
name|sv_setiv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|PL_compcv
operator|=
name|NULL
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
goto|goto
name|noblock
goto|;
block|}
if|if
condition|(
operator|!
name|name
operator|||
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
name|cv
operator|=
name|Nullcv
expr_stmt|;
elseif|else
if|if
condition|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|cv_ckproto
argument_list|(
name|cv
argument_list|,
name|gv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
comment|/* already defined (or promised)? */
if|if
condition|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|||
name|GvASSUMECV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|const_sv
decl_stmt|;
name|bool
name|const_changed
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|block
condition|)
block|{
comment|/* just a "sub foo;" when&foo is already defined */
name|SAVEFREESV
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* ahem, death to those who redefine active sort subs */
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|cv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_sv
operator|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
condition|)
name|const_changed
operator|=
name|sv_cmp
argument_list|(
name|const_sv
argument_list|,
name|op_const_sv
argument_list|(
name|block
argument_list|,
name|Nullcv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|const_sv
operator|&&
name|const_changed
operator|)
operator|||
name|PL_dowarn
operator|&&
operator|!
operator|(
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|&&
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"autouse"
argument_list|)
operator|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|warn
argument_list|(
name|const_sv
condition|?
literal|"Constant subroutine %s redefined"
else|:
literal|"Subroutine %s redefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|Nullcv
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cv
condition|)
block|{
comment|/* must reuse cv if autoloaded */
name|cv_undef
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|cv
argument_list|)
operator|=
name|CvFLAGS
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|PL_compcv
argument_list|)
operator|>
literal|1
condition|)
comment|/* XXX Make closures transit through stub. */
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cv
operator|=
name|PL_compcv
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
block|}
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|CvFILEGV
argument_list|(
name|cv
argument_list|)
operator|=
name|PL_curcop
operator|->
name|cop_filegv
expr_stmt|;
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|=
name|PL_curstash
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
condition|)
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|ps
condition|)
name|sv_setpv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
block|{
name|op_free
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|block
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
condition|?
name|s
operator|+
literal|1
else|:
name|name
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|not_safe
init|=
literal|"BEGIN not safe after errors--compilation aborted"
decl_stmt|;
if|if
condition|(
name|PL_in_eval
operator|&
literal|4
condition|)
name|croak
argument_list|(
name|not_safe
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* force display of errors found but not reported */
name|sv_catpv
argument_list|(
name|ERRSV
argument_list|,
name|not_safe
argument_list|)
expr_stmt|;
name|croak
argument_list|(
literal|"%s"
argument_list|,
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|PL_na
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
name|noblock
label|:
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
if|if
condition|(
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|<
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
condition|)
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|namep
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
decl_stmt|;
if|if
condition|(
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
continue|continue;
comment|/* 	     * The only things that a clonable function needs in its 	     * pad are references to outer lexicals and anonymous subs. 	     * The rest are created anew during cloning. 	     */
if|if
condition|(
operator|!
operator|(
operator|(
name|namesv
operator|=
name|namep
index|[
name|ix
index|]
operator|)
operator|!=
name|Nullsv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|SvFAKE
argument_list|(
name|namesv
argument_list|)
operator|||
operator|*
name|SvPVX
argument_list|(
name|namesv
argument_list|)
operator|==
literal|'&'
operator|)
operator|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|Nullsv
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|AV
modifier|*
name|av
init|=
name|newAV
argument_list|()
decl_stmt|;
comment|/* Will be @_ */
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SvPADMY
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVESUB
argument_list|,
literal|0
argument_list|,
name|scalarseq
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|LINKLIST
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|PERLDB_SUBLINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|tmpstr
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|GV
modifier|*
name|db_postponed
init|=
name|gv_fetchpv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|sv_setpvf
argument_list|(
name|sv
argument_list|,
literal|"%_:%ld-%ld"
argument_list|,
name|GvSV
argument_list|(
name|PL_curcop
operator|->
name|cop_filegv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PL_subline
argument_list|,
operator|(
name|long
operator|)
name|PL_curcop
operator|->
name|cop_line
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|hv_store
argument_list|(
name|GvHV
argument_list|(
name|PL_DBsub
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hv
operator|=
name|GvHVn
argument_list|(
name|db_postponed
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvFILL
argument_list|(
name|hv
argument_list|)
operator|>
literal|0
operator|&&
name|hv_exists
argument_list|(
name|hv
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
operator|&&
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|db_postponed
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
name|I32
name|oldscope
init|=
name|PL_scopestack_ix
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_filegv
argument_list|)
expr_stmt|;
name|SAVEI16
argument_list|(
name|PL_compiling
operator|.
name|cop_line
argument_list|)
expr_stmt|;
name|save_svref
argument_list|(
operator|&
name|PL_rs
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|PL_rs
argument_list|,
name|PL_nrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_beginav
condition|)
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_sub
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|PL_beginav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_beginav
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"END"
argument_list|)
operator|&&
operator|!
name|PL_error_count
condition|)
block|{
if|if
condition|(
operator|!
name|PL_endav
condition|)
name|PL_endav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_unshift
argument_list|(
name|PL_endav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_endav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"INIT"
argument_list|)
operator|&&
operator|!
name|PL_error_count
condition|)
block|{
if|if
condition|(
operator|!
name|PL_initav
condition|)
name|PL_initav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_initav
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|done
label|:
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
end_function

begin_function
name|void
name|newCONSTSUB
parameter_list|(
name|HV
modifier|*
name|stash
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|U32
name|oldhints
init|=
name|PL_hints
decl_stmt|;
name|HV
modifier|*
name|old_cop_stash
init|=
name|PL_curcop
operator|->
name|cop_stash
decl_stmt|;
name|HV
modifier|*
name|old_curstash
init|=
name|PL_curstash
decl_stmt|;
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|PL_hints
operator|&=
operator|~
name|HINT_BLOCK_SCOPE
expr_stmt|;
if|if
condition|(
name|stash
condition|)
name|PL_curstash
operator|=
name|PL_curcop
operator|->
name|cop_stash
operator|=
name|stash
expr_stmt|;
name|newSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_sv_no
argument_list|)
argument_list|,
comment|/* SvPV(&PL_sv_no) == "" -- GMB */
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_hints
operator|=
name|oldhints
expr_stmt|;
name|PL_curcop
operator|->
name|cop_stash
operator|=
name|old_cop_stash
expr_stmt|;
name|PL_curstash
operator|=
name|old_curstash
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
end_function

begin_function
name|CV
modifier|*
name|newXS
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
function_decl|(
modifier|*
name|subaddr
function_decl|)
parameter_list|(
name|CV
modifier|*
name|_CPERLproto
parameter_list|)
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
condition|?
name|name
else|:
literal|"__ANON__"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|cv
operator|=
operator|(
name|name
condition|?
name|GvCV
argument_list|(
name|gv
argument_list|)
else|:
name|Nullcv
operator|)
condition|)
block|{
if|if
condition|(
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
block|{
comment|/* just a cached method */
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|||
name|GvASSUMECV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
comment|/* already defined (or promised) */
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|&&
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"autouse"
argument_list|)
operator|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|warn
argument_list|(
literal|"Subroutine %s redefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cv
condition|)
comment|/* must reuse cv if autoloaded */
name|cv_undef
argument_list|(
name|cv
argument_list|)
expr_stmt|;
else|else
block|{
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1105
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
block|}
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|CvFILEGV
argument_list|(
name|cv
argument_list|)
operator|=
name|gv_fetchfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|=
name|subaddr
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_beginav
condition|)
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_beginav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"END"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_endav
condition|)
name|PL_endav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_unshift
argument_list|(
name|PL_endav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_endav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"INIT"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_initav
condition|)
name|PL_initav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_initav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|CvANON_on
argument_list|(
name|cv
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
end_function

begin_function
name|void
name|newFORM
parameter_list|(
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|I32
name|ix
decl_stmt|;
if|if
condition|(
name|o
condition|)
name|name
operator|=
name|SvPVx
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|"STDOUT"
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVFM
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|=
name|GvFORM
argument_list|(
name|gv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
condition|)
block|{
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|PL_copline
expr_stmt|;
name|warn
argument_list|(
literal|"Format %s redefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
name|cv
operator|=
name|PL_compcv
expr_stmt|;
name|GvFORM
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|CvFILEGV
argument_list|(
name|cv
argument_list|)
operator|=
name|PL_curcop
operator|->
name|cop_filegv
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|SvPADMY
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|&&
operator|!
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVEWRITE
argument_list|,
literal|0
argument_list|,
name|scalarseq
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|LINKLIST
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newANONLIST
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ANONLIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newANONHASH
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ANONHASH
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newANONSUB
parameter_list|(
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|newSVOP
argument_list|(
name|OP_ANONCODE
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newSUB
argument_list|(
name|floor
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|,
name|block
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|oopsAV
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_PADSV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PADAV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PADAV
index|]
expr_stmt|;
return|return
name|ref
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_RV2AV
argument_list|)
return|;
case|case
name|OP_RV2SV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2AV
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"oops: oopsAV"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|oopsHV
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_PADSV
case|:
case|case
name|OP_PADAV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PADHV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PADHV
index|]
expr_stmt|;
return|return
name|ref
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2HV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_RV2HV
argument_list|)
return|;
case|case
name|OP_RV2SV
case|:
case|case
name|OP_RV2AV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_RV2HV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2HV
index|]
expr_stmt|;
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2HV
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"oops: oopsHV"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newAVREF
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADAV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PADAV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newGVREF
parameter_list|(
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_MAPSTART
condition|)
return|return
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
return|;
return|return
name|ref
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
name|OPf_REF
argument_list|,
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newHVREF
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADHV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PADHV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2HV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|oopsCV
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|croak
argument_list|(
literal|"NOT IMPL LINE %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* STUB */
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newCVREF
parameter_list|(
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|newSVREF
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADSV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PADSV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_THREADSV
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPpDONE_SVREF
operator|)
condition|)
block|{
name|o
operator|->
name|op_flags
operator||=
name|OPpDONE_SVREF
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2SV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check routines. */
end_comment

begin_function
name|OP
modifier|*
name|ck_anoncode
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|PADOFFSET
name|ix
decl_stmt|;
name|SV
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|NEWSV
argument_list|(
literal|1106
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|name
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|name
argument_list|,
literal|"&"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|name
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|SvNVX
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ix
operator|=
name|pad_alloc
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|ix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|ix
argument_list|,
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
name|cSVOPo
operator|->
name|op_targ
operator|=
name|ix
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_bitop
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator|=
name|PL_hints
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_concat
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_CONCAT
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_spair
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|newop
decl_stmt|;
name|OP
modifier|*
name|kid
decl_stmt|;
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
name|o
operator|=
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
name|newop
operator|=
name|kUNOP
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|newop
operator|&&
operator|(
name|newop
operator|->
name|op_sibling
operator|||
operator|!
operator|(
name|opargs
index|[
name|newop
operator|->
name|op_type
index|]
operator|&
name|OA_RETSCALAR
operator|)
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|)
condition|)
block|{
return|return
name|o
return|;
block|}
name|op_free
argument_list|(
name|kUNOP
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|kUNOP
operator|->
name|op_first
operator|=
name|newop
expr_stmt|;
block|}
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
operator|++
name|o
operator|->
name|op_type
index|]
expr_stmt|;
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_delete
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_HSLICE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpSLICE
expr_stmt|;
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_HELEM
condition|)
name|croak
argument_list|(
literal|"%s argument is not a HASH element or slice"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_eof
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
if|if
condition|(
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_STUB
condition|)
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|type
argument_list|,
name|OPf_SPECIAL
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"main::ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_eval
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_KIDS
expr_stmt|;
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_LINESEQ
condition|)
block|{
name|LOGOP
modifier|*
name|enter
decl_stmt|;
name|kid
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
name|cUNOPo
operator|->
name|op_first
operator|=
literal|0
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|enter
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|enter
operator|->
name|op_type
operator|=
name|OP_ENTERTRY
expr_stmt|;
name|enter
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_ENTERTRY
index|]
expr_stmt|;
name|enter
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
comment|/* establish postfix order */
name|enter
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|enter
expr_stmt|;
name|o
operator|=
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|enter
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|kid
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LEAVETRY
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_LEAVETRY
index|]
expr_stmt|;
name|enter
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
else|else
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_ENTEREVAL
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|op_targ
operator|=
operator|(
name|PADOFFSET
operator|)
name|PL_hints
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_exec
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
name|o
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_exists
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_HELEM
condition|)
name|croak
argument_list|(
literal|"%s argument is not a HASH element"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_gvconst
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|fold_constants
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|o
operator|->
name|op_type
operator|=
name|OP_GV
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_rvconst
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|iscv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|name
operator|=
name|SvPV
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|badthing
init|=
name|Nullch
decl_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_RV2SV
case|:
name|badthing
operator|=
literal|"a SCALAR"
expr_stmt|;
break|break;
case|case
name|OP_RV2AV
case|:
name|badthing
operator|=
literal|"an ARRAY"
expr_stmt|;
break|break;
case|case
name|OP_RV2HV
case|:
name|badthing
operator|=
literal|"a HASH"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|badthing
condition|)
name|croak
argument_list|(
literal|"Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use"
argument_list|,
name|name
argument_list|,
name|badthing
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This is a little tricky.  We only want to add the symbol if we 	 * didn't add it in the lexer.  Otherwise we get duplicate strict 	 * warnings.  But if we didn't add it in the lexer, we must at 	 * least pretend like we wanted to add it even if it existed before, 	 * or we get possible typo warnings.  OPpCONST_ENTERED says 	 * whether the lexer already added THIS instance of this symbol. 	 */
name|iscv
operator|=
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2CV
operator|)
operator|*
literal|2
expr_stmt|;
do|do
block|{
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|iscv
operator||
operator|!
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_ENTERED
operator|)
argument_list|,
name|iscv
condition|?
name|SVt_PVCV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|?
name|SVt_PV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2AV
condition|?
name|SVt_PVAV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2HV
condition|?
name|SVt_PVHV
else|:
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|gv
operator|&&
operator|!
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_ENTERED
operator|)
operator|&&
operator|!
name|iscv
operator|++
condition|)
do|;
if|if
condition|(
name|gv
condition|)
block|{
name|kid
operator|->
name|op_type
operator|=
name|OP_GV
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_ftst
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
return|return
name|o
return|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_STUB
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|OP
modifier|*
name|newop
init|=
name|newGVOP
argument_list|(
name|type
argument_list|,
name|OPf_REF
argument_list|,
name|gv_fetchpv
argument_list|(
name|SvPVx
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|newop
return|;
block|}
block|}
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_FTTTY
condition|)
return|return
name|newGVOP
argument_list|(
name|type
argument_list|,
name|OPf_REF
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"main::STDIN"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
return|;
else|else
return|return
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_fun
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
modifier|*
name|tokid
decl_stmt|;
name|OP
modifier|*
name|sibl
decl_stmt|;
name|I32
name|numargs
init|=
literal|0
decl_stmt|;
name|int
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
specifier|register
name|I32
name|oa
init|=
name|opargs
index|[
name|type
index|]
operator|>>
name|OASHIFT
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
if|if
condition|(
operator|(
name|oa
operator|&
name|OA_OPTIONAL
operator|)
operator|&&
operator|(
name|oa
operator|>>
literal|4
operator|)
operator|&&
operator|!
operator|(
operator|(
name|oa
operator|>>
literal|4
operator|)
operator|&
name|OA_OPTIONAL
operator|)
condition|)
name|oa
operator|&=
operator|~
name|OA_OPTIONAL
expr_stmt|;
else|else
return|return
name|no_fh_allowed
argument_list|(
name|o
argument_list|)
return|;
block|}
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|tokid
operator|=
operator|&
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHMARK
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|kid
operator|->
name|op_targ
operator|==
name|OP_PUSHMARK
condition|)
block|{
name|tokid
operator|=
operator|&
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kid
operator|&&
name|opargs
index|[
name|type
index|]
operator|&
name|OA_DEFGV
condition|)
operator|*
name|tokid
operator|=
name|kid
operator|=
name|newDEFSVOP
argument_list|()
expr_stmt|;
while|while
condition|(
name|oa
operator|&&
name|kid
condition|)
block|{
name|numargs
operator|++
expr_stmt|;
name|sibl
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
switch|switch
condition|(
name|oa
operator|&
literal|7
condition|)
block|{
case|case
name|OA_SCALAR
case|:
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_LIST
case|:
if|if
condition|(
name|oa
operator|<
literal|16
condition|)
block|{
name|kid
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_AVREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
decl_stmt|;
name|OP
modifier|*
name|newop
init|=
name|newAVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Array @%s missing the @ in argument %ld of %s()"
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|numargs
argument_list|,
name|op_desc
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2AV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_PADAV
condition|)
name|bad_type
argument_list|(
name|numargs
argument_list|,
literal|"array"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_HVREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
decl_stmt|;
name|OP
modifier|*
name|newop
init|=
name|newHVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Hash %%%s missing the %% in argument %ld of %s()"
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|numargs
argument_list|,
name|op_desc
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_PADHV
condition|)
name|bad_type
argument_list|(
name|numargs
argument_list|,
literal|"hash"
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_CVREF
case|:
block|{
name|OP
modifier|*
name|newop
init|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|kid
argument_list|)
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|linklist
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|newop
operator|->
name|op_next
operator|=
name|newop
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
break|break;
case|case
name|OA_FILEREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_GV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|OP
modifier|*
name|newop
init|=
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|PL_na
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
block|}
else|else
block|{
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|kid
operator|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_SCALARREF
case|:
name|mod
argument_list|(
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|oa
operator|>>=
literal|4
expr_stmt|;
name|tokid
operator|=
operator|&
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
name|o
operator|->
name|op_private
operator||=
name|numargs
expr_stmt|;
if|if
condition|(
name|kid
condition|)
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opargs
index|[
name|type
index|]
operator|&
name|OA_DEFGV
condition|)
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|oa
condition|)
block|{
while|while
condition|(
name|oa
operator|&
name|OA_OPTIONAL
condition|)
name|oa
operator|>>=
literal|4
expr_stmt|;
if|if
condition|(
name|oa
operator|&&
name|oa
operator|!=
name|OA_LIST
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_glob
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
operator|!
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"glob"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
operator|)
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::glob"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
specifier|static
name|int
name|glob_index
decl_stmt|;
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
name|glob_index
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LIST
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_LIST
index|]
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_type
operator|=
name|OP_PUSHMARK
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PUSHMARK
index|]
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|o
argument_list|,
name|scalar
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|ck_subr
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|OP_GLOB
expr_stmt|;
comment|/* hint at what it used to be */
return|return
name|o
return|;
block|}
name|gv
operator|=
name|newGVgen
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
name|gv_IOadd
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|scalarkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_grep
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|LOGOP
modifier|*
name|gwop
decl_stmt|;
name|OP
modifier|*
name|kid
decl_stmt|;
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
operator|==
name|OP_GREPSTART
condition|?
name|OP_GREPWHILE
else|:
name|OP_MAPWHILE
decl_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_GREPSTART
index|]
expr_stmt|;
name|Newz
argument_list|(
literal|1101
argument_list|,
name|gwop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|OP
modifier|*
name|k
decl_stmt|;
name|o
operator|=
name|ck_sort
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
for|for
control|(
name|k
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|->
name|op_next
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|op_next
control|)
block|{
name|kid
operator|=
name|k
expr_stmt|;
block|}
name|kid
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|gwop
expr_stmt|;
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_STACKED
expr_stmt|;
block|}
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_MAPWHILE
condition|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
return|return
name|o
return|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_NULL
condition|)
name|croak
argument_list|(
literal|"panic: ck_grep"
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
name|gwop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|gwop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|type
index|]
expr_stmt|;
name|gwop
operator|->
name|op_first
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|gwop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|gwop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|gwop
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|gwop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|gwop
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|||
operator|!
name|kid
operator|->
name|op_sibling
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
for|for
control|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
return|return
operator|(
name|OP
operator|*
operator|)
name|gwop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_index
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|fbm_compile
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_lengthconst
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
comment|/* XXX length optimization goes here */
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_lfun
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
return|return
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_rfun
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
return|return
name|refkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_listiob
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|o
operator|=
name|force_list
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
block|}
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHMARK
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
elseif|else
if|if
condition|(
name|kid
operator|&&
operator|!
name|kid
operator|->
name|op_sibling
condition|)
block|{
comment|/* print HANDLE; */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
condition|)
block|{
name|o
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
comment|/* make it a filehandle */
name|kid
operator|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
name|OPf_REF
argument_list|,
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|=
name|kid
expr_stmt|;
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|kid
condition|)
name|append_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_fun_locale
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_scmp
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_match
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpRUNTIME
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_null
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_repeat
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpREPEAT_DOLIST
expr_stmt|;
name|cBINOPo
operator|->
name|op_first
operator|=
name|force_list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
block|}
else|else
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_require
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
comment|/* Shall we supply missing .pm? */
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|SvPVX
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|s
operator|=
literal|'/'
expr_stmt|;
name|Move
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|s
operator|+
literal|2
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|--
name|SvCUR
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
block|}
block|}
name|sv_catpvn
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
literal|".pm"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_retarget
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|croak
argument_list|(
literal|"NOT IMPL LINE %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* STUB */
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_select
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_sibling
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_SSELECT
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_SSELECT
index|]
expr_stmt|;
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|fold_constants
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
name|kid
operator|->
name|op_private
operator|&=
operator|~
name|HINT_STRICT_REFS
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_shift
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|argop
decl_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|)
block|{
name|argop
operator|=
name|newOP
argument_list|(
name|OP_PADAV
argument_list|,
name|OPf_REF
argument_list|)
expr_stmt|;
name|argop
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* PL_curpad[0] is @_ */
block|}
else|else
block|{
name|argop
operator|=
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|argop
operator|=
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|?
name|PL_defgv
else|:
name|gv_fetchpv
argument_list|(
literal|"ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|argop
argument_list|)
argument_list|)
return|;
block|}
return|return
name|scalar
argument_list|(
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_sort
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* get past pushmark */
name|OP
modifier|*
name|k
decl_stmt|;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* get past rv2gv */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_LEAVE
condition|)
block|{
name|linklist
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_SCOPE
condition|)
block|{
name|k
operator|=
name|kid
operator|->
name|op_next
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_LEAVE
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
condition|)
block|{
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
comment|/* wipe out leave */
name|kid
operator|->
name|op_next
operator|=
name|kid
expr_stmt|;
for|for
control|(
name|k
operator|=
name|kLISTOP
operator|->
name|op_first
operator|->
name|op_next
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|op_next
control|)
block|{
if|if
condition|(
name|k
operator|->
name|op_next
operator|==
name|kid
condition|)
name|k
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|kid
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
comment|/* just disconnect the leave */
name|k
operator|=
name|kLISTOP
operator|->
name|op_first
expr_stmt|;
block|}
name|peep
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
comment|/* wipe out rv2gv */
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
condition|)
name|kid
operator|->
name|op_next
operator|=
name|kid
expr_stmt|;
else|else
name|kid
operator|->
name|op_next
operator|=
name|k
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_split
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
return|return
name|no_fh_allowed
argument_list|(
name|o
argument_list|)
return|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_NULL
condition|)
name|croak
argument_list|(
literal|"panic: ck_split"
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|op_free
argument_list|(
name|cLISTOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
expr_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
comment|/* There was only one element previously */
block|}
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_MATCH
condition|)
block|{
name|OP
modifier|*
name|sibl
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|kid
operator|=
name|pmruntime
argument_list|(
name|newPMOP
argument_list|(
name|OP_MATCH
argument_list|,
name|OPf_SPECIAL
argument_list|)
argument_list|,
name|kid
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cLISTOPo
operator|->
name|op_first
operator|==
name|cLISTOPo
operator|->
name|op_last
condition|)
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
block|}
name|kid
operator|->
name|op_type
operator|=
name|OP_PUSHRE
expr_stmt|;
name|kid
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_PUSHRE
index|]
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_SPLIT
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_SPLIT
argument_list|,
name|o
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_subr
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|OP
modifier|*
name|prev
init|=
operator|(
operator|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|)
condition|?
name|cUNOPo
else|:
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|o2
init|=
name|prev
operator|->
name|op_sibling
decl_stmt|;
name|OP
modifier|*
name|cvop
decl_stmt|;
name|char
modifier|*
name|proto
init|=
literal|0
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
literal|0
decl_stmt|;
name|GV
modifier|*
name|namegv
init|=
literal|0
decl_stmt|;
name|int
name|optional
init|=
literal|0
decl_stmt|;
name|I32
name|arg
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cvop
operator|=
name|o2
init|;
name|cvop
operator|->
name|op_sibling
condition|;
name|cvop
operator|=
name|cvop
operator|->
name|op_sibling
control|)
empty_stmt|;
if|if
condition|(
name|cvop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
block|{
name|SVOP
modifier|*
name|tmpop
decl_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|cvop
operator|->
name|op_private
operator|&
name|OPpENTERSUB_AMPER
operator|)
expr_stmt|;
name|null
argument_list|(
name|cvop
argument_list|)
expr_stmt|;
comment|/* disable rv2cv */
name|tmpop
operator|=
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cvop
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|tmpop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|cv
operator|=
name|GvCVu
argument_list|(
name|tmpop
operator|->
name|op_sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|&&
name|SvPOK
argument_list|(
name|cv
argument_list|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpENTERSUB_AMPER
operator|)
condition|)
block|{
name|namegv
operator|=
name|CvANON
argument_list|(
name|cv
argument_list|)
condition|?
operator|(
name|GV
operator|*
operator|)
name|tmpop
operator|->
name|op_sv
else|:
name|CvGV
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|proto
operator|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|PL_na
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|o
operator|->
name|op_private
operator||=
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
while|while
condition|(
name|o2
operator|!=
name|cvop
condition|)
block|{
if|if
condition|(
name|proto
condition|)
block|{
switch|switch
condition|(
operator|*
name|proto
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|)
return|;
case|case
literal|';'
case|:
name|optional
operator|=
literal|1
expr_stmt|;
name|proto
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
name|scalar
argument_list|(
name|o2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
case|case
literal|'@'
case|:
name|list
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|arg
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_REFGEN
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_UNDEF
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"block"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
goto|goto
name|wrapref
goto|;
block|{
name|OP
modifier|*
name|kid
init|=
name|o2
decl_stmt|;
name|OP
modifier|*
name|sib
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|o2
operator|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
literal|0
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|o2
operator|->
name|op_sibling
operator|=
name|sib
expr_stmt|;
name|prev
operator|->
name|op_sibling
operator|=
name|o2
expr_stmt|;
block|}
goto|goto
name|wrapref
goto|;
case|case
literal|'\\'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|proto
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2GV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"symbol"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'&'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2CV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"sub"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2SV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADSV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_THREADSV
condition|)
block|{
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"scalar"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
goto|goto
name|wrapref
goto|;
case|case
literal|'@'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2AV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADAV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"array"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'%'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADHV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"hash"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
name|wrapref
label|:
block|{
name|OP
modifier|*
name|kid
init|=
name|o2
decl_stmt|;
name|OP
modifier|*
name|sib
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|o2
operator|=
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|o2
operator|->
name|op_sibling
operator|=
name|sib
expr_stmt|;
name|prev
operator|->
name|op_sibling
operator|=
name|o2
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|oops
goto|;
block|}
break|break;
case|case
literal|' '
case|:
name|proto
operator|++
expr_stmt|;
continue|continue;
default|default:
name|oops
label|:
name|croak
argument_list|(
literal|"Malformed prototype for %s: %s"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|PL_na
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|list
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|o2
argument_list|,
name|OP_ENTERSUB
argument_list|)
expr_stmt|;
name|prev
operator|=
name|o2
expr_stmt|;
name|o2
operator|=
name|o2
operator|->
name|op_sibling
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|&&
operator|!
name|optional
operator|&&
operator|(
operator|*
name|proto
operator|&&
operator|*
name|proto
operator|!=
literal|'@'
operator|&&
operator|*
name|proto
operator|!=
literal|'%'
operator|&&
operator|*
name|proto
operator|!=
literal|';'
operator|)
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|)
return|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_svconst
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|SvREADONLY_on
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|ck_trunc
parameter_list|(
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|kid
operator|=
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A peephole optimizer.  We visit the ops in the order they're to execute. */
end_comment

begin_function
name|void
name|peep
parameter_list|(
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|OP
modifier|*
name|oldop
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_seq
condition|)
return|return;
name|ENTER
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|op_next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|op_seq
condition|)
break|break;
if|if
condition|(
operator|!
name|PL_op_seqmax
condition|)
name|PL_op_seqmax
operator|++
expr_stmt|;
name|PL_op
operator|=
name|o
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
expr_stmt|;
comment|/* for warnings */
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CONCAT
case|:
case|case
name|OP_CONST
case|:
case|case
name|OP_JOIN
case|:
case|case
name|OP_UC
case|:
case|case
name|OP_UCFIRST
case|:
case|case
name|OP_LC
case|:
case|case
name|OP_LCFIRST
case|:
case|case
name|OP_QUOTEMETA
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_STRINGIFY
condition|)
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_STUB
case|:
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|!=
name|OPf_WANT_LIST
condition|)
block|{
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
comment|/* Scalar stub must produce undef.  List stub is noop */
block|}
goto|goto
name|nothin
goto|;
case|case
name|OP_NULL
case|:
if|if
condition|(
name|o
operator|->
name|op_targ
operator|==
name|OP_NEXTSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_DBSTATE
condition|)
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
expr_stmt|;
goto|goto
name|nothin
goto|;
case|case
name|OP_SCALAR
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_SCOPE
case|:
name|nothin
label|:
if|if
condition|(
name|oldop
operator|&&
name|o
operator|->
name|op_next
condition|)
block|{
name|oldop
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
continue|continue;
block|}
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_GV
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_next
operator|->
name|op_private
operator|&
name|OPpDEREF
operator|)
condition|)
block|{
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|o
operator|->
name|op_next
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_GVSV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_GVSV
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2AV
condition|)
block|{
name|OP
modifier|*
name|pop
init|=
name|o
operator|->
name|op_next
operator|->
name|op_next
decl_stmt|;
name|IV
name|i
decl_stmt|;
if|if
condition|(
name|pop
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|PL_op
operator|=
name|pop
operator|->
name|op_next
operator|)
operator|&&
name|pop
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_AELEM
operator|&&
operator|!
operator|(
name|pop
operator|->
name|op_next
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpLVAL_DEFER
operator||
name|OPpDEREF
operator|)
operator|)
operator|&&
operator|(
name|i
operator|=
name|SvIV
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|pop
operator|)
operator|->
name|op_sv
argument_list|)
operator|-
name|PL_compiling
operator|.
name|cop_arybase
operator|)
operator|<=
literal|255
operator|&&
name|i
operator|>=
literal|0
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|pop
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|pop
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|pop
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|pop
operator|->
name|op_next
operator|->
name|op_flags
operator|&
name|OPf_MOD
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|pop
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_AELEMFAST
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_AELEMFAST
index|]
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
operator|(
name|U8
operator|)
name|i
expr_stmt|;
name|GvAVn
argument_list|(
operator|(
operator|(
name|GVOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_gv
argument_list|)
expr_stmt|;
block|}
block|}
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_PADAV
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|&&
operator|(
name|o
operator|->
name|op_next
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|)
condition|)
block|{
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
block|}
break|break;
case|case
name|OP_PADHV
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|&&
operator|(
name|o
operator|->
name|op_next
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|)
condition|)
block|{
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
block|}
break|break;
case|case
name|OP_MAPWHILE
case|:
case|case
name|OP_GREPWHILE
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_OR
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
while|while
condition|(
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cLOGOP
operator|->
name|op_other
operator|=
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COND_EXPR
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
name|peep
argument_list|(
name|cCONDOP
operator|->
name|op_true
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|cCONDOP
operator|->
name|op_false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ENTERLOOP
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_redoop
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_nextop
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_lastop
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_QR
case|:
case|case
name|OP_MATCH
case|:
case|case
name|OP_SUBST
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
name|peep
argument_list|(
name|cPMOP
operator|->
name|op_pmreplstart
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXEC
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
name|o
operator|->
name|op_next
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_EXIT
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_WARN
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_DIE
condition|)
block|{
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|->
name|op_next
operator|)
operator|->
name|cop_line
expr_stmt|;
name|warn
argument_list|(
literal|"Statement unlikely to be reached"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"(Maybe you meant system() when you said exec()?)\n"
argument_list|)
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_HELEM
case|:
block|{
name|UNOP
modifier|*
name|rop
decl_stmt|;
name|SV
modifier|*
name|lexname
decl_stmt|;
name|GV
modifier|*
modifier|*
name|fields
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|,
modifier|*
modifier|*
name|indsvp
decl_stmt|;
name|I32
name|ind
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|keylen
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpDEREF_HV
operator||
name|OPpDEREF_AV
operator||
name|OPpLVAL_INTRO
operator|)
operator|||
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_last
operator|->
name|op_type
operator|!=
name|OP_CONST
condition|)
break|break;
name|rop
operator|=
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|rop
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|||
name|rop
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_PADSV
condition|)
break|break;
name|lexname
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|rop
operator|->
name|op_first
operator|->
name|op_targ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|lexname
argument_list|)
condition|)
break|break;
name|fields
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|,
literal|"FIELDS"
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
operator|||
operator|!
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
condition|)
break|break;
name|svp
operator|=
operator|&
operator|(
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_last
operator|)
operator|->
name|op_sv
expr_stmt|;
name|key
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|indsvp
operator|=
name|hv_fetch
argument_list|(
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indsvp
condition|)
block|{
name|croak
argument_list|(
literal|"No such field \"%s\" in variable %s of type %s"
argument_list|,
name|key
argument_list|,
name|SvPV
argument_list|(
name|lexname
argument_list|,
name|PL_na
argument_list|)
argument_list|,
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|SvIV
argument_list|(
operator|*
name|indsvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
condition|)
name|croak
argument_list|(
literal|"Bad index while coercing array into hash"
argument_list|)
expr_stmt|;
name|rop
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|rop
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_AELEM
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|ppaddr
index|[
name|OP_AELEM
index|]
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|newSViv
argument_list|(
name|ind
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
block|}
name|oldop
operator|=
name|o
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
block|}
end_function

end_unit

