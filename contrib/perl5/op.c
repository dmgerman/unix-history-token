begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    op.c  *  *    Copyright (c) 1991-2001, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "You see: Mr. Drogo, he married poor Miss Primula Brandybuck.  She was  * our Mr. Bilbo's first cousin on the mother's side (her mother being the  * youngest of the Old Took's daughters); and Mr. Drogo was his second  * cousin.  So Mr. Frodo is his first *and* second cousin, once removed  * either way, as the saying is, if you follow me."  --the Gaffer  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_OP_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_comment
comment|/* #define PL_OP_SLAB_ALLOC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PL_OP_SLAB_ALLOC
end_ifdef

begin_define
define|#
directive|define
name|SLAB_SIZE
value|8192
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PL_OpPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PL_OpSpace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NewOp
parameter_list|(
name|m
parameter_list|,
name|var
parameter_list|,
name|c
parameter_list|,
name|type
parameter_list|)
value|do { if ((PL_OpSpace -= c*sizeof(type))>= 0)     \                               var =  (type *)(PL_OpPtr -= c*sizeof(type));    \                              else                                             \                               var = (type *) Slab_Alloc(m,c*sizeof(type));    \                            } while (0)
end_define

begin_function
name|STATIC
name|void
modifier|*
name|S_Slab_Alloc
parameter_list|(
name|pTHX_
name|int
name|m
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|Newz
argument_list|(
name|m
argument_list|,
name|PL_OpPtr
argument_list|,
name|SLAB_SIZE
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|PL_OpSpace
operator|=
name|SLAB_SIZE
operator|-
name|sz
expr_stmt|;
return|return
name|PL_OpPtr
operator|+=
name|PL_OpSpace
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NewOp
parameter_list|(
name|m
parameter_list|,
name|var
parameter_list|,
name|c
parameter_list|,
name|type
parameter_list|)
value|Newz(m, var, c, type)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In the following definition, the ", Nullop" is just to make the compiler  * think the expression is of the right type: croak actually does a Siglongjmp.  */
end_comment

begin_define
define|#
directive|define
name|CHECKOP
parameter_list|(
name|type
parameter_list|,
name|o
parameter_list|)
define|\
value|((PL_op_mask&& PL_op_mask[type])					\      ? ( op_free((OP*)o),					\ 	 Perl_croak(aTHX_ "%s trapped by operation mask", PL_op_desc[type]),	\ 	 Nullop )						\      : CALL_FPTR(PL_check[type])(aTHX_ (OP*)o))
end_define

begin_define
define|#
directive|define
name|PAD_MAX
value|999999999
end_define

begin_define
define|#
directive|define
name|RETURN_UNLIMITED_NUMBER
value|(PERL_INT_MAX / 2)
end_define

begin_function
name|STATIC
name|char
modifier|*
name|S_gv_ename
parameter_list|(
name|pTHX_
name|GV
modifier|*
name|gv
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|SV
modifier|*
name|tmpsv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname3
argument_list|(
name|tmpsv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
return|return
name|SvPV
argument_list|(
name|tmpsv
argument_list|,
name|n_a
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_no_fh_allowed
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Missing comma after first argument to %s function"
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_too_few_arguments
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Not enough arguments for %s"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_too_many_arguments
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Too many arguments for %s"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_bad_type
parameter_list|(
name|pTHX_
name|I32
name|n
parameter_list|,
name|char
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|OP
modifier|*
name|kid
parameter_list|)
block|{
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Type of arg %d to %s must be %s (not %s)"
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|name
argument_list|,
name|t
argument_list|,
name|PL_op_desc
index|[
name|kid
operator|->
name|op_type
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_no_bareword_allowed
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|qerror
argument_list|(
name|Perl_mess
argument_list|(
name|aTHX_
literal|"Bareword \"%s\" not allowed while \"strict subs\" in use"
argument_list|,
name|SvPV_nolen
argument_list|(
name|cSVOPo_sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|U8
modifier|*
name|S_trlist_upgrade
parameter_list|(
name|pTHX_
name|U8
modifier|*
modifier|*
name|sp
parameter_list|,
name|U8
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|U8
modifier|*
name|s
init|=
operator|*
name|sp
decl_stmt|;
name|U8
modifier|*
name|e
init|=
operator|*
name|ep
decl_stmt|;
name|U8
modifier|*
name|d
decl_stmt|;
name|Newz
argument_list|(
literal|801
argument_list|,
name|d
argument_list|,
operator|(
name|e
operator|-
name|s
operator|)
operator|*
literal|2
argument_list|,
name|U8
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|0x80
operator|||
operator|*
name|s
operator|==
literal|0xff
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
else|else
block|{
name|U8
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
operator|*
name|d
operator|++
operator|=
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator||
literal|0xc0
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|(
operator|(
name|c
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|ep
operator|=
name|d
expr_stmt|;
return|return
operator|*
name|sp
return|;
block|}
end_function

begin_comment
comment|/* "register" allocation */
end_comment

begin_function
name|PADOFFSET
name|Perl_pad_allocmy
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|)
block|{
name|PADOFFSET
name|off
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|PL_in_my
operator|==
name|KEY_our
operator|||
name|isALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|PL_hints
operator|&
name|HINT_UTF8
operator|&&
name|UTF8_IS_START
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isPRINT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"\t\n\r\f"
argument_list|,
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 1999-02-27 mjd@plover.com */
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* The next block assumes the buffer is at least 205 chars 	       long.  At present, it's always at least 256 chars. */
if|if
condition|(
name|p
operator|-
name|name
operator|>
literal|200
condition|)
block|{
name|strcpy
argument_list|(
name|name
operator|+
literal|200
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
operator|+
literal|199
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Move everything else down one character */
for|for
control|(
init|;
name|p
operator|-
name|name
operator|>
literal|2
condition|;
name|p
operator|--
control|)
operator|*
name|p
operator|=
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|toCTRL
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
block|}
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Can't use global %s in \"my\""
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|HV
modifier|*
name|ourstash
init|=
operator|(
name|PL_curstash
condition|?
name|PL_curstash
else|:
name|PL_defstash
operator|)
decl_stmt|;
name|PADOFFSET
name|top
init|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
name|off
operator|=
name|top
init|;
name|off
operator|>
name|PL_comppad_name_floor
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|PAD_MAX
operator|||
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|PL_in_my
operator|!=
name|KEY_our
operator|||
operator|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVpad_OUR
operator|)
operator|&&
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|==
name|ourstash
operator|)
operator|)
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"\"%s\" variable %s masks earlier declaration in same %s"
argument_list|,
argument|(PL_in_my == KEY_our ?
literal|"our"
argument|:
literal|"my"
argument|)
argument_list|,
argument|name
argument_list|,
argument|(SvIVX(sv) == PAD_MAX ?
literal|"scope"
argument|:
literal|"statement"
argument|)
argument_list|)
empty_stmt|;
operator|--
name|off
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|PL_in_my
operator|==
name|KEY_our
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|PAD_MAX
operator|||
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVpad_OUR
operator|)
operator|&&
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|==
name|ourstash
operator|)
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"\"our\" variable %s redeclared"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"\t(Did you mean \"local\" instead of \"our\"?)\n"
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|off
operator|--
operator|>
literal|0
condition|)
do|;
block|}
block|}
name|off
operator|=
name|pad_alloc
argument_list|(
name|OP_PADSV
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv
operator|=
name|NEWSV
argument_list|(
literal|1102
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_in_my_stash
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|!=
literal|'$'
condition|)
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Can't declare class for non-scalar %s in \"%s\""
argument_list|,
name|name
argument_list|,
name|PL_in_my
operator|==
name|KEY_our
condition|?
literal|"our"
else|:
literal|"my"
argument_list|)
argument_list|)
expr_stmt|;
name|SvOBJECT_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_in_my_stash
argument_list|)
expr_stmt|;
name|PL_sv_objcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|PL_in_my
operator|==
name|KEY_our
condition|)
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_curstash
condition|?
operator|(
name|SV
operator|*
operator|)
name|PL_curstash
else|:
operator|(
name|SV
operator|*
operator|)
name|PL_defstash
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVpad_OUR
expr_stmt|;
block|}
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|off
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|NV
operator|)
name|PAD_MAX
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Not yet introduced--see newSTATEOP */
if|if
condition|(
operator|!
name|PL_min_intro_pending
condition|)
name|PL_min_intro_pending
operator|=
name|off
expr_stmt|;
name|PL_max_intro_pending
operator|=
name|off
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|off
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|off
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
name|off
index|]
argument_list|)
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_function
name|STATIC
name|PADOFFSET
name|S_pad_addlex
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|proto_namesv
parameter_list|)
block|{
name|SV
modifier|*
name|namesv
init|=
name|NEWSV
argument_list|(
literal|1103
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|PADOFFSET
name|newoff
init|=
name|pad_alloc
argument_list|(
name|OP_PADSV
argument_list|,
name|SVs_PADMY
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|namesv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|namesv
argument_list|,
name|SvPVX
argument_list|(
name|proto_namesv
argument_list|)
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|newoff
argument_list|,
name|namesv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|namesv
argument_list|)
operator|=
operator|(
name|NV
operator|)
name|PL_curcop
operator|->
name|cop_seq
expr_stmt|;
name|SvIVX
argument_list|(
name|namesv
argument_list|)
operator|=
name|PAD_MAX
expr_stmt|;
comment|/* A ref, intro immediately */
name|SvFAKE_on
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
comment|/* A ref, not a real var */
if|if
condition|(
name|SvFLAGS
argument_list|(
name|proto_namesv
argument_list|)
operator|&
name|SVpad_OUR
condition|)
block|{
comment|/* An "our" variable */
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator||=
name|SVpad_OUR
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|namesv
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|namesv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvSTASH
argument_list|(
name|proto_namesv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvOBJECT
argument_list|(
name|proto_namesv
argument_list|)
condition|)
block|{
comment|/* A typed var */
name|SvOBJECT_on
argument_list|(
name|namesv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|namesv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|namesv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|SvSTASH
argument_list|(
name|proto_namesv
argument_list|)
argument_list|)
expr_stmt|;
name|PL_sv_objcount
operator|++
expr_stmt|;
block|}
return|return
name|newoff
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FINDLEX_NOSEARCH
value|1
end_define

begin_comment
comment|/* don't search outer contexts */
end_comment

begin_function
name|STATIC
name|PADOFFSET
name|S_pad_findlex
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|,
name|PADOFFSET
name|newoff
parameter_list|,
name|U32
name|seq
parameter_list|,
name|CV
modifier|*
name|startcv
parameter_list|,
name|I32
name|cx_ix
parameter_list|,
name|I32
name|saweval
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
name|I32
name|off
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
for|for
control|(
name|cv
operator|=
name|startcv
init|;
name|cv
condition|;
name|cv
operator|=
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
control|)
block|{
name|AV
modifier|*
name|curlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|curlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|curname
decl_stmt|;
if|if
condition|(
operator|!
name|svp
operator|||
operator|*
name|svp
operator|==
operator|&
name|PL_sv_undef
condition|)
continue|continue;
name|curname
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|svp
expr_stmt|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|curname
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|curname
argument_list|)
init|;
name|off
operator|>
literal|0
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|seq
operator|<=
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|seq
operator|>
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|I32
name|depth
decl_stmt|;
name|AV
modifier|*
name|oldpad
decl_stmt|;
name|SV
modifier|*
name|oldsv
decl_stmt|;
name|depth
operator|=
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|depth
condition|)
block|{
if|if
condition|(
name|newoff
condition|)
block|{
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
continue|continue;
return|return
literal|0
return|;
comment|/* don't clone from inactive stack frame */
block|}
name|depth
operator|=
literal|1
expr_stmt|;
block|}
name|oldpad
operator|=
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|curlist
argument_list|)
index|[
name|depth
index|]
expr_stmt|;
name|oldsv
operator|=
operator|*
name|av_fetch
argument_list|(
name|oldpad
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newoff
condition|)
block|{
comment|/* Not a mere clone operation. */
name|newoff
operator|=
name|pad_addlex
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvANON
argument_list|(
name|PL_compcv
argument_list|)
operator|||
name|SvTYPE
argument_list|(
name|PL_compcv
argument_list|)
operator|==
name|SVt_PVFM
condition|)
block|{
comment|/* "It's closures all the way down." */
name|CvCLONE_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|==
name|startcv
condition|)
block|{
if|if
condition|(
name|CvANON
argument_list|(
name|PL_compcv
argument_list|)
condition|)
name|oldsv
operator|=
name|Nullsv
expr_stmt|;
comment|/* no need to keep ref */
block|}
else|else
block|{
name|CV
modifier|*
name|bcv
decl_stmt|;
for|for
control|(
name|bcv
operator|=
name|startcv
init|;
name|bcv
operator|&&
name|bcv
operator|!=
name|cv
operator|&&
operator|!
name|CvCLONE
argument_list|(
name|bcv
argument_list|)
condition|;
name|bcv
operator|=
name|CvOUTSIDE
argument_list|(
name|bcv
argument_list|)
control|)
block|{
if|if
condition|(
name|CvANON
argument_list|(
name|bcv
argument_list|)
condition|)
block|{
comment|/* install the missing pad entry in intervening 				     * nested subs and mark them cloneable. 				     * XXX fix pad_foo() to not use globals */
name|AV
modifier|*
name|ocomppad_name
init|=
name|PL_comppad_name
decl_stmt|;
name|AV
modifier|*
name|ocomppad
init|=
name|PL_comppad
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ocurpad
init|=
name|PL_curpad
decl_stmt|;
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|bcv
argument_list|)
decl_stmt|;
name|PL_comppad_name
operator|=
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|PL_comppad
operator|=
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
index|[
literal|1
index|]
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|pad_addlex
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|ocomppad_name
expr_stmt|;
name|PL_comppad
operator|=
name|ocomppad
expr_stmt|;
name|PL_curpad
operator|=
name|ocurpad
expr_stmt|;
name|CvCLONE_on
argument_list|(
name|bcv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSURE
argument_list|)
operator|&&
operator|!
name|CvUNIQUE
argument_list|(
name|bcv
argument_list|)
operator|&&
operator|!
name|CvUNIQUE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_CLOSURE
argument_list|,
literal|"Variable \"%s\" may be unavailable"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_CLOSURE
argument_list|)
operator|&&
operator|!
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|CvUNIQUE
argument_list|(
name|cv
argument_list|)
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVpad_OUR
operator|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_CLOSURE
argument_list|,
literal|"Variable \"%s\" will not stay shared"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
block|}
block|}
block|}
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|newoff
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|oldsv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newoff
return|;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|FINDLEX_NOSEARCH
condition|)
return|return
literal|0
return|;
comment|/* Nothing in current lexical context--try eval's context, if any.      * This is necessary to let the perldb get at lexically scoped variables.      * XXX This will also probably interact badly with eval tree caching.      */
for|for
control|(
name|i
operator|=
name|cx_ix
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|CxTYPE
argument_list|(
name|cx
argument_list|)
condition|)
block|{
default|default:
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|saweval
condition|)
block|{
name|seq
operator|=
name|cxstack
index|[
name|saweval
index|]
operator|.
name|blk_oldcop
operator|->
name|cop_seq
expr_stmt|;
return|return
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|newoff
argument_list|,
name|seq
argument_list|,
name|PL_main_cv
argument_list|,
operator|-
literal|1
argument_list|,
name|saweval
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|CXt_EVAL
case|:
switch|switch
condition|(
name|cx
operator|->
name|blk_eval
operator|.
name|old_op_type
condition|)
block|{
case|case
name|OP_ENTEREVAL
case|:
if|if
condition|(
name|CxREALEVAL
argument_list|(
name|cx
argument_list|)
condition|)
name|saweval
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|OP_DOFILE
case|:
case|case
name|OP_REQUIRE
case|:
comment|/* require/do must have their own scope */
return|return
literal|0
return|;
block|}
break|break;
case|case
name|CXt_FORMAT
case|:
case|case
name|CXt_SUB
case|:
if|if
condition|(
operator|!
name|saweval
condition|)
return|return
literal|0
return|;
name|cv
operator|=
name|cx
operator|->
name|blk_sub
operator|.
name|cv
expr_stmt|;
if|if
condition|(
name|PL_debstash
operator|&&
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|==
name|PL_debstash
condition|)
block|{
comment|/* ignore DB'* scope */
name|saweval
operator|=
name|i
expr_stmt|;
comment|/* so we know where we were called from */
continue|continue;
block|}
name|seq
operator|=
name|cxstack
index|[
name|saweval
index|]
operator|.
name|blk_oldcop
operator|->
name|cop_seq
expr_stmt|;
return|return
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|newoff
argument_list|,
name|seq
argument_list|,
name|cv
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|saweval
argument_list|,
name|FINDLEX_NOSEARCH
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|PADOFFSET
name|Perl_pad_findmy
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|)
block|{
name|I32
name|off
decl_stmt|;
name|I32
name|pendoff
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|U32
name|seq
init|=
name|PL_cop_seqmax
decl_stmt|;
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|CV
modifier|*
name|outside
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
comment|/*      * Special case to get lexical (and hence per-thread) @_.      * XXX I need to find out how to tell at parse-time whether use      * of @_ should refer to a lexical (from a sub) or defgv (global      * scope and maybe weird sub-ish things like formats). See      * startsub in perly.y.  It's possible that @_ could be lexical      * (at least from subs) even in non-threaded perl.      */
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"@_"
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* success. (NOT_IN_PAD indicates failure) */
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* The one we're looking for is probably just before comppad_name_fill. */
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|off
operator|>
literal|0
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
operator|!
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|seq
operator|<=
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|seq
operator|>
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|strEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|||
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVpad_OUR
condition|)
return|return
operator|(
name|PADOFFSET
operator|)
name|off
return|;
name|pendoff
operator|=
name|off
expr_stmt|;
comment|/* this pending def. will override import */
block|}
block|}
name|outside
operator|=
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
comment|/* Check if if we're compiling an eval'', and adjust seq to be the      * eval's seq number.  This depends on eval'' having a non-null      * CvOUTSIDE() while it is being compiled.  The eval'' itself is      * identified by CvEVAL being true and CvGV being null. */
if|if
condition|(
name|outside
operator|&&
name|CvEVAL
argument_list|(
name|PL_compcv
argument_list|)
operator|&&
operator|!
name|CvGV
argument_list|(
name|PL_compcv
argument_list|)
operator|&&
name|cxstack_ix
operator|>=
literal|0
condition|)
block|{
name|cx
operator|=
operator|&
name|cxstack
index|[
name|cxstack_ix
index|]
expr_stmt|;
if|if
condition|(
name|CxREALEVAL
argument_list|(
name|cx
argument_list|)
condition|)
name|seq
operator|=
name|cx
operator|->
name|blk_oldcop
operator|->
name|cop_seq
expr_stmt|;
block|}
comment|/* See if it's in a nested scope */
name|off
operator|=
name|pad_findlex
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|seq
argument_list|,
name|outside
argument_list|,
name|cxstack_ix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
comment|/* If there is a pending local definition, this new alias must die */
if|if
condition|(
name|pendoff
condition|)
name|SvIVX
argument_list|(
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
index|[
name|off
index|]
argument_list|)
operator|=
name|seq
expr_stmt|;
return|return
name|off
return|;
comment|/* pad_findlex returns 0 for failure...*/
block|}
return|return
name|NOT_IN_PAD
return|;
comment|/* ...but we return NOT_IN_PAD for failure */
block|}
end_function

begin_function
name|void
name|Perl_pad_leavemy
parameter_list|(
name|pTHX_
name|I32
name|fill
parameter_list|)
block|{
name|I32
name|off
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_min_intro_pending
operator|&&
name|fill
operator|<
name|PL_min_intro_pending
condition|)
block|{
for|for
control|(
name|off
operator|=
name|PL_max_intro_pending
init|;
name|off
operator|>=
name|PL_min_intro_pending
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"%s never introduced"
argument_list|,
argument|SvPVX(sv)
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* "Deintroduce" my variables that are leaving with this scope. */
for|for
control|(
name|off
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
init|;
name|off
operator|>
name|fill
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|off
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|PAD_MAX
condition|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|PL_cop_seqmax
expr_stmt|;
block|}
block|}
end_function

begin_function
name|PADOFFSET
name|Perl_pad_alloc
parameter_list|(
name|pTHX_
name|I32
name|optype
parameter_list|,
name|U32
name|tmptype
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|retval
decl_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_pad_reset_pending
condition|)
name|pad_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmptype
operator|&
name|SVs_PADMY
condition|)
block|{
do|do
block|{
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad
argument_list|,
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SvPADBUSY
argument_list|(
name|sv
argument_list|)
condition|)
do|;
comment|/* need a fresh one */
name|retval
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
modifier|*
name|names
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SSize_t
name|names_fill
init|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	     * "foreach" index vars temporarily become aliases to non-"my" 	     * values.  Thus we must skip, not just pad values that are 	     * marked as current pad values, but also those with names. 	     */
if|if
condition|(
operator|++
name|PL_padix
operator|<=
name|names_fill
operator|&&
operator|(
name|sv
operator|=
name|names
index|[
name|PL_padix
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
condition|)
continue|continue;
name|sv
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad
argument_list|,
name|PL_padix
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVs_PADTMP
operator||
name|SVs_PADMY
operator|)
operator|)
operator|&&
operator|!
name|IS_PADGV
argument_list|(
name|sv
argument_list|)
condition|)
break|break;
block|}
name|retval
operator|=
name|PL_padix
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|tmptype
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" Pad 0x%"
name|UVxf
literal|" alloc %ld for %s\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|,
name|PL_op_name
index|[
name|optype
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%"
name|UVxf
literal|" alloc %ld for %s\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|,
name|PL_op_name
index|[
name|optype
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
operator|(
name|PADOFFSET
operator|)
name|retval
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_pad_sv
parameter_list|(
name|pTHX_
name|PADOFFSET
name|po
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" Pad 0x%"
name|UVxf
literal|" sv %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|po
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_sv po"
argument_list|)
expr_stmt|;
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%"
name|UVxf
literal|" sv %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|PL_curpad
index|[
name|po
index|]
return|;
comment|/* eventually we'll turn this into a macro */
block|}
end_function

begin_function
name|void
name|Perl_pad_free
parameter_list|(
name|pTHX_
name|PADOFFSET
name|po
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PL_curpad
condition|)
return|return;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_free curpad"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|po
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_free po"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" Pad 0x%"
name|UVxf
literal|" free %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%"
name|UVxf
literal|" free %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|PL_curpad
index|[
name|po
index|]
operator|&&
name|PL_curpad
index|[
name|po
index|]
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|SvREADONLY_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
comment|/* could be a freed constant */
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|I32
operator|)
name|po
operator|<
name|PL_padix
condition|)
name|PL_padix
operator|=
name|po
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_pad_swipe
parameter_list|(
name|pTHX_
name|PADOFFSET
name|po
parameter_list|)
block|{
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_swipe curpad"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|po
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_swipe po"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" Pad 0x%"
name|UVxf
literal|" swipe %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%"
name|UVxf
literal|" swipe %"
name|IVdf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|po
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|po
index|]
operator|=
name|NEWSV
argument_list|(
literal|1107
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|I32
operator|)
name|po
operator|<
name|PL_padix
condition|)
name|PL_padix
operator|=
name|po
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX pad_reset() is currently disabled because it results in serious bugs.  * It causes pad temp TARGs to be shared between OPs. Since TARGs are pushed  * on the stack by OPs that use them, there are several ways to get an alias  * to  a shared TARG.  Such an alias will change randomly and unpredictably.  * We avoid doing this until we can think of a Better Way.  * GSAR 97-10-29 */
end_comment

begin_function
name|void
name|Perl_pad_reset
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_BROKEN_PAD_RESET
specifier|register
name|I32
name|po
decl_stmt|;
if|if
condition|(
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
operator|!=
name|PL_curpad
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pad_reset curpad"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%"
name|UVxf
literal|" Pad 0x%"
name|UVxf
literal|" reset\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUG_X
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Pad 0x%"
name|UVxf
literal|" reset\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_curpad
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|!
name|PL_tainting
condition|)
block|{
comment|/* Can't mix tainted and non-tainted temporaries. */
for|for
control|(
name|po
operator|=
name|AvMAX
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|po
operator|>
name|PL_padix_floor
condition|;
name|po
operator|--
control|)
block|{
if|if
condition|(
name|PL_curpad
index|[
name|po
index|]
operator|&&
operator|!
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
condition|)
name|SvPADTMP_off
argument_list|(
name|PL_curpad
index|[
name|po
index|]
argument_list|)
expr_stmt|;
block|}
name|PL_padix
operator|=
name|PL_padix_floor
expr_stmt|;
block|}
endif|#
directive|endif
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_THREADS
end_ifdef

begin_comment
comment|/* find_threadsv is not reentrant */
end_comment

begin_function
name|PADOFFSET
name|Perl_find_threadsv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|PADOFFSET
name|key
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
comment|/* We currently only handle names of a single character */
name|p
operator|=
name|strchr
argument_list|(
name|PL_threadsv_names
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NOT_IN_PAD
return|;
name|key
operator|=
name|p
operator|-
name|PL_threadsv_names
expr_stmt|;
name|MUTEX_LOCK
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|svp
operator|=
name|av_fetch
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|key
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
condition|)
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|av_store
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|,
name|key
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|thr
operator|->
name|threadsvp
operator|=
name|AvARRAY
argument_list|(
name|thr
operator|->
name|threadsv
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Some magic variables used to be automagically initialised 	 * in gv_fetchpv. Those which are now per-thread magicals get 	 * initialised here instead. 	 */
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'_'
case|:
break|break;
case|case
literal|';'
case|:
name|sv_setpv
argument_list|(
name|sv
argument_list|,
literal|"\034"
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'`'
case|:
case|case
literal|'\''
case|:
name|PL_sawampersand
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
comment|/* XXX %! tied to Errno.pm needs to be added here. 	 * See gv_fetchpv(). */
comment|/* case '!': */
default|default:
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"find_threadsv: new SV %p for $%s%c\n"
argument_list|,
name|sv
argument_list|,
operator|(
operator|*
name|name
operator|<
literal|32
operator|)
condition|?
literal|"^"
else|:
literal|""
argument_list|,
operator|(
operator|*
name|name
operator|<
literal|32
operator|)
condition|?
name|toCTRL
argument_list|(
operator|*
name|name
argument_list|)
else|:
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_THREADS */
end_comment

begin_comment
comment|/* Destructor */
end_comment

begin_function
name|void
name|Perl_op_free
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|,
modifier|*
name|nextkid
decl_stmt|;
name|OPCODE
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_seq
operator|==
operator|(
name|U16
operator|)
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
name|OPpREFCOUNTED
condition|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_LEAVESUB
case|:
case|case
name|OP_LEAVESUBLV
case|:
case|case
name|OP_LEAVEEVAL
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVEWRITE
case|:
name|OP_REFCNT_LOCK
expr_stmt|;
if|if
condition|(
name|OpREFCNT_dec
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|OP_REFCNT_UNLOCK
expr_stmt|;
return|return;
block|}
name|OP_REFCNT_UNLOCK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|nextkid
control|)
block|{
name|nextkid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
comment|/* Get before next freeing kid */
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
name|type
operator|=
name|o
operator|->
name|op_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_NULL
condition|)
name|type
operator|=
name|o
operator|->
name|op_targ
expr_stmt|;
comment|/* COP* is not cleared by op_clear() so that we may track line      * numbers etc even after null() */
if|if
condition|(
name|type
operator|==
name|OP_NEXTSTATE
operator|||
name|type
operator|==
name|OP_SETSTATE
operator|||
name|type
operator|==
name|OP_DBSTATE
condition|)
name|cop_free
argument_list|(
operator|(
name|COP
operator|*
operator|)
name|o
argument_list|)
expr_stmt|;
name|op_clear
argument_list|(
name|o
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PL_OP_SLAB_ALLOC
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|o
operator|==
name|PL_OpPtr
condition|)
block|{      }
else|#
directive|else
name|Safefree
argument_list|(
name|o
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|STATIC
name|void
name|S_op_clear
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
comment|/* Was holding old type, if any. */
case|case
name|OP_ENTEREVAL
case|:
comment|/* Was holding hints. */
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|OP_THREADSV
case|:
comment|/* Was holding index into thr->threadsv AV. */
endif|#
directive|endif
name|o
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|OP_ENTERITER
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* USE_THREADS */
default|default:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_REF
operator|)
operator|||
operator|(
name|PL_check
index|[
name|o
operator|->
name|op_type
index|]
operator|!=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_ck_ftst
argument_list|)
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_GVSV
case|:
case|case
name|OP_GV
case|:
case|case
name|OP_AELEMFAST
case|:
ifdef|#
directive|ifdef
name|USE_ITHREADS
if|if
condition|(
name|cPADOPo
operator|->
name|op_padix
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|PL_curpad
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPo_gv
decl_stmt|;
name|pad_swipe
argument_list|(
name|cPADOPo
operator|->
name|op_padix
argument_list|)
expr_stmt|;
comment|/* No GvIN_PAD_off(gv) here, because other references may still 		 * exist on the pad */
name|SvREFCNT_dec
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
name|cPADOPo
operator|->
name|op_padix
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|SvREFCNT_dec
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OP_METHOD_NAMED
case|:
case|case
name|OP_CONST
case|:
name|SvREFCNT_dec
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
break|break;
case|case
name|OP_GOTO
case|:
case|case
name|OP_NEXT
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REDO
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
operator|(
name|OPf_SPECIAL
operator||
name|OPf_STACKED
operator||
name|OPf_KIDS
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_TRANS
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpTRANS_FROM_UTF
operator||
name|OPpTRANS_TO_UTF
operator|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
block|}
else|else
block|{
name|Safefree
argument_list|(
name|cPVOPo
operator|->
name|op_pv
argument_list|)
expr_stmt|;
name|cPVOPo
operator|->
name|op_pv
operator|=
name|Nullch
expr_stmt|;
block|}
break|break;
case|case
name|OP_SUBST
case|:
name|op_free
argument_list|(
name|cPMOPo
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
goto|goto
name|clear_pmop
goto|;
case|case
name|OP_PUSHRE
case|:
ifdef|#
directive|ifdef
name|USE_ITHREADS
if|if
condition|(
operator|(
name|PADOFFSET
operator|)
name|cPMOPo
operator|->
name|op_pmreplroot
condition|)
block|{
if|if
condition|(
name|PL_curpad
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|PL_curpad
index|[
operator|(
name|PADOFFSET
operator|)
name|cPMOPo
operator|->
name|op_pmreplroot
index|]
decl_stmt|;
name|pad_swipe
argument_list|(
operator|(
name|PADOFFSET
operator|)
name|cPMOPo
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
comment|/* No GvIN_PAD_off(gv) here, because other references may still 		 * exist on the pad */
name|SvREFCNT_dec
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cPMOPo
operator|->
name|op_pmreplroot
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
name|clear_pmop
label|:
name|cPMOPo
operator|->
name|op_pmreplroot
operator|=
name|Nullop
expr_stmt|;
name|ReREFCNT_dec
argument_list|(
name|cPMOPo
operator|->
name|op_pmregexp
argument_list|)
expr_stmt|;
name|cPMOPo
operator|->
name|op_pmregexp
operator|=
operator|(
name|REGEXP
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|o
operator|->
name|op_targ
operator|>
literal|0
condition|)
block|{
name|pad_free
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|S_cop_free
parameter_list|(
name|pTHX_
name|COP
modifier|*
name|cop
parameter_list|)
block|{
name|Safefree
argument_list|(
name|cop
operator|->
name|cop_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|Safefree
argument_list|(
name|CopFILE
argument_list|(
name|cop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX share in a pvtable? */
name|Safefree
argument_list|(
name|CopSTASHPV
argument_list|(
name|cop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX share in a pvtable? */
else|#
directive|else
comment|/* NOTE: COP.cop_stash is not refcounted */
name|SvREFCNT_dec
argument_list|(
name|CopFILEGV
argument_list|(
name|cop
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|specialWARN
argument_list|(
name|cop
operator|->
name|cop_warnings
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|cop
operator|->
name|cop_warnings
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_null
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
return|return;
name|op_clear
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|o
operator|->
name|op_type
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_NULL
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_NULL
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Contextualizers */
end_comment

begin_define
define|#
directive|define
name|LINKLIST
parameter_list|(
name|o
parameter_list|)
value|((o)->op_next ? (o)->op_next : linklist((OP*)o))
end_define

begin_function
name|OP
modifier|*
name|Perl_linklist
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_next
condition|)
return|return
name|o
operator|->
name|op_next
return|;
comment|/* establish postfix order */
if|if
condition|(
name|cUNOPo
operator|->
name|op_first
condition|)
block|{
name|o
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|kid
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|kid
operator|->
name|op_sibling
argument_list|)
expr_stmt|;
else|else
name|kid
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
block|}
block|}
else|else
name|o
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
return|return
name|o
operator|->
name|op_next
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_scalarkids
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_scalarboolean
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SASSIGN
operator|&&
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_copline
operator|!=
name|NOLINE
condition|)
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"Found = in conditional, should be =="
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_scalar
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
comment|/* assumes no premature commitment */
if|if
condition|(
operator|!
name|o
operator|||
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
block|{
return|return
name|o
return|;
block|}
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_SCALAR
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_REPEAT
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
name|OPpREPEAT_DOLIST
condition|)
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cBINOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|scalar
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SPLIT
case|:
if|if
condition|(
operator|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|)
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|!
name|kPMOP
operator|->
name|op_pmreplroot
condition|)
name|deprecate
argument_list|(
literal|"implicit split to @_"
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_NULL
case|:
default|default:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
operator|)
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_scalarvoid
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|char
modifier|*
name|useless
init|=
literal|0
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|U8
name|want
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_SETSTATE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_DBSTATE
operator|||
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
operator|(
name|o
operator|->
name|op_targ
operator|==
name|OP_NEXTSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_SETSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_DBSTATE
operator|)
operator|)
condition|)
name|PL_curcop
operator|=
operator|(
name|COP
operator|*
operator|)
name|o
expr_stmt|;
comment|/* for warning below */
comment|/* assumes no premature commitment */
name|want
operator|=
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
expr_stmt|;
if|if
condition|(
operator|(
name|want
operator|&&
name|want
operator|!=
name|OPf_WANT_SCALAR
operator|)
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
block|{
return|return
name|o
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpTARGET_MY
operator|)
operator|&&
operator|(
name|PL_opargs
index|[
name|o
operator|->
name|op_type
index|]
operator|&
name|OA_TARGLEX
operator|)
condition|)
comment|/* OPp share the meaning */
block|{
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
comment|/* As if inside SASSIGN */
block|}
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_VOID
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
default|default:
if|if
condition|(
operator|!
operator|(
name|PL_opargs
index|[
name|o
operator|->
name|op_type
index|]
operator|&
name|OA_FOLDCONST
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_REPEAT
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
break|break;
goto|goto
name|func_ops
goto|;
case|case
name|OP_SUBSTR
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|==
literal|4
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_GVSV
case|:
case|case
name|OP_WANTARRAY
case|:
case|case
name|OP_GV
case|:
case|case
name|OP_PADSV
case|:
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
case|case
name|OP_PADANY
case|:
case|case
name|OP_AV2ARYLEN
case|:
case|case
name|OP_REF
case|:
case|case
name|OP_REFGEN
case|:
case|case
name|OP_SREFGEN
case|:
case|case
name|OP_DEFINED
case|:
case|case
name|OP_HEX
case|:
case|case
name|OP_OCT
case|:
case|case
name|OP_LENGTH
case|:
case|case
name|OP_VEC
case|:
case|case
name|OP_INDEX
case|:
case|case
name|OP_RINDEX
case|:
case|case
name|OP_SPRINTF
case|:
case|case
name|OP_AELEM
case|:
case|case
name|OP_AELEMFAST
case|:
case|case
name|OP_ASLICE
case|:
case|case
name|OP_HELEM
case|:
case|case
name|OP_HSLICE
case|:
case|case
name|OP_UNPACK
case|:
case|case
name|OP_PACK
case|:
case|case
name|OP_JOIN
case|:
case|case
name|OP_LSLICE
case|:
case|case
name|OP_ANONLIST
case|:
case|case
name|OP_ANONHASH
case|:
case|case
name|OP_SORT
case|:
case|case
name|OP_REVERSE
case|:
case|case
name|OP_RANGE
case|:
case|case
name|OP_FLIP
case|:
case|case
name|OP_FLOP
case|:
case|case
name|OP_CALLER
case|:
case|case
name|OP_FILENO
case|:
case|case
name|OP_EOF
case|:
case|case
name|OP_TELL
case|:
case|case
name|OP_GETSOCKNAME
case|:
case|case
name|OP_GETPEERNAME
case|:
case|case
name|OP_READLINK
case|:
case|case
name|OP_TELLDIR
case|:
case|case
name|OP_GETPPID
case|:
case|case
name|OP_GETPGRP
case|:
case|case
name|OP_GETPRIORITY
case|:
case|case
name|OP_TIME
case|:
case|case
name|OP_TMS
case|:
case|case
name|OP_LOCALTIME
case|:
case|case
name|OP_GMTIME
case|:
case|case
name|OP_GHBYNAME
case|:
case|case
name|OP_GHBYADDR
case|:
case|case
name|OP_GHOSTENT
case|:
case|case
name|OP_GNBYNAME
case|:
case|case
name|OP_GNBYADDR
case|:
case|case
name|OP_GNETENT
case|:
case|case
name|OP_GPBYNAME
case|:
case|case
name|OP_GPBYNUMBER
case|:
case|case
name|OP_GPROTOENT
case|:
case|case
name|OP_GSBYNAME
case|:
case|case
name|OP_GSBYPORT
case|:
case|case
name|OP_GSERVENT
case|:
case|case
name|OP_GPWNAM
case|:
case|case
name|OP_GPWUID
case|:
case|case
name|OP_GGRNAM
case|:
case|case
name|OP_GGRGID
case|:
case|case
name|OP_GETLOGIN
case|:
name|func_ops
label|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpOUR_INTRO
operator|)
operator|)
condition|)
name|useless
operator|=
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
expr_stmt|;
break|break;
case|case
name|OP_RV2GV
case|:
case|case
name|OP_RV2SV
case|:
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpOUR_INTRO
operator|)
operator|)
operator|&&
operator|(
operator|!
name|o
operator|->
name|op_sibling
operator|||
name|o
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_READLINE
operator|)
condition|)
name|useless
operator|=
literal|"a variable"
expr_stmt|;
break|break;
case|case
name|OP_CONST
case|:
name|sv
operator|=
name|cSVOPo_sv
expr_stmt|;
if|if
condition|(
name|cSVOPo
operator|->
name|op_private
operator|&
name|OPpCONST_STRICT
condition|)
name|no_bareword_allowed
argument_list|(
name|o
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
block|{
name|useless
operator|=
literal|"a constant"
expr_stmt|;
if|if
condition|(
name|SvNIOK
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|==
literal|0.0
operator|||
name|SvNV
argument_list|(
name|sv
argument_list|)
operator|==
literal|1.0
operator|)
condition|)
name|useless
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"di"
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"ds"
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"ig"
argument_list|,
literal|2
argument_list|)
condition|)
name|useless
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* don't execute or even remember it */
break|break;
case|case
name|OP_POSTINC
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PREINC
expr_stmt|;
comment|/* pre-increment is faster */
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PREINC
index|]
expr_stmt|;
break|break;
case|case
name|OP_POSTDEC
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PREDEC
expr_stmt|;
comment|/* pre-decrement is faster */
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PREDEC
index|]
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NULL
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
case|case
name|OP_ENTERTRY
case|:
case|case
name|OP_ENTER
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
case|case
name|OP_LEAVELOOP
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ENTEREVAL
case|:
name|scalarkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REQUIRE
case|:
comment|/* all requires must return a boolean value */
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_SCALAR
case|:
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
case|case
name|OP_SPLIT
case|:
if|if
condition|(
operator|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|)
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|!
name|kPMOP
operator|->
name|op_pmreplroot
condition|)
name|deprecate
argument_list|(
literal|"implicit split to @_"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|useless
operator|&&
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_VOID
argument_list|,
literal|"Useless use of %s in void context"
argument_list|,
argument|useless
argument_list|)
empty_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_listkids
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_list
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
comment|/* assumes no premature commitment */
if|if
condition|(
operator|!
name|o
operator|||
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|||
name|PL_error_count
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RETURN
condition|)
block|{
return|return
name|o
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpTARGET_MY
operator|)
operator|&&
operator|(
name|PL_opargs
index|[
name|o
operator|->
name|op_type
index|]
operator|&
name|OA_TARGLEX
operator|)
condition|)
comment|/* OPp share the meaning */
block|{
return|return
name|o
return|;
comment|/* As if inside SASSIGN */
block|}
name|o
operator|->
name|op_flags
operator|=
operator|(
name|o
operator|->
name|op_flags
operator|&
operator|~
name|OPf_WANT
operator|)
operator||
name|OPf_WANT_LIST
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_FLOP
case|:
case|case
name|OP_REPEAT
case|:
name|list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_OR
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|OP_MATCH
case|:
case|case
name|OP_QR
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|o
operator|->
name|op_next
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_FLOP
condition|)
block|{
name|list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
return|return
name|gen_constant_list
argument_list|(
name|o
argument_list|)
return|;
block|}
case|case
name|OP_LIST
case|:
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LEAVE
case|:
case|case
name|OP_LEAVETRY
case|:
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
operator|)
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LINESEQ
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
name|WITH_THR
argument_list|(
name|PL_curcop
operator|=
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REQUIRE
case|:
comment|/* all requires must return a boolean value */
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_scalarseq
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_LEAVETRY
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
block|{
name|scalarvoid
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
block|}
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_PARENS
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_BLOCK_SCOPE
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_PARENS
expr_stmt|;
block|}
else|else
name|o
operator|=
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_modkids
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_mod
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpTARGET_MY
operator|)
operator|&&
operator|(
name|PL_opargs
index|[
name|o
operator|->
name|op_type
index|]
operator|&
name|OA_TARGLEX
operator|)
condition|)
comment|/* OPp share the meaning */
block|{
return|return
name|o
return|;
block|}
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_UNDEF
case|:
name|PL_modcount
operator|++
expr_stmt|;
return|return
name|o
return|;
case|case
name|OP_CONST
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpCONST_BARE
operator|)
operator|&&
operator|!
operator|(
name|type
operator|==
name|OP_GREPSTART
operator|||
name|type
operator|==
name|OP_ENTERSUB
operator|||
name|type
operator|==
name|OP_REFGEN
operator|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_sv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
comment|/* Could be a filehandle */
if|if
condition|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
condition|)
block|{
name|OP
modifier|*
name|gvio
init|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|gvio
expr_stmt|;
block|}
else|else
block|{
comment|/* OK, it's a sub */
name|OP
modifier|*
name|enter
decl_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|enter
operator|=
name|newUNOP
argument_list|(
name|OP_ENTERSUB
argument_list|,
literal|0
argument_list|,
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|enter
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|enter
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpCONST_ARYBASE
operator|)
operator|)
condition|)
goto|goto
name|nomod
goto|;
if|if
condition|(
name|PL_eval_start
operator|&&
name|PL_eval_start
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|PL_compiling
operator|.
name|cop_arybase
operator|=
operator|(
name|I32
operator|)
name|SvIV
argument_list|(
name|cSVOPx
argument_list|(
name|PL_eval_start
argument_list|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|SAVEI32
argument_list|(
name|PL_compiling
operator|.
name|cop_arybase
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_arybase
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
condition|)
goto|goto
name|nomod
goto|;
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"That use of $[ is unsupported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STUB
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
break|break;
goto|goto
name|nomod
goto|;
case|case
name|OP_ENTERSUB
case|:
if|if
condition|(
operator|(
name|type
operator|==
name|OP_UNDEF
operator|||
name|type
operator|==
name|OP_REFGEN
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
comment|/* entersub => rv2cv */
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|assert
argument_list|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_NULL
argument_list|)
expr_stmt|;
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
comment|/* disable pushmark */
break|break;
block|}
else|else
block|{
comment|/* lvalue subroutine call */
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
name|PL_modcount
operator|=
name|RETURN_UNLIMITED_NUMBER
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_GREPSTART
operator|||
name|type
operator|==
name|OP_ENTERSUB
operator|||
name|type
operator|==
name|OP_REFGEN
condition|)
block|{
comment|/* Backward compatibility mode: */
name|o
operator|->
name|op_private
operator||=
name|OPpENTERSUB_INARGS
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Compile-time error message: */
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|OP
modifier|*
name|okid
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHMARK
condition|)
goto|goto
name|skip_kids
goto|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_NULL
operator|||
name|kid
operator|->
name|op_targ
operator|!=
name|OP_LIST
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: unexpected lvalue entersub "
literal|"args: type/targ %ld:%ld"
argument_list|,
operator|(
name|long
operator|)
name|kid
operator|->
name|op_type
argument_list|,
name|kid
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kLISTOP
operator|->
name|op_first
expr_stmt|;
name|skip_kids
label|:
while|while
condition|(
name|kid
operator|->
name|op_sibling
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|kid
operator|->
name|op_targ
operator|==
name|OP_RV2CV
operator|)
condition|)
block|{
comment|/* Indirect call */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_METHOD_NAMED
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_METHOD
condition|)
block|{
name|UNOP
modifier|*
name|newop
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_sibling
operator|||
name|kid
operator|->
name|op_next
operator|!=
name|kid
condition|)
block|{
name|yyerror
argument_list|(
literal|"panic: unexpected optree near method call"
argument_list|)
expr_stmt|;
break|break;
block|}
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|newop
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|newop
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
name|newop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|newop
operator|->
name|op_first
operator|=
name|Nullop
expr_stmt|;
name|newop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
operator|(
name|OP
operator|*
operator|)
name|newop
expr_stmt|;
name|newop
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2CV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: unexpected lvalue entersub "
literal|"entry via type/targ %ld:%ld"
argument_list|,
operator|(
name|long
operator|)
name|kid
operator|->
name|op_type
argument_list|,
name|kid
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
break|break;
comment|/* Postpone until runtime */
block|}
name|okid
operator|=
name|kid
expr_stmt|;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|kid
operator|->
name|op_targ
operator|==
name|OP_RV2SV
condition|)
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unexpected constant lvalue entersub "
literal|"entry via type/targ %ld:%ld"
argument_list|,
operator|(
name|long
operator|)
name|kid
operator|->
name|op_type
argument_list|,
name|kid
operator|->
name|op_targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
block|{
comment|/* Restore RV2CV to check lvalueness */
name|restore_2cv
label|:
if|if
condition|(
name|kid
operator|->
name|op_next
operator|&&
name|kid
operator|->
name|op_next
operator|!=
name|kid
condition|)
block|{
comment|/* Happens? */
name|okid
operator|->
name|op_next
operator|=
name|kid
operator|->
name|op_next
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
name|okid
expr_stmt|;
block|}
else|else
name|okid
operator|->
name|op_next
operator|=
name|Nullop
expr_stmt|;
name|okid
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
name|okid
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
name|okid
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|okid
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
break|break;
block|}
name|cv
operator|=
name|GvCV
argument_list|(
name|kGVOP_gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
goto|goto
name|restore_2cv
goto|;
if|if
condition|(
name|CvLVALUE
argument_list|(
name|cv
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* FALL THROUGH */
default|default:
name|nomod
label|:
comment|/* grep, foreach, subcalls, refgen */
if|if
condition|(
name|type
operator|==
name|OP_GREPSTART
operator|||
name|type
operator|==
name|OP_ENTERSUB
operator|||
name|type
operator|==
name|OP_REFGEN
condition|)
break|break;
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Can't modify %s in %s"
argument_list|,
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|?
literal|"do block"
else|:
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
condition|?
literal|"non-lvalue subroutine call"
else|:
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
operator|)
operator|)
argument_list|,
name|type
condition|?
name|PL_op_desc
index|[
name|type
index|]
else|:
literal|"local"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
case|case
name|OP_PREINC
case|:
case|case
name|OP_PREDEC
case|:
case|case
name|OP_POW
case|:
case|case
name|OP_MULTIPLY
case|:
case|case
name|OP_DIVIDE
case|:
case|case
name|OP_MODULO
case|:
case|case
name|OP_REPEAT
case|:
case|case
name|OP_ADD
case|:
case|case
name|OP_SUBTRACT
case|:
case|case
name|OP_CONCAT
case|:
case|case
name|OP_LEFT_SHIFT
case|:
case|case
name|OP_RIGHT_SHIFT
case|:
case|case
name|OP_BIT_AND
case|:
case|case
name|OP_BIT_XOR
case|:
case|case
name|OP_BIT_OR
case|:
case|case
name|OP_I_MULTIPLY
case|:
case|case
name|OP_I_DIVIDE
case|:
case|case
name|OP_I_MODULO
case|:
case|case
name|OP_I_ADD
case|:
case|case
name|OP_I_SUBTRACT
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
goto|goto
name|nomod
goto|;
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
if|if
condition|(
operator|!
name|type
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't localize through a reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
block|{
name|PL_modcount
operator|=
name|RETURN_UNLIMITED_NUMBER
expr_stmt|;
return|return
name|o
return|;
comment|/* Treat \(@foo) like ordinary list. */
block|}
comment|/* FALL THROUGH */
case|case
name|OP_RV2GV
case|:
if|if
condition|(
name|scalar_mod_type
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|nomod
goto|;
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_ASLICE
case|:
case|case
name|OP_HSLICE
case|:
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpMAYBE_LVSUB
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_AASSIGN
case|:
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
case|case
name|OP_CHOMP
case|:
name|PL_modcount
operator|=
name|RETURN_UNLIMITED_NUMBER
expr_stmt|;
break|break;
case|case
name|OP_RV2SV
case|:
if|if
condition|(
operator|!
name|type
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't localize through a reference"
argument_list|)
expr_stmt|;
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_GV
case|:
case|case
name|OP_AV2ARYLEN
case|:
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
case|case
name|OP_SASSIGN
case|:
case|case
name|OP_ANDASSIGN
case|:
case|case
name|OP_ORASSIGN
case|:
case|case
name|OP_AELEMFAST
case|:
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
name|PL_modcount
operator|=
name|RETURN_UNLIMITED_NUMBER
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_REFGEN
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
return|return
name|o
return|;
comment|/* Treat \(@foo) like ordinary list. */
if|if
condition|(
name|scalar_mod_type
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|nomod
goto|;
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpMAYBE_LVSUB
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_PADSV
case|:
name|PL_modcount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't localize lexical variable %s"
argument_list|,
name|SvPV
argument_list|(
operator|*
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|o
operator|->
name|op_targ
argument_list|,
literal|4
argument_list|)
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
name|OP_THREADSV
case|:
name|PL_modcount
operator|++
expr_stmt|;
comment|/* XXX ??? */
break|break;
endif|#
directive|endif
comment|/* USE_THREADS */
case|case
name|OP_PUSHMARK
case|:
break|break;
case|case
name|OP_KEYS
case|:
if|if
condition|(
name|type
operator|!=
name|OP_SASSIGN
condition|)
goto|goto
name|nomod
goto|;
goto|goto
name|lvalue_func
goto|;
case|case
name|OP_SUBSTR
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|==
literal|4
condition|)
comment|/* don't allow 4 arg substr as lvalue */
goto|goto
name|nomod
goto|;
comment|/* FALL THROUGH */
case|case
name|OP_POS
case|:
case|case
name|OP_VEC
case|:
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpMAYBE_LVSUB
expr_stmt|;
name|lvalue_func
label|:
name|pad_free
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|PAD_SV
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
argument_list|)
operator|==
name|SVt_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|mod
argument_list|(
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_sibling
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_AELEM
case|:
case|case
name|OP_HELEM
case|:
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_ENTERSUB
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpDEREF
operator|)
operator|)
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_DEFER
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpMAYBE_LVSUB
expr_stmt|;
name|PL_modcount
operator|++
expr_stmt|;
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_ENTER
case|:
case|case
name|OP_LINESEQ
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|mod
argument_list|(
name|cLISTOPo
operator|->
name|op_last
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NULL
case|:
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
condition|)
comment|/* do BLOCK */
goto|goto
name|nomod
goto|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
if|if
condition|(
name|o
operator|->
name|op_targ
operator|!=
name|OP_LIST
condition|)
block|{
name|mod
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|OP_LIST
case|:
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RETURN
case|:
if|if
condition|(
name|type
operator|!=
name|OP_LEAVESUBLV
condition|)
goto|goto
name|nomod
goto|;
break|break;
comment|/* mod()ing was handled by ck_return() */
block|}
if|if
condition|(
name|type
operator|!=
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_AASSIGN
operator|||
name|type
operator|==
name|OP_SASSIGN
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
operator||
name|OPf_REF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_SPECIAL
expr_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|OP_GREPSTART
operator|&&
name|type
operator|!=
name|OP_ENTERSUB
operator|&&
name|type
operator|!=
name|OP_LEAVESUBLV
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|bool
name|S_scalar_mod_type
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
return|return
name|FALSE
return|;
comment|/* FALL THROUGH */
case|case
name|OP_PREINC
case|:
case|case
name|OP_PREDEC
case|:
case|case
name|OP_POSTINC
case|:
case|case
name|OP_POSTDEC
case|:
case|case
name|OP_I_PREINC
case|:
case|case
name|OP_I_PREDEC
case|:
case|case
name|OP_I_POSTINC
case|:
case|case
name|OP_I_POSTDEC
case|:
case|case
name|OP_POW
case|:
case|case
name|OP_MULTIPLY
case|:
case|case
name|OP_DIVIDE
case|:
case|case
name|OP_MODULO
case|:
case|case
name|OP_REPEAT
case|:
case|case
name|OP_ADD
case|:
case|case
name|OP_SUBTRACT
case|:
case|case
name|OP_I_MULTIPLY
case|:
case|case
name|OP_I_DIVIDE
case|:
case|case
name|OP_I_MODULO
case|:
case|case
name|OP_I_ADD
case|:
case|case
name|OP_I_SUBTRACT
case|:
case|case
name|OP_LEFT_SHIFT
case|:
case|case
name|OP_RIGHT_SHIFT
case|:
case|case
name|OP_BIT_AND
case|:
case|case
name|OP_BIT_XOR
case|:
case|case
name|OP_BIT_OR
case|:
case|case
name|OP_CONCAT
case|:
case|case
name|OP_SUBST
case|:
case|case
name|OP_TRANS
case|:
case|case
name|OP_READ
case|:
case|case
name|OP_SYSREAD
case|:
case|case
name|OP_RECV
case|:
case|case
name|OP_ANDASSIGN
case|:
case|case
name|OP_ORASSIGN
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|STATIC
name|bool
name|S_is_handle_constructor
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|argnum
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_PIPE_OP
case|:
case|case
name|OP_SOCKPAIR
case|:
if|if
condition|(
name|argnum
operator|==
literal|2
condition|)
return|return
name|TRUE
return|;
comment|/* FALL THROUGH */
case|case
name|OP_SYSOPEN
case|:
case|case
name|OP_OPEN
case|:
case|case
name|OP_SELECT
case|:
comment|/* XXX c.f. SelectSaver.pm */
case|case
name|OP_SOCKET
case|:
case|case
name|OP_OPEN_DIR
case|:
case|case
name|OP_ACCEPT
case|:
if|if
condition|(
name|argnum
operator|==
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* FALL THROUGH */
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_refkids
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|ref
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ref
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|type
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_ENTERSUB
case|:
if|if
condition|(
operator|(
name|type
operator|==
name|OP_EXISTS
operator|||
name|type
operator|==
name|OP_DEFINED
operator|||
name|type
operator|==
name|OP_LOCK
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_RV2CV
expr_stmt|;
comment|/* entersub => rv2cv */
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2CV
index|]
expr_stmt|;
name|assert
argument_list|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_NULL
argument_list|)
expr_stmt|;
name|null
argument_list|(
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_first
argument_list|)
expr_stmt|;
comment|/* disable pushmark */
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
block|}
break|break;
case|case
name|OP_COND_EXPR
case|:
for|for
control|(
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|ref
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RV2SV
case|:
if|if
condition|(
name|type
operator|==
name|OP_DEFINED
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* don't create GV */
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_PADSV
case|:
if|if
condition|(
name|type
operator|==
name|OP_RV2SV
operator|||
name|type
operator|==
name|OP_RV2AV
operator|||
name|type
operator|==
name|OP_RV2HV
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
operator|(
name|type
operator|==
name|OP_RV2AV
condition|?
name|OPpDEREF_AV
else|:
name|type
operator|==
name|OP_RV2HV
condition|?
name|OPpDEREF_HV
else|:
name|OPpDEREF_SV
operator|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
block|}
break|break;
case|case
name|OP_THREADSV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
comment|/* XXX ??? */
break|break;
case|case
name|OP_RV2AV
case|:
case|case
name|OP_RV2HV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_RV2GV
case|:
if|if
condition|(
name|type
operator|==
name|OP_DEFINED
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* don't create GV */
name|ref
argument_list|(
name|cUNOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PADAV
case|:
case|case
name|OP_PADHV
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_REF
expr_stmt|;
break|break;
case|case
name|OP_SCALAR
case|:
case|case
name|OP_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_AELEM
case|:
case|case
name|OP_HELEM
case|:
name|ref
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_RV2SV
operator|||
name|type
operator|==
name|OP_RV2AV
operator|||
name|type
operator|==
name|OP_RV2HV
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
operator|(
name|type
operator|==
name|OP_RV2AV
condition|?
name|OPpDEREF_AV
else|:
name|type
operator|==
name|OP_RV2HV
condition|?
name|OPpDEREF_HV
else|:
name|OPpDEREF_SV
operator|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
block|}
break|break;
case|case
name|OP_SCOPE
case|:
case|case
name|OP_LEAVE
case|:
case|case
name|OP_ENTER
case|:
case|case
name|OP_LIST
case|:
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
break|break;
name|ref
argument_list|(
name|cLISTOPo
operator|->
name|op_last
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|scalar
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_dup_attrlist
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|rop
init|=
name|Nullop
decl_stmt|;
comment|/* An attrlist is either a simple OP_CONST or an OP_LIST with kids,      * where the first kid is OP_PUSHMARK and the remaining ones      * are OP_CONST.  We need to push the OP_CONST values.      */
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|rop
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
name|o
operator|->
name|op_flags
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_LIST
operator|)
operator|&&
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|rop
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|rop
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
name|o
operator|->
name|op_flags
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rop
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_apply_attrs
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
name|SV
modifier|*
name|target
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|)
block|{
name|SV
modifier|*
name|stashsv
decl_stmt|;
comment|/* fake up C<use attributes $pkg,$rv,@attrs> */
name|ENTER
expr_stmt|;
comment|/* need to protect against side-effects of 'use' */
name|SAVEINT
argument_list|(
name|PL_expect
argument_list|)
expr_stmt|;
if|if
condition|(
name|stash
operator|&&
name|HvNAME
argument_list|(
name|stash
argument_list|)
condition|)
name|stashsv
operator|=
name|newSVpv
argument_list|(
name|HvNAME
argument_list|(
name|stash
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|stashsv
operator|=
operator|&
name|PL_sv_no
expr_stmt|;
define|#
directive|define
name|ATTRSMODULE
value|"attributes"
name|Perl_load_module
argument_list|(
argument|aTHX_ PERL_LOADMOD_IMPORT_OPS
argument_list|,
argument|newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-
literal|1
argument|)
argument_list|,
argument|Nullsv
argument_list|,
argument|prepend_elem(OP_LIST, 				  newSVOP(OP_CONST,
literal|0
argument|, stashsv), 				  prepend_elem(OP_LIST, 					       newSVOP(OP_CONST,
literal|0
argument|, 						       newRV(target)), 					       dup_attrlist(attrs)))
argument_list|)
empty_stmt|;
name|LEAVE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_apply_attrs_string
parameter_list|(
name|pTHX_
name|char
modifier|*
name|stashpv
parameter_list|,
name|CV
modifier|*
name|cv
parameter_list|,
name|char
modifier|*
name|attrstr
parameter_list|,
name|STRLEN
name|len
parameter_list|)
block|{
name|OP
modifier|*
name|attrs
init|=
name|Nullop
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|attrstr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
condition|)
block|{
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|attrstr
argument_list|)
operator|&&
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|attrstr
control|)
empty_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|char
modifier|*
name|sstr
init|=
name|attrstr
decl_stmt|;
for|for
control|(
init|;
operator|!
name|isSPACE
argument_list|(
operator|*
name|attrstr
argument_list|)
operator|&&
name|len
condition|;
operator|--
name|len
operator|,
operator|++
name|attrstr
control|)
empty_stmt|;
name|attrs
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|attrs
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
name|sstr
argument_list|,
name|attrstr
operator|-
name|sstr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Perl_load_module
argument_list|(
argument|aTHX_ PERL_LOADMOD_IMPORT_OPS
argument_list|,
argument|newSVpvn(ATTRSMODULE, sizeof(ATTRSMODULE)-
literal|1
argument|)
argument_list|,
argument|Nullsv
argument_list|,
argument|prepend_elem(OP_LIST, 				  newSVOP(OP_CONST,
literal|0
argument|, newSVpv(stashpv,
literal|0
argument|)), 				  prepend_elem(OP_LIST, 					       newSVOP(OP_CONST,
literal|0
argument|, 						       newRV((SV*)cv)),                                                attrs))
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_my_kid
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|I32
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|PL_error_count
condition|)
return|return
name|o
return|;
name|type
operator|=
name|o
operator|->
name|op_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|my_kid
argument_list|(
name|kid
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_UNDEF
condition|)
block|{
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OP_RV2SV
operator|||
comment|/* "our" declaration */
name|type
operator|==
name|OP_RV2AV
operator|||
name|type
operator|==
name|OP_RV2HV
condition|)
block|{
comment|/* XXX does this let anything illegal in? */
name|o
operator|->
name|op_private
operator||=
name|OPpOUR_INTRO
expr_stmt|;
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|OP_PADSV
operator|&&
name|type
operator|!=
name|OP_PADAV
operator|&&
name|type
operator|!=
name|OP_PADHV
operator|&&
name|type
operator|!=
name|OP_PUSHMARK
condition|)
block|{
name|yyerror
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"Can't declare %s in \"%s\""
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|,
name|PL_in_my
operator|==
name|KEY_our
condition|?
literal|"our"
else|:
literal|"my"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|attrs
operator|&&
name|type
operator|!=
name|OP_PUSHMARK
condition|)
block|{
name|HV
modifier|*
name|stash
decl_stmt|;
name|SV
modifier|*
name|padsv
decl_stmt|;
name|SV
modifier|*
modifier|*
name|namesvp
decl_stmt|;
name|PL_in_my
operator|=
name|FALSE
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
comment|/* check for C<my Dog $spot> when deciding package */
name|namesvp
operator|=
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|o
operator|->
name|op_targ
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|namesvp
operator|&&
operator|*
name|namesvp
operator|&&
name|SvOBJECT
argument_list|(
operator|*
name|namesvp
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
operator|*
name|namesvp
argument_list|)
argument_list|)
condition|)
name|stash
operator|=
name|SvSTASH
argument_list|(
operator|*
name|namesvp
argument_list|)
expr_stmt|;
else|else
name|stash
operator|=
name|PL_curstash
expr_stmt|;
name|padsv
operator|=
name|PAD_SV
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
name|apply_attrs
argument_list|(
name|stash
argument_list|,
name|padsv
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|OPpLVAL_INTRO
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_my_attrs
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
name|list
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|SAVEFREEOP
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|o
operator|=
name|my_kid
argument_list|(
name|o
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|PL_in_my
operator|=
name|FALSE
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_my
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|my_kid
argument_list|(
name|o
argument_list|,
name|Nullop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_sawparens
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_PARENS
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_bind_match
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
operator|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|)
condition|)
block|{
name|char
modifier|*
name|desc
init|=
name|PL_op_desc
index|[
operator|(
name|right
operator|->
name|op_type
operator|==
name|OP_SUBST
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
operator|)
condition|?
name|right
operator|->
name|op_type
else|:
name|OP_MATCH
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|sample
init|=
operator|(
operator|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|left
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|)
condition|?
literal|"@array"
else|:
literal|"%hash"
operator|)
decl_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Applying %s to %s will act on scalar(%s)"
argument_list|,
argument|desc
argument_list|,
argument|sample
argument_list|,
argument|sample
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|right
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
name|right
operator|->
name|op_type
operator|==
name|OP_MATCH
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_SUBST
operator|||
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
operator|)
condition|)
block|{
name|right
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|!=
name|OP_MATCH
operator|&&
operator|!
operator|(
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
operator|&&
name|right
operator|->
name|op_private
operator|&
name|OPpTRANS_IDENTICAL
operator|)
condition|)
name|left
operator|=
name|mod
argument_list|(
name|left
argument_list|,
name|right
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|==
name|OP_TRANS
condition|)
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_NULL
argument_list|,
name|OPf_STACKED
argument_list|,
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|prepend_elem
argument_list|(
name|right
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_NOT
condition|)
return|return
name|newUNOP
argument_list|(
name|OP_NOT
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
return|return
name|o
return|;
block|}
else|else
return|return
name|bind_match
argument_list|(
name|type
argument_list|,
name|left
argument_list|,
name|pmruntime
argument_list|(
name|newPMOP
argument_list|(
name|OP_MATCH
argument_list|,
literal|0
argument_list|)
argument_list|,
name|right
argument_list|,
name|Nullop
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_invert
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|o
return|;
comment|/* XXX need to optimize away NOT NOT here?  Or do we let optimizer do it? */
return|return
name|newUNOP
argument_list|(
name|OP_NOT
argument_list|,
name|OPf_SPECIAL
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_scope
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|||
name|PERLDB_NOOPT
operator|||
name|PL_tainting
condition|)
block|{
name|o
operator|=
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|newOP
argument_list|(
name|OP_ENTER
argument_list|,
literal|0
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LEAVE
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_LEAVE
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
condition|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_SCOPE
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_SCOPE
index|]
expr_stmt|;
name|kid
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_DBSTATE
condition|)
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_SCOPE
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|void
name|Perl_save_hints
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|SAVEI32
argument_list|(
name|PL_hints
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
operator|=
name|newHVhv
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|Perl_block_start
parameter_list|(
name|pTHX_
name|int
name|full
parameter_list|)
block|{
name|int
name|retval
init|=
name|PL_savestack_ix
decl_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_floor
argument_list|)
expr_stmt|;
name|PL_comppad_name_floor
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
condition|)
name|PL_comppad_name_fill
operator|=
name|PL_comppad_name_floor
expr_stmt|;
if|if
condition|(
name|PL_comppad_name_floor
operator|<
literal|0
condition|)
name|PL_comppad_name_floor
operator|=
literal|0
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_min_intro_pending
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_max_intro_pending
argument_list|)
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_padix_floor
argument_list|)
expr_stmt|;
name|PL_padix_floor
operator|=
name|PL_padix
expr_stmt|;
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|&=
operator|~
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|specialWARN
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
condition|)
block|{
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|newSVsv
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
name|SAVEFREESV
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_block_end
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|seq
parameter_list|)
block|{
name|int
name|needblockscope
init|=
name|PL_hints
operator|&
name|HINT_BLOCK_SCOPE
decl_stmt|;
name|OP
modifier|*
name|retval
init|=
name|scalarseq
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
name|PL_pad_reset_pending
operator|=
name|FALSE
expr_stmt|;
name|PL_compiling
operator|.
name|op_private
operator|=
name|PL_hints
expr_stmt|;
if|if
condition|(
name|needblockscope
condition|)
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
comment|/* propagate out */
name|pad_leavemy
argument_list|(
name|PL_comppad_name_fill
argument_list|)
expr_stmt|;
name|PL_cop_seqmax
operator|++
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_newDEFSVOP
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|OP
modifier|*
name|o
init|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
return|return
name|o
return|;
else|#
directive|else
return|return
name|newSVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|PL_defgv
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* USE_THREADS */
block|}
end_function

begin_function
name|void
name|Perl_newPROG
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|PL_in_eval
condition|)
block|{
if|if
condition|(
name|PL_eval_root
condition|)
return|return;
name|PL_eval_root
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVEEVAL
argument_list|,
operator|(
operator|(
name|PL_in_eval
operator|&
name|EVAL_KEEPERR
operator|)
condition|?
name|OPf_SPECIAL
else|:
literal|0
operator|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|PL_eval_start
operator|=
name|linklist
argument_list|(
name|PL_eval_root
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|->
name|op_private
operator||=
name|OPpREFCOUNTED
expr_stmt|;
name|OpREFCNT_set
argument_list|(
name|PL_eval_root
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|PL_eval_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return;
name|PL_main_root
operator|=
name|scope
argument_list|(
name|sawparens
argument_list|(
name|scalarvoid
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_main_start
operator|=
name|LINKLIST
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|->
name|op_private
operator||=
name|OPpREFCOUNTED
expr_stmt|;
name|OpREFCNT_set
argument_list|(
name|PL_main_root
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_main_root
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|PL_main_start
argument_list|)
expr_stmt|;
name|PL_compcv
operator|=
literal|0
expr_stmt|;
comment|/* Register with debugger */
if|if
condition|(
name|PERLDB_INTER
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|get_cv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|CopFILEGV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_localize
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|I32
name|lex
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
name|list
argument_list|(
name|o
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_PARENTHESIS
argument_list|)
operator|&&
name|PL_bufptr
operator|>
name|PL_oldbufptr
operator|&&
name|PL_bufptr
index|[
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|PL_bufptr
init|;
operator|*
name|s
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|UTF8_IS_CONTINUED
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"@$%, "
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PARENTHESIS
argument_list|,
literal|"Parentheses missing around \"%s\" list"
argument_list|,
argument|lex ? (PL_in_my == KEY_our ?
literal|"our"
argument|:
literal|"my"
argument|) :
literal|"local"
argument_list|)
empty_stmt|;
block|}
block|}
if|if
condition|(
name|lex
condition|)
name|o
operator|=
name|my
argument_list|(
name|o
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|mod
argument_list|(
name|o
argument_list|,
name|OP_NULL
argument_list|)
expr_stmt|;
comment|/* a bit kludgey */
name|PL_in_my
operator|=
name|FALSE
expr_stmt|;
name|PL_in_my_stash
operator|=
name|Nullhv
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_jmaybe
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LIST
condition|)
block|{
name|OP
modifier|*
name|o2
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|o2
operator|=
name|newOP
argument_list|(
name|OP_THREADSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o2
operator|->
name|op_targ
operator|=
name|find_threadsv
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
else|#
directive|else
name|o2
operator|=
name|newSVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|";"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
argument_list|)
operator|,
endif|#
directive|endif
comment|/* USE_THREADS */
name|o
operator|=
name|convert
argument_list|(
name|OP_JOIN
argument_list|,
literal|0
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|o2
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_fold_constants
parameter_list|(
name|pTHX_
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|curop
decl_stmt|;
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
operator|&&
operator|!
name|o
operator|->
name|op_targ
condition|)
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
comment|/* integerize op, unless it happens to be C<-foo>.      * XXX should pp_i_negate() do magic string negation instead? */
if|if
condition|(
operator|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_OTHERINT
operator|)
operator|&&
operator|(
name|PL_hints
operator|&
name|HINT_INTEGER
operator|)
operator|&&
operator|!
operator|(
name|type
operator|==
name|OP_NEGATE
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
operator|)
condition|)
block|{
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
operator|=
operator|++
operator|(
name|o
operator|->
name|op_type
operator|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_FOLDCONST
operator|)
condition|)
goto|goto
name|nope
goto|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OP_NEGATE
case|:
comment|/* XXX might want a ck_negate() for this */
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_private
operator|&=
operator|~
name|OPpCONST_STRICT
expr_stmt|;
break|break;
case|case
name|OP_SPRINTF
case|:
case|case
name|OP_UCFIRST
case|:
case|case
name|OP_LCFIRST
case|:
case|case
name|OP_UC
case|:
case|case
name|OP_LC
case|:
case|case
name|OP_SLT
case|:
case|case
name|OP_SGT
case|:
case|case
name|OP_SLE
case|:
case|case
name|OP_SGE
case|:
case|case
name|OP_SCMP
case|:
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
name|OPpLOCALE
condition|)
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
name|PL_error_count
condition|)
goto|goto
name|nope
goto|;
comment|/* Don't try to run w/ errors */
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
init|;
name|curop
operator|!=
name|o
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|curop
operator|->
name|op_type
operator|!=
name|OP_CONST
operator|||
operator|(
name|curop
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
operator|)
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_LIST
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_SCALAR
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_NULL
operator|&&
name|curop
operator|->
name|op_type
operator|!=
name|OP_PUSHMARK
condition|)
block|{
goto|goto
name|nope
goto|;
block|}
block|}
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|PL_op
operator|=
name|curop
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|*
operator|(
name|PL_stack_sp
operator|--
operator|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_targ
operator|&&
name|sv
operator|==
name|PAD_SV
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
condition|)
comment|/* grab pad temp? */
name|pad_swipe
argument_list|(
name|o
operator|->
name|op_targ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvTEMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* grab mortal temp? */
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_RV2GV
condition|)
return|return
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
return|;
else|else
block|{
comment|/* try to smush double to int, but don't smush -2.0 to -2 */
if|if
condition|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVf_POK
operator|)
operator|)
operator|==
name|SVf_NOK
operator|&&
name|type
operator|!=
name|OP_NEGATE
condition|)
block|{
name|IV
name|iv
init|=
name|SvIV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|NV
operator|)
name|iv
operator|==
name|SvNV
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSViv
argument_list|(
name|iv
argument_list|)
expr_stmt|;
block|}
else|else
name|SvIOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* undo SvIV() damage */
block|}
return|return
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
return|;
block|}
name|nope
label|:
if|if
condition|(
operator|!
operator|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_OTHERINT
operator|)
condition|)
return|return
name|o
return|;
if|if
condition|(
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_INTEGER
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_MODULO
operator|||
name|type
operator|==
name|OP_DIVIDE
operator|||
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
return|return
name|o
return|;
block|}
for|for
control|(
name|curop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
init|;
name|curop
condition|;
name|curop
operator|=
name|curop
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
continue|continue;
return|return
name|o
return|;
block|}
if|if
condition|(
name|PL_opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_RETINTEGER
condition|)
continue|continue;
return|return
name|o
return|;
block|}
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
operator|++
operator|(
name|o
operator|->
name|op_type
operator|)
index|]
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_gen_constant_list
parameter_list|(
name|pTHX_
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|curop
decl_stmt|;
name|I32
name|oldtmps_floor
init|=
name|PL_tmps_floor
decl_stmt|;
name|list
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
return|return
name|o
return|;
comment|/* Don't attempt to run with errors */
name|PL_op
operator|=
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|curop
argument_list|)
expr_stmt|;
name|pp_pushmark
argument_list|()
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
name|PL_op
operator|=
name|curop
expr_stmt|;
name|pp_anonlist
argument_list|()
expr_stmt|;
name|PL_tmps_floor
operator|=
name|oldtmps_floor
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|curop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|SvREFCNT_inc
argument_list|(
operator|*
name|PL_stack_sp
operator|--
argument_list|)
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|curop
argument_list|)
expr_stmt|;
name|linklist
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|list
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_convert
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
name|last
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_type
operator|!=
name|OP_LIST
condition|)
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
else|else
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_MARK
operator|)
condition|)
name|null
argument_list|(
name|cLISTOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|=
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|o
return|;
return|return
name|fold_constants
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* List constructors */
end_comment

begin_function
name|OP
modifier|*
name|Perl_append_elem
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
name|first
return|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|!=
name|type
operator|||
operator|(
name|type
operator|==
name|OP_LIST
operator|&&
operator|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|)
operator|)
condition|)
block|{
return|return
name|newLISTOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
return|;
block|}
if|if
condition|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_last
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
else|else
block|{
name|first
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_first
operator|=
name|last
expr_stmt|;
block|}
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_last
operator|=
name|last
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_append_list
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|LISTOP
modifier|*
name|first
parameter_list|,
name|LISTOP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|first
return|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|prepend_elem
argument_list|(
name|type
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|first
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|last
argument_list|)
return|;
if|if
condition|(
name|last
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
name|append_elem
argument_list|(
name|type
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|first
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|last
argument_list|)
return|;
name|first
operator|->
name|op_last
operator|->
name|op_sibling
operator|=
name|last
operator|->
name|op_first
expr_stmt|;
name|first
operator|->
name|op_last
operator|=
name|last
operator|->
name|op_last
expr_stmt|;
name|first
operator|->
name|op_flags
operator||=
operator|(
name|last
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PL_OP_SLAB_ALLOC
else|#
directive|else
name|Safefree
argument_list|(
name|last
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|OP
operator|*
operator|)
name|first
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_prepend_elem
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|last
return|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
name|first
return|;
if|if
condition|(
name|last
operator|->
name|op_type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
comment|/* already a PUSHMARK there */
name|first
operator|->
name|op_sibling
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|last
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_last
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
block|}
name|first
operator|->
name|op_sibling
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
expr_stmt|;
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|last
operator|)
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
block|}
name|last
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
return|return
name|last
return|;
block|}
return|return
name|newLISTOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Constructors */
end_comment

begin_function
name|OP
modifier|*
name|Perl_newNULLLIST
parameter_list|(
name|pTHX
parameter_list|)
block|{
return|return
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_force_list
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_type
operator|!=
name|OP_LIST
condition|)
name|o
operator|=
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newLISTOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
name|LISTOP
modifier|*
name|listop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|listop
argument_list|,
literal|1
argument_list|,
name|LISTOP
argument_list|)
expr_stmt|;
name|listop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|listop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|first
operator|||
name|last
condition|)
name|flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|listop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|last
operator|&&
name|first
condition|)
name|last
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|first
operator|&&
name|last
condition|)
name|first
operator|=
name|last
expr_stmt|;
elseif|else
if|if
condition|(
name|first
condition|)
name|first
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
name|listop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|listop
operator|->
name|op_last
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_LIST
condition|)
block|{
name|OP
modifier|*
name|pushop
decl_stmt|;
name|pushop
operator|=
name|newOP
argument_list|(
name|OP_PUSHMARK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushop
operator|->
name|op_sibling
operator|=
name|first
expr_stmt|;
name|listop
operator|->
name|op_first
operator|=
name|pushop
expr_stmt|;
name|listop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|listop
operator|->
name|op_last
operator|=
name|pushop
expr_stmt|;
block|}
return|return
operator|(
name|OP
operator|*
operator|)
name|listop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|o
argument_list|,
literal|1
argument_list|,
name|OP
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|o
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
operator|+
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|o
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newUNOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|)
block|{
name|UNOP
modifier|*
name|unop
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newOP
argument_list|(
name|OP_STUB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_MARK
condition|)
name|first
operator|=
name|force_list
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|unop
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|unop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|unop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|unop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|unop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|unop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|unop
operator|=
operator|(
name|UNOP
operator|*
operator|)
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|unop
argument_list|)
expr_stmt|;
if|if
condition|(
name|unop
operator|->
name|op_next
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|unop
return|;
return|return
name|fold_constants
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|unop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newBINOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|last
parameter_list|)
block|{
name|BINOP
modifier|*
name|binop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|binop
argument_list|,
literal|1
argument_list|,
name|BINOP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|newOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|binop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|binop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|binop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|last
operator|=
name|first
expr_stmt|;
name|binop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|binop
operator|->
name|op_private
operator|=
literal|2
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|last
expr_stmt|;
block|}
name|binop
operator|=
operator|(
name|BINOP
operator|*
operator|)
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|binop
argument_list|)
expr_stmt|;
if|if
condition|(
name|binop
operator|->
name|op_next
operator|||
name|binop
operator|->
name|op_type
operator|!=
name|type
condition|)
return|return
operator|(
name|OP
operator|*
operator|)
name|binop
return|;
name|binop
operator|->
name|op_last
operator|=
name|binop
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
return|return
name|fold_constants
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|binop
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utf8compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|U8
operator|*
operator|*
operator|)
name|a
operator|)
index|[
name|i
index|]
operator|<
operator|(
operator|*
operator|(
name|U8
operator|*
operator|*
operator|)
name|b
operator|)
index|[
name|i
index|]
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
operator|*
operator|(
name|U8
operator|*
operator|*
operator|)
name|a
operator|)
index|[
name|i
index|]
operator|>
operator|(
operator|*
operator|(
name|U8
operator|*
operator|*
operator|)
name|b
operator|)
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_pmtrans
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|repl
parameter_list|)
block|{
name|SV
modifier|*
name|tstr
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
decl_stmt|;
name|SV
modifier|*
name|rstr
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|repl
operator|)
operator|->
name|op_sv
decl_stmt|;
name|STRLEN
name|tlen
decl_stmt|;
name|STRLEN
name|rlen
decl_stmt|;
name|U8
modifier|*
name|t
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|tstr
argument_list|,
name|tlen
argument_list|)
decl_stmt|;
name|U8
modifier|*
name|r
init|=
operator|(
name|U8
operator|*
operator|)
name|SvPV
argument_list|(
name|rstr
argument_list|,
name|rlen
argument_list|)
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
name|j
decl_stmt|;
name|I32
name|del
decl_stmt|;
name|I32
name|complement
decl_stmt|;
name|I32
name|squash
decl_stmt|;
name|I32
name|grows
init|=
literal|0
decl_stmt|;
specifier|register
name|short
modifier|*
name|tbl
decl_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|complement
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_COMPLEMENT
expr_stmt|;
name|del
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_DELETE
expr_stmt|;
name|squash
operator|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_SQUASH
expr_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|tstr
argument_list|)
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_FROM_UTF
expr_stmt|;
if|if
condition|(
name|SvUTF8
argument_list|(
name|rstr
argument_list|)
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_TO_UTF
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpTRANS_FROM_UTF
operator||
name|OPpTRANS_TO_UTF
operator|)
condition|)
block|{
name|SV
modifier|*
name|listsv
init|=
name|newSVpvn
argument_list|(
literal|"# comment\n"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|transv
init|=
literal|0
decl_stmt|;
name|U8
modifier|*
name|tend
init|=
name|t
operator|+
name|tlen
decl_stmt|;
name|U8
modifier|*
name|rend
init|=
name|r
operator|+
name|rlen
decl_stmt|;
name|STRLEN
name|ulen
decl_stmt|;
name|U32
name|tfirst
init|=
literal|1
decl_stmt|;
name|U32
name|tlast
init|=
literal|0
decl_stmt|;
name|I32
name|tdiff
decl_stmt|;
name|U32
name|rfirst
init|=
literal|1
decl_stmt|;
name|U32
name|rlast
init|=
literal|0
decl_stmt|;
name|I32
name|rdiff
decl_stmt|;
name|I32
name|diff
decl_stmt|;
name|I32
name|none
init|=
literal|0
decl_stmt|;
name|U32
name|max
init|=
literal|0
decl_stmt|;
name|I32
name|bits
decl_stmt|;
name|I32
name|havefinal
init|=
literal|0
decl_stmt|;
name|U32
name|final
decl_stmt|;
name|I32
name|from_utf
init|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_FROM_UTF
decl_stmt|;
name|I32
name|to_utf
init|=
name|o
operator|->
name|op_private
operator|&
name|OPpTRANS_TO_UTF
decl_stmt|;
name|U8
modifier|*
name|tsave
init|=
name|from_utf
condition|?
name|NULL
else|:
name|trlist_upgrade
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tend
argument_list|)
decl_stmt|;
name|U8
modifier|*
name|rsave
init|=
name|to_utf
condition|?
name|NULL
else|:
name|trlist_upgrade
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|rend
argument_list|)
decl_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|U8
modifier|*
modifier|*
name|cp
decl_stmt|;
name|I32
modifier|*
name|cl
decl_stmt|;
name|UV
name|nextmin
init|=
literal|0
decl_stmt|;
name|New
argument_list|(
literal|1109
argument_list|,
name|cp
argument_list|,
name|tlen
argument_list|,
name|U8
operator|*
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|transv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|tend
condition|)
block|{
name|cp
index|[
name|i
operator|++
index|]
operator|=
name|t
expr_stmt|;
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|tend
operator|&&
operator|*
name|t
operator|==
literal|0xff
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|t
operator|+=
name|UTF8SKIP
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|cp
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|U8
operator|*
argument_list|)
argument_list|,
name|utf8compare
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|U8
modifier|*
name|s
init|=
name|cp
index|[
name|j
index|]
decl_stmt|;
name|I32
name|cur
init|=
name|j
operator|<
name|i
operator|-
literal|1
condition|?
name|cp
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|s
else|:
name|tend
operator|-
name|s
decl_stmt|;
name|UV
name|val
init|=
name|utf8_to_uv
argument_list|(
name|s
argument_list|,
name|cur
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|s
operator|+=
name|ulen
expr_stmt|;
name|diff
operator|=
name|val
operator|-
name|nextmin
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|nextmin
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|t
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|1
condition|)
block|{
name|t
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|val
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
literal|"\377"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|t
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|<
name|tend
operator|&&
operator|*
name|s
operator|==
literal|0xff
condition|)
name|val
operator|=
name|utf8_to_uv
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|cur
operator|-
literal|1
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|nextmin
condition|)
name|nextmin
operator|=
name|val
operator|+
literal|1
expr_stmt|;
block|}
name|t
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|nextmin
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|t
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|t
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
literal|"\377"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|transv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmpbuf
argument_list|,
name|t
operator|-
name|tmpbuf
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|transv
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|SvCUR
argument_list|(
name|transv
argument_list|)
expr_stmt|;
name|tend
operator|=
name|t
operator|+
name|tlen
expr_stmt|;
name|Safefree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rlen
operator|&&
operator|!
name|del
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
name|rlen
operator|=
name|tlen
expr_stmt|;
name|rend
operator|=
name|tend
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|squash
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|r
operator|||
operator|(
name|tlen
operator|==
name|rlen
operator|&&
name|memEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
argument_list|,
name|tlen
argument_list|)
operator|)
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_IDENTICAL
expr_stmt|;
block|}
block|}
while|while
condition|(
name|t
operator|<
name|tend
operator|||
name|tfirst
operator|<=
name|tlast
condition|)
block|{
comment|/* see if we need more "t" chars */
if|if
condition|(
name|tfirst
operator|>
name|tlast
condition|)
block|{
name|tfirst
operator|=
operator|(
name|I32
operator|)
name|utf8_to_uv
argument_list|(
name|t
argument_list|,
name|tend
operator|-
name|t
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|+=
name|ulen
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|tend
operator|&&
operator|*
name|t
operator|==
literal|0xff
condition|)
block|{
comment|/* illegal utf8 val indicates range */
name|t
operator|++
expr_stmt|;
name|tlast
operator|=
operator|(
name|I32
operator|)
name|utf8_to_uv
argument_list|(
name|t
argument_list|,
name|tend
operator|-
name|t
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|+=
name|ulen
expr_stmt|;
block|}
else|else
name|tlast
operator|=
name|tfirst
expr_stmt|;
block|}
comment|/* now see if we need more "r" chars */
if|if
condition|(
name|rfirst
operator|>
name|rlast
condition|)
block|{
if|if
condition|(
name|r
operator|<
name|rend
condition|)
block|{
name|rfirst
operator|=
operator|(
name|I32
operator|)
name|utf8_to_uv
argument_list|(
name|r
argument_list|,
name|rend
operator|-
name|r
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|+=
name|ulen
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
operator|&&
operator|*
name|r
operator|==
literal|0xff
condition|)
block|{
comment|/* illegal utf8 val indicates range */
name|r
operator|++
expr_stmt|;
name|rlast
operator|=
operator|(
name|I32
operator|)
name|utf8_to_uv
argument_list|(
name|r
argument_list|,
name|rend
operator|-
name|r
argument_list|,
operator|&
name|ulen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|+=
name|ulen
expr_stmt|;
block|}
else|else
name|rlast
operator|=
name|rfirst
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|havefinal
operator|++
condition|)
name|final
operator|=
name|rlast
expr_stmt|;
name|rfirst
operator|=
name|rlast
operator|=
literal|0xffffffff
expr_stmt|;
block|}
block|}
comment|/* now see which range will peter our first, if either. */
name|tdiff
operator|=
name|tlast
operator|-
name|tfirst
expr_stmt|;
name|rdiff
operator|=
name|rlast
operator|-
name|rfirst
expr_stmt|;
if|if
condition|(
name|tdiff
operator|<=
name|rdiff
condition|)
name|diff
operator|=
name|tdiff
expr_stmt|;
else|else
name|diff
operator|=
name|rdiff
expr_stmt|;
if|if
condition|(
name|rfirst
operator|==
literal|0xffffffff
condition|)
block|{
name|diff
operator|=
name|tdiff
expr_stmt|;
comment|/* oops, pretend rdiff is infinite */
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"%04lx\t%04lx\tXXXX\n"
argument_list|,
argument|(long)tfirst
argument_list|,
argument|(long)tlast
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"%04lx\t\tXXXX\n"
argument_list|,
argument|(long)tfirst
argument_list|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"%04lx\t%04lx\t%04lx\n"
argument_list|,
argument|(long)tfirst
argument_list|,
argument|(long)(tfirst + diff)
argument_list|,
argument|(long)rfirst
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"%04lx\t\t%04lx\n"
argument_list|,
argument|(long)tfirst
argument_list|,
argument|(long)rfirst
argument_list|)
empty_stmt|;
if|if
condition|(
name|rfirst
operator|+
name|diff
operator|>
name|max
condition|)
name|max
operator|=
name|rfirst
operator|+
name|diff
expr_stmt|;
name|rfirst
operator|+=
name|diff
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|grows
condition|)
name|grows
operator|=
operator|(
name|UNISKIP
argument_list|(
name|tfirst
argument_list|)
operator|<
name|UNISKIP
argument_list|(
name|rfirst
argument_list|)
operator|)
expr_stmt|;
block|}
name|tfirst
operator|+=
name|diff
operator|+
literal|1
expr_stmt|;
block|}
name|none
operator|=
operator|++
name|max
expr_stmt|;
if|if
condition|(
name|del
condition|)
name|del
operator|=
operator|++
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0xffff
condition|)
name|bits
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|>
literal|0xff
condition|)
name|bits
operator|=
literal|16
expr_stmt|;
else|else
name|bits
operator|=
literal|8
expr_stmt|;
name|Safefree
argument_list|(
name|cPVOPo
operator|->
name|op_pv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|swash_init
argument_list|(
literal|"utf8"
argument_list|,
literal|""
argument_list|,
name|listsv
argument_list|,
name|bits
argument_list|,
name|none
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|listsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|transv
condition|)
name|SvREFCNT_dec
argument_list|(
name|transv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|del
operator|&&
name|havefinal
condition|)
operator|(
name|void
operator|)
name|hv_store
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|SvRV
argument_list|(
operator|(
name|cSVOPo
operator|->
name|op_sv
operator|)
argument_list|)
argument_list|,
literal|"FINAL"
argument_list|,
literal|5
argument_list|,
name|newSVuv
argument_list|(
operator|(
name|UV
operator|)
name|final
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|grows
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_GROWS
expr_stmt|;
if|if
condition|(
name|tsave
condition|)
name|Safefree
argument_list|(
name|tsave
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsave
condition|)
name|Safefree
argument_list|(
name|rsave
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|repl
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
name|tbl
operator|=
operator|(
name|short
operator|*
operator|)
name|cPVOPo
operator|->
name|op_pv
expr_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|Zero
argument_list|(
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|tbl
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|del
condition|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rlen
condition|)
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|tbl
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
literal|128
operator|&&
name|r
index|[
name|j
index|]
operator|>=
literal|128
condition|)
name|grows
operator|=
literal|1
expr_stmt|;
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rlen
operator|&&
operator|!
name|del
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
name|rlen
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
operator|!
name|squash
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_IDENTICAL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|del
condition|)
block|{
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
operator|--
name|j
expr_stmt|;
block|}
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|t
index|[
name|i
index|]
operator|<
literal|128
operator|&&
name|r
index|[
name|j
index|]
operator|>=
literal|128
condition|)
name|grows
operator|=
literal|1
expr_stmt|;
name|tbl
index|[
name|t
index|[
name|i
index|]
index|]
operator|=
name|r
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|grows
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpTRANS_GROWS
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|repl
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newPMOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|PMOP
modifier|*
name|pmop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|pmop
argument_list|,
literal|1
argument_list|,
name|PMOP
argument_list|)
expr_stmt|;
name|pmop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|pmop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|pmop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|pmop
operator|->
name|op_private
operator|=
literal|0
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_RE_TAINT
condition|)
name|pmop
operator|->
name|op_pmpermflags
operator||=
name|PMf_RETAINT
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|pmop
operator|->
name|op_pmpermflags
operator||=
name|PMf_LOCALE
expr_stmt|;
name|pmop
operator|->
name|op_pmflags
operator|=
name|pmop
operator|->
name|op_pmpermflags
expr_stmt|;
comment|/* link into pm list */
if|if
condition|(
name|type
operator|!=
name|OP_TRANS
operator|&&
name|PL_curstash
condition|)
block|{
name|pmop
operator|->
name|op_pmnext
operator|=
name|HvPMROOT
argument_list|(
name|PL_curstash
argument_list|)
expr_stmt|;
name|HvPMROOT
argument_list|(
name|PL_curstash
argument_list|)
operator|=
name|pmop
expr_stmt|;
block|}
return|return
operator|(
name|OP
operator|*
operator|)
name|pmop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_pmruntime
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|repl
parameter_list|)
block|{
name|PMOP
modifier|*
name|pm
decl_stmt|;
name|LOGOP
modifier|*
name|rcop
decl_stmt|;
name|I32
name|repl_has_vars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_TRANS
condition|)
return|return
name|pmtrans
argument_list|(
name|o
argument_list|,
name|expr
argument_list|,
name|repl
argument_list|)
return|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|pm
operator|=
operator|(
name|PMOP
operator|*
operator|)
name|o
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|STRLEN
name|plen
decl_stmt|;
name|SV
modifier|*
name|pat
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|SvPV
argument_list|(
name|pat
argument_list|,
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
operator|&&
name|strEQ
argument_list|(
name|p
argument_list|,
literal|" "
argument_list|)
condition|)
block|{
name|sv_setpvn
argument_list|(
name|pat
argument_list|,
literal|"\\s+"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvPV
argument_list|(
name|pat
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_SKIPWHITE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_UTF8
operator|)
operator|||
name|DO_UTF8
argument_list|(
name|pat
argument_list|)
condition|)
name|pm
operator|->
name|op_pmdynflags
operator||=
name|PMdf_UTF8
expr_stmt|;
name|pm
operator|->
name|op_pmregexp
operator|=
name|CALLREGCOMP
argument_list|(
argument|aTHX_ p
argument_list|,
argument|p + plen
argument_list|,
argument|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
literal|"\\s+"
argument_list|,
name|pm
operator|->
name|op_pmregexp
operator|->
name|precomp
argument_list|)
condition|)
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_WHITE
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_hints
operator|&
name|HINT_UTF8
condition|)
name|pm
operator|->
name|op_pmdynflags
operator||=
name|PMdf_UTF8
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
operator|||
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
operator|(
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|?
name|OP_REGCRESET
else|:
name|OP_REGCMAYBE
operator|)
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|rcop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_type
operator|=
name|OP_REGCOMP
expr_stmt|;
name|rcop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_REGCOMP
index|]
expr_stmt|;
name|rcop
operator|->
name|op_first
operator|=
name|scalar
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_flags
operator||=
operator|(
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|?
operator|(
name|OPf_SPECIAL
operator||
name|OPf_KIDS
operator|)
else|:
name|OPf_KIDS
operator|)
expr_stmt|;
name|rcop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|rcop
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
comment|/* establish postfix order */
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_KEEP
operator|||
operator|!
operator|(
name|PL_hints
operator|&
name|HINT_RE_EVAL
operator|)
condition|)
block|{
name|LINKLIST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_next
operator|=
name|expr
expr_stmt|;
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
block|}
else|else
block|{
name|rcop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
block|}
name|prepend_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|rcop
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repl
condition|)
block|{
name|OP
modifier|*
name|curop
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_EVAL
condition|)
block|{
name|curop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
operator|<
name|PL_multi_end
condition|)
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_multi_end
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_THREADS
elseif|else
if|if
condition|(
name|repl
operator|->
name|op_type
operator|==
name|OP_THREADSV
operator|&&
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
name|PL_threadsv_names
index|[
name|repl
operator|->
name|op_targ
index|]
argument_list|)
condition|)
block|{
name|curop
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
elseif|else
if|if
condition|(
name|repl
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|curop
operator|=
name|repl
expr_stmt|;
else|else
block|{
name|OP
modifier|*
name|lastop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|repl
argument_list|)
init|;
name|curop
operator|!=
name|repl
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
name|PL_opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_DANGEROUS
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_THREADSV
condition|)
block|{
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
name|curop
operator|->
name|op_private
argument_list|)
condition|)
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPx_gv
argument_list|(
name|curop
argument_list|)
decl_stmt|;
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"&`'123456789+"
argument_list|,
operator|*
name|GvENAME
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
break|break;
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|lastop
operator|&&
name|lastop
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
comment|/*funny deref?*/
break|break;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PADSV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|repl_has_vars
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
empty_stmt|;
comment|/* Okay here, dangerous in newASSIGNOP */
else|else
break|break;
block|}
name|lastop
operator|=
name|curop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curop
operator|==
name|repl
operator|&&
operator|!
operator|(
name|repl_has_vars
operator|&&
operator|(
operator|!
name|pm
operator|->
name|op_pmregexp
operator|||
name|pm
operator|->
name|op_pmregexp
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
operator|)
operator|)
condition|)
block|{
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_CONST
expr_stmt|;
comment|/* const for long enough */
name|pm
operator|->
name|op_pmpermflags
operator||=
name|PMf_CONST
expr_stmt|;
comment|/* const for long enough */
name|prepend_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|scalar
argument_list|(
name|repl
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|curop
operator|==
name|repl
operator|&&
operator|!
name|pm
operator|->
name|op_pmregexp
condition|)
block|{
comment|/* Has variables. */
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_MAYBE_CONST
expr_stmt|;
name|pm
operator|->
name|op_pmpermflags
operator||=
name|PMf_MAYBE_CONST
expr_stmt|;
block|}
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|rcop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_type
operator|=
name|OP_SUBSTCONT
expr_stmt|;
name|rcop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_SUBSTCONT
index|]
expr_stmt|;
name|rcop
operator|->
name|op_first
operator|=
name|scalar
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|rcop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|rcop
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
comment|/* establish postfix order */
name|rcop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|repl
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|rcop
expr_stmt|;
name|pm
operator|->
name|op_pmreplroot
operator|=
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|rcop
argument_list|)
expr_stmt|;
name|pm
operator|->
name|op_pmreplstart
operator|=
name|LINKLIST
argument_list|(
name|rcop
argument_list|)
expr_stmt|;
name|rcop
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|OP
operator|*
operator|)
name|pm
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newSVOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SVOP
modifier|*
name|svop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|svop
argument_list|,
literal|1
argument_list|,
name|SVOP
argument_list|)
expr_stmt|;
name|svop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|svop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|svop
operator|->
name|op_sv
operator|=
name|sv
expr_stmt|;
name|svop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|svop
expr_stmt|;
name|svop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|svop
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|svop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|svop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newPADOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|PADOP
modifier|*
name|padop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|padop
argument_list|,
literal|1
argument_list|,
name|PADOP
argument_list|)
expr_stmt|;
name|padop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|padop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|padop
operator|->
name|op_padix
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_curpad
index|[
name|padop
operator|->
name|op_padix
index|]
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|padop
operator|->
name|op_padix
index|]
operator|=
name|sv
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|padop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|padop
expr_stmt|;
name|padop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|padop
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|padop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|padop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newGVOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|GvIN_PAD_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
return|return
name|newPADOP
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|newSVOP
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newPVOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|pv
parameter_list|)
block|{
name|PVOP
modifier|*
name|pvop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|pvop
argument_list|,
literal|1
argument_list|,
name|PVOP
argument_list|)
expr_stmt|;
name|pvop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|pvop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|pvop
operator|->
name|op_pv
operator|=
name|pv
expr_stmt|;
name|pvop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|pvop
expr_stmt|;
name|pvop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_RETSCALAR
condition|)
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|pvop
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_TARGET
condition|)
name|pvop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
return|return
name|CHECKOP
argument_list|(
name|type
argument_list|,
name|pvop
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|Perl_package
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|save_hptr
argument_list|(
operator|&
name|PL_curstash
argument_list|)
expr_stmt|;
name|save_item
argument_list|(
name|PL_curstname
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|sv
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
name|name
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|gv_stashpvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|PL_curstname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_setpv
argument_list|(
name|PL_curstname
argument_list|,
literal|"<none>"
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|Nullhv
expr_stmt|;
block|}
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_utilize
parameter_list|(
name|pTHX_
name|int
name|aver
parameter_list|,
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|version
parameter_list|,
name|OP
modifier|*
name|id
parameter_list|,
name|OP
modifier|*
name|arg
parameter_list|)
block|{
name|OP
modifier|*
name|pack
decl_stmt|;
name|OP
modifier|*
name|rqop
decl_stmt|;
name|OP
modifier|*
name|imop
decl_stmt|;
name|OP
modifier|*
name|veop
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|op_type
operator|!=
name|OP_CONST
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Module name must be constant"
argument_list|)
expr_stmt|;
name|veop
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|Nullop
condition|)
block|{
name|SV
modifier|*
name|vesv
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|version
operator|)
operator|->
name|op_sv
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|Nullop
operator|&&
operator|!
name|SvNIOKp
argument_list|(
name|vesv
argument_list|)
condition|)
block|{
name|arg
operator|=
name|version
expr_stmt|;
block|}
else|else
block|{
name|OP
modifier|*
name|pack
decl_stmt|;
name|SV
modifier|*
name|meth
decl_stmt|;
if|if
condition|(
name|version
operator|->
name|op_type
operator|!=
name|OP_CONST
operator|||
operator|!
name|SvNIOKp
argument_list|(
name|vesv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Version number must be constant number"
argument_list|)
expr_stmt|;
comment|/* Make copy of id so we don't free it twice */
name|pack
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVsv
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fake up a method call to VERSION */
name|meth
operator|=
name|newSVpvn
argument_list|(
literal|"VERSION"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|meth
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|meth
argument_list|)
expr_stmt|;
name|PERL_HASH
argument_list|(
name|SvUVX
argument_list|(
name|meth
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|meth
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|meth
argument_list|)
argument_list|)
expr_stmt|;
name|veop
operator|=
name|convert
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
operator||
name|OPf_SPECIAL
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|pack
argument_list|,
name|list
argument_list|(
name|version
argument_list|)
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_METHOD_NAMED
argument_list|,
literal|0
argument_list|,
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fake up an import/unimport */
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|op_type
operator|==
name|OP_STUB
condition|)
name|imop
operator|=
name|arg
expr_stmt|;
comment|/* no import on explicit () */
elseif|else
if|if
condition|(
name|SvNIOKp
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|imop
operator|=
name|Nullop
expr_stmt|;
comment|/* use 5.0; */
block|}
else|else
block|{
name|SV
modifier|*
name|meth
decl_stmt|;
comment|/* Make copy of id so we don't free it twice */
name|pack
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVsv
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|id
operator|)
operator|->
name|op_sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fake up a method call to import/unimport */
name|meth
operator|=
name|aver
condition|?
name|newSVpvn
argument_list|(
literal|"import"
argument_list|,
literal|6
argument_list|)
else|:
name|newSVpvn
argument_list|(
literal|"unimport"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
empty_stmt|;
name|sv_upgrade
argument_list|(
name|meth
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|meth
argument_list|)
expr_stmt|;
name|PERL_HASH
argument_list|(
name|SvUVX
argument_list|(
name|meth
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|meth
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|meth
argument_list|)
argument_list|)
expr_stmt|;
name|imop
operator|=
name|convert
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
operator||
name|OPf_SPECIAL
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|prepend_elem
argument_list|(
name|OP_LIST
argument_list|,
name|pack
argument_list|,
name|list
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_METHOD_NAMED
argument_list|,
literal|0
argument_list|,
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fake up a require, handle override, if any */
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"require"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::require"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|rqop
operator|=
name|ck_subr
argument_list|(
name|newUNOP
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|id
argument_list|,
name|scalar
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rqop
operator|=
name|newUNOP
argument_list|(
name|OP_REQUIRE
argument_list|,
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* Fake up the BEGIN {}, which does its thing immediately. */
name|newATTRSUB
argument_list|(
name|floor
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"BEGIN"
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|Nullop
argument_list|,
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|rqop
argument_list|)
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|veop
argument_list|)
argument_list|)
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|imop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|PL_expect
operator|=
name|XSTATE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_load_module
parameter_list|(
name|pTHX_
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|vload_module
argument_list|(
name|flags
argument_list|,
name|name
argument_list|,
name|ver
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_function
name|void
name|Perl_load_module_nocontext
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|vload_module
argument_list|(
name|flags
argument_list|,
name|name
argument_list|,
name|ver
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|Perl_vload_module
parameter_list|(
name|pTHX_
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|OP
modifier|*
name|modname
decl_stmt|,
modifier|*
name|veop
decl_stmt|,
modifier|*
name|imop
decl_stmt|;
name|modname
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|modname
operator|->
name|op_private
operator||=
name|OPpCONST_BARE
expr_stmt|;
if|if
condition|(
name|ver
condition|)
block|{
name|veop
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
else|else
name|veop
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PERL_LOADMOD_NOIMPORT
condition|)
block|{
name|imop
operator|=
name|sawparens
argument_list|(
name|newNULLLIST
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|PERL_LOADMOD_IMPORT_OPS
condition|)
block|{
name|imop
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|OP
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|imop
operator|=
name|Nullop
expr_stmt|;
name|sv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|sv
condition|)
block|{
name|imop
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|imop
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|line_t
name|ocopline
init|=
name|PL_copline
decl_stmt|;
name|int
name|oexpect
init|=
name|PL_expect
decl_stmt|;
name|utilize
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|PERL_LOADMOD_DENY
operator|)
argument_list|,
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|veop
argument_list|,
name|modname
argument_list|,
name|imop
argument_list|)
expr_stmt|;
name|PL_expect
operator|=
name|oexpect
expr_stmt|;
name|PL_copline
operator|=
name|ocopline
expr_stmt|;
block|}
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_dofile
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|term
parameter_list|)
block|{
name|OP
modifier|*
name|doop
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"do"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::do"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|doop
operator|=
name|ck_subr
argument_list|(
name|newUNOP
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|term
argument_list|,
name|scalar
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doop
operator|=
name|newUNOP
argument_list|(
name|OP_DOFILE
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|doop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newSLICEOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|subscript
parameter_list|,
name|OP
modifier|*
name|listval
parameter_list|)
block|{
return|return
name|newBINOP
argument_list|(
name|OP_LSLICE
argument_list|,
name|flags
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|subscript
argument_list|)
argument_list|)
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|listval
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_list_assignment
parameter_list|(
name|pTHX_
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
name|o
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_COND_EXPR
condition|)
block|{
name|I32
name|t
init|=
name|list_assignment
argument_list|(
name|cLOGOPo
operator|->
name|op_first
operator|->
name|op_sibling
argument_list|)
decl_stmt|;
name|I32
name|f
init|=
name|list_assignment
argument_list|(
name|cLOGOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|->
name|op_sibling
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|f
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|t
operator|||
name|f
condition|)
name|yyerror
argument_list|(
literal|"Assignment to both a list and a scalar"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LIST
operator|||
name|o
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_ASLICE
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_HSLICE
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|o
operator|->
name|op_type
operator|==
name|OP_PADHV
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
return|return
name|FALSE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newASSIGNOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|I32
name|optype
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|optype
condition|)
block|{
if|if
condition|(
name|optype
operator|==
name|OP_ANDASSIGN
operator|||
name|optype
operator|==
name|OP_ORASSIGN
condition|)
block|{
return|return
name|newLOGOP
argument_list|(
name|optype
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|optype
argument_list|)
argument_list|,
name|newUNOP
argument_list|(
name|OP_SASSIGN
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newBINOP
argument_list|(
name|optype
argument_list|,
name|OPf_STACKED
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|optype
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|list_assignment
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|OP
modifier|*
name|curop
decl_stmt|;
name|PL_modcount
operator|=
literal|0
expr_stmt|;
name|PL_eval_start
operator|=
name|right
expr_stmt|;
comment|/* Grandfathering $[ assignment here.  Bletch.*/
name|left
operator|=
name|mod
argument_list|(
name|left
argument_list|,
name|OP_AASSIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_start
condition|)
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|op_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
block|}
name|curop
operator|=
name|list
argument_list|(
name|force_list
argument_list|(
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_AASSIGN
argument_list|,
name|flags
argument_list|,
name|list
argument_list|(
name|force_list
argument_list|(
name|right
argument_list|)
argument_list|)
argument_list|,
name|curop
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|curop
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_first
init|;
name|curop
condition|;
name|curop
operator|=
name|curop
operator|->
name|op_sibling
control|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|&&
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpASSIGN_HASH
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|left
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
condition|)
block|{
name|OP
modifier|*
name|lastop
init|=
name|o
decl_stmt|;
name|PL_generation
operator|++
expr_stmt|;
for|for
control|(
name|curop
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
init|;
name|curop
operator|!=
name|o
condition|;
name|curop
operator|=
name|LINKLIST
argument_list|(
name|curop
argument_list|)
control|)
block|{
if|if
condition|(
name|PL_opargs
index|[
name|curop
operator|->
name|op_type
index|]
operator|&
name|OA_DANGEROUS
condition|)
block|{
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPx_gv
argument_list|(
name|curop
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|==
name|PL_defgv
operator|||
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PADSV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|svp
index|[
name|curop
operator|->
name|op_targ
index|]
decl_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
comment|/* (SvCUR not used any more) */
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
break|break;
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|||
name|curop
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|lastop
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
comment|/* funny deref? */
break|break;
block|}
elseif|else
if|if
condition|(
name|curop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_pmreplroot
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
name|PL_curpad
index|[
call|(
name|PADOFFSET
call|)
argument_list|(
operator|(
name|PMOP
operator|*
operator|)
name|curop
argument_list|)
operator|->
name|op_pmreplroot
index|]
decl_stmt|;
else|#
directive|else
name|GV
modifier|*
name|gv
init|=
operator|(
name|GV
operator|*
operator|)
operator|(
operator|(
name|PMOP
operator|*
operator|)
name|curop
operator|)
operator|->
name|op_pmreplroot
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gv
operator|==
name|PL_defgv
operator|||
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|==
name|PL_generation
condition|)
break|break;
name|SvCUR
argument_list|(
name|gv
argument_list|)
operator|=
name|PL_generation
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|lastop
operator|=
name|curop
expr_stmt|;
block|}
if|if
condition|(
name|curop
operator|!=
name|o
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpASSIGN_COMMON
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|&&
name|right
operator|->
name|op_type
operator|==
name|OP_SPLIT
condition|)
block|{
name|OP
modifier|*
name|tmpop
decl_stmt|;
if|if
condition|(
operator|(
name|tmpop
operator|=
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_first
operator|)
operator|&&
name|tmpop
operator|->
name|op_type
operator|==
name|OP_PUSHRE
condition|)
block|{
name|PMOP
modifier|*
name|pm
init|=
operator|(
name|PMOP
operator|*
operator|)
name|tmpop
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|&&
operator|!
operator|(
name|left
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpASSIGN_COMMON
operator|)
condition|)
block|{
name|tmpop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|left
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|tmpop
operator|->
name|op_type
operator|==
name|OP_GV
operator|&&
operator|!
name|pm
operator|->
name|op_pmreplroot
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|pm
operator|->
name|op_pmreplroot
operator|=
operator|(
name|OP
operator|*
operator|)
name|cPADOPx
argument_list|(
name|tmpop
argument_list|)
operator|->
name|op_padix
expr_stmt|;
name|cPADOPx
argument_list|(
name|tmpop
argument_list|)
operator|->
name|op_padix
operator|=
literal|0
expr_stmt|;
comment|/* steal it */
else|#
directive|else
name|pm
operator|->
name|op_pmreplroot
operator|=
operator|(
name|OP
operator|*
operator|)
name|cSVOPx
argument_list|(
name|tmpop
argument_list|)
operator|->
name|op_sv
expr_stmt|;
name|cSVOPx
argument_list|(
name|tmpop
argument_list|)
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
comment|/* steal it */
endif|#
directive|endif
name|pm
operator|->
name|op_pmflags
operator||=
name|PMf_ONCE
expr_stmt|;
name|tmpop
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
comment|/* to list (nulled) */
name|tmpop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|tmpop
operator|)
operator|->
name|op_first
expr_stmt|;
comment|/* to pushmark */
name|tmpop
operator|->
name|op_sibling
operator|=
name|Nullop
expr_stmt|;
comment|/* don't free split */
name|right
operator|->
name|op_next
operator|=
name|tmpop
operator|->
name|op_next
expr_stmt|;
comment|/* fix starting loc */
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* blow off assign */
name|right
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_WANT
expr_stmt|;
comment|/* "I don't know and I don't care." */
return|return
name|right
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PL_modcount
operator|<
name|RETURN_UNLIMITED_NUMBER
operator|&&
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_last
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
operator|(
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|right
operator|)
operator|->
name|op_last
operator|)
operator|->
name|op_sv
decl_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|PL_modcount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|o
return|;
block|}
if|if
condition|(
operator|!
name|right
condition|)
name|right
operator|=
name|newOP
argument_list|(
name|OP_UNDEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|op_type
operator|==
name|OP_READLINE
condition|)
block|{
name|right
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
return|return
name|newBINOP
argument_list|(
name|OP_NULL
argument_list|,
name|flags
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|OP_SASSIGN
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|PL_eval_start
operator|=
name|right
expr_stmt|;
comment|/* Grandfathering $[ assignment here.  Bletch.*/
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_SASSIGN
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|right
argument_list|)
argument_list|,
name|mod
argument_list|(
name|scalar
argument_list|(
name|left
argument_list|)
argument_list|,
name|OP_SASSIGN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_eval_start
condition|)
name|PL_eval_start
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newSTATEOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|U32
name|seq
init|=
name|intro_my
argument_list|()
decl_stmt|;
specifier|register
name|COP
modifier|*
name|cop
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|cop
argument_list|,
literal|1
argument_list|,
name|COP
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|cop
operator|->
name|op_type
operator|=
name|OP_DBSTATE
expr_stmt|;
name|cop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_DBSTATE
index|]
expr_stmt|;
block|}
else|else
block|{
name|cop
operator|->
name|op_type
operator|=
name|OP_NEXTSTATE
expr_stmt|;
name|cop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_NEXTSTATE
index|]
expr_stmt|;
block|}
name|cop
operator|->
name|op_flags
operator|=
name|flags
expr_stmt|;
name|cop
operator|->
name|op_private
operator|=
operator|(
name|PL_hints
operator|&
name|HINT_BYTE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NATIVE_HINTS
name|cop
operator|->
name|op_private
operator||=
name|NATIVE_HINTS
expr_stmt|;
endif|#
directive|endif
name|PL_compiling
operator|.
name|op_private
operator|=
name|cop
operator|->
name|op_private
expr_stmt|;
name|cop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|cop
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|cop
operator|->
name|cop_label
operator|=
name|label
expr_stmt|;
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
block|}
name|cop
operator|->
name|cop_seq
operator|=
name|seq
expr_stmt|;
name|cop
operator|->
name|cop_arybase
operator|=
name|PL_curcop
operator|->
name|cop_arybase
expr_stmt|;
if|if
condition|(
name|specialWARN
argument_list|(
name|PL_curcop
operator|->
name|cop_warnings
argument_list|)
condition|)
name|cop
operator|->
name|cop_warnings
operator|=
name|PL_curcop
operator|->
name|cop_warnings
expr_stmt|;
else|else
name|cop
operator|->
name|cop_warnings
operator|=
name|newSVsv
argument_list|(
name|PL_curcop
operator|->
name|cop_warnings
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_copline
operator|==
name|NOLINE
condition|)
name|CopLINE_set
argument_list|(
name|cop
argument_list|,
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|CopLINE_set
argument_list|(
name|cop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|CopFILE_set
argument_list|(
name|cop
argument_list|,
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX share in a pvtable? */
else|#
directive|else
name|CopFILEGV_set
argument_list|(
name|cop
argument_list|,
name|CopFILEGV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CopSTASH_set
argument_list|(
name|cop
argument_list|,
name|PL_curstash
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERLDB_LINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|CopFILEAV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|,
operator|(
name|I32
operator|)
name|CopLINE
argument_list|(
name|cop
argument_list|)
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
name|SvIOK
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
operator|*
name|svp
argument_list|)
operator|=
name|PTR2IV
argument_list|(
name|cop
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|cop
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* "Introduce" my variables to visible status. */
end_comment

begin_function
name|U32
name|Perl_intro_my
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|PL_min_intro_pending
condition|)
return|return
name|PL_cop_seqmax
return|;
name|svp
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PL_min_intro_pending
init|;
name|i
operator|<=
name|PL_max_intro_pending
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|svp
index|[
name|i
index|]
operator|)
operator|&&
name|sv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
name|SvIVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|PAD_MAX
expr_stmt|;
comment|/* Don't know scope end yet. */
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|NV
operator|)
name|PL_cop_seqmax
expr_stmt|;
block|}
block|}
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_comppad_name_fill
operator|=
name|PL_max_intro_pending
expr_stmt|;
comment|/* Needn't search higher */
return|return
name|PL_cop_seqmax
operator|++
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newLOGOP
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|other
parameter_list|)
block|{
return|return
name|new_logop
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|other
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|OP
modifier|*
name|S_new_logop
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
modifier|*
name|firstp
parameter_list|,
name|OP
modifier|*
modifier|*
name|otherp
parameter_list|)
block|{
name|LOGOP
modifier|*
name|logop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|OP
modifier|*
name|first
init|=
operator|*
name|firstp
decl_stmt|;
name|OP
modifier|*
name|other
init|=
operator|*
name|otherp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_XOR
condition|)
comment|/* Not short circuit, but here by precedence. */
return|return
name|newBINOP
argument_list|(
name|type
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|first
argument_list|)
argument_list|,
name|scalar
argument_list|(
name|other
argument_list|)
argument_list|)
return|;
name|scalarboolean
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* optimize "!a&& b" to "a || b", and "!a || b" to "a&& b" */
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_NOT
operator|&&
operator|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
operator|||
name|type
operator|==
name|OP_OR
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
condition|)
name|type
operator|=
name|OP_OR
expr_stmt|;
else|else
name|type
operator|=
name|OP_AND
expr_stmt|;
name|o
operator|=
name|first
expr_stmt|;
name|first
operator|=
operator|*
name|firstp
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_next
condition|)
name|first
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
name|cUNOPo
operator|->
name|op_first
operator|=
name|Nullop
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_BAREWORD
argument_list|)
operator|&&
operator|(
name|first
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_BAREWORD
argument_list|,
literal|"Bareword found in conditional"
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|OP_AND
operator|)
operator|==
operator|(
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_sv
argument_list|)
operator|)
condition|)
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
operator|*
name|firstp
operator|=
name|Nullop
expr_stmt|;
return|return
name|other
return|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|other
argument_list|)
expr_stmt|;
operator|*
name|otherp
operator|=
name|Nullop
expr_stmt|;
return|return
name|first
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_WANTARRAY
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_AND
condition|)
name|list
argument_list|(
name|other
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_MISC
argument_list|)
operator|&&
operator|(
name|first
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
name|k1
operator|->
name|op_sibling
decl_stmt|;
name|OPCODE
name|warnop
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|first
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
block|{
name|warnop
operator|=
name|k2
operator|->
name|op_type
expr_stmt|;
block|}
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|k1
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|k1
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
block|{
name|warnop
operator|=
operator|(
operator|(
name|k1
operator|->
name|op_type
operator|==
name|OP_NULL
operator|)
condition|?
name|k1
operator|->
name|op_targ
else|:
name|k1
operator|->
name|op_type
operator|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|warnop
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_MISC
argument_list|,
literal|"Value of %s%s can be \"0\"; test with defined()"
argument_list|,
argument|PL_op_desc[warnop]
argument_list|,
argument|((warnop == OP_READLINE || warnop == OP_GLOB) 		  ?
literal|" construct"
argument|:
literal|"() operator"
argument|)
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|other
condition|)
return|return
name|first
return|;
if|if
condition|(
name|type
operator|==
name|OP_ANDASSIGN
operator|||
name|type
operator|==
name|OP_ORASSIGN
condition|)
name|other
operator|->
name|op_private
operator||=
name|OPpASSIGN_BACKWARDS
expr_stmt|;
comment|/* other is an OP_SASSIGN */
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|logop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|logop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|logop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|logop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|logop
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* establish postfix order */
name|logop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|logop
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|other
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|logop
argument_list|)
expr_stmt|;
name|other
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newCONDOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|first
parameter_list|,
name|OP
modifier|*
name|trueop
parameter_list|,
name|OP
modifier|*
name|falseop
parameter_list|)
block|{
name|LOGOP
modifier|*
name|logop
decl_stmt|;
name|OP
modifier|*
name|start
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|falseop
condition|)
return|return
name|newLOGOP
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|trueop
argument_list|)
return|;
if|if
condition|(
operator|!
name|trueop
condition|)
return|return
name|newLOGOP
argument_list|(
name|OP_OR
argument_list|,
literal|0
argument_list|,
name|first
argument_list|,
name|falseop
argument_list|)
return|;
name|scalarboolean
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
if|if
condition|(
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|first
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
return|return
name|trueop
return|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
return|return
name|falseop
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|first
operator|->
name|op_type
operator|==
name|OP_WANTARRAY
condition|)
block|{
name|list
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
name|scalar
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
block|}
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|logop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_type
operator|=
name|OP_COND_EXPR
expr_stmt|;
name|logop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_COND_EXPR
index|]
expr_stmt|;
name|logop
operator|->
name|op_first
operator|=
name|first
expr_stmt|;
name|logop
operator|->
name|op_flags
operator|=
name|flags
operator||
name|OPf_KIDS
expr_stmt|;
name|logop
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|logop
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|trueop
argument_list|)
expr_stmt|;
name|logop
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|falseop
argument_list|)
expr_stmt|;
comment|/* establish postfix order */
name|start
operator|=
name|LINKLIST
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|logop
expr_stmt|;
name|first
operator|->
name|op_sibling
operator|=
name|trueop
expr_stmt|;
name|trueop
operator|->
name|op_sibling
operator|=
name|falseop
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|logop
argument_list|)
expr_stmt|;
name|trueop
operator|->
name|op_next
operator|=
name|falseop
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|start
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newRANGE
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|left
parameter_list|,
name|OP
modifier|*
name|right
parameter_list|)
block|{
name|LOGOP
modifier|*
name|range
decl_stmt|;
name|OP
modifier|*
name|flip
decl_stmt|;
name|OP
modifier|*
name|flop
decl_stmt|;
name|OP
modifier|*
name|leftstart
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|range
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|range
operator|->
name|op_type
operator|=
name|OP_RANGE
expr_stmt|;
name|range
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RANGE
index|]
expr_stmt|;
name|range
operator|->
name|op_first
operator|=
name|left
expr_stmt|;
name|range
operator|->
name|op_flags
operator|=
name|OPf_KIDS
expr_stmt|;
name|leftstart
operator|=
name|LINKLIST
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|range
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|range
operator|->
name|op_private
operator|=
literal|1
operator||
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|left
operator|->
name|op_sibling
operator|=
name|right
expr_stmt|;
name|range
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|range
expr_stmt|;
name|flip
operator|=
name|newUNOP
argument_list|(
name|OP_FLIP
argument_list|,
name|flags
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|range
argument_list|)
expr_stmt|;
name|flop
operator|=
name|newUNOP
argument_list|(
name|OP_FLOP
argument_list|,
literal|0
argument_list|,
name|flip
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|flop
argument_list|)
expr_stmt|;
name|linklist
argument_list|(
name|flop
argument_list|)
expr_stmt|;
name|range
operator|->
name|op_next
operator|=
name|leftstart
expr_stmt|;
name|left
operator|->
name|op_next
operator|=
name|flip
expr_stmt|;
name|right
operator|->
name|op_next
operator|=
name|flop
expr_stmt|;
name|range
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|OP_RANGE
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PAD_SV
argument_list|(
name|range
operator|->
name|op_targ
argument_list|)
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|flip
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|OP_RANGE
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PAD_SV
argument_list|(
name|flip
operator|->
name|op_targ
argument_list|)
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|flip
operator|->
name|op_private
operator|=
name|left
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|OPpFLIP_LINENUM
else|:
literal|0
expr_stmt|;
name|flop
operator|->
name|op_private
operator|=
name|right
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|OPpFLIP_LINENUM
else|:
literal|0
expr_stmt|;
name|flip
operator|->
name|op_next
operator|=
name|o
expr_stmt|;
if|if
condition|(
operator|!
name|flip
operator|->
name|op_private
operator|||
operator|!
name|flop
operator|->
name|op_private
condition|)
name|linklist
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* blow off optimizer unless constant */
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newLOOPOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|I32
name|debuggable
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
name|OP
modifier|*
name|listop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|int
name|once
init|=
name|block
operator|&&
name|block
operator|->
name|op_flags
operator|&
name|OPf_SPECIAL
operator|&&
operator|(
name|block
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
operator|||
name|block
operator|->
name|op_type
operator|==
name|OP_NULL
operator|)
decl_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
if|if
condition|(
name|once
operator|&&
name|expr
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|!
name|SvTRUE
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_sv
argument_list|)
condition|)
return|return
name|block
return|;
comment|/* do {} while 0 does once */
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|expr
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
condition|)
block|{
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|newASSIGNOP
argument_list|(
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
operator|(
name|k1
operator|)
condition|?
name|k1
operator|->
name|op_sibling
else|:
name|NULL
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|k1
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|k1
operator|->
name|op_targ
operator|==
name|OP_NULL
operator|)
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|listop
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|block
argument_list|,
name|newOP
argument_list|(
name|OP_UNSTACK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|new_logop
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
operator|&
name|expr
argument_list|,
operator|&
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|listop
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|listop
operator|)
operator|->
name|op_last
operator|->
name|op_next
operator|=
name|LINKLIST
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|once
operator|&&
name|o
operator|!=
name|listop
condition|)
name|o
operator|->
name|op_next
operator|=
operator|(
operator|(
name|LOGOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|->
name|op_other
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|listop
condition|)
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* or do {} while 1 loses outer block */
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|=
name|scope
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* suppress POPBLOCK curpm restoration*/
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newWHILEOP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|I32
name|debuggable
parameter_list|,
name|LOOP
modifier|*
name|loop
parameter_list|,
name|I32
name|whileline
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|,
name|OP
modifier|*
name|cont
parameter_list|)
block|{
name|OP
modifier|*
name|redo
decl_stmt|;
name|OP
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|OP
modifier|*
name|listop
decl_stmt|;
name|OP
modifier|*
name|o
decl_stmt|;
name|OP
modifier|*
name|condop
decl_stmt|;
name|U8
name|loopflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|expr
operator|&&
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|expr
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
operator|)
condition|)
block|{
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|newASSIGNOP
argument_list|(
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|&&
operator|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|k1
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|k2
init|=
operator|(
name|k1
operator|)
condition|?
name|k1
operator|->
name|op_sibling
else|:
name|NULL
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NULL
case|:
if|if
condition|(
name|k2
operator|&&
name|k2
operator|->
name|op_type
operator|==
name|OP_READLINE
operator|&&
operator|(
name|k2
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
operator|&&
operator|(
operator|(
name|k1
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|==
name|OPf_WANT_SCALAR
operator|)
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SASSIGN
case|:
if|if
condition|(
name|k1
operator|->
name|op_type
operator|==
name|OP_READDIR
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_GLOB
operator|||
operator|(
name|k1
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|k1
operator|->
name|op_targ
operator|==
name|OP_GLOB
operator|)
operator|||
name|k1
operator|->
name|op_type
operator|==
name|OP_EACH
condition|)
name|expr
operator|=
name|newUNOP
argument_list|(
name|OP_DEFINED
argument_list|,
literal|0
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|block
condition|)
name|block
operator|=
name|newOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cont
condition|)
block|{
name|block
operator|=
name|scope
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cont
condition|)
block|{
name|next
operator|=
name|LINKLIST
argument_list|(
name|cont
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
condition|)
block|{
name|OP
modifier|*
name|unstack
init|=
name|newOP
argument_list|(
name|OP_UNSTACK
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|next
operator|=
name|unstack
expr_stmt|;
name|cont
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|cont
argument_list|,
name|unstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line_t
operator|)
name|whileline
operator|!=
name|NOLINE
condition|)
block|{
name|PL_copline
operator|=
name|whileline
expr_stmt|;
name|cont
operator|=
name|append_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
name|cont
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|Nullop
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|listop
operator|=
name|append_list
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|LISTOP
operator|*
operator|)
name|block
argument_list|,
operator|(
name|LISTOP
operator|*
operator|)
name|cont
argument_list|)
expr_stmt|;
name|redo
operator|=
name|LINKLIST
argument_list|(
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|PL_copline
operator|=
name|whileline
expr_stmt|;
name|scalar
argument_list|(
name|listop
argument_list|)
expr_stmt|;
name|o
operator|=
name|new_logop
argument_list|(
name|OP_AND
argument_list|,
literal|0
argument_list|,
operator|&
name|expr
argument_list|,
operator|&
name|listop
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|expr
operator|&&
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|!
name|SvTRUE
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* oops, it's a while (0) */
name|op_free
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|loop
argument_list|)
expr_stmt|;
return|return
name|Nullop
return|;
comment|/* listop already freed by new_logop */
block|}
if|if
condition|(
name|listop
condition|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|listop
operator|)
operator|->
name|op_last
operator|->
name|op_next
operator|=
name|condop
operator|=
operator|(
name|o
operator|==
name|listop
condition|?
name|redo
else|:
name|LINKLIST
argument_list|(
name|o
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|o
operator|=
name|listop
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
block|{
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|loop
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
name|loop
operator|->
name|op_type
operator|=
name|OP_ENTERLOOP
expr_stmt|;
name|loop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_ENTERLOOP
index|]
expr_stmt|;
name|loop
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
name|loop
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|loop
expr_stmt|;
block|}
name|o
operator|=
name|newBINOP
argument_list|(
name|OP_LEAVELOOP
argument_list|,
literal|0
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|loop
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|loop
operator|->
name|op_redoop
operator|=
name|redo
expr_stmt|;
name|loop
operator|->
name|op_lastop
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|loopflags
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|loop
operator|->
name|op_nextop
operator|=
name|next
expr_stmt|;
else|else
name|loop
operator|->
name|op_nextop
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|flags
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|flags
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newFOROP
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|line_t
name|forline
parameter_list|,
name|OP
modifier|*
name|sv
parameter_list|,
name|OP
modifier|*
name|expr
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|,
name|OP
modifier|*
name|cont
parameter_list|)
block|{
name|LOOP
modifier|*
name|loop
decl_stmt|;
name|OP
modifier|*
name|wop
decl_stmt|;
name|int
name|padoff
init|=
literal|0
decl_stmt|;
name|I32
name|iterflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sv
condition|)
block|{
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
block|{
comment|/* symbol table variable */
name|sv
operator|->
name|op_type
operator|=
name|OP_RV2GV
expr_stmt|;
name|sv
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2GV
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_PADSV
condition|)
block|{
comment|/* private variable */
name|padoff
operator|=
name|sv
operator|->
name|op_targ
expr_stmt|;
name|sv
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
name|op_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Nullop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|->
name|op_type
operator|==
name|OP_THREADSV
condition|)
block|{
comment|/* per-thread variable */
name|padoff
operator|=
name|sv
operator|->
name|op_targ
expr_stmt|;
name|sv
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
name|iterflags
operator||=
name|OPf_SPECIAL
expr_stmt|;
name|op_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|Nullop
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use %s for loop variable"
argument_list|,
name|PL_op_desc
index|[
name|sv
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|padoff
operator|=
name|find_threadsv
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_SPECIAL
expr_stmt|;
else|#
directive|else
name|sv
operator|=
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|PL_defgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|expr
operator|->
name|op_type
operator|==
name|OP_PADAV
condition|)
block|{
name|expr
operator|=
name|mod
argument_list|(
name|force_list
argument_list|(
name|scalar
argument_list|(
name|ref
argument_list|(
name|expr
argument_list|,
name|OP_ITER
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_STACKED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
operator|(
name|expr
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_FLOP
condition|)
block|{
comment|/* Basically turn for($x..$y) into the same as for($x,$y), but we 	 * set the STACKED flag to indicate that these values are to be 	 * treated as min/max values by 'pp_iterinit'. 	 */
name|UNOP
modifier|*
name|flip
init|=
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|expr
operator|)
operator|->
name|op_first
operator|)
operator|->
name|op_first
decl_stmt|;
name|LOGOP
modifier|*
name|range
init|=
operator|(
name|LOGOP
operator|*
operator|)
name|flip
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|left
init|=
name|range
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|right
init|=
name|left
operator|->
name|op_sibling
decl_stmt|;
name|LISTOP
modifier|*
name|listop
decl_stmt|;
name|range
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_KIDS
expr_stmt|;
name|range
operator|->
name|op_first
operator|=
name|Nullop
expr_stmt|;
name|listop
operator|=
operator|(
name|LISTOP
operator|*
operator|)
name|newLISTOP
argument_list|(
name|OP_LIST
argument_list|,
literal|0
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|listop
operator|->
name|op_first
operator|->
name|op_next
operator|=
name|range
operator|->
name|op_next
expr_stmt|;
name|left
operator|->
name|op_next
operator|=
name|range
operator|->
name|op_other
expr_stmt|;
name|right
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|listop
expr_stmt|;
name|listop
operator|->
name|op_next
operator|=
name|listop
operator|->
name|op_first
expr_stmt|;
name|op_free
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|OP
operator|*
operator|)
operator|(
name|listop
operator|)
expr_stmt|;
name|null
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|iterflags
operator||=
name|OPf_STACKED
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|mod
argument_list|(
name|force_list
argument_list|(
name|expr
argument_list|)
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
block|}
name|loop
operator|=
operator|(
name|LOOP
operator|*
operator|)
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ENTERITER
argument_list|,
name|iterflags
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|expr
argument_list|,
name|scalar
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|loop
operator|->
name|op_next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PL_OP_SLAB_ALLOC
block|{
name|LOOP
modifier|*
name|tmp
decl_stmt|;
name|NewOp
argument_list|(
literal|1234
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|loop
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
name|loop
operator|=
name|tmp
expr_stmt|;
block|}
else|#
directive|else
name|Renew
argument_list|(
name|loop
argument_list|,
literal|1
argument_list|,
name|LOOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loop
operator|->
name|op_targ
operator|=
name|padoff
expr_stmt|;
name|wop
operator|=
name|newWHILEOP
argument_list|(
name|flags
argument_list|,
literal|1
argument_list|,
name|loop
argument_list|,
name|forline
argument_list|,
name|newOP
argument_list|(
name|OP_ITER
argument_list|,
literal|0
argument_list|)
argument_list|,
name|block
argument_list|,
name|cont
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|forline
expr_stmt|;
return|return
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|label
argument_list|,
name|wop
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newLOOPEX
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|label
parameter_list|)
block|{
name|OP
modifier|*
name|o
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|OP_GOTO
operator|||
name|label
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
comment|/* "last()" means "last" */
if|if
condition|(
name|label
operator|->
name|op_type
operator|==
name|OP_STUB
operator|&&
operator|(
name|label
operator|->
name|op_flags
operator|&
name|OPf_PARENS
operator|)
condition|)
name|o
operator|=
name|newOP
argument_list|(
name|type
argument_list|,
name|OPf_SPECIAL
argument_list|)
expr_stmt|;
else|else
block|{
name|o
operator|=
name|newPVOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|savepv
argument_list|(
name|label
operator|->
name|op_type
operator|==
name|OP_CONST
condition|?
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|label
operator|)
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|label
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
condition|)
name|label
operator|=
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|label
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|type
argument_list|,
name|OPf_STACKED
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|void
name|Perl_cv_undef
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|cv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|MUTEX_DESTROY
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
operator|!
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|&&
name|CvROOT
argument_list|(
name|cv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
operator|||
operator|(
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|&&
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|!=
name|thr
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't undef active subroutine"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|CvDEPTH
argument_list|(
name|cv
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't undef active subroutine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|ENTER
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curpad
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
literal|0
expr_stmt|;
name|op_free
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullop
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|SvPOK_off
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
comment|/* forget prototype */
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
comment|/* Since closure prototypes have the same lifetime as the containing      * CV, they don't hold a refcount on the outside CV.  This avoids      * the refcount loop between the outer CV (which keeps a refcount to      * the closure prototype in the pad entry for pp_anoncode()) and the      * closure prototype, and the ensuing memory leak.  --GSAR */
if|if
condition|(
operator|!
name|CvANON
argument_list|(
name|cv
argument_list|)
operator|||
name|CvCLONED
argument_list|(
name|cv
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
if|if
condition|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
condition|)
block|{
comment|/* may be during global destruction */
if|if
condition|(
name|SvREFCNT
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
condition|)
block|{
name|I32
name|i
init|=
name|AvFILLp
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|av_fetch
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|,
name|i
operator|--
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
name|svp
condition|?
operator|*
name|svp
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
continue|continue;
if|if
condition|(
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
condition|)
name|PL_comppad_name
operator|=
name|Nullav
expr_stmt|;
elseif|else
if|if
condition|(
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
condition|)
block|{
name|PL_comppad
operator|=
name|Nullav
expr_stmt|;
name|PL_curpad
operator|=
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|Nullav
expr_stmt|;
block|}
name|CvFLAGS
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_cv_dump
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|cv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|CV
modifier|*
name|outside
init|=
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|pad_name
decl_stmt|;
name|AV
modifier|*
name|pad
decl_stmt|;
name|SV
modifier|*
modifier|*
name|pname
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ppad
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\tCV=0x%"
name|UVxf
literal|" (%s), OUTSIDE=0x%"
name|UVxf
literal|" (%s)\n"
argument_list|,
name|PTR2UV
argument_list|(
name|cv
argument_list|)
argument_list|,
operator|(
name|CvANON
argument_list|(
name|cv
argument_list|)
condition|?
literal|"ANON"
else|:
operator|(
name|cv
operator|==
name|PL_main_cv
operator|)
condition|?
literal|"MAIN"
else|:
name|CvUNIQUE
argument_list|(
name|cv
argument_list|)
condition|?
literal|"UNIQUE"
else|:
name|CvGV
argument_list|(
name|cv
argument_list|)
condition|?
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
else|:
literal|"UNDEFINED"
operator|)
argument_list|,
name|PTR2UV
argument_list|(
name|outside
argument_list|)
argument_list|,
operator|(
operator|!
name|outside
condition|?
literal|"null"
else|:
name|CvANON
argument_list|(
name|outside
argument_list|)
condition|?
literal|"ANON"
else|:
operator|(
name|outside
operator|==
name|PL_main_cv
operator|)
condition|?
literal|"MAIN"
else|:
name|CvUNIQUE
argument_list|(
name|outside
argument_list|)
condition|?
literal|"UNIQUE"
else|:
name|CvGV
argument_list|(
name|outside
argument_list|)
condition|?
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|outside
argument_list|)
argument_list|)
else|:
literal|"UNDEFINED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|padlist
condition|)
return|return;
name|pad_name
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|padlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pad
operator|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|padlist
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pname
operator|=
name|AvARRAY
argument_list|(
name|pad_name
argument_list|)
expr_stmt|;
name|ppad
operator|=
name|AvARRAY
argument_list|(
name|pad
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|AvFILLp
argument_list|(
name|pad_name
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\t%4d. 0x%"
name|UVxf
literal|" (%s\"%s\" %"
name|IVdf
literal|"-%"
name|IVdf
literal|")\n"
argument_list|,
operator|(
name|int
operator|)
name|ix
argument_list|,
name|PTR2UV
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
argument_list|,
name|SvFAKE
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
condition|?
literal|"FAKE "
else|:
literal|""
argument_list|,
name|SvPVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|I_32
argument_list|(
name|SvNVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
argument_list|,
name|SvIVX
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|STATIC
name|CV
modifier|*
name|S_cv_clone2
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|proto
parameter_list|,
name|CV
modifier|*
name|outside
parameter_list|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|AV
modifier|*
name|protopadlist
init|=
name|CvPADLIST
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|protopad_name
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|protopadlist
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|protopad
init|=
operator|(
name|AV
operator|*
operator|)
operator|*
name|av_fetch
argument_list|(
name|protopadlist
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|pname
init|=
name|AvARRAY
argument_list|(
name|protopad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ppad
init|=
name|AvARRAY
argument_list|(
name|protopad
argument_list|)
decl_stmt|;
name|I32
name|fname
init|=
name|AvFILLp
argument_list|(
name|protopad_name
argument_list|)
decl_stmt|;
name|I32
name|fpad
init|=
name|AvFILLp
argument_list|(
name|protopad
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|assert
argument_list|(
operator|!
name|CvUNIQUE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
name|SAVECOMPPAD
argument_list|()
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|SAVESPTR
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SvTYPE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|cv
argument_list|)
operator|=
name|CvFLAGS
argument_list|(
name|proto
argument_list|)
operator|&
operator|~
name|CVf_CLONE
expr_stmt|;
name|CvCLONED_on
argument_list|(
name|cv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|CvFILE
argument_list|(
name|cv
argument_list|)
operator|=
name|CvFILE
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|CvGV
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|=
name|CvSTASH
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|OpREFCNT_inc
argument_list|(
name|CvROOT
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|CvSTART
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|outside
condition|)
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|outside
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|proto
argument_list|)
condition|)
name|sv_setpvn
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SvPVX
argument_list|(
name|proto
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|fname
init|;
name|ix
operator|>=
literal|0
condition|;
name|ix
operator|--
control|)
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|ix
argument_list|,
name|SvREFCNT_inc
argument_list|(
name|pname
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|av_fill
argument_list|(
name|PL_comppad
argument_list|,
name|AvFILLp
argument_list|(
name|protopad
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|av
operator|=
name|newAV
argument_list|()
expr_stmt|;
comment|/* will be @_ */
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|fpad
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
init|=
operator|(
name|ix
operator|<=
name|fname
operator|)
condition|?
name|pname
index|[
name|ix
index|]
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
name|namesv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVX
argument_list|(
name|namesv
argument_list|)
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator|&
name|SVf_FAKE
condition|)
block|{
comment|/* lexical from outside? */
name|I32
name|off
init|=
name|pad_findlex
argument_list|(
name|name
argument_list|,
name|ix
argument_list|,
name|SvIVX
argument_list|(
name|namesv
argument_list|)
argument_list|,
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
argument_list|,
name|cxstack_ix
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|off
condition|)
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|SvREFCNT_inc
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|!=
name|ix
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: cv_clone: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* our own lexical */
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
comment|/* anon code -- we'll come back for it */
name|sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'%'
condition|)
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|newHV
argument_list|()
expr_stmt|;
else|else
name|sv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvPADBUSY
argument_list|(
name|sv
argument_list|)
condition|)
name|SvPADMY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|sv
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_PADGV
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADCONST
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
condition|)
block|{
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|SvREFCNT_inc
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SvPADTMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|sv
expr_stmt|;
block|}
block|}
comment|/* Now that vars are all in place, clone nested closures. */
for|for
control|(
name|ix
operator|=
name|fpad
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
init|=
operator|(
name|ix
operator|<=
name|fname
operator|)
condition|?
name|pname
index|[
name|ix
index|]
else|:
name|Nullsv
decl_stmt|;
if|if
condition|(
name|namesv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|namesv
argument_list|)
operator|&
name|SVf_FAKE
operator|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|namesv
argument_list|)
operator|==
literal|'&'
operator|&&
name|CvCLONE
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
condition|)
block|{
name|CV
modifier|*
name|kid
init|=
name|cv_clone2
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|ppad
index|[
name|ix
index|]
argument_list|,
name|cv
argument_list|)
decl_stmt|;
name|SvREFCNT_dec
argument_list|(
name|ppad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|CvCLONE_on
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|kid
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_CLOSURES
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Cloned inside:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|outside
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  from:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"   to:\n"
argument_list|)
expr_stmt|;
name|cv_dump
argument_list|(
name|cv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LEAVE
expr_stmt|;
return|return
name|cv
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|Perl_cv_clone
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|proto
parameter_list|)
block|{
name|CV
modifier|*
name|cv
decl_stmt|;
name|LOCK_CRED_MUTEX
expr_stmt|;
comment|/* XXX create separate mutex */
name|cv
operator|=
name|cv_clone2
argument_list|(
name|proto
argument_list|,
name|CvOUTSIDE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK_CRED_MUTEX
expr_stmt|;
comment|/* XXX create separate mutex */
return|return
name|cv
return|;
block|}
end_function

begin_function
name|void
name|Perl_cv_ckproto
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|cv
parameter_list|,
name|GV
modifier|*
name|gv
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
operator|!
name|p
operator|!=
operator|!
name|SvPOK
argument_list|(
name|cv
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|&&
name|strNE
argument_list|(
name|p
argument_list|,
name|SvPVX
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_PROTOTYPE
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|msg
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|SV
modifier|*
name|name
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
name|gv
condition|)
name|gv_efullname3
argument_list|(
name|name
operator|=
name|sv_newmortal
argument_list|()
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|msg
argument_list|,
literal|"Prototype mismatch:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|" sub %"
argument|SVf
argument_list|,
argument|name
argument_list|)
empty_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|" (%s)"
argument_list|,
argument|SvPVX(cv)
argument_list|)
empty_stmt|;
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|" vs "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ msg
argument_list|,
literal|"(%s)"
argument_list|,
argument|p
argument_list|)
empty_stmt|;
else|else
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PROTOTYPE
argument_list|,
literal|"%"
argument|SVf
argument_list|,
argument|msg
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_cv_const_sv
parameter_list|(
name|pTHX_
name|CV
modifier|*
name|cv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cv
operator|||
operator|!
name|SvPOK
argument_list|(
name|cv
argument_list|)
operator|||
name|SvCUR
argument_list|(
name|cv
argument_list|)
condition|)
return|return
name|Nullsv
return|;
return|return
name|op_const_sv
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|,
name|cv
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_op_const_sv
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|,
name|CV
modifier|*
name|cv
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|Nullsv
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_LINESEQ
operator|&&
name|cLISTOPo
operator|->
name|op_first
condition|)
name|o
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
for|for
control|(
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|op_next
control|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|sv
operator|&&
name|o
operator|->
name|op_next
operator|==
name|o
condition|)
return|return
name|sv
return|;
if|if
condition|(
name|type
operator|==
name|OP_NEXTSTATE
operator|||
name|type
operator|==
name|OP_NULL
operator|||
name|type
operator|==
name|OP_PUSHMARK
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|OP_LEAVESUB
operator|||
name|type
operator|==
name|OP_RETURN
condition|)
break|break;
if|if
condition|(
name|sv
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|type
operator|==
name|OP_CONST
operator|&&
name|cSVOPo
operator|->
name|op_sv
condition|)
name|sv
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|OP_PADSV
operator|||
name|type
operator|==
name|OP_CONST
operator|)
operator|&&
name|cv
condition|)
block|{
name|AV
modifier|*
name|padav
init|=
operator|(
name|AV
operator|*
operator|)
operator|(
name|AvARRAY
argument_list|(
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
argument_list|)
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|sv
operator|=
name|padav
condition|?
name|AvARRAY
argument_list|(
name|padav
argument_list|)
index|[
name|o
operator|->
name|op_targ
index|]
else|:
name|Nullsv
expr_stmt|;
if|if
condition|(
operator|!
name|sv
operator|||
operator|(
operator|!
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|>
literal|1
operator|)
condition|)
return|return
name|Nullsv
return|;
block|}
else|else
return|return
name|Nullsv
return|;
block|}
if|if
condition|(
name|sv
condition|)
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|void
name|Perl_newMYSUB
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
name|SAVEFREEOP
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|SAVEFREEOP
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|SAVEFREEOP
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|SAVEFREEOP
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"\"my sub\" not yet implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CV
modifier|*
name|Perl_newSUB
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
return|return
name|Perl_newATTRSUB
argument_list|(
argument|aTHX_ floor
argument_list|,
argument|o
argument_list|,
argument|proto
argument_list|,
argument|Nullop
argument_list|,
argument|block
argument_list|)
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|Perl_newATTRSUB
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|aname
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|char
modifier|*
name|ps
init|=
name|proto
condition|?
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|proto
operator|)
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
else|:
name|Nullch
decl_stmt|;
specifier|register
name|CV
modifier|*
name|cv
init|=
literal|0
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|name
operator|=
name|o
condition|?
name|SvPVx
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
else|:
name|Nullch
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|&&
name|PERLDB_NAMEANON
operator|&&
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"__ANON__[%s:%"
argument|IVdf
literal|"]"
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(IV)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
name|aname
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|aname
operator|=
name|Nullch
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
condition|?
name|name
else|:
operator|(
name|aname
condition|?
name|aname
else|:
literal|"__ANON__"
operator|)
argument_list|,
name|GV_ADDMULTI
operator||
operator|(
operator|(
name|block
operator|||
name|attrs
operator|)
condition|?
literal|0
else|:
name|GV_NOINIT
operator|)
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
name|SAVEFREEOP
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|SAVEFREEOP
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
name|SAVEFREEOP
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|!=
name|SVt_PVGV
condition|)
block|{
comment|/* Maybe prototype now, and had at 					   maximum a prototype before. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|>
name|SVt_NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|&&
operator|!
operator|(
name|SvIOK
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|&&
name|SvIVX
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_PROTOTYPE
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PROTOTYPE
argument_list|,
literal|"Runaway prototype"
argument_list|)
empty_stmt|;
block|}
name|cv_ckproto
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|gv
argument_list|,
name|NULL
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
name|sv_setpv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
else|else
name|sv_setiv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|PL_compcv
operator|=
name|NULL
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
goto|goto
name|noblock
goto|;
block|}
if|if
condition|(
operator|!
name|name
operator|||
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
name|cv
operator|=
name|Nullcv
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cv
operator|=
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
name|cv_ckproto
argument_list|(
name|cv
argument_list|,
name|gv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
comment|/* already defined (or promised)? */
if|if
condition|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|||
name|GvASSUMECV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|const_sv
decl_stmt|;
name|bool
name|const_changed
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|block
operator|&&
operator|!
name|attrs
condition|)
block|{
comment|/* just a "sub foo;" when&foo is already defined */
name|SAVEFREESV
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* ahem, death to those who redefine active sort subs */
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|op_free
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|block
condition|)
goto|goto
name|withattrs
goto|;
if|if
condition|(
operator|(
name|const_sv
operator|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
name|const_changed
operator|=
name|sv_cmp
argument_list|(
name|const_sv
argument_list|,
name|op_const_sv
argument_list|(
name|block
argument_list|,
name|Nullcv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|const_sv
operator|||
name|const_changed
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_REDEFINE
argument_list|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REDEFINE
argument_list|,
argument|const_sv ?
literal|"Constant subroutine %s redefined"
argument|:
literal|"Subroutine %s redefined"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
name|Nullcv
expr_stmt|;
block|}
block|}
name|withattrs
label|:
if|if
condition|(
name|attrs
condition|)
block|{
name|HV
modifier|*
name|stash
decl_stmt|;
name|SV
modifier|*
name|rcv
decl_stmt|;
comment|/* Need to do a C<use attributes $stash_of_cv,\&cv,@attrs> 	 * before we clobber PL_compcv. 	 */
if|if
condition|(
name|cv
operator|&&
operator|!
name|block
condition|)
block|{
name|rcv
operator|=
operator|(
name|SV
operator|*
operator|)
name|cv
expr_stmt|;
if|if
condition|(
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|&&
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
condition|)
name|stash
operator|=
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|CvSTASH
argument_list|(
name|cv
argument_list|)
argument_list|)
condition|)
name|stash
operator|=
name|CvSTASH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
else|else
name|stash
operator|=
name|PL_curstash
expr_stmt|;
block|}
else|else
block|{
comment|/* possibly about to re-define existing subr -- ignore old cv */
name|rcv
operator|=
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|GvSTASH
argument_list|(
name|gv
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
name|stash
operator|=
name|GvSTASH
argument_list|(
name|gv
argument_list|)
expr_stmt|;
else|else
name|stash
operator|=
name|PL_curstash
expr_stmt|;
block|}
name|apply_attrs
argument_list|(
name|stash
argument_list|,
name|rcv
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cv
condition|)
block|{
comment|/* must reuse cv if autoloaded */
if|if
condition|(
operator|!
name|block
condition|)
block|{
comment|/* got here with just attrs -- work done, so bug out */
name|SAVEFREESV
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cv_undef
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|CvFLAGS
argument_list|(
name|cv
argument_list|)
operator|=
name|CvFLAGS
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
operator|=
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvOUTSIDE
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
operator|=
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* inner references to PL_compcv must be fixed up ... */
block|{
name|AV
modifier|*
name|padlist
init|=
name|CvPADLIST
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|AV
modifier|*
name|comppad_name
init|=
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
name|AV
modifier|*
name|comppad
init|=
operator|(
name|AV
operator|*
operator|)
name|AvARRAY
argument_list|(
name|padlist
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|SV
modifier|*
modifier|*
name|namepad
init|=
name|AvARRAY
argument_list|(
name|comppad_name
argument_list|)
decl_stmt|;
name|SV
modifier|*
modifier|*
name|curpad
init|=
name|AvARRAY
argument_list|(
name|comppad
argument_list|)
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|comppad_name
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
init|=
name|namepad
index|[
name|ix
index|]
decl_stmt|;
if|if
condition|(
name|namesv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|*
name|SvPVX
argument_list|(
name|namesv
argument_list|)
operator|==
literal|'&'
condition|)
block|{
name|CV
modifier|*
name|innercv
init|=
operator|(
name|CV
operator|*
operator|)
name|curpad
index|[
name|ix
index|]
decl_stmt|;
if|if
condition|(
name|CvOUTSIDE
argument_list|(
name|innercv
argument_list|)
operator|==
name|PL_compcv
condition|)
block|{
name|CvOUTSIDE
argument_list|(
name|innercv
argument_list|)
operator|=
name|cv
expr_stmt|;
if|if
condition|(
operator|!
name|CvANON
argument_list|(
name|innercv
argument_list|)
operator|||
name|CvCLONED
argument_list|(
name|innercv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvREFCNT_inc
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* ... before we throw it away */
name|SvREFCNT_dec
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cv
operator|=
name|PL_compcv
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
block|}
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|gv
expr_stmt|;
name|CvFILE
argument_list|(
name|cv
argument_list|)
operator|=
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|CvSTASH
argument_list|(
name|cv
argument_list|)
operator|=
name|PL_curstash
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
if|if
condition|(
name|ps
condition|)
name|sv_setpv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
block|{
name|op_free
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|block
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|s
operator|=
name|s
condition|?
name|s
operator|+
literal|1
else|:
name|name
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|not_safe
init|=
literal|"BEGIN not safe after errors--compilation aborted"
decl_stmt|;
if|if
condition|(
name|PL_in_eval
operator|&
name|EVAL_KEEPERR
condition|)
name|Perl_croak
argument_list|(
argument|aTHX_ not_safe
argument_list|)
empty_stmt|;
else|else
block|{
comment|/* force display of errors found but not reported */
name|sv_catpv
argument_list|(
name|ERRSV
argument_list|,
name|not_safe
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s"
argument_list|,
name|SvPVx
argument_list|(
name|ERRSV
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|block
condition|)
block|{
name|noblock
label|:
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
if|if
condition|(
name|AvFILLp
argument_list|(
name|PL_comppad_name
argument_list|)
operator|<
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
condition|)
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvLVALUE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVESUBLV
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|scalarseq
argument_list|(
name|block
argument_list|)
argument_list|,
name|OP_LEAVESUBLV
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVESUB
argument_list|,
literal|0
argument_list|,
name|scalarseq
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_private
operator||=
name|OPpREFCOUNTED
expr_stmt|;
name|OpREFCNT_set
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|LINKLIST
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now that optimizer has done its work, adjust pad values */
if|if
condition|(
name|CvCLONE
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|namep
init|=
name|AvARRAY
argument_list|(
name|PL_comppad_name
argument_list|)
decl_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
name|SV
modifier|*
name|namesv
decl_stmt|;
if|if
condition|(
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADGV
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADCONST
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
continue|continue;
comment|/* 	     * The only things that a clonable function needs in its 	     * pad are references to outer lexicals and anonymous subs. 	     * The rest are created anew during cloning. 	     */
if|if
condition|(
operator|!
operator|(
operator|(
name|namesv
operator|=
name|namep
index|[
name|ix
index|]
operator|)
operator|!=
name|Nullsv
operator|&&
name|namesv
operator|!=
operator|&
name|PL_sv_undef
operator|&&
operator|(
name|SvFAKE
argument_list|(
name|namesv
argument_list|)
operator|||
operator|*
name|SvPVX
argument_list|(
name|namesv
argument_list|)
operator|==
literal|'&'
operator|)
operator|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|Nullsv
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|AV
modifier|*
name|av
init|=
name|newAV
argument_list|()
decl_stmt|;
comment|/* Will be @_ */
name|av_extend
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|AvFLAGS
argument_list|(
name|av
argument_list|)
operator|=
name|AVf_REIFY
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADGV
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|||
name|IS_PADCONST
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SvPADMY
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a potential closure prototype, don't keep a refcount on outer CV.      * This is okay as the lifetime of the prototype is tied to the      * lifetime of the outer CV.  Avoids memory leak due to reference      * loop. --GSAR */
if|if
condition|(
operator|!
name|name
condition|)
name|SvREFCNT_dec
argument_list|(
name|CvOUTSIDE
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|||
name|aname
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tname
init|=
operator|(
name|name
condition|?
name|name
else|:
name|aname
operator|)
decl_stmt|;
if|if
condition|(
name|PERLDB_SUBLINE
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|tmpstr
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|GV
modifier|*
name|db_postponed
init|=
name|gv_fetchpv
argument_list|(
literal|"DB::postponed"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
decl_stmt|;
name|CV
modifier|*
name|pcv
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"%s:%ld-%ld"
argument_list|,
argument|CopFILE(PL_curcop)
argument_list|,
argument|(long)PL_subline
argument_list|,
argument|(long)CopLINE(PL_curcop)
argument_list|)
empty_stmt|;
name|gv_efullname3
argument_list|(
name|tmpstr
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|hv_store
argument_list|(
name|GvHV
argument_list|(
name|PL_DBsub
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hv
operator|=
name|GvHVn
argument_list|(
name|db_postponed
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvFILL
argument_list|(
name|hv
argument_list|)
operator|>
literal|0
operator|&&
name|hv_exists
argument_list|(
name|hv
argument_list|,
name|SvPVX
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|tmpstr
argument_list|)
argument_list|)
operator|&&
operator|(
name|pcv
operator|=
name|GvCV
argument_list|(
name|db_postponed
argument_list|)
operator|)
condition|)
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|XPUSHs
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|pcv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|tname
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|tname
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'B'
operator|&&
operator|*
name|s
operator|!=
literal|'E'
operator|&&
operator|*
name|s
operator|!=
literal|'C'
operator|&&
operator|*
name|s
operator|!=
literal|'I'
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
name|I32
name|oldscope
init|=
name|PL_scopestack_ix
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVECOPFILE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
expr_stmt|;
name|save_svref
argument_list|(
operator|&
name|PL_rs
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|PL_rs
argument_list|,
name|PL_nrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_beginav
condition|)
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_sub
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|av_push
argument_list|(
name|PL_beginav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_beginav
argument_list|)
expr_stmt|;
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_compiling
operator|.
name|op_private
operator|=
name|PL_hints
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"END"
argument_list|)
operator|&&
operator|!
name|PL_error_count
condition|)
block|{
if|if
condition|(
operator|!
name|PL_endav
condition|)
name|PL_endav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_sub
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|av_unshift
argument_list|(
name|PL_endav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_endav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"CHECK"
argument_list|)
operator|&&
operator|!
name|PL_error_count
condition|)
block|{
if|if
condition|(
operator|!
name|PL_checkav
condition|)
name|PL_checkav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_sub
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_main_start
operator|&&
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_VOID
argument_list|,
literal|"Too late to run CHECK block"
argument_list|)
empty_stmt|;
name|av_unshift
argument_list|(
name|PL_checkav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_checkav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"INIT"
argument_list|)
operator|&&
operator|!
name|PL_error_count
condition|)
block|{
if|if
condition|(
operator|!
name|PL_initav
condition|)
name|PL_initav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|DEBUG_x
argument_list|(
name|dump_sub
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_main_start
operator|&&
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_VOID
argument_list|,
literal|"Too late to run INIT block"
argument_list|)
empty_stmt|;
name|av_push
argument_list|(
name|PL_initav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
block|}
name|done
label|:
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
end_function

begin_comment
comment|/* XXX unsafe for threads if eval_owner isn't held */
end_comment

begin_comment
comment|/* =for apidoc newCONSTSUB  Creates a constant sub equivalent to Perl C<sub FOO () { 123 }> which is eligible for inlining at compile-time.  =cut */
end_comment

begin_function
name|void
name|Perl_newCONSTSUB
parameter_list|(
name|pTHX_
name|HV
modifier|*
name|stash
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|ENTER
expr_stmt|;
name|SAVECOPLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|SAVEHINTS
argument_list|()
expr_stmt|;
name|PL_hints
operator|&=
operator|~
name|HINT_BLOCK_SCOPE
expr_stmt|;
if|if
condition|(
name|stash
condition|)
block|{
name|SAVESPTR
argument_list|(
name|PL_curstash
argument_list|)
expr_stmt|;
name|SAVECOPSTASH
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|stash
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|CopSTASHPV
argument_list|(
name|PL_curcop
argument_list|)
operator|=
name|stash
condition|?
name|HvNAME
argument_list|(
name|stash
argument_list|)
else|:
name|Nullch
expr_stmt|;
else|#
directive|else
name|CopSTASH
argument_list|(
name|PL_curcop
argument_list|)
operator|=
name|stash
expr_stmt|;
endif|#
directive|endif
block|}
name|newATTRSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_sv_no
argument_list|)
argument_list|,
comment|/* SvPV(&PL_sv_no) == "" -- GMB */
name|Nullop
argument_list|,
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc U||newXS  Used by C<xsubpp> to hook up XSUBs as Perl subs.  =cut */
end_comment

begin_function
name|CV
modifier|*
name|Perl_newXS
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|,
name|XSUBADDR_t
name|subaddr
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
condition|?
name|name
else|:
literal|"__ANON__"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
operator|(
name|name
condition|?
name|GvCV
argument_list|(
name|gv
argument_list|)
else|:
name|Nullcv
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
condition|)
block|{
comment|/* just a cached method */
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|||
name|GvASSUMECV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
comment|/* already defined (or promised) */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REDEFINE
argument_list|)
operator|&&
operator|!
operator|(
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|&&
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"autouse"
argument_list|)
operator|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
if|if
condition|(
name|PL_copline
operator|!=
name|NOLINE
condition|)
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REDEFINE
argument_list|,
literal|"Subroutine %s redefined"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|cv
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cv
condition|)
comment|/* must reuse cv if autoloaded */
name|cv_undef
argument_list|(
name|cv
argument_list|)
expr_stmt|;
else|else
block|{
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1105
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
block|}
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|gv
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvOWNER
argument_list|(
name|cv
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
operator|(
name|void
operator|)
name|gv_fetchfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|CvFILE
argument_list|(
name|cv
argument_list|)
operator|=
name|filename
expr_stmt|;
comment|/* NOTE: not copied, as it is expected to be 				   an external constant string */
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|=
name|subaddr
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'B'
operator|&&
operator|*
name|s
operator|!=
literal|'E'
operator|&&
operator|*
name|s
operator|!=
literal|'C'
operator|&&
operator|*
name|s
operator|!=
literal|'I'
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_beginav
condition|)
name|PL_beginav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_beginav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"END"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_endav
condition|)
name|PL_endav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_unshift
argument_list|(
name|PL_endav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_endav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"CHECK"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_checkav
condition|)
name|PL_checkav
operator|=
name|newAV
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_main_start
operator|&&
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_VOID
argument_list|,
literal|"Too late to run CHECK block"
argument_list|)
empty_stmt|;
name|av_unshift
argument_list|(
name|PL_checkav
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_checkav
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"INIT"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PL_initav
condition|)
name|PL_initav
operator|=
name|newAV
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_main_start
operator|&&
name|ckWARN
argument_list|(
name|WARN_VOID
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_VOID
argument_list|,
literal|"Too late to run INIT block"
argument_list|)
empty_stmt|;
name|av_push
argument_list|(
name|PL_initav
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* cv has been hijacked */
block|}
block|}
else|else
name|CvANON_on
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|done
label|:
return|return
name|cv
return|;
block|}
end_function

begin_function
name|void
name|Perl_newFORM
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
specifier|register
name|CV
modifier|*
name|cv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|I32
name|ix
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
name|o
condition|)
name|name
operator|=
name|SvPVx
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|"STDOUT"
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVFM
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cv
operator|=
name|GvFORM
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REDEFINE
argument_list|)
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_copline
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REDEFINE
argument_list|,
literal|"Format %s redefined"
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
name|cv
operator|=
name|PL_compcv
expr_stmt|;
name|GvFORM
argument_list|(
name|gv
argument_list|)
operator|=
name|cv
expr_stmt|;
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|=
name|gv
expr_stmt|;
name|CvFILE
argument_list|(
name|cv
argument_list|)
operator|=
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|AvFILLp
argument_list|(
name|PL_comppad
argument_list|)
init|;
name|ix
operator|>
literal|0
condition|;
name|ix
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|SvPADMY
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
operator|&&
operator|!
name|SvIMMORTAL
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
condition|)
name|SvPADTMP_on
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|=
name|newUNOP
argument_list|(
name|OP_LEAVEWRITE
argument_list|,
literal|0
argument_list|,
name|scalarseq
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_private
operator||=
name|OPpREFCOUNTED
expr_stmt|;
name|OpREFCNT_set
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CvSTART
argument_list|(
name|cv
argument_list|)
operator|=
name|LINKLIST
argument_list|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
name|peep
argument_list|(
name|CvSTART
argument_list|(
name|cv
argument_list|)
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|PL_copline
operator|=
name|NOLINE
expr_stmt|;
name|LEAVE_SCOPE
argument_list|(
name|floor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newANONLIST
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ANONLIST
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newANONHASH
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|mod
argument_list|(
name|list
argument_list|(
name|convert
argument_list|(
name|OP_ANONHASH
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
argument_list|)
argument_list|,
name|OP_REFGEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newANONSUB
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
return|return
name|newANONATTRSUB
argument_list|(
name|floor
argument_list|,
name|proto
argument_list|,
name|Nullop
argument_list|,
name|block
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newANONATTRSUB
parameter_list|(
name|pTHX_
name|I32
name|floor
parameter_list|,
name|OP
modifier|*
name|proto
parameter_list|,
name|OP
modifier|*
name|attrs
parameter_list|,
name|OP
modifier|*
name|block
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|newSVOP
argument_list|(
name|OP_ANONCODE
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|newATTRSUB
argument_list|(
name|floor
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|,
name|attrs
argument_list|,
name|block
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_oopsAV
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_PADSV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PADAV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PADAV
index|]
expr_stmt|;
return|return
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2AV
argument_list|)
return|;
case|case
name|OP_RV2SV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2AV
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"oops: oopsAV"
argument_list|)
empty_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_oopsHV
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_PADSV
case|:
case|case
name|OP_PADAV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_PADHV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PADHV
index|]
expr_stmt|;
return|return
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2HV
argument_list|)
return|;
case|case
name|OP_RV2SV
case|:
case|case
name|OP_RV2AV
case|:
name|o
operator|->
name|op_type
operator|=
name|OP_RV2HV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2HV
index|]
expr_stmt|;
name|ref
argument_list|(
name|o
argument_list|,
name|OP_RV2HV
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"oops: oopsHV"
argument_list|)
empty_stmt|;
break|break;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newAVREF
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADAV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PADAV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newGVREF
parameter_list|(
name|pTHX_
name|I32
name|type
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|OP_MAPSTART
operator|||
name|type
operator|==
name|OP_GREPSTART
operator|||
name|type
operator|==
name|OP_SORT
condition|)
return|return
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|o
argument_list|)
return|;
return|return
name|ref
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
name|OPf_REF
argument_list|,
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newHVREF
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADHV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PADHV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2HV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_oopsCV
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"NOT IMPL LINE %d"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* STUB */
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newCVREF
parameter_list|(
name|pTHX_
name|I32
name|flags
parameter_list|,
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_newSVREF
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_PADANY
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_PADSV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PADSV
index|]
expr_stmt|;
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_THREADSV
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPpDONE_SVREF
operator|)
condition|)
block|{
name|o
operator|->
name|op_flags
operator||=
name|OPpDONE_SVREF
expr_stmt|;
return|return
name|o
return|;
block|}
return|return
name|newUNOP
argument_list|(
name|OP_RV2SV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check routines. */
end_comment

begin_function
name|OP
modifier|*
name|Perl_ck_anoncode
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|PADOFFSET
name|ix
decl_stmt|;
name|SV
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|NEWSV
argument_list|(
literal|1106
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|name
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|name
argument_list|,
literal|"&"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|name
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|SvNVX
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ix
operator|=
name|pad_alloc
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|SVs_PADMY
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
name|ix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|PL_comppad
argument_list|,
name|ix
argument_list|,
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
name|cSVOPo
operator|->
name|op_targ
operator|=
name|ix
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_bitop
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator|=
name|PL_hints
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_concat
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_CONCAT
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_spair
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|newop
decl_stmt|;
name|OP
modifier|*
name|kid
decl_stmt|;
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
name|o
operator|=
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
expr_stmt|;
name|newop
operator|=
name|kUNOP
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|newop
operator|&&
operator|(
name|newop
operator|->
name|op_sibling
operator|||
operator|!
operator|(
name|PL_opargs
index|[
name|newop
operator|->
name|op_type
index|]
operator|&
name|OA_RETSCALAR
operator|)
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_PADAV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_PADHV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_RV2AV
operator|||
name|newop
operator|->
name|op_type
operator|==
name|OP_RV2HV
operator|)
condition|)
block|{
return|return
name|o
return|;
block|}
name|op_free
argument_list|(
name|kUNOP
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|kUNOP
operator|->
name|op_first
operator|=
name|newop
expr_stmt|;
block|}
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
operator|++
name|o
operator|->
name|op_type
index|]
expr_stmt|;
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_delete
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
switch|switch
condition|(
name|kid
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_ASLICE
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_HSLICE
case|:
name|o
operator|->
name|op_private
operator||=
name|OPpSLICE
expr_stmt|;
break|break;
case|case
name|OP_AELEM
case|:
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|OP_HELEM
case|:
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s argument is not a HASH or ARRAY element or slice"
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_eof
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
if|if
condition|(
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_STUB
condition|)
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|type
argument_list|,
name|OPf_SPECIAL
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"main::ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_eval
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|PL_hints
operator||=
name|HINT_BLOCK_SCOPE
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_KIDS
expr_stmt|;
name|null
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_LINESEQ
condition|)
block|{
name|LOGOP
modifier|*
name|enter
decl_stmt|;
name|kid
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
name|cUNOPo
operator|->
name|op_first
operator|=
literal|0
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|enter
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|enter
operator|->
name|op_type
operator|=
name|OP_ENTERTRY
expr_stmt|;
name|enter
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_ENTERTRY
index|]
expr_stmt|;
name|enter
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
comment|/* establish postfix order */
name|enter
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|enter
expr_stmt|;
name|o
operator|=
name|prepend_elem
argument_list|(
name|OP_LINESEQ
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|enter
argument_list|,
operator|(
name|OP
operator|*
operator|)
name|kid
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LEAVETRY
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_LEAVETRY
index|]
expr_stmt|;
name|enter
operator|->
name|op_other
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
else|else
name|scalar
argument_list|(
operator|(
name|OP
operator|*
operator|)
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_ENTEREVAL
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|op_targ
operator|=
operator|(
name|PADOFFSET
operator|)
name|PL_hints
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_exit
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|HV
modifier|*
name|table
init|=
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
init|=
name|hv_fetch
argument_list|(
name|table
argument_list|,
literal|"vmsish_exit"
argument_list|,
literal|11
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
operator|&&
name|SvTRUE
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpEXIT_VMSISH
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_exec
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
name|o
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_exists
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
condition|)
block|{
operator|(
name|void
operator|)
name|ref
argument_list|(
name|kid
argument_list|,
name|o
operator|->
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2CV
operator|&&
operator|!
name|PL_error_count
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s argument is not a subroutine name"
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|OPpEXISTS_SUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_AELEM
condition|)
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_HELEM
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s argument is not a HASH or ARRAY element"
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|OP * Perl_ck_gvconst(pTHX_ register OP *o) {     o = fold_constants(o);     if (o->op_type == OP_CONST) 	o->op_type = OP_GV;     return o; }
endif|#
directive|endif
end_endif

begin_function
name|OP
modifier|*
name|Perl_ck_rvconst
parameter_list|(
name|pTHX_
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|iscv
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|SV
modifier|*
name|kidsv
init|=
name|kid
operator|->
name|op_sv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
comment|/* Is it a constant from cv_const_sv()? */
if|if
condition|(
name|SvROK
argument_list|(
name|kidsv
argument_list|)
operator|&&
name|SvREADONLY
argument_list|(
name|kidsv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|rsv
init|=
name|SvRV
argument_list|(
name|kidsv
argument_list|)
decl_stmt|;
name|int
name|svtype
init|=
name|SvTYPE
argument_list|(
name|rsv
argument_list|)
decl_stmt|;
name|char
modifier|*
name|badtype
init|=
name|Nullch
decl_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_RV2SV
case|:
if|if
condition|(
name|svtype
operator|>
name|SVt_PVMG
condition|)
name|badtype
operator|=
literal|"a SCALAR"
expr_stmt|;
break|break;
case|case
name|OP_RV2AV
case|:
if|if
condition|(
name|svtype
operator|!=
name|SVt_PVAV
condition|)
name|badtype
operator|=
literal|"an ARRAY"
expr_stmt|;
break|break;
case|case
name|OP_RV2HV
case|:
if|if
condition|(
name|svtype
operator|!=
name|SVt_PVHV
condition|)
block|{
if|if
condition|(
name|svtype
operator|==
name|SVt_PVAV
condition|)
block|{
comment|/* pseudohash? */
name|SV
modifier|*
modifier|*
name|ksv
init|=
name|av_fetch
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|rsv
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ksv
operator|&&
name|SvROK
argument_list|(
operator|*
name|ksv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
operator|*
name|ksv
argument_list|)
argument_list|)
operator|==
name|SVt_PVHV
condition|)
block|{
break|break;
block|}
block|}
name|badtype
operator|=
literal|"a HASH"
expr_stmt|;
block|}
break|break;
case|case
name|OP_RV2CV
case|:
if|if
condition|(
name|svtype
operator|!=
name|SVt_PVCV
condition|)
name|badtype
operator|=
literal|"a CODE"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|badtype
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Constant is not %s reference"
argument_list|,
name|badtype
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
name|name
operator|=
name|SvPV
argument_list|(
name|kidsv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|badthing
init|=
name|Nullch
decl_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_RV2SV
case|:
name|badthing
operator|=
literal|"a SCALAR"
expr_stmt|;
break|break;
case|case
name|OP_RV2AV
case|:
name|badthing
operator|=
literal|"an ARRAY"
expr_stmt|;
break|break;
case|case
name|OP_RV2HV
case|:
name|badthing
operator|=
literal|"a HASH"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|badthing
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use bareword (\"%s\") as %s ref while \"strict refs\" in use"
argument_list|,
name|name
argument_list|,
name|badthing
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This is a little tricky.  We only want to add the symbol if we 	 * didn't add it in the lexer.  Otherwise we get duplicate strict 	 * warnings.  But if we didn't add it in the lexer, we must at 	 * least pretend like we wanted to add it even if it existed before, 	 * or we get possible typo warnings.  OPpCONST_ENTERED says 	 * whether the lexer already added THIS instance of this symbol. 	 */
name|iscv
operator|=
operator|(
name|o
operator|->
name|op_type
operator|==
name|OP_RV2CV
operator|)
operator|*
literal|2
expr_stmt|;
do|do
block|{
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|iscv
operator||
operator|!
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_ENTERED
operator|)
argument_list|,
name|iscv
condition|?
name|SVt_PVCV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|?
name|SVt_PV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2AV
condition|?
name|SVt_PVAV
else|:
name|o
operator|->
name|op_type
operator|==
name|OP_RV2HV
condition|?
name|SVt_PVHV
else|:
name|SVt_PVGV
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|gv
operator|&&
operator|!
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_ENTERED
operator|)
operator|&&
operator|!
name|iscv
operator|++
condition|)
do|;
if|if
condition|(
name|gv
condition|)
block|{
name|kid
operator|->
name|op_type
operator|=
name|OP_GV
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
comment|/* XXX hack: dependence on sizeof(PADOP)<= sizeof(SVOP) */
name|kPADOP
operator|->
name|op_padix
operator|=
name|pad_alloc
argument_list|(
name|OP_GV
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_curpad
index|[
name|kPADOP
operator|->
name|op_padix
index|]
argument_list|)
expr_stmt|;
name|GvIN_PAD_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|kPADOP
operator|->
name|op_padix
index|]
operator|=
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
else|#
directive|else
name|kid
operator|->
name|op_sv
operator|=
name|SvREFCNT_inc
argument_list|(
name|gv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kid
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
name|kid
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_GV
index|]
expr_stmt|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_ftst
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_REF
condition|)
block|{
comment|/* nothing */
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|&&
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_STUB
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|OP
modifier|*
name|newop
init|=
name|newGVOP
argument_list|(
name|type
argument_list|,
name|OPf_REF
argument_list|,
name|gv_fetchpv
argument_list|(
name|SvPVx
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|newop
expr_stmt|;
block|}
block|}
else|else
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_FTTTY
condition|)
name|o
operator|=
name|newGVOP
argument_list|(
name|type
argument_list|,
name|OPf_REF
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"main::STDIN"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|type
operator|==
name|OP_FTTEXT
operator|||
name|type
operator|==
name|OP_FTBINARY
condition|)
block|{
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_fun
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
name|OP
modifier|*
modifier|*
name|tokid
decl_stmt|;
name|OP
modifier|*
name|sibl
decl_stmt|;
name|I32
name|numargs
init|=
literal|0
decl_stmt|;
name|int
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
specifier|register
name|I32
name|oa
init|=
name|PL_opargs
index|[
name|type
index|]
operator|>>
name|OASHIFT
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
if|if
condition|(
operator|(
name|oa
operator|&
name|OA_OPTIONAL
operator|)
operator|&&
operator|(
name|oa
operator|>>
literal|4
operator|)
operator|&&
operator|!
operator|(
operator|(
name|oa
operator|>>
literal|4
operator|)
operator|&
name|OA_OPTIONAL
operator|)
condition|)
name|oa
operator|&=
operator|~
name|OA_OPTIONAL
expr_stmt|;
else|else
return|return
name|no_fh_allowed
argument_list|(
name|o
argument_list|)
return|;
block|}
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|tokid
operator|=
operator|&
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHMARK
operator|||
operator|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
operator|&&
name|kid
operator|->
name|op_targ
operator|==
name|OP_PUSHMARK
operator|)
condition|)
block|{
name|tokid
operator|=
operator|&
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kid
operator|&&
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_DEFGV
condition|)
operator|*
name|tokid
operator|=
name|kid
operator|=
name|newDEFSVOP
argument_list|()
expr_stmt|;
while|while
condition|(
name|oa
operator|&&
name|kid
condition|)
block|{
name|numargs
operator|++
expr_stmt|;
name|sibl
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
switch|switch
condition|(
name|oa
operator|&
literal|7
condition|)
block|{
case|case
name|OA_SCALAR
case|:
comment|/* list seen where single (scalar) arg expected? */
if|if
condition|(
name|numargs
operator|==
literal|1
operator|&&
operator|!
operator|(
name|oa
operator|>>
literal|4
operator|)
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_LIST
operator|&&
name|type
operator|!=
name|OP_SCALAR
condition|)
block|{
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|PL_op_desc
index|[
name|type
index|]
argument_list|)
return|;
block|}
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_LIST
case|:
if|if
condition|(
name|oa
operator|<
literal|16
condition|)
block|{
name|kid
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_AVREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|OP
modifier|*
name|newop
init|=
name|newAVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"Array @%s missing the @ in argument %"
argument|IVdf
literal|" of %s()"
argument_list|,
argument|name
argument_list|,
argument|(IV)numargs
argument_list|,
argument|PL_op_desc[type]
argument_list|)
empty_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2AV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_PADAV
condition|)
name|bad_type
argument_list|(
name|numargs
argument_list|,
literal|"array"
argument_list|,
name|PL_op_desc
index|[
name|type
index|]
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_HVREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
decl_stmt|;
name|OP
modifier|*
name|newop
init|=
name|newHVREF
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"Hash %%%s missing the %% in argument %"
argument|IVdf
literal|" of %s()"
argument_list|,
argument|name
argument_list|,
argument|(IV)numargs
argument_list|,
argument|PL_op_desc[type]
argument_list|)
empty_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_PADHV
condition|)
name|bad_type
argument_list|(
name|numargs
argument_list|,
literal|"hash"
argument_list|,
name|PL_op_desc
index|[
name|type
index|]
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_CVREF
case|:
block|{
name|OP
modifier|*
name|newop
init|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|kid
argument_list|)
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|linklist
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|newop
operator|->
name|op_next
operator|=
name|newop
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
break|break;
case|case
name|OA_FILEREF
case|:
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_GV
operator|&&
name|kid
operator|->
name|op_type
operator|!=
name|OP_RV2GV
condition|)
block|{
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|OP
modifier|*
name|newop
init|=
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
name|SvPVx
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVIO
argument_list|)
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|=
name|newop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_READLINE
condition|)
block|{
comment|/* neophyte patrol: open(<FH>), close(<FH>) etc. */
name|bad_type
argument_list|(
name|numargs
argument_list|,
literal|"HANDLE"
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|,
name|kid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|I32
name|flags
init|=
name|OPf_SPECIAL
decl_stmt|;
name|I32
name|priv
init|=
literal|0
decl_stmt|;
name|PADOFFSET
name|targ
init|=
literal|0
decl_stmt|;
comment|/* is this op a FH constructor? */
if|if
condition|(
name|is_handle_constructor
argument_list|(
name|o
argument_list|,
name|numargs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|Nullch
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Set a flag to tell rv2gv to vivify 			     * need to "prove" flag does not mean something 			     * else already - NI-S 1999/05/07 			     */
name|priv
operator|=
name|OPpDEREF
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PADSV
condition|)
block|{
name|SV
modifier|*
modifier|*
name|namep
init|=
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|kid
operator|->
name|op_targ
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|namep
operator|&&
operator|*
name|namep
condition|)
name|name
operator|=
name|SvPV
argument_list|(
operator|*
name|namep
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|&&
name|kUNOP
operator|->
name|op_first
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPx_gv
argument_list|(
name|kUNOP
operator|->
name|op_first
argument_list|)
decl_stmt|;
name|name
operator|=
name|GvNAME
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|len
operator|=
name|GvNAMELEN
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_AELEM
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_HELEM
condition|)
block|{
name|name
operator|=
literal|"__ANONIO__"
expr_stmt|;
name|len
operator|=
literal|10
expr_stmt|;
name|mod
argument_list|(
name|kid
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|SV
modifier|*
name|namesv
decl_stmt|;
name|targ
operator|=
name|pad_alloc
argument_list|(
name|OP_RV2GV
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
name|namesv
operator|=
name|PL_curpad
index|[
name|targ
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|namesv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'$'
condition|)
name|sv_setpvn
argument_list|(
name|namesv
argument_list|,
literal|"$"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|namesv
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|kid
operator|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
name|flags
argument_list|,
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_targ
operator|=
name|targ
expr_stmt|;
name|kid
operator|->
name|op_private
operator||=
name|priv
expr_stmt|;
block|}
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
operator|*
name|tokid
operator|=
name|kid
expr_stmt|;
block|}
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
break|break;
case|case
name|OA_SCALARREF
case|:
name|mod
argument_list|(
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|oa
operator|>>=
literal|4
expr_stmt|;
name|tokid
operator|=
operator|&
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
name|o
operator|->
name|op_private
operator||=
name|numargs
expr_stmt|;
if|if
condition|(
name|kid
condition|)
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_opargs
index|[
name|type
index|]
operator|&
name|OA_DEFGV
condition|)
block|{
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|oa
condition|)
block|{
while|while
condition|(
name|oa
operator|&
name|OA_OPTIONAL
condition|)
name|oa
operator|>>=
literal|4
expr_stmt|;
if|if
condition|(
name|oa
operator|&&
name|oa
operator|!=
name|OA_LIST
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_glob
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
operator|!
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"glob"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
operator|)
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
operator|)
condition|)
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::glob"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_EXTERNAL_GLOB
argument_list|)
comment|/* XXX this can be tightened up and made more failsafe. */
if|if
condition|(
operator|!
name|gv
condition|)
block|{
name|ENTER
expr_stmt|;
name|Perl_load_module
argument_list|(
name|aTHX_
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"File::Glob"
argument_list|,
literal|10
argument_list|)
argument_list|,
name|Nullsv
argument_list|,
comment|/* null-terminated import list */
name|newSVpvn
argument_list|(
literal|":globally"
argument_list|,
literal|9
argument_list|)
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::glob"
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PERL_EXTERNAL_GLOB */
if|if
condition|(
name|gv
operator|&&
name|GvIMPORTED_CV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
name|PL_glob_index
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_LIST
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_LIST
index|]
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_type
operator|=
name|OP_PUSHMARK
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PUSHMARK
index|]
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_ENTERSUB
argument_list|,
name|OPf_STACKED
argument_list|,
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|o
argument_list|,
name|scalar
argument_list|(
name|newUNOP
argument_list|(
name|OP_RV2CV
argument_list|,
literal|0
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|newUNOP
argument_list|(
name|OP_NULL
argument_list|,
literal|0
argument_list|,
name|ck_subr
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|OP_GLOB
expr_stmt|;
comment|/* hint at what it used to be */
return|return
name|o
return|;
block|}
name|gv
operator|=
name|newGVgen
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
name|gv_IOadd
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|append_elem
argument_list|(
name|OP_GLOB
argument_list|,
name|o
argument_list|,
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|)
expr_stmt|;
comment|/* had excess refcnt */
name|scalarkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_grep
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|LOGOP
modifier|*
name|gwop
decl_stmt|;
name|OP
modifier|*
name|kid
decl_stmt|;
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
operator|==
name|OP_GREPSTART
condition|?
name|OP_GREPWHILE
else|:
name|OP_MAPWHILE
decl_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_GREPSTART
index|]
expr_stmt|;
name|NewOp
argument_list|(
literal|1101
argument_list|,
name|gwop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|OP
modifier|*
name|k
decl_stmt|;
name|o
operator|=
name|ck_sort
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
for|for
control|(
name|k
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|->
name|op_next
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|op_next
control|)
block|{
name|kid
operator|=
name|k
expr_stmt|;
block|}
name|kid
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|gwop
expr_stmt|;
name|o
operator|->
name|op_flags
operator|&=
operator|~
name|OPf_STACKED
expr_stmt|;
block|}
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OP_MAPWHILE
condition|)
name|list
argument_list|(
name|kid
argument_list|)
expr_stmt|;
else|else
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_error_count
condition|)
return|return
name|o
return|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_NULL
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: ck_grep"
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
name|gwop
operator|->
name|op_type
operator|=
name|type
expr_stmt|;
name|gwop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|type
index|]
expr_stmt|;
name|gwop
operator|->
name|op_first
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|gwop
operator|->
name|op_flags
operator||=
name|OPf_KIDS
expr_stmt|;
name|gwop
operator|->
name|op_private
operator|=
literal|1
expr_stmt|;
name|gwop
operator|->
name|op_other
operator|=
name|LINKLIST
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|gwop
operator|->
name|op_targ
operator|=
name|pad_alloc
argument_list|(
name|type
argument_list|,
name|SVs_PADTMP
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
operator|(
name|OP
operator|*
operator|)
name|gwop
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|||
operator|!
name|kid
operator|->
name|op_sibling
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
for|for
control|(
name|kid
operator|=
name|kid
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|OP_GREPSTART
argument_list|)
expr_stmt|;
return|return
operator|(
name|OP
operator|*
operator|)
name|gwop
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_index
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past "big" */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|fbm_compile
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|)
operator|->
name|op_sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_lengthconst
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
comment|/* XXX length optimization goes here */
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_lfun
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
return|return
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_defined
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
comment|/* 19990527 MJD */
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_DEPRECATED
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_RV2AV
case|:
comment|/* This is needed for 	       if (defined %stash::) 	       to work.   Do not break Tk. 	       */
break|break;
comment|/* Globals via GV can be undef */
case|case
name|OP_PADAV
case|:
case|case
name|OP_AASSIGN
case|:
comment|/* Is this a good idea? */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"defined(@array) is deprecated"
argument_list|)
empty_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"\t(Maybe you should just omit the defined()?)\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|OP_RV2HV
case|:
comment|/* This is needed for 	       if (defined %stash::) 	       to work.   Do not break Tk. 	       */
break|break;
comment|/* Globals via GV can be undef */
case|case
name|OP_PADHV
case|:
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"defined(%%hash) is deprecated"
argument_list|)
empty_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEPRECATED
argument_list|,
literal|"\t(Maybe you should just omit the defined()?)\n"
argument_list|)
empty_stmt|;
break|break;
default|default:
comment|/* no warning */
break|break;
block|}
block|}
return|return
name|ck_rfun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_rfun
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OPCODE
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
return|return
name|refkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_listiob
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|o
operator|=
name|force_list
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
block|}
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_PUSHMARK
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
elseif|else
if|if
condition|(
name|kid
operator|&&
operator|!
name|kid
operator|->
name|op_sibling
condition|)
block|{
comment|/* print HANDLE; */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
condition|)
block|{
name|o
operator|->
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
comment|/* make it a filehandle */
name|kid
operator|=
name|newUNOP
argument_list|(
name|OP_RV2GV
argument_list|,
name|OPf_REF
argument_list|,
name|scalar
argument_list|(
name|kid
argument_list|)
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|=
name|kid
expr_stmt|;
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|kid
condition|)
name|append_elem
argument_list|(
name|o
operator|->
name|op_type
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|=
name|listkids
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_fun_locale
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_sassign
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
decl_stmt|;
comment|/* has a disposable target? */
if|if
condition|(
operator|(
name|PL_opargs
index|[
name|kid
operator|->
name|op_type
index|]
operator|&
name|OA_TARGLEX
operator|)
operator|&&
operator|!
operator|(
name|kid
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
comment|/* Cannot steal the second time! */
operator|&&
operator|!
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpTARGET_MY
operator|)
condition|)
block|{
name|OP
modifier|*
name|kkid
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
comment|/* Can just relocate the target. */
if|if
condition|(
name|kkid
operator|&&
name|kkid
operator|->
name|op_type
operator|==
name|OP_PADSV
operator|&&
operator|!
operator|(
name|kkid
operator|->
name|op_private
operator|&
name|OPpLVAL_INTRO
operator|)
condition|)
block|{
name|kid
operator|->
name|op_targ
operator|=
name|kkid
operator|->
name|op_targ
expr_stmt|;
name|kkid
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* Now we do not need PADSV and SASSIGN. */
name|kid
operator|->
name|op_sibling
operator|=
name|o
operator|->
name|op_sibling
expr_stmt|;
comment|/* NULL */
name|cLISTOPo
operator|->
name|op_first
operator|=
name|NULL
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|kkid
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_private
operator||=
name|OPpTARGET_MY
expr_stmt|;
comment|/* Used for context settings */
return|return
name|kid
return|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_scmp
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_match
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpRUNTIME
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_method
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|kSVOP
operator|->
name|op_sv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|strchr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|||
name|strchr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|'\''
argument_list|)
operator|)
condition|)
block|{
name|OP
modifier|*
name|cmop
decl_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|PERL_HASH
argument_list|(
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|cmop
operator|=
name|newSVOP
argument_list|(
name|OP_METHOD_NAMED
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|kSVOP
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|cmop
return|;
block|}
block|}
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_null
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_open
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|HV
modifier|*
name|table
init|=
name|GvHV
argument_list|(
name|PL_hintgv
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|;
name|I32
name|mode
decl_stmt|;
name|svp
operator|=
name|hv_fetch
argument_list|(
name|table
argument_list|,
literal|"open_IN"
argument_list|,
literal|7
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
condition|)
block|{
name|mode
operator|=
name|mode_from_discipline
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_BINARY
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpOPEN_IN_RAW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|O_TEXT
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpOPEN_IN_CRLF
expr_stmt|;
block|}
name|svp
operator|=
name|hv_fetch
argument_list|(
name|table
argument_list|,
literal|"open_OUT"
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|&&
operator|*
name|svp
condition|)
block|{
name|mode
operator|=
name|mode_from_discipline
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_BINARY
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpOPEN_OUT_RAW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|O_TEXT
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpOPEN_OUT_CRLF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_BACKTICK
condition|)
return|return
name|o
return|;
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_repeat
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|cBINOPo
operator|->
name|op_first
operator|->
name|op_flags
operator|&
name|OPf_PARENS
condition|)
block|{
name|o
operator|->
name|op_private
operator||=
name|OPpREPEAT_DOLIST
expr_stmt|;
name|cBINOPo
operator|->
name|op_first
operator|=
name|force_list
argument_list|(
name|cBINOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
block|}
else|else
name|scalar
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_require
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
comment|/* Shall we supply missing .pm? */
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|SvPVX
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|s
operator|=
literal|'/'
expr_stmt|;
name|Move
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|s
operator|+
literal|2
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|--
name|SvCUR
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
condition|)
block|{
name|SvREADONLY_off
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
literal|".pm"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_catpvn
argument_list|(
name|kid
operator|->
name|op_sv
argument_list|,
literal|".pm"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_return
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|CvLVALUE
argument_list|(
name|PL_compcv
argument_list|)
condition|)
block|{
for|for
control|(
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
init|;
name|kid
condition|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
control|)
name|mod
argument_list|(
name|kid
argument_list|,
name|OP_LEAVESUBLV
argument_list|)
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|OP * Perl_ck_retarget(pTHX_ OP *o) {     Perl_croak(aTHX_ "NOT IMPL LINE %d",__LINE__);
comment|/* STUB */
end_comment

begin_endif
unit|return o; }
endif|#
directive|endif
end_endif

begin_function
name|OP
modifier|*
name|Perl_ck_select
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_sibling
condition|)
block|{
name|o
operator|->
name|op_type
operator|=
name|OP_SSELECT
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_SSELECT
index|]
expr_stmt|;
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|fold_constants
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
name|kid
operator|->
name|op_private
operator|&=
operator|~
name|HINT_STRICT_REFS
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_shift
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|I32
name|type
init|=
name|o
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
condition|)
block|{
name|OP
modifier|*
name|argop
decl_stmt|;
name|op_free
argument_list|(
name|o
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|)
block|{
name|argop
operator|=
name|newOP
argument_list|(
name|OP_PADAV
argument_list|,
name|OPf_REF
argument_list|)
expr_stmt|;
name|argop
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
comment|/* PL_curpad[0] is @_ */
block|}
else|else
block|{
name|argop
operator|=
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
name|gv_fetchpv
argument_list|(
literal|"ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|argop
operator|=
name|newUNOP
argument_list|(
name|OP_RV2AV
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|newGVOP
argument_list|(
name|OP_GV
argument_list|,
literal|0
argument_list|,
operator|!
name|CvUNIQUE
argument_list|(
name|PL_compcv
argument_list|)
condition|?
name|PL_defgv
else|:
name|gv_fetchpv
argument_list|(
literal|"ARGV"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
return|return
name|newUNOP
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|scalar
argument_list|(
name|argop
argument_list|)
argument_list|)
return|;
block|}
return|return
name|scalar
argument_list|(
name|modkids
argument_list|(
name|ck_fun
argument_list|(
name|o
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_sort
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|firstkid
decl_stmt|;
name|o
operator|->
name|op_private
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LOCALE
if|if
condition|(
name|PL_hints
operator|&
name|HINT_LOCALE
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpLOCALE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
operator|&&
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
name|simplify_sort
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|firstkid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* get past pushmark */
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
comment|/* may have been cleared */
name|OP
modifier|*
name|k
decl_stmt|;
name|OP
modifier|*
name|kid
init|=
name|cUNOPx
argument_list|(
name|firstkid
argument_list|)
operator|->
name|op_first
decl_stmt|;
comment|/* get past null */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_SCOPE
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_LEAVE
condition|)
block|{
name|linklist
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_SCOPE
condition|)
block|{
name|k
operator|=
name|kid
operator|->
name|op_next
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_LEAVE
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
condition|)
block|{
name|null
argument_list|(
name|kid
argument_list|)
expr_stmt|;
comment|/* wipe out leave */
name|kid
operator|->
name|op_next
operator|=
name|kid
expr_stmt|;
for|for
control|(
name|k
operator|=
name|kLISTOP
operator|->
name|op_first
operator|->
name|op_next
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|op_next
control|)
block|{
if|if
condition|(
name|k
operator|->
name|op_next
operator|==
name|kid
condition|)
name|k
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
comment|/* don't descend into loops */
elseif|else
if|if
condition|(
name|k
operator|->
name|op_type
operator|==
name|OP_ENTERLOOP
operator|||
name|k
operator|->
name|op_type
operator|==
name|OP_ENTERITER
condition|)
block|{
name|k
operator|=
name|cLOOPx
argument_list|(
name|k
argument_list|)
operator|->
name|op_lastop
expr_stmt|;
block|}
block|}
block|}
else|else
name|kid
operator|->
name|op_next
operator|=
literal|0
expr_stmt|;
comment|/* just disconnect the leave */
name|k
operator|=
name|kLISTOP
operator|->
name|op_first
expr_stmt|;
block|}
name|peep
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|kid
operator|=
name|firstkid
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
condition|)
block|{
comment|/* provide scalar context for comparison function/block */
name|kid
operator|=
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|kid
operator|->
name|op_next
operator|=
name|kid
expr_stmt|;
block|}
else|else
name|kid
operator|->
name|op_next
operator|=
name|k
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_RV2SV
operator|||
name|kid
operator|->
name|op_type
operator|==
name|OP_PADSV
condition|)
name|null
argument_list|(
name|firstkid
argument_list|)
expr_stmt|;
name|firstkid
operator|=
name|firstkid
operator|->
name|op_sibling
expr_stmt|;
block|}
comment|/* provide list context for arguments */
if|if
condition|(
name|o
operator|->
name|op_type
operator|==
name|OP_SORT
condition|)
name|list
argument_list|(
name|firstkid
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_simplify_sort
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
comment|/* get past pushmark */
name|OP
modifier|*
name|k
decl_stmt|;
name|int
name|reversed
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
operator|)
condition|)
return|return;
name|GvMULTI_on
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"a"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"b"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* get past null */
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_SCOPE
condition|)
return|return;
name|kid
operator|=
name|kLISTOP
operator|->
name|op_last
expr_stmt|;
comment|/* get past scope */
switch|switch
condition|(
name|kid
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_NCMP
case|:
case|case
name|OP_I_NCMP
case|:
case|case
name|OP_SCMP
case|:
break|break;
default|default:
return|return;
block|}
name|k
operator|=
name|kid
expr_stmt|;
comment|/* remember this node*/
if|if
condition|(
name|kBINOP
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_RV2SV
condition|)
return|return;
name|kid
operator|=
name|kBINOP
operator|->
name|op_first
expr_stmt|;
comment|/* get past cmp */
if|if
condition|(
name|kUNOP
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
return|return;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* get past rv2sv */
name|gv
operator|=
name|kGVOP_gv
expr_stmt|;
if|if
condition|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
operator|!=
name|PL_curstash
condition|)
return|return;
if|if
condition|(
name|strEQ
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"a"
argument_list|)
condition|)
name|reversed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"b"
argument_list|)
condition|)
name|reversed
operator|=
literal|1
expr_stmt|;
else|else
return|return;
name|kid
operator|=
name|k
expr_stmt|;
comment|/* back to cmp */
if|if
condition|(
name|kBINOP
operator|->
name|op_last
operator|->
name|op_type
operator|!=
name|OP_RV2SV
condition|)
return|return;
name|kid
operator|=
name|kBINOP
operator|->
name|op_last
expr_stmt|;
comment|/* down to 2nd arg */
if|if
condition|(
name|kUNOP
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_GV
condition|)
return|return;
name|kid
operator|=
name|kUNOP
operator|->
name|op_first
expr_stmt|;
comment|/* get past rv2sv */
name|gv
operator|=
name|kGVOP_gv
expr_stmt|;
if|if
condition|(
name|GvSTASH
argument_list|(
name|gv
argument_list|)
operator|!=
name|PL_curstash
operator|||
operator|(
name|reversed
condition|?
name|strNE
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"a"
argument_list|)
else|:
name|strNE
argument_list|(
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|,
literal|"b"
argument_list|)
operator|)
condition|)
return|return;
name|o
operator|->
name|op_flags
operator|&=
operator|~
operator|(
name|OPf_STACKED
operator||
name|OPf_SPECIAL
operator|)
expr_stmt|;
if|if
condition|(
name|reversed
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpSORT_REVERSE
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|op_type
operator|==
name|OP_NCMP
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpSORT_NUMERIC
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|op_type
operator|==
name|OP_I_NCMP
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpSORT_NUMERIC
operator||
name|OPpSORT_INTEGER
expr_stmt|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
comment|/* bypass old block */
name|op_free
argument_list|(
name|kid
argument_list|)
expr_stmt|;
comment|/* then delete it */
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_split
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
return|return
name|no_fh_allowed
argument_list|(
name|o
argument_list|)
return|;
name|kid
operator|=
name|cLISTOPo
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_NULL
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: ck_split"
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|op_free
argument_list|(
name|cLISTOPo
operator|->
name|op_first
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
expr_stmt|;
if|if
condition|(
operator|!
name|kid
condition|)
block|{
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
comment|/* There was only one element previously */
block|}
if|if
condition|(
name|kid
operator|->
name|op_type
operator|!=
name|OP_MATCH
operator|||
name|kid
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
block|{
name|OP
modifier|*
name|sibl
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|kid
operator|=
name|pmruntime
argument_list|(
name|newPMOP
argument_list|(
name|OP_MATCH
argument_list|,
name|OPf_SPECIAL
argument_list|)
argument_list|,
name|kid
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cLISTOPo
operator|->
name|op_first
operator|==
name|cLISTOPo
operator|->
name|op_last
condition|)
name|cLISTOPo
operator|->
name|op_last
operator|=
name|kid
expr_stmt|;
name|cLISTOPo
operator|->
name|op_first
operator|=
name|kid
expr_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
name|sibl
expr_stmt|;
block|}
name|kid
operator|->
name|op_type
operator|=
name|OP_PUSHRE
expr_stmt|;
name|kid
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_PUSHRE
index|]
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_SPLIT
argument_list|,
name|o
argument_list|,
name|newDEFSVOP
argument_list|()
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kid
operator|->
name|op_sibling
condition|)
name|append_elem
argument_list|(
name|OP_SPLIT
argument_list|,
name|o
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSViv
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
name|scalar
argument_list|(
name|kid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_sibling
condition|)
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|PL_op_desc
index|[
name|o
operator|->
name|op_type
index|]
argument_list|)
return|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_join
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_MATCH
condition|)
block|{
name|char
modifier|*
name|pmstr
init|=
literal|"STRING"
decl_stmt|;
if|if
condition|(
name|kPMOP
operator|->
name|op_pmregexp
condition|)
name|pmstr
operator|=
name|kPMOP
operator|->
name|op_pmregexp
operator|->
name|precomp
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SYNTAX
argument_list|,
literal|"/%s/ should probably be written as \"%s\""
argument_list|,
argument|pmstr
argument_list|,
argument|pmstr
argument_list|)
empty_stmt|;
block|}
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_subr
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|OP
modifier|*
name|prev
init|=
operator|(
operator|(
name|cUNOPo
operator|->
name|op_first
operator|->
name|op_sibling
operator|)
condition|?
name|cUNOPo
else|:
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
operator|)
operator|)
operator|->
name|op_first
decl_stmt|;
name|OP
modifier|*
name|o2
init|=
name|prev
operator|->
name|op_sibling
decl_stmt|;
name|OP
modifier|*
name|cvop
decl_stmt|;
name|char
modifier|*
name|proto
init|=
literal|0
decl_stmt|;
name|CV
modifier|*
name|cv
init|=
literal|0
decl_stmt|;
name|GV
modifier|*
name|namegv
init|=
literal|0
decl_stmt|;
name|int
name|optional
init|=
literal|0
decl_stmt|;
name|I32
name|arg
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
name|o
operator|->
name|op_private
operator||=
name|OPpENTERSUB_HASTARG
expr_stmt|;
for|for
control|(
name|cvop
operator|=
name|o2
init|;
name|cvop
operator|->
name|op_sibling
condition|;
name|cvop
operator|=
name|cvop
operator|->
name|op_sibling
control|)
empty_stmt|;
if|if
condition|(
name|cvop
operator|->
name|op_type
operator|==
name|OP_RV2CV
condition|)
block|{
name|SVOP
modifier|*
name|tmpop
decl_stmt|;
name|o
operator|->
name|op_private
operator||=
operator|(
name|cvop
operator|->
name|op_private
operator|&
name|OPpENTERSUB_AMPER
operator|)
expr_stmt|;
name|null
argument_list|(
name|cvop
argument_list|)
expr_stmt|;
comment|/* disable rv2cv */
name|tmpop
operator|=
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|cvop
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|tmpop
operator|->
name|op_type
operator|==
name|OP_GV
operator|&&
operator|!
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpENTERSUB_AMPER
operator|)
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPx_gv
argument_list|(
name|tmpop
argument_list|)
decl_stmt|;
name|cv
operator|=
name|GvCVu
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cv
condition|)
name|tmpop
operator|->
name|op_private
operator||=
name|OPpEARLY_CV
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPOK
argument_list|(
name|cv
argument_list|)
condition|)
block|{
name|namegv
operator|=
name|CvANON
argument_list|(
name|cv
argument_list|)
condition|?
name|gv
else|:
name|CvGV
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|proto
operator|=
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|n_a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cvop
operator|->
name|op_type
operator|==
name|OP_METHOD
operator|||
name|cvop
operator|->
name|op_type
operator|==
name|OP_METHOD_NAMED
condition|)
block|{
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|o2
operator|->
name|op_private
operator|&=
operator|~
name|OPpCONST_STRICT
expr_stmt|;
elseif|else
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_LIST
condition|)
block|{
name|OP
modifier|*
name|o
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o2
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|o
operator|->
name|op_private
operator|&=
operator|~
name|OPpCONST_STRICT
expr_stmt|;
block|}
block|}
name|o
operator|->
name|op_private
operator||=
operator|(
name|PL_hints
operator|&
name|HINT_STRICT_REFS
operator|)
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
condition|)
name|o
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
while|while
condition|(
name|o2
operator|!=
name|cvop
condition|)
block|{
if|if
condition|(
name|proto
condition|)
block|{
switch|switch
condition|(
operator|*
name|proto
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|too_many_arguments
argument_list|(
name|o
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|)
return|;
case|case
literal|';'
case|:
name|optional
operator|=
literal|1
expr_stmt|;
name|proto
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
name|scalar
argument_list|(
name|o2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
case|case
literal|'@'
case|:
name|list
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|arg
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_REFGEN
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_UNDEF
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
name|arg
operator|==
literal|1
condition|?
literal|"block or sub {}"
else|:
literal|"sub {}"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* '*' allows any scalar type, including bareword */
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_RV2GV
condition|)
goto|goto
name|wrapref
goto|;
comment|/* autoconvert GLOB -> GLOBref */
elseif|else
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_CONST
condition|)
name|o2
operator|->
name|op_private
operator|&=
operator|~
name|OPpCONST_STRICT
expr_stmt|;
elseif|else
if|if
condition|(
name|o2
operator|->
name|op_type
operator|==
name|OP_ENTERSUB
condition|)
block|{
comment|/* accidental subroutine, revert to bareword */
name|OP
modifier|*
name|gvop
init|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|o2
operator|)
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|gvop
operator|&&
name|gvop
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
block|{
name|gvop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|gvop
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|gvop
condition|)
block|{
for|for
control|(
init|;
name|gvop
operator|->
name|op_sibling
condition|;
name|gvop
operator|=
name|gvop
operator|->
name|op_sibling
control|)
empty_stmt|;
if|if
condition|(
name|gvop
operator|&&
operator|(
name|gvop
operator|->
name|op_private
operator|&
name|OPpENTERSUB_NOPAREN
operator|)
operator|&&
operator|(
name|gvop
operator|=
operator|(
operator|(
name|UNOP
operator|*
operator|)
name|gvop
operator|)
operator|->
name|op_first
operator|)
operator|&&
name|gvop
operator|->
name|op_type
operator|==
name|OP_GV
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPx_gv
argument_list|(
name|gvop
argument_list|)
decl_stmt|;
name|OP
modifier|*
name|sibling
init|=
name|o2
operator|->
name|op_sibling
decl_stmt|;
name|SV
modifier|*
name|n
init|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op_free
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|gv_fullname3
argument_list|(
name|n
argument_list|,
name|gv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|n
argument_list|)
operator|>
literal|6
operator|&&
name|strnEQ
argument_list|(
name|SvPVX
argument_list|(
name|n
argument_list|)
argument_list|,
literal|"main::"
argument_list|,
literal|6
argument_list|)
condition|)
name|sv_chop
argument_list|(
name|n
argument_list|,
name|SvPVX
argument_list|(
name|n
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|o2
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|prev
operator|->
name|op_sibling
operator|=
name|o2
expr_stmt|;
name|o2
operator|->
name|op_sibling
operator|=
name|sibling
expr_stmt|;
block|}
block|}
block|}
block|}
name|scalar
argument_list|(
name|o2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|proto
operator|++
expr_stmt|;
name|arg
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|proto
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2GV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"symbol"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'&'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_ENTERSUB
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"subroutine entry"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2SV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADSV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_HELEM
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_AELEM
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_THREADSV
condition|)
block|{
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"scalar"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
goto|goto
name|wrapref
goto|;
case|case
literal|'@'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2AV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADAV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"array"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|wrapref
goto|;
case|case
literal|'%'
case|:
if|if
condition|(
name|o2
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|&&
name|o2
operator|->
name|op_type
operator|!=
name|OP_PADHV
condition|)
name|bad_type
argument_list|(
name|arg
argument_list|,
literal|"hash"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|o2
argument_list|)
expr_stmt|;
name|wrapref
label|:
block|{
name|OP
modifier|*
name|kid
init|=
name|o2
decl_stmt|;
name|OP
modifier|*
name|sib
init|=
name|kid
operator|->
name|op_sibling
decl_stmt|;
name|kid
operator|->
name|op_sibling
operator|=
literal|0
expr_stmt|;
name|o2
operator|=
name|newUNOP
argument_list|(
name|OP_REFGEN
argument_list|,
literal|0
argument_list|,
name|kid
argument_list|)
expr_stmt|;
name|o2
operator|->
name|op_sibling
operator|=
name|sib
expr_stmt|;
name|prev
operator|->
name|op_sibling
operator|=
name|o2
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|oops
goto|;
block|}
break|break;
case|case
literal|' '
case|:
name|proto
operator|++
expr_stmt|;
continue|continue;
default|default:
name|oops
label|:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Malformed prototype for %s: %s"
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|,
name|SvPV
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|cv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|list
argument_list|(
name|o2
argument_list|)
expr_stmt|;
name|mod
argument_list|(
name|o2
argument_list|,
name|OP_ENTERSUB
argument_list|)
expr_stmt|;
name|prev
operator|=
name|o2
expr_stmt|;
name|o2
operator|=
name|o2
operator|->
name|op_sibling
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|&&
operator|!
name|optional
operator|&&
operator|(
operator|*
name|proto
operator|&&
operator|*
name|proto
operator|!=
literal|'@'
operator|&&
operator|*
name|proto
operator|!=
literal|'%'
operator|&&
operator|*
name|proto
operator|!=
literal|';'
operator|)
condition|)
return|return
name|too_few_arguments
argument_list|(
name|o
argument_list|,
name|gv_ename
argument_list|(
name|namegv
argument_list|)
argument_list|)
return|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_svconst
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|SvREADONLY_on
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_trunc
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
condition|)
block|{
name|SVOP
modifier|*
name|kid
init|=
operator|(
name|SVOP
operator|*
operator|)
name|cUNOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|kid
operator|=
operator|(
name|SVOP
operator|*
operator|)
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
operator|&&
name|kid
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|kid
operator|->
name|op_private
operator|&
name|OPpCONST_BARE
operator|)
condition|)
block|{
name|o
operator|->
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
name|kid
operator|->
name|op_private
operator|&=
operator|~
name|OPpCONST_STRICT
expr_stmt|;
block|}
block|}
return|return
name|ck_fun
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|OP
modifier|*
name|Perl_ck_substr
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|o
parameter_list|)
block|{
name|o
operator|=
name|ck_fun
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_KIDS
operator|)
operator|&&
name|o
operator|->
name|op_private
operator|==
literal|4
condition|)
block|{
name|OP
modifier|*
name|kid
init|=
name|cLISTOPo
operator|->
name|op_first
decl_stmt|;
if|if
condition|(
name|kid
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|kid
operator|=
name|kid
operator|->
name|op_sibling
expr_stmt|;
if|if
condition|(
name|kid
condition|)
name|kid
operator|->
name|op_flags
operator||=
name|OPf_MOD
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
end_function

begin_comment
comment|/* A peephole optimizer.  We visit the ops in the order they're to execute. */
end_comment

begin_function
name|void
name|Perl_peep
parameter_list|(
name|pTHX_
specifier|register
name|OP
modifier|*
name|o
parameter_list|)
block|{
specifier|register
name|OP
modifier|*
name|oldop
init|=
literal|0
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|op_seq
condition|)
return|return;
name|ENTER
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|op_next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|op_seq
condition|)
break|break;
if|if
condition|(
operator|!
name|PL_op_seqmax
condition|)
name|PL_op_seqmax
operator|++
expr_stmt|;
name|PL_op
operator|=
name|o
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|op_type
condition|)
block|{
case|case
name|OP_SETSTATE
case|:
case|case
name|OP_NEXTSTATE
case|:
case|case
name|OP_DBSTATE
case|:
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
expr_stmt|;
comment|/* for warnings */
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CONST
case|:
if|if
condition|(
name|cSVOPo
operator|->
name|op_private
operator|&
name|OPpCONST_STRICT
condition|)
name|no_bareword_allowed
argument_list|(
name|o
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
comment|/* Relocate sv to the pad for thread safety. 	     * Despite being a "constant", the SV is written to, 	     * for reference counts, sv_upgrade() etc. */
if|if
condition|(
name|cSVOP
operator|->
name|op_sv
condition|)
block|{
name|PADOFFSET
name|ix
init|=
name|pad_alloc
argument_list|(
name|OP_CONST
argument_list|,
name|SVs_PADTMP
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvPADTMP
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
condition|)
block|{
comment|/* If op_sv is already a PADTMP then it is being used by 		     * another pad, so make a copy. */
name|sv_setsv
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|,
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_curpad
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|SvPADTMP_on
argument_list|(
name|cSVOPo
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
name|ix
index|]
operator|=
name|cSVOPo
operator|->
name|op_sv
expr_stmt|;
block|}
name|cSVOPo
operator|->
name|op_sv
operator|=
name|Nullsv
expr_stmt|;
name|o
operator|->
name|op_targ
operator|=
name|ix
expr_stmt|;
block|}
endif|#
directive|endif
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_CONCAT
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_STRINGIFY
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_private
operator|&
name|OPpTARGET_MY
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_STACKED
condition|)
comment|/* chained concats */
goto|goto
name|ignore_optimization
goto|;
else|else
block|{
comment|/* assert(PL_opargs[o->op_type]& OA_TARGLEX); */
name|o
operator|->
name|op_targ
operator|=
name|o
operator|->
name|op_next
operator|->
name|op_targ
expr_stmt|;
name|o
operator|->
name|op_next
operator|->
name|op_targ
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|OPpTARGET_MY
expr_stmt|;
block|}
block|}
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
block|}
name|ignore_optimization
label|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_STUB
case|:
if|if
condition|(
operator|(
name|o
operator|->
name|op_flags
operator|&
name|OPf_WANT
operator|)
operator|!=
name|OPf_WANT_LIST
condition|)
block|{
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
comment|/* Scalar stub must produce undef.  List stub is noop */
block|}
goto|goto
name|nothin
goto|;
case|case
name|OP_NULL
case|:
if|if
condition|(
name|o
operator|->
name|op_targ
operator|==
name|OP_NEXTSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_DBSTATE
operator|||
name|o
operator|->
name|op_targ
operator|==
name|OP_SETSTATE
condition|)
block|{
name|PL_curcop
operator|=
operator|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|)
expr_stmt|;
block|}
goto|goto
name|nothin
goto|;
case|case
name|OP_SCALAR
case|:
case|case
name|OP_LINESEQ
case|:
case|case
name|OP_SCOPE
case|:
name|nothin
label|:
if|if
condition|(
name|oldop
operator|&&
name|o
operator|->
name|op_next
condition|)
block|{
name|oldop
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
expr_stmt|;
continue|continue;
block|}
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_GV
case|:
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2SV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|op_next
operator|->
name|op_private
operator|&
name|OPpDEREF
operator|)
condition|)
block|{
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_private
operator||=
name|o
operator|->
name|op_next
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpOUR_INTRO
operator|)
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|o
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_GVSV
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_GVSV
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_RV2AV
condition|)
block|{
name|OP
modifier|*
name|pop
init|=
name|o
operator|->
name|op_next
operator|->
name|op_next
decl_stmt|;
name|IV
name|i
decl_stmt|;
if|if
condition|(
name|pop
operator|->
name|op_type
operator|==
name|OP_CONST
operator|&&
operator|(
name|PL_op
operator|=
name|pop
operator|->
name|op_next
operator|)
operator|&&
name|pop
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_AELEM
operator|&&
operator|!
operator|(
name|pop
operator|->
name|op_next
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator||
name|OPpLVAL_DEFER
operator||
name|OPpDEREF
operator||
name|OPpMAYBE_LVSUB
operator|)
operator|)
operator|&&
operator|(
name|i
operator|=
name|SvIV
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|pop
operator|)
operator|->
name|op_sv
argument_list|)
operator|-
name|PL_compiling
operator|.
name|cop_arybase
operator|)
operator|<=
literal|255
operator|&&
name|i
operator|>=
literal|0
condition|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|null
argument_list|(
name|o
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|pop
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|null
argument_list|(
name|pop
argument_list|)
expr_stmt|;
name|o
operator|->
name|op_flags
operator||=
name|pop
operator|->
name|op_next
operator|->
name|op_flags
operator|&
name|OPf_MOD
expr_stmt|;
name|o
operator|->
name|op_next
operator|=
name|pop
operator|->
name|op_next
operator|->
name|op_next
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_AELEMFAST
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_AELEMFAST
index|]
expr_stmt|;
name|o
operator|->
name|op_private
operator|=
operator|(
name|U8
operator|)
name|i
expr_stmt|;
name|gv
operator|=
name|cGVOPo_gv
expr_stmt|;
name|GvAVn
argument_list|(
name|gv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
name|OPpEARLY_CV
operator|)
operator|&&
name|ckWARN
argument_list|(
name|WARN_PROTOTYPE
argument_list|)
condition|)
block|{
name|GV
modifier|*
name|gv
init|=
name|cGVOPo_gv
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|gv
argument_list|)
operator|==
name|SVt_PVGV
operator|&&
name|GvCV
argument_list|(
name|gv
argument_list|)
operator|&&
name|SvPVX
argument_list|(
name|GvCV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
block|{
comment|/* XXX could check prototype here instead of just carping */
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|gv_efullname3
argument_list|(
name|sv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_PROTOTYPE
argument_list|,
literal|"%s() called too early to check prototype"
argument_list|,
argument|SvPV_nolen(sv)
argument_list|)
empty_stmt|;
block|}
block|}
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
case|case
name|OP_MAPWHILE
case|:
case|case
name|OP_GREPWHILE
case|:
case|case
name|OP_AND
case|:
case|case
name|OP_OR
case|:
case|case
name|OP_ANDASSIGN
case|:
case|case
name|OP_ORASSIGN
case|:
case|case
name|OP_COND_EXPR
case|:
case|case
name|OP_RANGE
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
while|while
condition|(
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cLOGOP
operator|->
name|op_other
operator|=
name|cLOGOP
operator|->
name|op_other
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cLOGOP
operator|->
name|op_other
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ENTERLOOP
case|:
case|case
name|OP_ENTERITER
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
while|while
condition|(
name|cLOOP
operator|->
name|op_redoop
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cLOOP
operator|->
name|op_redoop
operator|=
name|cLOOP
operator|->
name|op_redoop
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_redoop
argument_list|)
expr_stmt|;
while|while
condition|(
name|cLOOP
operator|->
name|op_nextop
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cLOOP
operator|->
name|op_nextop
operator|=
name|cLOOP
operator|->
name|op_nextop
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_nextop
argument_list|)
expr_stmt|;
while|while
condition|(
name|cLOOP
operator|->
name|op_lastop
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cLOOP
operator|->
name|op_lastop
operator|=
name|cLOOP
operator|->
name|op_lastop
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cLOOP
operator|->
name|op_lastop
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_QR
case|:
case|case
name|OP_MATCH
case|:
case|case
name|OP_SUBST
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
while|while
condition|(
name|cPMOP
operator|->
name|op_pmreplstart
operator|&&
name|cPMOP
operator|->
name|op_pmreplstart
operator|->
name|op_type
operator|==
name|OP_NULL
condition|)
name|cPMOP
operator|->
name|op_pmreplstart
operator|=
name|cPMOP
operator|->
name|op_pmreplstart
operator|->
name|op_next
expr_stmt|;
name|peep
argument_list|(
name|cPMOP
operator|->
name|op_pmreplstart
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXEC
case|:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SYNTAX
argument_list|)
operator|&&
name|o
operator|->
name|op_next
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_type
operator|==
name|OP_NEXTSTATE
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_EXIT
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_WARN
operator|&&
name|o
operator|->
name|op_next
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_DIE
condition|)
block|{
name|line_t
name|oldline
init|=
name|CopLINE
argument_list|(
name|PL_curcop
argument_list|)
decl_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|CopLINE
argument_list|(
operator|(
name|COP
operator|*
operator|)
name|o
operator|->
name|op_next
argument_list|)
argument_list|)
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXEC
argument_list|,
literal|"Statement unlikely to be reached"
argument_list|)
empty_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_EXEC
argument_list|,
literal|"\t(Maybe you meant system() when you said exec()?)\n"
argument_list|)
empty_stmt|;
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
name|oldline
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OP_HELEM
case|:
block|{
name|UNOP
modifier|*
name|rop
decl_stmt|;
name|SV
modifier|*
name|lexname
decl_stmt|;
name|GV
modifier|*
modifier|*
name|fields
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|,
modifier|*
modifier|*
name|indsvp
decl_stmt|,
modifier|*
name|sv
decl_stmt|;
name|I32
name|ind
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|keylen
decl_stmt|;
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator|)
operator|)
operator|||
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_last
operator|->
name|op_type
operator|!=
name|OP_CONST
condition|)
break|break;
name|rop
operator|=
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
expr_stmt|;
if|if
condition|(
name|rop
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|||
name|rop
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_PADSV
condition|)
break|break;
name|lexname
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|rop
operator|->
name|op_first
operator|->
name|op_targ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|lexname
argument_list|)
condition|)
break|break;
name|fields
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|,
literal|"FIELDS"
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
operator|||
operator|!
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
condition|)
break|break;
name|svp
operator|=
name|cSVOPx_svp
argument_list|(
operator|(
operator|(
name|BINOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_last
argument_list|)
expr_stmt|;
name|key
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|indsvp
operator|=
name|hv_fetch
argument_list|(
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indsvp
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No such pseudo-hash field \"%s\" in variable %s of type %s"
argument_list|,
name|key
argument_list|,
name|SvPV
argument_list|(
name|lexname
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|SvIV
argument_list|(
operator|*
name|indsvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad index while coercing array into hash"
argument_list|)
expr_stmt|;
name|rop
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|rop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_AELEM
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_AELEM
index|]
expr_stmt|;
name|sv
operator|=
name|newSViv
argument_list|(
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|svp
argument_list|)
operator|&
operator|(
name|SVs_PADBUSY
operator||
name|SVs_PADTMP
operator||
name|SVs_PADMY
operator|)
operator|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|sv
expr_stmt|;
break|break;
block|}
case|case
name|OP_HSLICE
case|:
block|{
name|UNOP
modifier|*
name|rop
decl_stmt|;
name|SV
modifier|*
name|lexname
decl_stmt|;
name|GV
modifier|*
modifier|*
name|fields
decl_stmt|;
name|SV
modifier|*
modifier|*
name|svp
decl_stmt|,
modifier|*
modifier|*
name|indsvp
decl_stmt|,
modifier|*
name|sv
decl_stmt|;
name|I32
name|ind
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|STRLEN
name|keylen
decl_stmt|;
name|SVOP
modifier|*
name|first_key_op
decl_stmt|,
modifier|*
name|key_op
decl_stmt|;
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|op_private
operator|&
operator|(
name|OPpLVAL_INTRO
operator|)
operator|)
comment|/* I bet there's always a pushmark... */
operator|||
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
operator|->
name|op_type
operator|!=
name|OP_LIST
condition|)
comment|/* hmmm, no optimization if list contains only one key. */
break|break;
name|rop
operator|=
operator|(
name|UNOP
operator|*
operator|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_last
expr_stmt|;
if|if
condition|(
name|rop
operator|->
name|op_type
operator|!=
name|OP_RV2HV
operator|||
name|rop
operator|->
name|op_first
operator|->
name|op_type
operator|!=
name|OP_PADSV
condition|)
break|break;
name|lexname
operator|=
operator|*
name|av_fetch
argument_list|(
name|PL_comppad_name
argument_list|,
name|rop
operator|->
name|op_first
operator|->
name|op_targ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|lexname
argument_list|)
condition|)
break|break;
name|fields
operator|=
operator|(
name|GV
operator|*
operator|*
operator|)
name|hv_fetch
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|,
literal|"FIELDS"
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
operator|||
operator|!
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
condition|)
break|break;
comment|/* Again guessing that the pushmark can be jumped over.... */
name|first_key_op
operator|=
operator|(
name|SVOP
operator|*
operator|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
operator|(
operator|(
name|LISTOP
operator|*
operator|)
name|o
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
operator|)
operator|->
name|op_first
operator|->
name|op_sibling
expr_stmt|;
comment|/* Check that the key list contains only constants. */
for|for
control|(
name|key_op
operator|=
name|first_key_op
init|;
name|key_op
condition|;
name|key_op
operator|=
operator|(
name|SVOP
operator|*
operator|)
name|key_op
operator|->
name|op_sibling
control|)
if|if
condition|(
name|key_op
operator|->
name|op_type
operator|!=
name|OP_CONST
condition|)
break|break;
if|if
condition|(
name|key_op
condition|)
break|break;
name|rop
operator|->
name|op_type
operator|=
name|OP_RV2AV
expr_stmt|;
name|rop
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_RV2AV
index|]
expr_stmt|;
name|o
operator|->
name|op_type
operator|=
name|OP_ASLICE
expr_stmt|;
name|o
operator|->
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_ASLICE
index|]
expr_stmt|;
for|for
control|(
name|key_op
operator|=
name|first_key_op
init|;
name|key_op
condition|;
name|key_op
operator|=
operator|(
name|SVOP
operator|*
operator|)
name|key_op
operator|->
name|op_sibling
control|)
block|{
name|svp
operator|=
name|cSVOPx_svp
argument_list|(
name|key_op
argument_list|)
expr_stmt|;
name|key
operator|=
name|SvPV
argument_list|(
operator|*
name|svp
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|indsvp
operator|=
name|hv_fetch
argument_list|(
name|GvHV
argument_list|(
operator|*
name|fields
argument_list|)
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indsvp
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No such pseudo-hash field \"%s\" "
literal|"in variable %s of type %s"
argument_list|,
name|key
argument_list|,
name|SvPV
argument_list|(
name|lexname
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|lexname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|SvIV
argument_list|(
operator|*
name|indsvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Bad index while coercing array into hash"
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSViv
argument_list|(
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
operator|*
name|svp
argument_list|)
condition|)
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
operator|(
name|SvFLAGS
argument_list|(
operator|*
name|svp
argument_list|)
operator|&
operator|(
name|SVs_PADBUSY
operator||
name|SVs_PADTMP
operator||
name|SVs_PADMY
operator|)
operator|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|*
name|svp
argument_list|)
expr_stmt|;
operator|*
name|svp
operator|=
name|sv
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|o
operator|->
name|op_seq
operator|=
name|PL_op_seqmax
operator|++
expr_stmt|;
break|break;
block|}
name|oldop
operator|=
name|o
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
block|}
end_function

end_unit

