begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    regcomp.c  */
end_comment

begin_comment
comment|/*  * "A fair jaw-cracker dwarf-language must be."  --Samwise Gamgee  */
end_comment

begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* The names of the functions have been changed from regcomp and  * regexec to  pregcomp and pregexec in order to avoid conflicts  * with the POSIX routines of the same names. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_EXT_RE_BUILD
end_ifdef

begin_comment
comment|/* need to replace pregcomp et al, so enable that */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_IN_XSUB_RE
end_ifndef

begin_define
define|#
directive|define
name|PERL_IN_XSUB_RE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* need access to debugger hooks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_comment
comment|/* We *really* need to overwrite these symbols: */
end_comment

begin_define
define|#
directive|define
name|Perl_pregcomp
value|my_regcomp
end_define

begin_define
define|#
directive|define
name|Perl_regdump
value|my_regdump
end_define

begin_define
define|#
directive|define
name|Perl_regprop
value|my_regprop
end_define

begin_comment
comment|/* *These* symbols are masked to allow static link. */
end_comment

begin_define
define|#
directive|define
name|Perl_pregfree
value|my_regfree
end_define

begin_define
define|#
directive|define
name|Perl_regnext
value|my_regnext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * pregcomp and pregexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991-1997, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.   *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_IN_XSUB_RE
end_ifndef

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_COMP_C
end_define

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|op
end_ifdef

begin_undef
undef|#
directive|undef
name|op
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* op */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BUGGY_MSC6
argument_list|)
end_if

begin_comment
comment|/* MSC 6.00A breaks on op/regexp.t test 85 unless we turn this off */
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"a"
name|,
name|off
name|)
end_pragma

begin_comment
comment|/* But MSC 6.00A is happy with 'w', for aliases only across function calls*/
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"w"
name|,
name|on
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUGGY_MSC6 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISMULT1
parameter_list|(
name|c
parameter_list|)
value|((c) == '*' || (c) == '+' || (c) == '?')
end_define

begin_define
define|#
directive|define
name|ISMULT2
parameter_list|(
name|s
parameter_list|)
value|((*s) == '*' || (*s) == '+' || (*s) == '?' || \ 	((*s) == '{'&& regcurly(s)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_define
define|#
directive|define
name|PERL_META
value|"^$.[()|?+*\\"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|META
value|"^$.[()|?+*\\"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SPSTART
end_ifdef

begin_undef
undef|#
directive|undef
name|SPSTART
end_undef

begin_comment
comment|/* dratted cpp namespace... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Flags to be passed up and down.  */
end_comment

begin_define
define|#
directive|define
name|WORST
value|0
end_define

begin_comment
comment|/* Worst case. */
end_comment

begin_define
define|#
directive|define
name|HASWIDTH
value|0x1
end_define

begin_comment
comment|/* Known to match non-null strings. */
end_comment

begin_define
define|#
directive|define
name|SIMPLE
value|0x2
end_define

begin_comment
comment|/* Simple enough to be STAR/PLUS operand. */
end_comment

begin_define
define|#
directive|define
name|SPSTART
value|0x4
end_define

begin_comment
comment|/* Starts with * or +. */
end_comment

begin_define
define|#
directive|define
name|TRYAGAIN
value|0x8
end_define

begin_comment
comment|/* Weeded out a declaration. */
end_comment

begin_comment
comment|/*  * Forward declarations for pregcomp()'s friends.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|reg
name|_
argument_list|(
operator|(
name|I32
operator|,
name|I32
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|reganode
name|_
argument_list|(
operator|(
name|U8
operator|,
name|U32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|regatom
name|_
argument_list|(
operator|(
name|I32
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|regbranch
name|_
argument_list|(
operator|(
name|I32
operator|*
operator|,
name|I32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regc
name|_
argument_list|(
operator|(
name|U8
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|regclass
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|I32
name|regcurly
name|_
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|reg_node
name|_
argument_list|(
operator|(
name|U8
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regnode
modifier|*
name|regpiece
name|_
argument_list|(
operator|(
name|I32
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reginsert
name|_
argument_list|(
operator|(
name|U8
operator|,
name|regnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regoptail
name|_
argument_list|(
operator|(
name|regnode
operator|*
operator|,
name|regnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regtail
name|_
argument_list|(
operator|(
name|regnode
operator|*
operator|,
name|regnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regwhite
name|_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextchar
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|re_croak2
name|_
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|pat1
operator|,
specifier|const
name|char
operator|*
name|pat2
operator|,
operator|...
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Length of a variant. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_typedef
typedef|typedef
struct|struct
block|{
name|I32
name|len_min
decl_stmt|;
name|I32
name|len_delta
decl_stmt|;
name|I32
name|pos_min
decl_stmt|;
name|I32
name|pos_delta
decl_stmt|;
name|SV
modifier|*
name|last_found
decl_stmt|;
name|I32
name|last_end
decl_stmt|;
comment|/* min value,<0 unless valid. */
name|I32
name|last_start_min
decl_stmt|;
name|I32
name|last_start_max
decl_stmt|;
name|SV
modifier|*
modifier|*
name|longest
decl_stmt|;
comment|/* Either&l_fixed, or&l_float. */
name|SV
modifier|*
name|longest_fixed
decl_stmt|;
name|I32
name|offset_fixed
decl_stmt|;
name|SV
modifier|*
name|longest_float
decl_stmt|;
name|I32
name|offset_float_min
decl_stmt|;
name|I32
name|offset_float_max
decl_stmt|;
name|I32
name|flags
decl_stmt|;
block|}
name|scan_data_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|scan_data_t
name|zero_scan_data
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SF_BEFORE_EOL
value|(SF_BEFORE_SEOL|SF_BEFORE_MEOL)
end_define

begin_define
define|#
directive|define
name|SF_BEFORE_SEOL
value|0x1
end_define

begin_define
define|#
directive|define
name|SF_BEFORE_MEOL
value|0x2
end_define

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_EOL
value|(SF_FIX_BEFORE_SEOL|SF_FIX_BEFORE_MEOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_EOL
value|(SF_FL_BEFORE_SEOL|SF_FL_BEFORE_MEOL)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UNARY_PLUS
end_ifdef

begin_define
define|#
directive|define
name|SF_FIX_SHIFT_EOL
value|(0+2)
end_define

begin_define
define|#
directive|define
name|SF_FL_SHIFT_EOL
value|(0+4)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SF_FIX_SHIFT_EOL
value|(+2)
end_define

begin_define
define|#
directive|define
name|SF_FL_SHIFT_EOL
value|(+4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_SEOL
value|(SF_BEFORE_SEOL<< SF_FIX_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_MEOL
value|(SF_BEFORE_MEOL<< SF_FIX_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_SEOL
value|(SF_BEFORE_SEOL<< SF_FL_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_MEOL
value|(SF_BEFORE_MEOL<< SF_FL_SHIFT_EOL)
end_define

begin_comment
comment|/* 0x20 */
end_comment

begin_define
define|#
directive|define
name|SF_IS_INF
value|0x40
end_define

begin_define
define|#
directive|define
name|SF_HAS_PAR
value|0x80
end_define

begin_define
define|#
directive|define
name|SF_IN_PAR
value|0x100
end_define

begin_define
define|#
directive|define
name|SF_HAS_EVAL
value|0x200
end_define

begin_define
define|#
directive|define
name|SCF_DO_SUBSTR
value|0x400
end_define

begin_function
name|STATIC
name|void
name|scan_commit
parameter_list|(
name|scan_data_t
modifier|*
name|data
parameter_list|)
block|{
name|STRLEN
name|l
init|=
name|SvCUR
argument_list|(
name|data
operator|->
name|last_found
argument_list|)
decl_stmt|;
name|STRLEN
name|old_l
init|=
name|SvCUR
argument_list|(
operator|*
name|data
operator|->
name|longest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|>=
name|old_l
operator|)
operator|&&
operator|(
operator|(
name|l
operator|>
name|old_l
operator|)
operator|||
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|)
condition|)
block|{
name|sv_setsv
argument_list|(
operator|*
name|data
operator|->
name|longest
argument_list|,
name|data
operator|->
name|last_found
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|->
name|longest
operator|==
name|data
operator|->
name|longest_fixed
condition|)
block|{
name|data
operator|->
name|offset_fixed
operator|=
name|l
condition|?
name|data
operator|->
name|last_start_min
else|:
name|data
operator|->
name|pos_min
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
condition|)
name|data
operator|->
name|flags
operator||=
operator|(
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|<<
name|SF_FIX_SHIFT_EOL
operator|)
expr_stmt|;
else|else
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_FIX_BEFORE_EOL
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|offset_float_min
operator|=
name|l
condition|?
name|data
operator|->
name|last_start_min
else|:
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|offset_float_max
operator|=
operator|(
name|l
condition|?
name|data
operator|->
name|last_start_max
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
condition|)
name|data
operator|->
name|flags
operator||=
operator|(
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|<<
name|SF_FL_SHIFT_EOL
operator|)
expr_stmt|;
else|else
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_FL_BEFORE_EOL
expr_stmt|;
block|}
block|}
name|SvCUR_set
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_BEFORE_EOL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stops at toplevel WHILEM as well as at `last'. At end *scanp is set    to the position after last scanned or to NULL. */
end_comment

begin_function
name|STATIC
name|I32
name|study_chunk
parameter_list|(
name|regnode
modifier|*
modifier|*
name|scanp
parameter_list|,
name|I32
modifier|*
name|deltap
parameter_list|,
name|regnode
modifier|*
name|last
parameter_list|,
name|scan_data_t
modifier|*
name|data
parameter_list|,
name|U32
name|flags
parameter_list|)
comment|/* scanp: Start here (read-write). */
comment|/* deltap: Write maxlen-minlen here. */
comment|/* last: Stop before this one. */
block|{
name|dTHR
expr_stmt|;
name|I32
name|min
init|=
literal|0
decl_stmt|,
name|pars
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
name|regnode
modifier|*
name|scan
init|=
operator|*
name|scanp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|I32
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|is_inf
init|=
operator|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|)
operator|&&
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_IS_INF
operator|)
decl_stmt|;
name|I32
name|is_par
init|=
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|OPEN
condition|?
name|ARG
argument_list|(
name|scan
argument_list|)
else|:
literal|0
decl_stmt|;
name|scan_data_t
name|data_fake
decl_stmt|;
while|while
condition|(
name|scan
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|END
operator|&&
name|scan
operator|<
name|last
condition|)
block|{
comment|/* Peephole optimizer: */
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|regnode
modifier|*
name|n
init|=
name|regnext
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|U32
name|stringok
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|regnode
modifier|*
name|stop
init|=
name|scan
decl_stmt|;
endif|#
directive|endif
name|next
operator|=
name|scan
operator|+
operator|(
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
operator|+
literal|2
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Skip NOTHING, merge EXACT*. */
while|while
condition|(
name|n
operator|&&
operator|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
operator|||
operator|(
name|stringok
operator|&&
operator|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|OP
argument_list|(
name|scan
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|&&
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|<
name|I16_MAX
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|TAIL
operator|||
name|n
operator|>
name|next
condition|)
name|stringok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
condition|)
block|{
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|next
operator|=
name|n
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|stringok
condition|)
name|stop
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|regnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldl
init|=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|regnode
modifier|*
name|nnext
init|=
name|regnext
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldl
operator|+
operator|*
name|OPERAND
argument_list|(
name|n
argument_list|)
operator|>
name|U8_MAX
condition|)
break|break;
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
operator|+=
operator|*
name|OPERAND
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|next
operator|=
name|n
operator|+
operator|(
operator|*
name|OPERAND
argument_list|(
name|n
argument_list|)
operator|+
literal|2
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Now we can overwrite *n : */
name|Move
argument_list|(
name|OPERAND
argument_list|(
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|OPERAND
argument_list|(
name|scan
argument_list|)
operator|+
name|oldl
operator|+
literal|1
argument_list|,
operator|*
name|OPERAND
argument_list|(
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|stringok
condition|)
name|stop
operator|=
name|next
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|nnext
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
comment|/* Allow dumping */
name|n
operator|=
name|scan
operator|+
operator|(
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
operator|+
literal|2
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|n
operator|<=
name|stop
condition|)
block|{
comment|/* Purify reports a benign UMR here sometimes, because we 		 * don't initialize the OP() slot of a node when that node 		 * is occupied by just the trailing null of the string in 		 * an EXACT node */
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|!=
name|NOTHING
operator|||
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|NOTHING
condition|)
block|{
name|OP
argument_list|(
name|n
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|CURLYX
condition|)
block|{
name|int
name|max
init|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|?
name|I32_MAX
comment|/* I32 may be smaller than U16 on CRAYs! */
else|:
operator|(
name|I32_MAX
operator|<
name|U16_MAX
condition|?
name|I32_MAX
else|:
name|U16_MAX
operator|)
operator|)
decl_stmt|;
name|int
name|off
init|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|?
name|ARG
argument_list|(
name|scan
argument_list|)
else|:
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|)
decl_stmt|;
name|int
name|noff
decl_stmt|;
name|regnode
modifier|*
name|n
init|=
name|scan
decl_stmt|;
comment|/* Skip NOTHING and LONGJMP. */
while|while
condition|(
operator|(
name|n
operator|=
name|regnext
argument_list|(
name|n
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
operator|&&
operator|(
name|noff
operator|=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|LONGJMP
operator|)
operator|&&
operator|(
name|noff
operator|=
name|ARG
argument_list|(
name|n
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|off
operator|+
name|noff
operator|<
name|max
condition|)
name|off
operator|+=
name|noff
expr_stmt|;
if|if
condition|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
name|ARG
argument_list|(
name|scan
argument_list|)
operator|=
name|off
expr_stmt|;
else|else
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|=
name|off
expr_stmt|;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCHJ
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|IFTHEN
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SUSPEND
condition|)
block|{
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|code
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|code
operator|||
name|code
operator|==
name|IFTHEN
operator|||
name|code
operator|==
name|SUSPEND
condition|)
block|{
name|I32
name|max1
init|=
literal|0
decl_stmt|,
name|min1
init|=
name|I32_MAX
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|code
condition|)
block|{
name|I32
name|deltanext
decl_stmt|,
name|minnext
decl_stmt|;
name|num
operator|++
expr_stmt|;
name|data_fake
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|BRANCH
condition|)
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* We suppose the run is continuous, last=next...*/
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|next
argument_list|,
operator|&
name|data_fake
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|min1
operator|>
name|minnext
condition|)
name|min1
operator|=
name|minnext
expr_stmt|;
if|if
condition|(
name|max1
operator|<
name|minnext
operator|+
name|deltanext
condition|)
name|max1
operator|=
name|minnext
operator|+
name|deltanext
expr_stmt|;
if|if
condition|(
name|deltanext
operator|==
name|I32_MAX
condition|)
name|is_inf
operator|=
literal|1
expr_stmt|;
name|scan
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|data_fake
operator|.
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|data_fake
operator|.
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUSPEND
condition|)
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|IFTHEN
operator|&&
name|num
operator|<
literal|2
condition|)
comment|/* Empty ELSE branch */
name|min1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|data
operator|->
name|pos_min
operator|+=
name|min1
expr_stmt|;
name|data
operator|->
name|pos_delta
operator|+=
name|max1
operator|-
name|min1
expr_stmt|;
if|if
condition|(
name|max1
operator|!=
name|min1
operator|||
name|is_inf
condition|)
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|min
operator|+=
name|min1
expr_stmt|;
name|delta
operator|+=
name|max1
operator|-
name|min1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|BRANCHJ
condition|)
comment|/* single branch is optimized. */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* single branch is optimized. */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACT
condition|)
block|{
name|min
operator|+=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
comment|/* Update longest substr. */
name|I32
name|l
init|=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
decl_stmt|;
comment|/* The code below prefers earlier match for fixed 		   offset, later match for variable offset.  */
if|if
condition|(
name|data
operator|->
name|last_end
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Update the start info. */
name|data
operator|->
name|last_start_min
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|last_start_max
operator|=
name|is_inf
condition|?
name|I32_MAX
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
operator|+
literal|1
operator|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
name|data
operator|->
name|pos_min
operator|+
name|l
expr_stmt|;
name|data
operator|->
name|pos_min
operator|+=
name|l
expr_stmt|;
comment|/* As in the first entry. */
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_BEFORE_EOL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|min
operator|+=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|)
condition|)
name|data
operator|->
name|pos_min
operator|+=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|varies
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
block|{
name|I32
name|mincount
decl_stmt|,
name|maxcount
decl_stmt|,
name|minnext
decl_stmt|,
name|deltanext
decl_stmt|,
name|pos_before
decl_stmt|,
name|fl
decl_stmt|;
name|regnode
modifier|*
name|oscan
init|=
name|scan
decl_stmt|;
switch|switch
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
block|{
case|case
name|WHILEM
case|:
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|PLUS
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|next
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACT
condition|)
block|{
name|mincount
operator|=
literal|1
expr_stmt|;
name|maxcount
operator|=
name|REG_INFTY
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
name|data
operator|->
name|pos_min
operator|++
expr_stmt|;
name|min
operator|++
expr_stmt|;
comment|/* Fall through. */
case|case
name|STAR
case|:
name|is_inf
operator|=
literal|1
expr_stmt|;
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
goto|goto
name|optimize_curly_tail
goto|;
case|case
name|CURLY
case|:
name|mincount
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|maxcount
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
expr_stmt|;
name|do_curly
label|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
if|if
condition|(
name|mincount
operator|==
literal|0
condition|)
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|pos_before
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
block|}
if|if
condition|(
name|data
condition|)
block|{
name|fl
operator|=
name|data
operator|->
name|flags
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator||
name|SF_HAS_EVAL
operator|)
expr_stmt|;
if|if
condition|(
name|is_inf
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_IS_INF
expr_stmt|;
block|}
comment|/* This will finish on WHILEM, setting scan, or on NULL: */
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|last
argument_list|,
name|data
argument_list|,
name|mincount
operator|==
literal|0
condition|?
operator|(
name|flags
operator|&
operator|~
name|SCF_DO_SUBSTR
operator|)
else|:
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scan
condition|)
comment|/* It was not CURLYX, but CURLY. */
name|scan
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|(
name|minnext
operator|+
name|deltanext
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
operator|)
operator|&&
name|maxcount
operator|<=
literal|10000
condition|)
comment|/* Complement check for big count */
name|warn
argument_list|(
literal|"Strange *+?{} on zero-length expression"
argument_list|)
expr_stmt|;
name|min
operator|+=
name|minnext
operator|*
name|mincount
expr_stmt|;
name|is_inf
operator||=
operator|(
name|maxcount
operator|==
name|REG_INFTY
operator|&&
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|>
literal|0
operator|||
name|deltanext
operator|==
name|I32_MAX
operator|)
expr_stmt|;
name|delta
operator|+=
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|*
name|maxcount
operator|-
name|minnext
operator|*
name|mincount
expr_stmt|;
comment|/* Try powerful optimization CURLYX => CURLYN. */
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|==
name|CURLYX
operator|&&
name|data
operator|&&
name|data
operator|->
name|flags
operator|&
name|SF_IN_PAR
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
operator|&&
operator|!
name|deltanext
operator|&&
name|minnext
operator|==
literal|1
condition|)
block|{
comment|/* Try to optimize to CURLYN.  */
name|regnode
modifier|*
name|nxt
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
name|regnode
modifier|*
name|nxt1
init|=
name|nxt
decl_stmt|,
modifier|*
name|nxt2
decl_stmt|;
comment|/* Skip open. */
name|nxt
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|nxt
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|nxt
argument_list|)
index|]
operator|==
name|EXACT
operator|&&
operator|*
name|OPERAND
argument_list|(
name|nxt
argument_list|)
operator|==
literal|1
operator|)
condition|)
goto|goto
name|nogo
goto|;
name|nxt2
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|nxt
argument_list|)
operator|!=
name|CLOSE
condition|)
goto|goto
name|nogo
goto|;
comment|/* Now we know that nxt2 is the only contents: */
name|oscan
operator|->
name|flags
operator|=
name|ARG
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|oscan
argument_list|)
operator|=
name|CURLYN
expr_stmt|;
name|OP
argument_list|(
name|nxt1
argument_list|)
operator|=
name|NOTHING
expr_stmt|;
comment|/* was OPEN. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|OP
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
name|NEXT_OFF
argument_list|(
name|nxt2
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy with CURLY. */
name|OP
argument_list|(
name|nxt
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was CLOSE. */
name|OP
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
endif|#
directive|endif
block|}
name|nogo
label|:
comment|/* Try optimization CURLYX => CURLYM. */
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|==
name|CURLYX
operator|&&
name|data
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_PAR
operator|)
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
operator|&&
operator|!
name|deltanext
condition|)
block|{
comment|/* XXXX How to optimize if data == 0? */
comment|/* Optimize to a simpler form.  */
name|regnode
modifier|*
name|nxt
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
comment|/* OPEN */
name|regnode
modifier|*
name|nxt2
decl_stmt|;
name|OP
argument_list|(
name|oscan
argument_list|)
operator|=
name|CURLYM
expr_stmt|;
while|while
condition|(
operator|(
name|nxt2
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
operator|)
comment|/* skip over embedded stuff*/
operator|&&
operator|(
name|OP
argument_list|(
name|nxt2
argument_list|)
operator|!=
name|WHILEM
operator|)
condition|)
name|nxt
operator|=
name|nxt2
expr_stmt|;
name|OP
argument_list|(
name|nxt2
argument_list|)
operator|=
name|SUCCEED
expr_stmt|;
comment|/* Whas WHILEM */
comment|/* Need to optimize away parenths. */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_IN_PAR
condition|)
block|{
comment|/* Set the parenth number.  */
name|regnode
modifier|*
name|nxt1
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
comment|/* OPEN*/
if|if
condition|(
name|OP
argument_list|(
name|nxt
argument_list|)
operator|!=
name|CLOSE
condition|)
name|FAIL
argument_list|(
literal|"panic opt close"
argument_list|)
expr_stmt|;
name|oscan
operator|->
name|flags
operator|=
name|ARG
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|nxt1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was OPEN. */
name|OP
argument_list|(
name|nxt
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was CLOSE. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|OP
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|OP
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
name|NEXT_OFF
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
endif|#
directive|endif
if|#
directive|if
literal|0
block|while ( nxt1&& (OP(nxt1) != WHILEM)) { 			    regnode *nnxt = regnext(nxt1); 			     			    if (nnxt == nxt) { 				if (reg_off_by_arg[OP(nxt1)]) 				    ARG_SET(nxt1, nxt2 - nxt1); 				else if (nxt2 - nxt1< U16_MAX) 				    NEXT_OFF(nxt1) = nxt2 - nxt1; 				else 				    OP(nxt) = NOTHING;
comment|/* Cannot beautify */
block|} 			    nxt1 = nnxt; 			}
endif|#
directive|endif
comment|/* Optimize again: */
name|study_chunk
argument_list|(
operator|&
name|nxt1
argument_list|,
operator|&
name|deltanext
argument_list|,
name|nxt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|oscan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|&&
name|fl
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|SV
modifier|*
name|last_str
init|=
name|Nullsv
decl_stmt|;
name|int
name|counted
init|=
name|mincount
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|last_end
operator|>
literal|0
operator|&&
name|mincount
operator|!=
literal|0
condition|)
block|{
comment|/* Ends with a string. */
name|I32
name|b
init|=
name|pos_before
operator|>=
name|data
operator|->
name|last_start_min
condition|?
name|pos_before
else|:
name|data
operator|->
name|last_start_min
decl_stmt|;
name|STRLEN
name|l
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|l
operator|-=
name|b
operator|-
name|data
operator|->
name|last_start_min
expr_stmt|;
comment|/* Get the added string: */
name|last_str
operator|=
name|newSVpv
argument_list|(
name|s
operator|+
name|b
operator|-
name|data
operator|->
name|last_start_min
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltanext
operator|==
literal|0
operator|&&
name|pos_before
operator|==
name|b
condition|)
block|{
comment|/* What was added is a constant string */
if|if
condition|(
name|mincount
operator|>
literal|1
condition|)
block|{
name|SvGROW
argument_list|(
name|last_str
argument_list|,
operator|(
name|mincount
operator|*
name|l
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|SvPVX
argument_list|(
name|last_str
argument_list|)
operator|+
name|l
argument_list|,
name|SvPVX
argument_list|(
name|last_str
argument_list|)
argument_list|,
name|l
argument_list|,
name|mincount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|last_str
argument_list|)
operator|*=
name|mincount
expr_stmt|;
comment|/* Add additional parts. */
name|SvCUR_set
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|SvCUR
argument_list|(
name|data
operator|->
name|last_found
argument_list|)
operator|-
name|l
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|+=
name|l
operator|*
operator|(
name|mincount
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* It is counted once already... */
name|data
operator|->
name|pos_min
operator|+=
name|minnext
operator|*
operator|(
name|mincount
operator|-
name|counted
operator|)
expr_stmt|;
name|data
operator|->
name|pos_delta
operator|+=
operator|-
name|counted
operator|*
name|deltanext
operator|+
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|*
name|maxcount
operator|-
name|minnext
operator|*
name|mincount
expr_stmt|;
if|if
condition|(
name|mincount
operator|!=
name|maxcount
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|mincount
operator|&&
name|last_str
condition|)
block|{
name|sv_setsv
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|last_start_min
operator|=
name|data
operator|->
name|pos_min
operator|-
name|SvCUR
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_start_max
operator|=
name|is_inf
condition|?
name|I32_MAX
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
operator|-
name|SvCUR
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|&&
operator|(
name|fl
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
name|optimize_curly_tail
label|:
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|!=
name|CURLYX
condition|)
block|{
while|while
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
operator|=
name|regnext
argument_list|(
name|oscan
argument_list|)
argument_list|)
index|]
operator|==
name|NOTHING
operator|&&
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
condition|)
name|NEXT_OFF
argument_list|(
name|oscan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
comment|/* REF only? */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|is_inf
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pos_min
operator|++
expr_stmt|;
block|}
name|min
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EOL
operator|&&
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|data
operator|->
name|flags
operator||=
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|MEOL
condition|?
name|SF_BEFORE_MEOL
else|:
name|SF_BEFORE_SEOL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|BRANCHJ
operator|&&
operator|(
name|scan
operator|->
name|flags
operator|||
name|data
operator|)
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|IFMATCH
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|UNLESSM
operator|)
condition|)
block|{
name|I32
name|deltanext
decl_stmt|,
name|minnext
decl_stmt|;
name|regnode
modifier|*
name|nscan
decl_stmt|;
name|data_fake
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|nscan
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|nscan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|last
argument_list|,
operator|&
name|data_fake
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|deltanext
condition|)
block|{
name|FAIL
argument_list|(
literal|"variable length lookbehind not implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minnext
operator|>
name|U8_MAX
condition|)
block|{
name|FAIL2
argument_list|(
literal|"lookbehind longer than %d not implemented"
argument_list|,
name|U8_MAX
argument_list|)
expr_stmt|;
block|}
name|scan
operator|->
name|flags
operator|=
name|minnext
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|&&
name|data_fake
operator|.
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|data_fake
operator|.
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|OPEN
condition|)
block|{
name|pars
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|CLOSE
operator|&&
name|ARG
argument_list|(
name|scan
argument_list|)
operator|==
name|is_par
condition|)
block|{
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
operator|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|WHILEM
operator|)
operator|&&
name|next
operator|<
name|last
condition|)
name|is_par
operator|=
literal|0
expr_stmt|;
comment|/* Disable optimization */
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EVAL
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
block|}
comment|/* Else: zero-length, ignore. */
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
operator|*
name|scanp
operator|=
name|scan
expr_stmt|;
operator|*
name|deltap
operator|=
name|is_inf
condition|?
name|I32_MAX
else|:
name|delta
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|&&
name|is_inf
condition|)
name|data
operator|->
name|pos_delta
operator|=
name|I32_MAX
operator|-
name|data
operator|->
name|pos_min
expr_stmt|;
if|if
condition|(
name|is_par
operator|>
name|U8_MAX
condition|)
name|is_par
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_par
operator|&&
name|pars
operator|==
literal|1
operator|&&
name|data
condition|)
block|{
name|data
operator|->
name|flags
operator||=
name|SF_IN_PAR
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_HAS_PAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pars
operator|&&
name|data
condition|)
block|{
name|data
operator|->
name|flags
operator||=
name|SF_HAS_PAR
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_IN_PAR
expr_stmt|;
block|}
return|return
name|min
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|add_data
parameter_list|(
name|I32
name|n
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_regcomp_rx
operator|->
name|data
condition|)
block|{
name|Renewc
argument_list|(
name|PL_regcomp_rx
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|PL_regcomp_rx
operator|->
name|data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+
name|n
operator|-
literal|1
operator|)
argument_list|,
name|char
argument_list|,
expr|struct
name|reg_data
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|Newc
argument_list|(
literal|1207
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|PL_regcomp_rx
operator|->
name|data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
argument_list|,
name|char
argument_list|,
expr|struct
name|reg_data
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|1208
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
argument_list|,
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|=
name|n
expr_stmt|;
block|}
name|Copy
argument_list|(
name|s
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
operator|+
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|-
name|n
argument_list|,
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
return|return
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/*  - pregcomp - compile a regular expression into internal code  *  * We can't allocate space until we know how big the compiled form will be,  * but we can't compile it (and thus know how big it is) until we've got a  * place to put the code.  So we cheat:  we compile it twice, once with code  * generation turned off and size counting turned on, and once "for real".  * This also means that we don't allocate space until we are sure that the  * thing really will compile successfully, and we never have to move the  * code and thus invalidate pointers into it.  (Note that it has to be in  * one piece because free() must be able to free it all.) [NB: not true in perl]  *  * Beware that the optimization-preparation code in here knows about some  * of the structure of the compiled regexp.  [I'll say.]  */
end_comment

begin_function
name|regexp
modifier|*
name|pregcomp
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|char
modifier|*
name|xend
parameter_list|,
name|PMOP
modifier|*
name|pm
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regexp
modifier|*
name|r
decl_stmt|;
name|regnode
modifier|*
name|scan
decl_stmt|;
name|SV
modifier|*
modifier|*
name|longest
decl_stmt|;
name|SV
modifier|*
name|longest_fixed
decl_stmt|;
name|SV
modifier|*
name|longest_float
decl_stmt|;
name|regnode
modifier|*
name|first
decl_stmt|;
name|I32
name|flags
decl_stmt|;
name|I32
name|minlen
init|=
literal|0
decl_stmt|;
name|I32
name|sawplus
init|=
literal|0
decl_stmt|;
name|I32
name|sawopen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"NULL regexp argument"
argument_list|)
expr_stmt|;
name|PL_regprecomp
operator|=
name|savepvn
argument_list|(
name|exp
argument_list|,
name|xend
operator|-
name|exp
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"compiling RE `%*s'\n"
argument_list|,
name|xend
operator|-
name|exp
argument_list|,
name|PL_regprecomp
argument_list|)
argument_list|)
expr_stmt|;
name|PL_regflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_regsawback
operator|=
literal|0
expr_stmt|;
name|PL_regseen
operator|=
literal|0
expr_stmt|;
name|PL_seen_zerolen
operator|=
operator|*
name|exp
operator|==
literal|'^'
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|PL_seen_evals
operator|=
literal|0
expr_stmt|;
name|PL_extralen
operator|=
literal|0
expr_stmt|;
comment|/* First pass: determine size, legality. */
name|PL_regcomp_parse
operator|=
name|exp
expr_stmt|;
name|PL_regxend
operator|=
name|xend
expr_stmt|;
name|PL_regnaughty
operator|=
literal|0
expr_stmt|;
name|PL_regnpar
operator|=
literal|1
expr_stmt|;
name|PL_regsize
operator|=
literal|0L
expr_stmt|;
name|PL_regcode
operator|=
operator|&
name|PL_regdummy
expr_stmt|;
name|regc
argument_list|(
operator|(
name|U8
operator|)
name|MAGIC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PL_regcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Safefree
argument_list|(
name|PL_regprecomp
argument_list|)
expr_stmt|;
name|PL_regprecomp
operator|=
name|Nullch
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"size %d "
argument_list|,
name|PL_regsize
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|if (!PL_colorset) { 	    int i =
literal|0
argument|; 	    char *s = PerlEnv_getenv(
literal|"TERMCAP_COLORS"
argument|); 	     	    PL_colorset =
literal|1
argument|; 	    if (s) { 		PL_colors[
literal|0
argument|] = s = savepv(s); 		while (++i<
literal|4
argument|) { 		    s = strchr(s,
literal|'\t'
argument|); 		    if (!s)  			FAIL(
literal|"Not enough TABs in TERMCAP_COLORS"
argument|); 		    *s =
literal|'\0'
argument|; 		    PL_colors[i] = ++s; 		} 	    } else { 		while (i<
literal|4
argument|)  		    PL_colors[i++] =
literal|""
argument|; 	    }
comment|/* Reset colors: */
argument|PerlIO_printf(Perl_debug_log,
literal|"%s%s%s%s"
argument|,  			  PL_colors[
literal|0
argument|],PL_colors[
literal|1
argument|],PL_colors[
literal|2
argument|],PL_colors[
literal|3
argument|]); 	}
argument_list|)
empty_stmt|;
comment|/* Small enough for pointer-storage convention?        If extralen==0, this means that we will not need long jumps. */
if|if
condition|(
name|PL_regsize
operator|>=
literal|0x10000L
operator|&&
name|PL_extralen
condition|)
name|PL_regsize
operator|+=
name|PL_extralen
expr_stmt|;
else|else
name|PL_extralen
operator|=
literal|0
expr_stmt|;
comment|/* Allocate space and initialize. */
name|Newc
argument_list|(
literal|1001
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|PL_regsize
operator|*
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
argument_list|,
name|char
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"regexp out of space"
argument_list|)
expr_stmt|;
name|r
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|prelen
operator|=
name|xend
operator|-
name|exp
expr_stmt|;
name|r
operator|->
name|precomp
operator|=
name|PL_regprecomp
expr_stmt|;
name|r
operator|->
name|subbeg
operator|=
name|r
operator|->
name|subbase
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|nparens
operator|=
name|PL_regnpar
operator|-
literal|1
expr_stmt|;
comment|/* set early to validate backrefs */
name|PL_regcomp_rx
operator|=
name|r
expr_stmt|;
comment|/* Second pass: emit code. */
name|PL_regcomp_parse
operator|=
name|exp
expr_stmt|;
name|PL_regxend
operator|=
name|xend
expr_stmt|;
name|PL_regnaughty
operator|=
literal|0
expr_stmt|;
name|PL_regnpar
operator|=
literal|1
expr_stmt|;
name|PL_regcode
operator|=
name|r
operator|->
name|program
expr_stmt|;
comment|/* Store the count of eval-groups for security checks: */
name|PL_regcode
operator|->
name|next_off
operator|=
operator|(
operator|(
name|PL_seen_evals
operator|>
name|U16_MAX
operator|)
condition|?
name|U16_MAX
else|:
name|PL_seen_evals
operator|)
expr_stmt|;
name|regc
argument_list|(
operator|(
name|U8
operator|)
name|MAGIC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PL_regcode
operator|++
argument_list|)
expr_stmt|;
name|r
operator|->
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Dig out information for optimizations. */
name|r
operator|->
name|reganch
operator|=
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_COMPILETIME
expr_stmt|;
name|pm
operator|->
name|op_pmflags
operator|=
name|PL_regflags
expr_stmt|;
name|r
operator|->
name|regstclass
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|naughty
operator|=
name|PL_regnaughty
operator|>=
literal|10
expr_stmt|;
comment|/* Probably an expensive pattern. */
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
comment|/* First BRANCH. */
comment|/* XXXX To minimize changes to RE engine we always allocate        3-units-long substrs field. */
name|Newz
argument_list|(
literal|1004
argument_list|,
name|r
operator|->
name|substrs
argument_list|,
literal|1
argument_list|,
expr|struct
name|reg_substr_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|BRANCH
condition|)
block|{
comment|/* Only one top-level choice. */
name|scan_data_t
name|data
decl_stmt|;
name|I32
name|fake
decl_stmt|;
name|STRLEN
name|longest_float_length
decl_stmt|,
name|longest_fixed_length
decl_stmt|;
name|StructCopy
argument_list|(
operator|&
name|zero_scan_data
argument_list|,
operator|&
name|data
argument_list|,
name|scan_data_t
argument_list|)
expr_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
comment|/* Skip introductions and multiplicators>= 1. */
while|while
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|OPEN
operator|&&
operator|(
name|sawopen
operator|=
literal|1
operator|)
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|BRANCH
operator|&&
name|OP
argument_list|(
name|regnext
argument_list|(
name|first
argument_list|)
argument_list|)
operator|!=
name|BRANCH
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|MINMOD
operator|)
operator|||
operator|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|CURLY
operator|&&
name|ARG1
argument_list|(
name|first
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
condition|)
name|sawplus
operator|=
literal|1
expr_stmt|;
else|else
name|first
operator|+=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Starting-point info. */
name|again
label|:
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EXACT
condition|)
empty_stmt|;
comment|/* Empty, get anchored substr later. */
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|simple
operator|+
literal|2
argument_list|,
name|OP
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|BOUND
operator|||
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|NBOUND
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|BOL
condition|)
block|{
name|r
operator|->
name|reganch
operator||=
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|MBOL
condition|?
name|ROPT_ANCH_MBOL
else|:
name|ROPT_ANCH_BOL
operator|)
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|GPOS
condition|)
block|{
name|r
operator|->
name|reganch
operator||=
name|ROPT_ANCH_GPOS
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|STAR
operator|&&
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|first
argument_list|)
argument_list|)
index|]
operator|==
name|ANY
operator|)
operator|&&
operator|!
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
comment|/* turn .* into ^.* with an implied $*=1 */
name|r
operator|->
name|reganch
operator||=
name|ROPT_ANCH_BOL
operator||
name|ROPT_IMPLICIT
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|sawplus
operator|&&
operator|(
operator|!
name|sawopen
operator|||
operator|!
name|PL_regsawback
operator|)
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_SKIP
expr_stmt|;
comment|/* x+ must match 1st of run */
comment|/* Scan is after the zeroth branch, first is atomic matcher. */
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"first at %d\n"
argument_list|,
name|first
operator|-
name|scan
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	* If there's something expensive in the r.e., find the 	* longest literal string that must appear and make it the 	* regmust.  Resolve ties in favor of later strings, since 	* the regstart check works with the beginning of the r.e. 	* and avoiding duplication strengthens checking.  Not a 	* strong reason, but sufficient in the absence of others. 	* [Now we resolve ties in favor of the earlier string if 	* it happens that c_offset_min has been invalidated, since the 	* earlier string may buy us something the later one won't.] 	*/
name|minlen
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|longest_fixed
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|longest_float
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|last_found
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|longest
operator|=
operator|&
operator|(
name|data
operator|.
name|longest_fixed
operator|)
expr_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
name|minlen
operator|=
name|study_chunk
argument_list|(
operator|&
name|first
argument_list|,
operator|&
name|fake
argument_list|,
name|scan
operator|+
name|PL_regsize
argument_list|,
comment|/* Up to end */
operator|&
name|data
argument_list|,
name|SCF_DO_SUBSTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_regnpar
operator|==
literal|1
operator|&&
name|data
operator|.
name|longest
operator|==
operator|&
operator|(
name|data
operator|.
name|longest_fixed
operator|)
operator|&&
name|data
operator|.
name|last_start_min
operator|==
literal|0
operator|&&
name|data
operator|.
name|last_end
operator|>
literal|0
operator|&&
operator|!
name|PL_seen_zerolen
operator|&&
operator|(
operator|!
operator|(
name|PL_regseen
operator|&
name|REG_SEEN_GPOS
operator|)
operator|||
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
operator|)
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_CHECK_ALL
expr_stmt|;
name|scan_commit
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|last_found
argument_list|)
expr_stmt|;
name|longest_float_length
operator|=
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_float
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_float_length
operator|||
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_EOL
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
operator|&&
name|data
operator|.
name|offset_fixed
operator|==
name|data
operator|.
name|offset_float_min
condition|)
goto|goto
name|remove
goto|;
comment|/* Like in (a)+. */
name|r
operator|->
name|float_substr
operator|=
name|data
operator|.
name|longest_float
expr_stmt|;
name|r
operator|->
name|float_min_offset
operator|=
name|data
operator|.
name|offset_float_min
expr_stmt|;
name|r
operator|->
name|float_max_offset
operator|=
name|data
operator|.
name|offset_float_max
expr_stmt|;
name|fbm_compile
argument_list|(
name|r
operator|->
name|float_substr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_EOL
comment|/* Cannot have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
condition|)
name|SvTAIL_on
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remove
label|:
name|r
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|longest_float
argument_list|)
expr_stmt|;
name|longest_float_length
operator|=
literal|0
expr_stmt|;
block|}
name|longest_fixed_length
operator|=
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_fixed_length
operator|||
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_EOL
comment|/* Cannot have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
condition|)
block|{
name|r
operator|->
name|anchored_substr
operator|=
name|data
operator|.
name|longest_fixed
expr_stmt|;
name|r
operator|->
name|anchored_offset
operator|=
name|data
operator|.
name|offset_fixed
expr_stmt|;
name|fbm_compile
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_EOL
comment|/* Cannot have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
condition|)
name|SvTAIL_on
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|anchored_substr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
expr_stmt|;
name|longest_fixed_length
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
if|if
condition|(
name|longest_fixed_length
operator|>
name|longest_float_length
condition|)
block|{
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|anchored_substr
expr_stmt|;
name|r
operator|->
name|check_offset_min
operator|=
name|r
operator|->
name|check_offset_max
operator|=
name|r
operator|->
name|anchored_offset
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_SINGLE
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_NOSCAN
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|float_substr
expr_stmt|;
name|r
operator|->
name|check_offset_min
operator|=
name|data
operator|.
name|offset_float_min
expr_stmt|;
name|r
operator|->
name|check_offset_max
operator|=
name|data
operator|.
name|offset_float_max
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Several toplevels. Best we can is to set minlen. */
name|I32
name|fake
decl_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
name|minlen
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|fake
argument_list|,
name|scan
operator|+
name|PL_regsize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|anchored_substr
operator|=
name|r
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
block|}
name|r
operator|->
name|minlen
operator|=
name|minlen
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_GPOS
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_GPOS_SEEN
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_LOOKBEHIND
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_LOOKBEHIND_SEEN
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_EVAL
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_EVAL_SEEN
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|startp
argument_list|,
name|PL_regnpar
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|endp
argument_list|,
name|PL_regnpar
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|regdump
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - reg - regular expression, i.e. main body or parenthesized thing  *  * Caller must absorb opening parenthesis.  *  * Combining parenthesis handling with the base level of regular expression  * is a trifle forced, but the need to tie the tails of the branches to what  * follows makes it hard to avoid.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|reg
parameter_list|(
name|I32
name|paren
parameter_list|,
name|I32
modifier|*
name|flagp
parameter_list|)
comment|/* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
comment|/* Will be the head of the group. */
specifier|register
name|regnode
modifier|*
name|br
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|lastbr
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ender
init|=
literal|0
decl_stmt|;
specifier|register
name|I32
name|parno
init|=
literal|0
decl_stmt|;
name|I32
name|flags
decl_stmt|,
name|oregflags
init|=
name|PL_regflags
decl_stmt|,
name|have_branch
init|=
literal|0
decl_stmt|,
name|open
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
operator|*
name|flagp
operator|=
literal|0
expr_stmt|;
comment|/* Tentatively. */
comment|/* Make an OPEN node, if parenthesized. */
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'?'
condition|)
block|{
name|U16
name|posflags
init|=
literal|0
decl_stmt|,
name|negflags
init|=
literal|0
decl_stmt|;
name|U16
modifier|*
name|flagsp
init|=
operator|&
name|posflags
decl_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|paren
operator|=
operator|*
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* For look-ahead/behind. */
switch|switch
condition|(
name|paren
condition|)
block|{
case|case
literal|'<'
case|:
name|PL_regseen
operator||=
name|REG_SEEN_LOOKBEHIND
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'!'
condition|)
name|paren
operator|=
literal|','
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|'='
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'!'
condition|)
goto|goto
name|unknown
goto|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
case|case
literal|'='
case|:
case|case
literal|'!'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
case|case
literal|':'
case|:
case|case
literal|'>'
case|:
break|break;
case|case
literal|'$'
case|:
case|case
literal|'@'
case|:
name|FAIL2
argument_list|(
literal|"Sequence (?%c...) not implemented"
argument_list|,
operator|(
name|int
operator|)
name|paren
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Sequence (?#... not terminated"
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|'{'
case|:
block|{
name|dTHR
expr_stmt|;
name|I32
name|count
init|=
literal|1
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|PL_regcomp_parse
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|OP_4tree
modifier|*
name|sop
decl_stmt|,
modifier|*
name|rop
decl_stmt|;
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_EVAL
expr_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|c
operator|=
operator|*
name|PL_regcomp_parse
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Sequence (?{...}) not terminated or not {}-balanced"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|-
literal|1
operator|-
name|s
condition|)
name|sv
operator|=
name|newSVpv
argument_list|(
name|s
argument_list|,
name|PL_regcomp_parse
operator|-
literal|1
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
name|newSVpv
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rop
operator|=
name|sv_compile_2op
argument_list|(
name|sv
argument_list|,
operator|&
name|sop
argument_list|,
literal|"re"
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
literal|3
argument_list|,
literal|"nso"
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|rop
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
operator|+
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|av
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
operator|+
literal|2
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|sop
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First pass */
if|if
condition|(
name|PL_reginterp_cnt
operator|<
operator|++
name|PL_seen_evals
operator|&&
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
comment|/* No compiled RE interpolated, has runtime 			   components ===> unsafe.  */
name|FAIL
argument_list|(
literal|"Eval-group not allowed at runtime, use re 'eval'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_tainted
condition|)
name|FAIL
argument_list|(
literal|"Eval-group in insecure regular expression"
argument_list|)
expr_stmt|;
block|}
name|nextchar
argument_list|()
expr_stmt|;
return|return
name|reganode
argument_list|(
name|EVAL
argument_list|,
name|n
argument_list|)
return|;
block|}
case|case
literal|'('
case|:
block|{
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'!'
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'<'
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* Lookahead or eval. */
name|I32
name|flag
decl_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|LOGICAL
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flag
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|insert_if
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|>=
literal|'1'
operator|&&
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|parno
operator|=
name|atoi
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|GROUPP
argument_list|,
name|parno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|nextchar
argument_list|()
operator|)
operator|!=
literal|')'
condition|)
name|FAIL2
argument_list|(
literal|"Switch (?(number%c not recognized"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|insert_if
label|:
name|regtail
argument_list|(
name|ret
argument_list|,
name|reganode
argument_list|(
name|IFTHEN
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
name|br
operator|=
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|regtail
argument_list|(
name|br
argument_list|,
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|lastbr
operator|=
name|reganode
argument_list|(
name|IFTHEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fake one for optimizer. */
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|lastbr
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|nextchar
argument_list|()
expr_stmt|;
block|}
else|else
name|lastbr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Switch (?(condition)... contains too many branches"
argument_list|)
expr_stmt|;
name|ender
operator|=
name|reg_node
argument_list|(
name|TAIL
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastbr
condition|)
block|{
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|ender
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|lastbr
argument_list|)
argument_list|)
argument_list|,
name|ender
argument_list|)
expr_stmt|;
block|}
else|else
name|regtail
argument_list|(
name|ret
argument_list|,
name|ender
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|FAIL2
argument_list|(
literal|"Unknown condition for (?(%.2s"
argument_list|,
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
block|}
block|}
case|case
literal|0
case|:
name|FAIL
argument_list|(
literal|"Sequence (? incomplete"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|--
name|PL_regcomp_parse
expr_stmt|;
name|parse_flags
label|:
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|'o'
condition|)
name|pmflag
argument_list|(
name|flagsp
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
operator|++
name|PL_regcomp_parse
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
condition|)
block|{
name|flagsp
operator|=
operator|&
name|negflags
expr_stmt|;
operator|++
name|PL_regcomp_parse
expr_stmt|;
goto|goto
name|parse_flags
goto|;
block|}
name|PL_regflags
operator||=
name|posflags
expr_stmt|;
name|PL_regflags
operator|&=
operator|~
name|negflags
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|':'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|paren
operator|=
literal|':'
expr_stmt|;
break|break;
block|}
name|unknown
label|:
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL2
argument_list|(
literal|"Sequence (?%c...) not recognized"
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|parno
operator|=
name|PL_regnpar
expr_stmt|;
name|PL_regnpar
operator|++
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|OPEN
argument_list|,
name|parno
argument_list|)
expr_stmt|;
name|open
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* Pick up the branches, linking them together. */
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|reginsert
argument_list|(
name|BRANCHJ
argument_list|,
name|br
argument_list|)
expr_stmt|;
block|}
else|else
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|have_branch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|1
expr_stmt|;
comment|/* For BRANCHJ-BRANCH. */
block|}
elseif|else
if|if
condition|(
name|paren
operator|==
literal|':'
condition|)
block|{
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SIMPLE
expr_stmt|;
block|}
if|if
condition|(
name|open
condition|)
block|{
comment|/* Starts with OPEN. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* OPEN -> first. */
block|}
elseif|else
if|if
condition|(
name|paren
operator|!=
literal|'?'
condition|)
comment|/* Not Conditional */
name|ret
operator|=
name|br
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
name|lastbr
operator|=
name|br
expr_stmt|;
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|ender
operator|=
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|lastbr
argument_list|)
argument_list|)
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Append to the previous. */
block|}
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|2
expr_stmt|;
comment|/* Account for LONGJMP. */
name|nextchar
argument_list|()
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* BRANCH -> BRANCH. */
name|lastbr
operator|=
name|br
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
block|}
if|if
condition|(
name|have_branch
operator|||
name|paren
operator|!=
literal|':'
condition|)
block|{
comment|/* Make a closing node, and hook it on the end. */
switch|switch
condition|(
name|paren
condition|)
block|{
case|case
literal|':'
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|TAIL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ender
operator|=
name|reganode
argument_list|(
name|CLOSE
argument_list|,
name|parno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|','
case|:
case|case
literal|'='
case|:
case|case
literal|'!'
case|:
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'>'
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|SUCCEED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|END
argument_list|)
expr_stmt|;
break|break;
block|}
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|ender
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_branch
condition|)
block|{
comment|/* Hook the tails of the branches to the closing node. */
for|for
control|(
name|br
operator|=
name|ret
init|;
name|br
operator|!=
name|NULL
condition|;
name|br
operator|=
name|regnext
argument_list|(
name|br
argument_list|)
control|)
block|{
name|regoptail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|parens
index|[]
init|=
literal|"=!<,>"
decl_stmt|;
if|if
condition|(
name|paren
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|parens
argument_list|,
name|paren
argument_list|)
operator|)
condition|)
block|{
name|int
name|node
init|=
operator|(
operator|(
name|p
operator|-
name|parens
operator|)
operator|%
literal|2
operator|)
condition|?
name|UNLESSM
else|:
name|IFMATCH
decl_stmt|;
name|int
name|flag
init|=
operator|(
name|p
operator|-
name|parens
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|paren
operator|==
literal|'>'
condition|)
name|node
operator|=
name|SUSPEND
operator|,
name|flag
operator|=
literal|0
expr_stmt|;
name|reginsert
argument_list|(
name|node
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
name|flag
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg_node
argument_list|(
name|TAIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for proper termination. */
if|if
condition|(
name|paren
operator|&&
operator|(
name|PL_regcomp_parse
operator|>=
name|PL_regxend
operator|||
operator|*
name|nextchar
argument_list|()
operator|!=
literal|')'
operator|)
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|paren
operator|&&
name|PL_regcomp_parse
operator|<
name|PL_regxend
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL
argument_list|(
literal|"junk on end of regexp"
argument_list|)
expr_stmt|;
comment|/* "Can't happen". */
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|paren
operator|!=
literal|0
condition|)
block|{
name|PL_regflags
operator|=
name|oregflags
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regbranch - one alternative of an | operator  *  * Implements the concatenation operator.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|regbranch
parameter_list|(
name|I32
modifier|*
name|flagp
parameter_list|,
name|I32
name|first
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|chain
init|=
name|NULL
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|latest
decl_stmt|;
name|I32
name|flags
init|=
literal|0
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
name|ret
operator|=
name|reganode
argument_list|(
name|BRANCHJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
operator|&&
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|1
expr_stmt|;
comment|/* BRANCHJ */
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'|'
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
block|{
name|flags
operator|&=
operator|~
name|TRYAGAIN
expr_stmt|;
name|latest
operator|=
name|regpiece
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
continue|continue;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|latest
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* First piece. */
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
else|else
block|{
name|PL_regnaughty
operator|++
expr_stmt|;
name|regtail
argument_list|(
name|chain
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|latest
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
comment|/* Loop ran zero times. */
name|chain
operator|=
name|reg_node
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|chain
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|1
condition|)
block|{
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SIMPLE
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regpiece - something followed by possible [*+?]  *  * Note that the branching code sequences used for ? and the general cases  * of * and + are somewhat optimized:  they use the same NOTHING node as  * both the endmarker for their branch list and the body of the last branch.  * It might seem that this node could be dispensed with entirely, but the  * endmarker role is not redundant.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|regpiece
parameter_list|(
name|I32
modifier|*
name|flagp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
name|I32
name|flags
decl_stmt|;
name|char
modifier|*
name|origparse
init|=
name|PL_regcomp_parse
decl_stmt|;
name|char
modifier|*
name|maxpos
decl_stmt|;
name|I32
name|min
decl_stmt|;
name|I32
name|max
init|=
name|REG_INFTY
decl_stmt|;
name|ret
operator|=
name|regatom
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
operator|*
name|flagp
operator||=
name|TRYAGAIN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|op
operator|=
operator|*
name|PL_regcomp_parse
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'{'
operator|&&
name|regcurly
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|next
operator|=
name|PL_regcomp_parse
operator|+
literal|1
expr_stmt|;
name|maxpos
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|next
argument_list|)
operator|||
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|maxpos
condition|)
break|break;
else|else
name|maxpos
operator|=
name|next
expr_stmt|;
block|}
name|next
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|'}'
condition|)
block|{
comment|/* got one */
if|if
condition|(
operator|!
name|maxpos
condition|)
name|maxpos
operator|=
name|next
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|min
operator|=
name|atoi
argument_list|(
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|maxpos
operator|==
literal|','
condition|)
name|maxpos
operator|++
expr_stmt|;
else|else
name|maxpos
operator|=
name|PL_regcomp_parse
expr_stmt|;
name|max
operator|=
name|atoi
argument_list|(
name|maxpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max
operator|&&
operator|*
name|maxpos
operator|!=
literal|'0'
condition|)
name|max
operator|=
name|REG_INFTY
expr_stmt|;
comment|/* meaning "infinity" */
elseif|else
if|if
condition|(
name|max
operator|>=
name|REG_INFTY
condition|)
name|FAIL2
argument_list|(
literal|"Quantifier in {,} bigger than %d"
argument_list|,
name|REG_INFTY
operator|-
literal|1
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|=
name|next
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
name|do_curly
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|PL_regnaughty
operator|+=
literal|2
operator|+
name|PL_regnaughty
operator|/
literal|2
expr_stmt|;
name|reginsert
argument_list|(
name|CURLY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_regnaughty
operator|+=
literal|4
operator|+
name|PL_regnaughty
expr_stmt|;
comment|/* compound interest */
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg_node
argument_list|(
name|WHILEM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|reginsert
argument_list|(
name|LONGJMP
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|reginsert
argument_list|(
name|NOTHING
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|NEXT_OFF
argument_list|(
name|ret
argument_list|)
operator|=
literal|3
expr_stmt|;
comment|/* Go over LONGJMP. */
block|}
name|reginsert
argument_list|(
name|CURLYX
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
name|NEXT_OFF
argument_list|(
name|ret
argument_list|)
operator|=
literal|3
expr_stmt|;
comment|/* Go over NOTHING to LONGJMP. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg_node
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|3
expr_stmt|;
block|}
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|0
condition|)
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|max
operator|&&
name|max
operator|<
name|min
condition|)
name|FAIL
argument_list|(
literal|"Can't do {n,m} with n> m"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|ARG1_SET
argument_list|(
name|ret
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|ARG2_SET
argument_list|(
name|ret
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nest_check
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|ISMULT1
argument_list|(
name|op
argument_list|)
condition|)
block|{
operator|*
name|flagp
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* Now runtime fix should be reliable. */
block|if (!(flags&HASWIDTH)&& op != '?')       FAIL("regexp *+ operand could be empty");
endif|#
directive|endif
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
operator|(
name|op
operator|!=
literal|'+'
operator|)
condition|?
operator|(
name|WORST
operator||
name|SPSTART
operator||
name|HASWIDTH
operator|)
else|:
operator|(
name|WORST
operator||
name|HASWIDTH
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'*'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|reginsert
argument_list|(
name|STAR
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|PL_regnaughty
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|reginsert
argument_list|(
name|PLUS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|PL_regnaughty
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
condition|)
block|{
name|min
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'?'
condition|)
block|{
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
name|nest_check
label|:
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SIZE_ONLY
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
operator|&&
name|max
operator|>
literal|10000
condition|)
block|{
name|warn
argument_list|(
literal|"%.*s matches null string many times"
argument_list|,
name|PL_regcomp_parse
operator|-
name|origparse
argument_list|,
name|origparse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'?'
condition|)
block|{
name|nextchar
argument_list|()
expr_stmt|;
name|reginsert
argument_list|(
name|MINMOD
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|ret
operator|+
name|NODE_STEP_REGNODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISMULT2
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
name|FAIL
argument_list|(
literal|"nested *?+ in regexp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regatom - the lowest level  *  * Optimization:  gobbles an entire sequence of ordinary characters so that  * it can turn them into a single node, which is smaller to store and  * faster to run.  Backslashed characters are exceptions, each becoming a  * separate node; the code is simpler that way and it's not worth fixing.  *  * [Yes, it is worth fixing, some scripts can run twice the speed.]  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|regatom
parameter_list|(
name|I32
modifier|*
name|flagp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|I32
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|tryagain
label|:
switch|switch
condition|(
operator|*
name|PL_regcomp_parse
condition|)
block|{
case|case
literal|'^'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|MBOL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SBOL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|BOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|1
index|]
condition|)
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|MEOL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SEOL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|EOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SANY
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|ANY
argument_list|)
expr_stmt|;
name|PL_regnaughty
operator|++
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
name|regclass
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|nextchar
argument_list|()
expr_stmt|;
name|ret
operator|=
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
goto|goto
name|tryagain
goto|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|flagp
operator||=
name|flags
operator|&
operator|(
name|HASWIDTH
operator||
name|SPSTART
operator||
name|SIMPLE
operator|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|')'
case|:
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
block|{
operator|*
name|flagp
operator||=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|FAIL2
argument_list|(
literal|"internal urp in regexp at /%s/"
argument_list|,
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
comment|/* Supposed to be caught earlier. */
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
name|regcurly
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
goto|goto
name|defchar
goto|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
name|FAIL
argument_list|(
literal|"?+*{} follows nothing in regexp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|PL_regcomp_parse
condition|)
block|{
case|case
literal|'A'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|SBOL
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|GPOS
argument_list|)
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_GPOS
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|SEOL
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|EOS
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|PL_seen_zerolen
operator|++
expr_stmt|;
comment|/* Do not optimize RE away */
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|ALNUML
else|:
name|ALNUM
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|NALNUML
else|:
name|NALNUM
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|BOUNDL
else|:
name|BOUND
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|NBOUNDL
else|:
name|NBOUND
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|SPACEL
else|:
name|SPACE
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|NSPACEL
else|:
name|NSPACE
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|DIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|NDIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'a'
case|:
case|case
literal|'x'
case|:
case|case
literal|'c'
case|:
case|case
literal|'0'
case|:
goto|goto
name|defchar
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|I32
name|num
init|=
name|atoi
argument_list|(
name|PL_regcomp_parse
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|9
operator|&&
name|num
operator|>=
name|PL_regnpar
condition|)
goto|goto
name|defchar
goto|;
else|else
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|num
operator|>
name|PL_regcomp_rx
operator|->
name|nparens
condition|)
name|FAIL
argument_list|(
literal|"reference to nonexistent group"
argument_list|)
expr_stmt|;
name|PL_regsawback
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_FOLD
operator|)
condition|?
operator|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|REFFL
else|:
name|REFF
operator|)
else|:
name|REF
argument_list|,
name|num
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|PL_regcomp_parse
operator|>=
name|PL_regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
goto|goto
name|defchar
goto|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'\n'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
condition|)
goto|goto
name|tryagain
goto|;
block|}
comment|/* FALL THROUGH */
default|default:
block|{
specifier|register
name|I32
name|len
decl_stmt|;
specifier|register
name|U8
name|ender
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|I32
name|numlen
decl_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|defchar
label|:
name|ret
operator|=
name|reg_node
argument_list|(
operator|(
name|PL_regflags
operator|&
name|PMf_FOLD
operator|)
condition|?
operator|(
operator|(
name|PL_regflags
operator|&
name|PMf_LOCALE
operator|)
condition|?
name|EXACTFL
else|:
name|EXACTF
operator|)
else|:
name|EXACT
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|regc
argument_list|(
literal|0
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* save spot for len */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|PL_regcomp_parse
operator|-
literal|1
init|;
name|len
operator|<
literal|127
operator|&&
name|p
operator|<
name|PL_regxend
condition|;
name|len
operator|++
control|)
block|{
name|oldp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
name|p
operator|=
name|regwhite
argument_list|(
name|p
argument_list|,
name|PL_regxend
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
goto|goto
name|loopdone
goto|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'G'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
case|case
literal|'n'
case|:
name|ender
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ender
operator|=
literal|'\r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ender
operator|=
literal|'\t'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ender
operator|=
literal|'\f'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ender
operator|=
literal|'\033'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ender
operator|=
literal|'\007'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ender
operator|=
name|scan_hex
argument_list|(
operator|++
name|p
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|p
operator|++
expr_stmt|;
name|ender
operator|=
name|UCHARAT
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
name|ender
operator|=
name|toCTRL
argument_list|(
name|ender
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|||
operator|(
name|isDIGIT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|atoi
argument_list|(
name|p
argument_list|)
operator|>=
name|PL_regnpar
operator|)
condition|)
block|{
name|ender
operator|=
name|scan_oct
argument_list|(
name|p
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|p
operator|>=
name|PL_regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
name|p
operator|=
name|regwhite
argument_list|(
name|p
argument_list|,
name|PL_regxend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMULT2
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Back off on ?+*. */
if|if
condition|(
name|len
condition|)
name|p
operator|=
name|oldp
expr_stmt|;
else|else
block|{
name|len
operator|++
expr_stmt|;
name|regc
argument_list|(
name|ender
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|regc
argument_list|(
name|ender
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|loopdone
label|:
name|PL_regcomp_parse
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|FAIL
argument_list|(
literal|"internal disaster in regexp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
operator|*
name|OPERAND
argument_list|(
name|ret
argument_list|)
operator|=
name|len
expr_stmt|;
name|regc
argument_list|(
literal|'\0'
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|PL_regsize
operator|+=
operator|(
name|len
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_regcode
operator|+=
operator|(
name|len
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|regwhite
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|e
parameter_list|)
block|{
while|while
condition|(
name|p
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
do|;
block|}
else|else
break|break;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|STATIC
name|regnode
modifier|*
name|regclass
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|opnd
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|I32
name|Class
decl_stmt|;
specifier|register
name|I32
name|lastclass
init|=
literal|1234
decl_stmt|;
specifier|register
name|I32
name|range
init|=
literal|0
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|I32
name|def
decl_stmt|;
name|I32
name|numlen
decl_stmt|;
name|s
operator|=
name|opnd
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|PL_regcode
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|ANYOF
argument_list|)
expr_stmt|;
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|33
condition|;
name|Class
operator|++
control|)
name|regc
argument_list|(
literal|0
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'^'
condition|)
block|{
comment|/* Complement of range. */
name|PL_regnaughty
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_INVERT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|PL_regcode
operator|+=
name|ANY_SKIP
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_FOLD
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_FOLD
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_LOCALE
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
else|else
block|{
name|PL_regsize
operator|+=
name|ANY_SKIP
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|']'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
condition|)
goto|goto
name|skipcond
goto|;
comment|/* allow 1st char to be ] or - */
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|']'
condition|)
block|{
name|skipcond
label|:
name|Class
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|Class
operator|==
literal|'['
operator|&&
name|PL_regcomp_parse
operator|+
literal|1
operator|<
name|PL_regxend
operator|&&
comment|/* I smell either [: or [= or [. -- POSIX has been here, right? */
operator|(
operator|*
name|PL_regcomp_parse
operator|==
literal|':'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'='
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'.'
operator|)
condition|)
block|{
name|char
name|posixccc
init|=
operator|*
name|PL_regcomp_parse
decl_stmt|;
name|char
modifier|*
name|posixccs
init|=
name|PL_regcomp_parse
operator|++
decl_stmt|;
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
name|posixccc
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|==
name|PL_regxend
condition|)
comment|/* Grandfather lone [:, [=, [. */
name|PL_regcomp_parse
operator|=
name|posixccs
expr_stmt|;
else|else
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
comment|/* skip over the posixccc */
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|']'
condition|)
block|{
comment|/* Not Implemented Yet. 		     * (POSIX Extended Character Classes, that is) 		     * The text between e.g. [: and :] would start 		     * at posixccs + 1 and stop at regcomp_parse - 2. */
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SIZE_ONLY
condition|)
name|warn
argument_list|(
literal|"Character class syntax [%c %c] is reserved for future extensions"
argument_list|,
name|posixccc
argument_list|,
name|posixccc
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
comment|/* skip over the ending ] */
block|}
block|}
block|}
if|if
condition|(
name|Class
operator|==
literal|'\\'
condition|)
block|{
name|Class
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Class
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_LOCALE
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_ALNUML
expr_stmt|;
else|else
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|256
condition|;
name|Class
operator|++
control|)
if|if
condition|(
name|isALNUM
argument_list|(
name|Class
argument_list|)
condition|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_LOCALE
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_NALNUML
expr_stmt|;
else|else
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|256
condition|;
name|Class
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|Class
argument_list|)
condition|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_LOCALE
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_SPACEL
expr_stmt|;
else|else
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|256
condition|;
name|Class
operator|++
control|)
if|if
condition|(
name|isSPACE
argument_list|(
name|Class
argument_list|)
condition|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_LOCALE
condition|)
operator|*
name|opnd
operator||=
name|ANYOF_NSPACEL
expr_stmt|;
else|else
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|256
condition|;
name|Class
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|Class
argument_list|)
condition|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
for|for
control|(
name|Class
operator|=
literal|'0'
init|;
name|Class
operator|<=
literal|'9'
condition|;
name|Class
operator|++
control|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|'0'
condition|;
name|Class
operator|++
control|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
for|for
control|(
name|Class
operator|=
literal|'9'
operator|+
literal|1
init|;
name|Class
operator|<
literal|256
condition|;
name|Class
operator|++
control|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|Class
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Class
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|Class
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|Class
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Class
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|Class
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|Class
operator|=
literal|'\007'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|Class
operator|=
name|scan_hex
argument_list|(
name|PL_regcomp_parse
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Class
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
name|Class
operator|=
name|toCTRL
argument_list|(
name|Class
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|Class
operator|=
name|scan_oct
argument_list|(
operator|--
name|PL_regcomp_parse
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|range
condition|)
block|{
if|if
condition|(
name|lastclass
operator|>
name|Class
condition|)
name|FAIL
argument_list|(
literal|"invalid [] range in regexp"
argument_list|)
expr_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lastclass
operator|=
name|Class
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
operator|&&
name|PL_regcomp_parse
operator|+
literal|1
operator|<
name|PL_regxend
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|range
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* do it next time */
block|}
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
for|for
control|(
init|;
name|lastclass
operator|<=
name|Class
condition|;
name|lastclass
operator|++
control|)
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|lastclass
argument_list|)
expr_stmt|;
block|}
name|lastclass
operator|=
name|Class
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|']'
condition|)
name|FAIL
argument_list|(
literal|"unmatched [] in regexp"
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
comment|/* optimize case-insensitive simple patterns (e.g. /[a-z]/i) */
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
operator|(
operator|*
name|opnd
operator|&
operator|(
literal|0xFF
operator|^
name|ANYOF_INVERT
operator|)
operator|)
operator|==
name|ANYOF_FOLD
condition|)
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|256
condition|;
operator|++
name|Class
control|)
block|{
if|if
condition|(
name|ANYOF_TEST
argument_list|(
name|opnd
argument_list|,
name|Class
argument_list|)
condition|)
block|{
name|I32
name|cf
init|=
name|fold
index|[
name|Class
index|]
decl_stmt|;
name|ANYOF_SET
argument_list|(
name|opnd
argument_list|,
name|cf
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|opnd
operator|&=
operator|~
name|ANYOF_FOLD
expr_stmt|;
block|}
comment|/* optimize inverted simple patterns (e.g. [^a-z]) */
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
operator|(
operator|*
name|opnd
operator|&
literal|0xFF
operator|)
operator|==
name|ANYOF_INVERT
condition|)
block|{
for|for
control|(
name|Class
operator|=
literal|0
init|;
name|Class
operator|<
literal|32
condition|;
operator|++
name|Class
control|)
name|opnd
index|[
literal|1
operator|+
name|Class
index|]
operator|^=
literal|0xFF
expr_stmt|;
operator|*
name|opnd
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|nextchar
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|retval
init|=
name|PL_regcomp_parse
operator|++
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'('
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'?'
operator|&&
name|PL_regcomp_parse
index|[
literal|2
index|]
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'\n'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|retval
return|;
block|}
block|}
end_function

begin_comment
comment|/* - reg_node - emit a node */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
comment|/* Location. */
name|reg_node
parameter_list|(
name|U8
name|op
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|PL_regcode
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|SIZE_ALIGN
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|PL_regsize
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|NODE_ALIGN_FILL
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ret
expr_stmt|;
name|FILL_ADVANCE_NODE
argument_list|(
name|ptr
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|PL_regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* - reganode - emit a node with an argument */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
comment|/* Location. */
name|reganode
parameter_list|(
name|U8
name|op
parameter_list|,
name|U32
name|arg
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|PL_regcode
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|SIZE_ALIGN
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|PL_regsize
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|NODE_ALIGN_FILL
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ret
expr_stmt|;
name|FILL_ADVANCE_NODE_ARG
argument_list|(
name|ptr
argument_list|,
name|op
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|PL_regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* - regc - emit (if appropriate) a byte of code */
end_comment

begin_function
name|STATIC
name|void
name|regc
parameter_list|(
name|U8
name|b
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
operator|*
name|s
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - reginsert - insert an operator in front of already-emitted operand * * Means relocating the operand. */
end_comment

begin_function
name|STATIC
name|void
name|reginsert
parameter_list|(
name|U8
name|op
parameter_list|,
name|regnode
modifier|*
name|opnd
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|src
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|dst
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|place
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|op
index|]
decl_stmt|;
comment|/* (regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|PL_regsize
operator|+=
name|NODE_STEP_REGNODE
operator|+
name|offset
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|PL_regcode
expr_stmt|;
name|PL_regcode
operator|+=
name|NODE_STEP_REGNODE
operator|+
name|offset
expr_stmt|;
name|dst
operator|=
name|PL_regcode
expr_stmt|;
while|while
condition|(
name|src
operator|>
name|opnd
condition|)
name|StructCopy
argument_list|(
operator|--
name|src
argument_list|,
operator|--
name|dst
argument_list|,
name|regnode
argument_list|)
expr_stmt|;
name|place
operator|=
name|opnd
expr_stmt|;
comment|/* Op node, where operand used to be. */
name|src
operator|=
name|NEXTOPER
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|FILL_ADVANCE_NODE
argument_list|(
name|place
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|regnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - regtail - set the next-pointer at the end of a node chain of p to val. */
end_comment

begin_function
name|STATIC
name|void
name|regtail
parameter_list|(
name|regnode
modifier|*
name|p
parameter_list|,
name|regnode
modifier|*
name|val
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|scan
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|temp
decl_stmt|;
specifier|register
name|I32
name|offset
decl_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
return|return;
comment|/* Find last node. */
name|scan
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|temp
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
break|break;
name|scan
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
block|{
name|ARG_SET
argument_list|(
name|scan
argument_list|,
name|val
operator|-
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|=
name|val
operator|-
name|scan
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* - regoptail - regtail on operand of first argument; nop if operandless */
end_comment

begin_function
name|STATIC
name|void
name|regoptail
parameter_list|(
name|regnode
modifier|*
name|p
parameter_list|,
name|regnode
modifier|*
name|val
parameter_list|)
block|{
name|dTHR
expr_stmt|;
comment|/* "Operandless" and "op != BRANCH" are synonymous in practice. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|SIZE_ONLY
condition|)
return|return;
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|p
argument_list|)
index|]
operator|==
name|BRANCH
condition|)
block|{
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|p
argument_list|)
index|]
operator|==
name|BRANCHJ
condition|)
block|{
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
end_function

begin_comment
comment|/*  - regcurly - a little FSA that accepts {\d+,?\d*}  */
end_comment

begin_function
name|STATIC
name|I32
name|regcurly
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'{'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'}'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|STATIC
name|regnode
modifier|*
name|dumpuntil
parameter_list|(
name|regnode
modifier|*
name|start
parameter_list|,
name|regnode
modifier|*
name|node
parameter_list|,
name|regnode
modifier|*
name|last
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|l
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
specifier|register
name|char
name|op
init|=
name|EXACT
decl_stmt|;
comment|/* Arbitrary non-END op. */
specifier|register
name|regnode
modifier|*
name|next
decl_stmt|,
modifier|*
name|onode
decl_stmt|;
while|while
condition|(
name|op
operator|!=
name|END
operator|&&
operator|(
operator|!
name|last
operator|||
name|node
operator|<
name|last
operator|)
condition|)
block|{
comment|/* While that wasn't END last time... */
name|NODE_ALIGN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|op
operator|=
name|OP
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|CLOSE
condition|)
name|l
operator|--
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Where, what. */
if|if
condition|(
name|OP
argument_list|(
name|node
argument_list|)
operator|==
name|OPTIMIZED
condition|)
goto|goto
name|after_print
goto|;
name|regprop
argument_list|(
name|sv
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%4d:%*s%s"
argument_list|,
name|node
operator|-
name|start
argument_list|,
literal|2
operator|*
name|l
operator|+
literal|1
argument_list|,
literal|""
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* Next ptr. */
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(0)"
argument_list|)
expr_stmt|;
else|else
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(%d)"
argument_list|,
name|next
operator|-
name|start
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_putc
argument_list|(
name|Perl_debug_log
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|after_print
label|:
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|BRANCHJ
condition|)
block|{
specifier|register
name|regnode
modifier|*
name|nnode
init|=
operator|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|LONGJMP
condition|?
name|regnext
argument_list|(
name|next
argument_list|)
else|:
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|last
operator|&&
name|nnode
operator|>
name|last
condition|)
name|nnode
operator|=
name|last
expr_stmt|;
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|nnode
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|BRANCH
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|,
name|next
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|CURLY
condition|)
block|{
comment|/* `next' might be very big: optimizer */
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|CURLY
operator|&&
name|op
operator|!=
name|CURLYX
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
argument_list|,
name|next
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|PLUS
operator|||
name|op
operator|==
name|STAR
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ANYOF
condition|)
block|{
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|+=
name|ANY_SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|EXACT
condition|)
block|{
comment|/* Literal string, where present. */
name|node
operator|+=
operator|(
operator|(
operator|*
name|OPERAND
argument_list|(
name|node
argument_list|)
operator|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
expr_stmt|;
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|+=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|op
index|]
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|CURLYX
operator|||
name|op
operator|==
name|OPEN
condition|)
name|l
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|WHILEM
condition|)
name|l
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGGING */
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/*  - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form  */
end_comment

begin_function
name|void
name|regdump
parameter_list|(
name|regexp
modifier|*
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|dumpuntil
argument_list|(
name|r
operator|->
name|program
argument_list|,
name|r
operator|->
name|program
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Header fields of interest. */
if|if
condition|(
name|r
operator|->
name|anchored_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"anchored `%s%s%s'%s at %d "
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|SvPVX
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
name|SvTAIL
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
argument_list|,
name|r
operator|->
name|anchored_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|float_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"floating `%s%s%s'%s at %d..%u "
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|SvPVX
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
name|SvTAIL
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
argument_list|,
name|r
operator|->
name|float_min_offset
argument_list|,
name|r
operator|->
name|float_max_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|check_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
name|r
operator|->
name|check_substr
operator|==
name|r
operator|->
name|float_substr
condition|?
literal|"(checking floating"
else|:
literal|"(checking anchored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_NOSCAN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" noscan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_CHECK_ALL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" isall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|check_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regstclass
condition|)
block|{
name|regprop
argument_list|(
name|sv
argument_list|,
name|r
operator|->
name|regstclass
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stclass `%s' "
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"anchored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_BOL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(BOL)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_MBOL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(MBOL)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(GPOS)"
argument_list|)
expr_stmt|;
name|PerlIO_putc
argument_list|(
name|Perl_debug_log
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_GPOS_SEEN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"GPOS "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"plus "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"implicit "
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"minlen %ld "
argument_list|,
operator|(
name|long
operator|)
name|r
operator|->
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"with eval "
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_comment
comment|/* - regprop - printable representation of opcode */
end_comment

begin_function
name|void
name|regprop
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|regnode
modifier|*
name|o
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|o
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
name|p
operator|=
literal|"BOL"
expr_stmt|;
break|break;
case|case
name|MBOL
case|:
name|p
operator|=
literal|"MBOL"
expr_stmt|;
break|break;
case|case
name|SBOL
case|:
name|p
operator|=
literal|"SBOL"
expr_stmt|;
break|break;
case|case
name|EOL
case|:
name|p
operator|=
literal|"EOL"
expr_stmt|;
break|break;
case|case
name|EOS
case|:
name|p
operator|=
literal|"EOS"
expr_stmt|;
break|break;
case|case
name|MEOL
case|:
name|p
operator|=
literal|"MEOL"
expr_stmt|;
break|break;
case|case
name|SEOL
case|:
name|p
operator|=
literal|"SEOL"
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|p
operator|=
literal|"ANY"
expr_stmt|;
break|break;
case|case
name|SANY
case|:
name|p
operator|=
literal|"SANY"
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|p
operator|=
literal|"ANYOF"
expr_stmt|;
break|break;
case|case
name|BRANCH
case|:
name|p
operator|=
literal|"BRANCH"
expr_stmt|;
break|break;
case|case
name|EXACT
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"EXACT<%s%s%s>"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|OPERAND
argument_list|(
name|o
argument_list|)
operator|+
literal|1
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACTF
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"EXACTF<%s%s%s>"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|OPERAND
argument_list|(
name|o
argument_list|)
operator|+
literal|1
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACTFL
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"EXACTFL<%s%s%s>"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|OPERAND
argument_list|(
name|o
argument_list|)
operator|+
literal|1
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
name|p
operator|=
literal|"NOTHING"
expr_stmt|;
break|break;
case|case
name|TAIL
case|:
name|p
operator|=
literal|"TAIL"
expr_stmt|;
break|break;
case|case
name|BACK
case|:
name|p
operator|=
literal|"BACK"
expr_stmt|;
break|break;
case|case
name|END
case|:
name|p
operator|=
literal|"END"
expr_stmt|;
break|break;
case|case
name|BOUND
case|:
name|p
operator|=
literal|"BOUND"
expr_stmt|;
break|break;
case|case
name|BOUNDL
case|:
name|p
operator|=
literal|"BOUNDL"
expr_stmt|;
break|break;
case|case
name|NBOUND
case|:
name|p
operator|=
literal|"NBOUND"
expr_stmt|;
break|break;
case|case
name|NBOUNDL
case|:
name|p
operator|=
literal|"NBOUNDL"
expr_stmt|;
break|break;
case|case
name|CURLY
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"CURLY {%d,%d}"
argument_list|,
name|ARG1
argument_list|(
name|o
argument_list|)
argument_list|,
name|ARG2
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURLYM
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"CURLYM[%d] {%d,%d}"
argument_list|,
name|o
operator|->
name|flags
argument_list|,
name|ARG1
argument_list|(
name|o
argument_list|)
argument_list|,
name|ARG2
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURLYN
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"CURLYN[%d] {%d,%d}"
argument_list|,
name|o
operator|->
name|flags
argument_list|,
name|ARG1
argument_list|(
name|o
argument_list|)
argument_list|,
name|ARG2
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURLYX
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"CURLYX {%d,%d}"
argument_list|,
name|ARG1
argument_list|(
name|o
argument_list|)
argument_list|,
name|ARG2
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REF
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"REF%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFF
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"REFF%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFFL
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"REFFL%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"OPEN%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"CLOSE%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|p
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|p
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
case|case
name|MINMOD
case|:
name|p
operator|=
literal|"MINMOD"
expr_stmt|;
break|break;
case|case
name|GPOS
case|:
name|p
operator|=
literal|"GPOS"
expr_stmt|;
break|break;
case|case
name|UNLESSM
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"UNLESSM[-%d]"
argument_list|,
name|o
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFMATCH
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"IFMATCH[-%d]"
argument_list|,
name|o
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUCCEED
case|:
name|p
operator|=
literal|"SUCCEED"
expr_stmt|;
break|break;
case|case
name|WHILEM
case|:
name|p
operator|=
literal|"WHILEM"
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
name|p
operator|=
literal|"DIGIT"
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
name|p
operator|=
literal|"NDIGIT"
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
name|p
operator|=
literal|"ALNUM"
expr_stmt|;
break|break;
case|case
name|NALNUM
case|:
name|p
operator|=
literal|"NALNUM"
expr_stmt|;
break|break;
case|case
name|SPACE
case|:
name|p
operator|=
literal|"SPACE"
expr_stmt|;
break|break;
case|case
name|NSPACE
case|:
name|p
operator|=
literal|"NSPACE"
expr_stmt|;
break|break;
case|case
name|ALNUML
case|:
name|p
operator|=
literal|"ALNUML"
expr_stmt|;
break|break;
case|case
name|NALNUML
case|:
name|p
operator|=
literal|"NALNUML"
expr_stmt|;
break|break;
case|case
name|SPACEL
case|:
name|p
operator|=
literal|"SPACEL"
expr_stmt|;
break|break;
case|case
name|NSPACEL
case|:
name|p
operator|=
literal|"NSPACEL"
expr_stmt|;
break|break;
case|case
name|EVAL
case|:
name|p
operator|=
literal|"EVAL"
expr_stmt|;
break|break;
case|case
name|LONGJMP
case|:
name|p
operator|=
literal|"LONGJMP"
expr_stmt|;
break|break;
case|case
name|BRANCHJ
case|:
name|p
operator|=
literal|"BRANCHJ"
expr_stmt|;
break|break;
case|case
name|IFTHEN
case|:
name|p
operator|=
literal|"IFTHEN"
expr_stmt|;
break|break;
case|case
name|GROUPP
case|:
name|sv_catpvf
argument_list|(
name|sv
argument_list|,
literal|"GROUPP%d"
argument_list|,
name|ARG
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOGICAL
case|:
name|p
operator|=
literal|"LOGICAL"
expr_stmt|;
break|break;
case|case
name|SUSPEND
case|:
name|p
operator|=
literal|"SUSPEND"
expr_stmt|;
break|break;
case|case
name|RENUM
case|:
name|p
operator|=
literal|"RENUM"
expr_stmt|;
break|break;
case|case
name|OPTIMIZED
case|:
name|p
operator|=
literal|"OPTIMIZED"
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|(
literal|"corrupted regexp opcode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|void
name|pregfree
parameter_list|(
name|struct
name|regexp
modifier|*
name|r
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|||
operator|(
operator|--
name|r
operator|->
name|refcnt
operator|>
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|r
operator|->
name|precomp
condition|)
name|Safefree
argument_list|(
name|r
operator|->
name|precomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|subbase
condition|)
name|Safefree
argument_list|(
name|r
operator|->
name|subbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|substrs
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|anchored_substr
condition|)
name|SvREFCNT_dec
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|float_substr
condition|)
name|SvREFCNT_dec
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|substrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
condition|)
block|{
name|int
name|n
init|=
name|r
operator|->
name|data
operator|->
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|data
operator|->
name|what
index|[
name|n
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|op_free
argument_list|(
operator|(
name|OP_4tree
operator|*
operator|)
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
break|break;
default|default:
name|FAIL2
argument_list|(
literal|"panic: regfree data code '%c'"
argument_list|,
name|r
operator|->
name|data
operator|->
name|what
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|Safefree
argument_list|(
name|r
operator|->
name|data
operator|->
name|what
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|r
operator|->
name|startp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|endp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regnext - dig the "next" pointer out of a node  *  * [Note, when REGALIGN is defined there are two places in regmatch()  * that bypass this code for speed.]  */
end_comment

begin_function
name|regnode
modifier|*
name|regnext
parameter_list|(
specifier|register
name|regnode
modifier|*
name|p
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|PL_regdummy
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|offset
operator|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|p
argument_list|)
index|]
condition|?
name|ARG
argument_list|(
name|p
argument_list|)
else|:
name|NEXT_OFF
argument_list|(
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|p
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|re_croak2
parameter_list|(
specifier|const
name|char
modifier|*
name|pat1
parameter_list|,
specifier|const
name|char
modifier|*
name|pat2
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|STRLEN
name|l1
init|=
name|strlen
argument_list|(
name|pat1
argument_list|)
decl_stmt|;
name|STRLEN
name|l2
init|=
name|strlen
argument_list|(
name|pat2
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|l1
operator|>
literal|510
condition|)
name|l1
operator|=
literal|510
expr_stmt|;
if|if
condition|(
name|l1
operator|+
name|l2
operator|>
literal|510
condition|)
name|l2
operator|=
literal|510
operator|-
name|l1
expr_stmt|;
name|Copy
argument_list|(
name|pat1
argument_list|,
name|buf
argument_list|,
name|l1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|pat2
argument_list|,
name|buf
operator|+
name|l1
argument_list|,
name|l2
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|buf
index|[
name|l1
operator|+
name|l2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|l1
operator|+
name|l2
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat2
argument_list|)
expr_stmt|;
name|message
operator|=
name|mess
argument_list|(
name|buf
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|>
literal|512
condition|)
name|l1
operator|=
literal|512
expr_stmt|;
name|Copy
argument_list|(
name|message
argument_list|,
name|buf
argument_list|,
name|l1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|buf
index|[
name|l1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Overwrite \n */
name|croak
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

