begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    regcomp.c  */
end_comment

begin_comment
comment|/*  * "A fair jaw-cracker dwarf-language must be."  --Samwise Gamgee  */
end_comment

begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* The names of the functions have been changed from regcomp and  * regexec to  pregcomp and pregexec in order to avoid conflicts  * with the POSIX routines of the same names. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_EXT_RE_BUILD
end_ifdef

begin_comment
comment|/* need to replace pregcomp et al, so enable that */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_IN_XSUB_RE
end_ifndef

begin_define
define|#
directive|define
name|PERL_IN_XSUB_RE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* need access to debugger hooks */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_EXT_RE_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEBUGGING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_comment
comment|/* We *really* need to overwrite these symbols: */
end_comment

begin_define
define|#
directive|define
name|Perl_pregcomp
value|my_regcomp
end_define

begin_define
define|#
directive|define
name|Perl_regdump
value|my_regdump
end_define

begin_define
define|#
directive|define
name|Perl_regprop
value|my_regprop
end_define

begin_define
define|#
directive|define
name|Perl_pregfree
value|my_regfree
end_define

begin_define
define|#
directive|define
name|Perl_re_intuit_string
value|my_re_intuit_string
end_define

begin_comment
comment|/* *These* symbols are masked to allow static link. */
end_comment

begin_define
define|#
directive|define
name|Perl_regnext
value|my_regnext
end_define

begin_define
define|#
directive|define
name|Perl_save_re_context
value|my_save_re_context
end_define

begin_define
define|#
directive|define
name|Perl_reginitcolors
value|my_reginitcolors
end_define

begin_define
define|#
directive|define
name|PERL_NO_GET_CONTEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * pregcomp and pregexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991-2000, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.   *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_REGCOMP_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CAPI
argument_list|)
operator|||
name|defined
argument_list|(
name|PERL_OBJECT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_COMP_C
end_define

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|op
end_ifdef

begin_undef
undef|#
directive|undef
name|op
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* op */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BUGGY_MSC6
argument_list|)
end_if

begin_comment
comment|/* MSC 6.00A breaks on op/regexp.t test 85 unless we turn this off */
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"a"
name|,
name|off
name|)
end_pragma

begin_comment
comment|/* But MSC 6.00A is happy with 'w', for aliases only across function calls*/
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"w"
name|,
name|on
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUGGY_MSC6 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISMULT1
parameter_list|(
name|c
parameter_list|)
value|((c) == '*' || (c) == '+' || (c) == '?')
end_define

begin_define
define|#
directive|define
name|ISMULT2
parameter_list|(
name|s
parameter_list|)
value|((*s) == '*' || (*s) == '+' || (*s) == '?' || \ 	((*s) == '{'&& regcurly(s)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_define
define|#
directive|define
name|PERL_META
value|"^$.[()|?+*\\"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|META
value|"^$.[()|?+*\\"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SPSTART
end_ifdef

begin_undef
undef|#
directive|undef
name|SPSTART
end_undef

begin_comment
comment|/* dratted cpp namespace... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Flags to be passed up and down.  */
end_comment

begin_define
define|#
directive|define
name|WORST
value|0
end_define

begin_comment
comment|/* Worst case. */
end_comment

begin_define
define|#
directive|define
name|HASWIDTH
value|0x1
end_define

begin_comment
comment|/* Known to match non-null strings. */
end_comment

begin_define
define|#
directive|define
name|SIMPLE
value|0x2
end_define

begin_comment
comment|/* Simple enough to be STAR/PLUS operand. */
end_comment

begin_define
define|#
directive|define
name|SPSTART
value|0x4
end_define

begin_comment
comment|/* Starts with * or +. */
end_comment

begin_define
define|#
directive|define
name|TRYAGAIN
value|0x8
end_define

begin_comment
comment|/* Weeded out a declaration. */
end_comment

begin_comment
comment|/* Length of a variant. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scan_data_t
block|{
name|I32
name|len_min
decl_stmt|;
name|I32
name|len_delta
decl_stmt|;
name|I32
name|pos_min
decl_stmt|;
name|I32
name|pos_delta
decl_stmt|;
name|SV
modifier|*
name|last_found
decl_stmt|;
name|I32
name|last_end
decl_stmt|;
comment|/* min value,<0 unless valid. */
name|I32
name|last_start_min
decl_stmt|;
name|I32
name|last_start_max
decl_stmt|;
name|SV
modifier|*
modifier|*
name|longest
decl_stmt|;
comment|/* Either&l_fixed, or&l_float. */
name|SV
modifier|*
name|longest_fixed
decl_stmt|;
name|I32
name|offset_fixed
decl_stmt|;
name|SV
modifier|*
name|longest_float
decl_stmt|;
name|I32
name|offset_float_min
decl_stmt|;
name|I32
name|offset_float_max
decl_stmt|;
name|I32
name|flags
decl_stmt|;
name|I32
name|whilem_c
decl_stmt|;
name|struct
name|regnode_charclass_class
modifier|*
name|start_class
decl_stmt|;
block|}
name|scan_data_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations for pregcomp()'s friends.  */
end_comment

begin_decl_stmt
specifier|static
name|scan_data_t
name|zero_scan_data
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SF_BEFORE_EOL
value|(SF_BEFORE_SEOL|SF_BEFORE_MEOL)
end_define

begin_define
define|#
directive|define
name|SF_BEFORE_SEOL
value|0x1
end_define

begin_define
define|#
directive|define
name|SF_BEFORE_MEOL
value|0x2
end_define

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_EOL
value|(SF_FIX_BEFORE_SEOL|SF_FIX_BEFORE_MEOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_EOL
value|(SF_FL_BEFORE_SEOL|SF_FL_BEFORE_MEOL)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UNARY_PLUS
end_ifdef

begin_define
define|#
directive|define
name|SF_FIX_SHIFT_EOL
value|(0+2)
end_define

begin_define
define|#
directive|define
name|SF_FL_SHIFT_EOL
value|(0+4)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SF_FIX_SHIFT_EOL
value|(+2)
end_define

begin_define
define|#
directive|define
name|SF_FL_SHIFT_EOL
value|(+4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_SEOL
value|(SF_BEFORE_SEOL<< SF_FIX_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FIX_BEFORE_MEOL
value|(SF_BEFORE_MEOL<< SF_FIX_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_SEOL
value|(SF_BEFORE_SEOL<< SF_FL_SHIFT_EOL)
end_define

begin_define
define|#
directive|define
name|SF_FL_BEFORE_MEOL
value|(SF_BEFORE_MEOL<< SF_FL_SHIFT_EOL)
end_define

begin_comment
comment|/* 0x20 */
end_comment

begin_define
define|#
directive|define
name|SF_IS_INF
value|0x40
end_define

begin_define
define|#
directive|define
name|SF_HAS_PAR
value|0x80
end_define

begin_define
define|#
directive|define
name|SF_IN_PAR
value|0x100
end_define

begin_define
define|#
directive|define
name|SF_HAS_EVAL
value|0x200
end_define

begin_define
define|#
directive|define
name|SCF_DO_SUBSTR
value|0x400
end_define

begin_define
define|#
directive|define
name|SCF_DO_STCLASS_AND
value|0x0800
end_define

begin_define
define|#
directive|define
name|SCF_DO_STCLASS_OR
value|0x1000
end_define

begin_define
define|#
directive|define
name|SCF_DO_STCLASS
value|(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR)
end_define

begin_define
define|#
directive|define
name|RF_utf8
value|8
end_define

begin_define
define|#
directive|define
name|UTF
value|(PL_reg_flags& RF_utf8)
end_define

begin_define
define|#
directive|define
name|LOC
value|(PL_regflags& PMf_LOCALE)
end_define

begin_define
define|#
directive|define
name|FOLD
value|(PL_regflags& PMf_FOLD)
end_define

begin_define
define|#
directive|define
name|OOB_CHAR8
value|1234
end_define

begin_define
define|#
directive|define
name|OOB_UTF8
value|123456
end_define

begin_define
define|#
directive|define
name|OOB_NAMEDCLASS
value|-1
end_define

begin_define
define|#
directive|define
name|CHR_SVLEN
parameter_list|(
name|sv
parameter_list|)
value|(UTF ? sv_len_utf8(sv) : SvCUR(sv))
end_define

begin_define
define|#
directive|define
name|CHR_DIST
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(UTF ? utf8_distance(a,b) : a - b)
end_define

begin_comment
comment|/* Allow for side effects in s */
end_comment

begin_define
define|#
directive|define
name|REGC
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|STMT_START { if (!SIZE_ONLY) *(s) = (c); else (s);} STMT_END
end_define

begin_function_decl
specifier|static
name|void
name|clear_re
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Mark that we cannot extend a found fixed substring at this point.    Updata the longest found anchored substring and the longest found    floating substrings if needed. */
end_comment

begin_function
name|STATIC
name|void
name|S_scan_commit
parameter_list|(
name|pTHX_
name|scan_data_t
modifier|*
name|data
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|STRLEN
name|l
init|=
name|CHR_SVLEN
argument_list|(
name|data
operator|->
name|last_found
argument_list|)
decl_stmt|;
name|STRLEN
name|old_l
init|=
name|CHR_SVLEN
argument_list|(
operator|*
name|data
operator|->
name|longest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|>=
name|old_l
operator|)
operator|&&
operator|(
operator|(
name|l
operator|>
name|old_l
operator|)
operator|||
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|)
condition|)
block|{
name|sv_setsv
argument_list|(
operator|*
name|data
operator|->
name|longest
argument_list|,
name|data
operator|->
name|last_found
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|->
name|longest
operator|==
name|data
operator|->
name|longest_fixed
condition|)
block|{
name|data
operator|->
name|offset_fixed
operator|=
name|l
condition|?
name|data
operator|->
name|last_start_min
else|:
name|data
operator|->
name|pos_min
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
condition|)
name|data
operator|->
name|flags
operator||=
operator|(
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|<<
name|SF_FIX_SHIFT_EOL
operator|)
expr_stmt|;
else|else
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_FIX_BEFORE_EOL
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|offset_float_min
operator|=
name|l
condition|?
name|data
operator|->
name|last_start_min
else|:
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|offset_float_max
operator|=
operator|(
name|l
condition|?
name|data
operator|->
name|last_start_max
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
condition|)
name|data
operator|->
name|flags
operator||=
operator|(
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_BEFORE_EOL
operator|)
operator|<<
name|SF_FL_SHIFT_EOL
operator|)
expr_stmt|;
else|else
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_FL_BEFORE_EOL
expr_stmt|;
block|}
block|}
name|SvCUR_set
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_BEFORE_EOL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Can match anything (initialization) */
end_comment

begin_function
name|STATIC
name|void
name|S_cl_anything
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|ANYOF_CLASS_ZERO
argument_list|(
name|cl
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
operator|++
name|value
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|cl
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cl
operator|->
name|flags
operator|=
name|ANYOF_EOS
expr_stmt|;
if|if
condition|(
name|LOC
condition|)
name|cl
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Can match anything (initialization) */
end_comment

begin_function
name|STATIC
name|int
name|S_cl_is_anything
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
name|ANYOF_MAX
condition|;
name|value
operator|+=
literal|2
control|)
if|if
condition|(
name|ANYOF_CLASS_TEST
argument_list|(
name|cl
argument_list|,
name|value
argument_list|)
operator|&&
name|ANYOF_CLASS_TEST
argument_list|(
name|cl
argument_list|,
name|value
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
operator|++
name|value
control|)
if|if
condition|(
operator|!
name|ANYOF_BITMAP_TEST
argument_list|(
name|cl
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Can match anything (initialization) */
end_comment

begin_function
name|STATIC
name|void
name|S_cl_init
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|)
block|{
name|Zero
argument_list|(
name|cl
argument_list|,
literal|1
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|cl
operator|->
name|type
operator|=
name|ANYOF
expr_stmt|;
name|cl_anything
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_cl_init_zero
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|)
block|{
name|Zero
argument_list|(
name|cl
argument_list|,
literal|1
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|cl
operator|->
name|type
operator|=
name|ANYOF
expr_stmt|;
name|cl_anything
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOC
condition|)
name|cl
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 'And' a given class with another one.  Can create false positives */
end_comment

begin_comment
comment|/* We assume that cl is not inverted */
end_comment

begin_function
name|STATIC
name|void
name|S_cl_and
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|,
name|struct
name|regnode_charclass_class
modifier|*
name|and_with
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|and_with
operator|->
name|flags
operator|&
name|ANYOF_CLASS
operator|)
operator|&&
operator|!
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_CLASS
operator|)
operator|&&
operator|(
name|and_with
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|==
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|&&
operator|!
operator|(
name|and_with
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
operator|&&
operator|!
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|and_with
operator|->
name|flags
operator|&
name|ANYOF_INVERT
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ANYOF_BITMAP_SIZE
condition|;
name|i
operator|++
control|)
name|cl
operator|->
name|bitmap
index|[
name|i
index|]
operator|&=
operator|~
name|and_with
operator|->
name|bitmap
index|[
name|i
index|]
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ANYOF_BITMAP_SIZE
condition|;
name|i
operator|++
control|)
name|cl
operator|->
name|bitmap
index|[
name|i
index|]
operator|&=
name|and_with
operator|->
name|bitmap
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* XXXX: logic is complicated otherwise, leave it along for a moment. */
if|if
condition|(
operator|!
operator|(
name|and_with
operator|->
name|flags
operator|&
name|ANYOF_EOS
operator|)
condition|)
name|cl
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 'OR' a given class with another one.  Can create false positives */
end_comment

begin_comment
comment|/* We assume that cl is not inverted */
end_comment

begin_function
name|STATIC
name|void
name|S_cl_or
parameter_list|(
name|pTHX_
name|struct
name|regnode_charclass_class
modifier|*
name|cl
parameter_list|,
name|struct
name|regnode_charclass_class
modifier|*
name|or_with
parameter_list|)
block|{
if|if
condition|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_INVERT
condition|)
block|{
comment|/* We do not use 	 * (B1 | CL1) | (!B2& !CL2) = (B1 | !B2& !CL2) | (CL1 | (!B2& !CL2)) 	 *<= (B1 | !B2) | (CL1 | !CL2) 	 * which is wasteful if CL2 is small, but we ignore CL2: 	 *   (B1 | CL1) | (!B2& !CL2)<= (B1 | CL1) | !B2 = (B1 | !B2) | CL1 	 * XXXX Can we handle case-fold?  Unclear: 	 *   (OK1(i) | OK1(i')) | !(OK1(i) | OK1(i')) = 	 *   (OK1(i) | OK1(i')) | (!OK1(i)& !OK1(i')) 	 */
if|if
condition|(
operator|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|==
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|&&
operator|!
operator|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
operator|&&
operator|!
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ANYOF_BITMAP_SIZE
condition|;
name|i
operator|++
control|)
name|cl
operator|->
name|bitmap
index|[
name|i
index|]
operator||=
operator|~
name|or_with
operator|->
name|bitmap
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* XXXX: logic is complicated otherwise */
else|else
block|{
name|cl_anything
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* (B1 | CL1) | (B2 | CL2) = (B1 | B2) | (CL1 | CL2)) */
if|if
condition|(
operator|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|==
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
operator|||
operator|(
name|cl
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* OR char bitmap and class bitmap separately */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ANYOF_BITMAP_SIZE
condition|;
name|i
operator|++
control|)
name|cl
operator|->
name|bitmap
index|[
name|i
index|]
operator||=
name|or_with
operator|->
name|bitmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_CLASS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ANYOF_CLASSBITMAP_SIZE
condition|;
name|i
operator|++
control|)
name|cl
operator|->
name|classflags
index|[
name|i
index|]
operator||=
name|or_with
operator|->
name|classflags
index|[
name|i
index|]
expr_stmt|;
name|cl
operator|->
name|flags
operator||=
name|ANYOF_CLASS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* XXXX: logic is complicated, leave it along for a moment. */
name|cl_anything
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|or_with
operator|->
name|flags
operator|&
name|ANYOF_EOS
condition|)
name|cl
operator|->
name|flags
operator||=
name|ANYOF_EOS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REx optimizer.  Converts nodes into quickier variants "in place".    Finds fixed substrings.  */
end_comment

begin_comment
comment|/* Stops at toplevel WHILEM as well as at `last'. At end *scanp is set    to the position after last scanned or to NULL. */
end_comment

begin_function
name|STATIC
name|I32
name|S_study_chunk
parameter_list|(
name|pTHX_
name|regnode
modifier|*
modifier|*
name|scanp
parameter_list|,
name|I32
modifier|*
name|deltap
parameter_list|,
name|regnode
modifier|*
name|last
parameter_list|,
name|scan_data_t
modifier|*
name|data
parameter_list|,
name|U32
name|flags
parameter_list|)
comment|/* scanp: Start here (read-write). */
comment|/* deltap: Write maxlen-minlen here. */
comment|/* last: Stop before this one. */
block|{
name|dTHR
expr_stmt|;
name|I32
name|min
init|=
literal|0
decl_stmt|,
name|pars
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
name|regnode
modifier|*
name|scan
init|=
operator|*
name|scanp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|I32
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|is_inf
init|=
operator|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|)
operator|&&
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_IS_INF
operator|)
decl_stmt|;
name|int
name|is_inf_internal
init|=
literal|0
decl_stmt|;
comment|/* The studied chunk is infinite */
name|I32
name|is_par
init|=
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|OPEN
condition|?
name|ARG
argument_list|(
name|scan
argument_list|)
else|:
literal|0
decl_stmt|;
name|scan_data_t
name|data_fake
decl_stmt|;
name|struct
name|regnode_charclass_class
name|and_with
decl_stmt|;
comment|/* Valid if flags& SCF_DO_STCLASS_OR */
while|while
condition|(
name|scan
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|END
operator|&&
name|scan
operator|<
name|last
condition|)
block|{
comment|/* Peephole optimizer: */
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
comment|/* Merge several consecutive EXACTish nodes into one. */
name|regnode
modifier|*
name|n
init|=
name|regnext
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|U32
name|stringok
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|regnode
modifier|*
name|stop
init|=
name|scan
decl_stmt|;
endif|#
directive|endif
name|next
operator|=
name|scan
operator|+
name|NODE_SZ_STR
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Skip NOTHING, merge EXACT*. */
while|while
condition|(
name|n
operator|&&
operator|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
operator|||
operator|(
name|stringok
operator|&&
operator|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|OP
argument_list|(
name|scan
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|&&
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|<
name|I16_MAX
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|TAIL
operator|||
name|n
operator|>
name|next
condition|)
name|stringok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
condition|)
block|{
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|next
operator|=
name|n
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|stringok
condition|)
name|stop
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|regnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldl
init|=
name|STR_LEN
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|regnode
modifier|*
name|nnext
init|=
name|regnext
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldl
operator|+
name|STR_LEN
argument_list|(
name|n
argument_list|)
operator|>
name|U8_MAX
condition|)
break|break;
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|STR_LEN
argument_list|(
name|scan
argument_list|)
operator|+=
name|STR_LEN
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|next
operator|=
name|n
operator|+
name|NODE_SZ_STR
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Now we can overwrite *n : */
name|Move
argument_list|(
name|STRING
argument_list|(
name|n
argument_list|)
argument_list|,
name|STRING
argument_list|(
name|scan
argument_list|)
operator|+
name|oldl
argument_list|,
name|STR_LEN
argument_list|(
name|n
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|stringok
condition|)
name|stop
operator|=
name|next
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|nnext
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
comment|/* Allow dumping */
name|n
operator|=
name|scan
operator|+
name|NODE_SZ_STR
argument_list|(
name|scan
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|<=
name|stop
condition|)
block|{
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|!=
name|NOTHING
operator|||
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|NOTHING
condition|)
block|{
name|OP
argument_list|(
name|n
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Follow the next-chain of the current node and optimize 	   away all the NOTHINGs from it.  */
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|CURLYX
condition|)
block|{
name|int
name|max
init|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|?
name|I32_MAX
comment|/* I32 may be smaller than U16 on CRAYs! */
else|:
operator|(
name|I32_MAX
operator|<
name|U16_MAX
condition|?
name|I32_MAX
else|:
name|U16_MAX
operator|)
operator|)
decl_stmt|;
name|int
name|off
init|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|?
name|ARG
argument_list|(
name|scan
argument_list|)
else|:
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|)
decl_stmt|;
name|int
name|noff
decl_stmt|;
name|regnode
modifier|*
name|n
init|=
name|scan
decl_stmt|;
comment|/* Skip NOTHING and LONGJMP. */
while|while
condition|(
operator|(
name|n
operator|=
name|regnext
argument_list|(
name|n
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|n
argument_list|)
index|]
operator|==
name|NOTHING
operator|&&
operator|(
name|noff
operator|=
name|NEXT_OFF
argument_list|(
name|n
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|OP
argument_list|(
name|n
argument_list|)
operator|==
name|LONGJMP
operator|)
operator|&&
operator|(
name|noff
operator|=
name|ARG
argument_list|(
name|n
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|off
operator|+
name|noff
operator|<
name|max
condition|)
name|off
operator|+=
name|noff
expr_stmt|;
if|if
condition|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
name|ARG
argument_list|(
name|scan
argument_list|)
operator|=
name|off
expr_stmt|;
else|else
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|=
name|off
expr_stmt|;
block|}
comment|/* The principal pseudo-switch.  Cannot be a switch, since we 	   look into several different things.  */
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCHJ
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|IFTHEN
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SUSPEND
condition|)
block|{
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|code
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|code
operator|||
name|code
operator|==
name|IFTHEN
operator|||
name|code
operator|==
name|SUSPEND
condition|)
block|{
name|I32
name|max1
init|=
literal|0
decl_stmt|,
name|min1
init|=
name|I32_MAX
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
name|struct
name|regnode_charclass_class
name|accum
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
comment|/* XXXX Add !SUSPEND? */
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Cannot merge strings after this. */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
name|cl_init_zero
argument_list|(
operator|&
name|accum
argument_list|)
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|code
condition|)
block|{
name|I32
name|deltanext
decl_stmt|,
name|minnext
decl_stmt|,
name|f
init|=
literal|0
decl_stmt|;
name|struct
name|regnode_charclass_class
name|this_class
decl_stmt|;
name|num
operator|++
expr_stmt|;
name|data_fake
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|data_fake
operator|.
name|whilem_c
operator|=
name|data
operator|->
name|whilem_c
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|BRANCH
condition|)
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
block|{
name|cl_init
argument_list|(
operator|&
name|this_class
argument_list|)
expr_stmt|;
name|data_fake
operator|.
name|start_class
operator|=
operator|&
name|this_class
expr_stmt|;
name|f
operator|=
name|SCF_DO_STCLASS_AND
expr_stmt|;
block|}
comment|/* we suppose the run is continuous, last=next...*/
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|next
argument_list|,
operator|&
name|data_fake
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|min1
operator|>
name|minnext
condition|)
name|min1
operator|=
name|minnext
expr_stmt|;
if|if
condition|(
name|max1
operator|<
name|minnext
operator|+
name|deltanext
condition|)
name|max1
operator|=
name|minnext
operator|+
name|deltanext
expr_stmt|;
if|if
condition|(
name|deltanext
operator|==
name|I32_MAX
condition|)
name|is_inf
operator|=
name|is_inf_internal
operator|=
literal|1
expr_stmt|;
name|scan
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|data_fake
operator|.
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|data_fake
operator|.
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|data
operator|->
name|whilem_c
operator|=
name|data_fake
operator|.
name|whilem_c
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
name|cl_or
argument_list|(
operator|&
name|accum
argument_list|,
operator|&
name|this_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUSPEND
condition|)
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|IFTHEN
operator|&&
name|num
operator|<
literal|2
condition|)
comment|/* Empty ELSE branch */
name|min1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|data
operator|->
name|pos_min
operator|+=
name|min1
expr_stmt|;
name|data
operator|->
name|pos_delta
operator|+=
name|max1
operator|-
name|min1
expr_stmt|;
if|if
condition|(
name|max1
operator|!=
name|min1
operator|||
name|is_inf
condition|)
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|min
operator|+=
name|min1
expr_stmt|;
name|delta
operator|+=
name|max1
operator|-
name|min1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
name|cl_or
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|accum
argument_list|)
expr_stmt|;
if|if
condition|(
name|min1
condition|)
block|{
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
name|min1
condition|)
block|{
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|accum
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
else|else
block|{
comment|/* Switch to OR mode: cache the old value of  			 * data->start_class */
name|StructCopy
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS_AND
expr_stmt|;
name|StructCopy
argument_list|(
operator|&
name|accum
argument_list|,
name|data
operator|->
name|start_class
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|flags
operator||=
name|SCF_DO_STCLASS_OR
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_EOS
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|BRANCHJ
condition|)
comment|/* single branch is optimized. */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* single branch is optimized. */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACT
condition|)
block|{
name|I32
name|l
init|=
name|STR_LEN
argument_list|(
name|scan
argument_list|)
decl_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|STRING
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|l
decl_stmt|;
name|I32
name|newl
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
name|newl
operator|++
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|newl
expr_stmt|;
block|}
name|min
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
comment|/* Update longest substr. */
comment|/* The code below prefers earlier match for fixed 		   offset, later match for variable offset.  */
if|if
condition|(
name|data
operator|->
name|last_end
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Update the start info. */
name|data
operator|->
name|last_start_min
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|last_start_max
operator|=
name|is_inf
condition|?
name|I32_MAX
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
expr_stmt|;
block|}
name|sv_catpvn
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|,
name|STR_LEN
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
name|data
operator|->
name|pos_min
operator|+
name|l
expr_stmt|;
name|data
operator|->
name|pos_min
operator|+=
name|l
expr_stmt|;
comment|/* As in the first entry. */
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_BEFORE_EOL
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
comment|/* Check whether it is compatible with what we know already! */
name|int
name|compat
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
operator|(
name|ANYOF_CLASS
operator||
name|ANYOF_LOCALE
operator|)
operator|)
operator|&&
operator|!
name|ANYOF_BITMAP_TEST
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_FOLD
operator|)
operator|||
operator|!
name|ANYOF_BITMAP_TEST
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|PL_fold
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|STRING
argument_list|(
name|scan
argument_list|)
index|]
argument_list|)
operator|)
condition|)
name|compat
operator|=
literal|0
expr_stmt|;
name|ANYOF_CLASS_ZERO
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
name|ANYOF_BITMAP_ZERO
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
comment|/* false positive possible if the class is case-folded */
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
block|}
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
comment|/* But OP != EXACT! */
name|I32
name|l
init|=
name|STR_LEN
argument_list|(
name|scan
argument_list|)
decl_stmt|;
comment|/* Search for fixed substrings supports EXACT only. */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|STRING
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|l
decl_stmt|;
name|I32
name|newl
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
name|newl
operator|++
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|newl
expr_stmt|;
block|}
name|min
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|)
condition|)
name|data
operator|->
name|pos_min
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
comment|/* Check whether it is compatible with what we know already! */
name|int
name|compat
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
operator|(
name|ANYOF_CLASS
operator||
name|ANYOF_LOCALE
operator|)
operator|)
operator|&&
operator|!
name|ANYOF_BITMAP_TEST
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|&&
operator|!
name|ANYOF_BITMAP_TEST
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|PL_fold
index|[
operator|*
operator|(
name|U8
operator|*
operator|)
name|STRING
argument_list|(
name|scan
argument_list|)
index|]
argument_list|)
condition|)
name|compat
operator|=
literal|0
expr_stmt|;
name|ANYOF_CLASS_ZERO
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
name|ANYOF_BITMAP_ZERO
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
condition|)
block|{
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_FOLD
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTFL
condition|)
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_FOLD
condition|)
block|{
comment|/* false positive possible if the class is case-folded. 		       Assume that the locale settings are the same... */
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|*
name|STRING
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
block|}
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
block|}
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_varies
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
block|{
name|I32
name|mincount
decl_stmt|,
name|maxcount
decl_stmt|,
name|minnext
decl_stmt|,
name|deltanext
decl_stmt|,
name|pos_before
decl_stmt|,
name|fl
decl_stmt|;
name|I32
name|f
init|=
name|flags
decl_stmt|;
name|regnode
modifier|*
name|oscan
init|=
name|scan
decl_stmt|;
name|struct
name|regnode_charclass_class
name|this_class
decl_stmt|;
name|struct
name|regnode_charclass_class
modifier|*
name|oclass
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
block|{
case|case
name|WHILEM
case|:
comment|/* End of (?:...)* . */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|PLUS
case|:
if|if
condition|(
name|flags
operator|&
operator|(
name|SCF_DO_SUBSTR
operator||
name|SCF_DO_STCLASS
operator|)
condition|)
block|{
name|next
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACT
operator|||
operator|(
name|flags
operator|&
name|SCF_DO_STCLASS
operator|)
condition|)
block|{
name|mincount
operator|=
literal|1
expr_stmt|;
name|maxcount
operator|=
name|REG_INFTY
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
name|data
operator|->
name|pos_min
operator|++
expr_stmt|;
name|min
operator|++
expr_stmt|;
comment|/* Fall through. */
case|case
name|STAR
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
block|{
name|mincount
operator|=
literal|0
expr_stmt|;
name|maxcount
operator|=
name|REG_INFTY
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
name|is_inf
operator|=
name|is_inf_internal
operator|=
literal|1
expr_stmt|;
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Cannot extend fixed substrings */
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
goto|goto
name|optimize_curly_tail
goto|;
case|case
name|CURLY
case|:
name|mincount
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|maxcount
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
expr_stmt|;
name|do_curly
label|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
if|if
condition|(
name|mincount
operator|==
literal|0
condition|)
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Cannot extend fixed substrings */
name|pos_before
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
block|}
if|if
condition|(
name|data
condition|)
block|{
name|fl
operator|=
name|data
operator|->
name|flags
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator||
name|SF_HAS_EVAL
operator|)
expr_stmt|;
if|if
condition|(
name|is_inf
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_IS_INF
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
block|{
name|cl_init
argument_list|(
operator|&
name|this_class
argument_list|)
expr_stmt|;
name|oclass
operator|=
name|data
operator|->
name|start_class
expr_stmt|;
name|data
operator|->
name|start_class
operator|=
operator|&
name|this_class
expr_stmt|;
name|f
operator||=
name|SCF_DO_STCLASS_AND
expr_stmt|;
name|f
operator|&=
operator|~
name|SCF_DO_STCLASS_OR
expr_stmt|;
block|}
comment|/* This will finish on WHILEM, setting scan, or on NULL: */
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|last
argument_list|,
name|data
argument_list|,
name|mincount
operator|==
literal|0
condition|?
operator|(
name|f
operator|&
operator|~
name|SCF_DO_SUBSTR
operator|)
else|:
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
name|data
operator|->
name|start_class
operator|=
name|oclass
expr_stmt|;
if|if
condition|(
name|mincount
operator|==
literal|0
operator|||
name|minnext
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
name|cl_or
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|this_class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
comment|/* Switch to OR mode: cache the old value of  			 * data->start_class */
name|StructCopy
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS_AND
expr_stmt|;
name|StructCopy
argument_list|(
operator|&
name|this_class
argument_list|,
name|data
operator|->
name|start_class
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|flags
operator||=
name|SCF_DO_STCLASS_OR
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_EOS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Non-zero len */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
name|cl_or
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|this_class
argument_list|)
expr_stmt|;
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|this_class
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scan
condition|)
comment|/* It was not CURLYX, but CURLY. */
name|scan
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
operator|(
name|minnext
operator|+
name|deltanext
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
operator|)
operator|&&
name|maxcount
operator|<=
name|REG_INFTY
operator|/
literal|3
condition|)
comment|/* Complement check for big count */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"Strange *+?{} on zero-length expression"
argument_list|)
empty_stmt|;
name|min
operator|+=
name|minnext
operator|*
name|mincount
expr_stmt|;
name|is_inf_internal
operator||=
operator|(
operator|(
name|maxcount
operator|==
name|REG_INFTY
operator|&&
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|>
literal|0
operator|)
operator|||
name|deltanext
operator|==
name|I32_MAX
operator|)
expr_stmt|;
name|is_inf
operator||=
name|is_inf_internal
expr_stmt|;
name|delta
operator|+=
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|*
name|maxcount
operator|-
name|minnext
operator|*
name|mincount
expr_stmt|;
comment|/* Try powerful optimization CURLYX => CURLYN. */
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|==
name|CURLYX
operator|&&
name|data
operator|&&
name|data
operator|->
name|flags
operator|&
name|SF_IN_PAR
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
operator|&&
operator|!
name|deltanext
operator|&&
name|minnext
operator|==
literal|1
condition|)
block|{
comment|/* Try to optimize to CURLYN.  */
name|regnode
modifier|*
name|nxt
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
name|regnode
modifier|*
name|nxt1
init|=
name|nxt
decl_stmt|,
modifier|*
name|nxt2
decl_stmt|;
comment|/* Skip open. */
name|nxt
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_simple
argument_list|,
name|OP
argument_list|(
name|nxt
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|nxt
argument_list|)
index|]
operator|==
name|EXACT
operator|&&
name|STR_LEN
argument_list|(
name|nxt
argument_list|)
operator|==
literal|1
operator|)
condition|)
goto|goto
name|nogo
goto|;
name|nxt2
operator|=
name|nxt
expr_stmt|;
name|nxt
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|nxt
argument_list|)
operator|!=
name|CLOSE
condition|)
goto|goto
name|nogo
goto|;
comment|/* Now we know that nxt2 is the only contents: */
name|oscan
operator|->
name|flags
operator|=
name|ARG
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|oscan
argument_list|)
operator|=
name|CURLYN
expr_stmt|;
name|OP
argument_list|(
name|nxt1
argument_list|)
operator|=
name|NOTHING
expr_stmt|;
comment|/* was OPEN. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|OP
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
name|NEXT_OFF
argument_list|(
name|nxt2
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy with CURLY. */
name|OP
argument_list|(
name|nxt
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was CLOSE. */
name|OP
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
endif|#
directive|endif
block|}
name|nogo
label|:
comment|/* Try optimization CURLYX => CURLYM. */
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|==
name|CURLYX
operator|&&
name|data
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_PAR
operator|)
operator|&&
operator|!
operator|(
name|data
operator|->
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
operator|&&
operator|!
name|deltanext
condition|)
block|{
comment|/* XXXX How to optimize if data == 0? */
comment|/* Optimize to a simpler form.  */
name|regnode
modifier|*
name|nxt
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
comment|/* OPEN */
name|regnode
modifier|*
name|nxt2
decl_stmt|;
name|OP
argument_list|(
name|oscan
argument_list|)
operator|=
name|CURLYM
expr_stmt|;
while|while
condition|(
operator|(
name|nxt2
operator|=
name|regnext
argument_list|(
name|nxt
argument_list|)
operator|)
comment|/* skip over embedded stuff*/
operator|&&
operator|(
name|OP
argument_list|(
name|nxt2
argument_list|)
operator|!=
name|WHILEM
operator|)
condition|)
name|nxt
operator|=
name|nxt2
expr_stmt|;
name|OP
argument_list|(
name|nxt2
argument_list|)
operator|=
name|SUCCEED
expr_stmt|;
comment|/* Whas WHILEM */
comment|/* Need to optimize away parenths. */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SF_IN_PAR
condition|)
block|{
comment|/* Set the parenth number.  */
name|regnode
modifier|*
name|nxt1
init|=
name|NEXTOPER
argument_list|(
name|oscan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
decl_stmt|;
comment|/* OPEN*/
if|if
condition|(
name|OP
argument_list|(
name|nxt
argument_list|)
operator|!=
name|CLOSE
condition|)
name|FAIL
argument_list|(
literal|"panic opt close"
argument_list|)
expr_stmt|;
name|oscan
operator|->
name|flags
operator|=
name|ARG
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|nxt1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was OPEN. */
name|OP
argument_list|(
name|nxt
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was CLOSE. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|OP
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|OP
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
name|OPTIMIZED
expr_stmt|;
comment|/* was count. */
name|NEXT_OFF
argument_list|(
name|nxt1
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
name|NEXT_OFF
argument_list|(
name|nxt
operator|+
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* just for consistancy. */
endif|#
directive|endif
if|#
directive|if
literal|0
block|while ( nxt1&& (OP(nxt1) != WHILEM)) { 			    regnode *nnxt = regnext(nxt1); 			     			    if (nnxt == nxt) { 				if (reg_off_by_arg[OP(nxt1)]) 				    ARG_SET(nxt1, nxt2 - nxt1); 				else if (nxt2 - nxt1< U16_MAX) 				    NEXT_OFF(nxt1) = nxt2 - nxt1; 				else 				    OP(nxt) = NOTHING;
comment|/* Cannot beautify */
block|} 			    nxt1 = nnxt; 			}
endif|#
directive|endif
comment|/* Optimize again: */
name|study_chunk
argument_list|(
operator|&
name|nxt1
argument_list|,
operator|&
name|deltanext
argument_list|,
name|nxt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|oscan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|==
name|CURLYX
operator|&&
name|data
operator|&&
operator|++
name|data
operator|->
name|whilem_c
operator|<
literal|16
condition|)
block|{
comment|/* This stays as CURLYX, and can put the count/of pair. */
comment|/* Find WHILEM (as in regexec.c) */
name|regnode
modifier|*
name|nxt
init|=
name|oscan
operator|+
name|NEXT_OFF
argument_list|(
name|oscan
argument_list|)
decl_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|PREVOPER
argument_list|(
name|nxt
argument_list|)
argument_list|)
operator|==
name|NOTHING
condition|)
comment|/* LONGJMP */
name|nxt
operator|+=
name|ARG
argument_list|(
name|nxt
argument_list|)
expr_stmt|;
name|PREVOPER
argument_list|(
name|nxt
argument_list|)
operator|->
name|flags
operator|=
name|data
operator|->
name|whilem_c
operator||
operator|(
name|PL_reg_whilem_seen
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* On WHILEM */
block|}
if|if
condition|(
name|data
operator|&&
name|fl
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|SV
modifier|*
name|last_str
init|=
name|Nullsv
decl_stmt|;
name|int
name|counted
init|=
name|mincount
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|last_end
operator|>
literal|0
operator|&&
name|mincount
operator|!=
literal|0
condition|)
block|{
comment|/* Ends with a string. */
name|I32
name|b
init|=
name|pos_before
operator|>=
name|data
operator|->
name|last_start_min
condition|?
name|pos_before
else|:
name|data
operator|->
name|last_start_min
decl_stmt|;
name|STRLEN
name|l
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|SvPV
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|I32
name|old
init|=
name|b
operator|-
name|data
operator|->
name|last_start_min
decl_stmt|;
if|if
condition|(
name|UTF
condition|)
name|old
operator|=
name|utf8_hop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
name|old
argument_list|)
operator|-
operator|(
name|U8
operator|*
operator|)
name|s
expr_stmt|;
name|l
operator|-=
name|old
expr_stmt|;
comment|/* Get the added string: */
name|last_str
operator|=
name|newSVpvn
argument_list|(
name|s
operator|+
name|old
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltanext
operator|==
literal|0
operator|&&
name|pos_before
operator|==
name|b
condition|)
block|{
comment|/* What was added is a constant string */
if|if
condition|(
name|mincount
operator|>
literal|1
condition|)
block|{
name|SvGROW
argument_list|(
name|last_str
argument_list|,
operator|(
name|mincount
operator|*
name|l
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|SvPVX
argument_list|(
name|last_str
argument_list|)
operator|+
name|l
argument_list|,
name|SvPVX
argument_list|(
name|last_str
argument_list|)
argument_list|,
name|l
argument_list|,
name|mincount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|last_str
argument_list|)
operator|*=
name|mincount
expr_stmt|;
comment|/* Add additional parts. */
name|SvCUR_set
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|SvCUR
argument_list|(
name|data
operator|->
name|last_found
argument_list|)
operator|-
name|l
argument_list|)
expr_stmt|;
name|sv_catsv
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|+=
name|l
operator|*
operator|(
name|mincount
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* It is counted once already... */
name|data
operator|->
name|pos_min
operator|+=
name|minnext
operator|*
operator|(
name|mincount
operator|-
name|counted
operator|)
expr_stmt|;
name|data
operator|->
name|pos_delta
operator|+=
operator|-
name|counted
operator|*
name|deltanext
operator|+
operator|(
name|minnext
operator|+
name|deltanext
operator|)
operator|*
name|maxcount
operator|-
name|minnext
operator|*
name|mincount
expr_stmt|;
if|if
condition|(
name|mincount
operator|!=
name|maxcount
condition|)
block|{
comment|/* Cannot extend fixed substrings found inside 			    the group.  */
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|mincount
operator|&&
name|last_str
condition|)
block|{
name|sv_setsv
argument_list|(
name|data
operator|->
name|last_found
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_end
operator|=
name|data
operator|->
name|pos_min
expr_stmt|;
name|data
operator|->
name|last_start_min
operator|=
name|data
operator|->
name|pos_min
operator|-
name|CHR_SVLEN
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
name|data
operator|->
name|last_start_max
operator|=
name|is_inf
condition|?
name|I32_MAX
else|:
name|data
operator|->
name|pos_min
operator|+
name|data
operator|->
name|pos_delta
operator|-
name|CHR_SVLEN
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|SvREFCNT_dec
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|&&
operator|(
name|fl
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
name|optimize_curly_tail
label|:
if|if
condition|(
name|OP
argument_list|(
name|oscan
argument_list|)
operator|!=
name|CURLYX
condition|)
block|{
while|while
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
operator|=
name|regnext
argument_list|(
name|oscan
argument_list|)
argument_list|)
index|]
operator|==
name|NOTHING
operator|&&
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
condition|)
name|NEXT_OFF
argument_list|(
name|oscan
argument_list|)
operator|+=
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
comment|/* REF and CLUMP only? */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Cannot expect anything... */
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|is_inf
operator|=
name|is_inf_internal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
name|cl_anything
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_simple
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|||
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|ANYUTF8
condition|)
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|pos_min
operator|++
expr_stmt|;
block|}
name|min
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
condition|)
block|{
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&=
operator|~
name|ANYOF_EOS
expr_stmt|;
comment|/* No match on empty */
comment|/* Some of the logic below assumes that switching 		   locale on will only add false positives. */
switch|switch
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
block|{
case|case
name|ANYUTF8
case|:
case|case
name|SANY
case|:
case|case
name|SANYUTF8
case|:
case|case
name|ALNUMUTF8
case|:
case|case
name|ANYOFUTF8
case|:
case|case
name|ALNUMLUTF8
case|:
case|case
name|NALNUMUTF8
case|:
case|case
name|NALNUMLUTF8
case|:
case|case
name|SPACEUTF8
case|:
case|case
name|NSPACEUTF8
case|:
case|case
name|SPACELUTF8
case|:
case|case
name|NSPACELUTF8
case|:
case|case
name|DIGITUTF8
case|:
case|case
name|NDIGITUTF8
case|:
default|default:
name|do_default
label|:
comment|/* Perl_croak(aTHX_ "panic: unexpected simple REx opcode %d", OP(scan)); */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
comment|/* Allow everything */
name|cl_anything
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_ANY
case|:
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SANY
condition|)
goto|goto
name|do_default
goto|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
block|{
comment|/* Everything but \n */
name|value
operator|=
operator|(
name|ANYOF_BITMAP_TEST
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
literal|'\n'
argument_list|)
operator|||
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_CLASS
operator|)
operator|)
expr_stmt|;
name|cl_anything
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
operator|||
operator|!
name|value
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|(
expr|struct
name|regnode_charclass_class
operator|*
operator|)
name|scan
argument_list|)
expr_stmt|;
else|else
name|cl_or
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|(
expr|struct
name|regnode_charclass_class
operator|*
operator|)
name|scan
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NALNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_ALNUM
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ALNUML
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NALNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_ALNUM
argument_list|)
expr_stmt|;
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
break|break;
case|case
name|NALNUM
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_ALNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NALNUM
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NALNUML
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_ALNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NALNUM
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPACE
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NSPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_SPACE
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SPACEL
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NSPACE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_SPACE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NSPACE
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
operator|)
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_SPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NSPACE
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NSPACEL
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_SPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NSPACE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIGIT
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NDIGIT
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_DIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NDIGIT
case|:
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_AND
condition|)
block|{
name|ANYOF_CLASS_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_DIGIT
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_CLEAR
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|ANYOF_NDIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|EOL
operator|&&
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|data
operator|->
name|flags
operator||=
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|MEOL
condition|?
name|SF_BEFORE_MEOL
else|:
name|SF_BEFORE_SEOL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|scan
argument_list|)
index|]
operator|==
name|BRANCHJ
comment|/* Lookbehind, or need to calculate parens/evals/stclass: */
operator|&&
operator|(
name|scan
operator|->
name|flags
operator|||
name|data
operator|||
operator|(
name|flags
operator|&
name|SCF_DO_STCLASS
operator|)
operator|)
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|IFMATCH
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|UNLESSM
operator|)
condition|)
block|{
comment|/* Lookahead/lookbehind */
name|I32
name|deltanext
decl_stmt|,
name|minnext
decl_stmt|;
name|regnode
modifier|*
name|nscan
decl_stmt|;
name|struct
name|regnode_charclass_class
name|intrnl
decl_stmt|;
name|int
name|f
init|=
literal|0
decl_stmt|;
name|data_fake
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|data_fake
operator|.
name|whilem_c
operator|=
name|data
operator|->
name|whilem_c
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS
operator|&&
operator|!
name|scan
operator|->
name|flags
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|IFMATCH
condition|)
block|{
comment|/* Lookahead */
name|cl_init
argument_list|(
operator|&
name|intrnl
argument_list|)
expr_stmt|;
name|data_fake
operator|.
name|start_class
operator|=
operator|&
name|intrnl
expr_stmt|;
name|f
operator|=
name|SCF_DO_STCLASS_AND
expr_stmt|;
block|}
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|nscan
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|minnext
operator|=
name|study_chunk
argument_list|(
operator|&
name|nscan
argument_list|,
operator|&
name|deltanext
argument_list|,
name|last
argument_list|,
operator|&
name|data_fake
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|deltanext
condition|)
block|{
name|FAIL
argument_list|(
literal|"variable length lookbehind not implemented"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minnext
operator|>
name|U8_MAX
condition|)
block|{
name|FAIL2
argument_list|(
literal|"lookbehind longer than %"
name|UVuf
literal|" not implemented"
argument_list|,
operator|(
name|UV
operator|)
name|U8_MAX
argument_list|)
expr_stmt|;
block|}
name|scan
operator|->
name|flags
operator|=
name|minnext
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|&&
name|data_fake
operator|.
name|flags
operator|&
operator|(
name|SF_HAS_PAR
operator||
name|SF_IN_PAR
operator|)
condition|)
name|pars
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|&&
operator|(
name|data_fake
operator|.
name|flags
operator|&
name|SF_HAS_EVAL
operator|)
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|data
operator|->
name|whilem_c
operator|=
name|data_fake
operator|.
name|whilem_c
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|int
name|was
init|=
operator|(
name|data
operator|->
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_EOS
operator|)
decl_stmt|;
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|intrnl
argument_list|)
expr_stmt|;
if|if
condition|(
name|was
condition|)
name|data
operator|->
name|start_class
operator|->
name|flags
operator||=
name|ANYOF_EOS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|OPEN
condition|)
block|{
name|pars
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|CLOSE
operator|&&
name|ARG
argument_list|(
name|scan
argument_list|)
operator|==
name|is_par
condition|)
block|{
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
operator|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|WHILEM
operator|)
operator|&&
name|next
operator|<
name|last
condition|)
name|is_par
operator|=
literal|0
expr_stmt|;
comment|/* Disable optimization */
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EVAL
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|data
operator|->
name|flags
operator||=
name|SF_HAS_EVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|LOGICAL
operator|&&
name|scan
operator|->
name|flags
operator|==
literal|2
condition|)
block|{
comment|/* Embedded follows */
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
condition|)
block|{
name|scan_commit
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|longest
operator|=
operator|&
operator|(
name|data
operator|->
name|longest_float
operator|)
expr_stmt|;
block|}
name|is_inf
operator|=
name|is_inf_internal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
comment|/* Allow everything */
name|cl_anything
argument_list|(
name|data
operator|->
name|start_class
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|SCF_DO_STCLASS
expr_stmt|;
block|}
comment|/* Else: zero-length, ignore. */
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
operator|*
name|scanp
operator|=
name|scan
expr_stmt|;
operator|*
name|deltap
operator|=
name|is_inf_internal
condition|?
name|I32_MAX
else|:
name|delta
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCF_DO_SUBSTR
operator|&&
name|is_inf
condition|)
name|data
operator|->
name|pos_delta
operator|=
name|I32_MAX
operator|-
name|data
operator|->
name|pos_min
expr_stmt|;
if|if
condition|(
name|is_par
operator|>
name|U8_MAX
condition|)
name|is_par
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_par
operator|&&
name|pars
operator|==
literal|1
operator|&&
name|data
condition|)
block|{
name|data
operator|->
name|flags
operator||=
name|SF_IN_PAR
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_HAS_PAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pars
operator|&&
name|data
condition|)
block|{
name|data
operator|->
name|flags
operator||=
name|SF_HAS_PAR
expr_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|SF_IN_PAR
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCF_DO_STCLASS_OR
condition|)
name|cl_and
argument_list|(
name|data
operator|->
name|start_class
argument_list|,
operator|&
name|and_with
argument_list|)
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_function
name|STATIC
name|I32
name|S_add_data
parameter_list|(
name|pTHX_
name|I32
name|n
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_regcomp_rx
operator|->
name|data
condition|)
block|{
name|Renewc
argument_list|(
name|PL_regcomp_rx
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|PL_regcomp_rx
operator|->
name|data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+
name|n
operator|-
literal|1
operator|)
argument_list|,
name|char
argument_list|,
expr|struct
name|reg_data
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|Newc
argument_list|(
literal|1207
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|PL_regcomp_rx
operator|->
name|data
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
argument_list|,
name|char
argument_list|,
expr|struct
name|reg_data
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|1208
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
argument_list|,
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|=
name|n
expr_stmt|;
block|}
name|Copy
argument_list|(
name|s
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|what
operator|+
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|-
name|n
argument_list|,
name|n
argument_list|,
name|U8
argument_list|)
expr_stmt|;
return|return
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|count
operator|-
name|n
return|;
block|}
end_function

begin_function
name|void
name|Perl_reginitcolors
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_RE_COLORS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|PL_colors
index|[
literal|0
index|]
operator|=
name|s
operator|=
name|savepv
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
literal|6
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|PL_colors
index|[
name|i
index|]
operator|=
operator|++
name|s
expr_stmt|;
block|}
else|else
name|PL_colors
index|[
name|i
index|]
operator|=
name|s
operator|=
literal|""
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|i
operator|<
literal|6
condition|)
name|PL_colors
index|[
name|i
operator|++
index|]
operator|=
literal|""
expr_stmt|;
block|}
name|PL_colorset
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - pregcomp - compile a regular expression into internal code  *  * We can't allocate space until we know how big the compiled form will be,  * but we can't compile it (and thus know how big it is) until we've got a  * place to put the code.  So we cheat:  we compile it twice, once with code  * generation turned off and size counting turned on, and once "for real".  * This also means that we don't allocate space until we are sure that the  * thing really will compile successfully, and we never have to move the  * code and thus invalidate pointers into it.  (Note that it has to be in  * one piece because free() must be able to free it all.) [NB: not true in perl]  *  * Beware that the optimization-preparation code in here knows about some  * of the structure of the compiled regexp.  [I'll say.]  */
end_comment

begin_function
name|regexp
modifier|*
name|Perl_pregcomp
parameter_list|(
name|pTHX_
name|char
modifier|*
name|exp
parameter_list|,
name|char
modifier|*
name|xend
parameter_list|,
name|PMOP
modifier|*
name|pm
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regexp
modifier|*
name|r
decl_stmt|;
name|regnode
modifier|*
name|scan
decl_stmt|;
name|regnode
modifier|*
name|first
decl_stmt|;
name|I32
name|flags
decl_stmt|;
name|I32
name|minlen
init|=
literal|0
decl_stmt|;
name|I32
name|sawplus
init|=
literal|0
decl_stmt|;
name|I32
name|sawopen
init|=
literal|0
decl_stmt|;
name|scan_data_t
name|data
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"NULL regexp argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|op_pmdynflags
operator|&
name|PMdf_UTF8
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_utf8
expr_stmt|;
block|}
else|else
name|PL_reg_flags
operator|=
literal|0
expr_stmt|;
name|PL_regprecomp
operator|=
name|savepvn
argument_list|(
name|exp
argument_list|,
name|xend
operator|-
name|exp
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|if (!PL_colorset) reginitcolors()
argument_list|)
empty_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sCompiling REx%s `%s%*s%s'\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|xend
operator|-
name|exp
argument_list|)
argument_list|,
name|PL_regprecomp
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PL_regflags
operator|=
name|pm
operator|->
name|op_pmflags
expr_stmt|;
name|PL_regsawback
operator|=
literal|0
expr_stmt|;
name|PL_regseen
operator|=
literal|0
expr_stmt|;
name|PL_seen_zerolen
operator|=
operator|*
name|exp
operator|==
literal|'^'
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|PL_seen_evals
operator|=
literal|0
expr_stmt|;
name|PL_extralen
operator|=
literal|0
expr_stmt|;
comment|/* First pass: determine size, legality. */
name|PL_regcomp_parse
operator|=
name|exp
expr_stmt|;
name|PL_regxend
operator|=
name|xend
expr_stmt|;
name|PL_regnaughty
operator|=
literal|0
expr_stmt|;
name|PL_regnpar
operator|=
literal|1
expr_stmt|;
name|PL_regsize
operator|=
literal|0L
expr_stmt|;
name|PL_regcode
operator|=
operator|&
name|PL_regdummy
expr_stmt|;
name|PL_reg_whilem_seen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* REGC() is (currently) a NOP at the first pass.        * Clever compilers notice this and complain. --jhi */
block|REGC((U8)REG_MAGIC, (char*)PL_regcode);
endif|#
directive|endif
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Safefree
argument_list|(
name|PL_regprecomp
argument_list|)
expr_stmt|;
name|PL_regprecomp
operator|=
name|Nullch
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"size %"
name|IVdf
literal|" "
argument_list|,
operator|(
name|IV
operator|)
name|PL_regsize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Small enough for pointer-storage convention?        If extralen==0, this means that we will not need long jumps. */
if|if
condition|(
name|PL_regsize
operator|>=
literal|0x10000L
operator|&&
name|PL_extralen
condition|)
name|PL_regsize
operator|+=
name|PL_extralen
expr_stmt|;
else|else
name|PL_extralen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_reg_whilem_seen
operator|>
literal|15
condition|)
name|PL_reg_whilem_seen
operator|=
literal|15
expr_stmt|;
comment|/* Allocate space and initialize. */
name|Newc
argument_list|(
literal|1001
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|PL_regsize
operator|*
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
argument_list|,
name|char
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"regexp out of space"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
comment|/* avoid reading uninitialized memory in DEBUGGING code in study_chunk() */
name|Zero
argument_list|(
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|PL_regsize
operator|*
sizeof|sizeof
argument_list|(
name|regnode
argument_list|)
argument_list|,
name|char
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|prelen
operator|=
name|xend
operator|-
name|exp
expr_stmt|;
name|r
operator|->
name|precomp
operator|=
name|PL_regprecomp
expr_stmt|;
name|r
operator|->
name|subbeg
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|reganch
operator|=
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_COMPILETIME
expr_stmt|;
name|r
operator|->
name|nparens
operator|=
name|PL_regnpar
operator|-
literal|1
expr_stmt|;
comment|/* set early to validate backrefs */
name|r
operator|->
name|substrs
operator|=
literal|0
expr_stmt|;
comment|/* Useful during FAIL. */
name|r
operator|->
name|startp
operator|=
literal|0
expr_stmt|;
comment|/* Useful during FAIL. */
name|r
operator|->
name|endp
operator|=
literal|0
expr_stmt|;
comment|/* Useful during FAIL. */
name|PL_regcomp_rx
operator|=
name|r
expr_stmt|;
comment|/* Second pass: emit code. */
name|PL_regcomp_parse
operator|=
name|exp
expr_stmt|;
name|PL_regxend
operator|=
name|xend
expr_stmt|;
name|PL_regnaughty
operator|=
literal|0
expr_stmt|;
name|PL_regnpar
operator|=
literal|1
expr_stmt|;
name|PL_regcode
operator|=
name|r
operator|->
name|program
expr_stmt|;
comment|/* Store the count of eval-groups for security checks: */
name|PL_regcode
operator|->
name|next_off
operator|=
operator|(
operator|(
name|PL_seen_evals
operator|>
name|U16_MAX
operator|)
condition|?
name|U16_MAX
else|:
name|PL_seen_evals
operator|)
expr_stmt|;
name|REGC
argument_list|(
operator|(
name|U8
operator|)
name|REG_MAGIC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PL_regcode
operator|++
argument_list|)
expr_stmt|;
name|r
operator|->
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Dig out information for optimizations. */
name|r
operator|->
name|reganch
operator|=
name|pm
operator|->
name|op_pmflags
operator|&
name|PMf_COMPILETIME
expr_stmt|;
comment|/* Again? */
name|pm
operator|->
name|op_pmflags
operator|=
name|PL_regflags
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_UTF8
expr_stmt|;
name|r
operator|->
name|regstclass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|PL_regnaughty
operator|>=
literal|10
condition|)
comment|/* Probably an expensive pattern. */
name|r
operator|->
name|reganch
operator||=
name|ROPT_NAUGHTY
expr_stmt|;
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
comment|/* First BRANCH. */
comment|/* XXXX To minimize changes to RE engine we always allocate        3-units-long substrs field. */
name|Newz
argument_list|(
literal|1004
argument_list|,
name|r
operator|->
name|substrs
argument_list|,
literal|1
argument_list|,
expr|struct
name|reg_substr_data
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
operator|&
name|zero_scan_data
argument_list|,
operator|&
name|data
argument_list|,
name|scan_data_t
argument_list|)
expr_stmt|;
comment|/* XXXX Should not we check for something else?  Usually it is OPEN1... */
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|BRANCH
condition|)
block|{
comment|/* Only one top-level choice. */
name|I32
name|fake
decl_stmt|;
name|STRLEN
name|longest_float_length
decl_stmt|,
name|longest_fixed_length
decl_stmt|;
name|struct
name|regnode_charclass_class
name|ch_class
decl_stmt|;
name|int
name|stclass_flag
decl_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
comment|/* Skip introductions and multiplicators>= 1. */
while|while
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|OPEN
operator|&&
operator|(
name|sawopen
operator|=
literal|1
operator|)
operator|)
operator|||
comment|/* An OR of *one* alternative - should not happen now. */
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|BRANCH
operator|&&
name|OP
argument_list|(
name|regnext
argument_list|(
name|first
argument_list|)
argument_list|)
operator|!=
name|BRANCH
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|MINMOD
operator|)
operator|||
comment|/* An {n,m} with n>0 */
operator|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|CURLY
operator|&&
name|ARG1
argument_list|(
name|first
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
condition|)
name|sawplus
operator|=
literal|1
expr_stmt|;
else|else
name|first
operator|+=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Starting-point info. */
name|again
label|:
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EXACT
condition|)
empty_stmt|;
comment|/* Empty, get anchored substr later. */
elseif|else
if|if
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EXACTF
operator|||
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EXACTFL
operator|)
operator|&&
operator|!
name|UTF
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_simple
argument_list|,
name|OP
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|BOUND
operator|||
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|NBOUND
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|first
argument_list|)
index|]
operator|==
name|BOL
condition|)
block|{
name|r
operator|->
name|reganch
operator||=
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|MBOL
condition|?
name|ROPT_ANCH_MBOL
else|:
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|SBOL
condition|?
name|ROPT_ANCH_SBOL
else|:
name|ROPT_ANCH_BOL
operator|)
operator|)
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|GPOS
condition|)
block|{
name|r
operator|->
name|reganch
operator||=
name|ROPT_ANCH_GPOS
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|STAR
operator|&&
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|first
argument_list|)
argument_list|)
index|]
operator|==
name|REG_ANY
operator|)
operator|&&
operator|!
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
comment|/* turn .* into ^.* with an implied $*=1 */
name|int
name|type
init|=
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|first
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|REG_ANY
operator|||
name|type
operator|==
name|ANYUTF8
condition|)
name|type
operator|=
name|ROPT_ANCH_MBOL
expr_stmt|;
else|else
name|type
operator|=
name|ROPT_ANCH_SBOL
expr_stmt|;
name|r
operator|->
name|reganch
operator||=
name|type
operator||
name|ROPT_IMPLICIT
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|sawplus
operator|&&
operator|(
operator|!
name|sawopen
operator|||
operator|!
name|PL_regsawback
operator|)
operator|&&
operator|!
operator|(
name|PL_regseen
operator|&
name|REG_SEEN_EVAL
operator|)
condition|)
comment|/* May examine pos and $& */
comment|/* x+ must match at the 1st pos of run of x's */
name|r
operator|->
name|reganch
operator||=
name|ROPT_SKIP
expr_stmt|;
comment|/* Scan is after the zeroth branch, first is atomic matcher. */
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"first at %"
name|IVdf
literal|"\n"
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|first
operator|-
name|scan
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	* If there's something expensive in the r.e., find the 	* longest literal string that must appear and make it the 	* regmust.  Resolve ties in favor of later strings, since 	* the regstart check works with the beginning of the r.e. 	* and avoiding duplication strengthens checking.  Not a 	* strong reason, but sufficient in the absence of others. 	* [Now we resolve ties in favor of the earlier string if 	* it happens that c_offset_min has been invalidated, since the 	* earlier string may buy us something the later one won't.] 	*/
name|minlen
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|longest_fixed
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|longest_float
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|last_found
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|longest
operator|=
operator|&
operator|(
name|data
operator|.
name|longest_fixed
operator|)
expr_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|regstclass
condition|)
block|{
name|cl_init
argument_list|(
operator|&
name|ch_class
argument_list|)
expr_stmt|;
name|data
operator|.
name|start_class
operator|=
operator|&
name|ch_class
expr_stmt|;
name|stclass_flag
operator|=
name|SCF_DO_STCLASS_AND
expr_stmt|;
block|}
else|else
comment|/* XXXX Check for BOUND? */
name|stclass_flag
operator|=
literal|0
expr_stmt|;
name|minlen
operator|=
name|study_chunk
argument_list|(
operator|&
name|first
argument_list|,
operator|&
name|fake
argument_list|,
name|scan
operator|+
name|PL_regsize
argument_list|,
comment|/* Up to end */
operator|&
name|data
argument_list|,
name|SCF_DO_SUBSTR
operator||
name|stclass_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_regnpar
operator|==
literal|1
operator|&&
name|data
operator|.
name|longest
operator|==
operator|&
operator|(
name|data
operator|.
name|longest_fixed
operator|)
operator|&&
name|data
operator|.
name|last_start_min
operator|==
literal|0
operator|&&
name|data
operator|.
name|last_end
operator|>
literal|0
operator|&&
operator|!
name|PL_seen_zerolen
operator|&&
operator|(
operator|!
operator|(
name|PL_regseen
operator|&
name|REG_SEEN_GPOS
operator|)
operator|||
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
operator|)
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_CHECK_ALL
expr_stmt|;
name|scan_commit
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|last_found
argument_list|)
expr_stmt|;
name|longest_float_length
operator|=
name|CHR_SVLEN
argument_list|(
name|data
operator|.
name|longest_float
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_float_length
operator|||
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_EOL
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
comment|/* ok to leave SvCUR */
operator|&&
name|data
operator|.
name|offset_fixed
operator|==
name|data
operator|.
name|offset_float_min
operator|&&
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
operator|==
name|SvCUR
argument_list|(
name|data
operator|.
name|longest_float
argument_list|)
condition|)
goto|goto
name|remove_float
goto|;
comment|/* As in (a)+. */
name|r
operator|->
name|float_substr
operator|=
name|data
operator|.
name|longest_float
expr_stmt|;
name|r
operator|->
name|float_min_offset
operator|=
name|data
operator|.
name|offset_float_min
expr_stmt|;
name|r
operator|->
name|float_max_offset
operator|=
name|data
operator|.
name|offset_float_max
expr_stmt|;
name|t
operator|=
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_EOL
comment|/* Can't have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FL_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
expr_stmt|;
name|fbm_compile
argument_list|(
name|r
operator|->
name|float_substr
argument_list|,
name|t
condition|?
name|FBMcf_TAIL
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remove_float
label|:
name|r
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|longest_float
argument_list|)
expr_stmt|;
name|longest_float_length
operator|=
literal|0
expr_stmt|;
block|}
name|longest_fixed_length
operator|=
name|CHR_SVLEN
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_fixed_length
operator|||
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_EOL
comment|/* Cannot have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|t
decl_stmt|;
name|r
operator|->
name|anchored_substr
operator|=
name|data
operator|.
name|longest_fixed
expr_stmt|;
name|r
operator|->
name|anchored_offset
operator|=
name|data
operator|.
name|offset_fixed
expr_stmt|;
name|t
operator|=
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_EOL
comment|/* Can't have SEOL and MULTI */
operator|&&
operator|(
operator|!
operator|(
name|data
operator|.
name|flags
operator|&
name|SF_FIX_BEFORE_MEOL
operator|)
operator|||
operator|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
operator|)
operator|)
operator|)
expr_stmt|;
name|fbm_compile
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|,
name|t
condition|?
name|FBMcf_TAIL
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|anchored_substr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|data
operator|.
name|longest_fixed
argument_list|)
expr_stmt|;
name|longest_fixed_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|regstclass
operator|&&
operator|(
name|OP
argument_list|(
name|r
operator|->
name|regstclass
argument_list|)
operator|==
name|REG_ANY
operator|||
name|OP
argument_list|(
name|r
operator|->
name|regstclass
argument_list|)
operator|==
name|ANYUTF8
operator|||
name|OP
argument_list|(
name|r
operator|->
name|regstclass
argument_list|)
operator|==
name|SANYUTF8
operator|||
name|OP
argument_list|(
name|r
operator|->
name|regstclass
argument_list|)
operator|==
name|SANY
operator|)
condition|)
name|r
operator|->
name|regstclass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|r
operator|->
name|anchored_substr
operator|||
name|r
operator|->
name|anchored_offset
operator|)
operator|&&
name|stclass_flag
operator|&&
operator|!
operator|(
name|data
operator|.
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_EOS
operator|)
operator|&&
operator|!
name|cl_is_anything
argument_list|(
name|data
operator|.
name|start_class
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|n
init|=
name|add_data
argument_list|(
literal|1
argument_list|,
literal|"f"
argument_list|)
decl_stmt|;
name|New
argument_list|(
literal|1006
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|,
literal|1
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|data
operator|.
name|start_class
argument_list|,
operator|(
expr|struct
name|regnode_charclass_class
operator|*
operator|)
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|r
operator|->
name|regstclass
operator|=
operator|(
name|regnode
operator|*
operator|)
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
expr_stmt|;
name|r
operator|->
name|reganch
operator|&=
operator|~
name|ROPT_SKIP
expr_stmt|;
comment|/* Used in find_byclass(). */
name|DEBUG_r
argument_list|(
operator|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
operator|,
name|regprop
argument_list|(
name|sv
argument_list|,
operator|(
name|regnode
operator|*
operator|)
name|data
operator|.
name|start_class
argument_list|)
operator|,
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"synthetic stclass `%s'.\n"
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* A temporary algorithm prefers floated substr to fixed one to dig more info. */
if|if
condition|(
name|longest_fixed_length
operator|>
name|longest_float_length
condition|)
block|{
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|anchored_substr
expr_stmt|;
name|r
operator|->
name|check_offset_min
operator|=
name|r
operator|->
name|check_offset_max
operator|=
name|r
operator|->
name|anchored_offset
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_SINGLE
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_NOSCAN
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|float_substr
expr_stmt|;
name|r
operator|->
name|check_offset_min
operator|=
name|data
operator|.
name|offset_float_min
expr_stmt|;
name|r
operator|->
name|check_offset_max
operator|=
name|data
operator|.
name|offset_float_max
expr_stmt|;
block|}
comment|/* XXXX Currently intuiting is not compatible with ANCH_GPOS. 	   This should be changed ASAP!  */
if|if
condition|(
name|r
operator|->
name|check_substr
operator|&&
operator|!
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
condition|)
block|{
name|r
operator|->
name|reganch
operator||=
name|RE_USE_INTUIT
expr_stmt|;
if|if
condition|(
name|SvTAIL
argument_list|(
name|r
operator|->
name|check_substr
argument_list|)
condition|)
name|r
operator|->
name|reganch
operator||=
name|RE_INTUIT_TAIL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Several toplevels. Best we can is to set minlen. */
name|I32
name|fake
decl_stmt|;
name|struct
name|regnode_charclass_class
name|ch_class
decl_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
name|cl_init
argument_list|(
operator|&
name|ch_class
argument_list|)
expr_stmt|;
name|data
operator|.
name|start_class
operator|=
operator|&
name|ch_class
expr_stmt|;
name|minlen
operator|=
name|study_chunk
argument_list|(
operator|&
name|scan
argument_list|,
operator|&
name|fake
argument_list|,
name|scan
operator|+
name|PL_regsize
argument_list|,
operator|&
name|data
argument_list|,
name|SCF_DO_STCLASS_AND
argument_list|)
expr_stmt|;
name|r
operator|->
name|check_substr
operator|=
name|r
operator|->
name|anchored_substr
operator|=
name|r
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|.
name|start_class
operator|->
name|flags
operator|&
name|ANYOF_EOS
operator|)
operator|&&
operator|!
name|cl_is_anything
argument_list|(
name|data
operator|.
name|start_class
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|I32
name|n
init|=
name|add_data
argument_list|(
literal|1
argument_list|,
literal|"f"
argument_list|)
decl_stmt|;
name|New
argument_list|(
literal|1006
argument_list|,
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|,
literal|1
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|data
operator|.
name|start_class
argument_list|,
operator|(
expr|struct
name|regnode_charclass_class
operator|*
operator|)
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|,
expr|struct
name|regnode_charclass_class
argument_list|)
expr_stmt|;
name|r
operator|->
name|regstclass
operator|=
operator|(
name|regnode
operator|*
operator|)
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
expr_stmt|;
name|r
operator|->
name|reganch
operator|&=
operator|~
name|ROPT_SKIP
expr_stmt|;
comment|/* Used in find_byclass(). */
name|DEBUG_r
argument_list|(
operator|(
name|sv
operator|=
name|sv_newmortal
argument_list|()
operator|,
name|regprop
argument_list|(
name|sv
argument_list|,
operator|(
name|regnode
operator|*
operator|)
name|data
operator|.
name|start_class
argument_list|)
operator|,
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"synthetic stclass `%s'.\n"
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|->
name|minlen
operator|=
name|minlen
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_GPOS
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_GPOS_SEEN
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_LOOKBEHIND
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_LOOKBEHIND_SEEN
expr_stmt|;
if|if
condition|(
name|PL_regseen
operator|&
name|REG_SEEN_EVAL
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_EVAL_SEEN
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|startp
argument_list|,
name|PL_regnpar
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|endp
argument_list|,
name|PL_regnpar
argument_list|,
name|I32
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|regdump
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - reg - regular expression, i.e. main body or parenthesized thing  *  * Caller must absorb opening parenthesis.  *  * Combining parenthesis handling with the base level of regular expression  * is a trifle forced, but the need to tie the tails of the branches to what  * follows makes it hard to avoid.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|S_reg
parameter_list|(
name|pTHX_
name|I32
name|paren
parameter_list|,
name|I32
modifier|*
name|flagp
parameter_list|)
comment|/* paren: Parenthesized? 0=top, 1=(, inside: changed to letter. */
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
comment|/* Will be the head of the group. */
specifier|register
name|regnode
modifier|*
name|br
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|lastbr
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ender
init|=
literal|0
decl_stmt|;
specifier|register
name|I32
name|parno
init|=
literal|0
decl_stmt|;
name|I32
name|flags
decl_stmt|,
name|oregflags
init|=
name|PL_regflags
decl_stmt|,
name|have_branch
init|=
literal|0
decl_stmt|,
name|open
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
operator|*
name|flagp
operator|=
literal|0
expr_stmt|;
comment|/* Tentatively. */
comment|/* Make an OPEN node, if parenthesized. */
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'?'
condition|)
block|{
name|U16
name|posflags
init|=
literal|0
decl_stmt|,
name|negflags
init|=
literal|0
decl_stmt|;
name|U16
modifier|*
name|flagsp
init|=
operator|&
name|posflags
decl_stmt|;
name|int
name|logical
init|=
literal|0
decl_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|paren
operator|=
operator|*
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* For look-ahead/behind. */
switch|switch
condition|(
name|paren
condition|)
block|{
case|case
literal|'<'
case|:
name|PL_regseen
operator||=
name|REG_SEEN_LOOKBEHIND
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'!'
condition|)
name|paren
operator|=
literal|','
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|'='
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'!'
condition|)
goto|goto
name|unknown
goto|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
case|case
literal|'='
case|:
case|case
literal|'!'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
case|case
literal|':'
case|:
case|case
literal|'>'
case|:
break|break;
case|case
literal|'$'
case|:
case|case
literal|'@'
case|:
name|FAIL2
argument_list|(
literal|"Sequence (?%c...) not implemented"
argument_list|,
operator|(
name|int
operator|)
name|paren
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Sequence (?#... not terminated"
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|'p'
case|:
if|if
condition|(
name|SIZE_ONLY
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"(?p{}) is deprecated - use (??{})"
argument_list|)
empty_stmt|;
comment|/* FALL THROUGH*/
case|case
literal|'?'
case|:
name|logical
operator|=
literal|1
expr_stmt|;
name|paren
operator|=
operator|*
name|PL_regcomp_parse
operator|++
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'{'
case|:
block|{
name|dTHR
expr_stmt|;
name|I32
name|count
init|=
literal|1
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|PL_regcomp_parse
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|OP_4tree
modifier|*
name|sop
decl_stmt|,
modifier|*
name|rop
decl_stmt|;
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_EVAL
expr_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|c
operator|=
operator|*
name|PL_regcomp_parse
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Sequence (?{...}) not terminated or not {}-balanced"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|-
literal|1
operator|-
name|s
condition|)
name|sv
operator|=
name|newSVpvn
argument_list|(
name|s
argument_list|,
name|PL_regcomp_parse
operator|-
literal|1
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
name|sv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rop
operator|=
name|sv_compile_2op
argument_list|(
name|sv
argument_list|,
operator|&
name|sop
argument_list|,
literal|"re"
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
literal|3
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|rop
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
operator|+
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|sop
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
operator|+
literal|2
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|av
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First pass */
if|if
condition|(
name|PL_reginterp_cnt
operator|<
operator|++
name|PL_seen_evals
operator|&&
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
comment|/* No compiled RE interpolated, has runtime 			   components ===> unsafe.  */
name|FAIL
argument_list|(
literal|"Eval-group not allowed at runtime, use re 'eval'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_tainted
condition|)
name|FAIL
argument_list|(
literal|"Eval-group in insecure regular expression"
argument_list|)
expr_stmt|;
block|}
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|logical
condition|)
block|{
name|ret
operator|=
name|reg_node
argument_list|(
name|LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|ret
operator|->
name|flags
operator|=
literal|2
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|reganode
argument_list|(
name|EVAL
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|reganode
argument_list|(
name|EVAL
argument_list|,
name|n
argument_list|)
return|;
block|}
case|case
literal|'('
case|:
block|{
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'!'
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'<'
operator|||
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* Lookahead or eval. */
name|I32
name|flag
decl_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|ret
operator|->
name|flags
operator|=
literal|1
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flag
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|insert_if
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|>=
literal|'1'
operator|&&
name|PL_regcomp_parse
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
block|{
name|parno
operator|=
name|atoi
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|GROUPP
argument_list|,
name|parno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|nextchar
argument_list|()
operator|)
operator|!=
literal|')'
condition|)
name|FAIL2
argument_list|(
literal|"Switch (?(number%c not recognized"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|insert_if
label|:
name|regtail
argument_list|(
name|ret
argument_list|,
name|reganode
argument_list|(
name|IFTHEN
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
name|br
operator|=
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|regtail
argument_list|(
name|br
argument_list|,
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|lastbr
operator|=
name|reganode
argument_list|(
name|IFTHEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fake one for optimizer. */
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|lastbr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
name|c
operator|=
operator|*
name|nextchar
argument_list|()
expr_stmt|;
block|}
else|else
name|lastbr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|FAIL
argument_list|(
literal|"Switch (?(condition)... contains too many branches"
argument_list|)
expr_stmt|;
name|ender
operator|=
name|reg_node
argument_list|(
name|TAIL
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastbr
condition|)
block|{
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|ender
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|lastbr
argument_list|)
argument_list|)
argument_list|,
name|ender
argument_list|)
expr_stmt|;
block|}
else|else
name|regtail
argument_list|(
name|ret
argument_list|,
name|ender
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|FAIL2
argument_list|(
literal|"Unknown condition for (?(%.2s"
argument_list|,
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
block|}
block|}
case|case
literal|0
case|:
name|FAIL
argument_list|(
literal|"Sequence (? incomplete"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|--
name|PL_regcomp_parse
expr_stmt|;
name|parse_flags
label|:
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
name|strchr
argument_list|(
literal|"iogcmsx"
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|'o'
condition|)
name|pmflag
argument_list|(
name|flagsp
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
operator|++
name|PL_regcomp_parse
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
condition|)
block|{
name|flagsp
operator|=
operator|&
name|negflags
expr_stmt|;
operator|++
name|PL_regcomp_parse
expr_stmt|;
goto|goto
name|parse_flags
goto|;
block|}
name|PL_regflags
operator||=
name|posflags
expr_stmt|;
name|PL_regflags
operator|&=
operator|~
name|negflags
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|':'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|paren
operator|=
literal|':'
expr_stmt|;
break|break;
block|}
name|unknown
label|:
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|FAIL2
argument_list|(
literal|"Sequence (?%c...) not recognized"
argument_list|,
operator|*
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|parno
operator|=
name|PL_regnpar
expr_stmt|;
name|PL_regnpar
operator|++
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|OPEN
argument_list|,
name|parno
argument_list|)
expr_stmt|;
name|open
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* Pick up the branches, linking them together. */
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|reginsert
argument_list|(
name|BRANCHJ
argument_list|,
name|br
argument_list|)
expr_stmt|;
block|}
else|else
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|have_branch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|1
expr_stmt|;
comment|/* For BRANCHJ-BRANCH. */
block|}
elseif|else
if|if
condition|(
name|paren
operator|==
literal|':'
condition|)
block|{
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SIMPLE
expr_stmt|;
block|}
if|if
condition|(
name|open
condition|)
block|{
comment|/* Starts with OPEN. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* OPEN -> first. */
block|}
elseif|else
if|if
condition|(
name|paren
operator|!=
literal|'?'
condition|)
comment|/* Not Conditional */
name|ret
operator|=
name|br
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
name|lastbr
operator|=
name|br
expr_stmt|;
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|ender
operator|=
name|reganode
argument_list|(
name|LONGJMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|lastbr
argument_list|)
argument_list|)
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Append to the previous. */
block|}
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|2
expr_stmt|;
comment|/* Account for LONGJMP. */
name|nextchar
argument_list|()
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* BRANCH -> BRANCH. */
name|lastbr
operator|=
name|br
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HASWIDTH
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
block|}
if|if
condition|(
name|have_branch
operator|||
name|paren
operator|!=
literal|':'
condition|)
block|{
comment|/* Make a closing node, and hook it on the end. */
switch|switch
condition|(
name|paren
condition|)
block|{
case|case
literal|':'
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|TAIL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ender
operator|=
name|reganode
argument_list|(
name|CLOSE
argument_list|,
name|parno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|','
case|:
case|case
literal|'='
case|:
case|case
literal|'!'
case|:
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'>'
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|SUCCEED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ender
operator|=
name|reg_node
argument_list|(
name|END
argument_list|)
expr_stmt|;
break|break;
block|}
name|regtail
argument_list|(
name|lastbr
argument_list|,
name|ender
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_branch
condition|)
block|{
comment|/* Hook the tails of the branches to the closing node. */
for|for
control|(
name|br
operator|=
name|ret
init|;
name|br
operator|!=
name|NULL
condition|;
name|br
operator|=
name|regnext
argument_list|(
name|br
argument_list|)
control|)
block|{
name|regoptail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|parens
index|[]
init|=
literal|"=!<,>"
decl_stmt|;
if|if
condition|(
name|paren
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|parens
argument_list|,
name|paren
argument_list|)
operator|)
condition|)
block|{
name|int
name|node
init|=
operator|(
operator|(
name|p
operator|-
name|parens
operator|)
operator|%
literal|2
operator|)
condition|?
name|UNLESSM
else|:
name|IFMATCH
decl_stmt|;
name|int
name|flag
init|=
operator|(
name|p
operator|-
name|parens
operator|)
operator|>
literal|1
decl_stmt|;
if|if
condition|(
name|paren
operator|==
literal|'>'
condition|)
name|node
operator|=
name|SUSPEND
operator|,
name|flag
operator|=
literal|0
expr_stmt|;
name|reginsert
argument_list|(
name|node
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
name|flag
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg_node
argument_list|(
name|TAIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for proper termination. */
if|if
condition|(
name|paren
condition|)
block|{
name|PL_regflags
operator|=
name|oregflags
expr_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|>=
name|PL_regxend
operator|||
operator|*
name|nextchar
argument_list|()
operator|!=
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|paren
operator|&&
name|PL_regcomp_parse
operator|<
name|PL_regxend
condition|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL
argument_list|(
literal|"junk on end of regexp"
argument_list|)
expr_stmt|;
comment|/* "Can't happen". */
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regbranch - one alternative of an | operator  *  * Implements the concatenation operator.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|S_regbranch
parameter_list|(
name|pTHX_
name|I32
modifier|*
name|flagp
parameter_list|,
name|I32
name|first
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|chain
init|=
name|NULL
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|latest
decl_stmt|;
name|I32
name|flags
init|=
literal|0
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
name|ret
operator|=
name|reganode
argument_list|(
name|BRANCHJ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
operator|&&
name|SIZE_ONLY
condition|)
name|PL_extralen
operator|+=
literal|1
expr_stmt|;
comment|/* BRANCHJ */
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'|'
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
block|{
name|flags
operator|&=
operator|~
name|TRYAGAIN
expr_stmt|;
name|latest
operator|=
name|regpiece
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
continue|continue;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|latest
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* First piece. */
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
else|else
block|{
name|PL_regnaughty
operator|++
expr_stmt|;
name|regtail
argument_list|(
name|chain
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|latest
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
comment|/* Loop ran zero times. */
name|chain
operator|=
name|reg_node
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|chain
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|1
condition|)
block|{
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SIMPLE
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regpiece - something followed by possible [*+?]  *  * Note that the branching code sequences used for ? and the general cases  * of * and + are somewhat optimized:  they use the same NOTHING node as  * both the endmarker for their branch list and the body of the last branch.  * It might seem that this node could be dispensed with entirely, but the  * endmarker role is not redundant.  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|S_regpiece
parameter_list|(
name|pTHX_
name|I32
modifier|*
name|flagp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
name|I32
name|flags
decl_stmt|;
name|char
modifier|*
name|origparse
init|=
name|PL_regcomp_parse
decl_stmt|;
name|char
modifier|*
name|maxpos
decl_stmt|;
name|I32
name|min
decl_stmt|;
name|I32
name|max
init|=
name|REG_INFTY
decl_stmt|;
name|ret
operator|=
name|regatom
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
operator|*
name|flagp
operator||=
name|TRYAGAIN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|op
operator|=
operator|*
name|PL_regcomp_parse
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'{'
operator|&&
name|regcurly
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|next
operator|=
name|PL_regcomp_parse
operator|+
literal|1
expr_stmt|;
name|maxpos
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|next
argument_list|)
operator|||
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|maxpos
condition|)
break|break;
else|else
name|maxpos
operator|=
name|next
expr_stmt|;
block|}
name|next
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|'}'
condition|)
block|{
comment|/* got one */
if|if
condition|(
operator|!
name|maxpos
condition|)
name|maxpos
operator|=
name|next
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|min
operator|=
name|atoi
argument_list|(
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|maxpos
operator|==
literal|','
condition|)
name|maxpos
operator|++
expr_stmt|;
else|else
name|maxpos
operator|=
name|PL_regcomp_parse
expr_stmt|;
name|max
operator|=
name|atoi
argument_list|(
name|maxpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|max
operator|&&
operator|*
name|maxpos
operator|!=
literal|'0'
condition|)
name|max
operator|=
name|REG_INFTY
expr_stmt|;
comment|/* meaning "infinity" */
elseif|else
if|if
condition|(
name|max
operator|>=
name|REG_INFTY
condition|)
name|FAIL2
argument_list|(
literal|"Quantifier in {,} bigger than %d"
argument_list|,
name|REG_INFTY
operator|-
literal|1
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|=
name|next
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
name|do_curly
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|PL_regnaughty
operator|+=
literal|2
operator|+
name|PL_regnaughty
operator|/
literal|2
expr_stmt|;
name|reginsert
argument_list|(
name|CURLY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regnode
modifier|*
name|w
init|=
name|reg_node
argument_list|(
name|WHILEM
argument_list|)
decl_stmt|;
name|w
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
block|{
name|reginsert
argument_list|(
name|LONGJMP
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|reginsert
argument_list|(
name|NOTHING
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|NEXT_OFF
argument_list|(
name|ret
argument_list|)
operator|=
literal|3
expr_stmt|;
comment|/* Go over LONGJMP. */
block|}
name|reginsert
argument_list|(
name|CURLYX
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|PL_extralen
condition|)
name|NEXT_OFF
argument_list|(
name|ret
argument_list|)
operator|=
literal|3
expr_stmt|;
comment|/* Go over NOTHING to LONGJMP. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|reg_node
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_reg_whilem_seen
operator|++
operator|,
name|PL_extralen
operator|+=
literal|3
expr_stmt|;
name|PL_regnaughty
operator|+=
literal|4
operator|+
name|PL_regnaughty
expr_stmt|;
comment|/* compound interest */
block|}
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|0
condition|)
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|max
operator|&&
name|max
operator|<
name|min
condition|)
name|FAIL
argument_list|(
literal|"Can't do {n,m} with n> m"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|ARG1_SET
argument_list|(
name|ret
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|ARG2_SET
argument_list|(
name|ret
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nest_check
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|ISMULT1
argument_list|(
name|op
argument_list|)
condition|)
block|{
operator|*
name|flagp
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* Now runtime fix should be reliable. */
block|if (!(flags&HASWIDTH)&& op != '?')       FAIL("regexp *+ operand could be empty");
endif|#
directive|endif
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator|=
operator|(
name|op
operator|!=
literal|'+'
operator|)
condition|?
operator|(
name|WORST
operator||
name|SPSTART
operator||
name|HASWIDTH
operator|)
else|:
operator|(
name|WORST
operator||
name|HASWIDTH
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'*'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|reginsert
argument_list|(
name|STAR
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|PL_regnaughty
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
block|{
name|reginsert
argument_list|(
name|PLUS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|PL_regnaughty
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
condition|)
block|{
name|min
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'?'
condition|)
block|{
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_curly
goto|;
block|}
name|nest_check
label|:
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
operator|!
name|SIZE_ONLY
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
operator|&&
name|max
operator|>
name|REG_INFTY
operator|/
literal|3
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"%.*s matches null string many times"
argument_list|,
argument|PL_regcomp_parse - origparse
argument_list|,
argument|origparse
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'?'
condition|)
block|{
name|nextchar
argument_list|()
expr_stmt|;
name|reginsert
argument_list|(
name|MINMOD
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|ret
operator|+
name|NODE_STEP_REGNODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISMULT2
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
name|FAIL
argument_list|(
literal|"nested *?+ in regexp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regatom - the lowest level  *  * Optimization:  gobbles an entire sequence of ordinary characters so that  * it can turn them into a single node, which is smaller to store and  * faster to run.  Backslashed characters are exceptions, each becoming a  * separate node; the code is simpler that way and it's not worth fixing.  *  * [Yes, it is worth fixing, some scripts can run twice the speed.]  */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
name|S_regatom
parameter_list|(
name|pTHX_
name|I32
modifier|*
name|flagp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|I32
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|tryagain
label|:
switch|switch
condition|(
operator|*
name|PL_regcomp_parse
condition|)
block|{
case|case
literal|'^'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|MBOL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SBOL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|BOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|1
index|]
condition|)
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_MULTILINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|MEOL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SEOL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|EOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SANYUTF8
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|ANYUTF8
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_SINGLELINE
condition|)
name|ret
operator|=
name|reg_node
argument_list|(
name|SANY
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|reg_node
argument_list|(
name|REG_ANY
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
block|}
name|PL_regnaughty
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|ret
operator|=
operator|(
name|UTF
condition|?
name|regclassutf8
argument_list|()
else|:
name|regclass
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|!=
literal|']'
condition|)
name|FAIL
argument_list|(
literal|"unmatched [] in regexp"
argument_list|)
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|nextchar
argument_list|()
expr_stmt|;
name|ret
operator|=
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
goto|goto
name|tryagain
goto|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|flagp
operator||=
name|flags
operator|&
operator|(
name|HASWIDTH
operator||
name|SPSTART
operator||
name|SIMPLE
operator|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|')'
case|:
if|if
condition|(
name|flags
operator|&
name|TRYAGAIN
condition|)
block|{
operator|*
name|flagp
operator||=
name|TRYAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|FAIL2
argument_list|(
literal|"internal urp in regexp at /%s/"
argument_list|,
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
comment|/* Supposed to be caught earlier. */
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
name|regcurly
argument_list|(
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
goto|goto
name|defchar
goto|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
name|FAIL
argument_list|(
literal|"?+*{} follows nothing in regexp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|PL_regcomp_parse
condition|)
block|{
case|case
literal|'A'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|SBOL
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|GPOS
argument_list|)
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_GPOS
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|SEOL
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|EOS
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|PL_seen_zerolen
operator|++
expr_stmt|;
comment|/* Do not optimize RE away */
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|SANY
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|CLUMP
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_mark
condition|)
name|is_utf8_mark
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"~"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'w'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|ALNUMLUTF8
else|:
name|ALNUMUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|ALNUML
else|:
name|ALNUM
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_alnum
condition|)
name|is_utf8_alnum
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"a"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'W'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|NALNUMLUTF8
else|:
name|NALNUMUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|NALNUML
else|:
name|NALNUM
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_alnum
condition|)
name|is_utf8_alnum
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"a"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'b'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_LOOKBEHIND
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|BOUNDLUTF8
else|:
name|BOUNDUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|BOUNDL
else|:
name|BOUND
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_alnum
condition|)
name|is_utf8_alnum
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"a"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'B'
case|:
name|PL_seen_zerolen
operator|++
expr_stmt|;
name|PL_regseen
operator||=
name|REG_SEEN_LOOKBEHIND
expr_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|NBOUNDLUTF8
else|:
name|NBOUNDUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|NBOUNDL
else|:
name|NBOUND
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_alnum
condition|)
name|is_utf8_alnum
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"a"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'s'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|SPACELUTF8
else|:
name|SPACEUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|SPACEL
else|:
name|SPACE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_space
condition|)
name|is_utf8_space
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|" "
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'S'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
operator|(
name|LOC
condition|?
name|NSPACELUTF8
else|:
name|NSPACEUTF8
operator|)
else|:
operator|(
name|LOC
condition|?
name|NSPACEL
else|:
name|NSPACE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_space
condition|)
name|is_utf8_space
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|" "
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'d'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
name|DIGITUTF8
else|:
name|DIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_digit
condition|)
name|is_utf8_digit
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"1"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'D'
case|:
name|ret
operator|=
name|reg_node
argument_list|(
name|UTF
condition|?
name|NDIGITUTF8
else|:
name|NDIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
operator|!
name|PL_utf8_digit
condition|)
name|is_utf8_digit
argument_list|(
operator|(
name|U8
operator|*
operator|)
literal|"1"
argument_list|)
expr_stmt|;
comment|/* preload table */
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
block|{
comment|/* a lovely hack--pretend we saw [\pX] instead */
name|char
modifier|*
name|oldregxend
init|=
name|PL_regxend
decl_stmt|;
if|if
condition|(
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
name|PL_regxend
operator|=
name|strchr
argument_list|(
name|PL_regcomp_parse
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_regxend
condition|)
name|FAIL
argument_list|(
literal|"Missing right brace on \\p{}"
argument_list|)
expr_stmt|;
name|PL_regxend
operator|++
expr_stmt|;
block|}
else|else
name|PL_regxend
operator|=
name|PL_regcomp_parse
operator|+
literal|2
expr_stmt|;
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|ret
operator|=
name|regclassutf8
argument_list|()
expr_stmt|;
name|PL_regxend
operator|=
name|oldregxend
expr_stmt|;
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'a'
case|:
case|case
literal|'x'
case|:
case|case
literal|'c'
case|:
case|case
literal|'0'
case|:
goto|goto
name|defchar
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|I32
name|num
init|=
name|atoi
argument_list|(
name|PL_regcomp_parse
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|9
operator|&&
name|num
operator|>=
name|PL_regnpar
condition|)
goto|goto
name|defchar
goto|;
else|else
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|num
operator|>
name|PL_regcomp_rx
operator|->
name|nparens
condition|)
name|FAIL
argument_list|(
literal|"reference to nonexistent group"
argument_list|)
expr_stmt|;
name|PL_regsawback
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|FOLD
condition|?
operator|(
name|LOC
condition|?
name|REFFL
else|:
name|REFF
operator|)
else|:
name|REF
argument_list|,
name|num
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|--
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|PL_regcomp_parse
operator|>=
name|PL_regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
comment|/* Do not generate `unrecognized' warnings here, we fall 	       back into the quick-grab loop below */
goto|goto
name|defchar
goto|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'\n'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
condition|)
goto|goto
name|tryagain
goto|;
block|}
comment|/* FALL THROUGH */
default|default:
block|{
specifier|register
name|I32
name|len
decl_stmt|;
specifier|register
name|UV
name|ender
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|I32
name|numlen
decl_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|defchar
label|:
name|ret
operator|=
name|reg_node
argument_list|(
name|FOLD
condition|?
operator|(
name|LOC
condition|?
name|EXACTFL
else|:
name|EXACTF
operator|)
else|:
name|EXACT
argument_list|)
expr_stmt|;
name|s
operator|=
name|STRING
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|PL_regcomp_parse
operator|-
literal|1
init|;
name|len
operator|<
literal|127
operator|&&
name|p
operator|<
name|PL_regxend
condition|;
name|len
operator|++
control|)
block|{
name|oldp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
name|p
operator|=
name|regwhite
argument_list|(
name|p
argument_list|,
name|PL_regxend
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
goto|goto
name|loopdone
goto|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'G'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
case|case
literal|'n'
case|:
name|ender
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ender
operator|=
literal|'\r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ender
operator|=
literal|'\t'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ender
operator|=
literal|'\f'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
ifdef|#
directive|ifdef
name|ASCIIish
name|ender
operator|=
literal|'\033'
expr_stmt|;
else|#
directive|else
name|ender
operator|=
literal|'\047'
expr_stmt|;
endif|#
directive|endif
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
ifdef|#
directive|ifdef
name|ASCIIish
name|ender
operator|=
literal|'\007'
expr_stmt|;
else|#
directive|else
name|ender
operator|=
literal|'\057'
expr_stmt|;
endif|#
directive|endif
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|e
init|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'}'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|FAIL
argument_list|(
literal|"Missing right brace on \\x{}"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UTF
condition|)
block|{
name|ender
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|e
operator|-
name|p
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|numlen
operator|+
name|len
operator|>=
literal|127
condition|)
block|{
comment|/* numlen is generous */
name|p
operator|--
expr_stmt|;
goto|goto
name|loopdone
goto|;
block|}
name|p
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|FAIL
argument_list|(
literal|"Can't use \\x{} without 'use utf8' declaration"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ender
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|p
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|p
operator|++
expr_stmt|;
name|ender
operator|=
name|UCHARAT
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
name|ender
operator|=
name|toCTRL
argument_list|(
name|ender
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|||
operator|(
name|isDIGIT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|atoi
argument_list|(
name|p
argument_list|)
operator|>=
name|PL_regnpar
operator|)
condition|)
block|{
name|ender
operator|=
operator|(
name|UV
operator|)
name|scan_oct
argument_list|(
name|p
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|p
operator|>=
name|PL_regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
name|isALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: Unrecognized escape \\%c passed through"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|*p
argument_list|)
empty_stmt|;
goto|goto
name|normal_default
goto|;
block|}
break|break;
default|default:
name|normal_default
label|:
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xc0
operator|)
operator|==
literal|0xc0
operator|&&
name|UTF
condition|)
block|{
name|ender
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|p
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
name|p
operator|=
name|regwhite
argument_list|(
name|p
argument_list|,
name|PL_regxend
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
name|FOLD
condition|)
block|{
if|if
condition|(
name|LOC
condition|)
name|ender
operator|=
name|toLOWER_LC_uni
argument_list|(
name|ender
argument_list|)
expr_stmt|;
else|else
name|ender
operator|=
name|toLOWER_uni
argument_list|(
name|ender
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISMULT2
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Back off on ?+*. */
if|if
condition|(
name|len
condition|)
name|p
operator|=
name|oldp
expr_stmt|;
elseif|else
if|if
condition|(
name|ender
operator|>=
literal|0x80
operator|&&
name|UTF
condition|)
block|{
name|reguni
argument_list|(
name|ender
argument_list|,
name|s
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|s
operator|+=
name|numlen
expr_stmt|;
name|len
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
name|len
operator|++
expr_stmt|;
name|REGC
argument_list|(
name|ender
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ender
operator|>=
literal|0x80
operator|&&
name|UTF
condition|)
block|{
name|reguni
argument_list|(
name|ender
argument_list|,
name|s
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|s
operator|+=
name|numlen
expr_stmt|;
name|len
operator|+=
name|numlen
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|REGC
argument_list|(
name|ender
argument_list|,
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|loopdone
label|:
name|PL_regcomp_parse
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|FAIL
argument_list|(
literal|"internal disaster in regexp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|STR_LEN
argument_list|(
name|ret
argument_list|)
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_regsize
operator|+=
name|STR_SZ
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|PL_regcode
operator|+=
name|STR_SZ
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_regwhite
parameter_list|(
name|pTHX_
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|e
parameter_list|)
block|{
while|while
condition|(
name|p
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
do|;
block|}
else|else
break|break;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Parse POSIX character classes: [[:foo:]], [[=foo=]], [[.foo.]].    Character classes ([:foo:]) can also be negated ([:^foo:]).    Returns a named class id (ANYOF_XXX) if successful, -1 otherwise.    Equivalence classes ([=foo=]) and composites ([.foo.]) are parsed,    but trigger warnings because they are currently unimplemented. */
end_comment

begin_function
name|STATIC
name|I32
name|S_regpposixcc
parameter_list|(
name|pTHX_
name|I32
name|value
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|posixcc
init|=
literal|0
decl_stmt|;
name|I32
name|namedclass
init|=
name|OOB_NAMEDCLASS
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|'['
operator|&&
name|PL_regcomp_parse
operator|+
literal|1
operator|<
name|PL_regxend
operator|&&
comment|/* I smell either [: or [= or [. -- POSIX has been here, right? */
operator|(
operator|*
name|PL_regcomp_parse
operator|==
literal|':'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'='
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'.'
operator|)
condition|)
block|{
name|char
name|c
init|=
operator|*
name|PL_regcomp_parse
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|PL_regcomp_parse
operator|++
decl_stmt|;
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
name|c
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|PL_regcomp_parse
operator|==
name|PL_regxend
condition|)
comment|/* Grandfather lone [:, [=, [. */
name|PL_regcomp_parse
operator|=
name|s
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|t
init|=
name|PL_regcomp_parse
operator|++
decl_stmt|;
comment|/* skip over the c */
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|']'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
comment|/* skip over the ending ] */
name|posixcc
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|I32
name|complement
init|=
operator|*
name|posixcc
operator|==
literal|'^'
condition|?
operator|*
name|posixcc
operator|++
else|:
literal|0
decl_stmt|;
name|I32
name|skip
init|=
literal|5
decl_stmt|;
comment|/* the most common skip */
switch|switch
condition|(
operator|*
name|posixcc
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"alnum"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NALNUMC
else|:
name|ANYOF_ALNUMC
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"alpha"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NALPHA
else|:
name|ANYOF_ALPHA
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"ascii"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NASCII
else|:
name|ANYOF_ASCII
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"cntrl"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NCNTRL
else|:
name|ANYOF_CNTRL
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"digit"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NDIGIT
else|:
name|ANYOF_DIGIT
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"graph"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NGRAPH
else|:
name|ANYOF_GRAPH
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"lower"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NLOWER
else|:
name|ANYOF_LOWER
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"print"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NPRINT
else|:
name|ANYOF_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"punct"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NPUNCT
else|:
name|ANYOF_PUNCT
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"space"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NSPACE
else|:
name|ANYOF_SPACE
expr_stmt|;
case|case
literal|'u'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"upper"
argument_list|,
literal|5
argument_list|)
condition|)
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NUPPER
else|:
name|ANYOF_UPPER
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* this is not POSIX, this is the Perl \w */
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"word"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NALNUM
else|:
name|ANYOF_ALNUM
expr_stmt|;
name|skip
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|posixcc
argument_list|,
literal|"xdigit"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|namedclass
operator|=
name|complement
condition|?
name|ANYOF_NXDIGIT
else|:
name|ANYOF_XDIGIT
expr_stmt|;
name|skip
operator|=
literal|6
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|namedclass
operator|==
name|OOB_NAMEDCLASS
operator|||
name|posixcc
index|[
name|skip
index|]
operator|!=
literal|':'
operator|||
name|posixcc
index|[
name|skip
operator|+
literal|1
index|]
operator|!=
literal|']'
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Character class [:%.*s:] unknown"
argument_list|,
name|t
operator|-
name|s
operator|-
literal|1
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
operator|!
name|SIZE_ONLY
condition|)
comment|/* [[=foo=]] and [[.foo.]] are still future. */
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"Character class syntax [%c %c] is reserved for future extensions"
argument_list|,
argument|c
argument_list|,
argument|c
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Maternal grandfather: 		 * "[:" ending in ":" but not in ":]" */
name|PL_regcomp_parse
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
return|return
name|namedclass
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_checkposixcc
parameter_list|(
name|pTHX
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
operator|(
operator|*
name|PL_regcomp_parse
operator|==
literal|':'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'='
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'.'
operator|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|PL_regcomp_parse
decl_stmt|;
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
name|c
operator|==
operator|*
name|s
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"Character class syntax [%c %c] belongs inside character classes"
argument_list|,
argument|c
argument_list|,
argument|c
argument_list|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
operator|||
name|c
operator|==
literal|'.'
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"Character class syntax [%c %c] is reserved for future extensions"
argument_list|,
argument|c
argument_list|,
argument|c
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|regnode
modifier|*
name|S_regclass
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|U32
name|value
decl_stmt|;
specifier|register
name|I32
name|lastvalue
init|=
name|OOB_CHAR8
decl_stmt|;
specifier|register
name|I32
name|range
init|=
literal|0
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
name|I32
name|numlen
decl_stmt|;
name|I32
name|namedclass
decl_stmt|;
name|char
modifier|*
name|rangebegin
decl_stmt|;
name|bool
name|need_class
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|reg_node
argument_list|(
name|ANYOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_regsize
operator|+=
name|ANYOF_SKIP
expr_stmt|;
else|else
block|{
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ANYOF_BITMAP_ZERO
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|PL_regcode
operator|+=
name|ANYOF_SKIP
expr_stmt|;
if|if
condition|(
name|FOLD
condition|)
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator||=
name|ANYOF_FOLD
expr_stmt|;
if|if
condition|(
name|LOC
condition|)
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator||=
name|ANYOF_LOCALE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'^'
condition|)
block|{
comment|/* Complement of range. */
name|PL_regnaughty
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator||=
name|ANYOF_INVERT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|checkposixcc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|']'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
condition|)
goto|goto
name|skipcond
goto|;
comment|/* allow 1st char to be ] or - */
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|']'
condition|)
block|{
name|skipcond
label|:
name|namedclass
operator|=
name|OOB_NAMEDCLASS
expr_stmt|;
if|if
condition|(
operator|!
name|range
condition|)
name|rangebegin
operator|=
name|PL_regcomp_parse
expr_stmt|;
name|value
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|'['
condition|)
name|namedclass
operator|=
name|regpposixcc
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|'\\'
condition|)
block|{
name|value
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
comment|/* Some compilers cannot handle switching on 64-bit integer 	     * values, therefore value cannot be an UV. --jhi */
switch|switch
condition|(
name|value
condition|)
block|{
case|case
literal|'w'
case|:
name|namedclass
operator|=
name|ANYOF_ALNUM
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|namedclass
operator|=
name|ANYOF_NALNUM
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|namedclass
operator|=
name|ANYOF_SPACE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|namedclass
operator|=
name|ANYOF_NSPACE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|namedclass
operator|=
name|ANYOF_DIGIT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|namedclass
operator|=
name|ANYOF_NDIGIT
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|value
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|value
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|value
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|value
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|value
operator|=
literal|'\b'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ASCIIish
case|case
literal|'e'
case|:
name|value
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
literal|'\007'
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'e'
case|:
name|value
operator|=
literal|'\047'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
literal|'\057'
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'x'
case|:
name|value
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|PL_regcomp_parse
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|value
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
name|value
operator|=
name|toCTRL
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|value
operator|=
operator|(
name|UV
operator|)
name|scan_oct
argument_list|(
operator|--
name|PL_regcomp_parse
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
name|isALPHA
argument_list|(
name|value
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: Unrecognized escape \\%c in character class passed through"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|(int)value
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namedclass
operator|>
name|OOB_NAMEDCLASS
condition|)
block|{
if|if
condition|(
operator|!
name|need_class
operator|&&
operator|!
name|SIZE_ONLY
condition|)
name|ANYOF_CLASS_ZERO
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|need_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|range
condition|)
block|{
comment|/* a-\d, a-[:digit:] */
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: false [] range \"%*.*s\" in regexp"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|rangebegin
argument_list|)
empty_stmt|;
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|lastvalue
argument_list|)
expr_stmt|;
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|range
operator|=
literal|0
expr_stmt|;
comment|/* this is not a true range */
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
switch|switch
condition|(
name|namedclass
condition|)
block|{
case|case
name|ANYOF_ALNUM
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_ALNUM
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NALNUM
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NALNUM
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_SPACE
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_SPACE
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NSPACE
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NSPACE
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_DIGIT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_DIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|'0'
init|;
name|value
operator|<=
literal|'9'
condition|;
name|value
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NDIGIT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NDIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|'0'
condition|;
name|value
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|value
operator|=
literal|'9'
operator|+
literal|1
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NALNUMC
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NALNUMC
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUMC
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_ALNUMC
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_ALNUMC
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isALNUMC
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_ALPHA
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_ALPHA
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isALPHA
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NALPHA
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NALPHA
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_ASCII
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_ASCII
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|ASCIIish
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|128
condition|;
name|value
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC */
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isASCII
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EBCDIC */
block|}
break|break;
case|case
name|ANYOF_NASCII
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NASCII
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|ASCIIish
for|for
control|(
name|value
operator|=
literal|128
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* EBCDIC */
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isASCII
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EBCDIC */
block|}
break|break;
case|case
name|ANYOF_CNTRL
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_CNTRL
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isCNTRL
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|lastvalue
operator|=
name|OOB_CHAR8
expr_stmt|;
break|break;
case|case
name|ANYOF_NCNTRL
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NCNTRL
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isCNTRL
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_GRAPH
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_GRAPH
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isGRAPH
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NGRAPH
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NGRAPH
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isGRAPH
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_LOWER
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_LOWER
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NLOWER
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NLOWER
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isLOWER
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_PRINT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_PRINT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isPRINT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NPRINT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NPRINT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isPRINT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_PUNCT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_PUNCT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isPUNCT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NPUNCT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NPUNCT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isPUNCT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_UPPER
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_UPPER
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isUPPER
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NUPPER
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NUPPER
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isUPPER
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_XDIGIT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_XDIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
name|isXDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF_NXDIGIT
case|:
if|if
condition|(
name|LOC
condition|)
name|ANYOF_CLASS_SET
argument_list|(
name|ret
argument_list|,
name|ANYOF_NXDIGIT
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
name|value
operator|++
control|)
if|if
condition|(
operator|!
name|isXDIGIT
argument_list|(
name|value
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|(
literal|"invalid [::] class in regexp"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LOC
condition|)
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator||=
name|ANYOF_CLASS
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|range
condition|)
block|{
if|if
condition|(
name|lastvalue
operator|>
name|value
condition|)
comment|/* b-a */
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"/%.127s/: invalid [] range \"%*.*s\" in regexp"
argument_list|,
name|PL_regprecomp
argument_list|,
name|PL_regcomp_parse
operator|-
name|rangebegin
argument_list|,
name|PL_regcomp_parse
operator|-
name|rangebegin
argument_list|,
name|rangebegin
argument_list|)
expr_stmt|;
block|}
name|range
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lastvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
operator|&&
name|PL_regcomp_parse
operator|+
literal|1
operator|<
name|PL_regxend
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|namedclass
operator|>
name|OOB_NAMEDCLASS
condition|)
block|{
comment|/* \w-, [:word:]- */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: false [] range \"%*.*s\" in regexp"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|rangebegin
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* do it next time */
block|}
block|}
comment|/* now is the next time */
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
ifndef|#
directive|ifndef
name|ASCIIish
comment|/* EBCDIC, for example. */
if|if
condition|(
operator|(
name|isLOWER
argument_list|(
name|lastvalue
argument_list|)
operator|&&
name|isLOWER
argument_list|(
name|value
argument_list|)
operator|)
operator|||
operator|(
name|isUPPER
argument_list|(
name|lastvalue
argument_list|)
operator|&&
name|isUPPER
argument_list|(
name|value
argument_list|)
operator|)
condition|)
block|{
name|I32
name|i
decl_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
name|lastvalue
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lastvalue
init|;
name|i
operator|<=
name|value
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isLOWER
argument_list|(
name|i
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|lastvalue
init|;
name|i
operator|<=
name|value
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isUPPER
argument_list|(
name|i
argument_list|)
condition|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
init|;
name|lastvalue
operator|<=
name|value
condition|;
name|lastvalue
operator|++
control|)
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|lastvalue
argument_list|)
expr_stmt|;
block|}
name|range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|need_class
condition|)
block|{
if|if
condition|(
name|SIZE_ONLY
condition|)
name|PL_regsize
operator|+=
name|ANYOF_CLASS_ADD_SKIP
expr_stmt|;
else|else
name|PL_regcode
operator|+=
name|ANYOF_CLASS_ADD_SKIP
expr_stmt|;
block|}
comment|/* optimize case-insensitive simple patterns (e.g. /[a-z]/i) */
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
operator|(
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator|&
operator|(
name|ANYOF_FLAGS_ALL
operator|^
name|ANYOF_INVERT
operator|)
operator|)
operator|==
name|ANYOF_FOLD
condition|)
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
literal|256
condition|;
operator|++
name|value
control|)
block|{
if|if
condition|(
name|ANYOF_BITMAP_TEST
argument_list|(
name|ret
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|I32
name|cf
init|=
name|PL_fold
index|[
name|value
index|]
decl_stmt|;
name|ANYOF_BITMAP_SET
argument_list|(
name|ret
argument_list|,
name|cf
argument_list|)
expr_stmt|;
block|}
block|}
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator|&=
operator|~
name|ANYOF_FOLD
expr_stmt|;
block|}
comment|/* optimize inverted simple patterns (e.g. [^a-z]) */
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
operator|(
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator|&
name|ANYOF_FLAGS_ALL
operator|)
operator|==
name|ANYOF_INVERT
condition|)
block|{
for|for
control|(
name|value
operator|=
literal|0
init|;
name|value
operator|<
name|ANYOF_BITMAP_SIZE
condition|;
operator|++
name|value
control|)
name|ANYOF_BITMAP
argument_list|(
name|ret
argument_list|)
index|[
name|value
index|]
operator|^=
name|ANYOF_FLAGS_ALL
expr_stmt|;
name|ANYOF_FLAGS
argument_list|(
name|ret
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|STATIC
name|regnode
modifier|*
name|S_regclassutf8
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
specifier|register
name|U32
name|value
decl_stmt|;
specifier|register
name|U32
name|lastvalue
init|=
name|OOB_UTF8
decl_stmt|;
specifier|register
name|I32
name|range
init|=
literal|0
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
name|I32
name|numlen
decl_stmt|;
name|I32
name|n
decl_stmt|;
name|SV
modifier|*
name|listsv
decl_stmt|;
name|U8
name|flags
init|=
literal|0
decl_stmt|;
name|I32
name|namedclass
decl_stmt|;
name|char
modifier|*
name|rangebegin
decl_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'^'
condition|)
block|{
comment|/* Complement of range. */
name|PL_regnaughty
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|flags
operator||=
name|ANYOF_INVERT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|FOLD
condition|)
name|flags
operator||=
name|ANYOF_FOLD
expr_stmt|;
if|if
condition|(
name|LOC
condition|)
name|flags
operator||=
name|ANYOF_LOCALE
expr_stmt|;
name|listsv
operator|=
name|newSVpvn
argument_list|(
literal|"# comment\n"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|checkposixcc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|']'
operator|||
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
condition|)
goto|goto
name|skipcond
goto|;
comment|/* allow 1st char to be ] or - */
while|while
condition|(
name|PL_regcomp_parse
operator|<
name|PL_regxend
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|']'
condition|)
block|{
name|skipcond
label|:
name|namedclass
operator|=
name|OOB_NAMEDCLASS
expr_stmt|;
if|if
condition|(
operator|!
name|range
condition|)
name|rangebegin
operator|=
name|PL_regcomp_parse
expr_stmt|;
name|value
operator|=
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|PL_regcomp_parse
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|'['
condition|)
name|namedclass
operator|=
name|regpposixcc
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|'\\'
condition|)
block|{
name|value
operator|=
operator|(
name|U32
operator|)
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|PL_regcomp_parse
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
comment|/* Some compilers cannot handle switching on 64-bit integer 	     * values, therefore value cannot be an UV.  Yes, this will 	     * be a problem later if we want switch on Unicode.  --jhi */
switch|switch
condition|(
name|value
condition|)
block|{
case|case
literal|'w'
case|:
name|namedclass
operator|=
name|ANYOF_ALNUM
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|namedclass
operator|=
name|ANYOF_NALNUM
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|namedclass
operator|=
name|ANYOF_SPACE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|namedclass
operator|=
name|ANYOF_NSPACE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|namedclass
operator|=
name|ANYOF_DIGIT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|namedclass
operator|=
name|ANYOF_NDIGIT
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'{'
condition|)
block|{
name|e
operator|=
name|strchr
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|FAIL
argument_list|(
literal|"Missing right brace on \\p{}"
argument_list|)
expr_stmt|;
name|n
operator|=
name|e
operator|-
name|PL_regcomp_parse
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|PL_regcomp_parse
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|'p'
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::%.*s\n"
argument_list|,
argument|(int)n
argument_list|,
argument|PL_regcomp_parse
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::%.*s\n"
argument_list|,
argument|(int)n
argument_list|,
argument|PL_regcomp_parse
argument_list|)
empty_stmt|;
block|}
name|PL_regcomp_parse
operator|=
name|e
operator|+
literal|1
expr_stmt|;
name|lastvalue
operator|=
name|OOB_UTF8
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|value
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|value
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|value
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|value
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|value
operator|=
literal|'\b'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ASCIIish
case|case
literal|'e'
case|:
name|value
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
literal|'\007'
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'e'
case|:
name|value
operator|=
literal|'\047'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|value
operator|=
literal|'\057'
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'x'
case|:
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'{'
condition|)
block|{
name|e
operator|=
name|strchr
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|FAIL
argument_list|(
literal|"Missing right brace on \\x{}"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|PL_regcomp_parse
argument_list|,
name|e
operator|-
name|PL_regcomp_parse
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|UV
operator|)
name|scan_hex
argument_list|(
name|PL_regcomp_parse
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|value
operator|=
name|UCHARAT
argument_list|(
name|PL_regcomp_parse
operator|++
argument_list|)
expr_stmt|;
name|value
operator|=
name|toCTRL
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|value
operator|=
operator|(
name|UV
operator|)
name|scan_oct
argument_list|(
operator|--
name|PL_regcomp_parse
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|PL_regcomp_parse
operator|+=
name|numlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|SIZE_ONLY
operator|&&
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
name|isALPHA
argument_list|(
name|value
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: Unrecognized escape \\%c in character class passed through"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|(int)value
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namedclass
operator|>
name|OOB_NAMEDCLASS
condition|)
block|{
if|if
condition|(
name|range
condition|)
block|{
comment|/* a-\d, a-[:digit:] */
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: false [] range \"%*.*s\" in regexp"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|rangebegin
argument_list|)
empty_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
comment|/* 0x002D is Unicode for '-' */
literal|"%04"
argument|UVxf
literal|"\n002D\n"
argument_list|,
argument|(UV)lastvalue
argument_list|)
empty_stmt|;
block|}
name|range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
switch|switch
condition|(
name|namedclass
condition|)
block|{
case|case
name|ANYOF_ALNUM
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsWord\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NALNUM
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsWord\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_ALNUMC
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsAlnum\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NALNUMC
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsAlnum\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_ALPHA
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsAlpha\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NALPHA
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsAlpha\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_ASCII
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsASCII\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NASCII
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsASCII\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_CNTRL
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsCntrl\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NCNTRL
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsCntrl\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_GRAPH
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsGraph\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NGRAPH
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsGraph\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_DIGIT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsDigit\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NDIGIT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsDigit\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_LOWER
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsLower\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NLOWER
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsLower\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_PRINT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsPrint\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NPRINT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsPrint\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_PUNCT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsPunct\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NPUNCT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsPunct\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_SPACE
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsSpace\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NSPACE
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsSpace\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_UPPER
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsUpper\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NUPPER
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsUpper\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_XDIGIT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"+utf8::IsXDigit\n"
argument_list|)
empty_stmt|;
break|break;
case|case
name|ANYOF_NXDIGIT
case|:
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"!utf8::IsXDigit\n"
argument_list|)
empty_stmt|;
break|break;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|range
condition|)
block|{
if|if
condition|(
name|lastvalue
operator|>
name|value
condition|)
block|{
comment|/* b-a */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"/%.127s/: invalid [] range \"%*.*s\" in regexp"
argument_list|,
name|PL_regprecomp
argument_list|,
name|PL_regcomp_parse
operator|-
name|rangebegin
argument_list|,
name|PL_regcomp_parse
operator|-
name|rangebegin
argument_list|,
name|rangebegin
argument_list|)
expr_stmt|;
block|}
name|range
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lastvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'-'
operator|&&
name|PL_regcomp_parse
operator|+
literal|1
operator|<
name|PL_regxend
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
if|if
condition|(
name|namedclass
operator|>
name|OOB_NAMEDCLASS
condition|)
block|{
comment|/* \w-, [:word:]- */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"/%.127s/: false [] range \"%*.*s\" in regexp"
argument_list|,
argument|PL_regprecomp
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|PL_regcomp_parse - rangebegin
argument_list|,
argument|rangebegin
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
comment|/* 0x002D is Unicode for '-' */
literal|"002D\n"
argument_list|)
empty_stmt|;
block|}
else|else
name|range
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* do it next time */
block|}
block|}
comment|/* now is the next time */
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ listsv
argument_list|,
literal|"%04"
argument|UVxf
literal|"\t%04"
argument|UVxf
literal|"\n"
argument_list|,
argument|(UV)lastvalue
argument_list|,
argument|(UV)value
argument_list|)
empty_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|reganode
argument_list|(
name|ANYOFUTF8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SIZE_ONLY
condition|)
block|{
name|SV
modifier|*
name|rv
init|=
name|swash_init
argument_list|(
literal|"utf8"
argument_list|,
literal|""
argument_list|,
name|listsv
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SvREFCNT_dec
argument_list|(
name|listsv
argument_list|)
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
literal|1
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|PL_regcomp_rx
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|rv
expr_stmt|;
name|ARG1_SET
argument_list|(
name|ret
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ARG2_SET
argument_list|(
name|ret
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_nextchar
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|retval
init|=
name|PL_regcomp_parse
operator|++
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'('
operator|&&
name|PL_regcomp_parse
index|[
literal|1
index|]
operator|==
literal|'?'
operator|&&
name|PL_regcomp_parse
index|[
literal|2
index|]
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|')'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PL_regflags
operator|&
name|PMf_EXTENDED
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|PL_regcomp_parse
argument_list|)
condition|)
block|{
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|PL_regcomp_parse
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|PL_regcomp_parse
operator|&&
operator|*
name|PL_regcomp_parse
operator|!=
literal|'\n'
condition|)
name|PL_regcomp_parse
operator|++
expr_stmt|;
name|PL_regcomp_parse
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|retval
return|;
block|}
block|}
end_function

begin_comment
comment|/* - reg_node - emit a node */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
comment|/* Location. */
name|S_reg_node
parameter_list|(
name|pTHX_
name|U8
name|op
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|PL_regcode
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|SIZE_ALIGN
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|PL_regsize
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|NODE_ALIGN_FILL
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ret
expr_stmt|;
name|FILL_ADVANCE_NODE
argument_list|(
name|ptr
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|PL_regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* - reganode - emit a node with an argument */
end_comment

begin_function
name|STATIC
name|regnode
modifier|*
comment|/* Location. */
name|S_reganode
parameter_list|(
name|pTHX_
name|U8
name|op
parameter_list|,
name|U32
name|arg
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|ret
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|PL_regcode
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|SIZE_ALIGN
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|PL_regsize
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|NODE_ALIGN_FILL
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ret
expr_stmt|;
name|FILL_ADVANCE_NODE_ARG
argument_list|(
name|ptr
argument_list|,
name|op
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|PL_regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* - reguni - emit (if appropriate) a Unicode character */
end_comment

begin_function
name|STATIC
name|void
name|S_reguni
parameter_list|(
name|pTHX_
name|UV
name|uv
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|I32
modifier|*
name|lenp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
index|]
decl_stmt|;
operator|*
name|lenp
operator|=
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|uv
argument_list|)
operator|-
name|tmpbuf
expr_stmt|;
block|}
else|else
operator|*
name|lenp
operator|=
name|uv_to_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
name|uv
argument_list|)
operator|-
operator|(
name|U8
operator|*
operator|)
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - reginsert - insert an operator in front of already-emitted operand * * Means relocating the operand. */
end_comment

begin_function
name|STATIC
name|void
name|S_reginsert
parameter_list|(
name|pTHX_
name|U8
name|op
parameter_list|,
name|regnode
modifier|*
name|opnd
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|src
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|dst
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|place
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|op
index|]
decl_stmt|;
comment|/* (PL_regkind[(U8)op] == CURLY ? EXTRA_STEP_2ARGS : 0); */
if|if
condition|(
name|SIZE_ONLY
condition|)
block|{
name|PL_regsize
operator|+=
name|NODE_STEP_REGNODE
operator|+
name|offset
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|PL_regcode
expr_stmt|;
name|PL_regcode
operator|+=
name|NODE_STEP_REGNODE
operator|+
name|offset
expr_stmt|;
name|dst
operator|=
name|PL_regcode
expr_stmt|;
while|while
condition|(
name|src
operator|>
name|opnd
condition|)
name|StructCopy
argument_list|(
operator|--
name|src
argument_list|,
operator|--
name|dst
argument_list|,
name|regnode
argument_list|)
expr_stmt|;
name|place
operator|=
name|opnd
expr_stmt|;
comment|/* Op node, where operand used to be. */
name|src
operator|=
name|NEXTOPER
argument_list|(
name|place
argument_list|)
expr_stmt|;
name|FILL_ADVANCE_NODE
argument_list|(
name|place
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|regnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - regtail - set the next-pointer at the end of a node chain of p to val. */
end_comment

begin_function
name|STATIC
name|void
name|S_regtail
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|p
parameter_list|,
name|regnode
modifier|*
name|val
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|scan
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|SIZE_ONLY
condition|)
return|return;
comment|/* Find last node. */
name|scan
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|temp
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
break|break;
name|scan
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|scan
argument_list|)
index|]
condition|)
block|{
name|ARG_SET
argument_list|(
name|scan
argument_list|,
name|val
operator|-
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
operator|=
name|val
operator|-
name|scan
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* - regoptail - regtail on operand of first argument; nop if operandless */
end_comment

begin_function
name|STATIC
name|void
name|S_regoptail
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|p
parameter_list|,
name|regnode
modifier|*
name|val
parameter_list|)
block|{
name|dTHR
expr_stmt|;
comment|/* "Operandless" and "op != BRANCH" are synonymous in practice. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|SIZE_ONLY
condition|)
return|return;
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|p
argument_list|)
index|]
operator|==
name|BRANCH
condition|)
block|{
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|p
argument_list|)
index|]
operator|==
name|BRANCHJ
condition|)
block|{
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
end_function

begin_comment
comment|/*  - regcurly - a little FSA that accepts {\d+,?\d*}  */
end_comment

begin_function
name|STATIC
name|I32
name|S_regcurly
parameter_list|(
name|pTHX_
specifier|register
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'{'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'}'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|STATIC
name|regnode
modifier|*
name|S_dumpuntil
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|start
parameter_list|,
name|regnode
modifier|*
name|node
parameter_list|,
name|regnode
modifier|*
name|last
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|l
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
specifier|register
name|U8
name|op
init|=
name|EXACT
decl_stmt|;
comment|/* Arbitrary non-END op. */
specifier|register
name|regnode
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|op
operator|!=
name|END
operator|&&
operator|(
operator|!
name|last
operator|||
name|node
operator|<
name|last
operator|)
condition|)
block|{
comment|/* While that wasn't END last time... */
name|NODE_ALIGN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|op
operator|=
name|OP
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|CLOSE
condition|)
name|l
operator|--
expr_stmt|;
name|next
operator|=
name|regnext
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Where, what. */
if|if
condition|(
name|OP
argument_list|(
name|node
argument_list|)
operator|==
name|OPTIMIZED
condition|)
goto|goto
name|after_print
goto|;
name|regprop
argument_list|(
name|sv
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%4"
name|IVdf
literal|":%*s%s"
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|node
operator|-
name|start
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
name|l
operator|+
literal|1
argument_list|)
argument_list|,
literal|""
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* Next ptr. */
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(0)"
argument_list|)
expr_stmt|;
else|else
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(%"
name|IVdf
literal|")"
argument_list|,
call|(
name|IV
call|)
argument_list|(
name|next
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PerlIO_putc
argument_list|(
name|Perl_debug_log
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|after_print
label|:
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|BRANCHJ
condition|)
block|{
specifier|register
name|regnode
modifier|*
name|nnode
init|=
operator|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|LONGJMP
condition|?
name|regnext
argument_list|(
name|next
argument_list|)
else|:
name|next
operator|)
decl_stmt|;
if|if
condition|(
name|last
operator|&&
name|nnode
operator|>
name|last
condition|)
name|nnode
operator|=
name|last
expr_stmt|;
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|nnode
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|BRANCH
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|,
name|next
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|CURLY
condition|)
block|{
comment|/* `next' might be very big: optimizer */
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|CURLY
operator|&&
name|op
operator|!=
name|CURLYX
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
argument_list|,
name|next
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|PLUS
operator|||
name|op
operator|==
name|STAR
condition|)
block|{
name|node
operator|=
name|dumpuntil
argument_list|(
name|start
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
argument_list|,
name|NEXTOPER
argument_list|(
name|node
argument_list|)
operator|+
literal|1
argument_list|,
name|sv
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ANYOF
condition|)
block|{
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|+=
name|ANYOF_SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|op
index|]
operator|==
name|EXACT
condition|)
block|{
comment|/* Literal string, where present. */
name|node
operator|+=
name|NODE_SZ_STR
argument_list|(
name|node
argument_list|)
operator|-
literal|1
expr_stmt|;
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|NEXTOPER
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|+=
name|regarglen
index|[
operator|(
name|U8
operator|)
name|op
index|]
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|CURLYX
operator|||
name|op
operator|==
name|OPEN
condition|)
name|l
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|WHILEM
condition|)
name|l
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGGING */
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/*  - regdump - dump a regexp onto Perl_debug_log in vaguely comprehensible form  */
end_comment

begin_function
name|void
name|Perl_regdump
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|r
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|dumpuntil
argument_list|(
name|r
operator|->
name|program
argument_list|,
name|r
operator|->
name|program
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Header fields of interest. */
if|if
condition|(
name|r
operator|->
name|anchored_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"anchored `%s%.*s%s'%s at %"
name|IVdf
literal|" "
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SvCUR
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
name|SvTAIL
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
argument_list|,
operator|(
name|IV
operator|)
name|r
operator|->
name|anchored_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|float_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"floating `%s%.*s%s'%s at %"
name|IVdf
literal|"..%"
name|UVuf
literal|" "
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SvCUR
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
name|SvTAIL
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
argument_list|,
operator|(
name|IV
operator|)
name|r
operator|->
name|float_min_offset
argument_list|,
operator|(
name|UV
operator|)
name|r
operator|->
name|float_max_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|check_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
name|r
operator|->
name|check_substr
operator|==
name|r
operator|->
name|float_substr
condition|?
literal|"(checking floating"
else|:
literal|"(checking anchored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_NOSCAN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" noscan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_CHECK_ALL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" isall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|check_substr
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regstclass
condition|)
block|{
name|regprop
argument_list|(
name|sv
argument_list|,
name|r
operator|->
name|regstclass
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"stclass `%s' "
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"anchored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_BOL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(BOL)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_MBOL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(MBOL)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_SBOL
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(SBOL)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"(GPOS)"
argument_list|)
expr_stmt|;
name|PerlIO_putc
argument_list|(
name|Perl_debug_log
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_GPOS_SEEN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"GPOS "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"plus "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"implicit "
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"minlen %ld "
argument_list|,
operator|(
name|long
operator|)
name|r
operator|->
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"with eval "
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|STATIC
name|void
name|S_put_byte
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<=
literal|' '
operator|||
name|c
operator|==
literal|127
operator|||
name|c
operator|==
literal|255
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"\\%o"
argument_list|,
argument|c
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'^'
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"\\%c"
argument_list|,
argument|c
argument_list|)
empty_stmt|;
else|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"%c"
argument_list|,
argument|c
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* - regprop - printable representation of opcode */
end_comment

begin_function
name|void
name|Perl_regprop
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|regnode
modifier|*
name|o
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|dTHR
expr_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|o
argument_list|)
operator|>=
name|reg_num
condition|)
comment|/* regnode.type is unsigned */
name|FAIL
argument_list|(
literal|"corrupted regexp opcode"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reg_name
index|[
name|OP
argument_list|(
name|o
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* Take off const! */
name|k
operator|=
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|o
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|EXACT
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"<%s%.*s%s>"
argument_list|,
argument|PL_colors[
literal|0
argument|]
argument_list|,
argument|STR_LEN(o)
argument_list|,
argument|STRING(o)
argument_list|,
argument|PL_colors[
literal|1
argument|]
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
name|CURLY
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|o
argument_list|)
operator|==
name|CURLYM
operator|||
name|OP
argument_list|(
name|o
argument_list|)
operator|==
name|CURLYN
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"[%d]"
argument_list|,
argument|o->flags
argument_list|)
empty_stmt|;
comment|/* Parenth number */
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|" {%d,%d}"
argument_list|,
argument|ARG1(o)
argument_list|,
argument|ARG2(o)
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|==
name|WHILEM
operator|&&
name|o
operator|->
name|flags
condition|)
comment|/* Ordinal/of */
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"[%d/%d]"
argument_list|,
argument|o->flags&
literal|0xf
argument_list|,
argument|o->flags>>
literal|4
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
name|REF
operator|||
name|k
operator|==
name|OPEN
operator|||
name|k
operator|==
name|CLOSE
operator|||
name|k
operator|==
name|GROUPP
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"%d"
argument_list|,
argument|(int)ARG(o)
argument_list|)
empty_stmt|;
comment|/* Parenth number */
elseif|else
if|if
condition|(
name|k
operator|==
name|LOGICAL
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"[%d]"
argument_list|,
argument|o->flags
argument_list|)
empty_stmt|;
comment|/* 2: embedded, otherwise 1 */
elseif|else
if|if
condition|(
name|k
operator|==
name|ANYOF
condition|)
block|{
name|int
name|i
decl_stmt|,
name|rangestart
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|out
index|[]
init|=
block|{
comment|/* Should be syncronized with 					   a table in regcomp.h */
literal|"\\w"
block|,
literal|"\\W"
block|,
literal|"\\s"
block|,
literal|"\\S"
block|,
literal|"\\d"
block|,
literal|"\\D"
block|,
literal|"[:alnum:]"
block|,
literal|"[:^alnum:]"
block|,
literal|"[:alpha:]"
block|,
literal|"[:^alpha:]"
block|,
literal|"[:ascii:]"
block|,
literal|"[:^ascii:]"
block|,
literal|"[:ctrl:]"
block|,
literal|"[:^ctrl:]"
block|,
literal|"[:graph:]"
block|,
literal|"[:^graph:]"
block|,
literal|"[:lower:]"
block|,
literal|"[:^lower:]"
block|,
literal|"[:print:]"
block|,
literal|"[:^print:]"
block|,
literal|"[:punct:]"
block|,
literal|"[:^punct:]"
block|,
literal|"[:upper:]"
block|,
literal|"[:!upper:]"
block|,
literal|"[:xdigit:]"
block|,
literal|"[:^xdigit:]"
block|}
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"{loc}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|ANYOF_FOLD
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"{i}"
argument_list|)
expr_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"[%s"
argument_list|,
argument|PL_colors[
literal|0
argument|]
argument_list|)
empty_stmt|;
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|ANYOF_INVERT
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|256
operator|&&
name|ANYOF_BITMAP_TEST
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|rangestart
operator|==
operator|-
literal|1
condition|)
name|rangestart
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rangestart
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|<=
name|rangestart
operator|+
literal|3
condition|)
for|for
control|(
init|;
name|rangestart
operator|<
name|i
condition|;
name|rangestart
operator|++
control|)
name|put_byte
argument_list|(
name|sv
argument_list|,
name|rangestart
argument_list|)
expr_stmt|;
else|else
block|{
name|put_byte
argument_list|(
name|sv
argument_list|,
name|rangestart
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|sv
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rangestart
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|ANYOF_CLASS
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|out
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ANYOF_CLASS_TEST
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|out
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"%s]"
argument_list|,
argument|PL_colors[
literal|1
argument|]
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|==
name|BRANCHJ
operator|&&
operator|(
name|OP
argument_list|(
name|o
argument_list|)
operator|==
name|UNLESSM
operator|||
name|OP
argument_list|(
name|o
argument_list|)
operator|==
name|IFMATCH
operator|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ sv
argument_list|,
literal|"[-%d]"
argument_list|,
argument|o->flags
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|SV
modifier|*
name|Perl_re_intuit_string
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|prog
parameter_list|)
block|{
comment|/* Assume that RE_INTUIT is set */
name|DEBUG_r
argument_list|(
argument|{   STRLEN n_a; 	    char *s = SvPV(prog->check_substr,n_a);  	    if (!PL_colorset) reginitcolors(); 	    PerlIO_printf(Perl_debug_log,
literal|"%sUsing REx substr:%s `%s%.60s%s%s'\n"
argument|, 		      PL_colors[
literal|4
argument|],PL_colors[
literal|5
argument|],PL_colors[
literal|0
argument|], 		      s, 		      PL_colors[
literal|1
argument|], 		      (strlen(s)>
literal|60
argument|?
literal|"..."
argument|:
literal|""
argument|)); 	}
argument_list|)
empty_stmt|;
return|return
name|prog
operator|->
name|check_substr
return|;
block|}
end_function

begin_function
name|void
name|Perl_pregfree
parameter_list|(
name|pTHX_
name|struct
name|regexp
modifier|*
name|r
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|if (!PL_colorset) reginitcolors()
argument_list|)
empty_stmt|;
if|if
condition|(
operator|!
name|r
operator|||
operator|(
operator|--
name|r
operator|->
name|refcnt
operator|>
literal|0
operator|)
condition|)
return|return;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sFreeing REx:%s `%s%.60s%s%s'\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|precomp
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strlen
argument_list|(
name|r
operator|->
name|precomp
argument_list|)
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|precomp
condition|)
name|Safefree
argument_list|(
name|r
operator|->
name|precomp
argument_list|)
expr_stmt|;
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|r
argument_list|)
condition|)
name|Safefree
argument_list|(
name|r
operator|->
name|subbeg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|substrs
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|anchored_substr
condition|)
name|SvREFCNT_dec
argument_list|(
name|r
operator|->
name|anchored_substr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|float_substr
condition|)
name|SvREFCNT_dec
argument_list|(
name|r
operator|->
name|float_substr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|substrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
condition|)
block|{
name|int
name|n
init|=
name|r
operator|->
name|data
operator|->
name|count
decl_stmt|;
name|AV
modifier|*
name|new_comppad
init|=
name|NULL
decl_stmt|;
name|AV
modifier|*
name|old_comppad
decl_stmt|;
name|SV
modifier|*
modifier|*
name|old_curpad
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|data
operator|->
name|what
index|[
name|n
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|Safefree
argument_list|(
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|new_comppad
operator|=
operator|(
name|AV
operator|*
operator|)
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|new_comppad
operator|==
name|NULL
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: pregfree comppad"
argument_list|)
expr_stmt|;
name|old_comppad
operator|=
name|PL_comppad
expr_stmt|;
name|old_curpad
operator|=
name|PL_curpad
expr_stmt|;
name|PL_comppad
operator|=
name|new_comppad
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|new_comppad
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
operator|(
name|OP_4tree
operator|*
operator|)
name|r
operator|->
name|data
operator|->
name|data
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|old_comppad
expr_stmt|;
name|PL_curpad
operator|=
name|old_curpad
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|new_comppad
argument_list|)
expr_stmt|;
name|new_comppad
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
break|break;
default|default:
name|FAIL2
argument_list|(
literal|"panic: regfree data code '%c'"
argument_list|,
name|r
operator|->
name|data
operator|->
name|what
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|Safefree
argument_list|(
name|r
operator|->
name|data
operator|->
name|what
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|r
operator|->
name|startp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|endp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regnext - dig the "next" pointer out of a node  *  * [Note, when REGALIGN is defined there are two places in regmatch()  * that bypass this code for speed.]  */
end_comment

begin_function
name|regnode
modifier|*
name|Perl_regnext
parameter_list|(
name|pTHX_
specifier|register
name|regnode
modifier|*
name|p
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|PL_regdummy
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|offset
operator|=
operator|(
name|reg_off_by_arg
index|[
name|OP
argument_list|(
name|p
argument_list|)
index|]
condition|?
name|ARG
argument_list|(
name|p
argument_list|)
else|:
name|NEXT_OFF
argument_list|(
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|p
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_re_croak2
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat1
parameter_list|,
specifier|const
name|char
modifier|*
name|pat2
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|STRLEN
name|l1
init|=
name|strlen
argument_list|(
name|pat1
argument_list|)
decl_stmt|;
name|STRLEN
name|l2
init|=
name|strlen
argument_list|(
name|pat2
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|SV
modifier|*
name|msv
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
if|if
condition|(
name|l1
operator|>
literal|510
condition|)
name|l1
operator|=
literal|510
expr_stmt|;
if|if
condition|(
name|l1
operator|+
name|l2
operator|>
literal|510
condition|)
name|l2
operator|=
literal|510
operator|-
name|l1
expr_stmt|;
name|Copy
argument_list|(
name|pat1
argument_list|,
name|buf
argument_list|,
name|l1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|pat2
argument_list|,
name|buf
operator|+
name|l1
argument_list|,
name|l2
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|buf
index|[
name|l1
operator|+
name|l2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|l1
operator|+
name|l2
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|I_STDARG
comment|/* ANSI variant takes additional second argument */
name|va_start
argument_list|(
name|args
argument_list|,
name|pat2
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msv
operator|=
name|vmess
argument_list|(
name|buf
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|message
operator|=
name|SvPV
argument_list|(
name|msv
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|>
literal|512
condition|)
name|l1
operator|=
literal|512
expr_stmt|;
name|Copy
argument_list|(
name|message
argument_list|,
name|buf
argument_list|,
name|l1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|buf
index|[
name|l1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Overwrite \n */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX Here's a total kludge.  But we need to re-enter for swash routines. */
end_comment

begin_function
name|void
name|Perl_save_re_context
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_bostr
argument_list|)
expr_stmt|;
name|SAVEPPTR
argument_list|(
name|PL_regprecomp
argument_list|)
expr_stmt|;
comment|/* uncompiled string. */
name|SAVEI32
argument_list|(
name|PL_regnpar
argument_list|)
expr_stmt|;
comment|/* () count. */
name|SAVEI32
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
comment|/* Code size. */
name|SAVEI16
argument_list|(
name|PL_regflags
argument_list|)
expr_stmt|;
comment|/* are we folding, multilining? */
name|SAVEPPTR
argument_list|(
name|PL_reginput
argument_list|)
expr_stmt|;
comment|/* String-input pointer. */
name|SAVEPPTR
argument_list|(
name|PL_regbol
argument_list|)
expr_stmt|;
comment|/* Beginning of input, for ^ check. */
name|SAVEPPTR
argument_list|(
name|PL_regeol
argument_list|)
expr_stmt|;
comment|/* End of input, for $ check. */
name|SAVEVPTR
argument_list|(
name|PL_regstartp
argument_list|)
expr_stmt|;
comment|/* Pointer to startp array. */
name|SAVEVPTR
argument_list|(
name|PL_regendp
argument_list|)
expr_stmt|;
comment|/* Ditto for endp. */
name|SAVEVPTR
argument_list|(
name|PL_reglastparen
argument_list|)
expr_stmt|;
comment|/* Similarly for lastparen. */
name|SAVEPPTR
argument_list|(
name|PL_regtill
argument_list|)
expr_stmt|;
comment|/* How far we are required to go. */
name|SAVEI8
argument_list|(
name|PL_regprev
argument_list|)
expr_stmt|;
comment|/* char before regbol, \n if none */
name|SAVEVPTR
argument_list|(
name|PL_reg_start_tmp
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|PL_reg_start_tmp
operator|=
literal|0
expr_stmt|;
name|SAVEFREEPV
argument_list|(
name|PL_reg_start_tmp
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_reg_start_tmpl
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|PL_reg_start_tmpl
operator|=
literal|0
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_regdata
argument_list|)
expr_stmt|;
name|SAVEI32
argument_list|(
name|PL_reg_flags
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEI32
argument_list|(
name|PL_reg_eval_set
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEI32
argument_list|(
name|PL_regnarrate
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_regprogram
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEINT
argument_list|(
name|PL_regindent
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_regcc
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|SAVEVPTR
argument_list|(
name|PL_regcomp_rx
argument_list|)
expr_stmt|;
comment|/* from regcomp.c */
name|SAVEI32
argument_list|(
name|PL_regseen
argument_list|)
expr_stmt|;
comment|/* from regcomp.c */
name|SAVEI32
argument_list|(
name|PL_regsawback
argument_list|)
expr_stmt|;
comment|/* Did we see \1, ...? */
name|SAVEI32
argument_list|(
name|PL_regnaughty
argument_list|)
expr_stmt|;
comment|/* How bad is this pattern? */
name|SAVEVPTR
argument_list|(
name|PL_regcode
argument_list|)
expr_stmt|;
comment|/* Code-emit pointer;&regdummy = don't */
name|SAVEPPTR
argument_list|(
name|PL_regxend
argument_list|)
expr_stmt|;
comment|/* End of input for compile */
name|SAVEPPTR
argument_list|(
name|PL_regcomp_parse
argument_list|)
expr_stmt|;
comment|/* Input-scan pointer. */
name|SAVEVPTR
argument_list|(
name|PL_reg_call_cc
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_reg_re
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEPPTR
argument_list|(
name|PL_reg_ganch
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVESPTR
argument_list|(
name|PL_reg_sv
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_reg_magic
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEI32
argument_list|(
name|PL_reg_oldpos
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_reg_oldcurpm
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
name|SAVEVPTR
argument_list|(
name|PL_reg_curpm
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
ifdef|#
directive|ifdef
name|DEBUGGING
name|SAVEPPTR
argument_list|(
name|PL_reg_starttry
argument_list|)
expr_stmt|;
comment|/* from regexec.c */
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_undef
undef|#
directive|undef
name|this
end_undef

begin_define
define|#
directive|define
name|this
value|pPerl
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|clear_re
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|r
parameter_list|)
block|{
name|ReREFCNT_dec
argument_list|(
operator|(
name|regexp
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

