begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    regexec.c  */
end_comment

begin_comment
comment|/*  * "One Ring to rule them all, One Ring to find them..."  */
end_comment

begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* The names of the functions have been changed from regcomp and  * regexec to  pregcomp and pregexec in order to avoid conflicts  * with the POSIX routines of the same names. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_EXT_RE_BUILD
end_ifdef

begin_comment
comment|/* need to replace pregcomp et al, so enable that */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_IN_XSUB_RE
end_ifndef

begin_define
define|#
directive|define
name|PERL_IN_XSUB_RE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* need access to debugger hooks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_comment
comment|/* We *really* need to overwrite these symbols: */
end_comment

begin_define
define|#
directive|define
name|Perl_regexec_flags
value|my_regexec
end_define

begin_define
define|#
directive|define
name|Perl_regdump
value|my_regdump
end_define

begin_define
define|#
directive|define
name|Perl_regprop
value|my_regprop
end_define

begin_comment
comment|/* *These* symbols are masked to allow static link. */
end_comment

begin_define
define|#
directive|define
name|Perl_pregexec
value|my_pregexec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * pregcomp and pregexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991-1999, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.  *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_define
define|#
directive|define
name|RF_tainted
value|1
end_define

begin_comment
comment|/* tainted information used? */
end_comment

begin_define
define|#
directive|define
name|RF_warned
value|2
end_define

begin_comment
comment|/* warned about big count? */
end_comment

begin_define
define|#
directive|define
name|RF_evaled
value|4
end_define

begin_comment
comment|/* Did an EVAL with setting? */
end_comment

begin_define
define|#
directive|define
name|RS_init
value|1
end_define

begin_comment
comment|/* eval environment created */
end_comment

begin_define
define|#
directive|define
name|RS_set
value|2
end_define

begin_comment
comment|/* replsv value is set */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_OBJECT
end_ifndef

begin_typedef
typedef|typedef
name|I32
name|CHECKPOINT
typedef|;
end_typedef

begin_comment
comment|/*  * Forwards.  */
end_comment

begin_decl_stmt
specifier|static
name|I32
name|regmatch
name|_
argument_list|(
operator|(
name|regnode
operator|*
name|prog
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|regrepeat
name|_
argument_list|(
operator|(
name|regnode
operator|*
name|p
operator|,
name|I32
name|max
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|regrepeat_hard
name|_
argument_list|(
operator|(
name|regnode
operator|*
name|p
operator|,
name|I32
name|max
operator|,
name|I32
operator|*
name|lp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|regtry
name|_
argument_list|(
operator|(
name|regexp
operator|*
name|prog
operator|,
name|char
operator|*
name|startpos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|reginclass
name|_
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|I32
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CHECKPOINT
name|regcppush
name|_
argument_list|(
operator|(
name|I32
name|parenfloor
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regcppop
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REGINCLASS
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
value|(*(p) ? reginclass(p,c) : ANYOF_TEST(p,c))
end_define

begin_function
name|STATIC
name|CHECKPOINT
name|regcppush
parameter_list|(
name|I32
name|parenfloor
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|retval
init|=
name|PL_savestack_ix
decl_stmt|;
name|int
name|i
init|=
operator|(
name|PL_regsize
operator|-
name|parenfloor
operator|)
operator|*
literal|4
decl_stmt|;
name|int
name|p
decl_stmt|;
name|SSCHECK
argument_list|(
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|PL_regsize
init|;
name|p
operator|>
name|parenfloor
condition|;
name|p
operator|--
control|)
block|{
name|SSPUSHPTR
argument_list|(
name|PL_regendp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHPTR
argument_list|(
name|PL_regstartp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHPTR
argument_list|(
name|PL_reg_start_tmp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|SSPUSHINT
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
operator|*
name|PL_reglastparen
argument_list|)
expr_stmt|;
name|SSPUSHPTR
argument_list|(
name|PL_reginput
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|SAVEt_REGCONTEXT
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* These are needed since we do not localize EVAL nodes: */
end_comment

begin_define
define|#
directive|define
name|REGCP_SET
value|DEBUG_r(PerlIO_printf(Perl_debug_log,		\ 			     "  Setting an EVAL scope, savestack=%i\n",	\ 			     PL_savestack_ix)); lastcp = PL_savestack_ix
end_define

begin_define
define|#
directive|define
name|REGCP_UNWIND
value|DEBUG_r(lastcp != PL_savestack_ix ?		\ 				PerlIO_printf(Perl_debug_log,		\ 				"  Clearing an EVAL scope, savestack=%i..%i\n", \ 				lastcp, PL_savestack_ix) : 0); regcpblow(lastcp)
end_define

begin_function
name|STATIC
name|char
modifier|*
name|regcppop
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|i
init|=
name|SSPOPINT
decl_stmt|;
name|U32
name|paren
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|assert
argument_list|(
name|i
operator|==
name|SAVEt_REGCONTEXT
argument_list|)
expr_stmt|;
name|i
operator|=
name|SSPOPINT
expr_stmt|;
name|input
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
operator|*
name|PL_reglastparen
operator|=
name|SSPOPINT
expr_stmt|;
name|PL_regsize
operator|=
name|SSPOPINT
expr_stmt|;
for|for
control|(
name|i
operator|-=
literal|3
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|4
control|)
block|{
name|paren
operator|=
operator|(
name|U32
operator|)
name|SSPOPINT
expr_stmt|;
name|PL_reg_start_tmp
index|[
name|paren
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
name|PL_regstartp
index|[
name|paren
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
name|tmps
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
if|if
condition|(
name|paren
operator|<=
operator|*
name|PL_reglastparen
condition|)
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|tmps
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|PerlIO_printf(Perl_debug_log,
literal|"     restoring \\%d to %d(%d)..%d%s\n"
argument|, 			  paren, PL_regstartp[paren] - PL_regbol,  			  PL_reg_start_tmp[paren] - PL_regbol, 			  PL_regendp[paren] - PL_regbol,  			  (paren> *PL_reglastparen ?
literal|"(no)"
argument|:
literal|""
argument|));
argument_list|)
empty_stmt|;
block|}
name|DEBUG_r
argument_list|(
argument|if (*PL_reglastparen +
literal|1
argument|<= PL_regnpar) { 	    PerlIO_printf(Perl_debug_log,
literal|"     restoring \\%d..\\%d to undef\n"
argument|, 			  *PL_reglastparen +
literal|1
argument|, PL_regnpar); 	}
argument_list|)
empty_stmt|;
for|for
control|(
name|paren
operator|=
operator|*
name|PL_reglastparen
operator|+
literal|1
init|;
name|paren
operator|<=
name|PL_regnpar
condition|;
name|paren
operator|++
control|)
block|{
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|Nullch
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|Nullch
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
end_function

begin_define
define|#
directive|define
name|regcpblow
parameter_list|(
name|cp
parameter_list|)
value|LEAVE_SCOPE(cp)
end_define

begin_comment
comment|/*  * pregexec and friends  */
end_comment

begin_comment
comment|/*  - pregexec - match a regexp against a string  */
end_comment

begin_function
name|I32
name|pregexec
parameter_list|(
specifier|register
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|stringarg
parameter_list|,
specifier|register
name|char
modifier|*
name|strend
parameter_list|,
name|char
modifier|*
name|strbeg
parameter_list|,
name|I32
name|minend
parameter_list|,
name|SV
modifier|*
name|screamer
parameter_list|,
name|U32
name|nosave
parameter_list|)
comment|/* strend: pointer to null at end of string */
comment|/* strbeg: real beginning of string */
comment|/* minend: end of match must be>=minend after stringarg. */
comment|/* nosave: For optimizations. */
block|{
return|return
name|regexec_flags
argument_list|(
name|prog
argument_list|,
name|stringarg
argument_list|,
name|strend
argument_list|,
name|strbeg
argument_list|,
name|minend
argument_list|,
name|screamer
argument_list|,
name|NULL
argument_list|,
name|nosave
condition|?
literal|0
else|:
name|REXEC_COPY_STR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  - regexec_flags - match a regexp against a string  */
end_comment

begin_function
name|I32
name|regexec_flags
parameter_list|(
specifier|register
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|stringarg
parameter_list|,
specifier|register
name|char
modifier|*
name|strend
parameter_list|,
name|char
modifier|*
name|strbeg
parameter_list|,
name|I32
name|minend
parameter_list|,
name|SV
modifier|*
name|screamer
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|U32
name|flags
parameter_list|)
comment|/* strend: pointer to null at end of string */
comment|/* strbeg: real beginning of string */
comment|/* minend: end of match must be>=minend after stringarg. */
comment|/* data: May be used for some additional optimizations. */
comment|/* nosave: For optimizations. */
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|startpos
init|=
name|stringarg
decl_stmt|;
specifier|register
name|I32
name|tmp
decl_stmt|;
name|I32
name|minlen
decl_stmt|;
comment|/* must match at least this many chars */
name|I32
name|dontbother
init|=
literal|0
decl_stmt|;
comment|/* how many characters not to try at end */
name|CURCUR
name|cc
decl_stmt|;
name|I32
name|start_shift
init|=
literal|0
decl_stmt|;
comment|/* Offset of the start to find 					 constant substr. */
name|I32
name|end_shift
init|=
literal|0
decl_stmt|;
comment|/* Same for the end. */
name|I32
name|scream_pos
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Internal iterator of scream. */
name|char
modifier|*
name|scream_olds
decl_stmt|;
name|SV
modifier|*
name|oreplsv
init|=
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
decl_stmt|;
name|cc
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
name|cc
operator|.
name|oldcc
operator|=
literal|0
expr_stmt|;
name|PL_regcc
operator|=
operator|&
name|cc
expr_stmt|;
name|PL_regprecomp
operator|=
name|prog
operator|->
name|precomp
expr_stmt|;
comment|/* Needed for error messages. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regnarrate
operator|=
name|PL_debug
operator|&
literal|512
expr_stmt|;
name|PL_regprogram
operator|=
name|prog
operator|->
name|program
expr_stmt|;
endif|#
directive|endif
comment|/* Be paranoid... */
if|if
condition|(
name|prog
operator|==
name|NULL
operator|||
name|startpos
operator|==
name|NULL
condition|)
block|{
name|croak
argument_list|(
literal|"NULL regexp parameter"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|minlen
operator|=
name|prog
operator|->
name|minlen
expr_stmt|;
if|if
condition|(
name|strend
operator|-
name|startpos
operator|<
name|minlen
condition|)
goto|goto
name|phooey
goto|;
if|if
condition|(
name|startpos
operator|==
name|strbeg
condition|)
comment|/* is ^ valid at stringarg? */
name|PL_regprev
operator|=
literal|'\n'
expr_stmt|;
else|else
block|{
name|PL_regprev
operator|=
name|stringarg
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|PL_multiline
operator|&&
name|PL_regprev
operator|==
literal|'\n'
condition|)
name|PL_regprev
operator|=
literal|'\0'
expr_stmt|;
comment|/* force ^ to NOT match */
block|}
comment|/* Check validity of program. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|prog
operator|->
name|program
argument_list|)
operator|!=
name|MAGIC
condition|)
block|{
name|FAIL
argument_list|(
literal|"corrupted regexp program"
argument_list|)
expr_stmt|;
block|}
name|PL_regnpar
operator|=
name|prog
operator|->
name|nparens
expr_stmt|;
name|PL_reg_flags
operator|=
literal|0
expr_stmt|;
name|PL_reg_eval_set
operator|=
literal|0
expr_stmt|;
comment|/* If there is a "must appear" string, look for it. */
name|s
operator|=
name|startpos
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REXEC_CHECKED
operator|)
operator|&&
name|prog
operator|->
name|check_substr
operator|!=
name|Nullsv
operator|&&
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
operator|(
name|ROPT_ANCH_BOL
operator||
name|ROPT_ANCH_MBOL
operator|)
operator|)
operator|||
operator|(
name|PL_multiline
operator|&&
name|prog
operator|->
name|check_substr
operator|==
name|prog
operator|->
name|anchored_substr
operator|)
operator|)
condition|)
block|{
name|start_shift
operator|=
name|prog
operator|->
name|check_offset_min
expr_stmt|;
comment|/* Should be nonnegative! */
name|end_shift
operator|=
name|minlen
operator|-
name|start_shift
operator|-
name|SvCUR
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
if|if
condition|(
name|screamer
condition|)
block|{
if|if
condition|(
name|PL_screamfirst
index|[
name|BmRARE
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
index|]
operator|>=
literal|0
condition|)
name|s
operator|=
name|screaminstr
argument_list|(
name|screamer
argument_list|,
name|prog
operator|->
name|check_substr
argument_list|,
name|start_shift
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
argument_list|,
name|end_shift
argument_list|,
operator|&
name|scream_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|Nullch
expr_stmt|;
name|scream_olds
operator|=
name|s
expr_stmt|;
block|}
else|else
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|+
name|start_shift
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
operator|-
name|end_shift
argument_list|,
name|prog
operator|->
name|check_substr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
operator|++
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
comment|/* hooray */
goto|goto
name|phooey
goto|;
comment|/* not present */
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|-
name|stringarg
operator|)
operator|>
name|prog
operator|->
name|check_offset_max
condition|)
block|{
operator|++
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
comment|/* hooray/2 */
name|s
operator|-=
name|prog
operator|->
name|check_offset_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prog
operator|->
name|naughty
operator|&&
operator|--
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
operator|<
literal|0
operator|&&
name|prog
operator|->
name|check_substr
operator|==
name|prog
operator|->
name|float_substr
condition|)
block|{
comment|/* boo */
name|SvREFCNT_dec
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
name|prog
operator|->
name|check_substr
operator|=
name|Nullsv
expr_stmt|;
comment|/* disable */
name|prog
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
comment|/* clear */
name|s
operator|=
name|startpos
expr_stmt|;
block|}
else|else
name|s
operator|=
name|startpos
expr_stmt|;
block|}
comment|/* Mark beginning of line for ^ and lookbehind. */
name|PL_regbol
operator|=
name|startpos
expr_stmt|;
name|PL_bostr
operator|=
name|strbeg
expr_stmt|;
comment|/* Mark end of line for $ (and such) */
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* see how far we have to get to not match where we matched before */
name|PL_regtill
operator|=
name|startpos
operator|+
name|minend
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Matching `%.60s%s' against `%.*s%s'\n"
argument_list|,
name|prog
operator|->
name|precomp
argument_list|,
operator|(
name|strlen
argument_list|(
name|prog
operator|->
name|precomp
argument_list|)
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|,
operator|(
name|strend
operator|-
name|startpos
operator|>
literal|60
condition|?
literal|60
else|:
name|strend
operator|-
name|startpos
operator|)
argument_list|,
name|startpos
argument_list|,
operator|(
name|strend
operator|-
name|startpos
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplest case:  anchored match need be tried only once. */
comment|/*  [unless only anchor is BOL and multiline is set] */
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|startpos
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
operator|&&
operator|(
name|PL_multiline
operator|||
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
operator|)
operator|||
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_MBOL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* for multiline we only have to try after newlines */
if|if
condition|(
name|s
operator|>
name|startpos
condition|)
name|s
operator|--
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
comment|/* Messy cases:  unanchored match. */
if|if
condition|(
name|prog
operator|->
name|anchored_substr
operator|&&
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
block|{
comment|/* we have /x+whatever/ */
comment|/* it must be a one character string */
name|char
name|ch
init|=
name|SvPVX
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|ch
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|==
name|ch
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|prog
operator|->
name|anchored_substr
operator|!=
name|Nullsv
operator|||
operator|(
name|prog
operator|->
name|float_substr
operator|!=
name|Nullsv
operator|&&
name|prog
operator|->
name|float_max_offset
operator|<
name|strend
operator|-
name|s
operator|)
condition|)
block|{
name|SV
modifier|*
name|must
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_substr
else|:
name|prog
operator|->
name|float_substr
decl_stmt|;
name|I32
name|back_max
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_offset
else|:
name|prog
operator|->
name|float_max_offset
decl_stmt|;
name|I32
name|back_min
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_offset
else|:
name|prog
operator|->
name|float_min_offset
decl_stmt|;
name|I32
name|delta
init|=
name|back_max
operator|-
name|back_min
decl_stmt|;
name|char
modifier|*
name|last
init|=
name|strend
operator|-
name|SvCUR
argument_list|(
name|must
argument_list|)
operator|-
name|back_min
decl_stmt|;
comment|/* Cannot start after this */
name|char
modifier|*
name|last1
init|=
name|s
operator|-
literal|1
decl_stmt|;
comment|/* Last position checked before */
comment|/* XXXX check_substr already used to find `s', can optimize if 	   check_substr==must. */
name|scream_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|dontbother
operator|=
name|end_shift
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<=
name|last
operator|)
operator|&&
operator|(
name|screamer
condition|?
operator|(
name|s
operator|=
name|screaminstr
argument_list|(
name|screamer
argument_list|,
name|must
argument_list|,
name|s
operator|+
name|back_min
operator|-
name|strbeg
argument_list|,
name|end_shift
argument_list|,
operator|&
name|scream_pos
argument_list|,
literal|0
argument_list|)
operator|)
else|:
operator|(
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|+
name|back_min
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|must
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|-
name|back_max
operator|>
name|last1
condition|)
block|{
name|last1
operator|=
name|s
operator|-
name|back_min
expr_stmt|;
name|s
operator|=
name|s
operator|-
name|back_max
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|t
init|=
name|last1
operator|+
literal|1
decl_stmt|;
name|last1
operator|=
name|s
operator|-
name|back_min
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<=
name|last1
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|=
name|prog
operator|->
name|regstclass
condition|)
block|{
name|I32
name|doevery
init|=
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
operator|)
operator|==
literal|0
decl_stmt|;
name|char
modifier|*
name|Class
decl_stmt|;
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* don't bother with what can't match */
name|tmp
operator|=
literal|1
expr_stmt|;
comment|/* We know what class it must start with. */
switch|switch
condition|(
name|OP
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|ANYOF
case|:
name|Class
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|REGINCLASS
argument_list|(
name|Class
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUND
case|:
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|++
operator|,
name|strend
operator|--
expr_stmt|;
name|tmp
operator|=
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|UCHARAT
argument_list|(
name|s
operator|-
literal|1
argument_list|)
else|:
name|PL_regprev
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUND
condition|?
name|isALNUM
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUND
condition|?
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minlen
operator|||
name|tmp
operator|)
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|NBOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NBOUND
case|:
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|++
operator|,
name|strend
operator|--
expr_stmt|;
name|tmp
operator|=
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|UCHARAT
argument_list|(
name|s
operator|-
literal|1
argument_list|)
else|:
name|PL_regprev
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUND
condition|?
name|isALNUM
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUND
condition|?
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minlen
operator|||
operator|!
name|tmp
operator|)
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|dontbother
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|float_substr
operator|!=
name|Nullsv
condition|)
block|{
comment|/* Trim the end. */
name|char
modifier|*
name|last
decl_stmt|;
name|I32
name|oldpos
init|=
name|scream_pos
decl_stmt|;
if|if
condition|(
name|screamer
condition|)
block|{
name|last
operator|=
name|screaminstr
argument_list|(
name|screamer
argument_list|,
name|prog
operator|->
name|float_substr
argument_list|,
name|s
operator|-
name|strbeg
argument_list|,
name|end_shift
argument_list|,
operator|&
name|scream_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* last one */
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|last
operator|=
name|scream_olds
expr_stmt|;
comment|/* Only one occurence. */
block|}
block|}
else|else
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|little
init|=
name|SvPV
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
name|last
operator|=
name|rninstr
argument_list|(
name|s
argument_list|,
name|strend
argument_list|,
name|little
argument_list|,
name|little
operator|+
name|len
argument_list|)
expr_stmt|;
else|else
name|last
operator|=
name|strend
expr_stmt|;
comment|/* matching `$' */
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
goto|goto
name|phooey
goto|;
comment|/* Should not happen! */
name|dontbother
operator|=
name|strend
operator|-
name|last
operator|+
name|prog
operator|->
name|float_min_offset
expr_stmt|;
block|}
if|if
condition|(
name|minlen
operator|&&
operator|(
name|dontbother
operator|<
name|minlen
operator|)
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* We don't know much -- general case. */
do|do
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
do|while
condition|(
name|s
operator|++
operator|<
name|strend
condition|)
do|;
block|}
comment|/* Failure. */
goto|goto
name|phooey
goto|;
name|got_it
label|:
name|prog
operator|->
name|subbeg
operator|=
name|strbeg
expr_stmt|;
name|prog
operator|->
name|subend
operator|=
name|PL_regeol
expr_stmt|;
comment|/* strend may have been modified */
name|RX_MATCH_TAINTED_set
argument_list|(
name|prog
argument_list|,
name|PL_reg_flags
operator|&
name|RF_tainted
argument_list|)
expr_stmt|;
comment|/* make sure $`, $&, $', and $digit will work later */
if|if
condition|(
name|strbeg
operator|!=
name|prog
operator|->
name|subbase
condition|)
block|{
comment|/* second+ //g match.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REXEC_COPY_STR
operator|)
condition|)
block|{
if|if
condition|(
name|prog
operator|->
name|subbase
condition|)
block|{
name|Safefree
argument_list|(
name|prog
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|prog
operator|->
name|subbase
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
else|else
block|{
name|I32
name|i
init|=
name|PL_regeol
operator|-
name|startpos
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
decl_stmt|;
name|s
operator|=
name|savepvn
argument_list|(
name|strbeg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|prog
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|prog
operator|->
name|subbase
operator|=
name|s
expr_stmt|;
name|prog
operator|->
name|subbeg
operator|=
name|prog
operator|->
name|subbase
expr_stmt|;
name|prog
operator|->
name|subend
operator|=
name|prog
operator|->
name|subbase
operator|+
name|i
expr_stmt|;
name|s
operator|=
name|prog
operator|->
name|subbase
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|prog
operator|->
name|nparens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prog
operator|->
name|endp
index|[
name|i
index|]
condition|)
block|{
name|prog
operator|->
name|startp
index|[
name|i
index|]
operator|=
name|s
operator|+
operator|(
name|prog
operator|->
name|startp
index|[
name|i
index|]
operator|-
name|startpos
operator|)
expr_stmt|;
name|prog
operator|->
name|endp
index|[
name|i
index|]
operator|=
name|s
operator|+
operator|(
name|prog
operator|->
name|endp
index|[
name|i
index|]
operator|-
name|startpos
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Preserve the current value of $^R */
if|if
condition|(
name|oreplsv
operator|!=
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
condition|)
block|{
name|sv_setsv
argument_list|(
name|oreplsv
argument_list|,
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* So that when GvSV(replgv) is 					   restored, the value remains 					   the same. */
block|}
return|return
literal|1
return|;
name|phooey
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regtry - try match at specific point  */
end_comment

begin_function
name|STATIC
name|I32
comment|/* 0 failure, 1 success */
name|regtry
parameter_list|(
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|startpos
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|CHECKPOINT
name|lastcp
decl_stmt|;
if|if
condition|(
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
operator|)
operator|&&
operator|!
name|PL_reg_eval_set
condition|)
block|{
name|PL_reg_eval_set
operator|=
name|RS_init
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|DEBUG_s( 	    PerlIO_printf(Perl_debug_log,
literal|"  setting stack tmpbase at %i\n"
argument|, 			  PL_stack_sp - PL_stack_base); 	    )
argument_list|)
empty_stmt|;
name|SAVEINT
argument_list|(
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
argument_list|)
expr_stmt|;
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
operator|=
name|PL_stack_sp
operator|-
name|PL_stack_base
expr_stmt|;
comment|/* Otherwise OP_NEXTSTATE will free whatever on stack now.  */
name|SAVETMPS
expr_stmt|;
comment|/* Apparently this is not needed, judging by wantarray. */
comment|/* SAVEINT(cxstack[cxstack_ix].blk_gimme); 	   cxstack[cxstack_ix].blk_gimme = G_SCALAR; */
block|}
name|PL_reginput
operator|=
name|startpos
expr_stmt|;
name|PL_regstartp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|PL_regendp
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
name|PL_reglastparen
operator|=
operator|&
name|prog
operator|->
name|lastparen
expr_stmt|;
name|prog
operator|->
name|lastparen
operator|=
literal|0
expr_stmt|;
name|PL_regsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PL_reg_start_tmpl
operator|<=
name|prog
operator|->
name|nparens
condition|)
block|{
name|PL_reg_start_tmpl
operator|=
name|prog
operator|->
name|nparens
operator|*
literal|3
operator|/
literal|2
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|PL_reg_start_tmp
condition|)
name|Renew
argument_list|(
name|PL_reg_start_tmp
argument_list|,
name|PL_reg_start_tmpl
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|22
argument_list|,
name|PL_reg_start_tmp
argument_list|,
name|PL_reg_start_tmpl
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|ep
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
name|PL_regdata
operator|=
name|prog
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|nparens
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prog
operator|->
name|nparens
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|sp
operator|++
operator|=
name|NULL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|prog
operator|->
name|program
operator|+
literal|1
argument_list|)
condition|)
block|{
name|prog
operator|->
name|startp
index|[
literal|0
index|]
operator|=
name|startpos
expr_stmt|;
name|prog
operator|->
name|endp
index|[
literal|0
index|]
operator|=
name|PL_reginput
expr_stmt|;
return|return
literal|1
return|;
block|}
name|REGCP_UNWIND
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regmatch - main matching routine  *  * Conceptually the strategy is simple:  check to see whether the current  * node matches, call self recursively to see whether the rest matches,  * and then act accordingly.  In practice we make some effort to avoid  * recursion, in particular by going through "ordinary" nodes (that don't  * need to know whether the rest of the match failed) by a loop instead of  * by recursion.  */
end_comment

begin_comment
comment|/* [lwall] I've hoisted the register declarations to the outer block in order to  * maybe save a little bit of pushing and popping on the stack.  It also takes  * advantage of machines that use a register save mask on subroutine entry.  */
end_comment

begin_function
name|STATIC
name|I32
comment|/* 0 failure, 1 success */
name|regmatch
parameter_list|(
name|regnode
modifier|*
name|prog
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|scan
decl_stmt|;
comment|/* Current node. */
name|regnode
modifier|*
name|next
decl_stmt|;
comment|/* Next node. */
name|regnode
modifier|*
name|inner
decl_stmt|;
comment|/* Next node in internal branch. */
specifier|register
name|I32
name|nextchr
decl_stmt|;
comment|/* renamed nextchr - nextchar colides with 				   function of same name */
specifier|register
name|I32
name|n
decl_stmt|;
comment|/* no or next */
specifier|register
name|I32
name|ln
decl_stmt|;
comment|/* len or last */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* operand or save */
specifier|register
name|char
modifier|*
name|locinput
init|=
name|PL_reginput
decl_stmt|;
specifier|register
name|I32
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|paren
decl_stmt|;
comment|/* case fold search, parenth */
name|int
name|minmod
init|=
literal|0
decl_stmt|,
name|sw
init|=
literal|0
decl_stmt|,
name|logical
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|++
expr_stmt|;
endif|#
directive|endif
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
name|scan
operator|=
name|prog
expr_stmt|;
while|while
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
define|#
directive|define
name|sayNO_L
value|(logical ? (logical = 0, sw = 0, goto cont) : sayNO)
ifdef|#
directive|ifdef
name|DEBUGGING
define|#
directive|define
name|sayYES
value|goto yes
define|#
directive|define
name|sayNO
value|goto no
define|#
directive|define
name|saySAME
parameter_list|(
name|x
parameter_list|)
value|if (x) goto yes; else goto no
define|#
directive|define
name|REPORT_CODE_OFF
value|24
else|#
directive|else
define|#
directive|define
name|sayYES
value|return 1
define|#
directive|define
name|sayNO
value|return 0
define|#
directive|define
name|saySAME
parameter_list|(
name|x
parameter_list|)
value|return x
endif|#
directive|endif
name|DEBUG_r
argument_list|(
argument|{ 	    SV *prop = sv_newmortal(); 	    int docolor = *PL_colors[
literal|0
argument|]; 	    int taill = (docolor ?
literal|10
argument|:
literal|7
argument|);
comment|/* 3 chars for "><" */
argument|int l = (PL_regeol - locinput> taill ? taill : PL_regeol - locinput); 	    int pref_len = (locinput - PL_bostr> (
literal|5
argument|+ taill) - l  			    ? (
literal|5
argument|+ taill) - l : locinput - PL_bostr);  	    if (l + pref_len< (
literal|5
argument|+ taill)&& l< PL_regeol - locinput) 		l = ( PL_regeol - locinput> (
literal|5
argument|+ taill) - pref_len  		      ? (
literal|5
argument|+ taill) - pref_len : PL_regeol - locinput); 	    regprop(prop, scan); 	    PerlIO_printf(Perl_debug_log,
literal|"%4i<%s%.*s%s%s%s%.*s%s>%*s|%3d:%*s%s\n"
argument|, 			  locinput - PL_bostr,  			  PL_colors[
literal|2
argument|], pref_len, locinput - pref_len, PL_colors[
literal|3
argument|], 			  (docolor ?
literal|""
argument|:
literal|"><"
argument|), 			  PL_colors[
literal|0
argument|], l, locinput, PL_colors[
literal|1
argument|],
literal|15
argument|- l - pref_len +
literal|1
argument|,
literal|""
argument|, 			  scan - PL_regprogram, PL_regindent*
literal|2
argument|,
literal|""
argument|, 			  SvPVX(prop)); 	}
argument_list|)
empty_stmt|;
name|next
operator|=
name|scan
operator|+
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_bostr
condition|?
name|PL_regprev
operator|==
literal|'\n'
else|:
operator|(
name|PL_multiline
operator|&&
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|locinput
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* PL_regtill = PL_regbol; */
break|break;
block|}
name|sayNO
expr_stmt|;
case|case
name|MBOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_bostr
condition|?
name|PL_regprev
operator|==
literal|'\n'
else|:
operator|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|locinput
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
name|sayNO
expr_stmt|;
case|case
name|SBOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_regbol
operator|&&
name|PL_regprev
operator|==
literal|'\n'
condition|)
break|break;
name|sayNO
expr_stmt|;
case|case
name|GPOS
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_regbol
condition|)
break|break;
name|sayNO
expr_stmt|;
case|case
name|EOL
case|:
if|if
condition|(
name|PL_multiline
condition|)
goto|goto
name|meol
goto|;
else|else
goto|goto
name|seol
goto|;
case|case
name|MEOL
case|:
name|meol
label|:
if|if
condition|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|nextchr
operator|!=
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SEOL
case|:
name|seol
label|:
if|if
condition|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|nextchr
operator|!=
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|>
literal|1
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|EOS
case|:
if|if
condition|(
name|PL_regeol
operator|!=
name|locinput
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SANY
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANY
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
operator|||
name|nextchr
operator|==
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACT
case|:
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|ln
operator|=
name|UCHARAT
argument_list|(
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
name|memNE
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACTFL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|EXACTF
case|:
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|ln
operator|=
name|UCHARAT
argument_list|(
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
operator|&&
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
operator|(
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTF
operator|)
condition|?
name|fold
else|:
name|fold_locale
operator|)
index|[
name|nextchr
index|]
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchr
operator|<
literal|0
condition|)
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REGINCLASS
argument_list|(
name|s
argument_list|,
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ALNUM
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|ALNUM
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NALNUM
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NALNUM
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUNDL
case|:
case|case
name|NBOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUND
case|:
case|case
name|NBOUND
case|:
comment|/* was last char in word? */
name|ln
operator|=
operator|(
name|locinput
operator|!=
name|PL_regbol
operator|)
condition|?
name|UCHARAT
argument_list|(
name|locinput
operator|-
literal|1
argument_list|)
else|:
name|PL_regprev
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUND
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NBOUND
condition|)
block|{
name|ln
operator|=
name|isALNUM
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|isALNUM_LC
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|!
name|ln
operator|)
operator|==
operator|(
operator|!
name|n
operator|)
operator|)
operator|==
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUND
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUNDL
operator|)
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SPACE
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SPACE
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NSPACE
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SPACE
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFFL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|REF
case|:
case|case
name|REFF
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|s
operator|=
name|PL_regstartp
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|PL_reglastparen
operator|<
name|n
operator|||
operator|!
name|s
condition|)
name|sayNO
expr_stmt|;
comment|/* Do not match unless seen CLOSEn. */
if|if
condition|(
name|s
operator|==
name|PL_regendp
index|[
name|n
index|]
condition|)
break|break;
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REF
operator|||
operator|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
operator|(
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REFF
condition|?
name|fold
else|:
name|fold_locale
operator|)
index|[
name|nextchr
index|]
operator|)
operator|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|ln
operator|=
name|PL_regendp
index|[
name|n
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|locinput
operator|+
name|ln
operator|>
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REF
condition|?
name|memNE
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REFF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
case|case
name|TAIL
case|:
break|break;
case|case
name|BACK
case|:
break|break;
case|case
name|EVAL
case|:
block|{
name|dSP
expr_stmt|;
name|OP_4tree
modifier|*
name|oop
init|=
name|PL_op
decl_stmt|;
name|COP
modifier|*
name|ocurcop
init|=
name|PL_curcop
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ocurpad
init|=
name|PL_curpad
decl_stmt|;
name|SV
modifier|*
name|ret
decl_stmt|;
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP_4tree
operator|*
operator|)
name|PL_regdata
operator|->
name|data
index|[
name|n
index|]
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  re_eval 0x%x\n"
argument_list|,
name|PL_op
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|PL_regdata
operator|->
name|data
index|[
name|n
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|CALLRUNOPS
argument_list|()
expr_stmt|;
comment|/* Scalar context. */
name|SPAGAIN
expr_stmt|;
name|ret
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|logical
condition|)
block|{
name|logical
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
name|SvTRUE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setsv
argument_list|(
name|save_scalar
argument_list|(
name|PL_replgv
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|PL_op
operator|=
name|oop
expr_stmt|;
name|PL_curpad
operator|=
name|ocurpad
expr_stmt|;
name|PL_curcop
operator|=
name|ocurcop
expr_stmt|;
break|break;
block|}
case|case
name|OPEN
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|PL_reg_start_tmp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|PL_regstartp
index|[
name|n
index|]
operator|=
name|PL_reg_start_tmp
index|[
name|n
index|]
expr_stmt|;
name|PL_regendp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|GROUPP
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|sw
operator|=
operator|(
operator|*
name|PL_reglastparen
operator|>=
name|n
operator|&&
name|PL_regendp
index|[
name|n
index|]
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|IFTHEN
case|:
if|if
condition|(
name|sw
condition|)
name|next
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|IFTHEN
condition|)
comment|/* Fake one. */
name|next
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOGICAL
case|:
name|logical
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CURLYX
case|:
block|{
name|CURCUR
name|cc
decl_stmt|;
name|CHECKPOINT
name|cp
init|=
name|PL_savestack_ix
decl_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|PREVOPER
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|NOTHING
condition|)
comment|/* LONGJMP */
name|next
operator|+=
name|ARG
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|cc
operator|.
name|oldcc
operator|=
name|PL_regcc
expr_stmt|;
name|PL_regcc
operator|=
operator|&
name|cc
expr_stmt|;
name|cc
operator|.
name|parenfloor
operator|=
operator|*
name|PL_reglastparen
expr_stmt|;
name|cc
operator|.
name|cur
operator|=
operator|-
literal|1
expr_stmt|;
name|cc
operator|.
name|min
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|cc
operator|.
name|max
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|cc
operator|.
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
expr_stmt|;
name|cc
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|cc
operator|.
name|minmod
operator|=
name|minmod
expr_stmt|;
name|cc
operator|.
name|lastloc
operator|=
literal|0
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|n
operator|=
name|regmatch
argument_list|(
name|PREVOPER
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start on the WHILEM */
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PL_regcc
operator|=
name|cc
operator|.
name|oldcc
expr_stmt|;
name|saySAME
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* NOT REACHED */
case|case
name|WHILEM
case|:
block|{
comment|/* 		 * This is really hard to understand, because after we match 		 * what we're trying to match, we must make sure the rest of 		 * the RE is going to match for sure, and to do that we have 		 * to go back UP the parse tree by recursing ever deeper.  And 		 * if it fails, we have to reset our parent's current state 		 * that we can try again after backing off. 		 */
name|CHECKPOINT
name|cp
decl_stmt|,
name|lastcp
decl_stmt|;
name|CURCUR
modifier|*
name|cc
init|=
name|PL_regcc
decl_stmt|;
name|char
modifier|*
name|lastloc
init|=
name|cc
operator|->
name|lastloc
decl_stmt|;
comment|/* Detection of 0-len. */
name|n
operator|=
name|cc
operator|->
name|cur
operator|+
literal|1
expr_stmt|;
comment|/* how many we know we matched */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  %ld out of %ld..%ld  cc=%lx\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|long
operator|)
name|cc
operator|->
name|min
argument_list|,
operator|(
name|long
operator|)
name|cc
operator|->
name|max
argument_list|,
operator|(
name|long
operator|)
name|cc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If degenerate scan matches "", assume scan done. */
if|if
condition|(
name|locinput
operator|==
name|cc
operator|->
name|lastloc
operator|&&
name|n
operator|>=
name|cc
operator|->
name|min
condition|)
block|{
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  empty match detected, try continuation...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* First just match a string of min scans. */
if|if
condition|(
name|n
operator|<
name|cc
operator|->
name|min
condition|)
block|{
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* Prefer next over scan for minimal matching. */
if|if
condition|(
name|cc
operator|->
name|minmod
condition|)
block|{
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
comment|/* All done. */
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|cc
operator|->
name|max
condition|)
block|{
comment|/* Maximum greed exceeded? */
if|if
condition|(
name|PL_dowarn
operator|&&
name|n
operator|>=
name|REG_INFTY
operator|&&
operator|!
operator|(
name|PL_reg_flags
operator|&
name|RF_warned
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_warned
expr_stmt|;
name|warn
argument_list|(
literal|"%s limit (%d) exceeded"
argument_list|,
literal|"Complex regular subexpression recursion"
argument_list|,
name|REG_INFTY
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sayNO
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  trying longer...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try scanning more and see if it helps. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* Prefer scan over next for maximal matching. */
if|if
condition|(
name|n
operator|<
name|cc
operator|->
name|max
condition|)
block|{
comment|/* More greed allowed? */
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
comment|/* Restore some previous $<digit>s? */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed, try continuation...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_dowarn
operator|&&
name|n
operator|>=
name|REG_INFTY
operator|&&
operator|!
operator|(
name|PL_reg_flags
operator|&
name|RF_warned
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_warned
expr_stmt|;
name|warn
argument_list|(
literal|"%s limit (%d) exceeded"
argument_list|,
literal|"Complex regular subexpression recursion"
argument_list|,
name|REG_INFTY
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Failed deeper matches of scan, so see if this one works. */
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* NOT REACHED */
case|case
name|BRANCHJ
case|:
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|BRANCH
case|:
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|do_branch
label|:
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|c1
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|c1
condition|)
comment|/* No choice. */
name|next
operator|=
name|inner
expr_stmt|;
comment|/* Avoid recursion. */
else|else
block|{
name|int
name|lastparen
init|=
operator|*
name|PL_reglastparen
decl_stmt|;
name|REGCP_SET
expr_stmt|;
do|do
block|{
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|inner
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
for|for
control|(
name|n
operator|=
operator|*
name|PL_reglastparen
init|;
name|n
operator|>
name|lastparen
condition|;
name|n
operator|--
control|)
name|PL_regendp
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|PL_reglastparen
operator|=
name|n
expr_stmt|;
name|scan
operator|=
name|next
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|n
operator|=
operator|(
name|c1
operator|==
name|BRANCH
condition|?
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
else|:
name|ARG
argument_list|(
name|next
argument_list|)
operator|)
condition|)
name|next
operator|+=
name|n
expr_stmt|;
else|else
name|next
operator|=
name|NULL
expr_stmt|;
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|BRANCHJ
condition|)
block|{
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|c1
condition|)
do|;
name|sayNO
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
break|break;
case|case
name|MINMOD
case|:
name|minmod
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CURLYM
case|:
block|{
name|I32
name|l
init|=
literal|0
decl_stmt|;
name|CHECKPOINT
name|lastcp
decl_stmt|;
comment|/* We suppose that the next guy does not need 	       backtracking: in particular, it is of constant length, 	       and has no parenths to influence future backrefs. */
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|paren
operator|=
name|scan
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|paren
expr_stmt|;
if|if
condition|(
name|paren
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|paren
expr_stmt|;
block|}
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
if|if
condition|(
name|paren
condition|)
name|scan
operator|+=
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Skip former OPEN. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|minmod
condition|)
block|{
name|minmod
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
name|ln
argument_list|,
operator|&
name|l
argument_list|)
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|l
operator|==
literal|0
operator|&&
name|n
operator|>=
name|ln
comment|/* In fact, this is tricky.  If paren, then the 		       fact that we did/didnot match may influence 		       future execution. */
operator|&&
operator|!
operator|(
name|paren
operator|&&
name|ln
operator|==
literal|0
operator|)
condition|)
name|ln
operator|=
name|n
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
name|UCHARAT
argument_list|(
name|OPERAND
argument_list|(
name|next
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
name|REGCP_SET
expr_stmt|;
comment|/* This may be improved if l == 0.  */
while|while
condition|(
name|n
operator|>=
name|ln
operator|||
operator|(
name|n
operator|==
name|REG_INFTY
operator|&&
name|ln
operator|>
literal|0
operator|&&
name|l
operator|)
condition|)
block|{
comment|/* ln overflow ? */
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|l
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- move forward. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|=
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
name|n
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|l
operator|==
literal|0
comment|/* In fact, this is tricky.  If paren, then the 		       fact that we did/didnot match may influence 		       future execution. */
operator|&&
operator|!
operator|(
name|paren
operator|&&
name|ln
operator|==
literal|0
operator|)
condition|)
name|ln
operator|=
name|n
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  matched %ld times, len=%ld...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|n
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
name|UCHARAT
argument_list|(
name|OPERAND
argument_list|(
name|next
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
name|REGCP_SET
expr_stmt|;
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  trying tail with n=%ld...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|l
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|locinput
operator|-=
name|l
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
block|}
block|}
name|sayNO
expr_stmt|;
break|break;
block|}
case|case
name|CURLYN
case|:
name|paren
operator|=
name|scan
operator|->
name|flags
expr_stmt|;
comment|/* Which paren to set */
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|paren
expr_stmt|;
if|if
condition|(
name|paren
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|paren
expr_stmt|;
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|scan
operator|=
name|regnext
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|CURLY
case|:
name|paren
operator|=
literal|0
expr_stmt|;
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|STAR
case|:
name|ln
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|REG_INFTY
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PLUS
case|:
name|ln
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|REG_INFTY
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
name|repeat
label|:
comment|/* 	    * Lookahead to avoid useless match attempts 	    * when we know what character comes next. 	    */
if|if
condition|(
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
name|UCHARAT
argument_list|(
name|OPERAND
argument_list|(
name|next
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|minmod
condition|)
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|minmod
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|ln
argument_list|)
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
name|REGCP_SET
expr_stmt|;
while|while
condition|(
name|n
operator|>=
name|ln
operator|||
operator|(
name|n
operator|==
name|REG_INFTY
operator|&&
name|ln
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* ln overflow ? */
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
literal|1
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- move forward. */
name|PL_reginput
operator|=
name|locinput
operator|+
name|ln
expr_stmt|;
if|if
condition|(
name|regrepeat
argument_list|(
name|scan
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
operator|+
name|ln
expr_stmt|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
block|}
else|else
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|n
operator|=
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|<
name|n
operator|&&
name|regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EOL
operator|&&
operator|(
operator|!
name|PL_multiline
operator|||
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|SEOL
operator|)
condition|)
name|ln
operator|=
name|n
expr_stmt|;
comment|/* why back off? */
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
operator|&&
name|n
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
literal|1
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
operator|+
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
operator|+
name|n
expr_stmt|;
block|}
block|}
block|}
name|sayNO
expr_stmt|;
break|break;
case|case
name|END
case|:
if|if
condition|(
name|locinput
operator|<
name|PL_regtill
condition|)
name|sayNO
expr_stmt|;
comment|/* Cannot match: too short. */
comment|/* Fall through */
case|case
name|SUCCEED
case|:
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* put where regtry can find it */
name|sayYES
expr_stmt|;
comment|/* Success! */
case|case
name|SUSPEND
case|:
name|n
operator|=
literal|1
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
goto|goto
name|do_ifmatch
goto|;
case|case
name|UNLESSM
case|:
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|locinput
operator|<
name|PL_bostr
operator|+
name|scan
operator|->
name|flags
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|do_ifmatch
goto|;
case|case
name|IFMATCH
case|:
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|locinput
operator|<
name|PL_bostr
operator|+
name|scan
operator|->
name|flags
condition|)
goto|goto
name|say_no
goto|;
name|do_ifmatch
label|:
name|PL_reginput
operator|=
name|locinput
operator|-
name|scan
operator|->
name|flags
expr_stmt|;
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|inner
argument_list|)
operator|!=
name|n
condition|)
block|{
name|say_no
label|:
if|if
condition|(
name|logical
condition|)
block|{
name|logical
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_longjump
goto|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
name|say_yes
label|:
if|if
condition|(
name|logical
condition|)
block|{
name|logical
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SUSPEND
condition|)
block|{
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH. */
case|case
name|LONGJMP
case|:
name|do_longjump
label|:
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"%lx %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|scan
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
literal|"regexp memory corruption"
argument_list|)
expr_stmt|;
block|}
name|scan
operator|=
name|next
expr_stmt|;
block|}
comment|/*     * We get here only if there's trouble -- normally "case END" is     * the terminating point.     */
name|FAIL
argument_list|(
literal|"corrupted regexp pointers"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|sayNO
expr_stmt|;
name|yes
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
name|no
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regrepeat - repeatedly match something simple, report how many  */
end_comment

begin_comment
comment|/*  * [This routine now assumes that it will only match on things of length 1.  * That was true before, but now we assume scan - reginput is the count,  * rather than incrementing count on every character.]  */
end_comment

begin_function
name|STATIC
name|I32
name|regrepeat
parameter_list|(
name|regnode
modifier|*
name|p
parameter_list|,
name|I32
name|max
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|opnd
decl_stmt|;
specifier|register
name|I32
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|loceol
init|=
name|PL_regeol
decl_stmt|;
name|scan
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|max
operator|!=
name|REG_INFTY
operator|&&
name|max
operator|<
name|loceol
operator|-
name|scan
condition|)
name|loceol
operator|=
name|scan
operator|+
name|max
expr_stmt|;
name|opnd
operator|=
operator|(
name|char
operator|*
operator|)
name|OPERAND
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|ANY
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SANY
case|:
name|scan
operator|=
name|loceol
expr_stmt|;
break|break;
case|case
name|EXACT
case|:
comment|/* length of string is 1 */
name|c
operator|=
name|UCHARAT
argument_list|(
operator|++
name|opnd
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTF
case|:
comment|/* length of string is 1 */
name|c
operator|=
name|UCHARAT
argument_list|(
operator|++
name|opnd
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
operator|||
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|fold
index|[
name|c
index|]
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTFL
case|:
comment|/* length of string is 1 */
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|c
operator|=
name|UCHARAT
argument_list|(
operator|++
name|opnd
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
operator|||
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|fold_locale
index|[
name|c
index|]
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|REGINCLASS
argument_list|(
name|opnd
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isSPACE_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isSPACE_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Called on something of 0 width. */
break|break;
comment|/* So match right here or not at all. */
block|}
name|c
operator|=
name|scan
operator|-
name|PL_reginput
expr_stmt|;
name|PL_reginput
operator|=
name|scan
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|{ 		SV *prop = sv_newmortal();  		regprop(prop, p); 		PerlIO_printf(Perl_debug_log,
literal|"%*s  %s can match %ld times out of %ld...\n"
argument|,  			      REPORT_CODE_OFF+
literal|1
argument|,
literal|""
argument|, SvPVX(prop),c,max); 	}
argument_list|)
empty_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regrepeat_hard - repeatedly match something, report total lenth and length  *   * The repeater is supposed to have constant length.  */
end_comment

begin_function
name|STATIC
name|I32
name|regrepeat_hard
parameter_list|(
name|regnode
modifier|*
name|p
parameter_list|,
name|I32
name|max
parameter_list|,
name|I32
modifier|*
name|lp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|char
modifier|*
name|loceol
init|=
name|PL_regeol
decl_stmt|;
name|I32
name|l
init|=
literal|0
decl_stmt|;
name|I32
name|count
init|=
literal|0
decl_stmt|,
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|max
condition|)
return|return
literal|0
return|;
name|start
operator|=
name|PL_reginput
expr_stmt|;
while|while
condition|(
name|PL_reginput
operator|<
name|loceol
operator|&&
operator|(
name|scan
operator|=
name|PL_reginput
operator|,
name|res
operator|=
name|regmatch
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|count
operator|++
condition|)
block|{
operator|*
name|lp
operator|=
name|l
operator|=
name|PL_reginput
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|max
operator|!=
name|REG_INFTY
operator|&&
name|l
operator|*
name|max
operator|<
name|loceol
operator|-
name|scan
condition|)
name|loceol
operator|=
name|scan
operator|+
name|l
operator|*
name|max
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|max
return|;
block|}
block|}
if|if
condition|(
operator|!
name|res
condition|)
name|PL_reginput
operator|=
name|scan
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  - regclass - determine if a character falls into a character class  */
end_comment

begin_function
name|STATIC
name|bool
name|reginclass
parameter_list|(
specifier|register
name|char
modifier|*
name|p
parameter_list|,
specifier|register
name|I32
name|c
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
name|flags
init|=
operator|*
name|p
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|c
operator|&=
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ANYOF_TEST
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ANYOF_FOLD
condition|)
block|{
name|I32
name|cf
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|cf
operator|=
name|fold_locale
index|[
name|c
index|]
expr_stmt|;
block|}
else|else
name|cf
operator|=
name|fold
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|ANYOF_TEST
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
operator|&&
operator|(
name|flags
operator|&
name|ANYOF_ISA
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|ANYOF_ALNUML
operator|)
operator|&&
name|isALNUM_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|ANYOF_NALNUML
operator|)
operator|&&
operator|!
name|isALNUM_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|ANYOF_SPACEL
operator|)
operator|&&
name|isSPACE_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|ANYOF_NSPACEL
operator|)
operator|&&
operator|!
name|isSPACE_LC
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|flags
operator|&
name|ANYOF_INVERT
operator|)
condition|?
operator|!
name|match
else|:
name|match
return|;
block|}
end_function

end_unit

