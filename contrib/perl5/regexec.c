begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    regexec.c  */
end_comment

begin_comment
comment|/*  * "One Ring to rule them all, One Ring to find them..."  */
end_comment

begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* The names of the functions have been changed from regcomp and  * regexec to  pregcomp and pregexec in order to avoid conflicts  * with the POSIX routines of the same names. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_EXT_RE_BUILD
end_ifdef

begin_comment
comment|/* need to replace pregcomp et al, so enable that */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_IN_XSUB_RE
end_ifndef

begin_define
define|#
directive|define
name|PERL_IN_XSUB_RE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* need access to debugger hooks */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_EXT_RE_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEBUGGING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_comment
comment|/* We *really* need to overwrite these symbols: */
end_comment

begin_define
define|#
directive|define
name|Perl_regexec_flags
value|my_regexec
end_define

begin_define
define|#
directive|define
name|Perl_regdump
value|my_regdump
end_define

begin_define
define|#
directive|define
name|Perl_regprop
value|my_regprop
end_define

begin_define
define|#
directive|define
name|Perl_re_intuit_start
value|my_re_intuit_start
end_define

begin_comment
comment|/* *These* symbols are masked to allow static link. */
end_comment

begin_define
define|#
directive|define
name|Perl_pregexec
value|my_pregexec
end_define

begin_define
define|#
directive|define
name|Perl_reginitcolors
value|my_reginitcolors
end_define

begin_define
define|#
directive|define
name|PERL_NO_GET_CONTEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * pregcomp and pregexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991-2000, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.  *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_REGEXEC_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IN_XSUB_RE
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_CAPI
argument_list|)
operator|||
name|defined
argument_list|(
name|PERL_OBJECT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_define
define|#
directive|define
name|RF_tainted
value|1
end_define

begin_comment
comment|/* tainted information used? */
end_comment

begin_define
define|#
directive|define
name|RF_warned
value|2
end_define

begin_comment
comment|/* warned about big count? */
end_comment

begin_define
define|#
directive|define
name|RF_evaled
value|4
end_define

begin_comment
comment|/* Did an EVAL with setting? */
end_comment

begin_define
define|#
directive|define
name|RF_utf8
value|8
end_define

begin_comment
comment|/* String contains multibyte chars? */
end_comment

begin_define
define|#
directive|define
name|UTF
value|(PL_reg_flags& RF_utf8)
end_define

begin_define
define|#
directive|define
name|RS_init
value|1
end_define

begin_comment
comment|/* eval environment created */
end_comment

begin_define
define|#
directive|define
name|RS_set
value|2
end_define

begin_comment
comment|/* replsv value is set */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Forwards.  */
end_comment

begin_define
define|#
directive|define
name|REGINCLASS
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
value|(ANYOF_FLAGS(p) ? reginclass(p,c) : ANYOF_BITMAP_TEST(p,c))
end_define

begin_define
define|#
directive|define
name|REGINCLASSUTF8
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|)
value|(ARG1(f) ? reginclassutf8(f,p) : swash_fetch((SV*)PL_regdata->data[ARG2(f)],p))
end_define

begin_define
define|#
directive|define
name|CHR_SVLEN
parameter_list|(
name|sv
parameter_list|)
value|(UTF ? sv_len_utf8(sv) : SvCUR(sv))
end_define

begin_define
define|#
directive|define
name|CHR_DIST
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(UTF ? utf8_distance(a,b) : a - b)
end_define

begin_define
define|#
directive|define
name|reghop_c
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|((char*)reghop((U8*)pos, off))
end_define

begin_define
define|#
directive|define
name|reghopmaybe_c
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|((char*)reghopmaybe((U8*)pos, off))
end_define

begin_define
define|#
directive|define
name|HOP
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|(UTF ? reghop((U8*)pos, off) : (U8*)(pos + off))
end_define

begin_define
define|#
directive|define
name|HOPMAYBE
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|(UTF ? reghopmaybe((U8*)pos, off) : (U8*)(pos + off))
end_define

begin_define
define|#
directive|define
name|HOPc
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|((char*)HOP(pos,off))
end_define

begin_define
define|#
directive|define
name|HOPMAYBEc
parameter_list|(
name|pos
parameter_list|,
name|off
parameter_list|)
value|((char*)HOPMAYBE(pos,off))
end_define

begin_function_decl
specifier|static
name|void
name|restore_pos
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|STATIC
name|CHECKPOINT
name|S_regcppush
parameter_list|(
name|pTHX_
name|I32
name|parenfloor
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|retval
init|=
name|PL_savestack_ix
decl_stmt|;
name|int
name|i
init|=
operator|(
name|PL_regsize
operator|-
name|parenfloor
operator|)
operator|*
literal|4
decl_stmt|;
name|int
name|p
decl_stmt|;
name|SSCHECK
argument_list|(
name|i
operator|+
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|PL_regsize
init|;
name|p
operator|>
name|parenfloor
condition|;
name|p
operator|--
control|)
block|{
name|SSPUSHINT
argument_list|(
name|PL_regendp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|PL_regstartp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHPTR
argument_list|(
name|PL_reg_start_tmp
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|SSPUSHINT
argument_list|(
name|PL_regsize
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
operator|*
name|PL_reglastparen
argument_list|)
expr_stmt|;
name|SSPUSHPTR
argument_list|(
name|PL_reginput
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|SSPUSHINT
argument_list|(
name|SAVEt_REGCONTEXT
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* These are needed since we do not localize EVAL nodes: */
end_comment

begin_define
define|#
directive|define
name|REGCP_SET
value|DEBUG_r(PerlIO_printf(Perl_debug_log,		\ 			     "  Setting an EVAL scope, savestack=%"IVdf"\n",	\ 			     (IV)PL_savestack_ix)); lastcp = PL_savestack_ix
end_define

begin_define
define|#
directive|define
name|REGCP_UNWIND
value|DEBUG_r(lastcp != PL_savestack_ix ?		\ 				PerlIO_printf(Perl_debug_log,		\ 				"  Clearing an EVAL scope, savestack=%"IVdf"..%"IVdf"\n", \ 				(IV)lastcp, (IV)PL_savestack_ix) : 0); regcpblow(lastcp)
end_define

begin_function
name|STATIC
name|char
modifier|*
name|S_regcppop
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|i
init|=
name|SSPOPINT
decl_stmt|;
name|U32
name|paren
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|;
name|I32
name|tmps
decl_stmt|;
name|assert
argument_list|(
name|i
operator|==
name|SAVEt_REGCONTEXT
argument_list|)
expr_stmt|;
name|i
operator|=
name|SSPOPINT
expr_stmt|;
name|input
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
operator|*
name|PL_reglastparen
operator|=
name|SSPOPINT
expr_stmt|;
name|PL_regsize
operator|=
name|SSPOPINT
expr_stmt|;
for|for
control|(
name|i
operator|-=
literal|3
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|4
control|)
block|{
name|paren
operator|=
operator|(
name|U32
operator|)
name|SSPOPINT
expr_stmt|;
name|PL_reg_start_tmp
index|[
name|paren
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|SSPOPPTR
expr_stmt|;
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|SSPOPINT
expr_stmt|;
name|tmps
operator|=
name|SSPOPINT
expr_stmt|;
if|if
condition|(
name|paren
operator|<=
operator|*
name|PL_reglastparen
condition|)
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|tmps
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|PerlIO_printf(Perl_debug_log,
literal|"     restoring \\%"
argument|UVuf
literal|" to %"
argument|IVdf
literal|"(%"
argument|IVdf
literal|")..%"
argument|IVdf
literal|"%s\n"
argument|, 			  (UV)paren, (IV)PL_regstartp[paren],  			  (IV)(PL_reg_start_tmp[paren] - PL_bostr), 			  (IV)PL_regendp[paren],  			  (paren> *PL_reglastparen ?
literal|"(no)"
argument|:
literal|""
argument|));
argument_list|)
empty_stmt|;
block|}
name|DEBUG_r
argument_list|(
argument|if (*PL_reglastparen +
literal|1
argument|<= PL_regnpar) { 	    PerlIO_printf(Perl_debug_log,
literal|"     restoring \\%"
argument|IVdf
literal|"..\\%"
argument|IVdf
literal|" to undef\n"
argument|, 			  (IV)(*PL_reglastparen +
literal|1
argument|), (IV)PL_regnpar); 	}
argument_list|)
empty_stmt|;
for|for
control|(
name|paren
operator|=
operator|*
name|PL_reglastparen
operator|+
literal|1
init|;
name|paren
operator|<=
name|PL_regnpar
condition|;
name|paren
operator|++
control|)
block|{
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regstartp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|S_regcp_set_to
parameter_list|(
name|pTHX_
name|I32
name|ss
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|tmp
init|=
name|PL_savestack_ix
decl_stmt|;
name|PL_savestack_ix
operator|=
name|ss
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|PL_savestack_ix
operator|=
name|tmp
expr_stmt|;
return|return
name|Nullch
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|re_cc_state
block|{
name|I32
name|ss
decl_stmt|;
name|regnode
modifier|*
name|node
decl_stmt|;
name|struct
name|re_cc_state
modifier|*
name|prev
decl_stmt|;
name|CURCUR
modifier|*
name|cc
decl_stmt|;
name|regexp
modifier|*
name|re
decl_stmt|;
block|}
name|re_cc_state
typedef|;
end_typedef

begin_define
define|#
directive|define
name|regcpblow
parameter_list|(
name|cp
parameter_list|)
value|LEAVE_SCOPE(cp)
end_define

begin_comment
comment|/*  * pregexec and friends  */
end_comment

begin_comment
comment|/*  - pregexec - match a regexp against a string  */
end_comment

begin_function
name|I32
name|Perl_pregexec
parameter_list|(
name|pTHX_
specifier|register
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|stringarg
parameter_list|,
specifier|register
name|char
modifier|*
name|strend
parameter_list|,
name|char
modifier|*
name|strbeg
parameter_list|,
name|I32
name|minend
parameter_list|,
name|SV
modifier|*
name|screamer
parameter_list|,
name|U32
name|nosave
parameter_list|)
comment|/* strend: pointer to null at end of string */
comment|/* strbeg: real beginning of string */
comment|/* minend: end of match must be>=minend after stringarg. */
comment|/* nosave: For optimizations. */
block|{
return|return
name|regexec_flags
argument_list|(
name|prog
argument_list|,
name|stringarg
argument_list|,
name|strend
argument_list|,
name|strbeg
argument_list|,
name|minend
argument_list|,
name|screamer
argument_list|,
name|NULL
argument_list|,
name|nosave
condition|?
literal|0
else|:
name|REXEC_COPY_STR
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_cache_re
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|prog
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|PL_regprecomp
operator|=
name|prog
operator|->
name|precomp
expr_stmt|;
comment|/* Needed for FAIL. */
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regprogram
operator|=
name|prog
operator|->
name|program
expr_stmt|;
endif|#
directive|endif
name|PL_regnpar
operator|=
name|prog
operator|->
name|nparens
expr_stmt|;
name|PL_regdata
operator|=
name|prog
operator|->
name|data
expr_stmt|;
name|PL_reg_re
operator|=
name|prog
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Need to implement the following flags for reg_anch:  *  * USE_INTUIT_NOML		- Useful to call re_intuit_start() first  * USE_INTUIT_ML  * INTUIT_AUTORITATIVE_NOML	- Can trust a positive answer  * INTUIT_AUTORITATIVE_ML  * INTUIT_ONCE_NOML		- Intuit can match in one location only.  * INTUIT_ONCE_ML  *  * Another flag for this function: SECOND_TIME (so that float substrs  * with giant delta may be not rechecked).  */
end_comment

begin_comment
comment|/* Assumptions: if ANCH_GPOS, then strpos is anchored. XXXX Check GPOS logic */
end_comment

begin_comment
comment|/* If SCREAM, then SvPVX(sv) should be compatible with strpos and strend.    Otherwise, only SvCUR(sv) is used to get strbeg. */
end_comment

begin_comment
comment|/* XXXX We assume that strpos is strbeg unless sv. */
end_comment

begin_comment
comment|/* XXXX Some places assume that there is a fixed substring. 	An update may be needed if optimizer marks as "INTUITable" 	RExen without fixed substrings.  Similarly, it is assumed that 	lengths of all the strings are no more than minlen, thus they 	cannot come from lookahead. 	(Or minlen should take into account lookahead.) */
end_comment

begin_comment
comment|/* A failure to find a constant substring means that there is no need to make    an expensive call to REx engine, thus we celebrate a failure.  Similarly,    finding a substring too deep into the string means that less calls to    regtry() should be needed.     REx compiler's optimizer found 4 possible hints: 	a) Anchored substring; 	b) Fixed substring; 	c) Whether we are anchored (beginning-of-line or \G); 	d) First node (of those at offset 0) which may distingush positions;    We use a)b)d) and multiline-part of c), and try to find a position in the    string which does not contradict any of them.  */
end_comment

begin_comment
comment|/* Most of decisions we do here should have been done at compile time.    The nodes of the REx which we used for the search should have been    deleted from the finite automaton. */
end_comment

begin_function
name|char
modifier|*
name|Perl_re_intuit_start
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|prog
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|char
modifier|*
name|strpos
parameter_list|,
name|char
modifier|*
name|strend
parameter_list|,
name|U32
name|flags
parameter_list|,
name|re_scream_pos_data
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|I32
name|start_shift
decl_stmt|;
comment|/* Should be nonnegative! */
specifier|register
name|I32
name|end_shift
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|SV
modifier|*
name|check
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|I32
name|ml_anch
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|char
modifier|*
name|other_last
init|=
name|Nullch
decl_stmt|;
comment|/* other substr checked before this */
name|char
modifier|*
name|check_at
decl_stmt|;
comment|/* check substr found at this pos */
ifdef|#
directive|ifdef
name|DEBUGGING
name|char
modifier|*
name|i_strpos
init|=
name|strpos
decl_stmt|;
endif|#
directive|endif
name|DEBUG_r
argument_list|(
argument|if (!PL_colorset) reginitcolors()
argument_list|)
empty_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sGuessing start of match, REx%s `%s%.60s%s%s' against `%s%.*s%s%s'...\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|prog
operator|->
name|precomp
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strlen
argument_list|(
name|prog
operator|->
name|precomp
argument_list|)
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|strpos
operator|>
literal|60
condition|?
literal|60
else|:
name|strend
operator|-
name|strpos
argument_list|)
argument_list|,
name|strpos
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strend
operator|-
name|strpos
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|minlen
operator|>
name|strend
operator|-
name|strpos
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"String too short...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|check
operator|=
name|prog
operator|->
name|check_substr
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
block|{
comment|/* Match at beg-of-str or after \n */
name|ml_anch
operator|=
operator|!
operator|(
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_SINGLE
operator|)
operator|||
operator|(
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_BOL
operator|)
operator|&&
operator|!
name|PL_multiline
operator|)
operator|)
expr_stmt|;
comment|/* Check after \n? */
if|if
condition|(
operator|(
name|prog
operator|->
name|check_offset_min
operator|==
name|prog
operator|->
name|check_offset_max
operator|)
operator|&&
operator|!
name|ml_anch
condition|)
block|{
comment|/* Substring at constant offset from beg-of-str... */
name|I32
name|slen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
operator|)
comment|/* Checked by the caller */
operator|&&
operator|(
name|sv
operator|&&
operator|(
name|strpos
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|!=
name|strend
operator|)
operator|)
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Not at start...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* Used in HOP() */
name|s
operator|=
name|HOPc
argument_list|(
name|strpos
argument_list|,
name|prog
operator|->
name|check_offset_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
condition|)
block|{
name|slen
operator|=
name|SvCUR
argument_list|(
name|check
argument_list|)
expr_stmt|;
comment|/*>= 1 */
if|if
condition|(
name|strend
operator|-
name|s
operator|>
name|slen
operator|||
name|strend
operator|-
name|s
operator|<
name|slen
operator|-
literal|1
operator|||
operator|(
name|strend
operator|-
name|s
operator|==
name|slen
operator|&&
name|strend
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"String too long...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_finish
goto|;
block|}
comment|/* Now should match s[0..slen-2] */
name|slen
operator|--
expr_stmt|;
if|if
condition|(
name|slen
operator|&&
operator|(
operator|*
name|SvPVX
argument_list|(
name|check
argument_list|)
operator|!=
operator|*
name|s
operator|||
operator|(
name|slen
operator|>
literal|1
operator|&&
name|memNE
argument_list|(
name|SvPVX
argument_list|(
name|check
argument_list|)
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|)
operator|)
condition|)
block|{
name|report_neq
label|:
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"String not equal...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_finish
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|SvPVX
argument_list|(
name|check
argument_list|)
operator|!=
operator|*
name|s
operator|||
operator|(
operator|(
name|slen
operator|=
name|SvCUR
argument_list|(
name|check
argument_list|)
operator|)
operator|>
literal|1
operator|&&
name|memNE
argument_list|(
name|SvPVX
argument_list|(
name|check
argument_list|)
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|)
condition|)
goto|goto
name|report_neq
goto|;
goto|goto
name|success_at_start
goto|;
block|}
comment|/* Match is anchored, but substr is not anchored wrt beg-of-str. */
name|s
operator|=
name|strpos
expr_stmt|;
name|start_shift
operator|=
name|prog
operator|->
name|check_offset_min
expr_stmt|;
comment|/* okay to underestimate on CC */
name|end_shift
operator|=
name|prog
operator|->
name|minlen
operator|-
name|start_shift
operator|-
name|CHR_SVLEN
argument_list|(
name|check
argument_list|)
operator|+
operator|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ml_anch
condition|)
block|{
name|I32
name|end
init|=
name|prog
operator|->
name|check_offset_max
operator|+
name|CHR_SVLEN
argument_list|(
name|check
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|I32
name|eshift
init|=
name|strend
operator|-
name|s
operator|-
name|end
decl_stmt|;
if|if
condition|(
name|end_shift
operator|<
name|eshift
condition|)
name|end_shift
operator|=
name|eshift
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can match at random position */
name|ml_anch
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|strpos
expr_stmt|;
name|start_shift
operator|=
name|prog
operator|->
name|check_offset_min
expr_stmt|;
comment|/* okay to underestimate on CC */
comment|/* Should be nonnegative! */
name|end_shift
operator|=
name|prog
operator|->
name|minlen
operator|-
name|start_shift
operator|-
name|CHR_SVLEN
argument_list|(
name|check
argument_list|)
operator|+
operator|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
comment|/* 7/99: reports of failure (with the older version) */
if|if
condition|(
name|end_shift
operator|<
literal|0
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: end_shift"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restart
label|:
comment|/* Find a possible match in the region s..strend by looking for        the "check" substring in the region corrected by start/end_shift. */
if|if
condition|(
name|flags
operator|&
name|REXEC_SCREAM
condition|)
block|{
name|char
modifier|*
name|strbeg
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
comment|/* XXXX Assume PV_force() on SCREAM! */
name|I32
name|p
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Internal iterator of scream. */
name|I32
modifier|*
name|pp
init|=
name|data
condition|?
name|data
operator|->
name|scream_pos
else|:
operator|&
name|p
decl_stmt|;
if|if
condition|(
name|PL_screamfirst
index|[
name|BmRARE
argument_list|(
name|check
argument_list|)
index|]
operator|>=
literal|0
operator|||
operator|(
name|BmRARE
argument_list|(
name|check
argument_list|)
operator|==
literal|'\n'
operator|&&
operator|(
name|BmPREVIOUS
argument_list|(
name|check
argument_list|)
operator|==
name|SvCUR
argument_list|(
name|check
argument_list|)
operator|-
literal|1
operator|)
operator|&&
name|SvTAIL
argument_list|(
name|check
argument_list|)
operator|)
condition|)
name|s
operator|=
name|screaminstr
argument_list|(
name|sv
argument_list|,
name|check
argument_list|,
name|start_shift
operator|+
operator|(
name|s
operator|-
name|strbeg
operator|)
argument_list|,
name|end_shift
argument_list|,
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
goto|goto
name|fail_finish
goto|;
if|if
condition|(
name|data
condition|)
operator|*
name|data
operator|->
name|scream_olds
operator|=
name|s
expr_stmt|;
block|}
else|else
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|+
name|start_shift
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
operator|-
name|end_shift
argument_list|,
name|check
argument_list|,
name|PL_multiline
condition|?
name|FBMrf_MULTILINE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Update the count-of-usability, remove useless subpatterns, 	unshift s.  */
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s %s substr `%s%.*s%s'%s%s"
argument_list|,
operator|(
name|s
condition|?
literal|"Found"
else|:
literal|"Did not find"
operator|)
argument_list|,
operator|(
operator|(
name|check
operator|==
name|prog
operator|->
name|anchored_substr
operator|)
condition|?
literal|"anchored"
else|:
literal|"floating"
operator|)
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SvCUR
argument_list|(
name|check
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|check
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|SvTAIL
argument_list|(
name|check
argument_list|)
condition|?
literal|"$"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|s
condition|?
literal|" at offset "
else|:
literal|"...\n"
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
goto|goto
name|fail_finish
goto|;
name|check_at
operator|=
name|s
expr_stmt|;
comment|/* Finish the diagnostic message */
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Got a candidate.  Check MBOL anchoring, and the *other* substr.        Start with the other substr.        XXXX no SCREAM optimization yet - and a very coarse implementation        XXXX /ttx+/ results in anchored=`ttx', floating=`x'.  floating will 		*always* match.  Probably should be marked during compile...        Probably it is right to do no SCREAM here...      */
if|if
condition|(
name|prog
operator|->
name|float_substr
operator|&&
name|prog
operator|->
name|anchored_substr
condition|)
block|{
comment|/* Take into account the "other" substring. */
comment|/* XXXX May be hopelessly wrong for UTF... */
if|if
condition|(
operator|!
name|other_last
condition|)
name|other_last
operator|=
name|strpos
expr_stmt|;
if|if
condition|(
name|check
operator|==
name|prog
operator|->
name|float_substr
condition|)
block|{
name|do_other_anchored
label|:
block|{
name|char
modifier|*
name|last
init|=
name|s
operator|-
name|start_shift
decl_stmt|,
modifier|*
name|last1
decl_stmt|,
modifier|*
name|last2
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
name|tmp
operator|=
name|PL_bostr
expr_stmt|;
name|t
operator|=
name|s
operator|-
name|prog
operator|->
name|check_offset_max
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|strpos
operator|>
name|prog
operator|->
name|check_offset_max
comment|/* signed-corrected t> strpos */
operator|&&
operator|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_UTF8
operator|)
operator|||
operator|(
name|PL_bostr
operator|=
name|strpos
operator|,
comment|/* Used in regcopmaybe() */
operator|(
name|t
operator|=
name|reghopmaybe_c
argument_list|(
name|s
argument_list|,
operator|-
operator|(
name|prog
operator|->
name|check_offset_max
operator|)
argument_list|)
operator|)
operator|&&
name|t
operator|>
name|strpos
operator|)
operator|)
condition|)
comment|/* EMPTY */
empty_stmt|;
else|else
name|t
operator|=
name|strpos
expr_stmt|;
name|t
operator|+=
name|prog
operator|->
name|anchored_offset
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|other_last
condition|)
comment|/* These positions already checked */
name|t
operator|=
name|other_last
expr_stmt|;
name|PL_bostr
operator|=
name|tmp
expr_stmt|;
name|last2
operator|=
name|last1
operator|=
name|strend
operator|-
name|prog
operator|->
name|minlen
expr_stmt|;
if|if
condition|(
name|last
operator|<
name|last1
condition|)
name|last1
operator|=
name|last
expr_stmt|;
comment|/* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
comment|/* On end-of-str: see comment below. */
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|last1
operator|+
name|prog
operator|->
name|anchored_offset
operator|+
name|SvCUR
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|,
name|prog
operator|->
name|anchored_substr
argument_list|,
name|PL_multiline
condition|?
name|FBMrf_MULTILINE
else|:
literal|0
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s anchored substr `%s%.*s%s'%s"
argument_list|,
operator|(
name|s
condition|?
literal|"Found"
else|:
literal|"Contradicts"
operator|)
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SvCUR
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|last1
operator|>=
name|last2
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|", giving up...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_finish
goto|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|", trying floating at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s1
operator|+
literal|1
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* Used in HOP() */
name|other_last
operator|=
name|last1
operator|+
name|prog
operator|->
name|anchored_offset
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|HOPc
argument_list|(
name|last
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
else|else
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|-
name|prog
operator|->
name|anchored_offset
expr_stmt|;
name|other_last
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|strpos
condition|)
goto|goto
name|try_at_start
goto|;
goto|goto
name|try_at_offset
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* Take into account the floating substring. */
name|char
modifier|*
name|last
decl_stmt|,
modifier|*
name|last1
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
name|t
operator|=
name|s
operator|-
name|start_shift
expr_stmt|;
name|last1
operator|=
name|last
operator|=
name|strend
operator|-
name|prog
operator|->
name|minlen
operator|+
name|prog
operator|->
name|float_min_offset
expr_stmt|;
if|if
condition|(
name|last
operator|-
name|t
operator|>
name|prog
operator|->
name|float_max_offset
condition|)
name|last
operator|=
name|t
operator|+
name|prog
operator|->
name|float_max_offset
expr_stmt|;
name|s
operator|=
name|t
operator|+
name|prog
operator|->
name|float_min_offset
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|other_last
condition|)
name|s
operator|=
name|other_last
expr_stmt|;
comment|/* XXXX It is not documented what units *_offsets are in.  Assume bytes.  */
comment|/* fbm_instr() takes into account exact value of end-of-str 		   if the check is SvTAIL(ed).  Since false positives are OK, 		   and end-of-str is not later than strend we are OK. */
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|last
operator|+
name|SvCUR
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|,
name|prog
operator|->
name|float_substr
argument_list|,
name|PL_multiline
condition|?
name|FBMrf_MULTILINE
else|:
literal|0
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s floating substr `%s%.*s%s'%s"
argument_list|,
operator|(
name|s
condition|?
literal|"Found"
else|:
literal|"Contradicts"
operator|)
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SvCUR
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
condition|?
literal|"$"
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
name|last1
operator|==
name|last
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|", giving up...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_finish
goto|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|", trying anchored starting at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s1
operator|+
literal|1
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|other_last
operator|=
name|last
operator|+
literal|1
expr_stmt|;
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* Used in HOP() */
name|s
operator|=
name|HOPc
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
else|else
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|" at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|other_last
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|strpos
condition|)
goto|goto
name|try_at_start
goto|;
goto|goto
name|try_at_offset
goto|;
block|}
block|}
block|}
name|t
operator|=
name|s
operator|-
name|prog
operator|->
name|check_offset_max
expr_stmt|;
name|tmp
operator|=
name|PL_bostr
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|strpos
operator|>
name|prog
operator|->
name|check_offset_max
comment|/* signed-corrected t> strpos */
operator|&&
operator|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_UTF8
operator|)
operator|||
operator|(
name|PL_bostr
operator|=
name|strpos
operator|,
comment|/* Used in regcopmaybe() */
operator|(
operator|(
name|t
operator|=
name|reghopmaybe_c
argument_list|(
name|s
argument_list|,
operator|-
operator|(
name|prog
operator|->
name|check_offset_max
operator|)
argument_list|)
operator|)
operator|&&
name|t
operator|>
name|strpos
operator|)
operator|)
operator|)
condition|)
block|{
name|PL_bostr
operator|=
name|tmp
expr_stmt|;
comment|/* Fixed substring is found far enough so that the match 	   cannot start at strpos. */
name|try_at_offset
label|:
if|if
condition|(
name|ml_anch
operator|&&
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Eventually fbm_*() should handle this, but often 	       anchored_offset is not 0, so this check will not be wasted. */
comment|/* XXXX In the code below we prefer to look for "^" even in 	       presence of anchored substrings.  And we search even 	       beyond the found float position.  These pessimizations 	       are historical artefacts only.  */
name|find_anchor
label|:
while|while
condition|(
name|t
operator|<
name|strend
operator|-
name|prog
operator|->
name|minlen
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|t
operator|<
name|s
operator|-
name|prog
operator|->
name|check_offset_min
condition|)
block|{
if|if
condition|(
name|prog
operator|->
name|anchored_substr
condition|)
block|{
comment|/* We definitely contradict the found anchored 			       substr.  Due to the above check we do not 			       contradict "check" substr. 			       Thus we can arrive here only if check substr 			       is float.  Redo checking for "other"=="fixed". 			     */
name|strpos
operator|=
name|t
operator|+
literal|1
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Found /%s^%s/m at offset %ld, rescanning for anchored from offset %ld...\n"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|strpos
operator|-
name|i_strpos
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|strpos
operator|-
name|i_strpos
operator|+
name|prog
operator|->
name|anchored_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|do_other_anchored
goto|;
block|}
name|s
operator|=
name|t
operator|+
literal|1
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Found /%s^%s/m at offset %ld...\n"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|set_useful
goto|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Found /%s^%s/m, restarting at offset %ld...\n"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|t
operator|+
literal|1
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strpos
operator|=
name|s
operator|=
name|t
operator|+
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|t
operator|++
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Did not find /%s^%s/m...\n"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_finish
goto|;
block|}
name|s
operator|=
name|t
expr_stmt|;
name|set_useful
label|:
operator|++
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
comment|/* hooray/5 */
block|}
else|else
block|{
name|PL_bostr
operator|=
name|tmp
expr_stmt|;
comment|/* The found string does not prohibit matching at beg-of-str 	   - no optimization of calling REx engine can be performed, 	   unless it was an MBOL and we are not after MBOL. */
name|try_at_start
label|:
comment|/* Even in this situation we may use MBOL flag if strpos is offset 	   wrt the start of the string. */
if|if
condition|(
name|ml_anch
operator|&&
name|sv
operator|&&
operator|(
name|strpos
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|!=
name|strend
operator|)
operator|&&
name|strpos
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
comment|/* May be due to an implicit anchor of m{.*foo}  */
operator|&&
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
operator|)
condition|)
block|{
name|t
operator|=
name|strpos
expr_stmt|;
goto|goto
name|find_anchor
goto|;
block|}
name|DEBUG_r
argument_list|(
argument|if (ml_anch) 	    PerlIO_printf(Perl_debug_log,
literal|"Does not contradict /%s^%s/m...\n"
argument|, 			PL_colors[
literal|0
argument|],PL_colors[
literal|1
argument|]);
argument_list|)
empty_stmt|;
name|success_at_start
label|:
if|if
condition|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_NAUGHTY
operator|)
comment|/* XXXX If strpos moved? */
operator|&&
name|prog
operator|->
name|check_substr
comment|/* Could be deleted already */
operator|&&
operator|--
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
operator|<
literal|0
operator|&&
name|prog
operator|->
name|check_substr
operator|==
name|prog
operator|->
name|float_substr
condition|)
block|{
comment|/* If flags& SOMETHING - do not do it many times on the same match */
name|SvREFCNT_dec
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
expr_stmt|;
name|prog
operator|->
name|check_substr
operator|=
name|Nullsv
expr_stmt|;
comment|/* disable */
name|prog
operator|->
name|float_substr
operator|=
name|Nullsv
expr_stmt|;
comment|/* clear */
name|s
operator|=
name|strpos
expr_stmt|;
comment|/* XXXX This is a remnant of the old implementation.  It 	            looks wasteful, since now INTUIT can use many 	            other heuristics. */
name|prog
operator|->
name|reganch
operator|&=
operator|~
name|RE_USE_INTUIT
expr_stmt|;
block|}
else|else
name|s
operator|=
name|strpos
expr_stmt|;
block|}
comment|/* Last resort... */
comment|/* XXXX BmUSEFUL already changed, maybe multiple change is meaningful... */
if|if
condition|(
name|prog
operator|->
name|regstclass
condition|)
block|{
comment|/* minlen == 0 is possible if regstclass is \b or \B, 	   and the fixed substr is ''$. 	   Since minlen is already taken into account, s+1 is before strend; 	   accidentally, minlen>= 1 guaranties no false positives at s + 1 	   even for \b or \B.  But (minlen? 1 : 0) below assumes that 	   regstclass does not come from lookahead...  */
comment|/* If regstclass takes bytelength more than 1: If charlength==1, OK. 	   This leaves EXACTF only, which is dealt with in find_byclass().  */
name|int
name|cl_l
init|=
operator|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|prog
operator|->
name|regstclass
argument_list|)
index|]
operator|==
name|EXACT
condition|?
name|STR_LEN
argument_list|(
name|prog
operator|->
name|regstclass
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|endpos
init|=
operator|(
name|prog
operator|->
name|anchored_substr
operator|||
name|ml_anch
operator|)
condition|?
name|s
operator|+
operator|(
name|prog
operator|->
name|minlen
condition|?
name|cl_l
else|:
literal|0
operator|)
else|:
operator|(
name|prog
operator|->
name|float_substr
condition|?
name|check_at
operator|-
name|start_shift
operator|+
name|cl_l
else|:
name|strend
operator|)
decl_stmt|;
name|char
modifier|*
name|startpos
init|=
name|sv
operator|&&
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|?
name|strend
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
else|:
name|s
decl_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_UTF8
condition|)
block|{
name|PL_regdata
operator|=
name|prog
operator|->
name|data
expr_stmt|;
comment|/* Used by REGINCLASS UTF logic */
name|PL_bostr
operator|=
name|startpos
expr_stmt|;
block|}
name|s
operator|=
name|find_byclass
argument_list|(
name|prog
argument_list|,
name|prog
operator|->
name|regstclass
argument_list|,
name|s
argument_list|,
name|endpos
argument_list|,
name|startpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|char
modifier|*
name|what
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|endpos
operator|==
name|strend
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Could not match STCLASS...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"This position contradicts STCLASS...\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
operator|&&
operator|!
name|ml_anch
condition|)
goto|goto
name|fail
goto|;
comment|/* Contradict one of substrings */
if|if
condition|(
name|prog
operator|->
name|anchored_substr
condition|)
block|{
if|if
condition|(
name|prog
operator|->
name|anchored_substr
operator|==
name|check
condition|)
block|{
name|DEBUG_r
argument_list|(
name|what
operator|=
literal|"anchored"
argument_list|)
expr_stmt|;
name|hop_and_restart
label|:
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* Used in HOP() */
name|s
operator|=
name|HOPc
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|+
name|start_shift
operator|+
name|end_shift
operator|>
name|strend
condition|)
block|{
comment|/* XXXX Should be taken into account earlier? */
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Could not match STCLASS...\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Trying %s substr starting at offset %ld...\n"
argument_list|,
name|what
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|+
name|start_shift
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Have both, check_string is floating */
if|if
condition|(
name|t
operator|+
name|start_shift
operator|>=
name|check_at
condition|)
comment|/* Contradicts floating=check */
goto|goto
name|retry_floating_check
goto|;
comment|/* Recheck anchored substring, but not floating... */
name|s
operator|=
name|check_at
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Trying anchored substr starting at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|other_last
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|do_other_anchored
goto|;
block|}
comment|/* Another way we could have checked stclass at the                current position only: */
if|if
condition|(
name|ml_anch
condition|)
block|{
name|s
operator|=
name|t
operator|=
name|t
operator|+
literal|1
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Trying /^/m starting at offset %ld...\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|t
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|try_at_offset
goto|;
block|}
if|if
condition|(
operator|!
name|prog
operator|->
name|float_substr
condition|)
comment|/* Could have been deleted */
goto|goto
name|fail
goto|;
comment|/* Check is floating subtring. */
name|retry_floating_check
label|:
name|t
operator|=
name|check_at
operator|-
name|start_shift
expr_stmt|;
name|DEBUG_r
argument_list|(
name|what
operator|=
literal|"floating"
argument_list|)
expr_stmt|;
goto|goto
name|hop_and_restart
goto|;
block|}
name|DEBUG_r
argument_list|(
argument|if (t != s) 		     PerlIO_printf(Perl_debug_log,
literal|"By STCLASS: moving %ld --> %ld\n"
argument|, 			(long)(t - i_strpos), (long)(s - i_strpos)); 		 else 		     PerlIO_printf(Perl_debug_log,
literal|"Does not contradict STCLASS...\n"
argument|)
argument_list|)
empty_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sGuessed:%s match at offset %ld\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|-
name|i_strpos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
name|fail_finish
label|:
comment|/* Substring not found */
if|if
condition|(
name|prog
operator|->
name|check_substr
condition|)
comment|/* could be removed already */
name|BmUSEFUL
argument_list|(
name|prog
operator|->
name|check_substr
argument_list|)
operator|+=
literal|5
expr_stmt|;
comment|/* hooray */
name|fail
label|:
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sMatch rejected by optimizer%s\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* We know what class REx starts with.  Try to find this position... */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|S_find_byclass
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|prog
parameter_list|,
name|regnode
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|strend
parameter_list|,
name|char
modifier|*
name|startpos
parameter_list|,
name|I32
name|norun
parameter_list|)
block|{
name|I32
name|doevery
init|=
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
operator|)
operator|==
literal|0
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
name|STRLEN
name|ln
decl_stmt|;
name|unsigned
name|int
name|c1
decl_stmt|;
name|unsigned
name|int
name|c2
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
specifier|register
name|I32
name|tmp
init|=
literal|1
decl_stmt|;
comment|/* Scratch variable? */
comment|/* We know what class it must start with. */
switch|switch
condition|(
name|OP
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|ANYOFUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|REGINCLASSUTF8
argument_list|(
name|c
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|REGINCLASS
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|EXACTF
case|:
name|m
operator|=
name|STRING
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ln
operator|=
name|STR_LEN
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|*
operator|(
name|U8
operator|*
operator|)
name|m
expr_stmt|;
name|c2
operator|=
name|PL_fold
index|[
name|c1
index|]
expr_stmt|;
goto|goto
name|do_exactf
goto|;
case|case
name|EXACTFL
case|:
name|m
operator|=
name|STRING
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ln
operator|=
name|STR_LEN
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|*
operator|(
name|U8
operator|*
operator|)
name|m
expr_stmt|;
name|c2
operator|=
name|PL_fold_locale
index|[
name|c1
index|]
expr_stmt|;
name|do_exactf
label|:
name|e
operator|=
name|strend
operator|-
name|ln
expr_stmt|;
if|if
condition|(
name|norun
operator|&&
name|e
operator|<
name|s
condition|)
name|e
operator|=
name|s
expr_stmt|;
comment|/* Due to minlen logic of intuit() */
comment|/* Here it is NOT UTF!  */
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
block|{
while|while
condition|(
name|s
operator|<=
name|e
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|==
name|c1
operator|&&
operator|(
name|ln
operator|==
literal|1
operator|||
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|EXACTF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|ln
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<=
name|e
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|==
name|c1
operator|||
operator|*
operator|(
name|U8
operator|*
operator|)
name|s
operator|==
name|c2
operator|)
operator|&&
operator|(
name|ln
operator|==
literal|1
operator|||
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|EXACTF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|m
argument_list|,
name|ln
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUND
case|:
name|tmp
operator|=
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|UCHARAT
argument_list|(
name|s
operator|-
literal|1
argument_list|)
else|:
literal|'\n'
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUND
condition|?
name|isALNUM
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUND
condition|?
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|prog
operator|->
name|minlen
operator|&&
name|tmp
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|BOUNDLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUNDUTF8
case|:
name|tmp
operator|=
operator|(
name|I32
operator|)
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|utf8_to_uv
argument_list|(
name|reghop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
literal|'\n'
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUNDUTF8
condition|?
name|isALNUM_uni
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC_uni
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|BOUNDUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
else|:
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|)
condition|)
block|{
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|prog
operator|->
name|minlen
operator|&&
name|tmp
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|NBOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NBOUND
case|:
name|tmp
operator|=
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|UCHARAT
argument_list|(
name|s
operator|-
literal|1
argument_list|)
else|:
literal|'\n'
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUND
condition|?
name|isALNUM
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUND
condition|?
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
operator|)
condition|)
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|prog
operator|->
name|minlen
operator|&&
operator|!
name|tmp
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|NBOUNDLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NBOUNDUTF8
case|:
name|tmp
operator|=
operator|(
name|I32
operator|)
operator|(
name|s
operator|!=
name|startpos
operator|)
condition|?
name|utf8_to_uv
argument_list|(
name|reghop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
literal|'\n'
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUNDUTF8
condition|?
name|isALNUM_uni
argument_list|(
name|tmp
argument_list|)
else|:
name|isALNUM_LC_uni
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
operator|!
operator|(
name|OP
argument_list|(
name|c
argument_list|)
operator|==
name|NBOUNDUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
else|:
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|)
condition|)
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|prog
operator|->
name|minlen
operator|&&
operator|!
name|tmp
operator|)
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ALNUMUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUMUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACEUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACEUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isSPACE_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|==
literal|' '
operator|||
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIGITUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIGITL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isDIGIT_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIGITLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isDIGIT_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NDIGITUTF8
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NDIGITL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT_LC
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NDIGITLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
operator|(
name|norun
operator|||
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: unknown regstclass %d"
argument_list|,
operator|(
name|int
operator|)
name|OP
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
name|got_it
label|:
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  - regexec_flags - match a regexp against a string  */
end_comment

begin_function
name|I32
name|Perl_regexec_flags
parameter_list|(
name|pTHX_
specifier|register
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|stringarg
parameter_list|,
specifier|register
name|char
modifier|*
name|strend
parameter_list|,
name|char
modifier|*
name|strbeg
parameter_list|,
name|I32
name|minend
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|U32
name|flags
parameter_list|)
comment|/* strend: pointer to null at end of string */
comment|/* strbeg: real beginning of string */
comment|/* minend: end of match must be>=minend after stringarg. */
comment|/* data: May be used for some additional optimizations. */
comment|/* nosave: For optimizations. */
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|regnode
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|startpos
init|=
name|stringarg
decl_stmt|;
name|I32
name|minlen
decl_stmt|;
comment|/* must match at least this many chars */
name|I32
name|dontbother
init|=
literal|0
decl_stmt|;
comment|/* how many characters not to try at end */
comment|/* I32 start_shift = 0; */
comment|/* Offset of the start to find 					 constant substr. */
comment|/* CC */
name|I32
name|end_shift
init|=
literal|0
decl_stmt|;
comment|/* Same for the end. */
comment|/* CC */
name|I32
name|scream_pos
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Internal iterator of scream. */
name|char
modifier|*
name|scream_olds
decl_stmt|;
name|SV
modifier|*
name|oreplsv
init|=
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
decl_stmt|;
name|PL_regcc
operator|=
literal|0
expr_stmt|;
name|cache_re
argument_list|(
name|prog
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regnarrate
operator|=
name|PL_debug
operator|&
literal|512
expr_stmt|;
endif|#
directive|endif
comment|/* Be paranoid... */
if|if
condition|(
name|prog
operator|==
name|NULL
operator|||
name|startpos
operator|==
name|NULL
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"NULL regexp parameter"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|minlen
operator|=
name|prog
operator|->
name|minlen
expr_stmt|;
if|if
condition|(
name|strend
operator|-
name|startpos
operator|<
name|minlen
condition|)
goto|goto
name|phooey
goto|;
if|if
condition|(
name|startpos
operator|==
name|strbeg
condition|)
comment|/* is ^ valid at stringarg? */
name|PL_regprev
operator|=
literal|'\n'
expr_stmt|;
else|else
block|{
name|PL_regprev
operator|=
operator|(
name|U32
operator|)
name|stringarg
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|PL_multiline
operator|&&
name|PL_regprev
operator|==
literal|'\n'
condition|)
name|PL_regprev
operator|=
literal|'\0'
expr_stmt|;
comment|/* force ^ to NOT match */
block|}
comment|/* Check validity of program. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|prog
operator|->
name|program
argument_list|)
operator|!=
name|REG_MAGIC
condition|)
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"corrupted regexp program"
argument_list|)
expr_stmt|;
block|}
name|PL_reg_flags
operator|=
literal|0
expr_stmt|;
name|PL_reg_eval_set
operator|=
literal|0
expr_stmt|;
name|PL_reg_maxiter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_UTF8
condition|)
name|PL_reg_flags
operator||=
name|RF_utf8
expr_stmt|;
comment|/* Mark beginning of line for ^ and lookbehind. */
name|PL_regbol
operator|=
name|startpos
expr_stmt|;
name|PL_bostr
operator|=
name|strbeg
expr_stmt|;
name|PL_reg_sv
operator|=
name|sv
expr_stmt|;
comment|/* Mark end of line for $ (and such) */
name|PL_regeol
operator|=
name|strend
expr_stmt|;
comment|/* see how far we have to get to not match where we matched before */
name|PL_regtill
operator|=
name|startpos
operator|+
name|minend
expr_stmt|;
comment|/* We start without call_cc context.  */
name|PL_reg_call_cc
operator|=
literal|0
expr_stmt|;
comment|/* If there is a "must appear" string, look for it. */
name|s
operator|=
name|startpos
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_GPOS_SEEN
condition|)
block|{
comment|/* Need to have PL_reg_ganch */
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|REXEC_IGNOREPOS
condition|)
comment|/* Means: check only at start */
name|PL_reg_ganch
operator|=
name|startpos
expr_stmt|;
elseif|else
if|if
condition|(
name|sv
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|&&
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
block|{
name|PL_reg_ganch
operator|=
name|strbeg
operator|+
name|mg
operator|->
name|mg_len
expr_stmt|;
comment|/* Defined pos() */
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|PL_reg_ganch
condition|)
goto|goto
name|phooey
goto|;
name|s
operator|=
name|PL_reg_ganch
expr_stmt|;
block|}
block|}
else|else
comment|/* pos() not defined */
name|PL_reg_ganch
operator|=
name|strbeg
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REXEC_CHECKED
operator|)
operator|&&
name|prog
operator|->
name|check_substr
operator|!=
name|Nullsv
condition|)
block|{
name|re_scream_pos_data
name|d
decl_stmt|;
name|d
operator|.
name|scream_olds
operator|=
operator|&
name|scream_olds
expr_stmt|;
name|d
operator|.
name|scream_pos
operator|=
operator|&
name|scream_pos
expr_stmt|;
name|s
operator|=
name|re_intuit_start
argument_list|(
name|prog
argument_list|,
name|sv
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|flags
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
goto|goto
name|phooey
goto|;
comment|/* not present */
block|}
name|DEBUG_r
argument_list|(
argument|if (!PL_colorset) reginitcolors()
argument_list|)
empty_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sMatching REx%s `%s%.60s%s%s' against `%s%.*s%s%s'\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|prog
operator|->
name|precomp
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strlen
argument_list|(
name|prog
operator|->
name|precomp
argument_list|)
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|startpos
operator|>
literal|60
condition|?
literal|60
else|:
name|strend
operator|-
name|startpos
argument_list|)
argument_list|,
name|startpos
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strend
operator|-
name|startpos
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplest case:  anchored match need be tried only once. */
comment|/*  [unless only anchor is BOL and multiline is set] */
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
operator|(
name|ROPT_ANCH
operator|&
operator|~
name|ROPT_ANCH_GPOS
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|startpos
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|startpos
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
elseif|else
if|if
condition|(
name|PL_multiline
operator|||
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
operator|)
operator|||
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_MBOL
operator|)
condition|)
comment|/* XXXX SBOL? */
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|HOPc
argument_list|(
name|strend
argument_list|,
operator|-
name|dontbother
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* for multiline we only have to try after newlines */
if|if
condition|(
name|prog
operator|->
name|check_substr
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|startpos
condition|)
goto|goto
name|after_try
goto|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|after_try
label|:
if|if
condition|(
name|s
operator|>=
name|end
condition|)
goto|goto
name|phooey
goto|;
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|RE_USE_INTUIT
condition|)
block|{
name|s
operator|=
name|re_intuit_start
argument_list|(
name|prog
argument_list|,
name|sv
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|strend
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
goto|goto
name|phooey
goto|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|>
name|startpos
condition|)
name|s
operator|--
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
comment|/* don't need PL_utf8skip here */
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
block|}
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
elseif|else
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH_GPOS
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|PL_reg_ganch
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
goto|goto
name|phooey
goto|;
block|}
comment|/* Messy cases:  unanchored match. */
if|if
condition|(
name|prog
operator|->
name|anchored_substr
operator|&&
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
block|{
comment|/* we have /x+whatever/ */
comment|/* it must be a one character string (XXXX Except UTF?) */
name|char
name|ch
init|=
name|SvPVX
argument_list|(
name|prog
operator|->
name|anchored_substr
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|ch
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|==
name|ch
condition|)
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|ch
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|==
name|ch
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|prog
operator|->
name|anchored_substr
operator|!=
name|Nullsv
operator|||
operator|(
name|prog
operator|->
name|float_substr
operator|!=
name|Nullsv
operator|&&
name|prog
operator|->
name|float_max_offset
operator|<
name|strend
operator|-
name|s
operator|)
condition|)
block|{
name|SV
modifier|*
name|must
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_substr
else|:
name|prog
operator|->
name|float_substr
decl_stmt|;
name|I32
name|back_max
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_offset
else|:
name|prog
operator|->
name|float_max_offset
decl_stmt|;
name|I32
name|back_min
init|=
name|prog
operator|->
name|anchored_substr
condition|?
name|prog
operator|->
name|anchored_offset
else|:
name|prog
operator|->
name|float_min_offset
decl_stmt|;
name|char
modifier|*
name|last
init|=
name|HOPc
argument_list|(
name|strend
argument_list|,
comment|/* Cannot start after this */
operator|-
call|(
name|I32
call|)
argument_list|(
name|CHR_SVLEN
argument_list|(
name|must
argument_list|)
operator|-
operator|(
name|SvTAIL
argument_list|(
name|must
argument_list|)
operator|!=
literal|0
operator|)
operator|+
name|back_min
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|last1
decl_stmt|;
comment|/* Last position checked before */
if|if
condition|(
name|s
operator|>
name|PL_bostr
condition|)
name|last1
operator|=
name|HOPc
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|last1
operator|=
name|s
operator|-
literal|1
expr_stmt|;
comment|/* bogus */
comment|/* XXXX check_substr already used to find `s', can optimize if 	   check_substr==must. */
name|scream_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|dontbother
operator|=
name|end_shift
expr_stmt|;
name|strend
operator|=
name|HOPc
argument_list|(
name|strend
argument_list|,
operator|-
name|dontbother
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|<=
name|last
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|REXEC_SCREAM
operator|)
condition|?
operator|(
name|s
operator|=
name|screaminstr
argument_list|(
name|sv
argument_list|,
name|must
argument_list|,
name|HOPc
argument_list|(
name|s
argument_list|,
name|back_min
argument_list|)
operator|-
name|strbeg
argument_list|,
name|end_shift
argument_list|,
operator|&
name|scream_pos
argument_list|,
literal|0
argument_list|)
operator|)
else|:
operator|(
name|s
operator|=
name|fbm_instr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|HOP
argument_list|(
name|s
argument_list|,
name|back_min
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|must
argument_list|,
name|PL_multiline
condition|?
name|FBMrf_MULTILINE
else|:
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|HOPc
argument_list|(
name|s
argument_list|,
operator|-
name|back_max
argument_list|)
operator|>
name|last1
condition|)
block|{
name|last1
operator|=
name|HOPc
argument_list|(
name|s
argument_list|,
operator|-
name|back_min
argument_list|)
expr_stmt|;
name|s
operator|=
name|HOPc
argument_list|(
name|s
argument_list|,
operator|-
name|back_max
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|t
init|=
operator|(
name|last1
operator|>=
name|PL_bostr
operator|)
condition|?
name|HOPc
argument_list|(
name|last1
argument_list|,
literal|1
argument_list|)
else|:
name|last1
operator|+
literal|1
decl_stmt|;
name|last1
operator|=
name|HOPc
argument_list|(
name|s
argument_list|,
operator|-
name|back_min
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|UTF
condition|)
block|{
while|while
condition|(
name|s
operator|<=
name|last1
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<=
name|last1
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|prog
operator|->
name|regstclass
operator|)
condition|)
block|{
if|if
condition|(
name|minlen
operator|&&
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|prog
operator|->
name|regstclass
argument_list|)
index|]
operator|!=
name|EXACT
condition|)
comment|/* don't bother with what can't match */
name|strend
operator|=
name|HOPc
argument_list|(
name|strend
argument_list|,
operator|-
operator|(
name|minlen
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_byclass
argument_list|(
name|prog
argument_list|,
name|c
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|startpos
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
else|else
block|{
name|dontbother
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|float_substr
operator|!=
name|Nullsv
condition|)
block|{
comment|/* Trim the end. */
name|char
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|REXEC_SCREAM
condition|)
block|{
name|last
operator|=
name|screaminstr
argument_list|(
name|sv
argument_list|,
name|prog
operator|->
name|float_substr
argument_list|,
name|s
operator|-
name|strbeg
argument_list|,
name|end_shift
argument_list|,
operator|&
name|scream_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* last one */
if|if
condition|(
operator|!
name|last
condition|)
name|last
operator|=
name|scream_olds
expr_stmt|;
comment|/* Only one occurence. */
block|}
else|else
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|little
init|=
name|SvPV
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvTAIL
argument_list|(
name|prog
operator|->
name|float_substr
argument_list|)
condition|)
block|{
if|if
condition|(
name|memEQ
argument_list|(
name|strend
operator|-
name|len
operator|+
literal|1
argument_list|,
name|little
argument_list|,
name|len
operator|-
literal|1
argument_list|)
condition|)
name|last
operator|=
name|strend
operator|-
name|len
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|PL_multiline
condition|)
name|last
operator|=
name|memEQ
argument_list|(
name|strend
operator|-
name|len
argument_list|,
name|little
argument_list|,
name|len
argument_list|)
condition|?
name|strend
operator|-
name|len
else|:
name|Nullch
expr_stmt|;
else|else
goto|goto
name|find_last
goto|;
block|}
else|else
block|{
name|find_last
label|:
if|if
condition|(
name|len
condition|)
name|last
operator|=
name|rninstr
argument_list|(
name|s
argument_list|,
name|strend
argument_list|,
name|little
argument_list|,
name|little
operator|+
name|len
argument_list|)
expr_stmt|;
else|else
name|last
operator|=
name|strend
expr_stmt|;
comment|/* matching `$' */
block|}
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
goto|goto
name|phooey
goto|;
comment|/* Should not happen! */
name|dontbother
operator|=
name|strend
operator|-
name|last
operator|+
name|prog
operator|->
name|float_min_offset
expr_stmt|;
block|}
if|if
condition|(
name|minlen
operator|&&
operator|(
name|dontbother
operator|<
name|minlen
operator|)
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* this one's always in bytes! */
comment|/* We don't know much -- general case. */
if|if
condition|(
name|UTF
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
if|if
condition|(
name|s
operator|>=
name|strend
condition|)
break|break;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
do|while
condition|(
name|s
operator|++
operator|<
name|strend
condition|)
do|;
block|}
block|}
comment|/* Failure. */
goto|goto
name|phooey
goto|;
name|got_it
label|:
name|RX_MATCH_TAINTED_set
argument_list|(
name|prog
argument_list|,
name|PL_reg_flags
operator|&
name|RF_tainted
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_reg_eval_set
condition|)
block|{
comment|/* Preserve the current value of $^R */
if|if
condition|(
name|oreplsv
operator|!=
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
condition|)
name|sv_setsv
argument_list|(
name|oreplsv
argument_list|,
name|GvSV
argument_list|(
name|PL_replgv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* So that when GvSV(replgv) is 						  restored, the value remains 						  the same. */
name|restore_pos
argument_list|(
name|aTHXo_
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* make sure $`, $&, $', and $digit will work later */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REXEC_NOT_FIRST
operator|)
condition|)
block|{
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|prog
argument_list|)
condition|)
block|{
name|Safefree
argument_list|(
name|prog
operator|->
name|subbeg
argument_list|)
expr_stmt|;
name|RX_MATCH_COPIED_off
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|REXEC_COPY_STR
condition|)
block|{
name|I32
name|i
init|=
name|PL_regeol
operator|-
name|startpos
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
decl_stmt|;
name|s
operator|=
name|savepvn
argument_list|(
name|strbeg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prog
operator|->
name|subbeg
operator|=
name|s
expr_stmt|;
name|prog
operator|->
name|sublen
operator|=
name|i
expr_stmt|;
name|RX_MATCH_COPIED_on
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prog
operator|->
name|subbeg
operator|=
name|strbeg
expr_stmt|;
name|prog
operator|->
name|sublen
operator|=
name|PL_regeol
operator|-
name|strbeg
expr_stmt|;
comment|/* strend may have been modified */
block|}
block|}
return|return
literal|1
return|;
name|phooey
label|:
if|if
condition|(
name|PL_reg_eval_set
condition|)
name|restore_pos
argument_list|(
name|aTHXo_
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regtry - try match at specific point  */
end_comment

begin_function
name|STATIC
name|I32
comment|/* 0 failure, 1 success */
name|S_regtry
parameter_list|(
name|pTHX_
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|startpos
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|I32
modifier|*
name|sp
decl_stmt|;
specifier|register
name|I32
modifier|*
name|ep
decl_stmt|;
name|CHECKPOINT
name|lastcp
decl_stmt|;
if|if
condition|(
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_EVAL_SEEN
operator|)
operator|&&
operator|!
name|PL_reg_eval_set
condition|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|PL_reg_eval_set
operator|=
name|RS_init
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|DEBUG_s( 	    PerlIO_printf(Perl_debug_log,
literal|"  setting stack tmpbase at %"
argument|IVdf
literal|"\n"
argument|, 			  (IV)(PL_stack_sp - PL_stack_base)); 	    )
argument_list|)
empty_stmt|;
name|SAVEI32
argument_list|(
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
argument_list|)
expr_stmt|;
name|cxstack
index|[
name|cxstack_ix
index|]
operator|.
name|blk_oldsp
operator|=
name|PL_stack_sp
operator|-
name|PL_stack_base
expr_stmt|;
comment|/* Otherwise OP_NEXTSTATE will free whatever on stack now.  */
name|SAVETMPS
expr_stmt|;
comment|/* Apparently this is not needed, judging by wantarray. */
comment|/* SAVEI8(cxstack[cxstack_ix].blk_gimme); 	   cxstack[cxstack_ix].blk_gimme = G_SCALAR; */
if|if
condition|(
name|PL_reg_sv
condition|)
block|{
comment|/* Make $_ available to executed code. */
if|if
condition|(
name|PL_reg_sv
operator|!=
name|DEFSV
condition|)
block|{
comment|/* SAVE_DEFSV does *not* suffice here for USE_THREADS */
name|SAVESPTR
argument_list|(
name|DEFSV
argument_list|)
expr_stmt|;
name|DEFSV
operator|=
name|PL_reg_sv
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|SvTYPE
argument_list|(
name|PL_reg_sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|PL_reg_sv
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|PL_reg_sv
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* prepare for quick setting of pos */
name|sv_magic
argument_list|(
name|PL_reg_sv
argument_list|,
operator|(
name|SV
operator|*
operator|)
literal|0
argument_list|,
literal|'g'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|PL_reg_sv
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|PL_reg_magic
operator|=
name|mg
expr_stmt|;
name|PL_reg_oldpos
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
name|SAVEDESTRUCTOR_X
argument_list|(
name|restore_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PL_reg_curpm
condition|)
name|Newz
argument_list|(
literal|22
argument_list|,
name|PL_reg_curpm
argument_list|,
literal|1
argument_list|,
name|PMOP
argument_list|)
expr_stmt|;
name|PL_reg_curpm
operator|->
name|op_pmregexp
operator|=
name|prog
expr_stmt|;
name|PL_reg_oldcurpm
operator|=
name|PL_curpm
expr_stmt|;
name|PL_curpm
operator|=
name|PL_reg_curpm
expr_stmt|;
if|if
condition|(
name|RX_MATCH_COPIED
argument_list|(
name|prog
argument_list|)
condition|)
block|{
comment|/*  Here is a serious problem: we cannot rewrite subbeg, 		since it may be needed if this match fails.  Thus 		$` inside (?{}) could fail... */
name|PL_reg_oldsaved
operator|=
name|prog
operator|->
name|subbeg
expr_stmt|;
name|PL_reg_oldsavedlen
operator|=
name|prog
operator|->
name|sublen
expr_stmt|;
name|RX_MATCH_COPIED_off
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
else|else
name|PL_reg_oldsaved
operator|=
name|Nullch
expr_stmt|;
name|prog
operator|->
name|subbeg
operator|=
name|PL_bostr
expr_stmt|;
name|prog
operator|->
name|sublen
operator|=
name|PL_regeol
operator|-
name|PL_bostr
expr_stmt|;
comment|/* strend may have been modified */
block|}
name|prog
operator|->
name|startp
index|[
literal|0
index|]
operator|=
name|startpos
operator|-
name|PL_bostr
expr_stmt|;
name|PL_reginput
operator|=
name|startpos
expr_stmt|;
name|PL_regstartp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|PL_regendp
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
name|PL_reglastparen
operator|=
operator|&
name|prog
operator|->
name|lastparen
expr_stmt|;
name|prog
operator|->
name|lastparen
operator|=
literal|0
expr_stmt|;
name|PL_regsize
operator|=
literal|0
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PL_reg_starttry
operator|=
name|startpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_reg_start_tmpl
operator|<=
name|prog
operator|->
name|nparens
condition|)
block|{
name|PL_reg_start_tmpl
operator|=
name|prog
operator|->
name|nparens
operator|*
literal|3
operator|/
literal|2
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|PL_reg_start_tmp
condition|)
name|Renew
argument_list|(
name|PL_reg_start_tmp
argument_list|,
name|PL_reg_start_tmpl
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|22
argument_list|,
name|PL_reg_start_tmp
argument_list|,
name|PL_reg_start_tmpl
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* XXXX What this code is doing here?!!!  There should be no need        to do this again and again, PL_reglastparen should take care of        this!  */
name|sp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|ep
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|nparens
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prog
operator|->
name|nparens
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
operator|*
operator|++
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
operator|++
name|ep
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|prog
operator|->
name|program
operator|+
literal|1
argument_list|)
condition|)
block|{
name|prog
operator|->
name|endp
index|[
literal|0
index|]
operator|=
name|PL_reginput
operator|-
name|PL_bostr
expr_stmt|;
return|return
literal|1
return|;
block|}
name|REGCP_UNWIND
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regmatch - main matching routine  *  * Conceptually the strategy is simple:  check to see whether the current  * node matches, call self recursively to see whether the rest matches,  * and then act accordingly.  In practice we make some effort to avoid  * recursion, in particular by going through "ordinary" nodes (that don't  * need to know whether the rest of the match failed) by a loop instead of  * by recursion.  */
end_comment

begin_comment
comment|/* [lwall] I've hoisted the register declarations to the outer block in order to  * maybe save a little bit of pushing and popping on the stack.  It also takes  * advantage of machines that use a register save mask on subroutine entry.  */
end_comment

begin_function
name|STATIC
name|I32
comment|/* 0 failure, 1 success */
name|S_regmatch
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|prog
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|regnode
modifier|*
name|scan
decl_stmt|;
comment|/* Current node. */
name|regnode
modifier|*
name|next
decl_stmt|;
comment|/* Next node. */
name|regnode
modifier|*
name|inner
decl_stmt|;
comment|/* Next node in internal branch. */
specifier|register
name|I32
name|nextchr
decl_stmt|;
comment|/* renamed nextchr - nextchar colides with 				   function of same name */
specifier|register
name|I32
name|n
decl_stmt|;
comment|/* no or next */
specifier|register
name|I32
name|ln
decl_stmt|;
comment|/* len or last */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* operand or save */
specifier|register
name|char
modifier|*
name|locinput
init|=
name|PL_reginput
decl_stmt|;
specifier|register
name|I32
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|paren
decl_stmt|;
comment|/* case fold search, parenth */
name|int
name|minmod
init|=
literal|0
decl_stmt|,
name|sw
init|=
literal|0
decl_stmt|,
name|logical
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Note that nextchr is a byte even in UTF */
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
name|scan
operator|=
name|prog
expr_stmt|;
while|while
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
define|#
directive|define
name|sayNO_L
value|(logical ? (logical = 0, sw = 0, goto cont) : sayNO)
ifdef|#
directive|ifdef
name|DEBUGGING
define|#
directive|define
name|sayYES
value|goto yes
define|#
directive|define
name|sayNO
value|goto no
define|#
directive|define
name|sayYES_FINAL
value|goto yes_final
define|#
directive|define
name|sayYES_LOUD
value|goto yes_loud
define|#
directive|define
name|sayNO_FINAL
value|goto no_final
define|#
directive|define
name|sayNO_SILENT
value|goto do_no
define|#
directive|define
name|saySAME
parameter_list|(
name|x
parameter_list|)
value|if (x) goto yes; else goto no
define|#
directive|define
name|REPORT_CODE_OFF
value|24
else|#
directive|else
define|#
directive|define
name|sayYES
value|return 1
define|#
directive|define
name|sayNO
value|return 0
define|#
directive|define
name|sayYES_FINAL
value|return 1
define|#
directive|define
name|sayYES_LOUD
value|return 1
define|#
directive|define
name|sayNO_FINAL
value|return 0
define|#
directive|define
name|sayNO_SILENT
value|return 0
define|#
directive|define
name|saySAME
parameter_list|(
name|x
parameter_list|)
value|return x
endif|#
directive|endif
name|DEBUG_r
argument_list|(
argument|{ 	    SV *prop = sv_newmortal(); 	    int docolor = *PL_colors[
literal|0
argument|]; 	    int taill = (docolor ?
literal|10
argument|:
literal|7
argument|);
comment|/* 3 chars for "><" */
argument|int l = (PL_regeol - locinput> taill ? taill : PL_regeol - locinput);
comment|/* The part of the string before starttry has one color 	       (pref0_len chars), between starttry and current 	       position another one (pref_len - pref0_len chars), 	       after the current position the third one. 	       We assume that pref0_len<= pref_len, otherwise we 	       decrease pref0_len.  */
argument|int pref_len = (locinput - PL_bostr> (
literal|5
argument|+ taill) - l  			    ? (
literal|5
argument|+ taill) - l : locinput - PL_bostr); 	    int pref0_len = pref_len  - (locinput - PL_reg_starttry);  	    if (l + pref_len< (
literal|5
argument|+ taill)&& l< PL_regeol - locinput) 		l = ( PL_regeol - locinput> (
literal|5
argument|+ taill) - pref_len  		      ? (
literal|5
argument|+ taill) - pref_len : PL_regeol - locinput); 	    if (pref0_len<
literal|0
argument|) 		pref0_len =
literal|0
argument|; 	    if (pref0_len> pref_len) 		pref0_len = pref_len; 	    regprop(prop, scan); 	    PerlIO_printf(Perl_debug_log,
literal|"%4"
argument|IVdf
literal|"<%s%.*s%s%s%.*s%s%s%s%.*s%s>%*s|%3"
argument|IVdf
literal|":%*s%s\n"
argument|, 			  (IV)(locinput - PL_bostr),  			  PL_colors[
literal|4
argument|], pref0_len,  			  locinput - pref_len, PL_colors[
literal|5
argument|], 			  PL_colors[
literal|2
argument|], pref_len - pref0_len,  			  locinput - pref_len + pref0_len, PL_colors[
literal|3
argument|], 			  (docolor ?
literal|""
argument|:
literal|"><"
argument|), 			  PL_colors[
literal|0
argument|], l, locinput, PL_colors[
literal|1
argument|],
literal|15
argument|- l - pref_len +
literal|1
argument|,
literal|""
argument|, 			  (IV)(scan - PL_regprogram), PL_regindent*
literal|2
argument|,
literal|""
argument|, 			  SvPVX(prop)); 	}
argument_list|)
empty_stmt|;
name|next
operator|=
name|scan
operator|+
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_bostr
condition|?
name|PL_regprev
operator|==
literal|'\n'
else|:
operator|(
name|PL_multiline
operator|&&
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|locinput
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* regtill = regbol; */
break|break;
block|}
name|sayNO
expr_stmt|;
case|case
name|MBOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_bostr
condition|?
name|PL_regprev
operator|==
literal|'\n'
else|:
operator|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|locinput
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
name|sayNO
expr_stmt|;
case|case
name|SBOL
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_regbol
operator|&&
name|PL_regprev
operator|==
literal|'\n'
condition|)
break|break;
name|sayNO
expr_stmt|;
case|case
name|GPOS
case|:
if|if
condition|(
name|locinput
operator|==
name|PL_reg_ganch
condition|)
break|break;
name|sayNO
expr_stmt|;
case|case
name|EOL
case|:
if|if
condition|(
name|PL_multiline
condition|)
goto|goto
name|meol
goto|;
else|else
goto|goto
name|seol
goto|;
case|case
name|MEOL
case|:
name|meol
label|:
if|if
condition|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|nextchr
operator|!=
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SEOL
case|:
name|seol
label|:
if|if
condition|(
operator|(
name|nextchr
operator|||
name|locinput
operator|<
name|PL_regeol
operator|)
operator|&&
name|nextchr
operator|!=
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|>
literal|1
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|EOS
case|:
if|if
condition|(
name|PL_regeol
operator|!=
name|locinput
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SANYUTF8
case|:
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
if|if
condition|(
name|locinput
operator|>
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|SANY
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYUTF8
case|:
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
if|if
condition|(
name|locinput
operator|>
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
operator|)
operator|||
name|nextchr
operator|==
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_ANY
case|:
if|if
condition|(
operator|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
operator|)
operator|||
name|nextchr
operator|==
literal|'\n'
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACT
case|:
name|s
operator|=
name|STRING
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|ln
operator|=
name|STR_LEN
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
name|memNE
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXACTFL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|EXACTF
case|:
name|s
operator|=
name|STRING
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|ln
operator|=
name|STR_LEN
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|locinput
decl_stmt|;
name|char
modifier|*
name|e
init|=
name|s
operator|+
name|ln
decl_stmt|;
name|c1
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTF
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|l
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|utf8_to_uv
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|)
operator|!=
operator|(
name|c1
condition|?
name|toLOWER_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|l
argument_list|)
else|:
name|toLOWER_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|l
argument_list|)
operator|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|l
operator|+=
name|UTF8SKIP
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|locinput
operator|=
name|l
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
operator|&&
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
operator|(
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTF
operator|)
condition|?
name|PL_fold
else|:
name|PL_fold_locale
operator|)
index|[
name|nextchr
index|]
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|PL_regeol
operator|-
name|locinput
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYOFUTF8
case|:
if|if
condition|(
operator|!
name|REGINCLASSUTF8
argument_list|(
name|scan
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
if|if
condition|(
name|nextchr
operator|<
literal|0
condition|)
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REGINCLASS
argument_list|(
name|scan
argument_list|,
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ALNUM
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|ALNUM
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ALNUMUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|ALNUMUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
operator|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|ALNUMUTF8
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NALNUM
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NALNUM
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NALNUMUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NALNUMUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NALNUMUTF8
condition|?
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
else|:
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUNDL
case|:
case|case
name|NBOUNDL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUND
case|:
case|case
name|NBOUND
case|:
comment|/* was last char in word? */
name|ln
operator|=
operator|(
name|locinput
operator|!=
name|PL_regbol
operator|)
condition|?
name|UCHARAT
argument_list|(
name|locinput
operator|-
literal|1
argument_list|)
else|:
name|PL_regprev
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUND
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NBOUND
condition|)
block|{
name|ln
operator|=
name|isALNUM
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM
argument_list|(
name|nextchr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|isALNUM_LC
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM_LC
argument_list|(
name|nextchr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|!
name|ln
operator|)
operator|==
operator|(
operator|!
name|n
operator|)
operator|)
operator|==
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUND
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUNDL
operator|)
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|BOUNDLUTF8
case|:
case|case
name|NBOUNDLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|BOUNDUTF8
case|:
case|case
name|NBOUNDUTF8
case|:
comment|/* was last char in word? */
name|ln
operator|=
operator|(
name|locinput
operator|!=
name|PL_regbol
operator|)
condition|?
name|utf8_to_uv
argument_list|(
name|reghop
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
name|PL_regprev
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUNDUTF8
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NBOUNDUTF8
condition|)
block|{
name|ln
operator|=
name|isALNUM_uni
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|isALNUM_LC_uni
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|!
name|ln
operator|)
operator|==
operator|(
operator|!
name|n
operator|)
operator|)
operator|==
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUNDUTF8
operator|||
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUNDLUTF8
operator|)
condition|)
name|sayNO
expr_stmt|;
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SPACE
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SPACE
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SPACEUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SPACEUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
operator|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SPACEUTF8
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NSPACE
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NSPACE
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NSPACEUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NSPACEUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NSPACEUTF8
condition|?
name|isSPACE
argument_list|(
name|nextchr
argument_list|)
else|:
name|isSPACE_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIGITL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|DIGIT
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|DIGIT
condition|?
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
else|:
name|isDIGIT_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIGITLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|DIGITUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|DIGITUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isDIGIT_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
operator|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|DIGITUTF8
condition|?
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
else|:
name|isDIGIT_LC
argument_list|(
name|nextchr
argument_list|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDIGITL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NDIGIT
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NDIGIT
condition|?
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
else|:
name|isDIGIT_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDIGITLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|NDIGITUTF8
case|:
if|if
condition|(
operator|!
name|nextchr
operator|&&
name|locinput
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|nextchr
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NDIGITUTF8
condition|?
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
else|:
name|isDIGIT_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
block|{
name|sayNO
expr_stmt|;
block|}
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|NDIGITUTF8
condition|?
name|isDIGIT
argument_list|(
name|nextchr
argument_list|)
else|:
name|isDIGIT_LC
argument_list|(
name|nextchr
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
operator|++
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLUMP
case|:
if|if
condition|(
name|locinput
operator|>=
name|PL_regeol
operator|||
name|swash_fetch
argument_list|(
name|PL_utf8_mark
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|PL_utf8skip
index|[
name|nextchr
index|]
expr_stmt|;
while|while
condition|(
name|locinput
operator|<
name|PL_regeol
operator|&&
name|swash_fetch
argument_list|(
name|PL_utf8_mark
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|locinput
argument_list|)
condition|)
name|locinput
operator|+=
name|UTF8SKIP
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
if|if
condition|(
name|locinput
operator|>
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFFL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|REF
case|:
case|case
name|REFF
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|ln
operator|=
name|PL_regstartp
index|[
name|n
index|]
expr_stmt|;
name|PL_reg_leftiter
operator|=
name|PL_reg_maxiter
expr_stmt|;
comment|/* Void cache */
if|if
condition|(
operator|*
name|PL_reglastparen
operator|<
name|n
operator|||
name|ln
operator|==
operator|-
literal|1
condition|)
name|sayNO
expr_stmt|;
comment|/* Do not match unless seen CLOSEn. */
if|if
condition|(
name|ln
operator|==
name|PL_regendp
index|[
name|n
index|]
condition|)
break|break;
name|s
operator|=
name|PL_bostr
operator|+
name|ln
expr_stmt|;
if|if
condition|(
name|UTF
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|REF
condition|)
block|{
comment|/* REF can do byte comparison */
name|char
modifier|*
name|l
init|=
name|locinput
decl_stmt|;
name|char
modifier|*
name|e
init|=
name|PL_bostr
operator|+
name|PL_regendp
index|[
name|n
index|]
decl_stmt|;
comment|/* 		 * Note that we can't do the "other character" lookup trick as 		 * in the 8-bit case (no pun intended) because in Unicode we 		 * have to map both upper and title case to lower case. 		 */
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REFF
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|l
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|toLOWER_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|!=
name|toLOWER_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|l
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|l
operator|+=
name|UTF8SKIP
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|l
operator|>=
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|toLOWER_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|s
argument_list|)
operator|!=
name|toLOWER_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|l
argument_list|)
condition|)
name|sayNO
expr_stmt|;
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|l
operator|+=
name|UTF8SKIP
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
name|locinput
operator|=
name|l
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Inline the first character, for speed. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
name|nextchr
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REF
operator|||
operator|(
name|UCHARAT
argument_list|(
name|s
argument_list|)
operator|!=
operator|(
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REFF
condition|?
name|PL_fold
else|:
name|PL_fold_locale
operator|)
index|[
name|nextchr
index|]
operator|)
operator|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|ln
operator|=
name|PL_regendp
index|[
name|n
index|]
operator|-
name|ln
expr_stmt|;
if|if
condition|(
name|locinput
operator|+
name|ln
operator|>
name|PL_regeol
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REF
condition|?
name|memNE
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|REFF
condition|?
name|ibcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
else|:
name|ibcmp_locale
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|)
operator|)
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
case|case
name|TAIL
case|:
break|break;
case|case
name|BACK
case|:
break|break;
case|case
name|EVAL
case|:
block|{
name|dSP
expr_stmt|;
name|OP_4tree
modifier|*
name|oop
init|=
name|PL_op
decl_stmt|;
name|COP
modifier|*
name|ocurcop
init|=
name|PL_curcop
decl_stmt|;
name|SV
modifier|*
modifier|*
name|ocurpad
init|=
name|PL_curpad
decl_stmt|;
name|SV
modifier|*
name|ret
decl_stmt|;
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP_4tree
operator|*
operator|)
name|PL_regdata
operator|->
name|data
index|[
name|n
index|]
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  re_eval 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|PL_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|PL_regdata
operator|->
name|data
index|[
name|n
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|PL_regendp
index|[
literal|0
index|]
operator|=
name|PL_reg_magic
operator|->
name|mg_len
operator|=
name|locinput
operator|-
name|PL_bostr
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
comment|/* Scalar context. */
name|SPAGAIN
expr_stmt|;
name|ret
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|PL_op
operator|=
name|oop
expr_stmt|;
name|PL_curpad
operator|=
name|ocurpad
expr_stmt|;
name|PL_curcop
operator|=
name|ocurcop
expr_stmt|;
if|if
condition|(
name|logical
condition|)
block|{
if|if
condition|(
name|logical
operator|==
literal|2
condition|)
block|{
comment|/* Postponed subexpression. */
name|regexp
modifier|*
name|re
decl_stmt|;
name|MAGIC
modifier|*
name|mg
init|=
name|Null
argument_list|(
name|MAGIC
operator|*
argument_list|)
decl_stmt|;
name|re_cc_state
name|state
decl_stmt|;
name|CHECKPOINT
name|cp
decl_stmt|,
name|lastcp
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|ret
argument_list|)
operator|||
name|SvRMAGICAL
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|sv
init|=
name|SvROK
argument_list|(
name|ret
argument_list|)
condition|?
name|SvRV
argument_list|(
name|ret
argument_list|)
else|:
name|ret
decl_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mg
condition|)
block|{
name|re
operator|=
operator|(
name|regexp
operator|*
operator|)
name|mg
operator|->
name|mg_obj
expr_stmt|;
operator|(
name|void
operator|)
name|ReREFCNT_inc
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|SvPV
argument_list|(
name|ret
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|PMOP
name|pm
decl_stmt|;
name|char
modifier|*
name|oprecomp
init|=
name|PL_regprecomp
decl_stmt|;
name|I32
name|osize
init|=
name|PL_regsize
decl_stmt|;
name|I32
name|onpar
init|=
name|PL_regnpar
decl_stmt|;
name|pm
operator|.
name|op_pmflags
operator|=
literal|0
expr_stmt|;
name|pm
operator|.
name|op_pmdynflags
operator|=
operator|(
name|UTF
operator|||
name|DO_UTF8
argument_list|(
name|ret
argument_list|)
condition|?
name|PMdf_UTF8
else|:
literal|0
operator|)
expr_stmt|;
name|re
operator|=
name|CALLREGCOMP
argument_list|(
argument|aTHX_ t
argument_list|,
argument|t + len
argument_list|,
argument|&pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|ret
argument_list|)
operator|&
operator|(
name|SVs_TEMP
operator||
name|SVs_PADTMP
operator||
name|SVf_READONLY
operator|)
operator|)
condition|)
name|sv_magic
argument_list|(
name|ret
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|ReREFCNT_inc
argument_list|(
name|re
argument_list|)
argument_list|,
literal|'r'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_regprecomp
operator|=
name|oprecomp
expr_stmt|;
name|PL_regsize
operator|=
name|osize
expr_stmt|;
name|PL_regnpar
operator|=
name|onpar
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Entering embedded `%s%.60s%s%s'\n"
argument_list|,
name|PL_colors
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|precomp
argument_list|,
name|PL_colors
index|[
literal|1
index|]
argument_list|,
operator|(
name|strlen
argument_list|(
name|re
operator|->
name|precomp
argument_list|)
operator|>
literal|60
condition|?
literal|"..."
else|:
literal|""
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|node
operator|=
name|next
expr_stmt|;
name|state
operator|.
name|prev
operator|=
name|PL_reg_call_cc
expr_stmt|;
name|state
operator|.
name|cc
operator|=
name|PL_regcc
expr_stmt|;
name|state
operator|.
name|re
operator|=
name|PL_reg_re
expr_stmt|;
name|PL_regcc
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Save *all* the positions. */
name|REGCP_SET
expr_stmt|;
name|cache_re
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|state
operator|.
name|ss
operator|=
name|PL_savestack_ix
expr_stmt|;
operator|*
name|PL_reglastparen
operator|=
literal|0
expr_stmt|;
name|PL_reg_call_cc
operator|=
operator|&
name|state
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* XXXX This is too dramatic a measure... */
name|PL_reg_maxiter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|re
operator|->
name|program
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* Even though we succeeded, we need to restore 			   global variables, since we may be wrapped inside 			   SUSPEND, thus the match may be not finished yet. */
comment|/* XXXX Do this only if SUSPENDed? */
name|PL_reg_call_cc
operator|=
name|state
operator|.
name|prev
expr_stmt|;
name|PL_regcc
operator|=
name|state
operator|.
name|cc
expr_stmt|;
name|PL_reg_re
operator|=
name|state
operator|.
name|re
expr_stmt|;
name|cache_re
argument_list|(
name|PL_reg_re
argument_list|)
expr_stmt|;
comment|/* XXXX This is too dramatic a measure... */
name|PL_reg_maxiter
operator|=
literal|0
expr_stmt|;
comment|/* These are needed even if not SUSPEND. */
name|ReREFCNT_dec
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|ReREFCNT_dec
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|PL_reg_call_cc
operator|=
name|state
operator|.
name|prev
expr_stmt|;
name|PL_regcc
operator|=
name|state
operator|.
name|cc
expr_stmt|;
name|PL_reg_re
operator|=
name|state
operator|.
name|re
expr_stmt|;
name|cache_re
argument_list|(
name|PL_reg_re
argument_list|)
expr_stmt|;
comment|/* XXXX This is too dramatic a measure... */
name|PL_reg_maxiter
operator|=
literal|0
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
name|sw
operator|=
name|SvTRUE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|logical
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sv_setsv
argument_list|(
name|save_scalar
argument_list|(
name|PL_replgv
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPEN
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|PL_reg_start_tmp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|PL_regstartp
index|[
name|n
index|]
operator|=
name|PL_reg_start_tmp
index|[
name|n
index|]
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|n
index|]
operator|=
name|locinput
operator|-
name|PL_bostr
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|GROUPP
case|:
name|n
operator|=
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|sw
operator|=
operator|(
operator|*
name|PL_reglastparen
operator|>=
name|n
operator|&&
name|PL_regendp
index|[
name|n
index|]
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|IFTHEN
case|:
name|PL_reg_leftiter
operator|=
name|PL_reg_maxiter
expr_stmt|;
comment|/* Void cache */
if|if
condition|(
name|sw
condition|)
name|next
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|IFTHEN
condition|)
comment|/* Fake one. */
name|next
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOGICAL
case|:
name|logical
operator|=
name|scan
operator|->
name|flags
expr_stmt|;
break|break;
comment|/*******************************************************************  PL_regcc contains infoblock about the innermost (...)* loop, and  a pointer to the next outer infoblock.   Here is how Y(A)*Z is processed (if it is compiled into CURLYX/WHILEM):     1) After matching X, regnode for CURLYX is processed;     2) This regnode creates infoblock on the stack, and calls        regmatch() recursively with the starting point at WHILEM node;     3) Each hit of WHILEM node tries to match A and Z (in the order       depending on the current iteration, min/max of {min,max} and       greediness).  The information about where are nodes for "A"       and "Z" is read from the infoblock, as is info on how many times "A"       was already matched, and greediness.     4) After A matches, the same WHILEM node is hit again.     5) Each time WHILEM is hit, PL_regcc is the infoblock created by CURLYX       of the same pair.  Thus when WHILEM tries to match Z, it temporarily       resets PL_regcc, since this Y(A)*Z can be a part of some other loop:       as in (Y(A)*Z)*.  If Z matches, the automaton will hit the WHILEM node       of the external loop.   Currently present infoblocks form a tree with a stem formed by PL_curcc  and whatever it mentions via ->next, and additional attached trees  corresponding to temporarily unset infoblocks as in "5" above.   In the following picture infoblocks for outer loop of   (Y(A)*?Z)*?T are denoted O, for inner I.  NULL starting block  is denoted by x.  The matched string is YAAZYAZT.  Temporarily postponed  infoblocks are drawn below the "reset" infoblock.   In fact in the picture below we do not show failed matches for Z and T  by WHILEM blocks.  [We illustrate minimal matches, since for them it is  more obvious *why* one needs to *temporary* unset infoblocks.]    Matched	REx position	InfoBlocks	Comment   		(Y(A)*?Z)*?T	x   		Y(A)*?Z)*?T	x<- O   Y		(A)*?Z)*?T	x<- O   Y		A)*?Z)*?T	x<- O<- I   YA		)*?Z)*?T	x<- O<- I   YA		A)*?Z)*?T	x<- O<- I   YAA		)*?Z)*?T	x<- O<- I   YAA		Z)*?T		x<- O		# Temporary unset I 				     I    YAAZ		Y(A)*?Z)*?T	x<- O 				     I    YAAZY		(A)*?Z)*?T	x<- O 				     I    YAAZY		A)*?Z)*?T	x<- O<- I 				     I    YAAZYA	)*?Z)*?T	x<- O<- I	 				     I    YAAZYA	Z)*?T		x<- O		# Temporary unset I 				     I,I    YAAZYAZ	)*?T		x<- O 				     I,I    YAAZYAZ	T		x		# Temporary unset O 				O 				I,I    YAAZYAZT			x 				O 				I,I  *******************************************************************/
case|case
name|CURLYX
case|:
block|{
name|CURCUR
name|cc
decl_stmt|;
name|CHECKPOINT
name|cp
init|=
name|PL_savestack_ix
decl_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|PREVOPER
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|NOTHING
condition|)
comment|/* LONGJMP */
name|next
operator|+=
name|ARG
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|cc
operator|.
name|oldcc
operator|=
name|PL_regcc
expr_stmt|;
name|PL_regcc
operator|=
operator|&
name|cc
expr_stmt|;
name|cc
operator|.
name|parenfloor
operator|=
operator|*
name|PL_reglastparen
expr_stmt|;
name|cc
operator|.
name|cur
operator|=
operator|-
literal|1
expr_stmt|;
name|cc
operator|.
name|min
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|cc
operator|.
name|max
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|cc
operator|.
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|EXTRA_STEP_2ARGS
expr_stmt|;
name|cc
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|cc
operator|.
name|minmod
operator|=
name|minmod
expr_stmt|;
name|cc
operator|.
name|lastloc
operator|=
literal|0
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|n
operator|=
name|regmatch
argument_list|(
name|PREVOPER
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start on the WHILEM */
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PL_regcc
operator|=
name|cc
operator|.
name|oldcc
expr_stmt|;
name|saySAME
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* NOT REACHED */
case|case
name|WHILEM
case|:
block|{
comment|/* 		 * This is really hard to understand, because after we match 		 * what we're trying to match, we must make sure the rest of 		 * the REx is going to match for sure, and to do that we have 		 * to go back UP the parse tree by recursing ever deeper.  And 		 * if it fails, we have to reset our parent's current state 		 * that we can try again after backing off. 		 */
name|CHECKPOINT
name|cp
decl_stmt|,
name|lastcp
decl_stmt|;
name|CURCUR
modifier|*
name|cc
init|=
name|PL_regcc
decl_stmt|;
name|char
modifier|*
name|lastloc
init|=
name|cc
operator|->
name|lastloc
decl_stmt|;
comment|/* Detection of 0-len. */
name|n
operator|=
name|cc
operator|->
name|cur
operator|+
literal|1
expr_stmt|;
comment|/* how many we know we matched */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  %ld out of %ld..%ld  cc=%lx\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|long
operator|)
name|cc
operator|->
name|min
argument_list|,
operator|(
name|long
operator|)
name|cc
operator|->
name|max
argument_list|,
operator|(
name|long
operator|)
name|cc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If degenerate scan matches "", assume scan done. */
if|if
condition|(
name|locinput
operator|==
name|cc
operator|->
name|lastloc
operator|&&
name|n
operator|>=
name|cc
operator|->
name|min
condition|)
block|{
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  empty match detected, try continuation...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* First just match a string of min scans. */
if|if
condition|(
name|n
operator|<
name|cc
operator|->
name|min
condition|)
block|{
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|->
name|flags
condition|)
block|{
comment|/* Check whether we already were at this position. 			Postpone detection until we know the match is not 			*that* much linear. */
if|if
condition|(
operator|!
name|PL_reg_maxiter
condition|)
block|{
name|PL_reg_maxiter
operator|=
operator|(
name|PL_regeol
operator|-
name|PL_bostr
operator|+
literal|1
operator|)
operator|*
operator|(
name|scan
operator|->
name|flags
operator|>>
literal|4
operator|)
expr_stmt|;
name|PL_reg_leftiter
operator|=
name|PL_reg_maxiter
expr_stmt|;
block|}
if|if
condition|(
name|PL_reg_leftiter
operator|--
operator|==
literal|0
condition|)
block|{
name|I32
name|size
init|=
operator|(
name|PL_reg_maxiter
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|PL_reg_poscache
condition|)
block|{
if|if
condition|(
name|PL_reg_poscache_size
operator|<
name|size
condition|)
block|{
name|Renew
argument_list|(
name|PL_reg_poscache
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|PL_reg_poscache_size
operator|=
name|size
expr_stmt|;
block|}
name|Zero
argument_list|(
name|PL_reg_poscache
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_reg_poscache_size
operator|=
name|size
expr_stmt|;
name|Newz
argument_list|(
literal|29
argument_list|,
name|PL_reg_poscache
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sDetected a super-linear match, switching on caching%s...\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_reg_leftiter
operator|<
literal|0
condition|)
block|{
name|I32
name|o
init|=
name|locinput
operator|-
name|PL_bostr
decl_stmt|,
name|b
decl_stmt|;
name|o
operator|=
operator|(
name|scan
operator|->
name|flags
operator|&
literal|0xf
operator|)
operator|-
literal|1
operator|+
name|o
operator|*
operator|(
name|scan
operator|->
name|flags
operator|>>
literal|4
operator|)
expr_stmt|;
name|b
operator|=
name|o
operator|%
literal|8
expr_stmt|;
name|o
operator|/=
literal|8
expr_stmt|;
if|if
condition|(
name|PL_reg_poscache
index|[
name|o
index|]
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  already tried at this position...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|sayNO_SILENT
expr_stmt|;
block|}
name|PL_reg_poscache
index|[
name|o
index|]
operator||=
operator|(
literal|1
operator|<<
name|b
operator|)
expr_stmt|;
block|}
block|}
comment|/* Prefer next over scan for minimal matching. */
if|if
condition|(
name|cc
operator|->
name|minmod
condition|)
block|{
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
comment|/* All done. */
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|cc
operator|->
name|max
condition|)
block|{
comment|/* Maximum greed exceeded? */
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
name|n
operator|>=
name|REG_INFTY
operator|&&
operator|!
operator|(
name|PL_reg_flags
operator|&
name|RF_warned
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_warned
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"%s limit (%d) exceeded"
argument_list|,
literal|"Complex regular subexpression recursion"
argument_list|,
argument|REG_INFTY -
literal|1
argument_list|)
empty_stmt|;
block|}
name|sayNO
expr_stmt|;
block|}
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  trying longer...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try scanning more and see if it helps. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* Prefer scan over next for maximal matching. */
if|if
condition|(
name|n
operator|<
name|cc
operator|->
name|max
condition|)
block|{
comment|/* More greed allowed? */
name|cp
operator|=
name|regcppush
argument_list|(
name|cc
operator|->
name|parenfloor
argument_list|)
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|locinput
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|scan
argument_list|)
condition|)
block|{
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
comment|/* Restore some previous $<digit>s? */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  failed, try continuation...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_REGEXP
argument_list|)
operator|&&
name|n
operator|>=
name|REG_INFTY
operator|&&
operator|!
operator|(
name|PL_reg_flags
operator|&
name|RF_warned
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_warned
expr_stmt|;
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_REGEXP
argument_list|,
literal|"%s limit (%d) exceeded"
argument_list|,
literal|"Complex regular subexpression recursion"
argument_list|,
argument|REG_INFTY -
literal|1
argument_list|)
empty_stmt|;
block|}
comment|/* Failed deeper matches of scan, so see if this one works. */
name|PL_regcc
operator|=
name|cc
operator|->
name|oldcc
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|ln
operator|=
name|PL_regcc
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cc
operator|->
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
if|if
condition|(
name|PL_regcc
condition|)
name|PL_regcc
operator|->
name|cur
operator|=
name|ln
expr_stmt|;
name|PL_regcc
operator|=
name|cc
expr_stmt|;
name|cc
operator|->
name|cur
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|cc
operator|->
name|lastloc
operator|=
name|lastloc
expr_stmt|;
name|sayNO
expr_stmt|;
block|}
comment|/* NOT REACHED */
case|case
name|BRANCHJ
case|:
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|BRANCH
case|:
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|do_branch
label|:
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|c1
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|c1
condition|)
comment|/* No choice. */
name|next
operator|=
name|inner
expr_stmt|;
comment|/* Avoid recursion. */
else|else
block|{
name|int
name|lastparen
init|=
operator|*
name|PL_reglastparen
decl_stmt|;
name|REGCP_SET
expr_stmt|;
do|do
block|{
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|inner
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
for|for
control|(
name|n
operator|=
operator|*
name|PL_reglastparen
init|;
name|n
operator|>
name|lastparen
condition|;
name|n
operator|--
control|)
name|PL_regendp
index|[
name|n
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|PL_reglastparen
operator|=
name|n
expr_stmt|;
name|scan
operator|=
name|next
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|c1
operator|==
name|BRANCH
condition|?
name|NEXT_OFF
argument_list|(
name|next
argument_list|)
else|:
name|ARG
argument_list|(
name|next
argument_list|)
operator|)
operator|)
condition|)
name|next
operator|+=
name|n
expr_stmt|;
else|else
name|next
operator|=
name|NULL
expr_stmt|;
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|BRANCHJ
condition|)
block|{
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|c1
condition|)
do|;
name|sayNO
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
break|break;
case|case
name|MINMOD
case|:
name|minmod
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CURLYM
case|:
block|{
name|I32
name|l
init|=
literal|0
decl_stmt|;
name|CHECKPOINT
name|lastcp
decl_stmt|;
comment|/* We suppose that the next guy does not need 	       backtracking: in particular, it is of constant length, 	       and has no parenths to influence future backrefs. */
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|paren
operator|=
name|scan
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|paren
expr_stmt|;
if|if
condition|(
name|paren
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|paren
expr_stmt|;
block|}
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
if|if
condition|(
name|paren
condition|)
name|scan
operator|+=
name|NEXT_OFF
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Skip former OPEN. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|minmod
condition|)
block|{
name|minmod
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
name|ln
argument_list|,
operator|&
name|l
argument_list|)
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|l
operator|==
literal|0
operator|&&
name|n
operator|>=
name|ln
comment|/* In fact, this is tricky.  If paren, then the 		       fact that we did/didnot match may influence 		       future execution. */
operator|&&
operator|!
operator|(
name|paren
operator|&&
name|ln
operator|==
literal|0
operator|)
condition|)
name|ln
operator|=
name|n
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|PL_fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|PL_fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
name|REGCP_SET
expr_stmt|;
comment|/* This may be improved if l == 0.  */
while|while
condition|(
name|n
operator|>=
name|ln
operator|||
operator|(
name|n
operator|==
name|REG_INFTY
operator|&&
name|ln
operator|>
literal|0
operator|&&
name|l
operator|)
condition|)
block|{
comment|/* ln overflow ? */
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|HOPc
argument_list|(
name|PL_reginput
argument_list|,
operator|-
name|l
argument_list|)
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|PL_bostr
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- move forward. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|=
name|regrepeat_hard
argument_list|(
name|scan
argument_list|,
name|n
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|l
operator|==
literal|0
comment|/* In fact, this is tricky.  If paren, then the 		       fact that we did/didnot match may influence 		       future execution. */
operator|&&
operator|!
operator|(
name|paren
operator|&&
name|ln
operator|==
literal|0
operator|)
condition|)
name|ln
operator|=
name|n
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  matched %"
name|IVdf
literal|" times, len=%"
name|IVdf
literal|"...\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|)
argument_list|,
literal|""
argument_list|,
operator|(
name|IV
operator|)
name|n
argument_list|,
operator|(
name|IV
operator|)
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|PL_fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|PL_fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
name|REGCP_SET
expr_stmt|;
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  trying tail with n=%"
name|IVdf
literal|"...\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|)
argument_list|,
literal|""
argument_list|,
operator|(
name|IV
operator|)
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|HOPc
argument_list|(
name|PL_reginput
argument_list|,
operator|-
name|l
argument_list|)
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|PL_bostr
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|locinput
operator|=
name|HOPc
argument_list|(
name|locinput
argument_list|,
operator|-
name|l
argument_list|)
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
block|}
block|}
name|sayNO
expr_stmt|;
break|break;
block|}
case|case
name|CURLYN
case|:
name|paren
operator|=
name|scan
operator|->
name|flags
expr_stmt|;
comment|/* Which paren to set */
if|if
condition|(
name|paren
operator|>
name|PL_regsize
condition|)
name|PL_regsize
operator|=
name|paren
expr_stmt|;
if|if
condition|(
name|paren
operator|>
operator|*
name|PL_reglastparen
condition|)
operator|*
name|PL_reglastparen
operator|=
name|paren
expr_stmt|;
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|scan
operator|=
name|regnext
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|CURLY
case|:
name|paren
operator|=
literal|0
expr_stmt|;
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
name|NODE_STEP_REGNODE
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|STAR
case|:
name|ln
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|REG_INFTY
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PLUS
case|:
name|ln
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|REG_INFTY
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
name|repeat
label|:
comment|/* 	    * Lookahead to avoid useless match attempts 	    * when we know what character comes next. 	    */
if|if
condition|(
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EXACT
condition|)
block|{
name|c1
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTF
condition|)
name|c2
operator|=
name|PL_fold
index|[
name|c1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTFL
condition|)
name|c2
operator|=
name|PL_fold_locale
index|[
name|c1
index|]
expr_stmt|;
else|else
name|c2
operator|=
name|c1
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1000
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|minmod
condition|)
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|minmod
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|ln
argument_list|)
operator|<
name|ln
condition|)
name|sayNO
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
operator|-
literal|1000
condition|)
block|{
name|char
modifier|*
name|e
init|=
name|locinput
operator|+
name|n
operator|-
name|ln
decl_stmt|;
comment|/* Should not check after this */
name|char
modifier|*
name|old
init|=
name|locinput
decl_stmt|;
if|if
condition|(
name|e
operator|>=
name|PL_regeol
operator|||
operator|(
name|n
operator|==
name|REG_INFTY
operator|)
condition|)
name|e
operator|=
name|PL_regeol
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find place 'next' could work */
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
block|{
while|while
condition|(
name|locinput
operator|<=
name|e
operator|&&
operator|*
name|locinput
operator|!=
name|c1
condition|)
name|locinput
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|locinput
operator|<=
name|e
operator|&&
operator|*
name|locinput
operator|!=
name|c1
operator|&&
operator|*
name|locinput
operator|!=
name|c2
condition|)
name|locinput
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|locinput
operator|>
name|e
condition|)
name|sayNO
expr_stmt|;
comment|/* PL_reginput == old now */
if|if
condition|(
name|locinput
operator|!=
name|old
condition|)
block|{
name|ln
operator|=
literal|1
expr_stmt|;
comment|/* Did some */
if|if
condition|(
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|locinput
operator|-
name|old
argument_list|)
operator|<
name|locinput
operator|-
name|old
condition|)
name|sayNO
expr_stmt|;
block|}
comment|/* PL_reginput == locinput now */
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|ln
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|HOPc
argument_list|(
name|locinput
argument_list|,
operator|-
literal|1
argument_list|)
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|locinput
operator|-
name|PL_bostr
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* Could be reset... */
name|REGCP_UNWIND
expr_stmt|;
comment|/* Couldn't or didn't -- move forward. */
name|old
operator|=
name|locinput
operator|++
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
name|n
operator|>=
name|ln
operator|||
operator|(
name|n
operator|==
name|REG_INFTY
operator|&&
name|ln
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* ln overflow ? */
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|HOPc
argument_list|(
name|PL_reginput
argument_list|,
operator|-
literal|1
argument_list|)
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|PL_bostr
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- move forward. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regrepeat
argument_list|(
name|scan
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
block|}
else|else
block|{
name|CHECKPOINT
name|lastcp
decl_stmt|;
name|n
operator|=
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|ln
operator|<
name|n
operator|&&
name|PL_regkind
index|[
operator|(
name|U8
operator|)
name|OP
argument_list|(
name|next
argument_list|)
index|]
operator|==
name|EOL
operator|&&
operator|(
operator|!
name|PL_multiline
operator|||
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|SEOL
operator|||
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EOS
operator|)
condition|)
block|{
name|ln
operator|=
name|n
expr_stmt|;
comment|/* why back off? */
comment|/* ...because $ and \Z can match before *and* after 		       newline at the end.  Consider "\n\n" =~ /\n+\Z\n/. 		       We should back off by one in this case. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|PL_reginput
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|&&
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|EOS
condition|)
name|ln
operator|--
expr_stmt|;
block|}
name|REGCP_SET
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|paren
operator|&&
name|n
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|PL_regstartp
index|[
name|paren
index|]
operator|=
name|HOPc
argument_list|(
name|PL_reginput
argument_list|,
operator|-
literal|1
argument_list|)
operator|-
name|PL_bostr
expr_stmt|;
name|PL_regendp
index|[
name|paren
index|]
operator|=
name|PL_reginput
operator|-
name|PL_bostr
expr_stmt|;
block|}
else|else
name|PL_regendp
index|[
name|paren
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
operator|=
name|HOPc
argument_list|(
name|locinput
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|c1
operator|==
operator|-
literal|1000
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c1
operator|||
name|UCHARAT
argument_list|(
name|PL_reginput
argument_list|)
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
name|sayYES
expr_stmt|;
name|REGCP_UNWIND
expr_stmt|;
block|}
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
operator|=
name|HOPc
argument_list|(
name|locinput
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sayNO
expr_stmt|;
break|break;
case|case
name|END
case|:
if|if
condition|(
name|PL_reg_call_cc
condition|)
block|{
name|re_cc_state
modifier|*
name|cur_call_cc
init|=
name|PL_reg_call_cc
decl_stmt|;
name|CURCUR
modifier|*
name|cctmp
init|=
name|PL_regcc
decl_stmt|;
name|regexp
modifier|*
name|re
init|=
name|PL_reg_re
decl_stmt|;
name|CHECKPOINT
name|cp
decl_stmt|,
name|lastcp
decl_stmt|;
name|cp
operator|=
name|regcppush
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Save *all* the positions. */
name|REGCP_SET
expr_stmt|;
name|regcp_set_to
argument_list|(
name|PL_reg_call_cc
operator|->
name|ss
argument_list|)
expr_stmt|;
comment|/* Restore parens of 						    the caller. */
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* Make position available to 					   the callcc. */
name|cache_re
argument_list|(
name|PL_reg_call_cc
operator|->
name|re
argument_list|)
expr_stmt|;
name|PL_regcc
operator|=
name|PL_reg_call_cc
operator|->
name|cc
expr_stmt|;
name|PL_reg_call_cc
operator|=
name|PL_reg_call_cc
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|cur_call_cc
operator|->
name|node
argument_list|)
condition|)
block|{
name|PL_reg_call_cc
operator|=
name|cur_call_cc
expr_stmt|;
name|regcpblow
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sayYES
expr_stmt|;
block|}
name|REGCP_UNWIND
expr_stmt|;
name|regcppop
argument_list|()
expr_stmt|;
name|PL_reg_call_cc
operator|=
name|cur_call_cc
expr_stmt|;
name|PL_regcc
operator|=
name|cctmp
expr_stmt|;
name|PL_reg_re
operator|=
name|re
expr_stmt|;
name|cache_re
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  continuation failed...\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|sayNO_SILENT
expr_stmt|;
block|}
if|if
condition|(
name|locinput
operator|<
name|PL_regtill
condition|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sMatch possible, but length=%ld is smaller than requested=%ld, failing!%s\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|locinput
operator|-
name|PL_reg_starttry
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PL_regtill
operator|-
name|PL_reg_starttry
argument_list|)
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sayNO_FINAL
expr_stmt|;
comment|/* Cannot match: too short. */
block|}
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* put where regtry can find it */
name|sayYES_FINAL
expr_stmt|;
comment|/* Success! */
case|case
name|SUCCEED
case|:
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
comment|/* put where regtry can find it */
name|sayYES_LOUD
expr_stmt|;
comment|/* Success! */
case|case
name|SUSPEND
case|:
name|n
operator|=
literal|1
expr_stmt|;
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
goto|goto
name|do_ifmatch
goto|;
case|case
name|UNLESSM
case|:
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|UTF
condition|)
block|{
comment|/* XXXX This is absolutely 					   broken, we read before 					   start of string. */
name|s
operator|=
name|HOPMAYBEc
argument_list|(
name|locinput
argument_list|,
operator|-
name|scan
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
goto|goto
name|say_yes
goto|;
name|PL_reginput
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locinput
operator|<
name|PL_bostr
operator|+
name|scan
operator|->
name|flags
condition|)
goto|goto
name|say_yes
goto|;
name|PL_reginput
operator|=
name|locinput
operator|-
name|scan
operator|->
name|flags
expr_stmt|;
goto|goto
name|do_ifmatch
goto|;
block|}
block|}
else|else
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
goto|goto
name|do_ifmatch
goto|;
case|case
name|IFMATCH
case|:
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|UTF
condition|)
block|{
comment|/* XXXX This is absolutely 					   broken, we read before 					   start of string. */
name|s
operator|=
name|HOPMAYBEc
argument_list|(
name|locinput
argument_list|,
operator|-
name|scan
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
name|s
operator|<
name|PL_bostr
condition|)
goto|goto
name|say_no
goto|;
name|PL_reginput
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locinput
operator|<
name|PL_bostr
operator|+
name|scan
operator|->
name|flags
condition|)
goto|goto
name|say_no
goto|;
name|PL_reginput
operator|=
name|locinput
operator|-
name|scan
operator|->
name|flags
expr_stmt|;
goto|goto
name|do_ifmatch
goto|;
block|}
block|}
else|else
name|PL_reginput
operator|=
name|locinput
expr_stmt|;
name|do_ifmatch
label|:
name|inner
operator|=
name|NEXTOPER
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|inner
argument_list|)
operator|!=
name|n
condition|)
block|{
name|say_no
label|:
if|if
condition|(
name|logical
condition|)
block|{
name|logical
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_longjump
goto|;
block|}
else|else
name|sayNO
expr_stmt|;
block|}
name|say_yes
label|:
if|if
condition|(
name|logical
condition|)
block|{
name|logical
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|SUSPEND
condition|)
block|{
name|locinput
operator|=
name|PL_reginput
expr_stmt|;
name|nextchr
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH. */
case|case
name|LONGJMP
case|:
name|do_longjump
label|:
name|next
operator|=
name|scan
operator|+
name|ARG
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"%"
name|UVxf
literal|" %d\n"
argument_list|,
name|PTR2UV
argument_list|(
name|scan
argument_list|)
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
name|Perl_croak
argument_list|(
name|aTHX_
literal|"regexp memory corruption"
argument_list|)
expr_stmt|;
block|}
name|scan
operator|=
name|next
expr_stmt|;
block|}
comment|/*     * We get here only if there's trouble -- normally "case END" is     * the terminating point.     */
name|Perl_croak
argument_list|(
name|aTHX_
literal|"corrupted regexp pointers"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|sayNO
expr_stmt|;
name|yes_loud
label|:
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  %scould match...%s\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|yes
goto|;
name|yes_final
label|:
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%sMatch successful!%s\n"
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|yes
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
name|no
label|:
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%*s  %sfailed...%s\n"
argument_list|,
name|REPORT_CODE_OFF
operator|+
name|PL_regindent
operator|*
literal|2
argument_list|,
literal|""
argument_list|,
name|PL_colors
index|[
literal|4
index|]
argument_list|,
name|PL_colors
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|do_no
goto|;
name|no_final
label|:
name|do_no
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|PL_regindent
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  - regrepeat - repeatedly match something simple, report how many  */
end_comment

begin_comment
comment|/*  * [This routine now assumes that it will only match on things of length 1.  * That was true before, but now we assume scan - reginput is the count,  * rather than incrementing count on every character.  [Er, except utf8.]]  */
end_comment

begin_function
name|STATIC
name|I32
name|S_regrepeat
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|p
parameter_list|,
name|I32
name|max
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|I32
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|loceol
init|=
name|PL_regeol
decl_stmt|;
specifier|register
name|I32
name|hardcount
init|=
literal|0
decl_stmt|;
name|scan
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|max
operator|!=
name|REG_INFTY
operator|&&
name|max
operator|<
name|loceol
operator|-
name|scan
condition|)
name|loceol
operator|=
name|scan
operator|+
name|max
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|REG_ANY
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SANY
case|:
name|scan
operator|=
name|loceol
expr_stmt|;
break|break;
case|case
name|ANYUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SANYUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|EXACT
case|:
comment|/* length of string is 1 */
name|c
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTF
case|:
comment|/* length of string is 1 */
name|c
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
operator|||
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|PL_fold
index|[
name|c
index|]
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTFL
case|:
comment|/* length of string is 1 */
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|c
operator|=
operator|(
name|U8
operator|)
operator|*
name|STRING
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|c
operator|||
name|UCHARAT
argument_list|(
name|scan
argument_list|)
operator|==
name|PL_fold_locale
index|[
name|c
index|]
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ANYOFUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|REGINCLASSUTF8
argument_list|(
name|p
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|REGINCLASS
argument_list|(
name|p
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ALNUMUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NALNUMUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|swash_fetch
argument_list|(
name|PL_utf8_alnum
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUML
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NALNUMLUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SPACEUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
operator|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isSPACE_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
operator|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NSPACEUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
name|swash_fetch
argument_list|(
name|PL_utf8_space
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
operator|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACEL
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isSPACE_LC
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NSPACELUTF8
case|:
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
name|isSPACE_LC_utf8
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
operator|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|DIGITUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NDIGITUTF8
case|:
name|loceol
operator|=
name|PL_regeol
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|swash_fetch
argument_list|(
name|PL_utf8_digit
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|+=
name|UTF8SKIP
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|hardcount
operator|++
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Called on something of 0 width. */
break|break;
comment|/* So match right here or not at all. */
block|}
if|if
condition|(
name|hardcount
condition|)
name|c
operator|=
name|hardcount
expr_stmt|;
else|else
name|c
operator|=
name|scan
operator|-
name|PL_reginput
expr_stmt|;
name|PL_reginput
operator|=
name|scan
expr_stmt|;
name|DEBUG_r
argument_list|(
argument|{ 		SV *prop = sv_newmortal();  		regprop(prop, p); 		PerlIO_printf(Perl_debug_log,
literal|"%*s  %s can match %"
argument|IVdf
literal|" times out of %"
argument|IVdf
literal|"...\n"
argument|,  			      REPORT_CODE_OFF+
literal|1
argument|,
literal|""
argument|, SvPVX(prop),(IV)c,(IV)max); 	}
argument_list|)
empty_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regrepeat_hard - repeatedly match something, report total lenth and length  *   * The repeater is supposed to have constant length.  */
end_comment

begin_function
name|STATIC
name|I32
name|S_regrepeat_hard
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|p
parameter_list|,
name|I32
name|max
parameter_list|,
name|I32
modifier|*
name|lp
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|char
modifier|*
name|loceol
init|=
name|PL_regeol
decl_stmt|;
name|I32
name|l
init|=
literal|0
decl_stmt|;
name|I32
name|count
init|=
literal|0
decl_stmt|,
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|max
condition|)
return|return
literal|0
return|;
name|start
operator|=
name|PL_reginput
expr_stmt|;
if|if
condition|(
name|UTF
condition|)
block|{
while|while
condition|(
name|PL_reginput
operator|<
name|loceol
operator|&&
operator|(
name|scan
operator|=
name|PL_reginput
operator|,
name|res
operator|=
name|regmatch
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|count
operator|++
condition|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|PL_reginput
condition|)
block|{
name|l
operator|++
expr_stmt|;
name|start
operator|+=
name|UTF8SKIP
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|max
return|;
block|}
if|if
condition|(
name|count
operator|==
name|max
condition|)
return|return
name|count
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|PL_reginput
operator|<
name|loceol
operator|&&
operator|(
name|scan
operator|=
name|PL_reginput
operator|,
name|res
operator|=
name|regmatch
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|count
operator|++
condition|)
block|{
operator|*
name|lp
operator|=
name|l
operator|=
name|PL_reginput
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|max
operator|!=
name|REG_INFTY
operator|&&
name|l
operator|*
name|max
operator|<
name|loceol
operator|-
name|scan
condition|)
name|loceol
operator|=
name|scan
operator|+
name|l
operator|*
name|max
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|max
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|res
condition|)
name|PL_reginput
operator|=
name|scan
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  - reginclass - determine if a character falls into a character class  */
end_comment

begin_function
name|STATIC
name|bool
name|S_reginclass
parameter_list|(
name|pTHX_
specifier|register
name|regnode
modifier|*
name|p
parameter_list|,
specifier|register
name|I32
name|c
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
name|flags
init|=
name|ANYOF_FLAGS
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|c
operator|&=
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ANYOF_BITMAP_TEST
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ANYOF_FOLD
condition|)
block|{
name|I32
name|cf
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|cf
operator|=
name|PL_fold_locale
index|[
name|c
index|]
expr_stmt|;
block|}
else|else
name|cf
operator|=
name|PL_fold
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|ANYOF_BITMAP_TEST
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
operator|&&
operator|(
name|flags
operator|&
name|ANYOF_CLASS
operator|)
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
if|if
condition|(
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_ALNUM
argument_list|)
operator|&&
name|isALNUM_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NALNUM
argument_list|)
operator|&&
operator|!
name|isALNUM_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_SPACE
argument_list|)
operator|&&
name|isSPACE_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NSPACE
argument_list|)
operator|&&
operator|!
name|isSPACE_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_DIGIT
argument_list|)
operator|&&
name|isDIGIT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NDIGIT
argument_list|)
operator|&&
operator|!
name|isDIGIT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_ALNUMC
argument_list|)
operator|&&
name|isALNUMC_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NALNUMC
argument_list|)
operator|&&
operator|!
name|isALNUMC_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_ALPHA
argument_list|)
operator|&&
name|isALPHA_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NALPHA
argument_list|)
operator|&&
operator|!
name|isALPHA_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_ASCII
argument_list|)
operator|&&
name|isASCII
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NASCII
argument_list|)
operator|&&
operator|!
name|isASCII
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_CNTRL
argument_list|)
operator|&&
name|isCNTRL_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NCNTRL
argument_list|)
operator|&&
operator|!
name|isCNTRL_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_GRAPH
argument_list|)
operator|&&
name|isGRAPH_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NGRAPH
argument_list|)
operator|&&
operator|!
name|isGRAPH_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_LOWER
argument_list|)
operator|&&
name|isLOWER_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NLOWER
argument_list|)
operator|&&
operator|!
name|isLOWER_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_PRINT
argument_list|)
operator|&&
name|isPRINT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NPRINT
argument_list|)
operator|&&
operator|!
name|isPRINT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_PUNCT
argument_list|)
operator|&&
name|isPUNCT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NPUNCT
argument_list|)
operator|&&
operator|!
name|isPUNCT_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_UPPER
argument_list|)
operator|&&
name|isUPPER_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NUPPER
argument_list|)
operator|&&
operator|!
name|isUPPER_LC
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_XDIGIT
argument_list|)
operator|&&
name|isXDIGIT
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|ANYOF_CLASS_TEST
argument_list|(
name|p
argument_list|,
name|ANYOF_NXDIGIT
argument_list|)
operator|&&
operator|!
name|isXDIGIT
argument_list|(
name|c
argument_list|)
operator|)
condition|)
comment|/* How's that for a conditional? */
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|flags
operator|&
name|ANYOF_INVERT
operator|)
condition|?
operator|!
name|match
else|:
name|match
return|;
block|}
end_function

begin_function
name|STATIC
name|bool
name|S_reginclassutf8
parameter_list|(
name|pTHX_
name|regnode
modifier|*
name|f
parameter_list|,
name|U8
modifier|*
name|p
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
name|flags
init|=
name|ARG1
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SV
modifier|*
name|sv
init|=
operator|(
name|SV
operator|*
operator|)
name|PL_regdata
operator|->
name|data
index|[
name|ARG2
argument_list|(
name|f
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|swash_fetch
argument_list|(
name|sv
argument_list|,
name|p
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ANYOF_FOLD
condition|)
block|{
name|U8
name|tmpbuf
index|[
name|UTF8_MAXLEN
index|]
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ANYOF_LOCALE
condition|)
block|{
name|PL_reg_flags
operator||=
name|RF_tainted
expr_stmt|;
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|toLOWER_LC_utf8
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|uv_to_utf8
argument_list|(
name|tmpbuf
argument_list|,
name|toLOWER_utf8
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swash_fetch
argument_list|(
name|sv
argument_list|,
name|tmpbuf
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* UTF8 combined with ANYOF_CLASS is ill-defined. */
return|return
operator|(
name|flags
operator|&
name|ANYOF_INVERT
operator|)
condition|?
operator|!
name|match
else|:
name|match
return|;
block|}
end_function

begin_function
name|STATIC
name|U8
modifier|*
name|S_reghop
parameter_list|(
name|pTHX_
name|U8
modifier|*
name|s
parameter_list|,
name|I32
name|off
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|off
operator|--
operator|&&
name|s
operator|<
operator|(
name|U8
operator|*
operator|)
name|PL_regeol
condition|)
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|off
operator|++
condition|)
block|{
if|if
condition|(
name|s
operator|>
operator|(
name|U8
operator|*
operator|)
name|PL_bostr
condition|)
block|{
name|s
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&
literal|0x80
condition|)
block|{
while|while
condition|(
name|s
operator|>
operator|(
name|U8
operator|*
operator|)
name|PL_bostr
operator|&&
operator|(
operator|*
name|s
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
name|s
operator|--
expr_stmt|;
block|}
comment|/* XXX could check well-formedness here */
block|}
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|STATIC
name|U8
modifier|*
name|S_reghopmaybe
parameter_list|(
name|pTHX_
name|U8
modifier|*
name|s
parameter_list|,
name|I32
name|off
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|off
operator|--
operator|&&
name|s
operator|<
operator|(
name|U8
operator|*
operator|)
name|PL_regeol
condition|)
name|s
operator|+=
name|UTF8SKIP
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
while|while
condition|(
name|off
operator|++
condition|)
block|{
if|if
condition|(
name|s
operator|>
operator|(
name|U8
operator|*
operator|)
name|PL_bostr
condition|)
block|{
name|s
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&
literal|0x80
condition|)
block|{
while|while
condition|(
name|s
operator|>
operator|(
name|U8
operator|*
operator|)
name|PL_bostr
operator|&&
operator|(
operator|*
name|s
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
name|s
operator|--
expr_stmt|;
block|}
comment|/* XXX could check well-formedness here */
block|}
else|else
break|break;
block|}
if|if
condition|(
name|off
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_include
include|#
directive|include
file|"XSUB.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|restore_pos
parameter_list|(
name|pTHXo_
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_reg_eval_set
condition|)
block|{
if|if
condition|(
name|PL_reg_oldsaved
condition|)
block|{
name|PL_reg_re
operator|->
name|subbeg
operator|=
name|PL_reg_oldsaved
expr_stmt|;
name|PL_reg_re
operator|->
name|sublen
operator|=
name|PL_reg_oldsavedlen
expr_stmt|;
name|RX_MATCH_COPIED_on
argument_list|(
name|PL_reg_re
argument_list|)
expr_stmt|;
block|}
name|PL_reg_magic
operator|->
name|mg_len
operator|=
name|PL_reg_oldpos
expr_stmt|;
name|PL_reg_eval_set
operator|=
literal|0
expr_stmt|;
name|PL_curpm
operator|=
name|PL_reg_oldcurpm
expr_stmt|;
block|}
block|}
end_function

end_unit

