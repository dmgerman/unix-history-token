begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_define
define|#
directive|define
name|INCL_DOSEXCEPTIONS
end_define

begin_comment
comment|/* for OS2 */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_threadproc.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_signal.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_if
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
name|APR_HAVE_PTHREAD_H
end_if

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWAIT_TAKES_ONE_ARG
end_ifdef

begin_define
define|#
directive|define
name|apr_sigwait
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((*(b)=sigwait((a)))<0?-1:0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|apr_sigwait
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|sigwait((a),(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_proc_kill
argument_list|(
argument|apr_proc_t *proc
argument_list|,
argument|int signum
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|OS2
comment|/* SIGTERM's don't work too well in OS/2 (only affects other EMX      * programs). CGIs may not be, esp. REXX scripts, so use a native      * call instead      */
if|if
condition|(
name|signum
operator|==
name|SIGTERM
condition|)
block|{
return|return
name|APR_OS2_STATUS
argument_list|(
name|DosSendSignalException
argument_list|(
name|proc
operator|->
name|pid
argument_list|,
name|XCPT_SIGNAL_BREAK
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* OS2 */
if|if
condition|(
name|kill
argument_list|(
name|proc
operator|->
name|pid
argument_list|,
name|signum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_if
if|#
directive|if
name|APR_HAVE_SIGACTION
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
end_if

begin_function
specifier|static
name|void
name|avoid_zombies
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|int
name|exit_status
decl_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|exit_status
argument_list|,
name|WNOHANG
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* do nothing */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DARWIN */
end_comment

begin_comment
comment|/*  * Replace standard signal() with the more reliable sigaction equivalent  * from W. Richard Stevens' "Advanced Programming in the UNIX Environment"  * (the version that does not automatically restart system calls).  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_sigfunc_t *
argument_list|)
end_macro

begin_macro
name|apr_signal
argument_list|(
argument|int signo
argument_list|,
argument|apr_sigfunc_t * func
argument_list|)
end_macro

begin_block
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|func
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_INTERRUPT
comment|/* SunOS */
name|act
operator|.
name|sa_flags
operator||=
name|SA_INTERRUPT
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha
argument_list|)
comment|/* XXX jeff thinks this should be enabled whenever SA_NOCLDWAIT is defined */
comment|/* this is required on Tru64 to cause child processes to      * disappear gracefully - XPG4 compatible       */
if|if
condition|(
operator|(
name|signo
operator|==
name|SIGCHLD
operator|)
operator|&&
operator|(
name|func
operator|==
name|SIG_IGN
operator|)
condition|)
block|{
name|act
operator|.
name|sa_flags
operator||=
name|SA_NOCLDWAIT
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN
argument_list|)
comment|/* ignoring SIGCHLD or leaving the default disposition doesn't avoid zombies,      * and there is no SA_NOCLDWAIT flag, so catch the signal and reap status in       * the handler to avoid zombies      */
if|if
condition|(
operator|(
name|signo
operator|==
name|SIGCHLD
operator|)
operator|&&
operator|(
name|func
operator|==
name|SIG_IGN
operator|)
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|avoid_zombies
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|<
literal|0
condition|)
return|return
name|SIG_ERR
return|;
return|return
name|oact
operator|.
name|sa_handler
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SIGACTION */
end_comment

begin_comment
comment|/* AC_DECL_SYS_SIGLIST defines either of these symbols depending  * on the version of autoconf used. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_SIGLIST_DECLARED
argument_list|)
operator|||
name|HAVE_DECL_SYS_SIGLIST
end_if

begin_function
name|void
name|apr_signal_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pglobal
parameter_list|)
block|{ }
end_function

begin_function
specifier|const
name|char
modifier|*
name|apr_signal_description_get
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
return|return
operator|(
name|signum
operator|>=
literal|0
operator|)
condition|?
name|sys_siglist
index|[
name|signum
index|]
else|:
literal|"unknown signal (number)"
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(SYS_SIGLIST_DECLARED || HAVE_DECL_SYS_SIGLIST) */
end_comment

begin_comment
comment|/* we need to roll our own signal description stuff */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NSIG
argument_list|)
end_if

begin_define
define|#
directive|define
name|APR_NUMSIG
value|NSIG
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_NSIG
argument_list|)
end_elif

begin_define
define|#
directive|define
name|APR_NUMSIG
value|_NSIG
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NSIG
argument_list|)
end_elif

begin_define
define|#
directive|define
name|APR_NUMSIG
value|__NSIG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APR_NUMSIG
value|33
end_define

begin_comment
comment|/* breaks on OS/390 with< 33; 32 is o.k. for most */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|signal_description
index|[
name|APR_NUMSIG
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|store_desc
parameter_list|(
name|index
parameter_list|,
name|string
parameter_list|)
define|\
value|do { \             if (index>= APR_NUMSIG) { \                 assert(index< APR_NUMSIG); \             } \             else { \                 signal_description[index] = string; \             } \         } while (0)
end_define

begin_function
name|void
name|apr_signal_init
parameter_list|(
name|apr_pool_t
modifier|*
name|pglobal
parameter_list|)
block|{
name|int
name|sig
decl_stmt|;
name|store_desc
argument_list|(
literal|0
argument_list|,
literal|"Signal 0"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
name|store_desc
argument_list|(
name|SIGHUP
argument_list|,
literal|"Hangup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|store_desc
argument_list|(
name|SIGINT
argument_list|,
literal|"Interrupt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|store_desc
argument_list|(
name|SIGQUIT
argument_list|,
literal|"Quit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|store_desc
argument_list|(
name|SIGILL
argument_list|,
literal|"Illegal instruction"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTRAP
name|store_desc
argument_list|(
name|SIGTRAP
argument_list|,
literal|"Trace/BPT trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGIOT
name|store_desc
argument_list|(
name|SIGIOT
argument_list|,
literal|"IOT instruction"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|store_desc
argument_list|(
name|SIGABRT
argument_list|,
literal|"Abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGEMT
name|store_desc
argument_list|(
name|SIGEMT
argument_list|,
literal|"Emulator trap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|store_desc
argument_list|(
name|SIGFPE
argument_list|,
literal|"Arithmetic exception"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGKILL
name|store_desc
argument_list|(
name|SIGKILL
argument_list|,
literal|"Killed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|store_desc
argument_list|(
name|SIGBUS
argument_list|,
literal|"Bus error"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|store_desc
argument_list|(
name|SIGSEGV
argument_list|,
literal|"Segmentation fault"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSYS
name|store_desc
argument_list|(
name|SIGSYS
argument_list|,
literal|"Bad system call"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|store_desc
argument_list|(
name|SIGPIPE
argument_list|,
literal|"Broken pipe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGALRM
name|store_desc
argument_list|(
name|SIGALRM
argument_list|,
literal|"Alarm clock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|store_desc
argument_list|(
name|SIGTERM
argument_list|,
literal|"Terminated"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|store_desc
argument_list|(
name|SIGUSR1
argument_list|,
literal|"User defined signal 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR2
name|store_desc
argument_list|(
name|SIGUSR2
argument_list|,
literal|"User defined signal 2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCLD
name|store_desc
argument_list|(
name|SIGCLD
argument_list|,
literal|"Child status change"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
name|store_desc
argument_list|(
name|SIGCHLD
argument_list|,
literal|"Child status change"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPWR
name|store_desc
argument_list|(
name|SIGPWR
argument_list|,
literal|"Power-fail restart"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGWINCH
name|store_desc
argument_list|(
name|SIGWINCH
argument_list|,
literal|"Window changed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGURG
name|store_desc
argument_list|(
name|SIGURG
argument_list|,
literal|"urgent socket condition"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPOLL
name|store_desc
argument_list|(
name|SIGPOLL
argument_list|,
literal|"Pollable event occurred"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGIO
name|store_desc
argument_list|(
name|SIGIO
argument_list|,
literal|"socket I/O possible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSTOP
name|store_desc
argument_list|(
name|SIGSTOP
argument_list|,
literal|"Stopped (signal)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
name|store_desc
argument_list|(
name|SIGTSTP
argument_list|,
literal|"Stopped"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCONT
name|store_desc
argument_list|(
name|SIGCONT
argument_list|,
literal|"Continued"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTIN
name|store_desc
argument_list|(
name|SIGTTIN
argument_list|,
literal|"Stopped (tty input)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
name|store_desc
argument_list|(
name|SIGTTOU
argument_list|,
literal|"Stopped (tty output)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGVTALRM
name|store_desc
argument_list|(
name|SIGVTALRM
argument_list|,
literal|"virtual timer expired"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPROF
name|store_desc
argument_list|(
name|SIGPROF
argument_list|,
literal|"profiling timer expired"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|store_desc
argument_list|(
name|SIGXCPU
argument_list|,
literal|"exceeded cpu limit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|store_desc
argument_list|(
name|SIGXFSZ
argument_list|,
literal|"exceeded file size limit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|sig
operator|=
literal|0
init|;
name|sig
operator|<
name|APR_NUMSIG
condition|;
operator|++
name|sig
control|)
if|if
condition|(
name|signal_description
index|[
name|sig
index|]
operator|==
name|NULL
condition|)
name|signal_description
index|[
name|sig
index|]
operator|=
name|apr_psprintf
argument_list|(
name|pglobal
argument_list|,
literal|"signal #%d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|apr_signal_description_get
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
return|return
operator|(
name|signum
operator|>=
literal|0
operator|&&
name|signum
operator|<
name|APR_NUMSIG
operator|)
condition|?
name|signal_description
index|[
name|signum
index|]
else|:
literal|"unknown signal (number)"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_SIGLIST_DECLARED || HAVE_DECL_SYS_SIGLIST */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|(
name|HAVE_SIGSUSPEND
operator|||
name|APR_HAVE_SIGWAIT
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
end_if

begin_function
specifier|static
name|void
name|remove_sync_sigs
parameter_list|(
name|sigset_t
modifier|*
name|sig_mask
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGABRT
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGABRT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGEMT
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGEMT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGFPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGIOT
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGIOT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSYS
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGSYS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTRAP
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* the rest of the signals removed from the mask in this function  * absolutely must be removed; you cannot block synchronous signals  * (requirement of pthreads API)  *  * SIGUSR2 is being removed from the mask for the convenience of  * Purify users (Solaris, HP-UX, SGI) since Purify uses SIGUSR2  */
ifdef|#
directive|ifdef
name|SIGUSR2
name|sigdelset
argument_list|(
name|sig_mask
argument_list|,
name|SIGUSR2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_signal_thread
argument_list|(
argument|int(*signal_handler)(int signum)
argument_list|)
end_macro

begin_block
block|{
name|sigset_t
name|sig_mask
decl_stmt|;
if|#
directive|if
name|APR_HAVE_SIGWAIT
name|int
function_decl|(
modifier|*
name|sig_func
function_decl|)
parameter_list|(
name|int
name|signum
parameter_list|)
init|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
operator|(
name|int
operator|)
operator|)
name|signal_handler
function_decl|;
endif|#
directive|endif
comment|/* This thread will be the one responsible for handling signals */
name|sigfillset
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
comment|/* On certain platforms, sigwait() returns EINVAL if any of various      * unblockable signals are included in the mask.  This was first       * observed on AIX and Tru64.      */
ifdef|#
directive|ifdef
name|SIGKILL
name|sigdelset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSTOP
name|sigdelset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCONT
name|sigdelset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGWAITING
name|sigdelset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|SIGWAITING
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no synchronous signals should be in the mask passed to sigwait() */
name|remove_sync_sigs
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
comment|/* On AIX (4.3.3, at least), sigwait() won't wake up if the high-      * order bit of the second word of flags is turned on.  sigdelset()      * returns an error when trying to turn this off, so we'll turn it      * off manually.      *      * Note that the private fields differ between 32-bit and 64-bit      * and even between _ALL_SOURCE and !_ALL_SOURCE.  Except that on      * AIX 4.3 32-bit builds and 64-bit builds use the same definition.      *      * Applicable AIX fixes such that this is no longer needed:      *      * APAR IY23096 for AIX 51B, fix included in AIX 51C, and      * APAR IY24162 for 43X.      */
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__64BIT__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_AIXVERSION_510
argument_list|)
ifdef|#
directive|ifdef
name|_ALL_SOURCE
name|sig_mask
operator|.
name|ss_set
index|[
literal|3
index|]
operator|&=
literal|0x7FFFFFFF
expr_stmt|;
else|#
directive|else
comment|/* not _ALL_SOURCE */
name|sig_mask
operator|.
name|__ss_set
index|[
literal|3
index|]
operator|&=
literal|0x7FFFFFFF
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* not 64-bit build, or 64-bit build on 4.3 */
ifdef|#
directive|ifdef
name|_ALL_SOURCE
name|sig_mask
operator|.
name|hisigs
operator|&=
literal|0x7FFFFFFF
expr_stmt|;
else|#
directive|else
comment|/* not _ALL_SOURCE */
name|sig_mask
operator|.
name|__hisigs
operator|&=
literal|0x7FFFFFFF
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* _AIX */
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
name|APR_HAVE_SIGWAIT
name|int
name|signal_received
decl_stmt|;
if|if
condition|(
name|apr_sigwait
argument_list|(
operator|&
name|sig_mask
argument_list|,
operator|&
name|signal_received
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* handle sigwait() error here */
block|}
if|if
condition|(
name|sig_func
argument_list|(
name|signal_received
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
elif|#
directive|elif
name|HAVE_SIGSUSPEND
name|sigsuspend
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|No apr_sigwait() and no sigsuspend()
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_setup_signal_thread
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|sigset_t
name|sig_mask
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* All threads should mask out signals to be handled by      * the thread doing sigwait().      *      * No thread should ever block synchronous signals.      * See the Solaris man page for pthread_sigmask() for      * some information.  Solaris chooses to knock out such      * processes when a blocked synchronous signal is       * delivered, skipping any registered signal handler.      * AIX doesn't call a signal handler either.  At least      * one level of linux+glibc does call the handler even      * when the synchronous signal is blocked.      */
name|sigfillset
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
name|remove_sync_sigs
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGPROCMASK_SETS_THREAD_MASK
argument_list|)
operator|||
operator|!
name|APR_HAS_THREADS
if|if
condition|(
operator|(
name|rv
operator|=
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|rv
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS&& ... */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_signal_block
argument_list|(
argument|int signum
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_HAVE_SIGACTION
name|sigset_t
name|sig_mask
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|signum
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGPROCMASK_SETS_THREAD_MASK
argument_list|)
operator|||
operator|!
name|APR_HAS_THREADS
if|if
condition|(
operator|(
name|rv
operator|=
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_sigmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|rv
return|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_signal_unblock
argument_list|(
argument|int signum
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_HAVE_SIGACTION
name|sigset_t
name|sig_mask
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sig_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sig_mask
argument_list|,
name|signum
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGPROCMASK_SETS_THREAD_MASK
argument_list|)
operator|||
operator|!
name|APR_HAS_THREADS
if|if
condition|(
operator|(
name|rv
operator|=
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_sigmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sig_mask
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|rv
return|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
block|}
end_block

end_unit

