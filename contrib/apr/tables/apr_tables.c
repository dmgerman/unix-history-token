begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * Resource allocation code... the code here is responsible for making  * sure that nothing leaks.  *  * rst --- 4/95 --- 6/95  */
end_comment

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_tables.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRINGS_H
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|||
name|defined
argument_list|(
name|MAKE_TABLE_PROFILE
argument_list|)
operator|)
operator|&&
name|APR_HAVE_STDIO_H
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************  * This file contains array and apr_table_t functions only.  */
end_comment

begin_comment
comment|/*****************************************************************  *  * The 'array' functions...  */
end_comment

begin_function
specifier|static
name|void
name|make_array_core
parameter_list|(
name|apr_array_header_t
modifier|*
name|res
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|int
name|nelts
parameter_list|,
name|int
name|elt_size
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
comment|/*      * Assure sanity if someone asks for      * array of zero elts.      */
if|if
condition|(
name|nelts
operator|<
literal|1
condition|)
block|{
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|clear
condition|)
block|{
name|res
operator|->
name|elts
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
name|nelts
operator|*
name|elt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|->
name|elts
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|nelts
operator|*
name|elt_size
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|res
operator|->
name|elt_size
operator|=
name|elt_size
expr_stmt|;
name|res
operator|->
name|nelts
operator|=
literal|0
expr_stmt|;
comment|/* No active elements yet... */
name|res
operator|->
name|nalloc
operator|=
name|nelts
expr_stmt|;
comment|/* ...but this many allocated */
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_is_empty_array
argument_list|(
argument|const apr_array_header_t *a
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|a
operator|==
name|NULL
operator|)
operator|||
operator|(
name|a
operator|->
name|nelts
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_array_make
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|int nelts
argument_list|,
argument|int elt_size
argument_list|)
end_macro

begin_block
block|{
name|apr_array_header_t
modifier|*
name|res
decl_stmt|;
name|res
operator|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_array_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|make_array_core
argument_list|(
name|res
argument_list|,
name|p
argument_list|,
name|nelts
argument_list|,
name|elt_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_array_clear
argument_list|(
argument|apr_array_header_t *arr
argument_list|)
end_macro

begin_block
block|{
name|arr
operator|->
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_array_pop
argument_list|(
argument|apr_array_header_t *arr
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|arr
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|arr
operator|->
name|elts
operator|+
operator|(
name|arr
operator|->
name|elt_size
operator|*
operator|(
operator|--
name|arr
operator|->
name|nelts
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_array_push
argument_list|(
argument|apr_array_header_t *arr
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|arr
operator|->
name|nelts
operator|==
name|arr
operator|->
name|nalloc
condition|)
block|{
name|int
name|new_size
init|=
operator|(
name|arr
operator|->
name|nalloc
operator|<=
literal|0
operator|)
condition|?
literal|1
else|:
name|arr
operator|->
name|nalloc
operator|*
literal|2
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
name|new_data
operator|=
name|apr_palloc
argument_list|(
name|arr
operator|->
name|pool
argument_list|,
name|arr
operator|->
name|elt_size
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_data
argument_list|,
name|arr
operator|->
name|elts
argument_list|,
name|arr
operator|->
name|nalloc
operator|*
name|arr
operator|->
name|elt_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_data
operator|+
name|arr
operator|->
name|nalloc
operator|*
name|arr
operator|->
name|elt_size
argument_list|,
literal|0
argument_list|,
name|arr
operator|->
name|elt_size
operator|*
operator|(
name|new_size
operator|-
name|arr
operator|->
name|nalloc
operator|)
argument_list|)
expr_stmt|;
name|arr
operator|->
name|elts
operator|=
name|new_data
expr_stmt|;
name|arr
operator|->
name|nalloc
operator|=
name|new_size
expr_stmt|;
block|}
operator|++
name|arr
operator|->
name|nelts
expr_stmt|;
return|return
name|arr
operator|->
name|elts
operator|+
operator|(
name|arr
operator|->
name|elt_size
operator|*
operator|(
name|arr
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|apr_array_push_noclear
parameter_list|(
name|apr_array_header_t
modifier|*
name|arr
parameter_list|)
block|{
if|if
condition|(
name|arr
operator|->
name|nelts
operator|==
name|arr
operator|->
name|nalloc
condition|)
block|{
name|int
name|new_size
init|=
operator|(
name|arr
operator|->
name|nalloc
operator|<=
literal|0
operator|)
condition|?
literal|1
else|:
name|arr
operator|->
name|nalloc
operator|*
literal|2
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
name|new_data
operator|=
name|apr_palloc
argument_list|(
name|arr
operator|->
name|pool
argument_list|,
name|arr
operator|->
name|elt_size
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_data
argument_list|,
name|arr
operator|->
name|elts
argument_list|,
name|arr
operator|->
name|nalloc
operator|*
name|arr
operator|->
name|elt_size
argument_list|)
expr_stmt|;
name|arr
operator|->
name|elts
operator|=
name|new_data
expr_stmt|;
name|arr
operator|->
name|nalloc
operator|=
name|new_size
expr_stmt|;
block|}
operator|++
name|arr
operator|->
name|nelts
expr_stmt|;
return|return
name|arr
operator|->
name|elts
operator|+
operator|(
name|arr
operator|->
name|elt_size
operator|*
operator|(
name|arr
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_array_cat
argument_list|(
argument|apr_array_header_t *dst
argument_list|,
argument|const apr_array_header_t *src
argument_list|)
end_macro

begin_block
block|{
name|int
name|elt_size
init|=
name|dst
operator|->
name|elt_size
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|nelts
operator|+
name|src
operator|->
name|nelts
operator|>
name|dst
operator|->
name|nalloc
condition|)
block|{
name|int
name|new_size
init|=
operator|(
name|dst
operator|->
name|nalloc
operator|<=
literal|0
operator|)
condition|?
literal|1
else|:
name|dst
operator|->
name|nalloc
operator|*
literal|2
decl_stmt|;
name|char
modifier|*
name|new_data
decl_stmt|;
while|while
condition|(
name|dst
operator|->
name|nelts
operator|+
name|src
operator|->
name|nelts
operator|>
name|new_size
condition|)
block|{
name|new_size
operator|*=
literal|2
expr_stmt|;
block|}
name|new_data
operator|=
name|apr_pcalloc
argument_list|(
name|dst
operator|->
name|pool
argument_list|,
name|elt_size
operator|*
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_data
argument_list|,
name|dst
operator|->
name|elts
argument_list|,
name|dst
operator|->
name|nalloc
operator|*
name|elt_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|elts
operator|=
name|new_data
expr_stmt|;
name|dst
operator|->
name|nalloc
operator|=
name|new_size
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dst
operator|->
name|elts
operator|+
name|dst
operator|->
name|nelts
operator|*
name|elt_size
argument_list|,
name|src
operator|->
name|elts
argument_list|,
name|elt_size
operator|*
name|src
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|dst
operator|->
name|nelts
operator|+=
name|src
operator|->
name|nelts
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_array_copy
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_array_header_t *arr
argument_list|)
end_macro

begin_block
block|{
name|apr_array_header_t
modifier|*
name|res
init|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_array_header_t
argument_list|)
argument_list|)
decl_stmt|;
name|make_array_core
argument_list|(
name|res
argument_list|,
name|p
argument_list|,
name|arr
operator|->
name|nalloc
argument_list|,
name|arr
operator|->
name|elt_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|elts
argument_list|,
name|arr
operator|->
name|elts
argument_list|,
name|arr
operator|->
name|elt_size
operator|*
name|arr
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|res
operator|->
name|nelts
operator|=
name|arr
operator|->
name|nelts
expr_stmt|;
name|memset
argument_list|(
name|res
operator|->
name|elts
operator|+
name|res
operator|->
name|elt_size
operator|*
name|res
operator|->
name|nelts
argument_list|,
literal|0
argument_list|,
name|res
operator|->
name|elt_size
operator|*
operator|(
name|res
operator|->
name|nalloc
operator|-
name|res
operator|->
name|nelts
operator|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/* This cute function copies the array header *only*, but arranges  * for the data section to be copied on the first push or arraycat.  * It's useful when the elements of the array being copied are  * read only, but new stuff *might* get added on the end; we have the  * overhead of the full copy only where it is really needed.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|copy_array_hdr_core
parameter_list|(
name|apr_array_header_t
modifier|*
name|res
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|arr
parameter_list|)
block|{
name|res
operator|->
name|elts
operator|=
name|arr
operator|->
name|elts
expr_stmt|;
name|res
operator|->
name|elt_size
operator|=
name|arr
operator|->
name|elt_size
expr_stmt|;
name|res
operator|->
name|nelts
operator|=
name|arr
operator|->
name|nelts
expr_stmt|;
name|res
operator|->
name|nalloc
operator|=
name|arr
operator|->
name|nelts
expr_stmt|;
comment|/* Force overflow on push */
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_array_copy_hdr
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_array_header_t *arr
argument_list|)
end_macro

begin_block
block|{
name|apr_array_header_t
modifier|*
name|res
decl_stmt|;
name|res
operator|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_array_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|copy_array_hdr_core
argument_list|(
name|res
argument_list|,
name|arr
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/* The above is used here to avoid consing multiple new array bodies... */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_array_append
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_array_header_t *first
argument_list|,
argument|const apr_array_header_t *second
argument_list|)
end_macro

begin_block
block|{
name|apr_array_header_t
modifier|*
name|res
init|=
name|apr_array_copy_hdr
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|apr_array_cat
argument_list|(
name|res
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/* apr_array_pstrcat generates a new string from the apr_pool_t containing  * the concatenated sequence of substrings referenced as elements within  * the array.  The string will be empty if all substrings are empty or null,  * or if there are no elements in the array.  * If sep is non-NUL, it will be inserted between elements as a separator.  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_array_pstrcat
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_array_header_t *arr
argument_list|,
argument|const char sep
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
modifier|*
name|strpp
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arr
operator|->
name|nelts
operator|<=
literal|0
operator|||
name|arr
operator|->
name|elts
operator|==
name|NULL
condition|)
block|{
comment|/* Empty table? */
return|return
operator|(
name|char
operator|*
operator|)
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Pass one --- find length of required string */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|strpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arr
operator|->
name|elts
init|;
condition|;
operator|++
name|strpp
control|)
block|{
if|if
condition|(
name|strpp
operator|&&
operator|*
name|strpp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
operator|*
name|strpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|arr
operator|->
name|nelts
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sep
condition|)
block|{
operator|++
name|len
expr_stmt|;
block|}
block|}
comment|/* Allocate the required string */
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|res
expr_stmt|;
comment|/* Pass two --- copy the argument strings into the result space */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|strpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arr
operator|->
name|elts
init|;
condition|;
operator|++
name|strpp
control|)
block|{
if|if
condition|(
name|strpp
operator|&&
operator|*
name|strpp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|strpp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|strpp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|arr
operator|->
name|nelts
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sep
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|sep
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Return the result string */
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*****************************************************************  *  * The "table" functions.  */
end_comment

begin_if
if|#
directive|if
name|APR_CHARSET_EBCDIC
end_if

begin_define
define|#
directive|define
name|CASE_MASK
value|0xbfbfbfbf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CASE_MASK
value|0xdfdfdfdf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TABLE_HASH_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|TABLE_INDEX_MASK
value|0x1f
end_define

begin_define
define|#
directive|define
name|TABLE_HASH
parameter_list|(
name|key
parameter_list|)
value|(TABLE_INDEX_MASK& *(unsigned char *)(key))
end_define

begin_define
define|#
directive|define
name|TABLE_INDEX_IS_INITIALIZED
parameter_list|(
name|t
parameter_list|,
name|i
parameter_list|)
value|((t)->index_initialized& (1<< (i)))
end_define

begin_define
define|#
directive|define
name|TABLE_SET_INDEX_INITIALIZED
parameter_list|(
name|t
parameter_list|,
name|i
parameter_list|)
value|((t)->index_initialized |= (1<< (i)))
end_define

begin_comment
comment|/* Compute the "checksum" for a key, consisting of the first  * 4 bytes, normalized for case-insensitivity and packed into  * an int...this checksum allows us to do a single integer  * comparison as a fast check to determine whether we can  * skip a strcasecmp  */
end_comment

begin_define
define|#
directive|define
name|COMPUTE_KEY_CHECKSUM
parameter_list|(
name|key
parameter_list|,
name|checksum
parameter_list|)
define|\
value|{                                              \     const char *k = (key);                     \     apr_uint32_t c = (apr_uint32_t)*k;         \     (checksum) = c;                            \     (checksum)<<= 8;                          \     if (c) {                                   \         c = (apr_uint32_t)*++k;                \         checksum |= c;                         \     }                                          \     (checksum)<<= 8;                          \     if (c) {                                   \         c = (apr_uint32_t)*++k;                \         checksum |= c;                         \     }                                          \     (checksum)<<= 8;                          \     if (c) {                                   \         c = (apr_uint32_t)*++k;                \         checksum |= c;                         \     }                                          \     checksum&= CASE_MASK;                     \ }
end_define

begin_comment
comment|/** The opaque string-content table type */
end_comment

begin_struct
struct|struct
name|apr_table_t
block|{
comment|/* This has to be first to promote backwards compatibility with      * older modules which cast a apr_table_t * to an apr_array_header_t *...      * they should use the apr_table_elts() function for most of the      * cases they do this for.      */
comment|/** The underlying array for the table */
name|apr_array_header_t
name|a
decl_stmt|;
ifdef|#
directive|ifdef
name|MAKE_TABLE_PROFILE
comment|/** Who created the array. */
name|void
modifier|*
name|creator
decl_stmt|;
endif|#
directive|endif
comment|/* An index to speed up table lookups.  The way this works is:      *   - Hash the key into the index:      *     - index_first[TABLE_HASH(key)] is the offset within      *       the table of the first entry with that key      *     - index_last[TABLE_HASH(key)] is the offset within      *       the table of the last entry with that key      *   - If (and only if) there is no entry in the table whose      *     key hashes to index element i, then the i'th bit      *     of index_initialized will be zero.  (Check this before      *     trying to use index_first[i] or index_last[i]!)      */
name|apr_uint32_t
name|index_initialized
decl_stmt|;
name|int
name|index_first
index|[
name|TABLE_HASH_SIZE
index|]
decl_stmt|;
name|int
name|index_last
index|[
name|TABLE_HASH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * NOTICE: if you tweak this you should look at is_empty_table()   * and table_elts() in alloc.h  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAKE_TABLE_PROFILE
end_ifdef

begin_function
specifier|static
name|apr_table_entry_t
modifier|*
name|do_table_push
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|apr_table_t
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|a
operator|.
name|nelts
operator|==
name|t
operator|->
name|a
operator|.
name|nalloc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: table created by %p hit limit of %u\n"
argument_list|,
name|func
condition|?
name|func
else|:
literal|"table_push"
argument_list|,
name|t
operator|->
name|creator
argument_list|,
name|t
operator|->
name|a
operator|.
name|nalloc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|apr_array_push_noclear
argument_list|(
operator|&
name|t
operator|->
name|a
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
end_if

begin_define
define|#
directive|define
name|table_push
parameter_list|(
name|t
parameter_list|)
value|do_table_push(__FUNCTION__, t)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|table_push
parameter_list|(
name|t
parameter_list|)
value|do_table_push(NULL, t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MAKE_TABLE_PROFILE */
end_comment

begin_define
define|#
directive|define
name|table_push
parameter_list|(
name|t
parameter_list|)
value|((apr_table_entry_t *) apr_array_push_noclear(&(t)->a))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKE_TABLE_PROFILE */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|const apr_array_header_t *
argument_list|)
end_macro

begin_macro
name|apr_table_elts
argument_list|(
argument|const apr_table_t *t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
specifier|const
name|apr_array_header_t
operator|*
operator|)
name|t
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_is_empty_table
argument_list|(
argument|const apr_table_t *t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|t
operator|==
name|NULL
operator|)
operator|||
operator|(
name|t
operator|->
name|a
operator|.
name|nelts
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_table_t *
argument_list|)
end_macro

begin_macro
name|apr_table_make
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|int nelts
argument_list|)
end_macro

begin_block
block|{
name|apr_table_t
modifier|*
name|t
init|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_table_t
argument_list|)
argument_list|)
decl_stmt|;
name|make_array_core
argument_list|(
operator|&
name|t
operator|->
name|a
argument_list|,
name|p
argument_list|,
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_table_entry_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAKE_TABLE_PROFILE
name|t
operator|->
name|creator
operator|=
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|->
name|index_initialized
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_table_t *
argument_list|)
end_macro

begin_macro
name|apr_table_copy
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_table_t *t
argument_list|)
end_macro

begin_block
block|{
name|apr_table_t
modifier|*
name|new
init|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_table_t
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* we don't copy keys and values, so it's necessary that t->a.pool      * have a life span at least as long as p      */
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_copy: t's pool is not an ancestor of p\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|make_array_core
argument_list|(
operator|&
name|new
operator|->
name|a
argument_list|,
name|p
argument_list|,
name|t
operator|->
name|a
operator|.
name|nalloc
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_table_entry_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|a
operator|.
name|elts
argument_list|,
name|t
operator|->
name|a
operator|.
name|elts
argument_list|,
name|t
operator|->
name|a
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|apr_table_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|a
operator|.
name|nelts
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|index_first
argument_list|,
name|t
operator|->
name|index_first
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TABLE_HASH_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
operator|->
name|index_last
argument_list|,
name|t
operator|->
name|index_last
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TABLE_HASH_SIZE
argument_list|)
expr_stmt|;
name|new
operator|->
name|index_initialized
operator|=
name|t
operator|->
name|index_initialized
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_table_t *
argument_list|)
end_macro

begin_macro
name|apr_table_clone
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_table_t *t
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|array
init|=
name|apr_table_elts
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|elts
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|array
operator|->
name|elts
decl_stmt|;
name|apr_table_t
modifier|*
name|new
init|=
name|apr_table_make
argument_list|(
name|p
argument_list|,
name|array
operator|->
name|nelts
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_table_add
argument_list|(
name|new
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|table_reindex
parameter_list|(
name|apr_table_t
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|next_elt
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
decl_stmt|;
name|t
operator|->
name|index_initialized
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|a
operator|.
name|nelts
condition|;
name|i
operator|++
operator|,
name|next_elt
operator|++
control|)
block|{
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|next_elt
operator|->
name|key
argument_list|)
expr_stmt|;
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|i
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_clear
argument_list|(
argument|apr_table_t *t
argument_list|)
end_macro

begin_block
block|{
name|t
operator|->
name|a
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|index_initialized
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|apr_table_get
argument_list|(
argument|const apr_table_t *t
argument_list|,
argument|const char *key
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
empty_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
name|next_elt
operator|->
name|val
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_set
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|table_end
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|add_new_elt
goto|;
block|}
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
empty_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
name|table_end
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* Found an existing entry with the same key, so overwrite it */
name|int
name|must_reindex
init|=
literal|0
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|dst_elt
init|=
name|NULL
decl_stmt|;
name|next_elt
operator|->
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Remove any other instances of this key */
for|for
control|(
name|next_elt
operator|++
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|t
operator|->
name|a
operator|.
name|nelts
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|dst_elt
condition|)
block|{
name|dst_elt
operator|=
name|next_elt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst_elt
condition|)
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
name|must_reindex
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we've removed anything, shift over the remainder              * of the table (note that the previous loop didn't              * run to the end of the table, just to the last match              * for the index)              */
if|if
condition|(
name|dst_elt
condition|)
block|{
for|for
control|(
init|;
name|next_elt
operator|<
name|table_end
condition|;
name|next_elt
operator|++
control|)
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
block|}
name|must_reindex
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|must_reindex
condition|)
block|{
name|table_reindex
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|add_new_elt
label|:
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|next_elt
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_setn
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|table_end
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|add_new_elt
goto|;
block|}
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
empty_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
name|table_end
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* Found an existing entry with the same key, so overwrite it */
name|int
name|must_reindex
init|=
literal|0
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|dst_elt
init|=
name|NULL
decl_stmt|;
name|next_elt
operator|->
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|val
expr_stmt|;
comment|/* Remove any other instances of this key */
for|for
control|(
name|next_elt
operator|++
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|t
operator|->
name|a
operator|.
name|nelts
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|dst_elt
condition|)
block|{
name|dst_elt
operator|=
name|next_elt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst_elt
condition|)
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
name|must_reindex
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we've removed anything, shift over the remainder              * of the table (note that the previous loop didn't              * run to the end of the table, just to the last match              * for the index)              */
if|if
condition|(
name|dst_elt
condition|)
block|{
for|for
control|(
init|;
name|next_elt
operator|<
name|table_end
condition|;
name|next_elt
operator|++
control|)
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
block|}
name|must_reindex
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|must_reindex
condition|)
block|{
name|table_reindex
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|add_new_elt
label|:
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|next_elt
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|key
expr_stmt|;
name|next_elt
operator|->
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|val
expr_stmt|;
name|next_elt
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_unset
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|dst_elt
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|int
name|must_reindex
decl_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
return|return;
block|}
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
name|must_reindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* Found a match: remove this entry, plus any additional              * matches for the same key that might follow              */
name|apr_table_entry_t
modifier|*
name|table_end
init|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|a
operator|.
name|nelts
decl_stmt|;
name|t
operator|->
name|a
operator|.
name|nelts
operator|--
expr_stmt|;
name|dst_elt
operator|=
name|next_elt
expr_stmt|;
for|for
control|(
name|next_elt
operator|++
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|t
operator|->
name|a
operator|.
name|nelts
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
block|}
block|}
comment|/* Shift over the remainder of the table (note that              * the previous loop didn't run to the end of the table,              * just to the last match for the index)              */
for|for
control|(
init|;
name|next_elt
operator|<
name|table_end
condition|;
name|next_elt
operator|++
control|)
block|{
operator|*
name|dst_elt
operator|++
operator|=
operator|*
name|next_elt
expr_stmt|;
block|}
name|must_reindex
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|must_reindex
condition|)
block|{
name|table_reindex
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_merge
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|add_new_elt
goto|;
block|}
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* Found an existing entry with the same key, so merge with it */
name|next_elt
operator|->
name|val
operator|=
name|apr_pstrcat
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|next_elt
operator|->
name|val
argument_list|,
literal|", "
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|add_new_elt
label|:
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|next_elt
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_mergen
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|next_elt
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|end_elt
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
name|apr_pool_find
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pool
operator|!=
name|key
operator|)
operator|&&
operator|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|pool
argument_list|,
name|t
operator|->
name|a
operator|.
name|pool
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_mergen: key not in ancestor pool of t\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|pool
operator|=
name|apr_pool_find
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pool
operator|!=
name|val
operator|)
operator|&&
operator|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|pool
argument_list|,
name|t
operator|->
name|a
operator|.
name|pool
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_mergen: val not in ancestor pool of t\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|add_new_elt
goto|;
block|}
name|next_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_first
index|[
name|hash
index|]
expr_stmt|;
empty_stmt|;
name|end_elt
operator|=
operator|(
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
operator|)
operator|+
name|t
operator|->
name|index_last
index|[
name|hash
index|]
expr_stmt|;
for|for
control|(
init|;
name|next_elt
operator|<=
name|end_elt
condition|;
name|next_elt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|checksum
operator|==
name|next_elt
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|next_elt
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* Found an existing entry with the same key, so merge with it */
name|next_elt
operator|->
name|val
operator|=
name|apr_pstrcat
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|next_elt
operator|->
name|val
argument_list|,
literal|", "
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|add_new_elt
label|:
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|next_elt
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|next_elt
operator|->
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|key
expr_stmt|;
name|next_elt
operator|->
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|val
expr_stmt|;
name|next_elt
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_add
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|elts
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|elts
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|elts
operator|->
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|elts
operator|->
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elts
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_addn
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|const char *key
argument_list|,
argument|const char *val
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
name|elts
decl_stmt|;
name|apr_uint32_t
name|checksum
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
block|{
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|apr_pool_find
argument_list|(
name|key
argument_list|)
argument_list|,
name|t
operator|->
name|a
operator|.
name|pool
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_addn: key not in ancestor pool of t\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|apr_pool_find
argument_list|(
name|val
argument_list|)
argument_list|,
name|t
operator|->
name|a
operator|.
name|pool
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_addn: val not in ancestor pool of t\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|hash
operator|=
name|TABLE_HASH
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|hash
index|]
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|TABLE_SET_INDEX_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|key
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|elts
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|table_push
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|elts
operator|->
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|key
expr_stmt|;
name|elts
operator|->
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|val
expr_stmt|;
name|elts
operator|->
name|key_checksum
operator|=
name|checksum
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_table_t *
argument_list|)
end_macro

begin_macro
name|apr_table_overlay
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_table_t *overlay
argument_list|,
argument|const apr_table_t *base
argument_list|)
end_macro

begin_block
block|{
name|apr_table_t
modifier|*
name|res
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* we don't copy keys and values, so it's necessary that      * overlay->a.pool and base->a.pool have a life span at least      * as long as p      */
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|overlay
operator|->
name|a
operator|.
name|pool
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_overlay: overlay's pool is not an ancestor of p\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|base
operator|->
name|a
operator|.
name|pool
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_overlay: base's pool is not an ancestor of p\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_table_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* behave like append_arrays */
name|res
operator|->
name|a
operator|.
name|pool
operator|=
name|p
expr_stmt|;
name|copy_array_hdr_core
argument_list|(
operator|&
name|res
operator|->
name|a
argument_list|,
operator|&
name|overlay
operator|->
name|a
argument_list|)
expr_stmt|;
name|apr_array_cat
argument_list|(
operator|&
name|res
operator|->
name|a
argument_list|,
operator|&
name|base
operator|->
name|a
argument_list|)
expr_stmt|;
name|table_reindex
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/* And now for something completely abstract ...   * For each key value given as a vararg:  *   run the function pointed to as  *     int comp(void *r, char *key, char *value);  *   on each valid key-value pair in the apr_table_t t that matches the vararg key,  *   or once for every valid key-value pair if the vararg list is empty,  *   until the function returns false (0) or we finish the table.  *  * Note that we restart the traversal for each vararg, which means that  * duplicate varargs will result in multiple executions of the function  * for each matching key.  Note also that if the vararg list is empty,  * only one traversal will be made and will cut short if comp returns 0.  *  * Note that the table_get and table_merge functions assume that each key in  * the apr_table_t is unique (i.e., no multiple entries with the same key).  This  * function does not make that assumption, since it (unfortunately) isn't  * true for some of Apache's tables.  *  * Note that rec is simply passed-on to the comp function, so that the  * caller can pass additional info for the task.  *  * ADDENDUM for apr_table_vdo():  *   * The caching api will allow a user to walk the header values:  *  * apr_status_t apr_cache_el_header_walk(apr_cache_el *el,   *    int (*comp)(void *, const char *, const char *), void *rec, ...);  *  * So it can be ..., however from there I use a  callback that use a va_list:  *  * apr_status_t (*cache_el_header_walk)(apr_cache_el *el,   *    int (*comp)(void *, const char *, const char *), void *rec, va_list);  *  * To pass those ...'s on down to the actual module that will handle walking  * their headers, in the file case this is actually just an apr_table - and  * rather than reimplementing apr_table_do (which IMHO would be bad) I just  * called it with the va_list. For mod_shmem_cache I don't need it since I  * can't use apr_table's, but mod_file_cache should (though a good hash would  * be better, but that's a different issue :).   *  * So to make mod_file_cache easier to maintain, it's a good thing  */
end_comment

begin_macro
name|APR_DECLARE_NONSTD
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_table_do
argument_list|(
argument|apr_table_do_callback_fn_t *comp
argument_list|,
argument|void *rec
argument_list|,
argument|const apr_table_t *t
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|int
name|rv
decl_stmt|;
name|va_list
name|vp
decl_stmt|;
name|va_start
argument_list|(
name|vp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_table_vdo
argument_list|(
name|comp
argument_list|,
name|rec
argument_list|,
name|t
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_block

begin_comment
comment|/* XXX: do the semantics of this routine make any sense?  Right now,  * if the caller passed in a non-empty va_list of keys to search for,  * the "early termination" facility only terminates on *that* key; other  * keys will continue to process.  Note that this only has any effect  * at all if there are multiple entries in the table with the same key,  * otherwise the called function can never effectively early-terminate  * this function, as the zero return value is effectively ignored.  *  * Note also that this behavior is at odds with the behavior seen if an  * empty va_list is passed in -- in that case, a zero return value terminates  * the entire apr_table_vdo (which is what I think should happen in  * both cases).  *  * If nobody objects soon, I'm going to change the order of the nested  * loops in this function so that any zero return value from the (*comp)  * function will cause a full termination of apr_table_vdo.  I'm hesitant  * at the moment because these (funky) semantics have been around for a  * very long time, and although Apache doesn't seem to use them at all,  * some third-party vendor might.  I can only think of one possible reason  * the existing semantics would make any sense, and it's very Apache-centric,  * which is this: if (*comp) is looking for matches of a particular  * substring in request headers (let's say it's looking for a particular  * cookie name in the Set-Cookie headers), then maybe it wants to be  * able to stop searching early as soon as it finds that one and move  * on to the next key.  That's only an optimization of course, but changing  * the behavior of this function would mean that any code that tried  * to do that would stop working right.  *  * Sigh.  --JCW, 06/28/02  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_table_vdo
argument_list|(
argument|apr_table_do_callback_fn_t *comp
argument_list|,
argument|void *rec
argument_list|,
argument|const apr_table_t *t
argument_list|,
argument|va_list vp
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|argp
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|elts
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
decl_stmt|;
name|int
name|vdorv
init|=
literal|1
decl_stmt|;
name|argp
operator|=
name|va_arg
argument_list|(
name|vp
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|rv
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|argp
condition|)
block|{
comment|/* Scan for entries that match the next key */
name|int
name|hash
init|=
name|TABLE_HASH
argument_list|(
name|argp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|apr_uint32_t
name|checksum
decl_stmt|;
name|COMPUTE_KEY_CHECKSUM
argument_list|(
name|argp
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|index_first
index|[
name|hash
index|]
init|;
name|rv
operator|&&
operator|(
name|i
operator|<=
name|t
operator|->
name|index_last
index|[
name|hash
index|]
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|.
name|key
operator|&&
operator|(
name|checksum
operator|==
name|elts
index|[
name|i
index|]
operator|.
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|elts
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|argp
argument_list|)
condition|)
block|{
name|rv
operator|=
call|(
modifier|*
name|comp
call|)
argument_list|(
name|rec
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Scan the entire table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rv
operator|&&
operator|(
name|i
operator|<
name|t
operator|->
name|a
operator|.
name|nelts
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|.
name|key
condition|)
block|{
name|rv
operator|=
call|(
modifier|*
name|comp
call|)
argument_list|(
name|rec
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|elts
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|vdorv
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|argp
operator|&&
operator|(
operator|(
name|argp
operator|=
name|va_arg
argument_list|(
name|vp
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
do|;
return|return
name|vdorv
return|;
block|}
end_block

begin_function
specifier|static
name|apr_table_entry_t
modifier|*
modifier|*
name|table_mergesort
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_table_entry_t
modifier|*
modifier|*
name|values
parameter_list|,
name|apr_size_t
name|n
parameter_list|)
block|{
comment|/* Bottom-up mergesort, based on design in Sedgewick's "Algorithms      * in C," chapter 8      */
name|apr_table_entry_t
modifier|*
modifier|*
name|values_tmp
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|*
operator|)
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|apr_table_entry_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|blocksize
decl_stmt|;
comment|/* First pass: sort pairs of elements (blocksize=1) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|n
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|values
index|[
name|i
index|]
operator|->
name|key
argument_list|,
name|values
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|key
argument_list|)
operator|>
literal|0
condition|)
block|{
name|apr_table_entry_t
modifier|*
name|swap
init|=
name|values
index|[
name|i
index|]
decl_stmt|;
name|values
index|[
name|i
index|]
operator|=
name|values
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|values
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|swap
expr_stmt|;
block|}
block|}
comment|/* Merge successively larger blocks */
name|blocksize
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|blocksize
operator|<
name|n
condition|)
block|{
name|apr_table_entry_t
modifier|*
modifier|*
name|dst
init|=
name|values_tmp
decl_stmt|;
name|apr_size_t
name|next_start
decl_stmt|;
name|apr_table_entry_t
modifier|*
modifier|*
name|swap
decl_stmt|;
comment|/* Merge consecutive pairs blocks of the next blocksize.          * Within a block, elements are in sorted order due to          * the previous iteration.          */
for|for
control|(
name|next_start
operator|=
literal|0
init|;
name|next_start
operator|+
name|blocksize
operator|<
name|n
condition|;
name|next_start
operator|+=
operator|(
name|blocksize
operator|+
name|blocksize
operator|)
control|)
block|{
name|apr_size_t
name|block1_start
init|=
name|next_start
decl_stmt|;
name|apr_size_t
name|block2_start
init|=
name|block1_start
operator|+
name|blocksize
decl_stmt|;
name|apr_size_t
name|block1_end
init|=
name|block2_start
decl_stmt|;
name|apr_size_t
name|block2_end
init|=
name|block2_start
operator|+
name|blocksize
decl_stmt|;
if|if
condition|(
name|block2_end
operator|>
name|n
condition|)
block|{
comment|/* The last block may be smaller than blocksize */
name|block2_end
operator|=
name|n
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Merge the next two blocks:                  * Pick the smaller of the next element from                  * block 1 and the next element from block 2.                  * Once either of the blocks is emptied, copy                  * over all the remaining elements from the                  * other block                  */
if|if
condition|(
name|block1_start
operator|==
name|block1_end
condition|)
block|{
for|for
control|(
init|;
name|block2_start
operator|<
name|block2_end
condition|;
name|block2_start
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|values
index|[
name|block2_start
index|]
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|block2_start
operator|==
name|block2_end
condition|)
block|{
for|for
control|(
init|;
name|block1_start
operator|<
name|block1_end
condition|;
name|block1_start
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|values
index|[
name|block1_start
index|]
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|values
index|[
name|block1_start
index|]
operator|->
name|key
argument_list|,
name|values
index|[
name|block2_start
index|]
operator|->
name|key
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|values
index|[
name|block2_start
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
name|values
index|[
name|block1_start
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* If n is not a multiple of 2*blocksize, some elements          * will be left over at the end of the array.          */
for|for
control|(
name|i
operator|=
name|dst
operator|-
name|values_tmp
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|values_tmp
index|[
name|i
index|]
operator|=
name|values
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* The output array of this pass becomes the input          * array of the next pass, and vice versa          */
name|swap
operator|=
name|values_tmp
expr_stmt|;
name|values_tmp
operator|=
name|values
expr_stmt|;
name|values
operator|=
name|swap
expr_stmt|;
name|blocksize
operator|+=
name|blocksize
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_compress
argument_list|(
argument|apr_table_t *t
argument_list|,
argument|unsigned flags
argument_list|)
end_macro

begin_block
block|{
name|apr_table_entry_t
modifier|*
modifier|*
name|sort_array
decl_stmt|;
name|apr_table_entry_t
modifier|*
modifier|*
name|sort_next
decl_stmt|;
name|apr_table_entry_t
modifier|*
modifier|*
name|sort_end
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|table_next
decl_stmt|;
name|apr_table_entry_t
modifier|*
modifier|*
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dups_found
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|a
operator|.
name|nelts
operator|<=
literal|1
condition|)
block|{
return|return;
block|}
comment|/* Copy pointers to all the table elements into an      * array and sort to allow for easy detection of      * duplicate keys      */
name|sort_array
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|*
operator|)
name|apr_palloc
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|t
operator|->
name|a
operator|.
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|apr_table_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sort_next
operator|=
name|sort_array
expr_stmt|;
name|table_next
operator|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
expr_stmt|;
name|i
operator|=
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
do|do
block|{
operator|*
name|sort_next
operator|++
operator|=
name|table_next
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* Note: the merge is done with mergesort instead of quicksort      * because mergesort is a stable sort and runs in n*log(n)      * time regardless of its inputs (quicksort is quadratic in      * the worst case)      */
name|sort_array
operator|=
name|table_mergesort
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|sort_array
argument_list|,
name|t
operator|->
name|a
operator|.
name|nelts
argument_list|)
expr_stmt|;
comment|/* Process any duplicate keys */
name|dups_found
operator|=
literal|0
expr_stmt|;
name|sort_next
operator|=
name|sort_array
expr_stmt|;
name|sort_end
operator|=
name|sort_array
operator|+
name|t
operator|->
name|a
operator|.
name|nelts
expr_stmt|;
name|last
operator|=
name|sort_next
operator|++
expr_stmt|;
while|while
condition|(
name|sort_next
operator|<
name|sort_end
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|sort_next
operator|)
operator|->
name|key_checksum
operator|==
operator|(
operator|*
name|last
operator|)
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|(
operator|*
name|sort_next
operator|)
operator|->
name|key
argument_list|,
operator|(
operator|*
name|last
operator|)
operator|->
name|key
argument_list|)
condition|)
block|{
name|apr_table_entry_t
modifier|*
modifier|*
name|dup_last
init|=
name|sort_next
operator|+
literal|1
decl_stmt|;
name|dups_found
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|dup_last
operator|<
name|sort_end
operator|)
operator|&&
operator|(
operator|(
operator|*
name|dup_last
operator|)
operator|->
name|key_checksum
operator|==
operator|(
operator|*
name|last
operator|)
operator|->
name|key_checksum
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|(
operator|*
name|dup_last
operator|)
operator|->
name|key
argument_list|,
operator|(
operator|*
name|last
operator|)
operator|->
name|key
argument_list|)
condition|)
block|{
name|dup_last
operator|++
expr_stmt|;
block|}
name|dup_last
operator|--
expr_stmt|;
comment|/* Elements from last through dup_last, inclusive,                          * all have the same key                          */
if|if
condition|(
name|flags
operator|==
name|APR_OVERLAP_TABLES_MERGE
condition|)
block|{
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|;
name|apr_table_entry_t
modifier|*
modifier|*
name|next
init|=
name|last
decl_stmt|;
name|char
modifier|*
name|new_val
decl_stmt|;
name|char
modifier|*
name|val_dst
decl_stmt|;
do|do
block|{
name|len
operator|+=
name|strlen
argument_list|(
operator|(
operator|*
name|next
operator|)
operator|->
name|val
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
comment|/* for ", " or trailing null */
block|}
do|while
condition|(
operator|++
name|next
operator|<=
name|dup_last
condition|)
do|;
name|new_val
operator|=
operator|(
name|char
operator|*
operator|)
name|apr_palloc
argument_list|(
name|t
operator|->
name|a
operator|.
name|pool
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val_dst
operator|=
name|new_val
expr_stmt|;
name|next
operator|=
name|last
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|strcpy
argument_list|(
name|val_dst
argument_list|,
operator|(
operator|*
name|next
operator|)
operator|->
name|val
argument_list|)
expr_stmt|;
name|val_dst
operator|+=
name|strlen
argument_list|(
operator|(
operator|*
name|next
operator|)
operator|->
name|val
argument_list|)
expr_stmt|;
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|dup_last
condition|)
block|{
operator|*
name|val_dst
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|val_dst
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|val_dst
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|last
operator|)
operator|->
name|val
operator|=
name|new_val
expr_stmt|;
block|}
else|else
block|{
comment|/* overwrite */
operator|(
operator|*
name|last
operator|)
operator|->
name|val
operator|=
operator|(
operator|*
name|dup_last
operator|)
operator|->
name|val
expr_stmt|;
block|}
do|do
block|{
operator|(
operator|*
name|sort_next
operator|)
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|sort_next
operator|<=
name|dup_last
condition|)
do|;
block|}
else|else
block|{
name|last
operator|=
name|sort_next
operator|++
expr_stmt|;
block|}
block|}
comment|/* Shift elements to the left to fill holes left by removing duplicates */
if|if
condition|(
name|dups_found
condition|)
block|{
name|apr_table_entry_t
modifier|*
name|src
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|dst
init|=
operator|(
name|apr_table_entry_t
operator|*
operator|)
name|t
operator|->
name|a
operator|.
name|elts
decl_stmt|;
name|apr_table_entry_t
modifier|*
name|last_elt
init|=
name|src
operator|+
name|t
operator|->
name|a
operator|.
name|nelts
decl_stmt|;
do|do
block|{
if|if
condition|(
name|src
operator|->
name|key
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|src
operator|<
name|last_elt
condition|)
do|;
name|t
operator|->
name|a
operator|.
name|nelts
operator|-=
call|(
name|int
call|)
argument_list|(
name|last_elt
operator|-
name|dst
argument_list|)
expr_stmt|;
block|}
name|table_reindex
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|apr_table_cat
parameter_list|(
name|apr_table_t
modifier|*
name|t
parameter_list|,
specifier|const
name|apr_table_t
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|int
name|n
init|=
name|t
operator|->
name|a
operator|.
name|nelts
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
name|apr_array_cat
argument_list|(
operator|&
name|t
operator|->
name|a
argument_list|,
operator|&
name|s
operator|->
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|t
operator|->
name|index_first
argument_list|,
name|s
operator|->
name|index_first
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TABLE_HASH_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
operator|->
name|index_last
argument_list|,
name|s
operator|->
name|index_last
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TABLE_HASH_SIZE
argument_list|)
expr_stmt|;
name|t
operator|->
name|index_initialized
operator|=
name|s
operator|->
name|index_initialized
expr_stmt|;
return|return;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|TABLE_HASH_SIZE
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|s
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_last
index|[
name|idx
index|]
operator|=
name|s
operator|->
name|index_last
index|[
name|idx
index|]
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|TABLE_INDEX_IS_INITIALIZED
argument_list|(
name|t
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|t
operator|->
name|index_first
index|[
name|idx
index|]
operator|=
name|s
operator|->
name|index_first
index|[
name|idx
index|]
operator|+
name|n
expr_stmt|;
block|}
block|}
block|}
name|t
operator|->
name|index_initialized
operator||=
name|s
operator|->
name|index_initialized
expr_stmt|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_table_overlap
argument_list|(
argument|apr_table_t *a
argument_list|,
argument|const apr_table_t *b
argument_list|,
argument|unsigned flags
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|a
operator|.
name|nelts
operator|+
name|b
operator|->
name|a
operator|.
name|nelts
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* Since the keys and values are not copied, it's required that      * b->a.pool has a lifetime at least as long as a->a.pool. */
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|b
operator|->
name|a
operator|.
name|pool
argument_list|,
name|a
operator|->
name|a
operator|.
name|pool
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_table_overlap: b's pool is not an ancestor of a's\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|apr_table_cat
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|apr_table_compress
argument_list|(
name|a
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

