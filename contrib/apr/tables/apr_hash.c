begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_POOL_DEBUG
operator|&&
name|APR_HAVE_STDIO_H
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The internal form of a hash table.  *  * The table is an array indexed by the hash of the key; collisions  * are resolved by hanging a linked list of hash entries off each  * element of the array. Although this is a really simple design it  * isn't too bad given that pools have a low allocation overhead.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|apr_hash_entry_t
name|apr_hash_entry_t
typedef|;
end_typedef

begin_struct
struct|struct
name|apr_hash_entry_t
block|{
name|apr_hash_entry_t
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
specifier|const
name|void
modifier|*
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data structure for iterating through a hash table.  *  * We keep a pointer to the next hash entry here to allow the current  * hash entry to be freed or otherwise mangled between calls to  * apr_hash_next().  */
end_comment

begin_struct
struct|struct
name|apr_hash_index_t
block|{
name|apr_hash_t
modifier|*
name|ht
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The size of the array is always a power of two. We use the maximum  * index rather than the size so that we can use bitwise-AND for  * modular arithmetic.  * The count of hash entries may be greater depending on the chosen  * collision rate.  */
end_comment

begin_struct
struct|struct
name|apr_hash_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_hash_entry_t
modifier|*
modifier|*
name|array
decl_stmt|;
name|apr_hash_index_t
name|iterator
decl_stmt|;
comment|/* For apr_hash_first(NULL, ...) */
name|unsigned
name|int
name|count
decl_stmt|,
name|max
decl_stmt|,
name|seed
decl_stmt|;
name|apr_hashfunc_t
name|hash_func
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|free
decl_stmt|;
comment|/* List of recycled entries */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INITIAL_MAX
value|15
end_define

begin_comment
comment|/* tunable == 2^n - 1 */
end_comment

begin_comment
comment|/*  * Hash creation functions.  */
end_comment

begin_function
specifier|static
name|apr_hash_entry_t
modifier|*
modifier|*
name|alloc_array
parameter_list|(
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|)
block|{
return|return
name|apr_pcalloc
argument_list|(
name|ht
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ht
operator|->
name|array
argument_list|)
operator|*
operator|(
name|max
operator|+
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_make
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_t
modifier|*
name|ht
decl_stmt|;
name|apr_time_t
name|now
init|=
name|apr_time_now
argument_list|()
decl_stmt|;
name|ht
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_hash_t
argument_list|)
argument_list|)
expr_stmt|;
name|ht
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ht
operator|->
name|free
operator|=
name|NULL
expr_stmt|;
name|ht
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|max
operator|=
name|INITIAL_MAX
expr_stmt|;
name|ht
operator|->
name|seed
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|now
operator|>>
literal|32
operator|)
operator|^
name|now
operator|^
operator|(
name|apr_uintptr_t
operator|)
name|pool
operator|^
operator|(
name|apr_uintptr_t
operator|)
name|ht
operator|^
operator|(
name|apr_uintptr_t
operator|)
operator|&
name|now
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ht
operator|->
name|array
operator|=
name|alloc_array
argument_list|(
name|ht
argument_list|,
name|ht
operator|->
name|max
argument_list|)
expr_stmt|;
name|ht
operator|->
name|hash_func
operator|=
name|NULL
expr_stmt|;
return|return
name|ht
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_make_custom
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_hashfunc_t hash_func
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_t
modifier|*
name|ht
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|ht
operator|->
name|hash_func
operator|=
name|hash_func
expr_stmt|;
return|return
name|ht
return|;
block|}
end_block

begin_comment
comment|/*  * Hash iteration functions.  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_index_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_next
argument_list|(
argument|apr_hash_index_t *hi
argument_list|)
end_macro

begin_block
block|{
name|hi
operator|->
name|this
operator|=
name|hi
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|!
name|hi
operator|->
name|this
condition|)
block|{
if|if
condition|(
name|hi
operator|->
name|index
operator|>
name|hi
operator|->
name|ht
operator|->
name|max
condition|)
return|return
name|NULL
return|;
name|hi
operator|->
name|this
operator|=
name|hi
operator|->
name|ht
operator|->
name|array
index|[
name|hi
operator|->
name|index
operator|++
index|]
expr_stmt|;
block|}
name|hi
operator|->
name|next
operator|=
name|hi
operator|->
name|this
operator|->
name|next
expr_stmt|;
return|return
name|hi
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_index_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_first
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|apr_hash_t *ht
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|hi
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hi
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hi
operator|=
operator|&
name|ht
operator|->
name|iterator
expr_stmt|;
name|hi
operator|->
name|ht
operator|=
name|ht
expr_stmt|;
name|hi
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|this
operator|=
name|NULL
expr_stmt|;
name|hi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hash_this
argument_list|(
argument|apr_hash_index_t *hi
argument_list|,
argument|const void **key
argument_list|,
argument|apr_ssize_t *klen
argument_list|,
argument|void **val
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|key
condition|)
operator|*
name|key
operator|=
name|hi
operator|->
name|this
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|klen
condition|)
operator|*
name|klen
operator|=
name|hi
operator|->
name|this
operator|->
name|klen
expr_stmt|;
if|if
condition|(
name|val
condition|)
operator|*
name|val
operator|=
operator|(
name|void
operator|*
operator|)
name|hi
operator|->
name|this
operator|->
name|val
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Expanding a hash table  */
end_comment

begin_function
specifier|static
name|void
name|expand_array
parameter_list|(
name|apr_hash_t
modifier|*
name|ht
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_entry_t
modifier|*
modifier|*
name|new_array
decl_stmt|;
name|unsigned
name|int
name|new_max
decl_stmt|;
name|new_max
operator|=
name|ht
operator|->
name|max
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|new_array
operator|=
name|alloc_array
argument_list|(
name|ht
argument_list|,
name|new_max
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|NULL
argument_list|,
name|ht
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|unsigned
name|int
name|i
init|=
name|hi
operator|->
name|this
operator|->
name|hash
operator|&
name|new_max
decl_stmt|;
name|hi
operator|->
name|this
operator|->
name|next
operator|=
name|new_array
index|[
name|i
index|]
expr_stmt|;
name|new_array
index|[
name|i
index|]
operator|=
name|hi
operator|->
name|this
expr_stmt|;
block|}
name|ht
operator|->
name|array
operator|=
name|new_array
expr_stmt|;
name|ht
operator|->
name|max
operator|=
name|new_max
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|hashfunc_default
parameter_list|(
specifier|const
name|char
modifier|*
name|char_key
parameter_list|,
name|apr_ssize_t
modifier|*
name|klen
parameter_list|,
name|unsigned
name|int
name|hash
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|key
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|char_key
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|apr_ssize_t
name|i
decl_stmt|;
comment|/*      * This is the popular `times 33' hash algorithm which is used by      * perl and also appears in Berkeley DB. This is one of the best      * known hash functions for strings because it is both computed      * very fast and distributes very well.      *      * The originator may be Dan Bernstein but the code in Berkeley DB      * cites Chris Torek as the source. The best citation I have found      * is "Chris Torek, Hash function for text in C, Usenet message      *<27038@mimsy.umd.edu> in comp.lang.c , October, 1990." in Rich      * Salz's USENIX 1992 paper about INN which can be found at      *<http://citeseer.nj.nec.com/salz92internetnews.html>.      *      * The magic of number 33, i.e. why it works better than many other      * constants, prime or not, has never been adequately explained by      * anyone. So I try an explanation: if one experimentally tests all      * multipliers between 1 and 256 (as I did while writing a low-level      * data structure library some time ago) one detects that even      * numbers are not useable at all. The remaining 128 odd numbers      * (except for the number 1) work more or less all equally well.      * They all distribute in an acceptable way and this way fill a hash      * table with an average percent of approx. 86%.      *      * If one compares the chi^2 values of the variants (see      * Bob Jenkins ``Hashing Frequently Asked Questions'' at      * http://burtleburtle.net/bob/hash/hashfaq.html for a description      * of chi^2), the number 33 not even has the best value. But the      * number 33 and a few other equally good numbers like 17, 31, 63,      * 127 and 129 have nevertheless a great advantage to the remaining      * numbers in the large set of possible multipliers: their multiply      * operation can be replaced by a faster operation based on just one      * shift plus either a single addition or subtraction operation. And      * because a hash function has to both distribute good _and_ has to      * be very fast to compute, those few numbers should be preferred.      *      *                  -- Ralf S. Engelschall<rse@engelschall.com>      */
if|if
condition|(
operator|*
name|klen
operator|==
name|APR_HASH_KEY_STRING
condition|)
block|{
for|for
control|(
name|p
operator|=
name|key
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|33
operator|+
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|klen
operator|=
name|p
operator|-
name|key
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|key
operator|,
name|i
operator|=
operator|*
name|klen
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|p
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|33
operator|+
operator|*
name|p
expr_stmt|;
block|}
block|}
return|return
name|hash
return|;
block|}
end_function

begin_macro
name|APR_DECLARE_NONSTD
argument_list|(
argument|unsigned int
argument_list|)
end_macro

begin_macro
name|apr_hashfunc_default
argument_list|(
argument|const char *char_key
argument_list|,
argument|apr_ssize_t *klen
argument_list|)
end_macro

begin_block
block|{
return|return
name|hashfunc_default
argument_list|(
name|char_key
argument_list|,
name|klen
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is where we keep the details of the hash function and control  * the maximum collision rate.  *  * If val is non-NULL it creates and initializes a new hash entry if  * there isn't already one there; it returns an updatable pointer so  * that hash entries can be removed.  */
end_comment

begin_function
specifier|static
name|apr_hash_entry_t
modifier|*
modifier|*
name|find_entry
parameter_list|(
name|apr_hash_t
modifier|*
name|ht
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|)
block|{
name|apr_hash_entry_t
modifier|*
modifier|*
name|hep
decl_stmt|,
modifier|*
name|he
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|ht
operator|->
name|hash_func
condition|)
name|hash
operator|=
name|ht
operator|->
name|hash_func
argument_list|(
name|key
argument_list|,
operator|&
name|klen
argument_list|)
expr_stmt|;
else|else
name|hash
operator|=
name|hashfunc_default
argument_list|(
name|key
argument_list|,
operator|&
name|klen
argument_list|,
name|ht
operator|->
name|seed
argument_list|)
expr_stmt|;
comment|/* scan linked list */
for|for
control|(
name|hep
operator|=
operator|&
name|ht
operator|->
name|array
index|[
name|hash
operator|&
name|ht
operator|->
name|max
index|]
operator|,
name|he
operator|=
operator|*
name|hep
init|;
name|he
condition|;
name|hep
operator|=
operator|&
name|he
operator|->
name|next
operator|,
name|he
operator|=
operator|*
name|hep
control|)
block|{
if|if
condition|(
name|he
operator|->
name|hash
operator|==
name|hash
operator|&&
name|he
operator|->
name|klen
operator|==
name|klen
operator|&&
name|memcmp
argument_list|(
name|he
operator|->
name|key
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|he
operator|||
operator|!
name|val
condition|)
return|return
name|hep
return|;
comment|/* add a new entry for non-NULL values */
if|if
condition|(
operator|(
name|he
operator|=
name|ht
operator|->
name|free
operator|)
operator|!=
name|NULL
condition|)
name|ht
operator|->
name|free
operator|=
name|he
operator|->
name|next
expr_stmt|;
else|else
name|he
operator|=
name|apr_palloc
argument_list|(
name|ht
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|he
argument_list|)
argument_list|)
expr_stmt|;
name|he
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|he
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|he
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|he
operator|->
name|klen
operator|=
name|klen
expr_stmt|;
name|he
operator|->
name|val
operator|=
name|val
expr_stmt|;
operator|*
name|hep
operator|=
name|he
expr_stmt|;
name|ht
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|hep
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_copy
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const apr_hash_t *orig
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_t
modifier|*
name|ht
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|new_vals
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ht
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_hash_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ht
operator|->
name|array
argument_list|)
operator|*
operator|(
name|orig
operator|->
name|max
operator|+
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|apr_hash_entry_t
argument_list|)
operator|*
name|orig
operator|->
name|count
argument_list|)
expr_stmt|;
name|ht
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ht
operator|->
name|free
operator|=
name|NULL
expr_stmt|;
name|ht
operator|->
name|count
operator|=
name|orig
operator|->
name|count
expr_stmt|;
name|ht
operator|->
name|max
operator|=
name|orig
operator|->
name|max
expr_stmt|;
name|ht
operator|->
name|seed
operator|=
name|orig
operator|->
name|seed
expr_stmt|;
name|ht
operator|->
name|hash_func
operator|=
name|orig
operator|->
name|hash_func
expr_stmt|;
name|ht
operator|->
name|array
operator|=
operator|(
name|apr_hash_entry_t
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ht
operator|+
sizeof|sizeof
argument_list|(
name|apr_hash_t
argument_list|)
operator|)
expr_stmt|;
name|new_vals
operator|=
operator|(
name|apr_hash_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ht
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|apr_hash_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ht
operator|->
name|array
argument_list|)
operator|*
operator|(
name|orig
operator|->
name|max
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ht
operator|->
name|max
condition|;
name|i
operator|++
control|)
block|{
name|apr_hash_entry_t
modifier|*
modifier|*
name|new_entry
init|=
operator|&
operator|(
name|ht
operator|->
name|array
index|[
name|i
index|]
operator|)
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|orig_entry
init|=
name|orig
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|orig_entry
condition|)
block|{
operator|*
name|new_entry
operator|=
operator|&
name|new_vals
index|[
name|j
operator|++
index|]
expr_stmt|;
operator|(
operator|*
name|new_entry
operator|)
operator|->
name|hash
operator|=
name|orig_entry
operator|->
name|hash
expr_stmt|;
operator|(
operator|*
name|new_entry
operator|)
operator|->
name|key
operator|=
name|orig_entry
operator|->
name|key
expr_stmt|;
operator|(
operator|*
name|new_entry
operator|)
operator|->
name|klen
operator|=
name|orig_entry
operator|->
name|klen
expr_stmt|;
operator|(
operator|*
name|new_entry
operator|)
operator|->
name|val
operator|=
name|orig_entry
operator|->
name|val
expr_stmt|;
name|new_entry
operator|=
operator|&
operator|(
operator|(
operator|*
name|new_entry
operator|)
operator|->
name|next
operator|)
expr_stmt|;
name|orig_entry
operator|=
name|orig_entry
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|new_entry
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ht
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_hash_get
argument_list|(
argument|apr_hash_t *ht
argument_list|,
argument|const void *key
argument_list|,
argument|apr_ssize_t klen
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_entry_t
modifier|*
name|he
decl_stmt|;
name|he
operator|=
operator|*
name|find_entry
argument_list|(
name|ht
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|he
operator|->
name|val
return|;
else|else
return|return
name|NULL
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hash_set
argument_list|(
argument|apr_hash_t *ht
argument_list|,
argument|const void *key
argument_list|,
argument|apr_ssize_t klen
argument_list|,
argument|const void *val
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_entry_t
modifier|*
modifier|*
name|hep
decl_stmt|;
name|hep
operator|=
name|find_entry
argument_list|(
name|ht
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hep
condition|)
block|{
if|if
condition|(
operator|!
name|val
condition|)
block|{
comment|/* delete entry */
name|apr_hash_entry_t
modifier|*
name|old
init|=
operator|*
name|hep
decl_stmt|;
operator|*
name|hep
operator|=
operator|(
operator|*
name|hep
operator|)
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|=
name|ht
operator|->
name|free
expr_stmt|;
name|ht
operator|->
name|free
operator|=
name|old
expr_stmt|;
operator|--
name|ht
operator|->
name|count
expr_stmt|;
block|}
else|else
block|{
comment|/* replace entry */
operator|(
operator|*
name|hep
operator|)
operator|->
name|val
operator|=
name|val
expr_stmt|;
comment|/* check that the collision rate isn't too high */
if|if
condition|(
name|ht
operator|->
name|count
operator|>
name|ht
operator|->
name|max
condition|)
block|{
name|expand_array
argument_list|(
name|ht
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* else key not present and val==NULL */
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|unsigned int
argument_list|)
end_macro

begin_macro
name|apr_hash_count
argument_list|(
argument|apr_hash_t *ht
argument_list|)
end_macro

begin_block
block|{
return|return
name|ht
operator|->
name|count
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_hash_clear
argument_list|(
argument|apr_hash_t *ht
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|NULL
argument_list|,
name|ht
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
name|apr_hash_set
argument_list|(
name|ht
argument_list|,
name|hi
operator|->
name|this
operator|->
name|key
argument_list|,
name|hi
operator|->
name|this
operator|->
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_t*
argument_list|)
end_macro

begin_macro
name|apr_hash_overlay
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_hash_t *overlay
argument_list|,
argument|const apr_hash_t *base
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_hash_merge
argument_list|(
name|p
argument_list|,
name|overlay
argument_list|,
name|base
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_hash_t *
argument_list|)
end_macro

begin_macro
name|apr_hash_merge
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const apr_hash_t *overlay
argument_list|,
argument|const apr_hash_t *base
argument_list|,
argument|void * (*merger)(apr_pool_t *p,                                                      const void *key,                                                      apr_ssize_t klen,                                                      const void *h1_val,                                                      const void *h2_val,                                                      const void *data)
argument_list|,
argument|const void *data
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_t
modifier|*
name|res
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|new_vals
init|=
name|NULL
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|iter
decl_stmt|;
name|apr_hash_entry_t
modifier|*
name|ent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|hash
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* we don't copy keys and values, so it's necessary that      * overlay->a.pool and base->a.pool have a life span at least      * as long as p      */
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|overlay
operator|->
name|pool
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_hash_merge: overlay's pool is not an ancestor of p\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apr_pool_is_ancestor
argument_list|(
name|base
operator|->
name|pool
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"apr_hash_merge: base's pool is not an ancestor of p\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|res
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_hash_t
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|res
operator|->
name|free
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|hash_func
operator|=
name|base
operator|->
name|hash_func
expr_stmt|;
name|res
operator|->
name|count
operator|=
name|base
operator|->
name|count
expr_stmt|;
name|res
operator|->
name|max
operator|=
operator|(
name|overlay
operator|->
name|max
operator|>
name|base
operator|->
name|max
operator|)
condition|?
name|overlay
operator|->
name|max
else|:
name|base
operator|->
name|max
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|count
operator|+
name|overlay
operator|->
name|count
operator|>
name|res
operator|->
name|max
condition|)
block|{
name|res
operator|->
name|max
operator|=
name|res
operator|->
name|max
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
name|res
operator|->
name|seed
operator|=
name|base
operator|->
name|seed
expr_stmt|;
name|res
operator|->
name|array
operator|=
name|alloc_array
argument_list|(
name|res
argument_list|,
name|res
operator|->
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|count
operator|+
name|overlay
operator|->
name|count
condition|)
block|{
name|new_vals
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_hash_entry_t
argument_list|)
operator|*
operator|(
name|base
operator|->
name|count
operator|+
name|overlay
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|base
operator|->
name|max
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|iter
operator|=
name|base
operator|->
name|array
index|[
name|k
index|]
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
name|i
operator|=
name|iter
operator|->
name|hash
operator|&
name|res
operator|->
name|max
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|klen
operator|=
name|iter
operator|->
name|klen
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|key
operator|=
name|iter
operator|->
name|key
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|val
operator|=
name|iter
operator|->
name|val
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|hash
operator|=
name|iter
operator|->
name|hash
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|next
operator|=
name|res
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|array
index|[
name|i
index|]
operator|=
operator|&
name|new_vals
index|[
name|j
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|overlay
operator|->
name|max
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|iter
operator|=
name|overlay
operator|->
name|array
index|[
name|k
index|]
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
if|if
condition|(
name|res
operator|->
name|hash_func
condition|)
name|hash
operator|=
name|res
operator|->
name|hash_func
argument_list|(
name|iter
operator|->
name|key
argument_list|,
operator|&
name|iter
operator|->
name|klen
argument_list|)
expr_stmt|;
else|else
name|hash
operator|=
name|hashfunc_default
argument_list|(
name|iter
operator|->
name|key
argument_list|,
operator|&
name|iter
operator|->
name|klen
argument_list|,
name|res
operator|->
name|seed
argument_list|)
expr_stmt|;
name|i
operator|=
name|hash
operator|&
name|res
operator|->
name|max
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|res
operator|->
name|array
index|[
name|i
index|]
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|ent
operator|->
name|klen
operator|==
name|iter
operator|->
name|klen
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|ent
operator|->
name|key
argument_list|,
name|iter
operator|->
name|key
argument_list|,
name|iter
operator|->
name|klen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|merger
condition|)
block|{
name|ent
operator|->
name|val
operator|=
call|(
modifier|*
name|merger
call|)
argument_list|(
name|p
argument_list|,
name|iter
operator|->
name|key
argument_list|,
name|iter
operator|->
name|klen
argument_list|,
name|iter
operator|->
name|val
argument_list|,
name|ent
operator|->
name|val
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|val
operator|=
name|iter
operator|->
name|val
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ent
condition|)
block|{
name|new_vals
index|[
name|j
index|]
operator|.
name|klen
operator|=
name|iter
operator|->
name|klen
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|key
operator|=
name|iter
operator|->
name|key
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|val
operator|=
name|iter
operator|->
name|val
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|new_vals
index|[
name|j
index|]
operator|.
name|next
operator|=
name|res
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|array
index|[
name|i
index|]
operator|=
operator|&
name|new_vals
index|[
name|j
index|]
expr_stmt|;
name|res
operator|->
name|count
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/* This is basically the following...  * for every element in hash table {  *    comp elemeny.key, element.value  * }  *  * Like with apr_table_do, the comp callback is called for each and every  * element of the hash table.  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_hash_do
argument_list|(
argument|apr_hash_do_callback_fn_t *comp
argument_list|,
argument|void *rec
argument_list|,
argument|const apr_hash_t *ht
argument_list|)
end_macro

begin_block
block|{
name|apr_hash_index_t
name|hix
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|dorv
init|=
literal|1
decl_stmt|;
name|hix
operator|.
name|ht
operator|=
operator|(
name|apr_hash_t
operator|*
operator|)
name|ht
expr_stmt|;
name|hix
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|hix
operator|.
name|this
operator|=
name|NULL
expr_stmt|;
name|hix
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|hi
operator|=
name|apr_hash_next
argument_list|(
operator|&
name|hix
argument_list|)
operator|)
condition|)
block|{
comment|/* Scan the entire table */
do|do
block|{
name|rv
operator|=
call|(
modifier|*
name|comp
call|)
argument_list|(
name|rec
argument_list|,
name|hi
operator|->
name|this
operator|->
name|key
argument_list|,
name|hi
operator|->
name|this
operator|->
name|klen
argument_list|,
name|hi
operator|->
name|this
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|&&
operator|(
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|dorv
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|dorv
return|;
block|}
end_block

begin_macro
name|APR_POOL_IMPLEMENT_ACCESSOR
argument_list|(
argument|hash
argument_list|)
end_macro

end_unit

