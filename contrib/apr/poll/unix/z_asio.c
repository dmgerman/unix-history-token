begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  *  ******************************************************************************  *  * This implementation is based on a design by John Brooks (IBM Pok) which uses  * the z/OS sockets async i/o facility.  When a  * socket is added to the pollset, an async poll is issued for that individual  * socket.  It specifies that the kernel should send an IPC message when the  * socket becomes ready.  The IPC messages are sent to a single message queue  * that is part of the pollset.  apr_pollset_poll waits on the arrival of IPC  * messages or the specified timeout.  *  * Since z/OS does not support async i/o for pipes or files at present, this  * implementation falls back to using ordinary poll() when  * APR_POLLSET_THREADSAFE is unset.  *  * Greg Ames  * April 2012  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_include
include|#
directive|include
file|"apr_poll.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_inherit.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_networkio.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_poll_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AIO_MSGQ
end_ifdef

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_comment
comment|/* msgget etc   */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* timestruct   */
end_comment

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_comment
comment|/* pollfd       */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/* MAX_INT      */
end_comment

begin_struct
struct|struct
name|apr_pollset_private_t
block|{
name|int
name|msg_q
decl_stmt|;
comment|/* IPC message queue. The z/OS kernel sends messages                                          * to this queue when our async polls on individual                                          * file descriptors complete                                          */
name|apr_pollfd_t
modifier|*
name|result_set
decl_stmt|;
name|apr_uint32_t
name|size
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
comment|/* A thread mutex to protect operations on the rings and the hash */
name|apr_thread_mutex_t
modifier|*
name|ring_lock
decl_stmt|;
endif|#
directive|endif
comment|/* A hash of all active elements used for O(1) _remove operations */
name|apr_hash_t
modifier|*
name|elems
decl_stmt|;
name|APR_RING_HEAD
argument_list|(
argument|ready_ring_t
argument_list|,
argument|asio_elem_t
argument_list|)
name|ready_ring
expr_stmt|;
name|APR_RING_HEAD
argument_list|(
argument|prior_ready_ring_t
argument_list|,
argument|asio_elem_t
argument_list|)
name|prior_ready_ring
expr_stmt|;
name|APR_RING_HEAD
argument_list|(
argument|free_ring_t
argument_list|,
argument|asio_elem_t
argument_list|)
name|free_ring
expr_stmt|;
comment|/* for pipes etc with no asio */
name|struct
name|pollfd
modifier|*
name|pollset
decl_stmt|;
name|apr_pollfd_t
modifier|*
name|query_set
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|ASIO_INIT
init|=
literal|0
block|,
name|ASIO_REMOVED
block|,
name|ASIO_COMPLETE
block|}
name|asio_state_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|asio_elem_t
name|asio_elem_t
typedef|;
end_typedef

begin_struct
struct|struct
name|asio_msgbuf_t
block|{
name|long
name|msg_type
decl_stmt|;
comment|/* must be> 0 */
name|asio_elem_t
modifier|*
name|msg_elem
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|asio_elem_t
block|{
name|APR_RING_ENTRY
argument_list|(
argument|asio_elem_t
argument_list|)
name|link
expr_stmt|;
name|apr_pollfd_t
name|pfd
decl_stmt|;
name|struct
name|pollfd
name|os_pfd
decl_stmt|;
name|struct
name|aiocb
name|a
decl_stmt|;
name|asio_state_e
name|state
decl_stmt|;
name|struct
name|asio_msgbuf_t
name|msg
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_comment
comment|/* DEBUG settings: 0 - no debug messages at all,  *                 1 - should not occur messages,  *                 2 - apr_pollset_* entry and exit messages,  *                 3 - state changes, memory usage,  *                 4 - z/OS, APR, and internal calls,  *                 5 - everything else except the timer pop path,  *                 6 - everything, including the Event 1 sec timer pop path  *  *  each DEBUG level includes all messages produced by lower numbered levels  */
end_comment

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* getpid       */
end_comment

begin_define
define|#
directive|define
name|DBG_BUFF
value|char dbg_msg_buff[256];
end_define

begin_define
define|#
directive|define
name|DBG_TEST
parameter_list|(
name|lvl
parameter_list|)
value|if (lvl<= DEBUG) {
end_define

begin_define
define|#
directive|define
name|DBG_CORE
parameter_list|(
name|msg
parameter_list|)
value|sprintf(dbg_msg_buff, "% 8d " __FUNCTION__ \                                         " "  msg, getpid()),                   \                                     fprintf(stderr, "%s", dbg_msg_buff);
end_define

begin_define
define|#
directive|define
name|DBG_CORE1
parameter_list|(
name|msg
parameter_list|,
name|var1
parameter_list|)
value|sprintf(dbg_msg_buff, "% 8d " __FUNCTION__ \                                         " " msg, getpid(), var1),              \                                     fprintf(stderr, "%s", dbg_msg_buff);
end_define

begin_define
define|#
directive|define
name|DBG_CORE2
parameter_list|(
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|)
value|sprintf(dbg_msg_buff, "% 8d " __FUNCTION__ \                                         " " msg, getpid(), var1, var2),        \                                     fprintf(stderr, "%s", dbg_msg_buff);
end_define

begin_define
define|#
directive|define
name|DBG_CORE3
parameter_list|(
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|)
define|\
value|sprintf(dbg_msg_buff, "% 8d " __FUNCTION__ \                                         " " msg, getpid(), var1, var2, var3),  \                                     fprintf(stderr, "%s", dbg_msg_buff);
end_define

begin_define
define|#
directive|define
name|DBG_CORE4
parameter_list|(
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|,
name|var4
parameter_list|)
define|\
value|sprintf(dbg_msg_buff, "% 8d " __FUNCTION__ \                                         " " msg, getpid(), var1, var2, var3, var4),\                                     fprintf(stderr, "%s", dbg_msg_buff);
end_define

begin_define
define|#
directive|define
name|DBG_END
value|}
end_define

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|)
value|DBG_TEST(lvl)   \                         DBG_CORE(msg)   \                         DBG_END
end_define

begin_define
define|#
directive|define
name|DBG1
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|)
value|DBG_TEST(lvl)           \                                 DBG_CORE1(msg, var1)    \                                 DBG_END
end_define

begin_define
define|#
directive|define
name|DBG2
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|)
value|DBG_TEST(lvl)               \                                         DBG_CORE2(msg, var1, var2)  \                                         DBG_END
end_define

begin_define
define|#
directive|define
name|DBG3
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|)
define|\
value|DBG_TEST(lvl)                           \                         DBG_CORE3(msg, var1, var2, var3)        \                         DBG_END
end_define

begin_define
define|#
directive|define
name|DBG4
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|,
name|var4
parameter_list|)
define|\
value|DBG_TEST(lvl)                           \                         DBG_CORE4(msg, var1, var2, var3, var4)  \                         DBG_END
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG is 0 */
end_comment

begin_define
define|#
directive|define
name|DBG_BUFF
end_define

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DBG1
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DBG2
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DBG3
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DBG4
parameter_list|(
name|lvl
parameter_list|,
name|msg
parameter_list|,
name|var1
parameter_list|,
name|var2
parameter_list|,
name|var3
parameter_list|,
name|var4
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|int
name|asyncio
parameter_list|(
name|struct
name|aiocb
modifier|*
name|a
parameter_list|)
block|{
name|DBG_BUFF
name|int
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|_LP64
define|#
directive|define
name|AIO
value|BPX4AIO
else|#
directive|else
define|#
directive|define
name|AIO
value|BPX1AIO
endif|#
directive|endif
name|AIO
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aiocb
argument_list|)
argument_list|,
name|a
argument_list|,
operator|&
name|rv
argument_list|,
operator|&
name|errno
argument_list|,
name|__err2ad
argument_list|()
argument_list|)
expr_stmt|;
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"BPX4AIO aiocb %p rv %d\n"
argument_list|,
name|a
argument_list|,
name|rv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"errno %d errnojr %08x\n"
argument_list|,
name|errno
argument_list|,
operator|*
name|__err2ad
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int16_t
name|get_event
parameter_list|(
name|apr_int16_t
name|event
parameter_list|)
block|{
name|DBG_BUFF
name|apr_int16_t
name|rv
init|=
literal|0
decl_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLIN
condition|)
name|rv
operator||=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLPRI
condition|)
name|rv
operator||=
name|POLLPRI
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLOUT
condition|)
name|rv
operator||=
name|POLLOUT
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLERR
condition|)
name|rv
operator||=
name|POLLERR
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLHUP
condition|)
name|rv
operator||=
name|POLLHUP
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|APR_POLLNVAL
condition|)
name|rv
operator||=
name|POLLNVAL
expr_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"exiting\n"
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_int16_t
name|get_revent
parameter_list|(
name|apr_int16_t
name|event
parameter_list|)
block|{
name|DBG_BUFF
name|apr_int16_t
name|rv
init|=
literal|0
decl_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLIN
condition|)
name|rv
operator||=
name|APR_POLLIN
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLPRI
condition|)
name|rv
operator||=
name|APR_POLLPRI
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLOUT
condition|)
name|rv
operator||=
name|APR_POLLOUT
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLERR
condition|)
name|rv
operator||=
name|APR_POLLERR
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLHUP
condition|)
name|rv
operator||=
name|APR_POLLHUP
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|POLLNVAL
condition|)
name|rv
operator||=
name|APR_POLLNVAL
expr_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"exiting\n"
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|asio_pollset_cleanup
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|)
block|{
name|DBG_BUFF
name|int
name|rv
decl_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|msgctl
argument_list|(
name|pollset
operator|->
name|p
operator|->
name|msg_q
argument_list|,
name|IPC_RMID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DBG1
argument_list|(
literal|4
argument_list|,
literal|"exiting, msgctl(IPC_RMID) returned %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|asio_pollset_create
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|,
name|apr_uint32_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|)
block|{
name|DBG_BUFF
name|apr_status_t
name|rv
decl_stmt|;
name|apr_pollset_private_t
modifier|*
name|priv
decl_stmt|;
name|DBG1
argument_list|(
literal|2
argument_list|,
literal|"entered, flags: %x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|priv
operator|=
name|pollset
operator|->
name|p
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ring_lock
operator|)
argument_list|,
name|APR_THREAD_MUTEX_DEFAULT
argument_list|,
name|p
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|DBG1
argument_list|(
literal|1
argument_list|,
literal|"apr_thread_mutex_create returned %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|pollset
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|rv
return|;
block|}
name|rv
operator|=
name|msgget
argument_list|(
name|IPC_PRIVATE
argument_list|,
name|S_IWUSR
operator|+
name|S_IRUSR
argument_list|)
expr_stmt|;
comment|/* user r/w perms */
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|perror
argument_list|(
name|__FUNCTION__
literal|" msgget returned< 0 "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pollset
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|rv
return|;
block|}
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"pollset %p msgget was OK, rv=%d\n"
argument_list|,
name|pollset
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|msg_q
operator|=
name|rv
expr_stmt|;
name|priv
operator|->
name|elems
operator|=
name|apr_hash_make
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
name|priv
operator|->
name|free_ring
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
name|priv
operator|->
name|prior_ready_ring
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* APR doesn't have threads but caller wants a threadsafe pollset */
name|pollset
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* APR_POLLSET_THREADSAFE not set, i.e. no async i/o,                * init fields only needed in old style pollset                */
name|priv
operator|->
name|pollset
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|query_set
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|apr_pollfd_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|priv
operator|->
name|pollset
operator|)
operator|||
operator|(
operator|!
name|priv
operator|->
name|query_set
operator|)
condition|)
block|{
name|pollset
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
block|}
name|pollset
operator|->
name|nelts
operator|=
literal|0
expr_stmt|;
name|pollset
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|pollset
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|priv
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|priv
operator|->
name|result_set
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|apr_pollfd_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|result_set
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
condition|)
block|{
name|msgctl
argument_list|(
name|priv
operator|->
name|msg_q
argument_list|,
name|IPC_RMID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|pollset
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|DBG2
argument_list|(
literal|2
argument_list|,
literal|"exiting, pollset: %p, type: %s\n"
argument_list|,
name|pollset
argument_list|,
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
condition|?
literal|"async"
else|:
literal|"POSIX"
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* end of asio_pollset_create */
end_comment

begin_function
specifier|static
name|apr_status_t
name|posix_add
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
name|descriptor
parameter_list|)
block|{
name|DBG_BUFF
name|int
name|fd
decl_stmt|;
name|apr_pool_t
modifier|*
name|p
init|=
name|pollset
operator|->
name|pool
decl_stmt|;
name|apr_pollset_private_t
modifier|*
name|priv
init|=
name|pollset
operator|->
name|p
decl_stmt|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pollset
operator|->
name|nelts
operator|==
name|priv
operator|->
name|size
condition|)
block|{
return|return
name|APR_ENOMEM
return|;
block|}
name|priv
operator|->
name|query_set
index|[
name|pollset
operator|->
name|nelts
index|]
operator|=
operator|*
name|descriptor
expr_stmt|;
if|if
condition|(
name|descriptor
operator|->
name|desc_type
operator|==
name|APR_POLL_SOCKET
condition|)
block|{
name|fd
operator|=
name|descriptor
operator|->
name|desc
operator|.
name|s
operator|->
name|socketdes
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|descriptor
operator|->
name|desc
operator|.
name|f
operator|->
name|filedes
expr_stmt|;
block|}
name|priv
operator|->
name|pollset
index|[
name|pollset
operator|->
name|nelts
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|priv
operator|->
name|pollset
index|[
name|pollset
operator|->
name|nelts
index|]
operator|.
name|events
operator|=
name|get_event
argument_list|(
name|descriptor
operator|->
name|reqevents
argument_list|)
expr_stmt|;
name|pollset
operator|->
name|nelts
operator|++
expr_stmt|;
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"exiting, fd %d added to pollset %p\n"
argument_list|,
name|fd
argument_list|,
name|pollset
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* end of posix_add */
end_comment

begin_function
specifier|static
name|apr_status_t
name|asio_pollset_add
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
name|descriptor
parameter_list|)
block|{
name|DBG_BUFF
name|asio_elem_t
modifier|*
name|elem
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_pollset_private_t
modifier|*
name|priv
init|=
name|pollset
operator|->
name|p
decl_stmt|;
name|pollset_lock_rings
argument_list|()
expr_stmt|;
name|DBG
argument_list|(
literal|2
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pollset
operator|->
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
condition|)
block|{
if|if
condition|(
operator|!
name|APR_RING_EMPTY
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|free_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|elem
operator|=
name|APR_RING_FIRST
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|free_ring
operator|)
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DBG1
argument_list|(
literal|3
argument_list|,
literal|"used recycled memory at %08p\n"
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|elem
operator|->
name|state
operator|=
name|ASIO_INIT
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_cflags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|elem
operator|=
operator|(
name|asio_elem_t
operator|*
operator|)
name|apr_pcalloc
argument_list|(
name|pollset
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|asio_elem_t
argument_list|)
argument_list|)
expr_stmt|;
name|DBG1
argument_list|(
literal|3
argument_list|,
literal|"alloced new memory at %08p\n"
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_notifytype
operator|=
name|AIO_MSGQ
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_msgev_qid
operator|=
name|priv
operator|->
name|msg_q
expr_stmt|;
name|DBG1
argument_list|(
literal|5
argument_list|,
literal|"aio_msgev_quid = %d \n"
argument_list|,
name|elem
operator|->
name|a
operator|.
name|aio_msgev_qid
argument_list|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_msgev_size
operator|=
sizeof|sizeof
argument_list|(
name|asio_elem_t
operator|*
argument_list|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_msgev_flag
operator|=
literal|0
expr_stmt|;
comment|/* wait if queue is full */
name|elem
operator|->
name|a
operator|.
name|aio_msgev_addr
operator|=
operator|&
operator|(
name|elem
operator|->
name|msg
operator|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_buf
operator|=
operator|&
operator|(
name|elem
operator|->
name|os_pfd
operator|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_nbytes
operator|=
literal|1
expr_stmt|;
comment|/* number of pfds to poll */
name|elem
operator|->
name|msg
operator|.
name|msg_type
operator|=
literal|1
expr_stmt|;
name|elem
operator|->
name|msg
operator|.
name|msg_elem
operator|=
name|elem
expr_stmt|;
block|}
comment|/* z/OS only supports async I/O for sockets for now */
name|elem
operator|->
name|os_pfd
operator|.
name|fd
operator|=
name|descriptor
operator|->
name|desc
operator|.
name|s
operator|->
name|socketdes
expr_stmt|;
name|APR_RING_ELEM_INIT
argument_list|(
name|elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_cmd
operator|=
name|AIO_SELPOLL
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_cflags
operator|&=
operator|~
name|AIO_OK2COMPIMD
expr_stmt|;
comment|/* not OK to complete inline*/
name|elem
operator|->
name|pfd
operator|=
operator|*
name|descriptor
expr_stmt|;
name|elem
operator|->
name|os_pfd
operator|.
name|events
operator|=
name|get_event
argument_list|(
name|descriptor
operator|->
name|reqevents
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|asyncio
argument_list|(
operator|&
name|elem
operator|->
name|a
argument_list|)
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
name|DBG3
argument_list|(
literal|4
argument_list|,
literal|"pollset %p asio failed fd %d, errno %p\n"
argument_list|,
name|pollset
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|perror
argument_list|(
name|__FUNCTION__
literal|" asio failure"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"good asio call, adding fd %d to pollset %p\n"
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|,
name|pollset
argument_list|)
expr_stmt|;
name|pollset
operator|->
name|nelts
operator|++
expr_stmt|;
name|apr_hash_set
argument_list|(
name|priv
operator|->
name|elems
argument_list|,
operator|&
operator|(
name|elem
operator|->
name|os_pfd
operator|.
name|fd
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* APR_POLLSET_THREADSAFE isn't set.  use POSIX poll in case          * pipes or files are used with this pollset          */
name|rv
operator|=
name|posix_add
argument_list|(
name|pollset
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
name|DBG1
argument_list|(
literal|2
argument_list|,
literal|"exiting, rv = %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|pollset_unlock_rings
argument_list|()
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* end of asio_pollset_add */
end_comment

begin_expr_stmt
specifier|static
name|posix_remove
argument_list|(
argument|apr_pollset_t *pollset
argument_list|,
argument|const apr_pollfd_t *descriptor
argument_list|)
block|{
name|DBG_BUFF
name|apr_uint32_t
name|i
block|;
name|apr_pollset_private_t
operator|*
name|priv
operator|=
name|pollset
operator|->
name|p
block|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pollset
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descriptor
operator|->
name|desc
operator|.
name|s
operator|==
name|priv
operator|->
name|query_set
index|[
name|i
index|]
operator|.
name|desc
operator|.
name|s
condition|)
block|{
comment|/* Found an instance of the fd: remove this and any other copies */
name|apr_uint32_t
name|dst
init|=
name|i
decl_stmt|;
name|apr_uint32_t
name|old_nelts
init|=
name|pollset
operator|->
name|nelts
decl_stmt|;
name|pollset
operator|->
name|nelts
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|old_nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descriptor
operator|->
name|desc
operator|.
name|s
operator|==
name|priv
operator|->
name|query_set
index|[
name|i
index|]
operator|.
name|desc
operator|.
name|s
condition|)
block|{
name|pollset
operator|->
name|nelts
operator|--
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|priv
operator|->
name|pollset
index|[
name|dst
index|]
operator|=
name|priv
operator|->
name|pollset
index|[
name|i
index|]
expr_stmt|;
name|priv
operator|->
name|query_set
index|[
name|dst
index|]
operator|=
name|priv
operator|->
name|query_set
index|[
name|i
index|]
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}             DBG
operator|(
literal|4
operator|,
literal|"returning OK\n"
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|APR_SUCCESS
return|;
end_return

begin_expr_stmt
unit|}     }
name|DBG
argument_list|(
literal|1
argument_list|,
literal|"returning APR_NOTFOUND\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|APR_NOTFOUND
return|;
end_return

begin_comment
unit|}
comment|/* end of posix_remove */
end_comment

begin_function
unit|static
name|apr_status_t
name|asio_pollset_remove
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
name|descriptor
parameter_list|)
block|{
name|DBG_BUFF
name|asio_elem_t
modifier|*
name|elem
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_pollset_private_t
modifier|*
name|priv
init|=
name|pollset
operator|->
name|p
decl_stmt|;
name|struct
name|aiocb
name|cancel_a
decl_stmt|;
comment|/* AIO_CANCEL is synchronous, so autodata works fine */
name|int
name|fd
decl_stmt|;
name|DBG
argument_list|(
literal|2
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pollset
operator|->
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
operator|)
condition|)
block|{
return|return
name|posix_remove
argument_list|(
name|pollset
argument_list|,
name|descriptor
argument_list|)
return|;
block|}
name|pollset_lock_rings
argument_list|()
expr_stmt|;
if|#
directive|if
name|DEBUG
name|assert
argument_list|(
name|descriptor
operator|->
name|desc_type
operator|==
name|APR_POLL_SOCKET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* zOS 1.12 doesn't support files for async i/o */
name|fd
operator|=
name|descriptor
operator|->
name|desc
operator|.
name|s
operator|->
name|socketdes
expr_stmt|;
name|elem
operator|=
name|apr_hash_get
argument_list|(
name|priv
operator|->
name|elems
argument_list|,
operator|&
operator|(
name|fd
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
name|NULL
condition|)
block|{
name|DBG1
argument_list|(
literal|1
argument_list|,
literal|"couldn't find fd %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|rv
operator|=
name|APR_NOTFOUND
expr_stmt|;
block|}
else|else
block|{
name|DBG1
argument_list|(
literal|5
argument_list|,
literal|"hash found fd %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* delete this fd from the hash */
name|apr_hash_set
argument_list|(
name|priv
operator|->
name|elems
argument_list|,
operator|&
operator|(
name|fd
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|state
operator|==
name|ASIO_INIT
condition|)
block|{
comment|/* asyncio call to cancel */
name|cancel_a
operator|.
name|aio_cmd
operator|=
name|AIO_CANCEL
expr_stmt|;
name|cancel_a
operator|.
name|aio_buf
operator|=
operator|&
name|elem
operator|->
name|a
expr_stmt|;
comment|/* point to original aiocb */
name|cancel_a
operator|.
name|aio_cflags
operator|=
literal|0
expr_stmt|;
name|cancel_a
operator|.
name|aio_cflags2
operator|=
literal|0
expr_stmt|;
comment|/* we want the original aiocb to show up on the pollset message queue               * before recycling its memory to eliminate race conditions              */
name|rv
operator|=
name|asyncio
argument_list|(
operator|&
name|cancel_a
argument_list|)
expr_stmt|;
name|DBG1
argument_list|(
literal|4
argument_list|,
literal|"asyncio returned %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|assert
argument_list|(
name|rv
operator|==
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|elem
operator|->
name|state
operator|=
name|ASIO_REMOVED
expr_stmt|;
name|rv
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
name|DBG1
argument_list|(
literal|2
argument_list|,
literal|"exiting, rv: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|pollset_unlock_rings
argument_list|()
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* end of asio_pollset_remove */
end_comment

begin_expr_stmt
specifier|static
name|posix_poll
argument_list|(
argument|apr_pollset_t *pollset
argument_list|,
argument|apr_interval_time_t timeout
argument_list|,
argument|apr_int32_t *num
argument_list|,
argument|const apr_pollfd_t **descriptors
argument_list|)
block|{
name|DBG_BUFF
name|int
name|rv
block|;
name|apr_uint32_t
name|i
block|,
name|j
block|;
name|apr_pollset_private_t
operator|*
name|priv
operator|=
name|pollset
operator|->
name|p
block|;
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"entered\n"
argument_list|)
block|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|timeout
operator|/=
literal|1000
expr_stmt|;
block|}
name|rv
operator|=
name|poll
argument_list|(
name|priv
operator|->
name|pollset
argument_list|,
name|pollset
operator|->
name|nelts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|*
name|num
operator|)
operator|=
name|rv
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
return|return
name|apr_get_netos_error
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
return|return
name|APR_TIMEUP
return|;
block|}
end_if

begin_expr_stmt
name|j
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pollset
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|pollset
index|[
name|i
index|]
operator|.
name|revents
operator|!=
literal|0
condition|)
block|{
name|priv
operator|->
name|result_set
index|[
name|j
index|]
operator|=
name|priv
operator|->
name|query_set
index|[
name|i
index|]
expr_stmt|;
name|priv
operator|->
name|result_set
index|[
name|j
index|]
operator|.
name|rtnevents
operator|=
name|get_revent
argument_list|(
name|priv
operator|->
name|pollset
index|[
name|i
index|]
operator|.
name|revents
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|descriptors
condition|)
operator|*
name|descriptors
operator|=
name|priv
operator|->
name|result_set
expr_stmt|;
end_if

begin_expr_stmt
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"exiting ok\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|APR_SUCCESS
return|;
end_return

begin_comment
unit|}
comment|/* end of posix_poll */
end_comment

begin_macro
unit|static
name|process_msg
argument_list|(
argument|apr_pollset_t *pollset
argument_list|,
argument|struct asio_msgbuf_t *msg
argument_list|)
end_macro

begin_block
block|{
name|DBG_BUFF
name|asio_elem_t
modifier|*
name|elem
init|=
name|msg
operator|->
name|msg_elem
decl_stmt|;
switch|switch
condition|(
name|elem
operator|->
name|state
condition|)
block|{
case|case
name|ASIO_REMOVED
case|:
name|DBG2
argument_list|(
literal|5
argument_list|,
literal|"for cancelled elem, recycling memory - elem %08p, fd %d\n"
argument_list|,
name|elem
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|)
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|pollset
operator|->
name|p
operator|->
name|free_ring
operator|)
argument_list|,
name|elem
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASIO_INIT
case|:
name|DBG2
argument_list|(
literal|4
argument_list|,
literal|"adding to ready ring: elem %08p, fd %d\n"
argument_list|,
name|elem
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|)
expr_stmt|;
name|elem
operator|->
name|state
operator|=
name|ASIO_COMPLETE
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|pollset
operator|->
name|p
operator|->
name|ready_ring
operator|)
argument_list|,
name|elem
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DBG3
argument_list|(
literal|1
argument_list|,
literal|"unexpected state: elem %08p, fd %d, state %d\n"
argument_list|,
name|elem
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|,
name|elem
operator|->
name|state
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_function
specifier|static
name|apr_status_t
name|asio_pollset_poll
parameter_list|(
name|apr_pollset_t
modifier|*
name|pollset
parameter_list|,
name|apr_interval_time_t
name|timeout
parameter_list|,
name|apr_int32_t
modifier|*
name|num
parameter_list|,
specifier|const
name|apr_pollfd_t
modifier|*
modifier|*
name|descriptors
parameter_list|)
block|{
name|DBG_BUFF
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|asio_elem_t
modifier|*
name|elem
decl_stmt|,
modifier|*
name|next_elem
decl_stmt|;
name|struct
name|asio_msgbuf_t
name|msg_buff
decl_stmt|;
name|struct
name|timespec
name|tv
decl_stmt|;
name|apr_status_t
name|rv
init|=
name|APR_SUCCESS
decl_stmt|;
name|apr_pollset_private_t
modifier|*
name|priv
init|=
name|pollset
operator|->
name|p
decl_stmt|;
name|DBG
argument_list|(
literal|6
argument_list|,
literal|"entered\n"
argument_list|)
expr_stmt|;
comment|/* chatty - traces every second w/Event */
if|if
condition|(
operator|(
name|pollset
operator|->
name|flags
operator|&
name|APR_POLLSET_THREADSAFE
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|posix_poll
argument_list|(
name|pollset
argument_list|,
name|timeout
argument_list|,
name|num
argument_list|,
name|descriptors
argument_list|)
return|;
block|}
name|pollset_lock_rings
argument_list|()
expr_stmt|;
name|APR_RING_INIT
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|APR_RING_EMPTY
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|prior_ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|elem
operator|=
name|APR_RING_FIRST
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|prior_ready_ring
operator|)
argument_list|)
expr_stmt|;
name|DBG3
argument_list|(
literal|5
argument_list|,
literal|"pollset %p elem %p fd %d on prior ready ring\n"
argument_list|,
name|pollset
argument_list|,
name|elem
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|)
expr_stmt|;
name|APR_RING_REMOVE
argument_list|(
name|elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/*          * since USS does not remember what's in our pollset, we have          * to re-add fds which have not been apr_pollset_remove'd          *          * there may have been too many ready fd's to return in the          * result set last time. re-poll inline for both cases          */
if|if
condition|(
name|elem
operator|->
name|state
operator|==
name|ASIO_REMOVED
condition|)
block|{
comment|/*               * async i/o is done since it was found on prior_ready              * the state says the caller is done with it too               * so recycle the elem               */
name|APR_RING_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|free_ring
operator|)
argument_list|,
name|elem
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
continue|continue;
comment|/* do not re-add if it has been _removed */
block|}
name|elem
operator|->
name|state
operator|=
name|ASIO_INIT
expr_stmt|;
name|elem
operator|->
name|a
operator|.
name|aio_cflags
operator|=
name|AIO_OK2COMPIMD
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|ret
operator|=
name|asyncio
argument_list|(
operator|&
name|elem
operator|->
name|a
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|DBG
argument_list|(
literal|4
argument_list|,
literal|"asyncio() completed inline\n"
argument_list|)
expr_stmt|;
comment|/* it's ready now */
name|elem
operator|->
name|state
operator|=
name|ASIO_COMPLETE
expr_stmt|;
name|APR_RING_INSERT_TAIL
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|elem
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBG2
argument_list|(
literal|1
argument_list|,
literal|"asyncio() failed, ret: %d, errno: %d\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|pollset_unlock_rings
argument_list|()
expr_stmt|;
return|return
name|errno
return|;
block|}
block|}
name|DBG1
argument_list|(
literal|4
argument_list|,
literal|"asyncio() completed rc %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|DBG
argument_list|(
literal|6
argument_list|,
literal|"after prior ready loop\n"
argument_list|)
expr_stmt|;
comment|/* chatty w/timeouts, hence 6 */
comment|/* Gather async poll completions that have occurred since the last call */
while|while
condition|(
literal|0
operator|<
name|msgrcv
argument_list|(
name|priv
operator|->
name|msg_q
argument_list|,
operator|&
name|msg_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|asio_elem_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IPC_NOWAIT
argument_list|)
condition|)
block|{
name|process_msg
argument_list|(
name|pollset
argument_list|,
operator|&
name|msg_buff
argument_list|)
expr_stmt|;
block|}
comment|/* Suspend if nothing is ready yet. */
if|if
condition|(
name|APR_RING_EMPTY
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|>=
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|apr_time_sec
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_nsec
operator|=
name|apr_time_usec
argument_list|(
name|timeout
argument_list|)
operator|*
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|INT_MAX
expr_stmt|;
comment|/* block until something is ready */
block|}
name|DBG2
argument_list|(
literal|6
argument_list|,
literal|"nothing on the ready ring "
literal|"- blocking for %d seconds %d ns\n"
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
name|pollset_unlock_rings
argument_list|()
expr_stmt|;
comment|/* allow other apr_pollset_* calls while blocked */
if|if
condition|(
literal|0
operator|>=
operator|(
name|ret
operator|=
name|__msgrcv_timed
argument_list|(
name|priv
operator|->
name|msg_q
argument_list|,
operator|&
name|msg_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|asio_elem_t
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|DEBUG
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|DBG
argument_list|(
literal|6
argument_list|,
literal|"__msgrcv_timed timed out\n"
argument_list|)
expr_stmt|;
comment|/* timeout path, so 6 */
block|}
else|else
block|{
name|DBG
argument_list|(
literal|1
argument_list|,
literal|"__msgrcv_timed failed!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
condition|?
name|APR_TIMEUP
else|:
name|errno
return|;
block|}
name|pollset_lock_rings
argument_list|()
expr_stmt|;
name|process_msg
argument_list|(
name|pollset
argument_list|,
operator|&
name|msg_buff
argument_list|)
expr_stmt|;
block|}
name|APR_RING_INIT
argument_list|(
operator|&
name|priv
operator|->
name|prior_ready_ring
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num
operator|)
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|APR_RING_FIRST
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|size
operator|&&
name|elem
operator|!=
name|APR_RING_SENTINEL
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|DBG2
argument_list|(
literal|5
argument_list|,
literal|"ready ring: elem %08p, fd %d\n"
argument_list|,
name|elem
argument_list|,
name|elem
operator|->
name|os_pfd
operator|.
name|fd
argument_list|)
expr_stmt|;
name|priv
operator|->
name|result_set
index|[
name|i
index|]
operator|=
name|elem
operator|->
name|pfd
expr_stmt|;
name|priv
operator|->
name|result_set
index|[
name|i
index|]
operator|.
name|rtnevents
operator|=
name|get_revent
argument_list|(
name|elem
operator|->
name|os_pfd
operator|.
name|revents
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num
operator|)
operator|++
expr_stmt|;
name|elem
operator|=
name|APR_RING_NEXT
argument_list|(
name|elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|elem
operator|==
name|APR_RING_SENTINEL
argument_list|(
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
literal|5
argument_list|,
literal|"end of ready ring reached\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|descriptors
condition|)
block|{
operator|*
name|descriptors
operator|=
name|priv
operator|->
name|result_set
expr_stmt|;
block|}
comment|/* if the result size is too small, remember which descriptors      * haven't had results reported yet.  we will look      * at these descriptors on the next apr_pollset_poll call      */
name|APR_RING_CONCAT
argument_list|(
operator|&
name|priv
operator|->
name|prior_ready_ring
argument_list|,
operator|&
operator|(
name|priv
operator|->
name|ready_ring
operator|)
argument_list|,
name|asio_elem_t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DBG1
argument_list|(
literal|2
argument_list|,
literal|"exiting, rv = %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|pollset_unlock_rings
argument_list|()
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* end of asio_pollset_poll */
end_comment

begin_decl_stmt
specifier|static
name|apr_pollset_provider_t
name|impl
init|=
block|{
name|asio_pollset_create
block|,
name|asio_pollset_add
block|,
name|asio_pollset_remove
block|,
name|asio_pollset_poll
block|,
name|asio_pollset_cleanup
block|,
literal|"asio"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|apr_pollset_provider_t
modifier|*
name|apr_pollset_provider_aio_msgq
init|=
operator|&
name|impl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_AIO_MSGQ */
end_comment

end_unit

