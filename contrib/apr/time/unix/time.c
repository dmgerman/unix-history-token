begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_comment
comment|/* private APR headers */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_internal_time.h"
end_include

begin_comment
comment|/* System Headers required for time library */
end_comment

begin_if
if|#
directive|if
name|APR_HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* End System Headers */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRUCT_TM_TM_GMTOFF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_STRUCT_TM___TM_GMTOFF
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|apr_int32_t
name|server_gmt_offset
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_GMTOFF_IN_STRUCT_TM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|apr_int32_t
name|get_offset
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_TM_TM_GMTOFF
argument_list|)
return|return
name|tm
operator|->
name|tm_gmtoff
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_TM___TM_GMTOFF
argument_list|)
return|return
name|tm
operator|->
name|__tm_gmtoff
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|NETWARE
comment|/* Need to adjust the global variable each time otherwise         the web server would have to be restarted when daylight         savings changes.     */
if|if
condition|(
name|daylightOnOff
condition|)
block|{
return|return
name|server_gmt_offset
operator|+
name|daylightOffset
return|;
block|}
else|#
directive|else
if|if
condition|(
name|tm
operator|->
name|tm_isdst
condition|)
return|return
name|server_gmt_offset
operator|+
literal|3600
return|;
endif|#
directive|endif
return|return
name|server_gmt_offset
return|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_ansi_put
argument_list|(
argument|apr_time_t *result
argument_list|,
argument|time_t input
argument_list|)
end_macro

begin_block
block|{
operator|*
name|result
operator|=
operator|(
name|apr_time_t
operator|)
name|input
operator|*
name|APR_USEC_PER_SEC
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* NB NB NB NB This returns GMT!!!!!!!!!! */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_time_t
argument_list|)
end_macro

begin_macro
name|apr_time_now
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|tv
operator|.
name|tv_sec
operator|*
name|APR_USEC_PER_SEC
operator|+
name|tv
operator|.
name|tv_usec
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|explode_time
parameter_list|(
name|apr_time_exp_t
modifier|*
name|xt
parameter_list|,
name|apr_time_t
name|t
parameter_list|,
name|apr_int32_t
name|offset
parameter_list|,
name|int
name|use_localtime
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|tt
init|=
operator|(
name|t
operator|/
name|APR_USEC_PER_SEC
operator|)
operator|+
name|offset
decl_stmt|;
name|xt
operator|->
name|tm_usec
operator|=
name|t
operator|%
name|APR_USEC_PER_SEC
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
if|if
condition|(
name|use_localtime
condition|)
name|localtime_r
argument_list|(
operator|&
name|tt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
else|else
name|gmtime_r
argument_list|(
operator|&
name|tt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|use_localtime
condition|)
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
else|else
name|tm
operator|=
operator|*
name|gmtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xt
operator|->
name|tm_sec
operator|=
name|tm
operator|.
name|tm_sec
expr_stmt|;
name|xt
operator|->
name|tm_min
operator|=
name|tm
operator|.
name|tm_min
expr_stmt|;
name|xt
operator|->
name|tm_hour
operator|=
name|tm
operator|.
name|tm_hour
expr_stmt|;
name|xt
operator|->
name|tm_mday
operator|=
name|tm
operator|.
name|tm_mday
expr_stmt|;
name|xt
operator|->
name|tm_mon
operator|=
name|tm
operator|.
name|tm_mon
expr_stmt|;
name|xt
operator|->
name|tm_year
operator|=
name|tm
operator|.
name|tm_year
expr_stmt|;
name|xt
operator|->
name|tm_wday
operator|=
name|tm
operator|.
name|tm_wday
expr_stmt|;
name|xt
operator|->
name|tm_yday
operator|=
name|tm
operator|.
name|tm_yday
expr_stmt|;
name|xt
operator|->
name|tm_isdst
operator|=
name|tm
operator|.
name|tm_isdst
expr_stmt|;
name|xt
operator|->
name|tm_gmtoff
operator|=
name|get_offset
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_exp_tz
argument_list|(
argument|apr_time_exp_t *result
argument_list|,
argument|apr_time_t input
argument_list|,
argument|apr_int32_t offs
argument_list|)
end_macro

begin_block
block|{
name|explode_time
argument_list|(
name|result
argument_list|,
name|input
argument_list|,
name|offs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|->
name|tm_gmtoff
operator|=
name|offs
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_exp_gmt
argument_list|(
argument|apr_time_exp_t *result
argument_list|,
argument|apr_time_t input
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_time_exp_tz
argument_list|(
name|result
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_exp_lt
argument_list|(
argument|apr_time_exp_t *result
argument_list|,
argument|apr_time_t input
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
comment|/* EMX gcc (OS/2) has a timezone global we can use */
return|return
name|apr_time_exp_tz
argument_list|(
name|result
argument_list|,
name|input
argument_list|,
operator|-
name|timezone
argument_list|)
return|;
else|#
directive|else
name|explode_time
argument_list|(
name|result
argument_list|,
name|input
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
endif|#
directive|endif
comment|/* __EMX__ */
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_exp_get
argument_list|(
argument|apr_time_t *t
argument_list|,
argument|apr_time_exp_t *xt
argument_list|)
end_macro

begin_block
block|{
name|apr_time_t
name|year
init|=
name|xt
operator|->
name|tm_year
decl_stmt|;
name|apr_time_t
name|days
decl_stmt|;
specifier|static
specifier|const
name|int
name|dayoffset
index|[
literal|12
index|]
init|=
block|{
literal|306
block|,
literal|337
block|,
literal|0
block|,
literal|31
block|,
literal|61
block|,
literal|92
block|,
literal|122
block|,
literal|153
block|,
literal|184
block|,
literal|214
block|,
literal|245
block|,
literal|275
block|}
decl_stmt|;
comment|/* shift new year to 1st March in order to make leap year calc easy */
if|if
condition|(
name|xt
operator|->
name|tm_mon
operator|<
literal|2
condition|)
name|year
operator|--
expr_stmt|;
comment|/* Find number of days since 1st March 1900 (in the Gregorian calendar). */
name|days
operator|=
name|year
operator|*
literal|365
operator|+
name|year
operator|/
literal|4
operator|-
name|year
operator|/
literal|100
operator|+
operator|(
name|year
operator|/
literal|100
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|days
operator|+=
name|dayoffset
index|[
name|xt
operator|->
name|tm_mon
index|]
operator|+
name|xt
operator|->
name|tm_mday
operator|-
literal|1
expr_stmt|;
name|days
operator|-=
literal|25508
expr_stmt|;
comment|/* 1 jan 1970 is 25508 days since 1 mar 1900 */
name|days
operator|=
operator|(
operator|(
name|days
operator|*
literal|24
operator|+
name|xt
operator|->
name|tm_hour
operator|)
operator|*
literal|60
operator|+
name|xt
operator|->
name|tm_min
operator|)
operator|*
literal|60
operator|+
name|xt
operator|->
name|tm_sec
expr_stmt|;
if|if
condition|(
name|days
operator|<
literal|0
condition|)
block|{
return|return
name|APR_EBADDATE
return|;
block|}
operator|*
name|t
operator|=
name|days
operator|*
name|APR_USEC_PER_SEC
operator|+
name|xt
operator|->
name|tm_usec
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_time_exp_gmt_get
argument_list|(
argument|apr_time_t *t
argument_list|,
argument|apr_time_exp_t *xt
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|status
init|=
name|apr_time_exp_get
argument_list|(
name|t
argument_list|,
name|xt
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
operator|*
name|t
operator|-=
operator|(
name|apr_time_t
operator|)
name|xt
operator|->
name|tm_gmtoff
operator|*
name|APR_USEC_PER_SEC
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_imp_time_get
argument_list|(
argument|apr_os_imp_time_t **ostime
argument_list|,
argument|apr_time_t *aprtime
argument_list|)
end_macro

begin_block
block|{
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tv_usec
operator|=
operator|*
name|aprtime
operator|%
name|APR_USEC_PER_SEC
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tv_sec
operator|=
operator|*
name|aprtime
operator|/
name|APR_USEC_PER_SEC
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_exp_time_get
argument_list|(
argument|apr_os_exp_time_t **ostime
argument_list|,
argument|apr_time_exp_t *aprtime
argument_list|)
end_macro

begin_block
block|{
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_sec
operator|=
name|aprtime
operator|->
name|tm_sec
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_min
operator|=
name|aprtime
operator|->
name|tm_min
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_hour
operator|=
name|aprtime
operator|->
name|tm_hour
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_mday
operator|=
name|aprtime
operator|->
name|tm_mday
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_mon
operator|=
name|aprtime
operator|->
name|tm_mon
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_year
operator|=
name|aprtime
operator|->
name|tm_year
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_wday
operator|=
name|aprtime
operator|->
name|tm_wday
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_yday
operator|=
name|aprtime
operator|->
name|tm_yday
expr_stmt|;
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_isdst
operator|=
name|aprtime
operator|->
name|tm_isdst
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_TM_TM_GMTOFF
argument_list|)
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_gmtoff
operator|=
name|aprtime
operator|->
name|tm_gmtoff
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_TM___TM_GMTOFF
argument_list|)
operator|(
operator|*
name|ostime
operator|)
operator|->
name|__tm_gmtoff
operator|=
name|aprtime
operator|->
name|tm_gmtoff
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_imp_time_put
argument_list|(
argument|apr_time_t *aprtime
argument_list|,
argument|apr_os_imp_time_t **ostime
argument_list|,
argument|apr_pool_t *cont
argument_list|)
end_macro

begin_block
block|{
operator|*
name|aprtime
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tv_sec
operator|*
name|APR_USEC_PER_SEC
operator|+
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tv_usec
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_exp_time_put
argument_list|(
argument|apr_time_exp_t *aprtime
argument_list|,
argument|apr_os_exp_time_t **ostime
argument_list|,
argument|apr_pool_t *cont
argument_list|)
end_macro

begin_block
block|{
name|aprtime
operator|->
name|tm_sec
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_sec
expr_stmt|;
name|aprtime
operator|->
name|tm_min
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_min
expr_stmt|;
name|aprtime
operator|->
name|tm_hour
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_hour
expr_stmt|;
name|aprtime
operator|->
name|tm_mday
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_mday
expr_stmt|;
name|aprtime
operator|->
name|tm_mon
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_mon
expr_stmt|;
name|aprtime
operator|->
name|tm_year
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_year
expr_stmt|;
name|aprtime
operator|->
name|tm_wday
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_wday
expr_stmt|;
name|aprtime
operator|->
name|tm_yday
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_yday
expr_stmt|;
name|aprtime
operator|->
name|tm_isdst
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_isdst
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_TM_TM_GMTOFF
argument_list|)
name|aprtime
operator|->
name|tm_gmtoff
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|tm_gmtoff
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_TM___TM_GMTOFF
argument_list|)
name|aprtime
operator|->
name|tm_gmtoff
operator|=
operator|(
operator|*
name|ostime
operator|)
operator|->
name|__tm_gmtoff
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_sleep
argument_list|(
argument|apr_interval_time_t t
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|OS2
name|DosSleep
argument_list|(
name|t
operator|/
literal|1000
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|BEOS
argument_list|)
name|snooze
argument_list|(
name|t
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|NETWARE
argument_list|)
name|delay
argument_list|(
name|t
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|t
operator|%
name|APR_USEC_PER_SEC
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|t
operator|/
name|APR_USEC_PER_SEC
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os2_time_to_apr_time
argument_list|(
argument|apr_time_t *result
argument_list|,
argument|FDATE os2date
argument_list|,
argument|FTIME os2time
argument_list|)
end_macro

begin_block
block|{
name|struct
name|tm
name|tmpdate
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tmpdate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpdate
argument_list|)
argument_list|)
expr_stmt|;
name|tmpdate
operator|.
name|tm_hour
operator|=
name|os2time
operator|.
name|hours
expr_stmt|;
name|tmpdate
operator|.
name|tm_min
operator|=
name|os2time
operator|.
name|minutes
expr_stmt|;
name|tmpdate
operator|.
name|tm_sec
operator|=
name|os2time
operator|.
name|twosecs
operator|*
literal|2
expr_stmt|;
name|tmpdate
operator|.
name|tm_mday
operator|=
name|os2date
operator|.
name|day
expr_stmt|;
name|tmpdate
operator|.
name|tm_mon
operator|=
name|os2date
operator|.
name|month
operator|-
literal|1
expr_stmt|;
name|tmpdate
operator|.
name|tm_year
operator|=
name|os2date
operator|.
name|year
operator|+
literal|80
expr_stmt|;
name|tmpdate
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|result
operator|=
name|mktime
argument_list|(
operator|&
name|tmpdate
argument_list|)
operator|*
name|APR_USEC_PER_SEC
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_apr_time_to_os2_time
argument_list|(
argument|FDATE *os2date
argument_list|,
argument|FTIME *os2time
argument_list|,
argument|apr_time_t aprtime
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|ansitime
init|=
name|aprtime
operator|/
name|APR_USEC_PER_SEC
decl_stmt|;
name|struct
name|tm
modifier|*
name|lt
decl_stmt|;
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|ansitime
argument_list|)
expr_stmt|;
name|os2time
operator|->
name|hours
operator|=
name|lt
operator|->
name|tm_hour
expr_stmt|;
name|os2time
operator|->
name|minutes
operator|=
name|lt
operator|->
name|tm_min
expr_stmt|;
name|os2time
operator|->
name|twosecs
operator|=
name|lt
operator|->
name|tm_sec
operator|/
literal|2
expr_stmt|;
name|os2date
operator|->
name|day
operator|=
name|lt
operator|->
name|tm_mday
expr_stmt|;
name|os2date
operator|->
name|month
operator|=
name|lt
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|os2date
operator|->
name|year
operator|=
name|lt
operator|->
name|tm_year
operator|-
literal|80
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NETWARE
end_ifdef

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_netware_setup_time
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|tzset
argument_list|()
expr_stmt|;
name|server_gmt_offset
operator|=
operator|-
name|TZONE
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_unix_setup_time
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_GMTOFF_IN_STRUCT_TM
comment|/* Precompute the offset from GMT on systems where it's not        in struct tm.         Note: This offset is normalized to be independent of daylight        savings time; if the calculation happens to be done in a        time/place where a daylight savings adjustment is in effect,        the returned offset has the same value that it would have        in the same location if daylight savings were not in effect.        The reason for this is that the returned offset can be        applied to a past or future timestamp in explode_time(),        so the DST adjustment obtained from the current time won't        necessarily be applicable.         mktime() is the inverse of localtime(); so, presumably,        passing in a struct tm made by gmtime() let's us calculate        the true GMT offset. However, there's a catch: if daylight        savings is in effect, gmtime()will set the tm_isdst field        and confuse mktime() into returning a time that's offset        by one hour. In that case, we must adjust the calculated GMT        offset.       */
name|struct
name|timeval
name|now
decl_stmt|;
name|time_t
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t1
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
name|gmtime_r
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
operator|*
name|gmtime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
comment|/* we know this GMT time isn't daylight-savings */
name|t2
operator|=
name|mktime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|server_gmt_offset
operator|=
operator|(
name|apr_int32_t
operator|)
name|difftime
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_GMTOFF_IN_STRUCT_TM */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A noop on all known Unix implementations */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_time_clock_hires
argument_list|(
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
return|return;
block|}
end_block

end_unit

