begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_network_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_include
include|#
directive|include
file|"apr_errno.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_if
if|#
directive|if
name|APR_HAVE_CTYPE_H
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_NETINET_IN_H
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_SYS_SOCKET_H
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_ARPA_INET_H
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|NO
init|=
literal|0
block|,
name|YES
init|=
literal|1
block|}
name|boolean_e
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUL
value|'\0'
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|null_string
index|[]
init|=
literal|"(null)"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S_NULL
value|((char *)null_string)
end_define

begin_define
define|#
directive|define
name|S_NULL_LEN
value|6
end_define

begin_define
define|#
directive|define
name|FLOAT_DIGITS
value|6
end_define

begin_define
define|#
directive|define
name|EXPONENT_LENGTH
value|10
end_define

begin_comment
comment|/*  * NUM_BUF_SIZE is the size of the buffer used for arithmetic conversions  *  * NOTICE: this is a magic number; do not decrease it  */
end_comment

begin_define
define|#
directive|define
name|NUM_BUF_SIZE
value|512
end_define

begin_comment
comment|/*  * cvt - IEEE floating point formatting routines.  *       Derived from UNIX V7, Copyright(C) Caldera International Inc.  */
end_comment

begin_comment
comment|/*  *    apr_ecvt converts to decimal  *      the number of digits is specified by ndigit  *      decpt is set to the position of the decimal point  *      sign is set to 0 for positive, 1 for negative  */
end_comment

begin_define
define|#
directive|define
name|NDIG
value|80
end_define

begin_comment
comment|/* buf must have at least NDIG bytes */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|apr_cvt
parameter_list|(
name|double
name|arg
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|int
name|eflag
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|register
name|int
name|r2
decl_stmt|;
name|double
name|fi
decl_stmt|,
name|fj
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|ndigits
operator|>=
name|NDIG
operator|-
literal|1
condition|)
name|ndigits
operator|=
name|NDIG
operator|-
literal|2
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
block|}
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
comment|/*      * Do integer part      */
if|if
condition|(
name|fi
operator|!=
literal|0
condition|)
block|{
name|p1
operator|=
operator|&
name|buf
index|[
name|NDIG
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|>
operator|&
name|buf
index|[
literal|0
index|]
operator|&&
name|fi
operator|!=
literal|0
condition|)
block|{
name|fj
operator|=
name|modf
argument_list|(
name|fi
operator|/
literal|10
argument_list|,
operator|&
name|fi
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p1
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|fj
operator|+
literal|.03
operator|)
operator|*
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|r2
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|fj
operator|=
name|arg
operator|*
literal|10
operator|)
operator|<
literal|1
condition|)
block|{
name|arg
operator|=
name|fj
expr_stmt|;
name|r2
operator|--
expr_stmt|;
block|}
block|}
name|p1
operator|=
operator|&
name|buf
index|[
name|ndigits
index|]
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
name|p1
operator|+=
name|r2
expr_stmt|;
if|if
condition|(
name|p1
operator|<
operator|&
name|buf
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|decpt
operator|=
operator|-
name|ndigits
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
operator|*
name|decpt
operator|=
name|r2
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|p1
operator|&&
name|p
operator|<
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|arg
operator|*=
literal|10
expr_stmt|;
name|arg
operator|=
name|modf
argument_list|(
name|arg
argument_list|,
operator|&
name|fj
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|int
operator|)
name|fj
operator|+
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|>=
operator|&
name|buf
index|[
name|NDIG
index|]
condition|)
block|{
name|buf
index|[
name|NDIG
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
operator|*
name|p1
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>
literal|'9'
condition|)
block|{
operator|*
name|p1
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|p1
operator|>
name|buf
condition|)
operator|++
operator|*
operator|--
name|p1
expr_stmt|;
else|else
block|{
operator|*
name|p1
operator|=
literal|'1'
expr_stmt|;
operator|(
operator|*
name|decpt
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|=
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|apr_ecvt
parameter_list|(
name|double
name|arg
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|apr_cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|apr_fcvt
parameter_list|(
name|double
name|arg
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|apr_cvt
argument_list|(
name|arg
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * apr_gcvt  - Floating output conversion to  * minimal length string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|apr_gcvt
parameter_list|(
name|double
name|number
parameter_list|,
name|int
name|ndigit
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|boolean_e
name|altform
parameter_list|)
block|{
name|int
name|sign
decl_stmt|,
name|decpt
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf1
index|[
name|NDIG
index|]
decl_stmt|;
name|p1
operator|=
name|apr_ecvt
argument_list|(
name|number
argument_list|,
name|ndigit
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndigit
operator|-
literal|1
init|;
name|i
operator|>
literal|0
operator|&&
name|p1
index|[
name|i
index|]
operator|==
literal|'0'
condition|;
name|i
operator|--
control|)
name|ndigit
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|decpt
operator|>=
literal|0
operator|&&
name|decpt
operator|-
name|ndigit
operator|>
literal|4
operator|)
operator|||
operator|(
name|decpt
operator|<
literal|0
operator|&&
name|decpt
operator|<
operator|-
literal|3
operator|)
condition|)
block|{
comment|/* use E-style */
name|decpt
operator|--
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ndigit
condition|;
name|i
operator|++
control|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'e'
expr_stmt|;
if|if
condition|(
name|decpt
operator|<
literal|0
condition|)
block|{
name|decpt
operator|=
operator|-
name|decpt
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
operator|*
name|p2
operator|++
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|decpt
operator|/
literal|100
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
name|decpt
operator|/
literal|100
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|decpt
operator|/
literal|10
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
operator|(
name|decpt
operator|%
literal|100
operator|)
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|decpt
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decpt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
literal|'0'
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
name|decpt
operator|<
literal|0
condition|)
block|{
name|decpt
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|ndigit
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|decpt
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|ndigit
operator|<
name|decpt
condition|)
block|{
while|while
condition|(
name|ndigit
operator|++
operator|<
name|decpt
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|altform
condition|)
name|p2
operator|--
expr_stmt|;
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The INS_CHAR macro inserts a character in the buffer and writes  * the buffer back to disk if necessary  * It uses the char pointers sp and bep:  *      sp points to the next available character in the buffer  *      bep points to the end-of-buffer+1  * While using this macro, note that the nextb pointer is NOT updated.  *  * NOTE: Evaluation of the c argument should not have any side-effects  */
end_comment

begin_define
define|#
directive|define
name|INS_CHAR
parameter_list|(
name|c
parameter_list|,
name|sp
parameter_list|,
name|bep
parameter_list|,
name|cc
parameter_list|)
define|\
value|{                                                   \     if (sp) {                                       \         if (sp>= bep) {                            \             vbuff->curpos = sp;                     \             if (flush_func(vbuff))                  \                 return -1;                          \             sp = vbuff->curpos;                     \             bep = vbuff->endpos;                    \         }                                           \         *sp++ = (c);                                \     }                                               \     cc++;                                           \ }
end_define

begin_define
define|#
directive|define
name|NUM
parameter_list|(
name|c
parameter_list|)
value|(c - '0')
end_define

begin_define
define|#
directive|define
name|STR_TO_DEC
parameter_list|(
name|str
parameter_list|,
name|num
parameter_list|)
define|\
value|num = NUM(*str++);                              \     while (apr_isdigit(*str))                       \     {                                               \         num *= 10 ;                                 \         num += NUM(*str++);                         \     }
end_define

begin_comment
comment|/*  * This macro does zero padding so that the precision  * requirement is satisfied. The padding is done by  * adding '0's to the left of the string that is going  * to be printed. We don't allow precision to be large  * enough that we continue past the start of s.  *  * NOTE: this makes use of the magic info that s is  * always based on num_buf with a size of NUM_BUF_SIZE.  */
end_comment

begin_define
define|#
directive|define
name|FIX_PRECISION
parameter_list|(
name|adjust
parameter_list|,
name|precision
parameter_list|,
name|s
parameter_list|,
name|s_len
parameter_list|)
define|\
value|if (adjust) {                                   \         apr_size_t p = (precision + 1< NUM_BUF_SIZE) \                      ? precision : NUM_BUF_SIZE - 1;  \         while (s_len< p)                           \         {                                           \             *--s = '0';                             \             s_len++;                                \         }                                           \     }
end_define

begin_comment
comment|/*  * Macro that does padding. The padding is done by printing  * the character ch.  */
end_comment

begin_define
define|#
directive|define
name|PAD
parameter_list|(
name|width
parameter_list|,
name|len
parameter_list|,
name|ch
parameter_list|)
define|\
value|do                                                  \ {                                                   \     INS_CHAR(ch, sp, bep, cc);                      \     width--;                                        \ }                                                   \ while (width> len)
end_define

begin_comment
comment|/*  * Prefix the character ch to the string str  * Increase length  * Set the has_prefix flag  */
end_comment

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|str
parameter_list|,
name|length
parameter_list|,
name|ch
parameter_list|)
define|\
value|*--str = ch;                                    \     length++;                                       \     has_prefix=YES;
end_define

begin_comment
comment|/*  * Convert num to its decimal format.  * Return value:  *   - a pointer to a string containing the number (no sign)  *   - len contains the length of the string  *   - is_negative is set to TRUE or FALSE depending on the sign  *     of the number (always set to FALSE if is_unsigned is TRUE)  *  * The caller provides a buffer for the string: that is the buf_end argument  * which is a pointer to the END of the buffer + 1 (i.e. if the buffer  * is declared as buf[ 100 ], buf_end should be&buf[ 100 ])  *  * Note: we have 2 versions. One is used when we need to use quads  * (conv_10_quad), the other when we don't (conv_10). We're assuming the  * latter is faster.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_10
parameter_list|(
specifier|register
name|apr_int32_t
name|num
parameter_list|,
specifier|register
name|int
name|is_unsigned
parameter_list|,
specifier|register
name|int
modifier|*
name|is_negative
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
specifier|register
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
specifier|register
name|apr_uint32_t
name|magnitude
init|=
name|num
decl_stmt|;
if|if
condition|(
name|is_unsigned
condition|)
block|{
operator|*
name|is_negative
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|is_negative
operator|=
operator|(
name|num
operator|<
literal|0
operator|)
expr_stmt|;
comment|/*          * On a 2's complement machine, negating the most negative integer           * results in a number that cannot be represented as a signed integer.          * Here is what we do to obtain the number's magnitude:          *      a. add 1 to the number          *      b. negate it (becomes positive)          *      c. convert it to unsigned          *      d. add 1          */
if|if
condition|(
operator|*
name|is_negative
condition|)
block|{
name|apr_int32_t
name|t
init|=
name|num
operator|+
literal|1
decl_stmt|;
name|magnitude
operator|=
operator|(
operator|(
name|apr_uint32_t
operator|)
operator|-
name|t
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * We use a do-while loop so that we write at least 1 digit       */
do|do
block|{
specifier|register
name|apr_uint32_t
name|new_magnitude
init|=
name|magnitude
operator|/
literal|10
decl_stmt|;
operator|*
operator|--
name|p
operator|=
call|(
name|char
call|)
argument_list|(
name|magnitude
operator|-
name|new_magnitude
operator|*
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|magnitude
operator|=
name|new_magnitude
expr_stmt|;
block|}
do|while
condition|(
name|magnitude
condition|)
do|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|conv_10_quad
parameter_list|(
name|apr_int64_t
name|num
parameter_list|,
specifier|register
name|int
name|is_unsigned
parameter_list|,
specifier|register
name|int
modifier|*
name|is_negative
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
specifier|register
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
name|apr_uint64_t
name|magnitude
init|=
name|num
decl_stmt|;
comment|/*      * We see if we can use the faster non-quad version by checking the      * number against the largest long value it can be. If<=, we      * punt to the quicker version.      */
if|if
condition|(
operator|(
name|magnitude
operator|<=
name|APR_UINT32_MAX
operator|&&
name|is_unsigned
operator|)
operator|||
operator|(
name|num
operator|<=
name|APR_INT32_MAX
operator|&&
name|num
operator|>=
name|APR_INT32_MIN
operator|&&
operator|!
name|is_unsigned
operator|)
condition|)
return|return
operator|(
name|conv_10
argument_list|(
operator|(
name|apr_int32_t
operator|)
name|num
argument_list|,
name|is_unsigned
argument_list|,
name|is_negative
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
operator|)
return|;
if|if
condition|(
name|is_unsigned
condition|)
block|{
operator|*
name|is_negative
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|is_negative
operator|=
operator|(
name|num
operator|<
literal|0
operator|)
expr_stmt|;
comment|/*          * On a 2's complement machine, negating the most negative integer           * results in a number that cannot be represented as a signed integer.          * Here is what we do to obtain the number's magnitude:          *      a. add 1 to the number          *      b. negate it (becomes positive)          *      c. convert it to unsigned          *      d. add 1          */
if|if
condition|(
operator|*
name|is_negative
condition|)
block|{
name|apr_int64_t
name|t
init|=
name|num
operator|+
literal|1
decl_stmt|;
name|magnitude
operator|=
operator|(
operator|(
name|apr_uint64_t
operator|)
operator|-
name|t
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * We use a do-while loop so that we write at least 1 digit       */
do|do
block|{
name|apr_uint64_t
name|new_magnitude
init|=
name|magnitude
operator|/
literal|10
decl_stmt|;
operator|*
operator|--
name|p
operator|=
call|(
name|char
call|)
argument_list|(
name|magnitude
operator|-
name|new_magnitude
operator|*
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|magnitude
operator|=
name|new_magnitude
expr_stmt|;
block|}
do|while
condition|(
name|magnitude
condition|)
do|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|conv_in_addr
parameter_list|(
name|struct
name|in_addr
modifier|*
name|ia
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|addr
init|=
name|ntohl
argument_list|(
name|ia
operator|->
name|s_addr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
name|int
name|is_negative
decl_stmt|;
name|apr_size_t
name|sub_len
decl_stmt|;
name|p
operator|=
name|conv_10
argument_list|(
operator|(
name|addr
operator|&
literal|0x000000FF
operator|)
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|p
argument_list|,
operator|&
name|sub_len
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
name|p
operator|=
name|conv_10
argument_list|(
operator|(
name|addr
operator|&
literal|0x0000FF00
operator|)
operator|>>
literal|8
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|p
argument_list|,
operator|&
name|sub_len
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
name|p
operator|=
name|conv_10
argument_list|(
operator|(
name|addr
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|p
argument_list|,
operator|&
name|sub_len
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
name|p
operator|=
name|conv_10
argument_list|(
operator|(
name|addr
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|24
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|p
argument_list|,
operator|&
name|sub_len
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Must be passed a buffer of size NUM_BUF_SIZE where buf_end points  * to 1 byte past the end of the buffer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_apr_sockaddr
parameter_list|(
name|apr_sockaddr_t
modifier|*
name|sa
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
name|int
name|is_negative
decl_stmt|;
name|apr_size_t
name|sub_len
decl_stmt|;
name|char
modifier|*
name|ipaddr_str
decl_stmt|;
name|p
operator|=
name|conv_10
argument_list|(
name|sa
operator|->
name|port
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|p
argument_list|,
operator|&
name|sub_len
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|':'
expr_stmt|;
name|ipaddr_str
operator|=
name|buf_end
operator|-
name|NUM_BUF_SIZE
expr_stmt|;
if|if
condition|(
name|apr_sockaddr_ip_getbuf
argument_list|(
name|ipaddr_str
argument_list|,
name|sa
operator|->
name|addr_str_len
argument_list|,
name|sa
argument_list|)
condition|)
block|{
comment|/* Should only fail if the buffer is too small, which it          * should not be; but fail safe anyway: */
operator|*
operator|--
name|p
operator|=
literal|'?'
expr_stmt|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
name|sub_len
operator|=
name|strlen
argument_list|(
name|ipaddr_str
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|sa
operator|->
name|family
operator|==
name|APR_INET6
operator|&&
operator|!
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sa
operator|->
name|sa
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
literal|']'
expr_stmt|;
name|p
operator|-=
name|sub_len
operator|+
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'['
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|ipaddr_str
argument_list|,
name|sub_len
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|p
operator|-=
name|sub_len
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ipaddr_str
argument_list|,
name|sub_len
argument_list|)
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_function
specifier|static
name|char
modifier|*
name|conv_os_thread_t
parameter_list|(
name|apr_os_thread_t
modifier|*
name|tid
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
union|union
block|{
name|apr_os_thread_t
name|tid
decl_stmt|;
name|apr_uint64_t
name|u64
decl_stmt|;
name|apr_uint32_t
name|u32
decl_stmt|;
block|}
name|u
union|;
name|int
name|is_negative
decl_stmt|;
name|u
operator|.
name|tid
operator|=
operator|*
name|tid
expr_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|u
operator|.
name|tid
argument_list|)
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
case|:
return|return
name|conv_10
argument_list|(
name|u
operator|.
name|u32
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
case|:
return|return
name|conv_10_quad
argument_list|(
name|u
operator|.
name|u64
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
default|default:
comment|/* not implemented; stick 0 in the buffer */
return|return
name|conv_10
argument_list|(
literal|0
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert a floating point number to a string formats 'f', 'e' or 'E'.  * The result is placed in buf, and len denotes the length of the string  * The sign is returned in the is_negative argument (and is not placed  * in buf).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_fp
parameter_list|(
specifier|register
name|char
name|format
parameter_list|,
specifier|register
name|double
name|num
parameter_list|,
name|boolean_e
name|add_dp
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
modifier|*
name|is_negative
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|decimal_point
decl_stmt|;
name|char
name|buf1
index|[
name|NDIG
index|]
decl_stmt|;
if|if
condition|(
name|format
operator|==
literal|'f'
condition|)
name|p
operator|=
name|apr_fcvt
argument_list|(
name|num
argument_list|,
name|precision
argument_list|,
operator|&
name|decimal_point
argument_list|,
name|is_negative
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
else|else
comment|/* either e or E format */
name|p
operator|=
name|apr_ecvt
argument_list|(
name|num
argument_list|,
name|precision
operator|+
literal|1
argument_list|,
operator|&
name|decimal_point
argument_list|,
name|is_negative
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
comment|/*      * Check for Infinity and NaN      */
if|if
condition|(
name|apr_isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
operator|*
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|is_negative
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
if|if
condition|(
name|format
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|decimal_point
operator|<=
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|precision
operator|>
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
name|decimal_point
operator|++
operator|<
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_dp
condition|)
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|decimal_point
operator|--
operator|>
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|precision
operator|>
literal|0
operator|||
name|add_dp
condition|)
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|precision
operator|>
literal|0
operator|||
name|add_dp
condition|)
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/*      * copy the rest of p, the NUL is NOT copied      */
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|format
operator|!=
literal|'f'
condition|)
block|{
name|char
name|temp
index|[
name|EXPONENT_LENGTH
index|]
decl_stmt|;
comment|/* for exponent conversion */
name|apr_size_t
name|t_len
decl_stmt|;
name|int
name|exponent_is_negative
decl_stmt|;
operator|*
name|s
operator|++
operator|=
name|format
expr_stmt|;
comment|/* either e or E */
name|decimal_point
operator|--
expr_stmt|;
if|if
condition|(
name|decimal_point
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|conv_10
argument_list|(
operator|(
name|apr_int32_t
operator|)
name|decimal_point
argument_list|,
name|FALSE
argument_list|,
operator|&
name|exponent_is_negative
argument_list|,
operator|&
name|temp
index|[
name|EXPONENT_LENGTH
index|]
argument_list|,
operator|&
name|t_len
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|exponent_is_negative
condition|?
literal|'-'
else|:
literal|'+'
expr_stmt|;
comment|/*              * Make sure the exponent has at least 2 digits              */
if|if
condition|(
name|t_len
operator|==
literal|1
condition|)
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
while|while
condition|(
name|t_len
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
operator|*
name|len
operator|=
name|s
operator|-
name|buf
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert num to a base X number where X is a power of 2. nbits determines X.  * For example, if nbits is 3, we do base 8 conversion  * Return value:  *      a pointer to a string containing the number  *  * The caller provides a buffer for the string: that is the buf_end argument  * which is a pointer to the END of the buffer + 1 (i.e. if the buffer  * is declared as buf[ 100 ], buf_end should be&buf[ 100 ])  *  * As with conv_10, we have a faster version which is used when  * the number isn't quad size.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_p2
parameter_list|(
specifier|register
name|apr_uint32_t
name|num
parameter_list|,
specifier|register
name|int
name|nbits
parameter_list|,
name|char
name|format
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
specifier|register
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|register
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|nbits
operator|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
specifier|static
specifier|const
name|char
name|low_digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
specifier|const
name|char
name|upper_digits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|digits
init|=
operator|(
name|format
operator|==
literal|'X'
operator|)
condition|?
name|upper_digits
else|:
name|low_digits
decl_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
name|digits
index|[
name|num
operator|&
name|mask
index|]
expr_stmt|;
name|num
operator|>>=
name|nbits
expr_stmt|;
block|}
do|while
condition|(
name|num
condition|)
do|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|conv_p2_quad
parameter_list|(
name|apr_uint64_t
name|num
parameter_list|,
specifier|register
name|int
name|nbits
parameter_list|,
name|char
name|format
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
specifier|register
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|register
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|nbits
operator|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_end
decl_stmt|;
specifier|static
specifier|const
name|char
name|low_digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
specifier|const
name|char
name|upper_digits
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|digits
init|=
operator|(
name|format
operator|==
literal|'X'
operator|)
condition|?
name|upper_digits
else|:
name|low_digits
decl_stmt|;
if|if
condition|(
name|num
operator|<=
name|APR_UINT32_MAX
condition|)
return|return
operator|(
name|conv_p2
argument_list|(
operator|(
name|apr_uint32_t
operator|)
name|num
argument_list|,
name|nbits
argument_list|,
name|format
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
operator|)
return|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
name|digits
index|[
name|num
operator|&
name|mask
index|]
expr_stmt|;
name|num
operator|>>=
name|nbits
expr_stmt|;
block|}
do|while
condition|(
name|num
condition|)
do|;
operator|*
name|len
operator|=
name|buf_end
operator|-
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_function
specifier|static
name|char
modifier|*
name|conv_os_thread_t_hex
parameter_list|(
name|apr_os_thread_t
modifier|*
name|tid
parameter_list|,
name|char
modifier|*
name|buf_end
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
union|union
block|{
name|apr_os_thread_t
name|tid
decl_stmt|;
name|apr_uint64_t
name|u64
decl_stmt|;
name|apr_uint32_t
name|u32
decl_stmt|;
block|}
name|u
union|;
name|int
name|is_negative
decl_stmt|;
name|u
operator|.
name|tid
operator|=
operator|*
name|tid
expr_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|u
operator|.
name|tid
argument_list|)
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
case|:
return|return
name|conv_p2
argument_list|(
name|u
operator|.
name|u32
argument_list|,
literal|4
argument_list|,
literal|'x'
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
case|case
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
case|:
return|return
name|conv_p2_quad
argument_list|(
name|u
operator|.
name|u64
argument_list|,
literal|4
argument_list|,
literal|'x'
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
default|default:
comment|/* not implemented; stick 0 in the buffer */
return|return
name|conv_10
argument_list|(
literal|0
argument_list|,
name|TRUE
argument_list|,
operator|&
name|is_negative
argument_list|,
name|buf_end
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do format conversion placing the output in buffer  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_vformatter
argument_list|(
argument|int (*flush_func)(apr_vformatter_buff_t *)
argument_list|,
argument|apr_vformatter_buff_t *vbuff
argument_list|,
argument|const char *fmt
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bep
decl_stmt|;
specifier|register
name|int
name|cc
init|=
literal|0
decl_stmt|;
specifier|register
name|apr_size_t
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|apr_size_t
name|s_len
init|=
literal|0
decl_stmt|;
specifier|register
name|apr_size_t
name|min_width
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|precision
init|=
literal|0
decl_stmt|;
enum|enum
block|{
name|LEFT
block|,
name|RIGHT
block|}
name|adjust
enum|;
name|char
name|pad_char
decl_stmt|;
name|char
name|prefix_char
decl_stmt|;
name|double
name|fp_num
decl_stmt|;
name|apr_int64_t
name|i_quad
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|ui_quad
decl_stmt|;
name|apr_int32_t
name|i_num
init|=
literal|0
decl_stmt|;
name|apr_uint32_t
name|ui_num
init|=
literal|0
decl_stmt|;
name|char
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
decl_stmt|;
name|char
name|char_buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* for printing %% and %<unknown> */
enum|enum
name|var_type_enum
block|{
name|IS_QUAD
block|,
name|IS_LONG
block|,
name|IS_SHORT
block|,
name|IS_INT
block|}
enum|;
name|enum
name|var_type_enum
name|var_type
init|=
name|IS_INT
decl_stmt|;
comment|/*      * Flag variables      */
name|boolean_e
name|alternate_form
decl_stmt|;
name|boolean_e
name|print_sign
decl_stmt|;
name|boolean_e
name|print_blank
decl_stmt|;
name|boolean_e
name|adjust_precision
decl_stmt|;
name|boolean_e
name|adjust_width
decl_stmt|;
name|int
name|is_negative
decl_stmt|;
name|sp
operator|=
name|vbuff
operator|->
name|curpos
expr_stmt|;
name|bep
operator|=
name|vbuff
operator|->
name|endpos
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
name|INS_CHAR
argument_list|(
operator|*
name|fmt
argument_list|,
name|sp
argument_list|,
name|bep
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * Default variable settings              */
name|boolean_e
name|print_something
init|=
name|YES
decl_stmt|;
name|adjust
operator|=
name|RIGHT
expr_stmt|;
name|alternate_form
operator|=
name|print_sign
operator|=
name|print_blank
operator|=
name|NO
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
name|prefix_char
operator|=
name|NUL
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
comment|/*              * Try to avoid checking for flags, width or precision              */
if|if
condition|(
operator|!
name|apr_islower
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
comment|/*                  * Recognize flags: -, #, BLANK, +                  */
for|for
control|(
init|;
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'-'
condition|)
name|adjust
operator|=
name|LEFT
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'+'
condition|)
name|print_sign
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'#'
condition|)
name|alternate_form
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|' '
condition|)
name|print_blank
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'0'
condition|)
name|pad_char
operator|=
literal|'0'
expr_stmt|;
else|else
break|break;
block|}
comment|/*                  * Check if a width was specified                  */
if|if
condition|(
name|apr_isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|STR_TO_DEC
argument_list|(
name|fmt
argument_list|,
name|min_width
argument_list|)
expr_stmt|;
name|adjust_width
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|int
name|v
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|fmt
operator|++
expr_stmt|;
name|adjust_width
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
block|{
name|adjust
operator|=
name|LEFT
expr_stmt|;
name|min_width
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
operator|-
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|min_width
operator|=
operator|(
name|apr_size_t
operator|)
name|v
expr_stmt|;
block|}
else|else
name|adjust_width
operator|=
name|NO
expr_stmt|;
comment|/*                  * Check if a precision was specified                  */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'.'
condition|)
block|{
name|adjust_precision
operator|=
name|YES
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|apr_isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|STR_TO_DEC
argument_list|(
name|fmt
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|int
name|v
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|fmt
operator|++
expr_stmt|;
name|precision
operator|=
operator|(
name|v
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|apr_size_t
operator|)
name|v
expr_stmt|;
block|}
else|else
name|precision
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|adjust_precision
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|adjust_precision
operator|=
name|adjust_width
operator|=
name|NO
expr_stmt|;
comment|/*              * Modifier check.  In same cases, APR_OFF_T_FMT can be              * "lld" and APR_INT64_T_FMT can be "ld" (that is, off_t is              * "larger" than int64). Check that case 1st.              * Note that if APR_OFF_T_FMT is "d",              * the first if condition is never true. If APR_INT64_T_FMT              * is "d' then the second if condition is never true.              */
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|)
operator|&&
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|==
literal|4
operator|&&
name|fmt
index|[
literal|0
index|]
operator|==
name|APR_OFF_T_FMT
index|[
literal|0
index|]
operator|&&
name|fmt
index|[
literal|1
index|]
operator|==
name|APR_OFF_T_FMT
index|[
literal|1
index|]
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|==
literal|3
operator|&&
name|fmt
index|[
literal|0
index|]
operator|==
name|APR_OFF_T_FMT
index|[
literal|0
index|]
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
name|fmt
argument_list|,
name|APR_OFF_T_FMT
argument_list|,
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Need to account for trailing 'd' and null in sizeof() */
name|var_type
operator|=
name|IS_QUAD
expr_stmt|;
name|fmt
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|APR_OFF_T_FMT
argument_list|)
operator|-
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|==
literal|4
operator|&&
name|fmt
index|[
literal|0
index|]
operator|==
name|APR_INT64_T_FMT
index|[
literal|0
index|]
operator|&&
name|fmt
index|[
literal|1
index|]
operator|==
name|APR_INT64_T_FMT
index|[
literal|1
index|]
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|==
literal|3
operator|&&
name|fmt
index|[
literal|0
index|]
operator|==
name|APR_INT64_T_FMT
index|[
literal|0
index|]
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
name|fmt
argument_list|,
name|APR_INT64_T_FMT
argument_list|,
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Need to account for trailing 'd' and null in sizeof() */
name|var_type
operator|=
name|IS_QUAD
expr_stmt|;
name|fmt
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|APR_INT64_T_FMT
argument_list|)
operator|-
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'q'
condition|)
block|{
name|var_type
operator|=
name|IS_QUAD
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'l'
condition|)
block|{
name|var_type
operator|=
name|IS_LONG
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'h'
condition|)
block|{
name|var_type
operator|=
name|IS_SHORT
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|var_type
operator|=
name|IS_INT
expr_stmt|;
block|}
comment|/*              * Argument extraction and printing.              * First we determine the argument type.              * Then, we convert the argument to a string.              * On exit from the switch, s points to the string that              * must be printed, s_len has the length of the string              * The precision requirements, if any, are reflected in s_len.              *              * NOTE: pad_char may be set to '0' because of the 0 flag.              *   It is reset to ' ' by non-numeric formats              */
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'u'
case|:
if|if
condition|(
name|var_type
operator|==
name|IS_QUAD
condition|)
block|{
name|i_quad
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_10_quad
argument_list|(
name|i_quad
argument_list|,
literal|1
argument_list|,
operator|&
name|is_negative
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var_type
operator|==
name|IS_LONG
condition|)
name|i_num
operator|=
operator|(
name|apr_int32_t
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint32_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_SHORT
condition|)
name|i_num
operator|=
operator|(
name|apr_int32_t
operator|)
operator|(
name|unsigned
name|short
operator|)
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
else|else
name|i_num
operator|=
operator|(
name|apr_int32_t
operator|)
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_10
argument_list|(
name|i_num
argument_list|,
literal|1
argument_list|,
operator|&
name|is_negative
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
name|FIX_PRECISION
argument_list|(
name|adjust_precision
argument_list|,
name|precision
argument_list|,
name|s
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|var_type
operator|==
name|IS_QUAD
condition|)
block|{
name|i_quad
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_int64_t
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_10_quad
argument_list|(
name|i_quad
argument_list|,
literal|0
argument_list|,
operator|&
name|is_negative
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var_type
operator|==
name|IS_LONG
condition|)
name|i_num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_int32_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_SHORT
condition|)
name|i_num
operator|=
operator|(
name|short
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|i_num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_10
argument_list|(
name|i_num
argument_list|,
literal|0
argument_list|,
operator|&
name|is_negative
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
name|FIX_PRECISION
argument_list|(
name|adjust_precision
argument_list|,
name|precision
argument_list|,
name|s
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_negative
condition|)
name|prefix_char
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|print_sign
condition|)
name|prefix_char
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|print_blank
condition|)
name|prefix_char
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|var_type
operator|==
name|IS_QUAD
condition|)
block|{
name|ui_quad
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2_quad
argument_list|(
name|ui_quad
argument_list|,
literal|3
argument_list|,
operator|*
name|fmt
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var_type
operator|==
name|IS_LONG
condition|)
name|ui_num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint32_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_SHORT
condition|)
name|ui_num
operator|=
operator|(
name|unsigned
name|short
operator|)
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
else|else
name|ui_num
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2
argument_list|(
name|ui_num
argument_list|,
literal|3
argument_list|,
operator|*
name|fmt
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
name|FIX_PRECISION
argument_list|(
name|adjust_precision
argument_list|,
name|precision
argument_list|,
name|s
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate_form
operator|&&
operator|*
name|s
operator|!=
literal|'0'
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|s_len
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|var_type
operator|==
name|IS_QUAD
condition|)
block|{
name|ui_quad
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2_quad
argument_list|(
name|ui_quad
argument_list|,
literal|4
argument_list|,
operator|*
name|fmt
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var_type
operator|==
name|IS_LONG
condition|)
name|ui_num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint32_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_SHORT
condition|)
name|ui_num
operator|=
operator|(
name|unsigned
name|short
operator|)
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
else|else
name|ui_num
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2
argument_list|(
name|ui_num
argument_list|,
literal|4
argument_list|,
operator|*
name|fmt
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
name|FIX_PRECISION
argument_list|(
name|adjust_precision
argument_list|,
name|precision
argument_list|,
name|s
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate_form
operator|&&
name|ui_num
operator|!=
literal|0
condition|)
block|{
operator|*
operator|--
name|s
operator|=
operator|*
name|fmt
expr_stmt|;
comment|/* 'x' or 'X' */
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|s_len
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|adjust_precision
condition|)
block|{
name|s_len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* From the C library standard in section 7.9.6.1:                          * ...if the precision is specified, no more then                          * that many characters are written.  If the                          * precision is not specified or is greater                          * than the size of the array, the array shall                          * contain a null character.                          *                          * My reading is is precision is specified and                          * is less then or equal to the size of the                          * array, no null character is required.  So                          * we can't do a strlen.                          *                          * This figures out the length of the string                          * up to the precision.  Once it's long enough                          * for the specified precision, we don't care                          * anymore.                          *                          * NOTE: you must do the length comparison                          * before the check for the null character.                          * Otherwise, you'll check one beyond the                          * last valid character.                          */
specifier|const
name|char
modifier|*
name|walk
decl_stmt|;
for|for
control|(
name|walk
operator|=
name|s
operator|,
name|s_len
operator|=
literal|0
init|;
operator|(
name|s_len
operator|<
name|precision
operator|)
operator|&&
operator|(
operator|*
name|walk
operator|!=
literal|'\0'
operator|)
condition|;
operator|++
name|walk
operator|,
operator|++
name|s_len
control|)
empty_stmt|;
block|}
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|fp_num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/*                  * We use&num_buf[ 1 ], so that we have room for the sign                  */
name|s
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ISNAN
if|if
condition|(
name|isnan
argument_list|(
name|fp_num
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"nan"
expr_stmt|;
name|s_len
operator|=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ISINF
if|if
condition|(
operator|!
name|s
operator|&&
name|isinf
argument_list|(
name|fp_num
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"inf"
expr_stmt|;
name|s_len
operator|=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
name|conv_fp
argument_list|(
operator|*
name|fmt
argument_list|,
name|fp_num
argument_list|,
name|alternate_form
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|adjust_precision
operator|==
name|NO
operator|)
condition|?
name|FLOAT_DIGITS
else|:
name|precision
argument_list|)
argument_list|,
operator|&
name|is_negative
argument_list|,
operator|&
name|num_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_negative
condition|)
name|prefix_char
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|print_sign
condition|)
name|prefix_char
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|print_blank
condition|)
name|prefix_char
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
name|adjust_precision
operator|==
name|NO
condition|)
name|precision
operator|=
name|FLOAT_DIGITS
expr_stmt|;
elseif|else
if|if
condition|(
name|precision
operator|==
literal|0
condition|)
name|precision
operator|=
literal|1
expr_stmt|;
comment|/*                  * * We use&num_buf[ 1 ], so that we have room for the sign                  */
name|s
operator|=
name|apr_gcvt
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|precision
argument_list|,
operator|&
name|num_buf
index|[
literal|1
index|]
argument_list|,
name|alternate_form
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|prefix_char
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|print_sign
condition|)
name|prefix_char
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|print_blank
condition|)
name|prefix_char
operator|=
literal|' '
expr_stmt|;
name|s_len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate_form
operator|&&
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
index|[
name|s_len
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|s
index|[
name|s_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit for following strchr() */
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'G'
operator|&&
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'E'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|char_buf
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|char_buf
index|[
literal|0
index|]
expr_stmt|;
name|s_len
operator|=
literal|1
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|char_buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|s
operator|=
operator|&
name|char_buf
index|[
literal|0
index|]
expr_stmt|;
name|s_len
operator|=
literal|1
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|var_type
operator|==
name|IS_QUAD
condition|)
operator|*
operator|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_int64_t
operator|*
argument_list|)
operator|)
operator|=
name|cc
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_LONG
condition|)
operator|*
operator|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
operator|*
argument_list|)
operator|)
operator|=
name|cc
expr_stmt|;
elseif|else
if|if
condition|(
name|var_type
operator|==
name|IS_SHORT
condition|)
operator|*
operator|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|short
operator|*
argument_list|)
operator|)
operator|=
name|cc
expr_stmt|;
else|else
operator|*
operator|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|)
operator|=
name|cc
expr_stmt|;
name|print_something
operator|=
name|NO
expr_stmt|;
break|break;
comment|/*                  * This is where we extend the printf format, with a second                  * type specifier                  */
case|case
literal|'p'
case|:
switch|switch
condition|(
operator|*
operator|++
name|fmt
condition|)
block|{
comment|/*                  * If the pointer size is equal to or smaller than the size                  * of the largest unsigned int, we convert the pointer to a                  * hex number, otherwise we print "%p" to indicate that we                  * don't handle "%p".                  */
case|case
literal|'p'
case|:
if|#
directive|if
name|APR_SIZEOF_VOIDP
operator|==
literal|8
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
condition|)
block|{
name|ui_quad
operator|=
operator|(
name|apr_uint64_t
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2_quad
argument_list|(
name|ui_quad
argument_list|,
literal|4
argument_list|,
literal|'x'
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
condition|)
block|{
name|ui_num
operator|=
operator|(
name|apr_uint32_t
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|s
operator|=
name|conv_p2
argument_list|(
name|ui_num
argument_list|,
literal|4
argument_list|,
literal|'x'
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|s
operator|=
literal|"%p"
expr_stmt|;
name|s_len
operator|=
literal|2
expr_stmt|;
name|prefix_char
operator|=
name|NUL
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
break|break;
comment|/* print an apr_sockaddr_t as a.b.c.d:port */
case|case
literal|'I'
case|:
block|{
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_sockaddr_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|conv_apr_sockaddr
argument_list|(
name|sa
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_precision
operator|&&
name|precision
operator|<
name|s_len
condition|)
name|s_len
operator|=
name|precision
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
comment|/* print a struct in_addr as a.b.c.d */
case|case
literal|'A'
case|:
block|{
name|struct
name|in_addr
modifier|*
name|ia
decl_stmt|;
name|ia
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|conv_in_addr
argument_list|(
name|ia
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_precision
operator|&&
name|precision
operator|<
name|s_len
condition|)
name|s_len
operator|=
name|precision
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
comment|/* print the error for an apr_status_t */
case|case
literal|'m'
case|:
block|{
name|apr_status_t
modifier|*
name|mrv
decl_stmt|;
name|mrv
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_status_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrv
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|apr_strerror
argument_list|(
operator|*
name|mrv
argument_list|,
name|num_buf
argument_list|,
name|NUM_BUF_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s_len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
if|#
directive|if
name|APR_HAS_THREADS
block|{
name|apr_os_thread_t
modifier|*
name|tid
decl_stmt|;
name|tid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_os_thread_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|conv_os_thread_t
argument_list|(
name|tid
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_precision
operator|&&
name|precision
operator|<
name|s_len
condition|)
name|s_len
operator|=
name|precision
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
else|#
directive|else
name|char_buf
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|s
operator|=
operator|&
name|char_buf
index|[
literal|0
index|]
expr_stmt|;
name|s_len
operator|=
literal|1
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
if|#
directive|if
name|APR_HAS_THREADS
block|{
name|apr_os_thread_t
modifier|*
name|tid
decl_stmt|;
name|tid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_os_thread_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|conv_os_thread_t_hex
argument_list|(
name|tid
argument_list|,
operator|&
name|num_buf
index|[
name|NUM_BUF_SIZE
index|]
argument_list|,
operator|&
name|s_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_precision
operator|&&
name|precision
operator|<
name|s_len
condition|)
name|s_len
operator|=
name|precision
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|S_NULL
expr_stmt|;
name|s_len
operator|=
name|S_NULL_LEN
expr_stmt|;
block|}
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
else|#
directive|else
name|char_buf
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|s
operator|=
operator|&
name|char_buf
index|[
literal|0
index|]
expr_stmt|;
name|s_len
operator|=
literal|1
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'B'
case|:
case|case
literal|'F'
case|:
case|case
literal|'S'
case|:
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|apr_off_t
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'B'
condition|)
block|{
name|apr_uint32_t
modifier|*
name|arg
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_uint32_t
operator|*
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|arg
operator|)
condition|?
operator|*
name|arg
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'F'
condition|)
block|{
name|apr_off_t
modifier|*
name|arg
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_off_t
operator|*
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|arg
operator|)
condition|?
operator|*
name|arg
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
modifier|*
name|arg
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_size_t
operator|*
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|arg
operator|)
condition|?
operator|*
name|arg
else|:
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|apr_strfsize
argument_list|(
name|size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|s_len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|NUL
case|:
comment|/* if %p ends the string, oh well ignore it */
continue|continue;
default|default:
name|s
operator|=
literal|"bogus %p"
expr_stmt|;
name|s_len
operator|=
literal|8
expr_stmt|;
name|prefix_char
operator|=
name|NUL
expr_stmt|;
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* skip the bogus argument on the stack */
break|break;
block|}
break|break;
case|case
name|NUL
case|:
comment|/*                  * The last character of the format string was %.                  * We ignore it.                  */
continue|continue;
comment|/*                  * The default case is for unrecognized %'s.                  * We print %<char> to help the user identify what                  * option is not understood.                  * This is also useful in case the user wants to pass                  * the output of format_converter to another function                  * that understands some other %<char> (like syslog).                  * Note that we can't point s inside fmt because the                  * unknown<char> could be preceded by width etc.                  */
default|default:
name|char_buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|char_buf
index|[
literal|1
index|]
operator|=
operator|*
name|fmt
expr_stmt|;
name|s
operator|=
name|char_buf
expr_stmt|;
name|s_len
operator|=
literal|2
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix_char
operator|!=
name|NUL
operator|&&
name|s
operator|!=
name|S_NULL
operator|&&
name|s
operator|!=
name|char_buf
condition|)
block|{
operator|*
operator|--
name|s
operator|=
name|prefix_char
expr_stmt|;
name|s_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|adjust_width
operator|&&
name|adjust
operator|==
name|RIGHT
operator|&&
name|min_width
operator|>
name|s_len
condition|)
block|{
if|if
condition|(
name|pad_char
operator|==
literal|'0'
operator|&&
name|prefix_char
operator|!=
name|NUL
condition|)
block|{
name|INS_CHAR
argument_list|(
operator|*
name|s
argument_list|,
name|sp
argument_list|,
name|bep
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|s_len
operator|--
expr_stmt|;
name|min_width
operator|--
expr_stmt|;
block|}
name|PAD
argument_list|(
name|min_width
argument_list|,
name|s_len
argument_list|,
name|pad_char
argument_list|)
expr_stmt|;
block|}
comment|/*              * Print the string s.               */
if|if
condition|(
name|print_something
operator|==
name|YES
condition|)
block|{
for|for
control|(
name|i
operator|=
name|s_len
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INS_CHAR
argument_list|(
operator|*
name|s
argument_list|,
name|sp
argument_list|,
name|bep
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adjust_width
operator|&&
name|adjust
operator|==
name|LEFT
operator|&&
name|min_width
operator|>
name|s_len
condition|)
name|PAD
argument_list|(
name|min_width
argument_list|,
name|s_len
argument_list|,
name|pad_char
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
name|vbuff
operator|->
name|curpos
operator|=
name|sp
expr_stmt|;
return|return
name|cc
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|snprintf_flush
parameter_list|(
name|apr_vformatter_buff_t
modifier|*
name|vbuff
parameter_list|)
block|{
comment|/* if the buffer fills we have to abort immediately, there is no way      * to "flush" an apr_snprintf... there's nowhere to flush it to.      */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_macro
name|APR_DECLARE_NONSTD
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_snprintf
argument_list|(
argument|char *buf
argument_list|,
argument|apr_size_t len
argument_list|,
argument|const char *format
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|int
name|cc
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|apr_vformatter_buff_t
name|vbuff
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* NOTE: This is a special case; we just want to return the number          * of chars that would be written (minus \0) if the buffer          * size was infinite. We leverage the fact that INS_CHAR          * just does actual inserts iff the buffer pointer is non-NULL.          * In this case, we don't care what buf is; it can be NULL, since          * we don't touch it at all.          */
name|vbuff
operator|.
name|curpos
operator|=
name|NULL
expr_stmt|;
name|vbuff
operator|.
name|endpos
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* save one byte for nul terminator */
name|vbuff
operator|.
name|curpos
operator|=
name|buf
expr_stmt|;
name|vbuff
operator|.
name|endpos
operator|=
name|buf
operator|+
name|len
operator|-
literal|1
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|cc
operator|=
name|apr_vformatter
argument_list|(
name|snprintf_flush
argument_list|,
operator|&
name|vbuff
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
operator|*
name|vbuff
operator|.
name|curpos
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|cc
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|int
operator|)
name|len
operator|-
literal|1
else|:
name|cc
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_vsnprintf
argument_list|(
argument|char *buf
argument_list|,
argument|apr_size_t len
argument_list|,
argument|const char *format
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|int
name|cc
decl_stmt|;
name|apr_vformatter_buff_t
name|vbuff
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* See above note */
name|vbuff
operator|.
name|curpos
operator|=
name|NULL
expr_stmt|;
name|vbuff
operator|.
name|endpos
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* save one byte for nul terminator */
name|vbuff
operator|.
name|curpos
operator|=
name|buf
expr_stmt|;
name|vbuff
operator|.
name|endpos
operator|=
name|buf
operator|+
name|len
operator|-
literal|1
expr_stmt|;
block|}
name|cc
operator|=
name|apr_vformatter
argument_list|(
name|snprintf_flush
argument_list|,
operator|&
name|vbuff
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
operator|*
name|vbuff
operator|.
name|curpos
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|cc
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|int
operator|)
name|len
operator|-
literal|1
else|:
name|cc
return|;
block|}
end_block

end_unit

