begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987, 1993, 1994  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_misc.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_define
define|#
directive|define
name|EMSG
value|""
end_define

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_getopt_init
argument_list|(
argument|apr_getopt_t **os
argument_list|,
argument|apr_pool_t *cont
argument_list|,
argument|int argc
argument_list|,
argument|const char *const *argv
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|argv_buff
decl_stmt|;
operator|*
name|os
operator|=
name|apr_palloc
argument_list|(
name|cont
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_getopt_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|cont
operator|=
name|cont
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|reset
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|errfn
operator|=
operator|(
name|apr_getopt_err_fn_t
operator|*
operator|)
operator|(
name|fprintf
operator|)
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|errarg
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|stderr
operator|)
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
comment|/* The argv parameter must be compatible with main()'s argv, since        that's the primary purpose of this function.  But people might        want to use this function with arrays other than the main argv,        and we shouldn't touch the caller's data.  So we copy. */
name|argv_buff
operator|=
name|apr_palloc
argument_list|(
name|cont
argument_list|,
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|argv_buff
argument_list|,
name|argv
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|argv
operator|=
name|argv_buff
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|interleave
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|ind
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|skip_start
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|os
operator|)
operator|->
name|skip_end
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_getopt
argument_list|(
argument|apr_getopt_t *os
argument_list|,
argument|const char *opts
argument_list|,
argument|char *optch
argument_list|,
argument|const char **optarg
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|oli
decl_stmt|;
comment|/* option letter list index */
if|if
condition|(
name|os
operator|->
name|reset
operator|||
operator|!
operator|*
name|os
operator|->
name|place
condition|)
block|{
comment|/* update scanning pointer */
name|os
operator|->
name|reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
operator|||
operator|*
operator|(
name|os
operator|->
name|place
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
operator|)
operator|!=
literal|'-'
condition|)
block|{
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_EOF
operator|)
return|;
block|}
if|if
condition|(
name|os
operator|->
name|place
index|[
literal|1
index|]
operator|&&
operator|*
operator|++
name|os
operator|->
name|place
operator|==
literal|'-'
condition|)
block|{
comment|/* found "--" */
operator|++
name|os
operator|->
name|ind
expr_stmt|;
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_EOF
operator|)
return|;
block|}
block|}
comment|/* option letter okay? */
if|if
condition|(
operator|(
name|os
operator|->
name|opt
operator|=
operator|(
name|int
operator|)
operator|*
name|os
operator|->
name|place
operator|++
operator|)
operator|==
operator|(
name|int
operator|)
literal|':'
operator|||
operator|!
operator|(
name|oli
operator|=
name|strchr
argument_list|(
name|opts
argument_list|,
name|os
operator|->
name|opt
argument_list|)
operator|)
condition|)
block|{
comment|/*          * if the user didn't specify '-' as an option,          * assume it means -1.          */
if|if
condition|(
name|os
operator|->
name|opt
operator|==
operator|(
name|int
operator|)
literal|'-'
condition|)
block|{
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_EOF
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|os
operator|->
name|place
condition|)
operator|++
name|os
operator|->
name|ind
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|errfn
operator|&&
operator|*
name|opts
operator|!=
literal|':'
condition|)
block|{
call|(
name|os
operator|->
name|errfn
call|)
argument_list|(
name|os
operator|->
name|errarg
argument_list|,
literal|"%s: illegal option -- %c\n"
argument_list|,
name|apr_filepath_name_get
argument_list|(
operator|*
name|os
operator|->
name|argv
argument_list|)
argument_list|,
name|os
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_BADCH
operator|)
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|oli
operator|!=
literal|':'
condition|)
block|{
comment|/* don't need argument */
operator|*
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|os
operator|->
name|place
condition|)
operator|++
name|os
operator|->
name|ind
expr_stmt|;
block|}
else|else
block|{
comment|/* need an argument */
if|if
condition|(
operator|*
name|os
operator|->
name|place
condition|)
comment|/* no white space */
operator|*
name|optarg
operator|=
name|os
operator|->
name|place
expr_stmt|;
elseif|else
if|if
condition|(
name|os
operator|->
name|argc
operator|<=
operator|++
name|os
operator|->
name|ind
condition|)
block|{
comment|/* no arg */
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
if|if
condition|(
operator|*
name|opts
operator|==
literal|':'
condition|)
block|{
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_BADARG
operator|)
return|;
block|}
if|if
condition|(
name|os
operator|->
name|errfn
condition|)
block|{
call|(
name|os
operator|->
name|errfn
call|)
argument_list|(
name|os
operator|->
name|errarg
argument_list|,
literal|"%s: option requires an argument -- %c\n"
argument_list|,
name|apr_filepath_name_get
argument_list|(
operator|*
name|os
operator|->
name|argv
argument_list|)
argument_list|,
name|os
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
operator|(
name|APR_BADCH
operator|)
return|;
block|}
else|else
comment|/* white space */
operator|*
name|optarg
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
expr_stmt|;
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
operator|++
name|os
operator|->
name|ind
expr_stmt|;
block|}
operator|*
name|optch
operator|=
name|os
operator|->
name|opt
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* Reverse the sequence argv[start..start+len-1]. */
end_comment

begin_function
specifier|static
name|void
name|reverse
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>=
literal|2
condition|;
name|start
operator|++
operator|,
name|len
operator|-=
literal|2
control|)
block|{
name|temp
operator|=
name|argv
index|[
name|start
index|]
expr_stmt|;
name|argv
index|[
name|start
index|]
operator|=
name|argv
index|[
name|start
operator|+
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|argv
index|[
name|start
operator|+
name|len
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Permute os->argv with the goal that non-option arguments will all  * appear at the end.  os->skip_start is where we started skipping  * non-option arguments, os->skip_end is where we stopped, and os->ind  * is where we are now.  */
end_comment

begin_function
specifier|static
name|void
name|permute
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|)
block|{
name|int
name|len1
init|=
name|os
operator|->
name|skip_end
operator|-
name|os
operator|->
name|skip_start
decl_stmt|;
name|int
name|len2
init|=
name|os
operator|->
name|ind
operator|-
name|os
operator|->
name|skip_end
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|interleave
condition|)
block|{
comment|/*          * Exchange the sequences argv[os->skip_start..os->skip_end-1] and          * argv[os->skip_end..os->ind-1].  The easiest way to do that is          * to reverse the entire range and then reverse the two          * sub-ranges.          */
name|reverse
argument_list|(
name|os
operator|->
name|argv
argument_list|,
name|os
operator|->
name|skip_start
argument_list|,
name|len1
operator|+
name|len2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|os
operator|->
name|argv
argument_list|,
name|os
operator|->
name|skip_start
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|os
operator|->
name|argv
argument_list|,
name|os
operator|->
name|skip_start
operator|+
name|len2
argument_list|,
name|len1
argument_list|)
expr_stmt|;
block|}
comment|/* Reset skip range to the new location of the non-option sequence. */
name|os
operator|->
name|skip_start
operator|+=
name|len2
expr_stmt|;
name|os
operator|->
name|skip_end
operator|+=
name|len2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function to print out an error involving a long option */
end_comment

begin_function
specifier|static
name|apr_status_t
name|serr
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_status_t
name|status
parameter_list|)
block|{
if|if
condition|(
name|os
operator|->
name|errfn
condition|)
call|(
name|os
operator|->
name|errfn
call|)
argument_list|(
name|os
operator|->
name|errarg
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|apr_filepath_name_get
argument_list|(
operator|*
name|os
operator|->
name|argv
argument_list|)
argument_list|,
name|err
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Helper function to print out an error involving a short option */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cerr
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
name|int
name|ch
parameter_list|,
name|apr_status_t
name|status
parameter_list|)
block|{
if|if
condition|(
name|os
operator|->
name|errfn
condition|)
call|(
name|os
operator|->
name|errfn
call|)
argument_list|(
name|os
operator|->
name|errarg
argument_list|,
literal|"%s: %s: %c\n"
argument_list|,
name|apr_filepath_name_get
argument_list|(
operator|*
name|os
operator|->
name|argv
argument_list|)
argument_list|,
name|err
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_getopt_long
argument_list|(
argument|apr_getopt_t *os
argument_list|,
argument|const apr_getopt_option_t *opts
argument_list|,
argument|int *optch
argument_list|,
argument|const char **optarg
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Let the calling program reset option processing. */
if|if
condition|(
name|os
operator|->
name|reset
condition|)
block|{
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
name|os
operator|->
name|ind
operator|=
literal|1
expr_stmt|;
name|os
operator|->
name|reset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * We can be in one of two states: in the middle of processing a      * run of short options, or about to process a new argument.      * Since the second case can lead to the first one, handle that      * one first.  */
name|p
operator|=
name|os
operator|->
name|place
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* If we are interleaving, skip non-option arguments. */
if|if
condition|(
name|os
operator|->
name|interleave
condition|)
block|{
while|while
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
operator|&&
operator|*
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
operator|!=
literal|'-'
condition|)
name|os
operator|->
name|ind
operator|++
expr_stmt|;
name|os
operator|->
name|skip_end
operator|=
name|os
operator|->
name|ind
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
operator|||
operator|*
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
index|]
operator|!=
literal|'-'
condition|)
block|{
name|os
operator|->
name|ind
operator|=
name|os
operator|->
name|skip_start
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
name|p
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Long option */
comment|/* Search for the long option name in the caller's table. */
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|optch
operator|==
literal|0
condition|)
comment|/* No match */
return|return
name|serr
argument_list|(
name|os
argument_list|,
literal|"invalid option"
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|APR_BADCH
argument_list|)
return|;
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|'='
operator|)
condition|)
break|break;
block|}
block|}
operator|*
name|optch
operator|=
name|opts
index|[
name|i
index|]
operator|.
name|optch
expr_stmt|;
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|has_arg
condition|)
block|{
if|if
condition|(
name|p
index|[
name|len
index|]
operator|==
literal|'='
condition|)
comment|/* Argument inline */
operator|*
name|optarg
operator|=
name|p
operator|+
name|len
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
comment|/* Argument missing */
return|return
name|serr
argument_list|(
name|os
argument_list|,
literal|"missing argument"
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|APR_BADARG
argument_list|)
return|;
else|else
comment|/* Argument in next arg */
operator|*
name|optarg
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
index|[
name|len
index|]
operator|==
literal|'='
condition|)
return|return
name|serr
argument_list|(
name|os
argument_list|,
literal|"erroneous argument"
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|APR_BADARG
argument_list|)
return|;
block|}
name|permute
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Bare "--"; we're done */
name|permute
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|->
name|ind
operator|=
name|os
operator|->
name|skip_start
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Bare "-" is illegal */
return|return
name|serr
argument_list|(
name|os
argument_list|,
literal|"invalid option"
argument_list|,
name|p
argument_list|,
name|APR_BADCH
argument_list|)
return|;
block|}
block|}
comment|/*      * Now we're in a run of short options, and *p is the next one.      * Look for it in the caller's table.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|optch
operator|==
literal|0
condition|)
comment|/* No match */
return|return
name|cerr
argument_list|(
name|os
argument_list|,
literal|"invalid option character"
argument_list|,
operator|*
name|p
argument_list|,
name|APR_BADCH
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|opts
index|[
name|i
index|]
operator|.
name|optch
condition|)
break|break;
block|}
operator|*
name|optch
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|has_arg
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
comment|/* Argument inline */
operator|*
name|optarg
operator|=
name|p
expr_stmt|;
else|else
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
comment|/* Argument missing */
return|return
name|cerr
argument_list|(
name|os
argument_list|,
literal|"missing argument"
argument_list|,
operator|*
name|optch
argument_list|,
name|APR_BADARG
argument_list|)
return|;
else|else
comment|/* Argument in next arg */
operator|*
name|optarg
operator|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
expr_stmt|;
block|}
name|os
operator|->
name|place
operator|=
name|EMSG
expr_stmt|;
block|}
else|else
block|{
operator|*
name|optarg
operator|=
name|NULL
expr_stmt|;
name|os
operator|->
name|place
operator|=
name|p
expr_stmt|;
block|}
name|permute
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

end_unit

