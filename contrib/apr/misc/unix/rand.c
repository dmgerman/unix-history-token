begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_misc.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|APR_HAVE_SYS_TYPES_H
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_SYS_SOCKET_H
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_SYS_UN_H
end_if

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UUID_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<uuid.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UUID_UUID_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<uuid/uuid.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_UUID_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHUT_RDWR
end_ifndef

begin_define
define|#
directive|define
name|SHUT_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAS_OS_UUID
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UUID_CREATE
argument_list|)
end_if

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_uuid_get
argument_list|(
argument|unsigned char *uuid_data
argument_list|)
end_macro

begin_block
block|{
name|uint32_t
name|rv
decl_stmt|;
name|uuid_t
name|g
decl_stmt|;
name|uuid_create
argument_list|(
operator|&
name|g
argument_list|,
operator|&
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|uuid_s_ok
condition|)
return|return
name|APR_EGENERAL
return|;
name|memcpy
argument_list|(
name|uuid_data
argument_list|,
operator|&
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UUID_GENERATE
argument_list|)
end_elif

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_os_uuid_get
argument_list|(
argument|unsigned char *uuid_data
argument_list|)
end_macro

begin_block
block|{
name|uuid_t
name|g
decl_stmt|;
name|uuid_generate
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|uuid_data
argument_list|,
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_OS_UUID */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_RANDOM
end_if

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_generate_random_bytes
argument_list|(
argument|unsigned char *buf
argument_list|,
argument|apr_size_t length
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEV_RANDOM
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* On BSD/OS 4.1, /dev/random gives out 8 bytes at a time, then      * gives EOF, so reading 'length' bytes may require opening the      * device several times. */
do|do
block|{
name|apr_ssize_t
name|rc
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|DEV_RANDOM
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|errno
return|;
do|do
block|{
name|rc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|int
name|errnum
init|=
name|errno
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|errnum
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* force open() again */
block|}
else|else
block|{
name|buf
operator|+=
name|rc
expr_stmt|;
name|length
operator|-=
name|rc
expr_stmt|;
block|}
block|}
do|while
condition|(
name|length
operator|>
literal|0
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|OS2
argument_list|)
specifier|static
name|UCHAR
name|randbyte
parameter_list|()
function_decl|;
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|length
condition|;
name|idx
operator|++
control|)
name|buf
index|[
name|idx
index|]
operator|=
name|randbyte
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EGD
argument_list|)
comment|/* use EGD-compatible socket daemon (such as EGD or PRNGd).      * message format:      * 0x00 (get entropy level)      *   0xMM (msb) 0xmm 0xll 0xLL (lsb)      * 0x01 (read entropy nonblocking) 0xNN (bytes requested)      *   0xMM (bytes granted) MM bytes      * 0x02 (read entropy blocking) 0xNN (bytes desired)      *   [block] NN bytes      * 0x03 (write entropy) 0xMM 0xLL (bits of entropy) 0xNN (bytes of data)       *      NN bytes      * (no response - write only)       * 0x04 (report PID)      *   0xMM (length of PID string, not null-terminated) MM chars      */
specifier|static
specifier|const
name|char
modifier|*
name|egd_sockets
index|[]
init|=
block|{
name|EGD_DEFAULT_SOCKET
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|egdsockname
init|=
name|NULL
decl_stmt|;
name|int
name|egd_socket
decl_stmt|,
name|egd_path_len
decl_stmt|,
name|rv
decl_stmt|,
name|bad_errno
decl_stmt|;
name|struct
name|sockaddr_un
name|addr
decl_stmt|;
name|apr_socklen_t
name|egd_addr_len
decl_stmt|;
name|apr_size_t
name|resp_expected
decl_stmt|;
name|unsigned
name|char
name|req
index|[
literal|2
index|]
decl_stmt|,
name|resp
index|[
literal|255
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curbuf
init|=
name|buf
decl_stmt|;
for|for
control|(
name|egdsockname
operator|=
name|egd_sockets
init|;
operator|*
name|egdsockname
operator|&&
name|length
operator|>
literal|0
condition|;
name|egdsockname
operator|++
control|)
block|{
name|egd_path_len
operator|=
name|strlen
argument_list|(
operator|*
name|egdsockname
argument_list|)
expr_stmt|;
if|if
condition|(
name|egd_path_len
operator|>
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|)
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|memcpy
argument_list|(
name|addr
operator|.
name|sun_path
argument_list|,
operator|*
name|egdsockname
argument_list|,
name|egd_path_len
argument_list|)
expr_stmt|;
name|egd_addr_len
operator|=
name|APR_OFFSETOF
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
operator|+
name|egd_path_len
expr_stmt|;
name|egd_socket
operator|=
name|socket
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|egd_socket
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
name|rv
operator|=
name|connect
argument_list|(
name|egd_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|egd_addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
name|bad_errno
operator|=
name|errno
expr_stmt|;
continue|continue;
block|}
comment|/* EGD can only return 255 bytes of data at a time.  Silly.  */
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|apr_ssize_t
name|srv
decl_stmt|;
name|req
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
comment|/* We'll block for now. */
name|req
index|[
literal|1
index|]
operator|=
name|length
operator|>
literal|255
condition|?
literal|255
else|:
name|length
expr_stmt|;
name|srv
operator|=
name|write
argument_list|(
name|egd_socket
argument_list|,
name|req
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|srv
operator|==
operator|-
literal|1
condition|)
block|{
name|bad_errno
operator|=
name|errno
expr_stmt|;
name|shutdown
argument_list|(
name|egd_socket
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|egd_socket
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srv
operator|!=
literal|2
condition|)
block|{
name|shutdown
argument_list|(
name|egd_socket
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|egd_socket
argument_list|)
expr_stmt|;
return|return
name|APR_EGENERAL
return|;
block|}
name|resp_expected
operator|=
name|req
index|[
literal|1
index|]
expr_stmt|;
name|srv
operator|=
name|read
argument_list|(
name|egd_socket
argument_list|,
name|resp
argument_list|,
name|resp_expected
argument_list|)
expr_stmt|;
if|if
condition|(
name|srv
operator|==
operator|-
literal|1
condition|)
block|{
name|bad_errno
operator|=
name|errno
expr_stmt|;
name|shutdown
argument_list|(
name|egd_socket
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|egd_socket
argument_list|)
expr_stmt|;
return|return
name|bad_errno
return|;
block|}
name|memcpy
argument_list|(
name|curbuf
argument_list|,
name|resp
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|curbuf
operator|+=
name|srv
expr_stmt|;
name|length
operator|-=
name|srv
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|egd_socket
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|egd_socket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* We must have iterated through the list of sockets,          * and no go. Return the errno.          */
return|return
name|bad_errno
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_TRUERAND
argument_list|)
comment|/* use truerand */
specifier|extern
name|int
name|randbyte
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* from the truerand library */
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* this will increase the startup time of the server, unfortunately...      * (generating 20 bytes takes about 8 seconds)      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|length
condition|;
name|idx
operator|++
control|)
name|buf
index|[
name|idx
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|randbyte
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_RANDOM */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|STR
end_undef

begin_undef
undef|#
directive|undef
name|XSTR
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_include
include|#
directive|include
file|"randbyte_os2.inc"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_RANDOM */
end_comment

end_unit

