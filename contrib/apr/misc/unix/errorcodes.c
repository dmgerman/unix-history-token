begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_misc.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_dso.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_NETDB_H
end_if

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLFCN_H
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * stuffbuffer - like apr_cpystrn() but returns the address of the  * dest buffer instead of the address of the terminating '\0'  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stuffbuffer
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|apr_cpystrn
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|apr_error_string
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|)
block|{
switch|switch
condition|(
name|statcode
condition|)
block|{
case|case
name|APR_ENOPOOL
case|:
return|return
literal|"A new pool could not be created."
return|;
case|case
name|APR_EBADDATE
case|:
return|return
literal|"An invalid date has been provided"
return|;
case|case
name|APR_EINVALSOCK
case|:
return|return
literal|"An invalid socket was returned"
return|;
case|case
name|APR_ENOPROC
case|:
return|return
literal|"No process was provided and one was required."
return|;
case|case
name|APR_ENOTIME
case|:
return|return
literal|"No time was provided and one was required."
return|;
case|case
name|APR_ENODIR
case|:
return|return
literal|"No directory was provided and one was required."
return|;
case|case
name|APR_ENOLOCK
case|:
return|return
literal|"No lock was provided and one was required."
return|;
case|case
name|APR_ENOPOLL
case|:
return|return
literal|"No poll structure was provided and one was required."
return|;
case|case
name|APR_ENOSOCKET
case|:
return|return
literal|"No socket was provided and one was required."
return|;
case|case
name|APR_ENOTHREAD
case|:
return|return
literal|"No thread was provided and one was required."
return|;
case|case
name|APR_ENOTHDKEY
case|:
return|return
literal|"No thread key structure was provided and one was required."
return|;
case|case
name|APR_ENOSHMAVAIL
case|:
return|return
literal|"No shared memory is currently available"
return|;
case|case
name|APR_EDSOOPEN
case|:
if|#
directive|if
name|APR_HAS_DSO
operator|&&
name|defined
argument_list|(
name|HAVE_LIBDL
argument_list|)
return|return
name|dlerror
argument_list|()
return|;
else|#
directive|else
return|return
literal|"DSO load failed"
return|;
endif|#
directive|endif
comment|/* HAVE_LIBDL */
case|case
name|APR_EBADIP
case|:
return|return
literal|"The specified IP address is invalid."
return|;
case|case
name|APR_EBADMASK
case|:
return|return
literal|"The specified network mask is invalid."
return|;
case|case
name|APR_INCHILD
case|:
return|return
literal|"Your code just forked, and you are currently executing in the "
literal|"child process"
return|;
case|case
name|APR_INPARENT
case|:
return|return
literal|"Your code just forked, and you are currently executing in the "
literal|"parent process"
return|;
case|case
name|APR_DETACH
case|:
return|return
literal|"The specified thread is detached"
return|;
case|case
name|APR_NOTDETACH
case|:
return|return
literal|"The specified thread is not detached"
return|;
case|case
name|APR_CHILD_DONE
case|:
return|return
literal|"The specified child process is done executing"
return|;
case|case
name|APR_CHILD_NOTDONE
case|:
return|return
literal|"The specified child process is not done executing"
return|;
case|case
name|APR_TIMEUP
case|:
return|return
literal|"The timeout specified has expired"
return|;
case|case
name|APR_INCOMPLETE
case|:
return|return
literal|"Partial results are valid but processing is incomplete"
return|;
case|case
name|APR_BADCH
case|:
return|return
literal|"Bad character specified on command line"
return|;
case|case
name|APR_BADARG
case|:
return|return
literal|"Missing parameter for the specified command line option"
return|;
case|case
name|APR_EOF
case|:
return|return
literal|"End of file found"
return|;
case|case
name|APR_NOTFOUND
case|:
return|return
literal|"Could not find specified socket in poll list."
return|;
case|case
name|APR_ANONYMOUS
case|:
return|return
literal|"Shared memory is implemented anonymously"
return|;
case|case
name|APR_FILEBASED
case|:
return|return
literal|"Shared memory is implemented using files"
return|;
case|case
name|APR_KEYBASED
case|:
return|return
literal|"Shared memory is implemented using a key system"
return|;
case|case
name|APR_EINIT
case|:
return|return
literal|"There is no error, this value signifies an initialized "
literal|"error code"
return|;
case|case
name|APR_ENOTIMPL
case|:
return|return
literal|"This function has not been implemented on this platform"
return|;
case|case
name|APR_EMISMATCH
case|:
return|return
literal|"passwords do not match"
return|;
case|case
name|APR_EABSOLUTE
case|:
return|return
literal|"The given path is absolute"
return|;
case|case
name|APR_ERELATIVE
case|:
return|return
literal|"The given path is relative"
return|;
case|case
name|APR_EINCOMPLETE
case|:
return|return
literal|"The given path is incomplete"
return|;
case|case
name|APR_EABOVEROOT
case|:
return|return
literal|"The given path was above the root path"
return|;
case|case
name|APR_EBADPATH
case|:
return|return
literal|"The given path is misformatted or contained invalid characters"
return|;
case|case
name|APR_EPATHWILD
case|:
return|return
literal|"The given path contained wildcard characters"
return|;
case|case
name|APR_EPROC_UNKNOWN
case|:
return|return
literal|"The process is not recognized."
return|;
case|case
name|APR_EGENERAL
case|:
return|return
literal|"Internal error"
return|;
default|default:
return|return
literal|"Error string not specified yet"
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
name|int
name|apr_canonical_error
parameter_list|(
name|apr_status_t
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|apr_os_strerror
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|char
name|result
index|[
literal|200
index|]
decl_stmt|;
name|unsigned
name|char
name|message
index|[
name|HUGE_STRING_LEN
index|]
decl_stmt|;
name|ULONG
name|len
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|err
operator|>=
literal|10000
operator|&&
name|err
operator|<
literal|12000
condition|)
block|{
comment|/* socket error codes */
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|strerror
argument_list|(
name|apr_canonical_error
argument_list|(
name|err
operator|+
name|APR_OS_START_SYSERR
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|DosGetMessage
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|message
argument_list|,
name|HUGE_STRING_LEN
argument_list|,
name|err
argument_list|,
literal|"OSO001.MSG"
argument_list|,
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|message
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|result
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|result
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|len
condition|;
name|c
operator|++
control|)
block|{
comment|/* skip multiple whitespace */
while|while
condition|(
name|apr_isspace
argument_list|(
name|message
index|[
name|c
index|]
argument_list|)
operator|&&
name|apr_isspace
argument_list|(
name|message
index|[
name|c
operator|+
literal|1
index|]
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
operator|*
operator|(
name|pos
operator|++
operator|)
operator|=
name|apr_isspace
argument_list|(
name|message
index|[
name|c
index|]
argument_list|)
condition|?
literal|' '
else|:
name|message
index|[
name|c
index|]
expr_stmt|;
block|}
operator|*
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"OS/2 error %d"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Stuff the string into the caller supplied buffer, then return     * a pointer to it.    */
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|NETWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WINSOCK
argument_list|)
operator|)
end_elif

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|apr_status_t
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|}
name|gaErrorList
index|[]
init|=
block|{
block|{
name|WSAEINTR
block|,
literal|"Interrupted system call"
block|}
block|,
block|{
name|WSAEBADF
block|,
literal|"Bad file number"
block|}
block|,
block|{
name|WSAEACCES
block|,
literal|"Permission denied"
block|}
block|,
block|{
name|WSAEFAULT
block|,
literal|"Bad address"
block|}
block|,
block|{
name|WSAEINVAL
block|,
literal|"Invalid argument"
block|}
block|,
block|{
name|WSAEMFILE
block|,
literal|"Too many open sockets"
block|}
block|,
block|{
name|WSAEWOULDBLOCK
block|,
literal|"Operation would block"
block|}
block|,
block|{
name|WSAEINPROGRESS
block|,
literal|"Operation now in progress"
block|}
block|,
block|{
name|WSAEALREADY
block|,
literal|"Operation already in progress"
block|}
block|,
block|{
name|WSAENOTSOCK
block|,
literal|"Socket operation on non-socket"
block|}
block|,
block|{
name|WSAEDESTADDRREQ
block|,
literal|"Destination address required"
block|}
block|,
block|{
name|WSAEMSGSIZE
block|,
literal|"Message too long"
block|}
block|,
block|{
name|WSAEPROTOTYPE
block|,
literal|"Protocol wrong type for socket"
block|}
block|,
block|{
name|WSAENOPROTOOPT
block|,
literal|"Bad protocol option"
block|}
block|,
block|{
name|WSAEPROTONOSUPPORT
block|,
literal|"Protocol not supported"
block|}
block|,
block|{
name|WSAESOCKTNOSUPPORT
block|,
literal|"Socket type not supported"
block|}
block|,
block|{
name|WSAEOPNOTSUPP
block|,
literal|"Operation not supported on socket"
block|}
block|,
block|{
name|WSAEPFNOSUPPORT
block|,
literal|"Protocol family not supported"
block|}
block|,
block|{
name|WSAEAFNOSUPPORT
block|,
literal|"Address family not supported"
block|}
block|,
block|{
name|WSAEADDRINUSE
block|,
literal|"Address already in use"
block|}
block|,
block|{
name|WSAEADDRNOTAVAIL
block|,
literal|"Can't assign requested address"
block|}
block|,
block|{
name|WSAENETDOWN
block|,
literal|"Network is down"
block|}
block|,
block|{
name|WSAENETUNREACH
block|,
literal|"Network is unreachable"
block|}
block|,
block|{
name|WSAENETRESET
block|,
literal|"Net connection reset"
block|}
block|,
block|{
name|WSAECONNABORTED
block|,
literal|"Software caused connection abort"
block|}
block|,
block|{
name|WSAECONNRESET
block|,
literal|"Connection reset by peer"
block|}
block|,
block|{
name|WSAENOBUFS
block|,
literal|"No buffer space available"
block|}
block|,
block|{
name|WSAEISCONN
block|,
literal|"Socket is already connected"
block|}
block|,
block|{
name|WSAENOTCONN
block|,
literal|"Socket is not connected"
block|}
block|,
block|{
name|WSAESHUTDOWN
block|,
literal|"Can't send after socket shutdown"
block|}
block|,
block|{
name|WSAETOOMANYREFS
block|,
literal|"Too many references, can't splice"
block|}
block|,
block|{
name|WSAETIMEDOUT
block|,
literal|"Connection timed out"
block|}
block|,
block|{
name|WSAECONNREFUSED
block|,
literal|"Connection refused"
block|}
block|,
block|{
name|WSAELOOP
block|,
literal|"Too many levels of symbolic links"
block|}
block|,
block|{
name|WSAENAMETOOLONG
block|,
literal|"File name too long"
block|}
block|,
block|{
name|WSAEHOSTDOWN
block|,
literal|"Host is down"
block|}
block|,
block|{
name|WSAEHOSTUNREACH
block|,
literal|"No route to host"
block|}
block|,
block|{
name|WSAENOTEMPTY
block|,
literal|"Directory not empty"
block|}
block|,
block|{
name|WSAEPROCLIM
block|,
literal|"Too many processes"
block|}
block|,
block|{
name|WSAEUSERS
block|,
literal|"Too many users"
block|}
block|,
block|{
name|WSAEDQUOT
block|,
literal|"Disc quota exceeded"
block|}
block|,
block|{
name|WSAESTALE
block|,
literal|"Stale NFS file handle"
block|}
block|,
block|{
name|WSAEREMOTE
block|,
literal|"Too many levels of remote in path"
block|}
block|,
block|{
name|WSASYSNOTREADY
block|,
literal|"Network system is unavailable"
block|}
block|,
block|{
name|WSAVERNOTSUPPORTED
block|,
literal|"Winsock version out of range"
block|}
block|,
block|{
name|WSANOTINITIALISED
block|,
literal|"WSAStartup not yet called"
block|}
block|,
block|{
name|WSAEDISCON
block|,
literal|"Graceful shutdown in progress"
block|}
block|,
block|{
name|WSAHOST_NOT_FOUND
block|,
literal|"Host not found"
block|}
block|,
block|{
name|WSANO_DATA
block|,
literal|"No host data of that type was found"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|apr_os_strerror
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|apr_status_t
name|errcode
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|NETWARE
ifndef|#
directive|ifndef
name|_WIN32_WCE
name|len
operator|=
name|FormatMessageA
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|errcode
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
comment|/* Default language */
name|buf
argument_list|,
operator|(
name|DWORD
operator|)
name|bufsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _WIN32_WCE speaks unicode */
name|LPTSTR
name|msg
init|=
operator|(
name|LPTSTR
operator|)
name|buf
decl_stmt|;
name|len
operator|=
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|errcode
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
comment|/* Default language */
name|msg
argument_list|,
call|(
name|DWORD
call|)
argument_list|(
name|bufsize
operator|/
sizeof|sizeof
argument_list|(
name|TCHAR
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* in-place convert to US-ASCII, substituting '?' for non ASCII   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msg
index|[
name|i
index|]
operator|<
literal|0x80
operator|&&
name|msg
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|msg
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|len
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gaErrorList
index|[
name|i
index|]
operator|.
name|msg
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gaErrorList
index|[
name|i
index|]
operator|.
name|code
operator|==
name|errcode
condition|)
block|{
name|apr_cpystrn
argument_list|(
name|buf
argument_list|,
name|gaErrorList
index|[
name|i
index|]
operator|.
name|msg
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|len
condition|)
block|{
comment|/* FormatMessage put the message in the buffer, but it may          * have embedded a newline (\r\n), and possible more than one.          * Remove the newlines replacing them with a space. This is not          * as visually perfect as moving all the remaining message over,          * but more efficient.          */
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Windows didn't provide us with a message.  Even stuff like                    * WSAECONNREFUSED won't get a message.          */
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"Unrecognized Win32 error code %d"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* On Unix, apr_os_strerror() handles error codes from the resolver   * (h_errno).   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|apr_os_strerror
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|,
name|int
name|err
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_HSTRERROR
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|hstrerror
argument_list|(
name|err
argument_list|)
argument_list|)
return|;
else|#
directive|else
comment|/* HAVE_HSTRERROR */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|msg
operator|=
literal|"Unknown host"
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|NO_DATA
argument_list|)
case|case
name|NO_DATA
case|:
if|#
directive|if
name|defined
argument_list|(
name|NO_ADDRESS
argument_list|)
operator|&&
operator|(
name|NO_DATA
operator|!=
name|NO_ADDRESS
operator|)
case|case
name|NO_ADDRESS
case|:
endif|#
directive|endif
name|msg
operator|=
literal|"No address for host"
expr_stmt|;
break|break;
elif|#
directive|elif
name|defined
argument_list|(
name|NO_ADDRESS
argument_list|)
case|case
name|NO_ADDRESS
case|:
name|msg
operator|=
literal|"No address for host"
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NO_DATA */
default|default:
name|msg
operator|=
literal|"Unrecognized resolver error"
expr_stmt|;
block|}
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|msg
argument_list|)
return|;
endif|#
directive|endif
comment|/* HAVE_STRERROR */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRERROR_R
argument_list|)
operator|&&
name|defined
argument_list|(
name|STRERROR_R_RC_INT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
end_if

begin_comment
comment|/* AIX and Tru64 style */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|native_strerror
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|)
block|{
if|if
condition|(
name|strerror_r
argument_list|(
name|statcode
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"APR does not understand this error code"
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|buf
return|;
block|}
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRERROR_R
argument_list|)
end_elif

begin_comment
comment|/* glibc style */
end_comment

begin_comment
comment|/* BeOS has the function available, but it doesn't provide  * the prototype publically (doh!), so to avoid a build warning  * we add a suitable prototype here.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BEOS
argument_list|)
end_if

begin_function_decl
specifier|const
name|char
modifier|*
name|strerror_r
parameter_list|(
name|apr_status_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|apr_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|native_strerror
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|msg
operator|=
name|strerror_r
argument_list|(
name|statcode
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* libc didn't use our buffer */
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|msg
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|buf
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* plain old strerror();   * thread-safe on some platforms (e.g., Solaris, OS/390)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|native_strerror
parameter_list|(
name|apr_status_t
name|statcode
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|bufsize
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32_WCE
specifier|static
name|char
name|err
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|err
argument_list|,
literal|"Native Error #%d"
argument_list|,
name|statcode
argument_list|)
expr_stmt|;
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|err
argument_list|)
return|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|statcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|err
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"APR does not understand this error code"
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|APR_DECLARE
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_strerror
argument_list|(
argument|apr_status_t statcode
argument_list|,
argument|char *buf
argument_list|,
argument|apr_size_t bufsize
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|statcode
operator|<
name|APR_OS_START_ERROR
condition|)
block|{
return|return
name|native_strerror
argument_list|(
name|statcode
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|statcode
operator|<
name|APR_OS_START_USERERR
condition|)
block|{
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|apr_error_string
argument_list|(
name|statcode
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|statcode
operator|<
name|APR_OS_START_EAIERR
condition|)
block|{
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"APR does not understand this error code"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|statcode
operator|<
name|APR_OS_START_SYSERR
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GAI_STRERROR
argument_list|)
name|statcode
operator|-=
name|APR_OS_START_EAIERR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NEGATIVE_EAI
argument_list|)
name|statcode
operator|=
operator|-
name|statcode
expr_stmt|;
endif|#
directive|endif
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|gai_strerror
argument_list|(
name|statcode
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|stuffbuffer
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"APR does not understand this error code"
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
name|apr_os_strerror
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|statcode
operator|-
name|APR_OS_START_SYSERR
argument_list|)
return|;
block|}
block|}
end_block

end_unit

