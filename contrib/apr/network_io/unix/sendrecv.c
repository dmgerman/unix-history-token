begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_networkio.h"
end_include

begin_include
include|#
directive|include
file|"apr_support.h"
end_include

begin_if
if|#
directive|if
name|APR_HAS_SENDFILE
end_if

begin_comment
comment|/* This file is needed to allow us access to the apr_file_t internals. */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_file_io.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_SENDFILE */
end_comment

begin_comment
comment|/* osreldate.h is only needed on FreeBSD for sendfile detection */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|apr_status_t
name|apr_socket_send
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_ssize_t
name|rv
decl_stmt|;
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
goto|goto
name|do_select
goto|;
block|}
do|do
block|{
name|rv
operator|=
name|write
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
decl_stmt|;
name|do_select
label|:
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|write
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
if|if
condition|(
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
name|rv
operator|<
operator|*
name|len
operator|)
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|rv
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|apr_socket_recv
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_ssize_t
name|rv
decl_stmt|;
name|apr_status_t
name|arv
decl_stmt|;
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_READ
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_READ
expr_stmt|;
goto|goto
name|do_select
goto|;
block|}
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|do_select
label|:
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
operator|*
name|len
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
if|if
condition|(
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
name|rv
operator|<
operator|*
name|len
operator|)
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_READ
expr_stmt|;
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|rv
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
return|return
name|APR_EOF
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|apr_socket_sendto
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_sockaddr_t
modifier|*
name|where
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_ssize_t
name|rv
decl_stmt|;
do|do
block|{
name|rv
operator|=
name|sendto
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|,
name|flags
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|where
operator|->
name|sa
argument_list|,
name|where
operator|->
name|salen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
init|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|sendto
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|,
name|flags
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|where
operator|->
name|sa
argument_list|,
name|where
operator|->
name|salen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
operator|*
name|len
operator|=
name|rv
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|apr_socket_recvfrom
parameter_list|(
name|apr_sockaddr_t
modifier|*
name|from
parameter_list|,
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_ssize_t
name|rv
decl_stmt|;
name|from
operator|->
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|from
operator|->
name|sa
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|recvfrom
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
operator|->
name|sa
argument_list|,
operator|&
name|from
operator|->
name|salen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
init|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|recvfrom
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|buf
argument_list|,
operator|(
operator|*
name|len
operator|)
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
operator|->
name|sa
argument_list|,
operator|&
name|from
operator|->
name|salen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
operator|*
name|len
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
comment|/*      * Check if we have a valid address. recvfrom() with MSG_PEEK may return      * success without filling in the address.      */
if|if
condition|(
name|from
operator|->
name|salen
operator|>
name|APR_OFFSETOF
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_port
argument_list|)
condition|)
block|{
name|apr_sockaddr_vars_set
argument_list|(
name|from
argument_list|,
name|from
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_family
argument_list|,
name|ntohs
argument_list|(
name|from
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|rv
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|sock
operator|->
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
return|return
name|APR_EOF
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
name|apr_status_t
name|apr_socket_sendv
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
specifier|const
name|struct
name|iovec
modifier|*
name|vec
parameter_list|,
name|apr_int32_t
name|nvec
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_WRITEV
name|apr_ssize_t
name|rv
decl_stmt|;
name|apr_size_t
name|requested_len
init|=
literal|0
decl_stmt|;
name|apr_int32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvec
condition|;
name|i
operator|++
control|)
block|{
name|requested_len
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
goto|goto
name|do_select
goto|;
block|}
do|do
block|{
name|rv
operator|=
name|writev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|vec
argument_list|,
name|nvec
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
decl_stmt|;
name|do_select
label|:
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|writev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|vec
argument_list|,
name|nvec
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
if|if
condition|(
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
name|rv
operator|<
name|requested_len
operator|)
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|rv
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
else|#
directive|else
operator|*
name|len
operator|=
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
return|return
name|apr_socket_send
argument_list|(
name|sock
argument_list|,
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
name|len
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_SENDFILE
end_if

begin_comment
comment|/* TODO: Verify that all platforms handle the fd the same way,  * i.e. that they don't move the file pointer.  */
end_comment

begin_comment
comment|/* TODO: what should flags be?  int_32? */
end_comment

begin_comment
comment|/* Define a structure to pass in when we have a NULL header value */
end_comment

begin_decl_stmt
specifier|static
name|apr_hdtr_t
name|no_hdtr
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNU__
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|HAVE_WRITEV
argument_list|)
end_if

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|nbytes
init|=
literal|0
decl_stmt|,
name|total_hdrbytes
decl_stmt|,
name|i
decl_stmt|;
name|apr_status_t
name|arv
decl_stmt|;
if|#
directive|if
name|APR_HAS_LARGE_FILES
operator|&&
name|defined
argument_list|(
name|HAVE_SENDFILE64
argument_list|)
name|apr_off_t
name|off
init|=
operator|*
name|offset
decl_stmt|;
define|#
directive|define
name|sendfile
value|sendfile64
elif|#
directive|elif
name|APR_HAS_LARGE_FILES
operator|&&
name|SIZEOF_OFF_T
operator|==
literal|4
comment|/* 64-bit apr_off_t but no sendfile64(): fail if trying to send      * past the 2Gb limit. */
name|off_t
name|off
decl_stmt|;
if|if
condition|(
operator|(
name|apr_int64_t
operator|)
operator|*
name|offset
operator|+
operator|*
name|len
operator|>
name|INT_MAX
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|off
operator|=
operator|*
name|offset
expr_stmt|;
else|#
directive|else
name|off_t
name|off
init|=
operator|*
name|offset
decl_stmt|;
comment|/* Multiple reports have shown sendfile failing with EINVAL if      * passed a>=2Gb count value on some 64-bit kernels.  It won't      * noticably hurt performance to limit each call to<2Gb at a      * time, so avoid that issue here: */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|==
literal|8
operator|&&
operator|*
name|len
operator|>
name|INT_MAX
condition|)
block|{
operator|*
name|len
operator|=
name|INT_MAX
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
if|if
condition|(
name|hdtr
operator|->
name|numheaders
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|hdrbytes
decl_stmt|;
comment|/* cork before writing headers */
name|rv
operator|=
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
comment|/* Now write the headers */
name|arv
operator|=
name|apr_socket_sendv
argument_list|(
name|sock
argument_list|,
name|hdtr
operator|->
name|headers
argument_list|,
name|hdtr
operator|->
name|numheaders
argument_list|,
operator|&
name|hdrbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
name|nbytes
operator|+=
name|hdrbytes
expr_stmt|;
comment|/* If this was a partial write and we aren't doing timeouts,           * return now with the partial byte count; this is a non-blocking           * socket.          */
name|total_hdrbytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|total_hdrbytes
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|if
condition|(
name|hdrbytes
operator|<
name|total_hdrbytes
condition|)
block|{
operator|*
name|len
operator|=
name|hdrbytes
expr_stmt|;
return|return
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
goto|goto
name|do_select
goto|;
block|}
do|do
block|{
name|rv
operator|=
name|sendfile
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket */
name|file
operator|->
name|filedes
argument_list|,
comment|/* open file descriptor of the file to be sent */
operator|&
name|off
argument_list|,
comment|/* where in the file to start */
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* number of bytes to send */
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|do_select
label|:
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|sendfile
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket */
name|file
operator|->
name|filedes
argument_list|,
comment|/* open file descriptor of the file to be sent */
operator|&
name|off
argument_list|,
comment|/* where in the file to start */
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* number of bytes to send */
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
name|nbytes
expr_stmt|;
name|rv
operator|=
name|errno
expr_stmt|;
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|nbytes
operator|+=
name|rv
expr_stmt|;
if|if
condition|(
name|rv
operator|<
operator|*
name|len
condition|)
block|{
operator|*
name|len
operator|=
name|nbytes
expr_stmt|;
name|arv
operator|=
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>
literal|0
condition|)
block|{
comment|/* If this was a partial write, return now with the               * partial byte count;  this is a non-blocking socket.              */
if|if
condition|(
name|sock
operator|->
name|timeout
operator|>
literal|0
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
return|return
name|arv
return|;
block|}
else|else
block|{
comment|/* If the file got smaller mid-request, eventually the offset              * becomes equal to the new file size and the kernel returns 0.                * Make this an error so the caller knows to log something and              * exit.              */
return|return
name|APR_EOF
return|;
block|}
block|}
comment|/* Now write the footers */
if|if
condition|(
name|hdtr
operator|->
name|numtrailers
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|trbytes
decl_stmt|;
name|arv
operator|=
name|apr_socket_sendv
argument_list|(
name|sock
argument_list|,
name|hdtr
operator|->
name|trailers
argument_list|,
name|hdtr
operator|->
name|numtrailers
argument_list|,
operator|&
name|trbytes
argument_list|)
expr_stmt|;
name|nbytes
operator|+=
name|trbytes
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
name|nbytes
expr_stmt|;
name|rv
operator|=
name|errno
expr_stmt|;
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_TCP_NOPUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|=
name|nbytes
expr_stmt|;
return|return
name|rv
operator|<
literal|0
condition|?
name|errno
else|:
name|APR_SUCCESS
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|DARWIN
argument_list|)
end_elif

begin_comment
comment|/* OS/X Release 10.5 or greater */
end_comment

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|apr_off_t
name|nbytes
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|bytes_to_send
init|=
operator|*
name|len
decl_stmt|;
name|apr_off_t
name|bytes_sent
init|=
literal|0
decl_stmt|;
name|apr_status_t
name|arv
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* Ignore flags for now. */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
comment|/* OS X can send the headers/footers as part of the system call,       * but how it counts bytes isn't documented properly. We use       * apr_socket_sendv() instead.      */
if|if
condition|(
name|hdtr
operator|->
name|numheaders
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|hbytes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now write the headers */
name|arv
operator|=
name|apr_socket_sendv
argument_list|(
name|sock
argument_list|,
name|hdtr
operator|->
name|headers
argument_list|,
name|hdtr
operator|->
name|numheaders
argument_list|,
operator|&
name|hbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
name|bytes_sent
operator|=
name|hbytes
expr_stmt|;
name|hbytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|hbytes
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|if
condition|(
name|bytes_sent
operator|<
name|hbytes
condition|)
block|{
operator|*
name|len
operator|=
name|bytes_sent
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
do|do
block|{
if|if
condition|(
operator|!
name|bytes_to_send
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|apr_status_t
name|arv
decl_stmt|;
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
block|}
name|nbytes
operator|=
name|bytes_to_send
expr_stmt|;
name|rv
operator|=
name|sendfile
argument_list|(
name|file
operator|->
name|filedes
argument_list|,
comment|/* file to be sent */
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket */
operator|*
name|offset
argument_list|,
comment|/* where in the file to start */
operator|&
name|nbytes
argument_list|,
comment|/* number of bytes to write/written */
name|NULL
argument_list|,
comment|/* Headers/footers */
name|flags
argument_list|)
expr_stmt|;
comment|/* undefined, set to 0 */
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|timeout
operator|>
literal|0
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
comment|/* BSD's sendfile can return -1/EAGAIN even if it                  * sent bytes.  Sanitize the result so we get normal EAGAIN                  * semantics w.r.t. bytes sent.                  */
if|if
condition|(
name|nbytes
condition|)
block|{
name|bytes_sent
operator|+=
name|nbytes
expr_stmt|;
comment|/* normal exit for a big file& non-blocking io */
operator|(
operator|*
name|len
operator|)
operator|=
name|bytes_sent
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* rv == 0 (or the kernel is broken) */
name|bytes_sent
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* Most likely the file got smaller after the stat.                  * Return an error so the caller can do the Right Thing.                  */
operator|(
operator|*
name|len
operator|)
operator|=
name|bytes_sent
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
block|}
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
do|;
comment|/* Now write the footers */
if|if
condition|(
name|hdtr
operator|->
name|numtrailers
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|tbytes
decl_stmt|;
name|arv
operator|=
name|apr_socket_sendv
argument_list|(
name|sock
argument_list|,
name|hdtr
operator|->
name|trailers
argument_list|,
name|hdtr
operator|->
name|numtrailers
argument_list|,
operator|&
name|tbytes
argument_list|)
expr_stmt|;
name|bytes_sent
operator|+=
name|tbytes
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
name|bytes_sent
expr_stmt|;
name|rv
operator|=
name|errno
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|bytes_sent
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
end_elif

begin_comment
comment|/* Release 3.1 or greater */
end_comment

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|off_t
name|nbytes
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|<
literal|460001
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|struct
name|sf_hdtr
name|headerstruct
decl_stmt|;
name|apr_size_t
name|bytes_to_send
init|=
operator|*
name|len
decl_stmt|;
comment|/* Ignore flags for now. */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|<
literal|460001
elseif|else
if|if
condition|(
name|hdtr
operator|->
name|numheaders
condition|)
block|{
comment|/* On early versions of FreeBSD sendfile, the number of bytes to send           * must include the length of the headers.  Don't look at the man page           * for this :(  Instead, look at the logic in           * src/sys/kern/uipc_syscalls::sendfile().          *          * This was fixed in the middle of 4.6-STABLE          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|bytes_to_send
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|headerstruct
operator|.
name|headers
operator|=
name|hdtr
operator|->
name|headers
expr_stmt|;
name|headerstruct
operator|.
name|hdr_cnt
operator|=
name|hdtr
operator|->
name|numheaders
expr_stmt|;
name|headerstruct
operator|.
name|trailers
operator|=
name|hdtr
operator|->
name|trailers
expr_stmt|;
name|headerstruct
operator|.
name|trl_cnt
operator|=
name|hdtr
operator|->
name|numtrailers
expr_stmt|;
comment|/* FreeBSD can send the headers/footers as part of the system call */
do|do
block|{
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|apr_status_t
name|arv
decl_stmt|;
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
block|}
if|if
condition|(
name|bytes_to_send
condition|)
block|{
comment|/* We won't dare call sendfile() if we don't have              * header or file bytes to send because bytes_to_send == 0              * means send the whole file.              */
name|rv
operator|=
name|sendfile
argument_list|(
name|file
operator|->
name|filedes
argument_list|,
comment|/* file to be sent */
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket */
operator|*
name|offset
argument_list|,
comment|/* where in the file to start */
name|bytes_to_send
argument_list|,
comment|/* number of bytes to send */
operator|&
name|headerstruct
argument_list|,
comment|/* Headers/footers */
operator|&
name|nbytes
argument_list|,
comment|/* number of bytes written */
name|flags
argument_list|)
expr_stmt|;
comment|/* undefined, set to 0 */
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|timeout
operator|>
literal|0
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
comment|/* FreeBSD's sendfile can return -1/EAGAIN even if it                      * sent bytes.  Sanitize the result so we get normal EAGAIN                      * semantics w.r.t. bytes sent.                      */
if|if
condition|(
name|nbytes
condition|)
block|{
comment|/* normal exit for a big file& non-blocking io */
operator|(
operator|*
name|len
operator|)
operator|=
name|nbytes
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* rv == 0 (or the kernel is broken) */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* Most likely the file got smaller after the stat.                      * Return an error so the caller can do the Right Thing.                      */
operator|(
operator|*
name|len
operator|)
operator|=
name|nbytes
expr_stmt|;
return|return
name|APR_EOF
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* just trailer bytes... use writev()              */
name|rv
operator|=
name|writev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|hdtr
operator|->
name|trailers
argument_list|,
name|hdtr
operator|->
name|numtrailers
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|rv
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
init|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
block|}
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
do|;
operator|(
operator|*
name|len
operator|)
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux__
argument_list|)
end_elif

begin_comment
comment|/* HP cc in ANSI mode defines __hpux; gcc defines __hpux__ */
end_comment

begin_comment
comment|/* HP-UX Version 10.30 or greater  * (no worries, because we only get here if autoconfiguration found sendfile)  */
end_comment

begin_comment
comment|/* ssize_t sendfile(int s, int fd, off_t offset, size_t nbytes,  *                  const struct iovec *hdtrl, int flags);  *  * nbytes is the number of bytes to send just from the file; as with FreeBSD,   * if nbytes == 0, the rest of the file (from offset) is sent  */
end_comment

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_ssize_t
name|rc
decl_stmt|;
name|apr_size_t
name|nbytes
init|=
operator|*
name|len
decl_stmt|,
name|headerlen
decl_stmt|,
name|trailerlen
decl_stmt|;
name|struct
name|iovec
name|hdtrarray
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|headerbuf
decl_stmt|,
modifier|*
name|trailerbuf
decl_stmt|;
if|#
directive|if
name|APR_HAS_LARGE_FILES
operator|&&
name|defined
argument_list|(
name|HAVE_SENDFILE64
argument_list|)
comment|/* later HP-UXes have a sendfile64() */
define|#
directive|define
name|sendfile
value|sendfile64
name|apr_off_t
name|off
init|=
operator|*
name|offset
decl_stmt|;
elif|#
directive|elif
name|APR_HAS_LARGE_FILES
operator|&&
name|SIZEOF_OFF_T
operator|==
literal|4
comment|/* HP-UX 11.00 doesn't have a sendfile64(): fail if trying to send      * past the 2Gb limit */
name|off_t
name|off
decl_stmt|;
if|if
condition|(
operator|(
name|apr_int64_t
operator|)
operator|*
name|offset
operator|+
operator|*
name|len
operator|>
name|INT_MAX
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|off
operator|=
operator|*
name|offset
expr_stmt|;
else|#
directive|else
name|apr_off_t
name|off
init|=
operator|*
name|offset
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
comment|/* Ignore flags for now. */
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* HP-UX can only send one header iovec and one footer iovec; try to      * only allocate storage to combine input iovecs when we really have to      */
switch|switch
condition|(
name|hdtr
operator|->
name|numheaders
condition|)
block|{
case|case
literal|0
case|:
name|hdtrarray
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|hdtrarray
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hdtrarray
index|[
literal|0
index|]
operator|=
name|hdtr
operator|->
name|headers
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|headerlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|headerlen
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* XXX:  BUHHH? wow, what a memory leak! */
name|headerbuf
operator|=
name|hdtrarray
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|apr_palloc
argument_list|(
name|sock
operator|->
name|pool
argument_list|,
name|headerlen
argument_list|)
expr_stmt|;
name|hdtrarray
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|headerlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|headerbuf
argument_list|,
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|headerbuf
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|hdtr
operator|->
name|numtrailers
condition|)
block|{
case|case
literal|0
case|:
name|hdtrarray
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|hdtrarray
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hdtrarray
index|[
literal|1
index|]
operator|=
name|hdtr
operator|->
name|trailers
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|trailerlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numtrailers
condition|;
name|i
operator|++
control|)
block|{
name|trailerlen
operator|+=
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* XXX:  BUHHH? wow, what a memory leak! */
name|trailerbuf
operator|=
name|hdtrarray
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|apr_palloc
argument_list|(
name|sock
operator|->
name|pool
argument_list|,
name|trailerlen
argument_list|)
expr_stmt|;
name|hdtrarray
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|trailerlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numtrailers
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|trailerbuf
argument_list|,
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|trailerbuf
operator|+=
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
block|}
do|do
block|{
if|if
condition|(
name|nbytes
condition|)
block|{
comment|/* any bytes to send from the file? */
name|rc
operator|=
name|sendfile
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket  */
name|file
operator|->
name|filedes
argument_list|,
comment|/* file descriptor to send */
name|off
argument_list|,
comment|/* where in the file to start */
name|nbytes
argument_list|,
comment|/* number of bytes to send from file */
name|hdtrarray
argument_list|,
comment|/* Headers/footers */
name|flags
argument_list|)
expr_stmt|;
comment|/* undefined, set to 0 */
block|}
else|else
block|{
comment|/* we can't call sendfile() with no bytes to send from the file */
name|rc
operator|=
name|writev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|hdtrarray
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rc
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|arv
init|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|nbytes
condition|)
block|{
name|rc
operator|=
name|sendfile
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
comment|/* socket  */
name|file
operator|->
name|filedes
argument_list|,
comment|/* file descriptor to send */
name|off
argument_list|,
comment|/* where in the file to start */
name|nbytes
argument_list|,
comment|/* number of bytes to send from file */
name|hdtrarray
argument_list|,
comment|/* Headers/footers */
name|flags
argument_list|)
expr_stmt|;
comment|/* undefined, set to 0 */
block|}
else|else
block|{
comment|/* we can't call sendfile() with no bytes to send from the file */
name|rc
operator|=
name|writev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|hdtrarray
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
comment|/* Set len to the number of bytes written */
operator|*
name|len
operator|=
name|rc
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
name|defined
argument_list|(
name|__MVS__
argument_list|)
end_elif

begin_comment
comment|/* AIX and OS/390 have the same send_file() interface.  *  * subtle differences:  *   AIX doesn't update the file ptr but OS/390 does  *  * availability (correctly determined by autoconf):  *  * AIX -  version 4.3.2 with APAR IX85388, or version 4.3.3 and above  * OS/390 - V2R7 and above  */
end_comment

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ptr
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|hbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|tbuf
init|=
name|NULL
decl_stmt|;
name|apr_status_t
name|arv
decl_stmt|;
name|struct
name|sf_parms
name|parms
decl_stmt|;
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
comment|/* Ignore flags for now. */
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* word to the wise: by default, AIX stores files sent by send_file()      * in the network buffer cache...  there are supposedly scenarios      * where the most recent copy of the file won't be sent, but I can't      * recreate the potential problem, perhaps because of the way we      * use send_file()...  if you suspect such a problem, try turning      * on the SF_SYNC_CACHE flag      */
comment|/* AIX can also send the headers/footers as part of the system call */
name|parms
operator|.
name|header_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdtr
operator|&&
name|hdtr
operator|->
name|numheaders
condition|)
block|{
if|if
condition|(
name|hdtr
operator|->
name|numheaders
operator|==
literal|1
condition|)
block|{
name|parms
operator|.
name|header_data
operator|=
name|hdtr
operator|->
name|headers
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
name|parms
operator|.
name|header_length
operator|=
name|hdtr
operator|->
name|headers
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|parms
operator|.
name|header_length
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Keepalives make apr_palloc a bad idea */
block|hbuf = malloc(parms.header_length);
else|#
directive|else
comment|/* but headers are small, so maybe we can hold on to the              * memory for the life of the socket...              */
name|hbuf
operator|=
name|apr_palloc
argument_list|(
name|sock
operator|->
name|pool
argument_list|,
name|parms
operator|.
name|header_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hbuf
operator|+
name|ptr
argument_list|,
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|parms
operator|.
name|header_data
operator|=
name|hbuf
expr_stmt|;
block|}
block|}
else|else
name|parms
operator|.
name|header_data
operator|=
name|NULL
expr_stmt|;
name|parms
operator|.
name|trailer_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdtr
operator|&&
name|hdtr
operator|->
name|numtrailers
condition|)
block|{
if|if
condition|(
name|hdtr
operator|->
name|numtrailers
operator|==
literal|1
condition|)
block|{
name|parms
operator|.
name|trailer_data
operator|=
name|hdtr
operator|->
name|trailers
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
name|parms
operator|.
name|trailer_length
operator|=
name|hdtr
operator|->
name|trailers
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numtrailers
condition|;
name|i
operator|++
control|)
block|{
name|parms
operator|.
name|trailer_length
operator|+=
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Keepalives make apr_palloc a bad idea */
block|tbuf = malloc(parms.trailer_length);
else|#
directive|else
name|tbuf
operator|=
name|apr_palloc
argument_list|(
name|sock
operator|->
name|pool
argument_list|,
name|parms
operator|.
name|trailer_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numtrailers
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
operator|+
name|ptr
argument_list|,
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|parms
operator|.
name|trailer_data
operator|=
name|tbuf
expr_stmt|;
block|}
block|}
else|else
block|{
name|parms
operator|.
name|trailer_data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Whew! Headers and trailers set up. Now for the file data */
name|parms
operator|.
name|file_descriptor
operator|=
name|file
operator|->
name|filedes
expr_stmt|;
name|parms
operator|.
name|file_offset
operator|=
operator|*
name|offset
expr_stmt|;
name|parms
operator|.
name|file_bytes
operator|=
operator|*
name|len
expr_stmt|;
comment|/* O.K. All set up now. Let's go to town */
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
goto|goto
name|do_select
goto|;
block|}
do|do
block|{
name|rv
operator|=
name|send_file
argument_list|(
operator|&
operator|(
name|sock
operator|->
name|socketdes
operator|)
argument_list|,
comment|/* socket */
operator|&
operator|(
name|parms
operator|)
argument_list|,
comment|/* all data */
name|flags
argument_list|)
expr_stmt|;
comment|/* flags */
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
while|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|do_select
label|:
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
else|else
block|{
do|do
block|{
name|rv
operator|=
name|send_file
argument_list|(
operator|&
operator|(
name|sock
operator|->
name|socketdes
operator|)
argument_list|,
comment|/* socket */
operator|&
operator|(
name|parms
operator|)
argument_list|,
comment|/* all data */
name|flags
argument_list|)
expr_stmt|;
comment|/* flags */
block|}
do|while
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
operator|(
operator|*
name|len
operator|)
operator|=
name|parms
operator|.
name|bytes_sent
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Clean up after ourselves */
block|if(hbuf) free(hbuf);     if(tbuf) free(tbuf);
endif|#
directive|endif
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|errno
return|;
block|}
if|if
condition|(
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
name|parms
operator|.
name|bytes_sent
operator|<
operator|(
name|parms
operator|.
name|file_bytes
operator|+
name|parms
operator|.
name|header_length
operator|+
name|parms
operator|.
name|trailer_length
operator|)
operator|)
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha
argument_list|)
end_elif

begin_comment
comment|/* Tru64's sendfile implementation doesn't work, and we need to make sure that  * we don't use it until it is fixed.  If it is used as it is now, it will  * hang the machine and the only way to fix it is a reboot.  */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SENDFILEV
argument_list|)
end_elif

begin_comment
comment|/* Solaris 8's sendfilev() interface   *  * SFV_FD_SELF refers to our memory space.  *  * Required Sparc patches (or newer):  * 111297-01, 108528-09, 109472-06, 109234-03, 108995-02, 111295-01, 109025-03,  * 108991-13  * Required x86 patches (or newer):  * 111298-01, 108529-09, 109473-06, 109235-04, 108996-02, 111296-01, 109026-04,  * 108992-13  */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_LARGE_FILES
operator|&&
name|defined
argument_list|(
name|HAVE_SENDFILEV64
argument_list|)
end_if

begin_define
define|#
directive|define
name|sendfilevec_t
value|sendfilevec64_t
end_define

begin_define
define|#
directive|define
name|sendfilev
value|sendfilev64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|apr_status_t
name|apr_socket_sendfile
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hdtr_t
modifier|*
name|hdtr
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|,
name|arv
decl_stmt|;
name|apr_size_t
name|nbytes
decl_stmt|;
name|sendfilevec_t
modifier|*
name|sfv
decl_stmt|;
name|int
name|vecs
decl_stmt|,
name|curvec
decl_stmt|,
name|i
decl_stmt|,
name|repeat
decl_stmt|;
name|apr_size_t
name|requested_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|hdtr
condition|)
block|{
name|hdtr
operator|=
operator|&
name|no_hdtr
expr_stmt|;
block|}
comment|/* Ignore flags for now. */
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Calculate how much space we need. */
name|vecs
operator|=
name|hdtr
operator|->
name|numheaders
operator|+
name|hdtr
operator|->
name|numtrailers
operator|+
literal|1
expr_stmt|;
name|sfv
operator|=
name|apr_palloc
argument_list|(
name|sock
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|sendfilevec_t
argument_list|)
operator|*
name|vecs
argument_list|)
expr_stmt|;
name|curvec
operator|=
literal|0
expr_stmt|;
comment|/* Add the headers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numheaders
condition|;
name|i
operator|++
operator|,
name|curvec
operator|++
control|)
block|{
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_fd
operator|=
name|SFV_FD_SELF
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_flag
operator|=
literal|0
expr_stmt|;
comment|/* Cast to unsigned long to prevent sign extension of the          * pointer value for the LFS case; see PR 39463. */
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_off
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
operator|=
name|hdtr
operator|->
name|headers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|requested_len
operator|+=
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
expr_stmt|;
block|}
comment|/* If the len is 0, we skip the file. */
if|if
condition|(
operator|*
name|len
condition|)
block|{
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_fd
operator|=
name|file
operator|->
name|filedes
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_flag
operator|=
literal|0
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_off
operator|=
operator|*
name|offset
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
operator|=
operator|*
name|len
expr_stmt|;
name|requested_len
operator|+=
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
expr_stmt|;
name|curvec
operator|++
expr_stmt|;
block|}
else|else
block|{
name|vecs
operator|--
expr_stmt|;
block|}
comment|/* Add the footers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdtr
operator|->
name|numtrailers
condition|;
name|i
operator|++
operator|,
name|curvec
operator|++
control|)
block|{
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_fd
operator|=
name|SFV_FD_SELF
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_flag
operator|=
literal|0
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_off
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
operator|=
name|hdtr
operator|->
name|trailers
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|requested_len
operator|+=
name|sfv
index|[
name|curvec
index|]
operator|.
name|sfv_len
expr_stmt|;
block|}
comment|/* If the last write couldn't send all the requested data,      * wait for the socket to become writable before proceeding      */
if|if
condition|(
name|sock
operator|->
name|options
operator|&
name|APR_INCOMPLETE_WRITE
condition|)
block|{
name|sock
operator|->
name|options
operator|&=
operator|~
name|APR_INCOMPLETE_WRITE
expr_stmt|;
name|arv
operator|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arv
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|arv
return|;
block|}
block|}
comment|/* Actually do the sendfilev      *      * Solaris may return -1/EAGAIN even if it sent bytes on a non-block sock.      *      * If no bytes were originally sent (nbytes == 0) and we are on a TIMEOUT       * socket (which as far as the OS is concerned is a non-blocking socket),       * we want to retry after waiting for the other side to read the data (as       * determined by poll).  Once it is clear to send, we want to retry      * sending the sendfilevec_t once more.      */
name|arv
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Clear out the repeat */
name|repeat
operator|=
literal|0
expr_stmt|;
comment|/* socket, vecs, number of vecs, bytes written */
name|rv
operator|=
name|sendfilev
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
name|sfv
argument_list|,
name|vecs
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|nbytes
condition|)
block|{
name|rv
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|arv
operator|&&
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_status_t
name|t
init|=
name|apr_wait_for_io_or_timeout
argument_list|(
name|NULL
argument_list|,
name|sock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|APR_SUCCESS
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
name|arv
operator|=
literal|1
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|)
operator|||
name|repeat
condition|)
do|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|errno
return|;
block|}
comment|/* Update how much we sent */
operator|*
name|len
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* Most likely the file got smaller after the stat.          * Return an error so the caller can do the Right Thing.          */
return|return
name|APR_EOF
return|;
block|}
if|if
condition|(
operator|(
name|sock
operator|->
name|timeout
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|*
name|len
operator|<
name|requested_len
operator|)
condition|)
block|{
name|sock
operator|->
name|options
operator||=
name|APR_INCOMPLETE_WRITE
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|APR has detected sendfile on your system, but nobody has written a
end_error

begin_error
error|#
directive|error
error|version of it for APR yet.  To get past this, either write
end_error

begin_error
error|#
directive|error
error|apr_socket_sendfile or change APR_HAS_SENDFILE in apr.h to 0.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__, __FreeBSD__, __DragonFly__, __HPUX__, _AIX, __MVS__, 	  Tru64/OSF1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_SENDFILE */
end_comment

end_unit

