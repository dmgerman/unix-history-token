begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr_arch_networkio.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_struct
struct|struct
name|apr_ipsubnet_t
block|{
name|int
name|family
decl_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
name|apr_uint32_t
name|sub
index|[
literal|4
index|]
decl_stmt|;
comment|/* big enough for IPv4 and IPv6 addresses */
name|apr_uint32_t
name|mask
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
name|apr_uint32_t
name|sub
index|[
literal|1
index|]
decl_stmt|;
name|apr_uint32_t
name|mask
index|[
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NETWARE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SET_H_ERRNO
end_ifdef

begin_define
define|#
directive|define
name|SET_H_ERRNO
parameter_list|(
name|newval
parameter_list|)
value|set_h_errno(newval)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_H_ERRNO
parameter_list|(
name|newval
parameter_list|)
value|h_errno = (newval)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SET_H_ERRNO
parameter_list|(
name|newval
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETHOSTBYNAME_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETHOSTBYNAME_R
argument_list|)
end_if

begin_comment
comment|/* This is the maximum size that may be returned from the reentrant  * gethostbyname_r function.  If the system tries to use more, it  * should return ERANGE.  */
end_comment

begin_define
define|#
directive|define
name|GETHOSTBYNAME_BUFLEN
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/* Some levels of AIX getaddrinfo() don't like servname = "0", so  * set servname to "1" when port is 0 and fix it up later.  */
end_comment

begin_define
define|#
directive|define
name|AIX_SERVNAME_HACK
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AIX_SERVNAME_HACK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32_WCE
end_ifdef

begin_comment
comment|/* XXX: BS solution.  Need an HAVE_GETSERVBYNAME and actually  * do something here, to provide the obvious proto mappings.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|getservbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|apr_status_t
name|get_local_addr
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|sock
operator|->
name|local_addr
operator|->
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|local_addr
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sock
operator|->
name|local_addr
operator|->
name|sa
argument_list|,
operator|&
name|sock
operator|->
name|local_addr
operator|->
name|salen
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|apr_get_netos_error
argument_list|()
return|;
block|}
else|else
block|{
name|sock
operator|->
name|local_port_unknown
operator|=
name|sock
operator|->
name|local_interface_unknown
operator|=
literal|0
expr_stmt|;
comment|/* XXX assumes sin_port and sin6_port at same offset */
name|sock
operator|->
name|local_addr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|sock
operator|->
name|local_addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|get_remote_addr
parameter_list|(
name|apr_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|sock
operator|->
name|remote_addr
operator|->
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|remote_addr
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|sock
operator|->
name|socketdes
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sock
operator|->
name|remote_addr
operator|->
name|sa
argument_list|,
operator|&
name|sock
operator|->
name|remote_addr
operator|->
name|salen
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|apr_get_netos_error
argument_list|()
return|;
block|}
else|else
block|{
name|sock
operator|->
name|remote_addr_unknown
operator|=
literal|0
expr_stmt|;
comment|/* XXX assumes sin_port and sin6_port at same offset */
name|sock
operator|->
name|remote_addr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|sock
operator|->
name|remote_addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sockaddr_ip_getbuf
argument_list|(
argument|char *buf
argument_list|,
argument|apr_size_t buflen
argument_list|,
argument|apr_sockaddr_t *sockaddr
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|apr_inet_ntop
argument_list|(
name|sockaddr
operator|->
name|family
argument_list|,
name|sockaddr
operator|->
name|ipaddr_ptr
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
condition|)
block|{
return|return
name|APR_ENOSPC
return|;
block|}
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|sockaddr
operator|->
name|family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|sockaddr
operator|->
name|ipaddr_ptr
argument_list|)
operator|&&
name|buflen
operator|>
name|strlen
argument_list|(
literal|"::ffff:"
argument_list|)
condition|)
block|{
comment|/* This is an IPv4-mapped IPv6 address; drop the leading          * part of the address string so we're left with the familiar          * IPv4 format.          */
name|memmove
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
literal|"::ffff:"
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
literal|"::ffff:"
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ensure NUL termination if the buffer is too short */
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_sockaddr_ip_get
argument_list|(
argument|char **addr
argument_list|,
argument|apr_sockaddr_t *sockaddr
argument_list|)
end_macro

begin_block
block|{
operator|*
name|addr
operator|=
name|apr_palloc
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|sockaddr
operator|->
name|addr_str_len
argument_list|)
expr_stmt|;
return|return
name|apr_sockaddr_ip_getbuf
argument_list|(
operator|*
name|addr
argument_list|,
name|sockaddr
operator|->
name|addr_str_len
argument_list|,
name|sockaddr
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|apr_sockaddr_vars_set
parameter_list|(
name|apr_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|int
name|family
parameter_list|,
name|apr_port_t
name|port
parameter_list|)
block|{
name|addr
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|family
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
comment|/* XXX IPv6: assumes sin_port and sin6_port at same offset */
name|addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|addr
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
if|#
directive|if
name|AIX_SERVNAME_HACK
else|else
block|{
name|addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|family
operator|==
name|APR_INET
condition|)
block|{
name|addr
operator|->
name|salen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|addr
operator|->
name|addr_str_len
operator|=
literal|16
expr_stmt|;
name|addr
operator|->
name|ipaddr_ptr
operator|=
operator|&
operator|(
name|addr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
operator|)
expr_stmt|;
name|addr
operator|->
name|ipaddr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAVE_IPV6
elseif|else
if|if
condition|(
name|family
operator|==
name|APR_INET6
condition|)
block|{
name|addr
operator|->
name|salen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|addr
operator|->
name|addr_str_len
operator|=
literal|46
expr_stmt|;
name|addr
operator|->
name|ipaddr_ptr
operator|=
operator|&
operator|(
name|addr
operator|->
name|sa
operator|.
name|sin6
operator|.
name|sin6_addr
operator|)
expr_stmt|;
name|addr
operator|->
name|ipaddr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_socket_addr_get
argument_list|(
argument|apr_sockaddr_t **sa
argument_list|,
argument|apr_interface_e which
argument_list|,
argument|apr_socket_t *sock
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|which
operator|==
name|APR_LOCAL
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|local_interface_unknown
operator|||
name|sock
operator|->
name|local_port_unknown
condition|)
block|{
name|apr_status_t
name|rv
init|=
name|get_local_addr
argument_list|(
name|sock
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
block|}
operator|*
name|sa
operator|=
name|sock
operator|->
name|local_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|APR_REMOTE
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|remote_addr_unknown
condition|)
block|{
name|apr_status_t
name|rv
init|=
name|get_remote_addr
argument_list|(
name|sock
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
block|}
operator|*
name|sa
operator|=
name|sock
operator|->
name|remote_addr
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sa
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_parse_addr_port
argument_list|(
argument|char **addr
argument_list|,
argument|char **scope_id
argument_list|,
argument|apr_port_t *port
argument_list|,
argument|const char *str
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|ch
decl_stmt|,
modifier|*
name|lastchar
decl_stmt|;
name|int
name|big_port
decl_stmt|;
name|apr_size_t
name|addrlen
decl_stmt|;
operator|*
name|addr
operator|=
name|NULL
expr_stmt|;
comment|/* assume not specified */
operator|*
name|scope_id
operator|=
name|NULL
expr_stmt|;
comment|/* assume not specified */
operator|*
name|port
operator|=
literal|0
expr_stmt|;
comment|/* assume not specified */
comment|/* First handle the optional port number.  That may be all that      * is specified in the string.      */
name|ch
operator|=
name|lastchar
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ch
operator|>=
name|str
operator|&&
name|apr_isdigit
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
operator|--
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|<
name|str
condition|)
block|{
comment|/* Entire string is the port. */
name|big_port
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|big_port
operator|<
literal|1
operator|||
name|big_port
operator|>
literal|65535
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
operator|*
name|port
operator|=
name|big_port
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|':'
operator|&&
name|ch
operator|<
name|lastchar
condition|)
block|{
comment|/* host and port number specified */
if|if
condition|(
name|ch
operator|==
name|str
condition|)
block|{
comment|/* string starts with ':' -- bad */
return|return
name|APR_EINVAL
return|;
block|}
name|big_port
operator|=
name|atoi
argument_list|(
name|ch
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|big_port
operator|<
literal|1
operator|||
name|big_port
operator|>
literal|65535
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
operator|*
name|port
operator|=
name|big_port
expr_stmt|;
name|lastchar
operator|=
name|ch
operator|-
literal|1
expr_stmt|;
block|}
comment|/* now handle the hostname */
name|addrlen
operator|=
name|lastchar
operator|-
name|str
operator|+
literal|1
expr_stmt|;
comment|/* XXX we don't really have to require APR_HAVE_IPV6 for this;   * just pass char[] for ipaddr (so we don't depend on struct in6_addr)  * and always define APR_INET6   */
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
specifier|const
name|char
modifier|*
name|end_bracket
init|=
name|memchr
argument_list|(
name|str
argument_list|,
literal|']'
argument_list|,
name|addrlen
argument_list|)
decl_stmt|;
name|struct
name|in6_addr
name|ipaddr
decl_stmt|;
specifier|const
name|char
modifier|*
name|scope_delim
decl_stmt|;
if|if
condition|(
operator|!
name|end_bracket
operator|||
name|end_bracket
operator|!=
name|lastchar
condition|)
block|{
operator|*
name|port
operator|=
literal|0
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
comment|/* handle scope id; this is the only context where it is allowed */
name|scope_delim
operator|=
name|memchr
argument_list|(
name|str
argument_list|,
literal|'%'
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope_delim
condition|)
block|{
if|if
condition|(
name|scope_delim
operator|==
name|end_bracket
operator|-
literal|1
condition|)
block|{
comment|/* '%' without scope id */
operator|*
name|port
operator|=
literal|0
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
name|addrlen
operator|=
name|scope_delim
operator|-
name|str
operator|-
literal|1
expr_stmt|;
operator|*
name|scope_id
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|end_bracket
operator|-
name|scope_delim
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|scope_id
argument_list|,
name|scope_delim
operator|+
literal|1
argument_list|,
name|end_bracket
operator|-
name|scope_delim
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|scope_id
operator|)
index|[
name|end_bracket
operator|-
name|scope_delim
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|addrlen
operator|=
name|addrlen
operator|-
literal|2
expr_stmt|;
comment|/* minus 2 for '[' and ']' */
block|}
operator|*
name|addr
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|addrlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|addr
argument_list|,
name|str
operator|+
literal|1
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|addr
operator|)
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|apr_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
operator|*
name|addr
argument_list|,
operator|&
name|ipaddr
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|*
name|addr
operator|=
name|NULL
expr_stmt|;
operator|*
name|scope_id
operator|=
name|NULL
expr_stmt|;
operator|*
name|port
operator|=
literal|0
expr_stmt|;
return|return
name|APR_EINVAL
return|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
comment|/* XXX If '%' is not a valid char in a DNS name, we *could* check           *     for bogus scope ids first.          */
operator|*
name|addr
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|addrlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|addr
argument_list|,
name|str
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|addr
operator|)
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETADDRINFO
argument_list|)
end_if

begin_function
specifier|static
name|apr_status_t
name|call_resolver
parameter_list|(
name|apr_sockaddr_t
modifier|*
modifier|*
name|sa
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|apr_int32_t
name|family
parameter_list|,
name|apr_port_t
name|port
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|,
modifier|*
name|ai_list
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|prev_sa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|servname
init|=
name|NULL
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GAI_ADDRCONFIG
if|if
condition|(
name|family
operator|==
name|APR_UNSPEC
condition|)
block|{
comment|/* By default, only look up addresses using address types for          * which a local interface is configured, i.e. no IPv6 if no          * IPv6 interfaces configured. */
name|hints
operator|.
name|ai_flags
operator|=
name|AI_ADDRCONFIG
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|AI_PASSIVE
comment|/* If hostname is NULL, assume we are trying to bind to all          * interfaces. */
name|hints
operator|.
name|ai_flags
operator||=
name|AI_PASSIVE
expr_stmt|;
endif|#
directive|endif
comment|/* getaddrinfo according to RFC 2553 must have either hostname          * or servname non-NULL.          */
ifdef|#
directive|ifdef
name|OSF1
comment|/* The Tru64 5.0 getaddrinfo() can only resolve services given          * by the name listed in /etc/services; a numeric or unknown          * servname gets an EAI_SERVICE error.  So just resolve the          * appropriate anyaddr and fill in the port later. */
name|hostname
operator|=
name|family
operator|==
name|AF_INET6
condition|?
literal|"::"
else|:
literal|"0.0.0.0"
expr_stmt|;
name|servname
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_NUMERICHOST
name|hints
operator|.
name|ai_flags
operator||=
name|AI_NUMERICHOST
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|AIX_SERVNAME_HACK
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|servname
operator|=
literal|"1"
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* AIX_SERVNAME_HACK */
name|servname
operator|=
name|apr_itoa
argument_list|(
name|p
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OSF1 */
block|}
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GAI_ADDRCONFIG
comment|/*      * Using AI_ADDRCONFIG involves some unfortunate guesswork because it      * does not consider loopback addresses when trying to determine if      * IPv4 or IPv6 is configured on a system (see RFC 3493).      * This is a problem if one actually wants to listen on or connect to      * the loopback address of a protocol family that is not otherwise      * configured on the system. See PR 52709.      * To work around some of the problems, retry without AI_ADDRCONFIG      * in case of EAI_ADDRFAMILY.      * XXX: apr_sockaddr_info_get() should really accept a flag to determine      * XXX: if AI_ADDRCONFIG's guesswork is wanted and if the address is      * XXX: to be used for listen() or connect().      *      * In case of EAI_BADFLAGS, AI_ADDRCONFIG is not supported.      */
if|if
condition|(
operator|(
name|family
operator|==
name|APR_UNSPEC
operator|)
operator|&&
operator|(
name|error
operator|==
name|EAI_BADFLAGS
ifdef|#
directive|ifdef
name|EAI_ADDRFAMILY
operator|||
name|error
operator|==
name|EAI_ADDRFAMILY
endif|#
directive|endif
operator|)
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|&=
operator|~
name|AI_ADDRCONFIG
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
return|return
name|apr_get_netos_error
argument_list|()
return|;
else|#
directive|else
if|if
condition|(
name|error
operator|==
name|EAI_SYSTEM
condition|)
block|{
return|return
name|errno
condition|?
name|errno
else|:
name|APR_EGENERAL
return|;
block|}
else|else
block|{
comment|/* issues with representing this with APR's error scheme:              * glibc uses negative values for these numbers, perhaps so               * they don't conflict with h_errno values...  Tru64 uses               * positive values which conflict with h_errno values              */
if|#
directive|if
name|defined
argument_list|(
name|NEGATIVE_EAI
argument_list|)
name|error
operator|=
operator|-
name|error
expr_stmt|;
endif|#
directive|endif
return|return
name|error
operator|+
name|APR_OS_START_EAIERR
return|;
block|}
endif|#
directive|endif
comment|/* WIN32 */
block|}
name|prev_sa
operator|=
name|NULL
expr_stmt|;
name|ai
operator|=
name|ai_list
expr_stmt|;
while|while
condition|(
name|ai
condition|)
block|{
comment|/* while more addresses to report */
name|apr_sockaddr_t
modifier|*
name|new_sa
decl_stmt|;
comment|/* Ignore anything bogus: getaddrinfo in some old versions of          * glibc will return AF_UNIX entries for APR_UNSPEC+AI_PASSIVE          * lookups. */
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
operator|&&
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|!=
name|AF_INET
condition|)
block|{
endif|#
directive|endif
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
continue|continue;
block|}
name|new_sa
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_sockaddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_sa
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_sa
operator|->
name|sa
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|apr_sockaddr_vars_set
argument_list|(
name|new_sa
argument_list|,
name|ai
operator|->
name|ai_family
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_sa
condition|)
block|{
comment|/* first element in new list */
if|if
condition|(
name|hostname
condition|)
block|{
name|new_sa
operator|->
name|hostname
operator|=
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
operator|*
name|sa
operator|=
name|new_sa
expr_stmt|;
block|}
else|else
block|{
name|new_sa
operator|->
name|hostname
operator|=
name|prev_sa
operator|->
name|hostname
expr_stmt|;
name|prev_sa
operator|->
name|next
operator|=
name|new_sa
expr_stmt|;
block|}
name|prev_sa
operator|=
name|new_sa
expr_stmt|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_sa
operator|==
name|NULL
condition|)
block|{
comment|/*          * getaddrinfo returned only useless entries and *sa is still empty.          * This should be treated as an error.          */
return|return
name|APR_EGENERAL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|find_addresses
parameter_list|(
name|apr_sockaddr_t
modifier|*
modifier|*
name|sa
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|apr_int32_t
name|family
parameter_list|,
name|apr_port_t
name|port
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|APR_IPV4_ADDR_OK
condition|)
block|{
name|apr_status_t
name|error
init|=
name|call_resolver
argument_list|(
name|sa
argument_list|,
name|hostname
argument_list|,
name|AF_INET
argument_list|,
name|port
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|error
condition|)
block|{
name|family
operator|=
name|AF_INET6
expr_stmt|;
comment|/* try again */
block|}
else|else
endif|#
directive|endif
return|return
name|error
return|;
block|}
if|#
directive|if
name|APR_HAVE_IPV6
elseif|else
if|if
condition|(
name|flags
operator|&
name|APR_IPV6_ADDR_OK
condition|)
block|{
name|apr_status_t
name|error
init|=
name|call_resolver
argument_list|(
name|sa
argument_list|,
name|hostname
argument_list|,
name|AF_INET6
argument_list|,
name|port
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|family
operator|=
name|AF_INET
expr_stmt|;
comment|/* try again */
block|}
else|else
block|{
return|return
name|APR_SUCCESS
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|call_resolver
argument_list|(
name|sa
argument_list|,
name|hostname
argument_list|,
name|family
argument_list|,
name|port
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
return|;
block|}
else|#
directive|else
comment|/* end of HAVE_GETADDRINFO code */
specifier|static
name|apr_status_t
name|find_addresses
parameter_list|(
name|apr_sockaddr_t
modifier|*
modifier|*
name|sa
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|apr_int32_t
name|family
parameter_list|,
name|apr_port_t
name|port
parameter_list|,
name|apr_int32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|prev_sa
decl_stmt|;
name|int
name|curaddr
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETHOSTBYNAME_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETHOSTBYNAME_R
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
ifdef|#
directive|ifdef
name|GETHOSTBYNAME_R_HOSTENT_DATA
name|struct
name|hostent_data
name|hd
decl_stmt|;
else|#
directive|else
comment|/* If you see ERANGE, that means GETHOSBYNAME_BUFLEN needs to be      * bumped. */
name|char
name|tmp
index|[
name|GETHOSTBYNAME_BUFLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|hosterror
decl_stmt|;
endif|#
directive|endif
name|struct
name|hostent
name|hs
decl_stmt|;
name|struct
name|in_addr
name|ipaddr
decl_stmt|;
name|char
modifier|*
name|addr_list
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_hostname
init|=
name|hostname
decl_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
block|{
comment|/* if we are given a NULL hostname, assume '0.0.0.0' */
name|hostname
operator|=
literal|"0.0.0.0"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|hostname
operator|>=
literal|'0'
operator|&&
operator|*
name|hostname
operator|<=
literal|'9'
operator|&&
name|strspn
argument_list|(
name|hostname
argument_list|,
literal|"0123456789."
argument_list|)
operator|==
name|strlen
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
name|ipaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|addr_list
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ipaddr
expr_stmt|;
name|addr_list
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* just one IP in list */
name|hs
operator|.
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|addr_list
expr_stmt|;
name|hp
operator|=
operator|&
name|hs
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETHOSTBYNAME_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETHOSTBYNAME_R
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|GETHOSTBYNAME_R_HOSTENT_DATA
argument_list|)
comment|/* AIX, HP/UX, D/UX et alia */
name|gethostbyname_r
argument_list|(
name|hostname
argument_list|,
operator|&
name|hs
argument_list|,
operator|&
name|hd
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|&
name|hs
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|GETHOSTBYNAME_R_GLIBC2
argument_list|)
comment|/* Linux glibc2+ */
name|gethostbyname_r
argument_list|(
name|hostname
argument_list|,
operator|&
name|hs
argument_list|,
name|tmp
argument_list|,
name|GETHOSTBYNAME_BUFLEN
operator|-
literal|1
argument_list|,
operator|&
name|hp
argument_list|,
operator|&
name|hosterror
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Solaris, Irix et alia */
name|hp
operator|=
name|gethostbyname_r
argument_list|(
name|hostname
argument_list|,
operator|&
name|hs
argument_list|,
name|tmp
argument_list|,
name|GETHOSTBYNAME_BUFLEN
operator|-
literal|1
argument_list|,
operator|&
name|hosterror
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(GETHOSTBYNAME_R_GLIBC2) */
if|if
condition|(
operator|!
name|hp
condition|)
block|{
return|return
operator|(
name|hosterror
operator|+
name|APR_OS_START_SYSERR
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !defined(GETHOSTBYNAME_R_HOSTENT_DATA) */
else|#
directive|else
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hp
condition|)
block|{
ifdef|#
directive|ifdef
name|WIN32
return|return
name|apr_get_netos_error
argument_list|()
return|;
else|#
directive|else
return|return
operator|(
name|h_errno
operator|+
name|APR_OS_START_SYSERR
operator|)
return|;
endif|#
directive|endif
block|}
block|}
name|prev_sa
operator|=
name|NULL
expr_stmt|;
name|curaddr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hp
operator|->
name|h_addr_list
index|[
name|curaddr
index|]
condition|)
block|{
name|apr_sockaddr_t
modifier|*
name|new_sa
init|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_sockaddr_t
argument_list|)
argument_list|)
decl_stmt|;
name|new_sa
operator|->
name|pool
operator|=
name|p
expr_stmt|;
name|new_sa
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|curaddr
index|]
expr_stmt|;
name|apr_sockaddr_vars_set
argument_list|(
name|new_sa
argument_list|,
name|AF_INET
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_sa
condition|)
block|{
comment|/* first element in new list */
if|if
condition|(
name|orig_hostname
condition|)
block|{
name|new_sa
operator|->
name|hostname
operator|=
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
name|orig_hostname
argument_list|)
expr_stmt|;
block|}
operator|*
name|sa
operator|=
name|new_sa
expr_stmt|;
block|}
else|else
block|{
name|new_sa
operator|->
name|hostname
operator|=
name|prev_sa
operator|->
name|hostname
expr_stmt|;
name|prev_sa
operator|->
name|next
operator|=
name|new_sa
expr_stmt|;
block|}
name|prev_sa
operator|=
name|new_sa
expr_stmt|;
operator|++
name|curaddr
expr_stmt|;
block|}
if|if
condition|(
name|prev_sa
operator|==
name|NULL
condition|)
block|{
comment|/* this should not happen but no result should be treated as error */
return|return
name|APR_EGENERAL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
endif|#
directive|endif
comment|/* end of !HAVE_GETADDRINFO code */
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_sockaddr_info_get
argument_list|(
argument|apr_sockaddr_t **sa
argument_list|,
argument|const char *hostname
argument_list|,
argument|apr_int32_t family
argument_list|,
argument|apr_port_t port
argument_list|,
argument|apr_int32_t flags
argument_list|,
argument|apr_pool_t *p
argument_list|)
block|{
name|apr_int32_t
name|masked
decl_stmt|;
operator|*
name|sa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|masked
operator|=
name|flags
operator|&
operator|(
name|APR_IPV4_ADDR_OK
operator||
name|APR_IPV6_ADDR_OK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hostname
operator|||
name|family
operator|!=
name|APR_UNSPEC
operator|||
name|masked
operator|==
operator|(
name|APR_IPV4_ADDR_OK
operator||
name|APR_IPV6_ADDR_OK
operator|)
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
if|#
directive|if
operator|!
name|APR_HAVE_IPV6
if|if
condition|(
name|flags
operator|&
name|APR_IPV6_ADDR_OK
condition|)
block|{
return|return
name|APR_ENOTIMPL
return|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|APR_HAVE_IPV6
comment|/* What may happen is that APR is not IPv6-enabled, but we're still      * going to call getaddrinfo(), so we have to tell the OS we only      * want IPv4 addresses back since we won't know what to do with      * IPv6 addresses.      */
if|if
condition|(
name|family
operator|==
name|APR_UNSPEC
condition|)
block|{
name|family
operator|=
name|APR_INET
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|find_addresses
argument_list|(
name|sa
argument_list|,
name|hostname
argument_list|,
name|family
argument_list|,
name|port
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_getnameinfo
argument_list|(
argument|char **hostname
argument_list|,
argument|apr_sockaddr_t *sockaddr
argument_list|,
argument|apr_int32_t flags
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETNAMEINFO
argument_list|)
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NI_MAXHOST
argument_list|)
name|char
name|tmphostname
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
else|#
directive|else
name|char
name|tmphostname
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* don't know if it is portable for getnameinfo() to set h_errno;      * clear it then see if it was set */
name|SET_H_ERRNO
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* default flags are NI_NAMREQD; otherwise, getnameinfo() will return      * a numeric address string if it fails to resolve the host name;      * that is *not* what we want here      *      * For IPv4-mapped IPv6 addresses, drop down to IPv4 before calling      * getnameinfo() to avoid getnameinfo bugs (MacOS X, glibc).      */
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|sockaddr
operator|->
name|family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sockaddr
operator|->
name|sa
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|tmpsa
decl_stmt|;
name|tmpsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|tmpsa
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|tmpsa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|(
operator|(
name|apr_uint32_t
operator|*
operator|)
name|sockaddr
operator|->
name|ipaddr_ptr
operator|)
index|[
literal|3
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SIN6_LEN
name|tmpsa
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|tmpsa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|getnameinfo
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmpsa
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpsa
argument_list|)
argument_list|,
name|tmphostname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmphostname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
operator|!=
literal|0
condition|?
name|flags
else|:
name|NI_NAMEREQD
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|rc
operator|=
name|getnameinfo
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|sa
argument_list|,
name|sockaddr
operator|->
name|salen
argument_list|,
name|tmphostname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmphostname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
operator|!=
literal|0
condition|?
name|flags
else|:
name|NI_NAMEREQD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
operator|*
name|hostname
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
comment|/* something went wrong. Look at the EAI_ error code */
if|if
condition|(
name|rc
operator|==
name|EAI_SYSTEM
condition|)
block|{
comment|/* EAI_SYSTEM      System error returned in errno. */
comment|/* IMHO, Implementations that set h_errno a simply broken. */
if|if
condition|(
name|h_errno
condition|)
block|{
comment|/* for broken implementations which set h_errno */
return|return
name|h_errno
operator|+
name|APR_OS_START_SYSERR
return|;
block|}
else|else
block|{
comment|/* "normal" case */
return|return
name|errno
operator|+
name|APR_OS_START_SYSERR
return|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEGATIVE_EAI
argument_list|)
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|rc
operator|=
operator|-
name|rc
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
operator|+
name|APR_OS_START_EAIERR
return|;
comment|/* return the EAI_ error */
block|}
block|}
operator|*
name|hostname
operator|=
name|sockaddr
operator|->
name|hostname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|tmphostname
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
else|#
directive|else
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETHOSTBYADDR_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETHOSTBYADDR_R
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BEOS
argument_list|)
ifdef|#
directive|ifdef
name|GETHOSTBYNAME_R_HOSTENT_DATA
name|struct
name|hostent_data
name|hd
decl_stmt|;
else|#
directive|else
name|char
name|tmp
index|[
name|GETHOSTBYNAME_BUFLEN
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|hosterror
decl_stmt|;
name|struct
name|hostent
name|hs
decl_stmt|,
modifier|*
name|hptr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GETHOSTBYNAME_R_HOSTENT_DATA
argument_list|)
comment|/* AIX, HP/UX, D/UX et alia */
name|gethostbyaddr_r
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|,
operator|&
name|hs
argument_list|,
operator|&
name|hd
argument_list|)
expr_stmt|;
name|hptr
operator|=
operator|&
name|hs
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|GETHOSTBYNAME_R_GLIBC2
argument_list|)
comment|/* Linux glibc2+ */
name|gethostbyaddr_r
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|,
operator|&
name|hs
argument_list|,
name|tmp
argument_list|,
name|GETHOSTBYNAME_BUFLEN
operator|-
literal|1
argument_list|,
operator|&
name|hptr
argument_list|,
operator|&
name|hosterror
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Solaris, Irix et alia */
name|hptr
operator|=
name|gethostbyaddr_r
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|,
operator|&
name|hs
argument_list|,
name|tmp
argument_list|,
name|GETHOSTBYNAME_BUFLEN
argument_list|,
operator|&
name|hosterror
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(GETHOSTBYNAME_R_GLIBC2) */
if|if
condition|(
operator|!
name|hptr
condition|)
block|{
operator|*
name|hostname
operator|=
name|NULL
expr_stmt|;
return|return
name|hosterror
operator|+
name|APR_OS_START_SYSERR
return|;
block|}
endif|#
directive|endif
comment|/* !defined(GETHOSTBYNAME_R_HOSTENT_DATA) */
else|#
directive|else
name|struct
name|hostent
modifier|*
name|hptr
decl_stmt|;
name|hptr
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hptr
condition|)
block|{
operator|*
name|hostname
operator|=
name|sockaddr
operator|->
name|hostname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|hptr
operator|->
name|h_name
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
operator|*
name|hostname
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
return|return
name|apr_get_netos_error
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|OS2
argument_list|)
return|return
name|h_errno
return|;
else|#
directive|else
return|return
name|h_errno
operator|+
name|APR_OS_START_SYSERR
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_getservbyname
argument_list|(
argument|apr_sockaddr_t *sockaddr
argument_list|,
argument|const char *servname
argument_list|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETSERVBYNAME_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETSERVBYNAME_R
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|GETSERVBYNAME_R_GLIBC2
argument_list|)
operator|||
name|defined
argument_list|(
name|GETSERVBYNAME_R_SOLARIS
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|GETSERVBYNAME_R_OSF1
argument_list|)
operator|)
name|struct
name|servent
name|se
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|GETSERVBYNAME_R_OSF1
argument_list|)
name|struct
name|servent_data
name|sed
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* must zero fill before use */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|GETSERVBYNAME_R_GLIBC2
argument_list|)
name|struct
name|servent
modifier|*
name|res
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
name|struct
name|servent
modifier|*
name|se
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
name|APR_EINVAL
return|;
if|#
directive|if
name|APR_HAS_THREADS
operator|&&
operator|!
name|defined
argument_list|(
name|GETSERVBYNAME_IS_THREAD_SAFE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_GETSERVBYNAME_R
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|GETSERVBYNAME_R_GLIBC2
argument_list|)
operator|||
name|defined
argument_list|(
name|GETSERVBYNAME_R_SOLARIS
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|GETSERVBYNAME_R_OSF1
argument_list|)
operator|)
if|#
directive|if
name|defined
argument_list|(
name|GETSERVBYNAME_R_GLIBC2
argument_list|)
if|if
condition|(
name|getservbyname_r
argument_list|(
name|servname
argument_list|,
name|NULL
argument_list|,
operator|&
name|se
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
operator|&&
name|res
operator|!=
name|NULL
condition|)
block|{
name|sockaddr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|res
operator|->
name|s_port
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|servname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|res
operator|->
name|s_port
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|GETSERVBYNAME_R_SOLARIS
argument_list|)
if|if
condition|(
name|getservbyname_r
argument_list|(
name|servname
argument_list|,
name|NULL
argument_list|,
operator|&
name|se
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sockaddr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|se
operator|.
name|s_port
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|servname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|se
operator|.
name|s_port
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|GETSERVBYNAME_R_OSF1
argument_list|)
if|if
condition|(
name|getservbyname_r
argument_list|(
name|servname
argument_list|,
name|NULL
argument_list|,
operator|&
name|se
argument_list|,
operator|&
name|sed
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sockaddr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|se
operator|.
name|s_port
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|servname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|se
operator|.
name|s_port
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|(
name|se
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sockaddr
operator|->
name|port
operator|=
name|ntohs
argument_list|(
name|se
operator|->
name|s_port
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|servname
operator|=
name|apr_pstrdup
argument_list|(
name|sockaddr
operator|->
name|pool
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|se
operator|->
name|s_port
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
endif|#
directive|endif
return|return
name|APR_ENOENT
return|;
block|}
define|#
directive|define
name|V4MAPPED_EQUAL
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|((a)->sa.sin.sin_family == AF_INET&&                         \  (b)->sa.sin.sin_family == AF_INET6&&                        \  IN6_IS_ADDR_V4MAPPED((struct in6_addr *)(b)->ipaddr_ptr)&&  \  !memcmp((a)->ipaddr_ptr,                                     \&((struct in6_addr *)(b)->ipaddr_ptr)->s6_addr[12],  \          (a)->ipaddr_len))
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
name|apr_sockaddr_equal
argument_list|(
argument|const apr_sockaddr_t *addr1
argument_list|,
argument|const apr_sockaddr_t *addr2
argument_list|)
block|{
if|if
condition|(
name|addr1
operator|->
name|ipaddr_len
operator|==
name|addr2
operator|->
name|ipaddr_len
operator|&&
operator|!
name|memcmp
argument_list|(
name|addr1
operator|->
name|ipaddr_ptr
argument_list|,
name|addr2
operator|->
name|ipaddr_ptr
argument_list|,
name|addr1
operator|->
name|ipaddr_len
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|V4MAPPED_EQUAL
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|V4MAPPED_EQUAL
argument_list|(
name|addr2
argument_list|,
name|addr1
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
comment|/* not equal */
block|}
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
name|apr_sockaddr_is_wildcard
argument_list|(
argument|const apr_sockaddr_t *addr
argument_list|)
block|{
specifier|static
specifier|const
name|char
name|inaddr_any
index|[
if|#
directive|if
name|APR_HAVE_IPV6
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
else|#
directive|else
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
endif|#
directive|endif
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|addr
operator|->
name|ipaddr_ptr
comment|/* IP address initialized */
operator|&&
name|addr
operator|->
name|ipaddr_len
operator|<=
sizeof|sizeof
name|inaddr_any
condition|)
block|{
comment|/* else bug elsewhere? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|inaddr_any
argument_list|,
name|addr
operator|->
name|ipaddr_ptr
argument_list|,
name|addr
operator|->
name|ipaddr_len
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
name|addr
operator|->
name|family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|addr
operator|->
name|ipaddr_ptr
argument_list|)
condition|)
block|{
name|struct
name|in_addr
modifier|*
name|v4
init|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
operator|(
operator|(
name|apr_uint32_t
operator|*
operator|)
name|addr
operator|->
name|ipaddr_ptr
operator|)
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|inaddr_any
argument_list|,
name|v4
argument_list|,
sizeof|sizeof
expr|*
name|v4
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|apr_status_t
name|parse_network
parameter_list|(
name|apr_ipsubnet_t
modifier|*
name|ipsub
parameter_list|,
specifier|const
name|char
modifier|*
name|network
parameter_list|)
block|{
comment|/* legacy syntax for ip addrs: a.b.c. ==> a.b.c.0/24 for example */
name|int
name|shift
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|octet
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|network
argument_list|)
operator|<
sizeof|sizeof
name|buf
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|network
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|APR_EBADIP
return|;
block|}
comment|/* parse components */
name|s
operator|=
name|buf
expr_stmt|;
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|24
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|apr_isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
return|return
name|APR_EBADIP
return|;
block|}
while|while
condition|(
name|apr_isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
operator|++
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'.'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|t
condition|)
block|{
return|return
name|APR_EBADIP
return|;
block|}
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
block|{
return|return
name|APR_EBADIP
return|;
block|}
name|octet
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|octet
operator|<
literal|0
operator|||
name|octet
operator|>
literal|255
condition|)
block|{
return|return
name|APR_EBADIP
return|;
block|}
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
operator||=
name|octet
operator|<<
name|shift
expr_stmt|;
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator||=
literal|0xFFUL
operator|<<
name|shift
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|shift
operator|-=
literal|8
expr_stmt|;
block|}
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ipsub
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
comment|/* return values:  * APR_EINVAL     not an IP address; caller should see if it is something else  * APR_BADIP      IP address portion is is not valid  * APR_BADMASK    mask portion is not valid  */
specifier|static
name|apr_status_t
name|parse_ip
parameter_list|(
name|apr_ipsubnet_t
modifier|*
name|ipsub
parameter_list|,
specifier|const
name|char
modifier|*
name|ipstr
parameter_list|,
name|int
name|network_allowed
parameter_list|)
block|{
comment|/* supported flavors of IP:      *      * . IPv6 numeric address string (e.g., "fe80::1")      *       *   IMPORTANT: Don't store IPv4-mapped IPv6 address as an IPv6 address.      *      * . IPv4 numeric address string (e.g., "127.0.0.1")      *      * . IPv4 network string (e.g., "9.67")      *      *   IMPORTANT: This network form is only allowed if network_allowed is on.      */
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
name|rc
operator|=
name|apr_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ipstr
argument_list|,
name|ipsub
operator|->
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ipsub
operator|->
name|sub
argument_list|)
condition|)
block|{
comment|/* apr_ipsubnet_test() assumes that we don't create IPv4-mapped IPv6              * addresses; this of course forces the user to specify IPv4 addresses              * in a.b.c.d style instead of ::ffff:a.b.c.d style.              */
return|return
name|APR_EBADIP
return|;
block|}
name|ipsub
operator|->
name|family
operator|=
name|AF_INET6
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|rc
operator|=
name|apr_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ipstr
argument_list|,
name|ipsub
operator|->
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
name|ipsub
operator|->
name|family
operator|=
name|AF_INET
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|network_allowed
condition|)
block|{
return|return
name|parse_network
argument_list|(
name|ipsub
argument_list|,
name|ipstr
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|APR_EBADIP
return|;
block|}
block|}
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|int
name|looks_like_ip
parameter_list|(
specifier|const
name|char
modifier|*
name|ipstr
parameter_list|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|ipstr
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
comment|/* definitely not a hostname; assume it is intended to be an IPv6 address */
return|return
literal|1
return|;
block|}
comment|/* simple IPv4 address string check */
while|while
condition|(
operator|(
operator|*
name|ipstr
operator|==
literal|'.'
operator|)
operator|||
name|apr_isdigit
argument_list|(
operator|*
name|ipstr
argument_list|)
condition|)
name|ipstr
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|ipstr
operator|==
literal|'\0'
operator|)
return|;
block|}
specifier|static
name|void
name|fix_subnet
parameter_list|(
name|apr_ipsubnet_t
modifier|*
name|ipsub
parameter_list|)
block|{
comment|/* in case caller specified more bits in network address than are      * valid according to the mask, turn off the extra bits      */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|ipsub
operator|->
name|mask
operator|/
sizeof|sizeof
argument_list|(
name|apr_int32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ipsub
operator|->
name|sub
index|[
name|i
index|]
operator|&=
name|ipsub
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* be sure not to store any IPv4 address as a v4-mapped IPv6 address */
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_ipsubnet_create
argument_list|(
argument|apr_ipsubnet_t **ipsub
argument_list|,
argument|const char *ipstr
argument_list|,
argument|const char *mask_or_numbits
argument_list|,
argument|apr_pool_t *p
argument_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|long
name|bits
decl_stmt|,
name|maxbits
init|=
literal|32
decl_stmt|;
comment|/* filter out stuff which doesn't look remotely like an IP address; this helps       * callers like mod_access which have a syntax allowing hostname or IP address;      * APR_EINVAL tells the caller that it was probably not intended to be an IP      * address      */
if|if
condition|(
operator|!
name|looks_like_ip
argument_list|(
name|ipstr
argument_list|)
condition|)
block|{
return|return
name|APR_EINVAL
return|;
block|}
operator|*
name|ipsub
operator|=
name|apr_pcalloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_ipsubnet_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assume ipstr is an individual IP address, not a subnet */
name|memset
argument_list|(
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ipsub
argument_list|)
operator|->
name|mask
argument_list|)
expr_stmt|;
name|rv
operator|=
name|parse_ip
argument_list|(
operator|*
name|ipsub
argument_list|,
name|ipstr
argument_list|,
name|mask_or_numbits
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
name|mask_or_numbits
condition|)
block|{
if|#
directive|if
name|APR_HAVE_IPV6
if|if
condition|(
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|family
operator|==
name|AF_INET6
condition|)
block|{
name|maxbits
operator|=
literal|128
expr_stmt|;
block|}
endif|#
directive|endif
name|bits
operator|=
name|strtol
argument_list|(
name|mask_or_numbits
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|==
literal|'\0'
operator|&&
name|bits
operator|>
literal|0
operator|&&
name|bits
operator|<=
name|maxbits
condition|)
block|{
comment|/* valid num-bits string; fill in mask appropriately */
name|int
name|cur_entry
init|=
literal|0
decl_stmt|;
name|apr_int32_t
name|cur_bit_value
decl_stmt|;
name|memset
argument_list|(
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ipsub
argument_list|)
operator|->
name|mask
argument_list|)
expr_stmt|;
while|while
condition|(
name|bits
operator|>
literal|32
condition|)
block|{
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
index|[
name|cur_entry
index|]
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* all 32 bits */
name|bits
operator|-=
literal|32
expr_stmt|;
operator|++
name|cur_entry
expr_stmt|;
block|}
name|cur_bit_value
operator|=
literal|0x80000000
expr_stmt|;
while|while
condition|(
name|bits
condition|)
block|{
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
index|[
name|cur_entry
index|]
operator||=
name|cur_bit_value
expr_stmt|;
operator|--
name|bits
expr_stmt|;
name|cur_bit_value
operator|/=
literal|2
expr_stmt|;
block|}
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
index|[
name|cur_entry
index|]
operator|=
name|htonl
argument_list|(
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
index|[
name|cur_entry
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|mask_or_numbits
argument_list|,
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|mask
argument_list|)
operator|==
literal|1
operator|&&
operator|(
operator|*
name|ipsub
operator|)
operator|->
name|family
operator|==
name|AF_INET
condition|)
block|{
comment|/* valid IPv4 netmask */
block|}
else|else
block|{
return|return
name|APR_EBADMASK
return|;
block|}
block|}
name|fix_subnet
argument_list|(
operator|*
name|ipsub
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
name|apr_ipsubnet_test
argument_list|(
argument|apr_ipsubnet_t *ipsub
argument_list|,
argument|apr_sockaddr_t *sa
argument_list|)
block|{
if|#
directive|if
name|APR_HAVE_IPV6
comment|/* XXX This line will segv on Win32 build with APR_HAVE_IPV6,      * but without the IPV6 drivers installed.      */
if|if
condition|(
name|sa
operator|->
name|family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|ipsub
operator|->
name|family
operator|==
name|AF_INET
operator|&&
operator|(
operator|(
name|sa
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|sa
operator|->
name|ipaddr_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ipsub
operator|->
name|family
operator|==
name|AF_INET
operator|&&
operator|(
operator|(
operator|(
name|apr_uint32_t
operator|*
operator|)
name|sa
operator|->
name|ipaddr_ptr
operator|)
index|[
literal|3
index|]
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|family
operator|==
name|AF_INET6
operator|&&
name|ipsub
operator|->
name|family
operator|==
name|AF_INET6
condition|)
block|{
name|apr_uint32_t
modifier|*
name|addr
init|=
operator|(
name|apr_uint32_t
operator|*
operator|)
name|sa
operator|->
name|ipaddr_ptr
decl_stmt|;
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
operator|&&
operator|(
name|addr
index|[
literal|1
index|]
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|1
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|1
index|]
operator|&&
operator|(
name|addr
index|[
literal|2
index|]
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|2
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|2
index|]
operator|&&
operator|(
name|addr
index|[
literal|3
index|]
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|3
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|3
index|]
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|sa
operator|->
name|sa
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|ipsub
operator|->
name|mask
index|[
literal|0
index|]
operator|)
operator|==
name|ipsub
operator|->
name|sub
index|[
literal|0
index|]
condition|)
block|{
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* APR_HAVE_IPV6 */
return|return
literal|0
return|;
comment|/* no match */
block|}
end_function

end_unit

