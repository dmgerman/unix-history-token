begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_file_io.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Win32 malpropism that can go away once everyone believes this  * code is golden, and I'm not testing it anymore :-)  */
end_comment

begin_if
if|#
directive|if
name|APR_HAVE_DIRENT_H
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Any OS that requires/refuses trailing slashes should be dealt with here.  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_get
argument_list|(
argument|char **defpath
argument_list|,
argument|apr_int32_t flags
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|char
name|path
index|[
name|APR_PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
return|return
name|APR_ENAMETOOLONG
return|;
else|else
return|return
name|errno
return|;
block|}
operator|*
name|defpath
operator|=
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* Any OS that requires/refuses trailing slashes should be dealt with here  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_set
argument_list|(
argument|const char *path
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|chdir
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|errno
return|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_root
argument_list|(
argument|const char **rootpath
argument_list|,
argument|const char **inpath
argument_list|,
argument|apr_int32_t flags
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|*
operator|*
name|inpath
operator|==
literal|'/'
condition|)
block|{
operator|*
name|rootpath
operator|=
name|apr_pstrdup
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
do|do
block|{
operator|++
operator|(
operator|*
name|inpath
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|inpath
operator|==
literal|'/'
condition|)
do|;
return|return
name|APR_SUCCESS
return|;
block|}
return|return
name|APR_ERELATIVE
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_merge
argument_list|(
argument|char **newpath
argument_list|,
argument|const char *rootpath
argument_list|,
argument|const char *addpath
argument_list|,
argument|apr_int32_t flags
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|apr_size_t
name|rootlen
decl_stmt|;
comment|/* is the length of the src rootpath */
name|apr_size_t
name|maxlen
decl_stmt|;
comment|/* maximum total path length */
name|apr_size_t
name|keptlen
decl_stmt|;
comment|/* is the length of the retained rootpath */
name|apr_size_t
name|pathlen
decl_stmt|;
comment|/* is the length of the result path */
name|apr_size_t
name|seglen
decl_stmt|;
comment|/* is the end of the current segment */
name|apr_status_t
name|rv
decl_stmt|;
comment|/* Treat null as an empty path.      */
if|if
condition|(
operator|!
name|addpath
condition|)
name|addpath
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|addpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* If addpath is rooted, then rootpath is unused.          * Ths violates any APR_FILEPATH_SECUREROOTTEST and          * APR_FILEPATH_NOTABSOLUTE flags specified.          */
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_SECUREROOTTEST
condition|)
return|return
name|APR_EABOVEROOT
return|;
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_NOTABSOLUTE
condition|)
return|return
name|APR_EABSOLUTE
return|;
comment|/* If APR_FILEPATH_NOTABOVEROOT wasn't specified,          * we won't test the root again, it's ignored.          * Waste no CPU retrieving the working path.          */
if|if
condition|(
operator|!
name|rootpath
operator|&&
operator|!
operator|(
name|flags
operator|&
name|APR_FILEPATH_NOTABOVEROOT
operator|)
condition|)
name|rootpath
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
comment|/* If APR_FILEPATH_NOTABSOLUTE is specified, the caller          * requires a relative result.  If the rootpath is          * ommitted, we do not retrieve the working path,          * if rootpath was supplied as absolute then fail.          */
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_NOTABSOLUTE
condition|)
block|{
if|if
condition|(
operator|!
name|rootpath
condition|)
name|rootpath
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|rootpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|APR_EABSOLUTE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|rootpath
condition|)
block|{
comment|/* Start with the current working path.  This is bass akwards,          * but required since the compiler (at least vc) doesn't like          * passing the address of a char const* for a char** arg.          */
name|char
modifier|*
name|getpath
decl_stmt|;
name|rv
operator|=
name|apr_filepath_get
argument_list|(
operator|&
name|getpath
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|rootpath
operator|=
name|getpath
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|errno
return|;
comment|/* XXX: Any kernel subject to goofy, uncanonical results          * must run the rootpath against the user's given flags.          * Simplest would be a recursive call to apr_filepath_merge          * with an empty (not null) rootpath and addpath of the cwd.          */
block|}
name|rootlen
operator|=
name|strlen
argument_list|(
name|rootpath
argument_list|)
expr_stmt|;
name|maxlen
operator|=
name|rootlen
operator|+
name|strlen
argument_list|(
name|addpath
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* 4 for slashes at start, after                                              * root, and at end, plus trailing                                              * null */
if|if
condition|(
name|maxlen
operator|>
name|APR_PATH_MAX
condition|)
block|{
return|return
name|APR_ENAMETOOLONG
return|;
block|}
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|apr_palloc
argument_list|(
name|p
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|addpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Ignore the given root path, strip off leading          * '/'s to a single leading '/' from the addpath,          * and leave addpath at the first non-'/' character.          */
name|keptlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|addpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|addpath
expr_stmt|;
name|path
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|pathlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If both paths are relative, fail early          */
if|if
condition|(
name|rootpath
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
operator|(
name|flags
operator|&
name|APR_FILEPATH_NOTRELATIVE
operator|)
condition|)
return|return
name|APR_ERELATIVE
return|;
comment|/* Base the result path on the rootpath          */
name|keptlen
operator|=
name|rootlen
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|rootpath
argument_list|,
name|rootlen
argument_list|)
expr_stmt|;
comment|/* Always '/' terminate the given root path          */
if|if
condition|(
name|keptlen
operator|&&
name|path
index|[
name|keptlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|path
index|[
name|keptlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|pathlen
operator|=
name|keptlen
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|addpath
condition|)
block|{
comment|/* Parse each segment, find the closing '/'          */
specifier|const
name|char
modifier|*
name|next
init|=
name|addpath
decl_stmt|;
while|while
condition|(
operator|*
name|next
operator|&&
operator|(
operator|*
name|next
operator|!=
literal|'/'
operator|)
condition|)
block|{
operator|++
name|next
expr_stmt|;
block|}
name|seglen
operator|=
name|next
operator|-
name|addpath
expr_stmt|;
if|if
condition|(
name|seglen
operator|==
literal|0
operator|||
operator|(
name|seglen
operator|==
literal|1
operator|&&
name|addpath
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
comment|/* noop segment (/ or ./) so skip it              */
block|}
elseif|else
if|if
condition|(
name|seglen
operator|==
literal|2
operator|&&
name|addpath
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|addpath
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* backpath (../) */
if|if
condition|(
name|pathlen
operator|==
literal|1
operator|&&
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Attempt to move above root.  Always die if the                  * APR_FILEPATH_SECUREROOTTEST flag is specified.                  */
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_SECUREROOTTEST
condition|)
block|{
return|return
name|APR_EABOVEROOT
return|;
block|}
comment|/* Otherwise this is simply a noop, above root is root.                  * Flag that rootpath was entirely replaced.                  */
name|keptlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pathlen
operator|==
literal|0
operator|||
operator|(
name|pathlen
operator|==
literal|3
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
operator|+
name|pathlen
operator|-
literal|3
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
name|pathlen
operator|>
literal|3
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
operator|+
name|pathlen
operator|-
literal|4
argument_list|,
literal|"/../"
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
block|{
comment|/* Path is already backpathed or empty, if the                  * APR_FILEPATH_SECUREROOTTEST.was given die now.                  */
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_SECUREROOTTEST
condition|)
block|{
return|return
name|APR_EABOVEROOT
return|;
block|}
comment|/* Otherwise append another backpath, including                  * trailing slash if present.                  */
name|memcpy
argument_list|(
name|path
operator|+
name|pathlen
argument_list|,
literal|"../"
argument_list|,
operator|*
name|next
condition|?
literal|3
else|:
literal|2
argument_list|)
expr_stmt|;
name|pathlen
operator|+=
operator|*
name|next
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise crop the prior segment                  */
do|do
block|{
operator|--
name|pathlen
expr_stmt|;
block|}
do|while
condition|(
name|pathlen
operator|&&
name|path
index|[
name|pathlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
do|;
block|}
comment|/* Now test if we are above where we started and back up              * the keptlen offset to reflect the added/altered path.              */
if|if
condition|(
name|pathlen
operator|<
name|keptlen
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|APR_FILEPATH_SECUREROOTTEST
condition|)
block|{
return|return
name|APR_EABOVEROOT
return|;
block|}
name|keptlen
operator|=
name|pathlen
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* An actual segment, append it to the destination path              */
if|if
condition|(
operator|*
name|next
condition|)
block|{
name|seglen
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|path
operator|+
name|pathlen
argument_list|,
name|addpath
argument_list|,
name|seglen
argument_list|)
expr_stmt|;
name|pathlen
operator|+=
name|seglen
expr_stmt|;
block|}
comment|/* Skip over trailing slash to the next segment          */
if|if
condition|(
operator|*
name|next
condition|)
block|{
operator|++
name|next
expr_stmt|;
block|}
name|addpath
operator|=
name|next
expr_stmt|;
block|}
name|path
index|[
name|pathlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* keptlen will be the rootlen unless the addpath contained      * backpath elements.  If so, and APR_FILEPATH_NOTABOVEROOT      * is specified (APR_FILEPATH_SECUREROOTTEST was caught above),      * compare the original root to assure the result path is      * still within given root path.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|APR_FILEPATH_NOTABOVEROOT
operator|)
operator|&&
name|keptlen
operator|<
name|rootlen
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|rootpath
argument_list|,
name|path
argument_list|,
name|rootlen
argument_list|)
condition|)
block|{
return|return
name|APR_EABOVEROOT
return|;
block|}
if|if
condition|(
name|rootpath
index|[
name|rootlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|path
index|[
name|rootlen
index|]
operator|&&
name|path
index|[
name|rootlen
index|]
operator|!=
literal|'/'
condition|)
block|{
return|return
name|APR_EABOVEROOT
return|;
block|}
block|}
operator|*
name|newpath
operator|=
name|path
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_list_split
argument_list|(
argument|apr_array_header_t **pathelts
argument_list|,
argument|const char *liststr
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_filepath_list_split_impl
argument_list|(
name|pathelts
argument_list|,
name|liststr
argument_list|,
literal|':'
argument_list|,
name|p
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_list_merge
argument_list|(
argument|char **liststr
argument_list|,
argument|apr_array_header_t *pathelts
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_filepath_list_merge_impl
argument_list|(
name|liststr
argument_list|,
name|pathelts
argument_list|,
literal|':'
argument_list|,
name|p
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_filepath_encoding
argument_list|(
argument|int *style
argument_list|,
argument|apr_pool_t *p
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|DARWIN
argument_list|)
operator|*
name|style
operator|=
name|APR_FILEPATH_ENCODING_UTF8
expr_stmt|;
else|#
directive|else
operator|*
name|style
operator|=
name|APR_FILEPATH_ENCODING_LOCALE
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_block

end_unit

