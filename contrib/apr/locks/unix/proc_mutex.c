begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_proc_mutex.h"
end_include

begin_include
include|#
directive|include
file|"apr_arch_file_io.h"
end_include

begin_comment
comment|/* for apr_mkstemp() */
end_comment

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_proc_mutex_destroy
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_cleanup_run
argument_list|(
name|mutex
operator|->
name|pool
argument_list|,
name|mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|APR_HAS_POSIXSEM_SERIALIZE
operator|||
name|APR_HAS_FCNTL_SERIALIZE
operator|||
expr|\
name|APR_HAS_PROC_PTHREAD_SERIALIZE
operator|||
name|APR_HAS_SYSVSEM_SERIALIZE
end_if

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_no_child_init
parameter_list|(
name|apr_proc_mutex_t
modifier|*
modifier|*
name|mutex
parameter_list|,
name|apr_pool_t
modifier|*
name|cont
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAS_POSIXSEM_SERIALIZE
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SEM_FAILED
end_ifndef

begin_define
define|#
directive|define
name|SEM_FAILED
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_posix_cleanup
parameter_list|(
name|void
modifier|*
name|mutex_
parameter_list|)
block|{
name|apr_proc_mutex_t
modifier|*
name|mutex
init|=
name|mutex_
decl_stmt|;
if|if
condition|(
name|sem_close
argument_list|(
name|mutex
operator|->
name|psem_interproc
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rshash
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
comment|/* hash function from Robert Sedgwicks 'Algorithms in C' book */
name|unsigned
name|int
name|b
init|=
literal|378551
decl_stmt|;
name|unsigned
name|int
name|a
init|=
literal|63689
decl_stmt|;
name|unsigned
name|int
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|retval
operator|=
name|retval
operator|*
name|a
operator|+
operator|(
operator|*
name|p
operator|)
expr_stmt|;
name|a
operator|*=
name|b
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_posix_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
define|#
directive|define
name|APR_POSIXSEM_NAME_MIN
value|13
name|sem_t
modifier|*
name|psem
decl_stmt|;
name|char
name|semname
index|[
literal|32
index|]
decl_stmt|;
name|new_mutex
operator|->
name|interproc
operator|=
name|apr_palloc
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_mutex
operator|->
name|interproc
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * This bogusness is to follow what appears to be the      * lowest common denominator in Posix semaphore naming:      *   - start with '/'      *   - be at most 14 chars      *   - be unique and not match anything on the filesystem      *      * Because of this, we use fname to generate a (unique) hash      * and use that as the name of the semaphore. If no filename was      * given, we create one based on the time. We tuck the name      * away, since it might be useful for debugging. We use 2 hashing      * functions to try to avoid collisions.      *      * To  make this as robust as possible, we initially try something      * larger (and hopefully more unique) and gracefully fail down to the      * LCD above.      *      * NOTE: Darwin (Mac OS X) seems to be the most restrictive      * implementation. Versions previous to Darwin 6.2 had the 14      * char limit, but later rev's allow up to 31 characters.      *      */
if|if
condition|(
name|fname
condition|)
block|{
name|apr_ssize_t
name|flen
init|=
name|strlen
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|apr_pstrndup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|h1
decl_stmt|,
name|h2
decl_stmt|;
name|h1
operator|=
operator|(
name|apr_hashfunc_default
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
operator|&
name|flen
argument_list|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|h2
operator|=
operator|(
name|rshash
argument_list|(
name|p
argument_list|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|apr_snprintf
argument_list|(
name|semname
argument_list|,
sizeof|sizeof
argument_list|(
name|semname
argument_list|)
argument_list|,
literal|"/ApR.%xH%x"
argument_list|,
name|h1
argument_list|,
name|h2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_time_t
name|now
decl_stmt|;
name|unsigned
name|long
name|sec
decl_stmt|;
name|unsigned
name|long
name|usec
decl_stmt|;
name|now
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|sec
operator|=
name|apr_time_sec
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|usec
operator|=
name|apr_time_usec
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|apr_snprintf
argument_list|(
name|semname
argument_list|,
sizeof|sizeof
argument_list|(
name|semname
argument_list|)
argument_list|,
literal|"/ApR.%lxZ%lx"
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|psem
operator|=
name|sem_open
argument_list|(
name|semname
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|psem
operator|==
operator|(
name|sem_t
operator|*
operator|)
name|SEM_FAILED
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|psem
operator|==
operator|(
name|sem_t
operator|*
operator|)
name|SEM_FAILED
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENAMETOOLONG
condition|)
block|{
comment|/* Oh well, good try */
name|semname
index|[
name|APR_POSIXSEM_NAME_MIN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
return|return
name|errno
return|;
block|}
do|do
block|{
name|psem
operator|=
name|sem_open
argument_list|(
name|semname
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|psem
operator|==
operator|(
name|sem_t
operator|*
operator|)
name|SEM_FAILED
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
if|if
condition|(
name|psem
operator|==
operator|(
name|sem_t
operator|*
operator|)
name|SEM_FAILED
condition|)
block|{
return|return
name|errno
return|;
block|}
comment|/* Ahhh. The joys of Posix sems. Predelete it... */
name|sem_unlink
argument_list|(
name|semname
argument_list|)
expr_stmt|;
name|new_mutex
operator|->
name|psem_interproc
operator|=
name|psem
expr_stmt|;
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
name|semname
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_posix_acquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|sem_wait
argument_list|(
name|mutex
operator|->
name|psem_interproc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_posix_tryacquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|sem_trywait
argument_list|(
name|mutex
operator|->
name|psem_interproc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
return|return
name|APR_EBUSY
return|;
block|}
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_posix_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sem_post
argument_list|(
name|mutex
operator|->
name|psem_interproc
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* any failure is probably fatal, so no big deal to leave          * ->curr_locked at 0. */
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|apr_proc_mutex_unix_lock_methods_t
name|mutex_posixsem_methods
init|=
block|{
if|#
directive|if
name|APR_PROCESS_LOCK_IS_GLOBAL
operator|||
operator|!
name|APR_HAS_THREADS
operator|||
name|defined
argument_list|(
name|POSIXSEM_IS_GLOBAL
argument_list|)
name|APR_PROCESS_LOCK_MECH_IS_GLOBAL
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
name|proc_mutex_posix_create
block|,
name|proc_mutex_posix_acquire
block|,
name|proc_mutex_posix_tryacquire
block|,
name|proc_mutex_posix_release
block|,
name|proc_mutex_posix_cleanup
block|,
name|proc_mutex_no_child_init
block|,
literal|"posixsem"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Posix sem implementation */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_SYSVSEM_SERIALIZE
end_if

begin_decl_stmt
specifier|static
name|struct
name|sembuf
name|proc_mutex_op_on
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sembuf
name|proc_mutex_op_try
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sembuf
name|proc_mutex_op_off
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|proc_mutex_sysv_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|proc_mutex_op_on
operator|.
name|sem_num
operator|=
literal|0
expr_stmt|;
name|proc_mutex_op_on
operator|.
name|sem_op
operator|=
operator|-
literal|1
expr_stmt|;
name|proc_mutex_op_on
operator|.
name|sem_flg
operator|=
name|SEM_UNDO
expr_stmt|;
name|proc_mutex_op_try
operator|.
name|sem_num
operator|=
literal|0
expr_stmt|;
name|proc_mutex_op_try
operator|.
name|sem_op
operator|=
operator|-
literal|1
expr_stmt|;
name|proc_mutex_op_try
operator|.
name|sem_flg
operator|=
name|SEM_UNDO
operator||
name|IPC_NOWAIT
expr_stmt|;
name|proc_mutex_op_off
operator|.
name|sem_num
operator|=
literal|0
expr_stmt|;
name|proc_mutex_op_off
operator|.
name|sem_op
operator|=
literal|1
expr_stmt|;
name|proc_mutex_op_off
operator|.
name|sem_flg
operator|=
name|SEM_UNDO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_sysv_cleanup
parameter_list|(
name|void
modifier|*
name|mutex_
parameter_list|)
block|{
name|apr_proc_mutex_t
modifier|*
name|mutex
init|=
name|mutex_
decl_stmt|;
name|union
name|semun
name|ick
decl_stmt|;
if|if
condition|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
operator|!=
operator|-
literal|1
condition|)
block|{
name|ick
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|semctl
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
literal|0
argument_list|,
name|IPC_RMID
argument_list|,
name|ick
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_sysv_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|union
name|semun
name|ick
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|new_mutex
operator|->
name|interproc
operator|=
name|apr_palloc
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_mutex
operator|->
name|interproc
argument_list|)
argument_list|)
expr_stmt|;
name|new_mutex
operator|->
name|interproc
operator|->
name|filedes
operator|=
name|semget
argument_list|(
name|IPC_PRIVATE
argument_list|,
literal|1
argument_list|,
name|IPC_CREAT
operator||
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mutex
operator|->
name|interproc
operator|->
name|filedes
operator|<
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
name|proc_mutex_sysv_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|ick
operator|.
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|semctl
argument_list|(
name|new_mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
literal|0
argument_list|,
name|SETVAL
argument_list|,
name|ick
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
name|proc_mutex_sysv_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|new_mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_sysv_acquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|semop
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
operator|&
name|proc_mutex_op_on
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_sysv_tryacquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|semop
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
operator|&
name|proc_mutex_op_try
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
return|return
name|APR_EBUSY
return|;
block|}
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_sysv_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|semop
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
operator|&
name|proc_mutex_op_off
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|apr_proc_mutex_unix_lock_methods_t
name|mutex_sysv_methods
init|=
block|{
if|#
directive|if
name|APR_PROCESS_LOCK_IS_GLOBAL
operator|||
operator|!
name|APR_HAS_THREADS
operator|||
name|defined
argument_list|(
name|SYSVSEM_IS_GLOBAL
argument_list|)
name|APR_PROCESS_LOCK_MECH_IS_GLOBAL
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
name|proc_mutex_sysv_create
block|,
name|proc_mutex_sysv_acquire
block|,
name|proc_mutex_sysv_tryacquire
block|,
name|proc_mutex_sysv_release
block|,
name|proc_mutex_sysv_cleanup
block|,
name|proc_mutex_no_child_init
block|,
literal|"sysvsem"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SysV sem implementation */
end_comment

begin_if
if|#
directive|if
name|APR_HAS_PROC_PTHREAD_SERIALIZE
end_if

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_proc_pthread_cleanup
parameter_list|(
name|void
modifier|*
name|mutex_
parameter_list|)
block|{
name|apr_proc_mutex_t
modifier|*
name|mutex
init|=
name|mutex_
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
name|mutex
operator|->
name|curr_locked
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_unlock
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
comment|/* curr_locked is set to -1 until the mutex has been created */
if|if
condition|(
name|mutex
operator|->
name|curr_locked
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_destroy
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
if|if
condition|(
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|mutex
operator|->
name|pthread_interproc
argument_list|,
sizeof|sizeof
argument_list|(
name|pthread_mutex_t
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_proc_pthread_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|new_mutex
operator|->
name|pthread_interproc
operator|=
operator|(
name|pthread_mutex_t
operator|*
operator|)
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pthread_mutex_t
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mutex
operator|->
name|pthread_interproc
operator|==
operator|(
name|pthread_mutex_t
operator|*
operator|)
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|new_mutex
operator|->
name|curr_locked
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* until the mutex has been created */
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutexattr_setpshared
argument_list|(
operator|&
name|mattr
argument_list|,
name|PTHREAD_PROCESS_SHARED
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PTHREAD_MUTEX_ROBUST
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutexattr_setrobust_np
argument_list|(
operator|&
name|mattr
argument_list|,
name|PTHREAD_MUTEX_ROBUST_NP
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|PTHREAD_PRIO_INHERIT
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_PTHREAD_MUTEX_ROBUST */
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_init
argument_list|(
name|new_mutex
operator|->
name|pthread_interproc
argument_list|,
operator|&
name|mattr
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|new_mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
comment|/* mutex created now */
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
name|proc_mutex_proc_pthread_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|apr_pool_cleanup_register
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_proc_pthread_acquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_lock
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PTHREAD_MUTEX_ROBUST
comment|/* Okay, our owner died.  Let's try to make it consistent again. */
if|if
condition|(
name|rv
operator|==
name|EOWNERDEAD
condition|)
block|{
name|pthread_mutex_consistent_np
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|rv
return|;
else|#
directive|else
return|return
name|rv
return|;
endif|#
directive|endif
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_proc_pthread_tryacquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_trylock
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rv
operator|==
name|EBUSY
condition|)
block|{
return|return
name|APR_EBUSY
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PTHREAD_MUTEX_ROBUST
comment|/* Okay, our owner died.  Let's try to make it consistent again. */
if|if
condition|(
name|rv
operator|==
name|EOWNERDEAD
condition|)
block|{
name|pthread_mutex_consistent_np
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
expr_stmt|;
name|rv
operator|=
name|APR_SUCCESS
expr_stmt|;
block|}
else|else
return|return
name|rv
return|;
else|#
directive|else
return|return
name|rv
return|;
endif|#
directive|endif
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_proc_pthread_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pthread_mutex_unlock
argument_list|(
name|mutex
operator|->
name|pthread_interproc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZOS_PTHREADS
name|rv
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|apr_proc_mutex_unix_lock_methods_t
name|mutex_proc_pthread_methods
init|=
block|{
name|APR_PROCESS_LOCK_MECH_IS_GLOBAL
block|,
name|proc_mutex_proc_pthread_create
block|,
name|proc_mutex_proc_pthread_acquire
block|,
name|proc_mutex_proc_pthread_tryacquire
block|,
name|proc_mutex_proc_pthread_release
block|,
name|proc_mutex_proc_pthread_cleanup
block|,
name|proc_mutex_no_child_init
block|,
literal|"pthread"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAS_FCNTL_SERIALIZE
end_if

begin_decl_stmt
specifier|static
name|struct
name|flock
name|proc_mutex_lock_it
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|flock
name|proc_mutex_unlock_it
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|proc_mutex_fcntl_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|proc_mutex_lock_it
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
comment|/* from current point */
name|proc_mutex_lock_it
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
comment|/* -"- */
name|proc_mutex_lock_it
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
comment|/* until end of file */
name|proc_mutex_lock_it
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
comment|/* set exclusive/write lock */
name|proc_mutex_lock_it
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
comment|/* pid not actually interesting */
name|proc_mutex_unlock_it
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
comment|/* from current point */
name|proc_mutex_unlock_it
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
comment|/* -"- */
name|proc_mutex_unlock_it
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
comment|/* until end of file */
name|proc_mutex_unlock_it
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
comment|/* set exclusive/write lock */
name|proc_mutex_unlock_it
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
comment|/* pid not actually interesting */
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_cleanup
parameter_list|(
name|void
modifier|*
name|mutex_
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_proc_mutex_t
modifier|*
name|mutex
init|=
name|mutex_
decl_stmt|;
if|if
condition|(
name|mutex
operator|->
name|curr_locked
operator|==
literal|1
condition|)
block|{
name|status
operator|=
name|proc_mutex_fcntl_release
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|apr_file_close
argument_list|(
name|mutex
operator|->
name|interproc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_file_open
argument_list|(
operator|&
name|new_mutex
operator|->
name|interproc
argument_list|,
name|new_mutex
operator|->
name|fname
argument_list|,
name|APR_FOPEN_CREATE
operator||
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_EXCL
argument_list|,
name|APR_UREAD
operator||
name|APR_UWRITE
operator||
name|APR_GREAD
operator||
name|APR_WREAD
argument_list|,
name|new_mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
literal|"/tmp/aprXXXXXX"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_file_mktemp
argument_list|(
operator|&
name|new_mutex
operator|->
name|interproc
argument_list|,
name|new_mutex
operator|->
name|fname
argument_list|,
name|APR_FOPEN_CREATE
operator||
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_EXCL
argument_list|,
name|new_mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|new_mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|new_mutex
operator|->
name|fname
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_acquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|fcntl
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|proc_mutex_lock_it
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_tryacquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|fcntl
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|proc_mutex_lock_it
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|FCNTL_TRYACQUIRE_EACCES
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
endif|#
directive|endif
return|return
name|APR_EBUSY
return|;
block|}
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_fcntl_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|fcntl
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|proc_mutex_unlock_it
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
specifier|const
name|apr_proc_mutex_unix_lock_methods_t
name|mutex_fcntl_methods
init|=
block|{
if|#
directive|if
name|APR_PROCESS_LOCK_IS_GLOBAL
operator|||
operator|!
name|APR_HAS_THREADS
operator|||
name|defined
argument_list|(
name|FCNTL_IS_GLOBAL
argument_list|)
name|APR_PROCESS_LOCK_MECH_IS_GLOBAL
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
name|proc_mutex_fcntl_create
block|,
name|proc_mutex_fcntl_acquire
block|,
name|proc_mutex_fcntl_tryacquire
block|,
name|proc_mutex_fcntl_release
block|,
name|proc_mutex_fcntl_cleanup
block|,
name|proc_mutex_no_child_init
block|,
literal|"fcntl"
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* fcntl implementation */
if|#
directive|if
name|APR_HAS_FLOCK_SERIALIZE
specifier|static
name|apr_status_t
name|proc_mutex_flock_release
argument_list|(
name|apr_proc_mutex_t
operator|*
argument_list|)
decl_stmt|;
specifier|static
name|apr_status_t
name|proc_mutex_flock_cleanup
parameter_list|(
name|void
modifier|*
name|mutex_
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_proc_mutex_t
modifier|*
name|mutex
init|=
name|mutex_
decl_stmt|;
if|if
condition|(
name|mutex
operator|->
name|curr_locked
operator|==
literal|1
condition|)
block|{
name|status
operator|=
name|proc_mutex_flock_release
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|mutex
operator|->
name|interproc
condition|)
block|{
comment|/* if it was opened properly */
name|apr_file_close
argument_list|(
name|mutex
operator|->
name|interproc
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|mutex
operator|->
name|fname
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_flock_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_file_open
argument_list|(
operator|&
name|new_mutex
operator|->
name|interproc
argument_list|,
name|new_mutex
operator|->
name|fname
argument_list|,
name|APR_FOPEN_CREATE
operator||
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_EXCL
argument_list|,
name|APR_UREAD
operator||
name|APR_UWRITE
argument_list|,
name|new_mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
literal|"/tmp/aprXXXXXX"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_file_mktemp
argument_list|(
operator|&
name|new_mutex
operator|->
name|interproc
argument_list|,
name|new_mutex
operator|->
name|fname
argument_list|,
name|APR_FOPEN_CREATE
operator||
name|APR_FOPEN_WRITE
operator||
name|APR_FOPEN_EXCL
argument_list|,
name|new_mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|proc_mutex_flock_cleanup
argument_list|(
name|new_mutex
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
name|new_mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|new_mutex
operator|->
name|pool
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_mutex
argument_list|,
name|apr_proc_mutex_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_flock_acquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|flock
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_flock_tryacquire
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
do|do
block|{
name|rc
operator|=
name|flock
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
block|{
return|return
name|APR_EBUSY
return|;
block|}
return|return
name|errno
return|;
block|}
name|mutex
operator|->
name|curr_locked
operator|=
literal|1
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_flock_release
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|mutex
operator|->
name|curr_locked
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|flock
argument_list|(
name|mutex
operator|->
name|interproc
operator|->
name|filedes
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_flock_child_init
parameter_list|(
name|apr_proc_mutex_t
modifier|*
modifier|*
name|mutex
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|apr_proc_mutex_t
modifier|*
name|new_mutex
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|new_mutex
operator|=
operator|(
name|apr_proc_mutex_t
operator|*
operator|)
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_proc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_mutex
argument_list|,
operator|*
name|mutex
argument_list|,
sizeof|sizeof
expr|*
name|new_mutex
argument_list|)
expr_stmt|;
name|new_mutex
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
operator|!
name|fname
condition|)
block|{
name|fname
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|fname
expr_stmt|;
block|}
name|new_mutex
operator|->
name|fname
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|rv
operator|=
name|apr_file_open
argument_list|(
operator|&
name|new_mutex
operator|->
name|interproc
argument_list|,
name|new_mutex
operator|->
name|fname
argument_list|,
name|APR_FOPEN_WRITE
argument_list|,
literal|0
argument_list|,
name|new_mutex
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
operator|*
name|mutex
operator|=
name|new_mutex
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
specifier|static
specifier|const
name|apr_proc_mutex_unix_lock_methods_t
name|mutex_flock_methods
init|=
block|{
if|#
directive|if
name|APR_PROCESS_LOCK_IS_GLOBAL
operator|||
operator|!
name|APR_HAS_THREADS
operator|||
name|defined
argument_list|(
name|FLOCK_IS_GLOBAL
argument_list|)
name|APR_PROCESS_LOCK_MECH_IS_GLOBAL
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
name|proc_mutex_flock_create
block|,
name|proc_mutex_flock_acquire
block|,
name|proc_mutex_flock_tryacquire
block|,
name|proc_mutex_flock_release
block|,
name|proc_mutex_flock_cleanup
block|,
name|proc_mutex_flock_child_init
block|,
literal|"flock"
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* flock implementation */
name|void
name|apr_proc_mutex_unix_setup_lock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* setup only needed for sysvsem and fnctl */
if|#
directive|if
name|APR_HAS_SYSVSEM_SERIALIZE
name|proc_mutex_sysv_setup
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_FCNTL_SERIALIZE
name|proc_mutex_fcntl_setup
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|apr_status_t
name|proc_mutex_choose_method
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
name|apr_lockmech_e
name|mech
parameter_list|)
block|{
switch|switch
condition|(
name|mech
condition|)
block|{
case|case
name|APR_LOCK_FCNTL
case|:
if|#
directive|if
name|APR_HAS_FCNTL_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_fcntl_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
case|case
name|APR_LOCK_FLOCK
case|:
if|#
directive|if
name|APR_HAS_FLOCK_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_flock_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
case|case
name|APR_LOCK_SYSVSEM
case|:
if|#
directive|if
name|APR_HAS_SYSVSEM_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_sysv_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
case|case
name|APR_LOCK_POSIXSEM
case|:
if|#
directive|if
name|APR_HAS_POSIXSEM_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_posixsem_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
case|case
name|APR_LOCK_PROC_PTHREAD
case|:
if|#
directive|if
name|APR_HAS_PROC_PTHREAD_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_proc_pthread_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
case|case
name|APR_LOCK_DEFAULT
case|:
if|#
directive|if
name|APR_USE_FLOCK_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_flock_methods
expr_stmt|;
elif|#
directive|elif
name|APR_USE_SYSVSEM_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_sysv_methods
expr_stmt|;
elif|#
directive|elif
name|APR_USE_FCNTL_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_fcntl_methods
expr_stmt|;
elif|#
directive|elif
name|APR_USE_PROC_PTHREAD_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_proc_pthread_methods
expr_stmt|;
elif|#
directive|elif
name|APR_USE_POSIXSEM_SERIALIZE
name|new_mutex
operator|->
name|inter_meth
operator|=
operator|&
name|mutex_posixsem_methods
expr_stmt|;
else|#
directive|else
return|return
name|APR_ENOTIMPL
return|;
endif|#
directive|endif
break|break;
default|default:
return|return
name|APR_ENOTIMPL
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|const char *
argument_list|)
name|apr_proc_mutex_defname
argument_list|(
argument|void
argument_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
name|apr_proc_mutex_t
name|mutex
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|proc_mutex_choose_method
argument_list|(
operator|&
name|mutex
argument_list|,
name|APR_LOCK_DEFAULT
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
literal|"unknown"
return|;
block|}
name|mutex
operator|.
name|meth
operator|=
name|mutex
operator|.
name|inter_meth
expr_stmt|;
return|return
name|apr_proc_mutex_name
argument_list|(
operator|&
name|mutex
argument_list|)
return|;
block|}
specifier|static
name|apr_status_t
name|proc_mutex_create
parameter_list|(
name|apr_proc_mutex_t
modifier|*
name|new_mutex
parameter_list|,
name|apr_lockmech_e
name|mech
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|proc_mutex_choose_method
argument_list|(
name|new_mutex
argument_list|,
name|mech
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|new_mutex
operator|->
name|meth
operator|=
name|new_mutex
operator|->
name|inter_meth
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|new_mutex
operator|->
name|meth
operator|->
name|create
argument_list|(
name|new_mutex
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_create
argument_list|(
argument|apr_proc_mutex_t **mutex
argument_list|,
argument|const char *fname
argument_list|,
argument|apr_lockmech_e mech
argument_list|,
argument|apr_pool_t *pool
argument_list|)
block|{
name|apr_proc_mutex_t
modifier|*
name|new_mutex
decl_stmt|;
name|apr_status_t
name|rv
decl_stmt|;
name|new_mutex
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_proc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_mutex
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|proc_mutex_create
argument_list|(
name|new_mutex
argument_list|,
name|mech
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|rv
return|;
operator|*
name|mutex
operator|=
name|new_mutex
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_child_init
argument_list|(
argument|apr_proc_mutex_t **mutex
argument_list|,
argument|const char *fname
argument_list|,
argument|apr_pool_t *pool
argument_list|)
block|{
return|return
operator|(
operator|*
name|mutex
operator|)
operator|->
name|meth
operator|->
name|child_init
argument_list|(
name|mutex
argument_list|,
name|pool
argument_list|,
name|fname
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_lock
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
block|{
return|return
name|mutex
operator|->
name|meth
operator|->
name|acquire
argument_list|(
name|mutex
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_trylock
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
block|{
return|return
name|mutex
operator|->
name|meth
operator|->
name|tryacquire
argument_list|(
name|mutex
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_unlock
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
block|{
return|return
name|mutex
operator|->
name|meth
operator|->
name|release
argument_list|(
name|mutex
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_proc_mutex_cleanup
argument_list|(
argument|void *mutex
argument_list|)
block|{
return|return
operator|(
operator|(
name|apr_proc_mutex_t
operator|*
operator|)
name|mutex
operator|)
operator|->
name|meth
operator|->
name|cleanup
argument_list|(
name|mutex
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|const char *
argument_list|)
name|apr_proc_mutex_name
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
block|{
return|return
name|mutex
operator|->
name|meth
operator|->
name|name
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|const char *
argument_list|)
name|apr_proc_mutex_lockfile
argument_list|(
argument|apr_proc_mutex_t *mutex
argument_list|)
block|{
comment|/* POSIX sems use the fname field but don't use a file,      * so be careful. */
if|#
directive|if
name|APR_HAS_FLOCK_SERIALIZE
if|if
condition|(
name|mutex
operator|->
name|meth
operator|==
operator|&
name|mutex_flock_methods
condition|)
block|{
return|return
name|mutex
operator|->
name|fname
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_FCNTL_SERIALIZE
if|if
condition|(
name|mutex
operator|->
name|meth
operator|==
operator|&
name|mutex_fcntl_methods
condition|)
block|{
return|return
name|mutex
operator|->
name|fname
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
name|APR_POOL_IMPLEMENT_ACCESSOR
argument_list|(
argument|proc_mutex
argument_list|)
comment|/* Implement OS-specific accessors defined in apr_portable.h */
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_os_proc_mutex_get
argument_list|(
argument|apr_os_proc_mutex_t *ospmutex
argument_list|,
argument|apr_proc_mutex_t *pmutex
argument_list|)
block|{
if|#
directive|if
name|APR_HAS_SYSVSEM_SERIALIZE
operator|||
name|APR_HAS_FCNTL_SERIALIZE
operator|||
name|APR_HAS_FLOCK_SERIALIZE
operator|||
name|APR_HAS_POSIXSEM_SERIALIZE
if|if
condition|(
name|pmutex
operator|->
name|interproc
condition|)
block|{
name|ospmutex
operator|->
name|crossproc
operator|=
name|pmutex
operator|->
name|interproc
operator|->
name|filedes
expr_stmt|;
block|}
else|else
block|{
name|ospmutex
operator|->
name|crossproc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_PROC_PTHREAD_SERIALIZE
name|ospmutex
operator|->
name|pthread_interproc
operator|=
name|pmutex
operator|->
name|pthread_interproc
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_os_proc_mutex_put
argument_list|(
argument|apr_proc_mutex_t **pmutex
argument_list|,
argument|apr_os_proc_mutex_t *ospmutex
argument_list|,
argument|apr_pool_t *pool
argument_list|)
block|{
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
return|return
name|APR_ENOPOOL
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|pmutex
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
operator|*
name|pmutex
operator|)
operator|=
operator|(
name|apr_proc_mutex_t
operator|*
operator|)
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_proc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pmutex
operator|)
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAS_SYSVSEM_SERIALIZE
operator|||
name|APR_HAS_FCNTL_SERIALIZE
operator|||
name|APR_HAS_FLOCK_SERIALIZE
operator|||
name|APR_HAS_POSIXSEM_SERIALIZE
name|apr_os_file_put
argument_list|(
operator|&
operator|(
operator|*
name|pmutex
operator|)
operator|->
name|interproc
argument_list|,
operator|&
name|ospmutex
operator|->
name|crossproc
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|APR_HAS_PROC_PTHREAD_SERIALIZE
operator|(
operator|*
name|pmutex
operator|)
operator|->
name|pthread_interproc
operator|=
name|ospmutex
operator|->
name|pthread_interproc
expr_stmt|;
endif|#
directive|endif
return|return
name|APR_SUCCESS
return|;
block|}
end_function

end_unit

