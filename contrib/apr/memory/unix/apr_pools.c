begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_include
include|#
directive|include
file|"apr.h"
end_include

begin_include
include|#
directive|include
file|"apr_private.h"
end_include

begin_include
include|#
directive|include
file|"apr_atomic.h"
end_include

begin_include
include|#
directive|include
file|"apr_portable.h"
end_include

begin_comment
comment|/* for get_os_proc */
end_comment

begin_include
include|#
directive|include
file|"apr_strings.h"
end_include

begin_include
include|#
directive|include
file|"apr_general.h"
end_include

begin_include
include|#
directive|include
file|"apr_pools.h"
end_include

begin_include
include|#
directive|include
file|"apr_allocator.h"
end_include

begin_include
include|#
directive|include
file|"apr_lib.h"
end_include

begin_include
include|#
directive|include
file|"apr_thread_mutex.h"
end_include

begin_include
include|#
directive|include
file|"apr_hash.h"
end_include

begin_include
include|#
directive|include
file|"apr_time.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_MEMFUNC
end_define

begin_include
include|#
directive|include
file|"apr_want.h"
end_include

begin_include
include|#
directive|include
file|"apr_env.h"
end_include

begin_if
if|#
directive|if
name|APR_HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for malloc, free and abort */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* for getpid and sysconf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
end_if

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Magic numbers  */
end_comment

begin_comment
comment|/*  * XXX: This is not optimal when using --enable-allocator-uses-mmap on  * XXX: machines with large pagesize, but currently the sink is assumed  * XXX: to be index 0, so MIN_ALLOC must be at least two pages.  */
end_comment

begin_define
define|#
directive|define
name|MIN_ALLOC
value|(2 * BOUNDARY_SIZE)
end_define

begin_define
define|#
directive|define
name|MAX_INDEX
value|20
end_define

begin_if
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
operator|&&
name|defined
argument_list|(
name|_SC_PAGESIZE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|boundary_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|boundary_size
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BOUNDARY_INDEX
value|boundary_index
end_define

begin_define
define|#
directive|define
name|BOUNDARY_SIZE
value|boundary_size
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BOUNDARY_INDEX
value|12
end_define

begin_define
define|#
directive|define
name|BOUNDARY_SIZE
value|(1<< BOUNDARY_INDEX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Timing constants for killing subprocesses  * There is a total 3-second delay between sending a SIGINT   * and sending of the final SIGKILL.  * TIMEOUT_INTERVAL should be set to TIMEOUT_USECS / 64  * for the exponetial timeout alogrithm.  */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT_USECS
value|3000000
end_define

begin_define
define|#
directive|define
name|TIMEOUT_INTERVAL
value|46875
end_define

begin_comment
comment|/*  * Allocator  *  * @note The max_free_index and current_free_index fields are not really  * indices, but quantities of BOUNDARY_SIZE big memory blocks.  */
end_comment

begin_struct
struct|struct
name|apr_allocator_t
block|{
comment|/** largest used index into free[], always< MAX_INDEX */
name|apr_uint32_t
name|max_index
decl_stmt|;
comment|/** Total size (in BOUNDARY_SIZE multiples) of unused memory before      * blocks are given back. @see apr_allocator_max_free_set().      * @note Initialized to APR_ALLOCATOR_MAX_FREE_UNLIMITED,      * which means to never give back blocks.      */
name|apr_uint32_t
name|max_free_index
decl_stmt|;
comment|/**      * Memory size (in BOUNDARY_SIZE multiples) that currently must be freed      * before blocks are given back. Range: 0..max_free_index      */
name|apr_uint32_t
name|current_free_index
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|apr_pool_t
modifier|*
name|owner
decl_stmt|;
comment|/**      * Lists of free nodes. Slot 0 is used for oversized nodes,      * and the slots 1..MAX_INDEX-1 contain nodes of sizes      * (i+1) * BOUNDARY_SIZE. Example for BOUNDARY_INDEX == 12:      * slot  0: nodes larger than 81920      * slot  1: size  8192      * slot  2: size 12288      * ...      * slot 19: size 81920      */
name|apr_memnode_t
modifier|*
name|free
index|[
name|MAX_INDEX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_ALLOCATOR_T
value|APR_ALIGN_DEFAULT(sizeof(apr_allocator_t))
end_define

begin_comment
comment|/*  * Allocator  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_allocator_create
argument_list|(
argument|apr_allocator_t **allocator
argument_list|)
end_macro

begin_block
block|{
name|apr_allocator_t
modifier|*
name|new_allocator
decl_stmt|;
operator|*
name|allocator
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|new_allocator
operator|=
name|malloc
argument_list|(
name|SIZEOF_ALLOCATOR_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|APR_ENOMEM
return|;
name|memset
argument_list|(
name|new_allocator
argument_list|,
literal|0
argument_list|,
name|SIZEOF_ALLOCATOR_T
argument_list|)
expr_stmt|;
name|new_allocator
operator|->
name|max_free_index
operator|=
name|APR_ALLOCATOR_MAX_FREE_UNLIMITED
expr_stmt|;
operator|*
name|allocator
operator|=
name|new_allocator
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_allocator_destroy
argument_list|(
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
name|apr_uint32_t
name|index
decl_stmt|;
name|apr_memnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAX_INDEX
condition|;
name|index
operator|++
control|)
block|{
name|ref
operator|=
operator|&
name|allocator
operator|->
name|free
index|[
name|index
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
operator|*
name|ref
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ref
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
name|munmap
argument_list|(
name|node
argument_list|,
operator|(
name|node
operator|->
name|index
operator|+
literal|1
operator|)
operator|<<
name|BOUNDARY_INDEX
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_allocator_mutex_set
argument_list|(
argument|apr_allocator_t *allocator
argument_list|,
argument|apr_thread_mutex_t *mutex
argument_list|)
end_macro

begin_block
block|{
name|allocator
operator|->
name|mutex
operator|=
name|mutex
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_thread_mutex_t *
argument_list|)
end_macro

begin_macro
name|apr_allocator_mutex_get
argument_list|(
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
return|return
name|allocator
operator|->
name|mutex
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_allocator_owner_set
argument_list|(
argument|apr_allocator_t *allocator
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|allocator
operator|->
name|owner
operator|=
name|pool
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_pool_t *
argument_list|)
end_macro

begin_macro
name|apr_allocator_owner_get
argument_list|(
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
return|return
name|allocator
operator|->
name|owner
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_allocator_max_free_set
argument_list|(
argument|apr_allocator_t *allocator
argument_list|,
argument|apr_size_t in_size
argument_list|)
end_macro

begin_block
block|{
name|apr_uint32_t
name|max_free_index
decl_stmt|;
name|apr_uint32_t
name|size
init|=
operator|(
name|APR_UINT32_TRUNC_CAST
operator|)
name|in_size
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|apr_allocator_mutex_get
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex
operator|!=
name|NULL
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|max_free_index
operator|=
name|APR_ALIGN
argument_list|(
name|size
argument_list|,
name|BOUNDARY_SIZE
argument_list|)
operator|>>
name|BOUNDARY_INDEX
expr_stmt|;
name|allocator
operator|->
name|current_free_index
operator|+=
name|max_free_index
expr_stmt|;
name|allocator
operator|->
name|current_free_index
operator|-=
name|allocator
operator|->
name|max_free_index
expr_stmt|;
name|allocator
operator|->
name|max_free_index
operator|=
name|max_free_index
expr_stmt|;
if|if
condition|(
name|allocator
operator|->
name|current_free_index
operator|>
name|max_free_index
condition|)
name|allocator
operator|->
name|current_free_index
operator|=
name|max_free_index
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|mutex
operator|!=
name|NULL
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
specifier|static
name|APR_INLINE
name|apr_memnode_t
modifier|*
name|allocator_alloc
parameter_list|(
name|apr_allocator_t
modifier|*
name|allocator
parameter_list|,
name|apr_size_t
name|in_size
parameter_list|)
block|{
name|apr_memnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|ref
decl_stmt|;
name|apr_uint32_t
name|max_index
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|,
name|i
decl_stmt|,
name|index
decl_stmt|;
comment|/* Round up the block size to the next boundary, but always      * allocate at least a certain size (MIN_ALLOC).      */
name|size
operator|=
name|APR_ALIGN
argument_list|(
name|in_size
operator|+
name|APR_MEMNODE_T_SIZE
argument_list|,
name|BOUNDARY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|in_size
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|size
operator|<
name|MIN_ALLOC
condition|)
name|size
operator|=
name|MIN_ALLOC
expr_stmt|;
comment|/* Find the index for this node size by      * dividing its size by the boundary size      */
name|index
operator|=
operator|(
name|size
operator|>>
name|BOUNDARY_INDEX
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|APR_UINT32_MAX
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* First see if there are any nodes in the area we know      * our node will fit into.      */
if|if
condition|(
name|index
operator|<=
name|allocator
operator|->
name|max_index
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
comment|/* Walk the free list to see if there are          * any nodes on it of the requested size          *          * NOTE: an optimization would be to check          * allocator->free[index] first and if no          * node is present, directly use          * allocator->free[max_index].  This seems          * like overkill though and could cause          * memory waste.          */
name|max_index
operator|=
name|allocator
operator|->
name|max_index
expr_stmt|;
name|ref
operator|=
operator|&
name|allocator
operator|->
name|free
index|[
name|index
index|]
expr_stmt|;
name|i
operator|=
name|index
expr_stmt|;
while|while
condition|(
operator|*
name|ref
operator|==
name|NULL
operator|&&
name|i
operator|<
name|max_index
condition|)
block|{
name|ref
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|node
operator|=
operator|*
name|ref
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If we have found a node and it doesn't have any              * nodes waiting in line behind it _and_ we are on              * the highest available index, find the new highest              * available index              */
if|if
condition|(
operator|(
operator|*
name|ref
operator|=
name|node
operator|->
name|next
operator|)
operator|==
name|NULL
operator|&&
name|i
operator|>=
name|max_index
condition|)
block|{
do|do
block|{
name|ref
operator|--
expr_stmt|;
name|max_index
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ref
operator|==
name|NULL
operator|&&
name|max_index
operator|>
literal|0
condition|)
do|;
name|allocator
operator|->
name|max_index
operator|=
name|max_index
expr_stmt|;
block|}
name|allocator
operator|->
name|current_free_index
operator|+=
name|node
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|allocator
operator|->
name|current_free_index
operator|>
name|allocator
operator|->
name|max_free_index
condition|)
name|allocator
operator|->
name|current_free_index
operator|=
name|allocator
operator|->
name|max_free_index
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|first_avail
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|+
name|APR_MEMNODE_T_SIZE
expr_stmt|;
return|return
name|node
return|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
comment|/* If we found nothing, seek the sink (at index 0), if      * it is not empty.      */
elseif|else
if|if
condition|(
name|allocator
operator|->
name|free
index|[
literal|0
index|]
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
comment|/* Walk the free list to see if there are          * any nodes on it of the requested size          */
name|ref
operator|=
operator|&
name|allocator
operator|->
name|free
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
operator|*
name|ref
operator|)
operator|!=
name|NULL
operator|&&
name|index
operator|>
name|node
operator|->
name|index
condition|)
name|ref
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
operator|*
name|ref
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|allocator
operator|->
name|current_free_index
operator|+=
name|node
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|allocator
operator|->
name|current_free_index
operator|>
name|allocator
operator|->
name|max_free_index
condition|)
name|allocator
operator|->
name|current_free_index
operator|=
name|allocator
operator|->
name|max_free_index
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|first_avail
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|+
name|APR_MEMNODE_T_SIZE
expr_stmt|;
return|return
name|node
return|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
comment|/* If we haven't got a suitable node, malloc a new one      * and initialize it.      */
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
if|if
condition|(
operator|(
name|node
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
return|return
name|NULL
return|;
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|index
operator|=
operator|(
name|APR_UINT32_TRUNC_CAST
operator|)
name|index
expr_stmt|;
name|node
operator|->
name|first_avail
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|+
name|APR_MEMNODE_T_SIZE
expr_stmt|;
name|node
operator|->
name|endp
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|+
name|size
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
name|void
name|allocator_free
parameter_list|(
name|apr_allocator_t
modifier|*
name|allocator
parameter_list|,
name|apr_memnode_t
modifier|*
name|node
parameter_list|)
block|{
name|apr_memnode_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|freelist
init|=
name|NULL
decl_stmt|;
name|apr_uint32_t
name|index
decl_stmt|,
name|max_index
decl_stmt|;
name|apr_uint32_t
name|max_free_index
decl_stmt|,
name|current_free_index
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|max_index
operator|=
name|allocator
operator|->
name|max_index
expr_stmt|;
name|max_free_index
operator|=
name|allocator
operator|->
name|max_free_index
expr_stmt|;
name|current_free_index
operator|=
name|allocator
operator|->
name|current_free_index
expr_stmt|;
comment|/* Walk the list of submitted nodes and free them one by one,      * shoving them in the right 'size' buckets as we go.      */
do|do
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|index
operator|=
name|node
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|max_free_index
operator|!=
name|APR_ALLOCATOR_MAX_FREE_UNLIMITED
operator|&&
name|index
operator|+
literal|1
operator|>
name|current_free_index
condition|)
block|{
name|node
operator|->
name|next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|<
name|MAX_INDEX
condition|)
block|{
comment|/* Add the node to the appropiate 'size' bucket.  Adjust              * the max_index when appropiate.              */
if|if
condition|(
operator|(
name|node
operator|->
name|next
operator|=
name|allocator
operator|->
name|free
index|[
name|index
index|]
operator|)
operator|==
name|NULL
operator|&&
name|index
operator|>
name|max_index
condition|)
block|{
name|max_index
operator|=
name|index
expr_stmt|;
block|}
name|allocator
operator|->
name|free
index|[
name|index
index|]
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|current_free_index
operator|>=
name|index
operator|+
literal|1
condition|)
name|current_free_index
operator|-=
name|index
operator|+
literal|1
expr_stmt|;
else|else
name|current_free_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* This node is too large to keep in a specific size bucket,              * just add it to the sink (at index 0).              */
name|node
operator|->
name|next
operator|=
name|allocator
operator|->
name|free
index|[
literal|0
index|]
expr_stmt|;
name|allocator
operator|->
name|free
index|[
literal|0
index|]
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|current_free_index
operator|>=
name|index
operator|+
literal|1
condition|)
name|current_free_index
operator|-=
name|index
operator|+
literal|1
expr_stmt|;
else|else
name|current_free_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|node
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
name|allocator
operator|->
name|max_index
operator|=
name|max_index
expr_stmt|;
name|allocator
operator|->
name|current_free_index
operator|=
name|current_free_index
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|allocator
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|allocator
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
while|while
condition|(
name|freelist
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
name|munmap
argument_list|(
name|node
argument_list|,
operator|(
name|node
operator|->
name|index
operator|+
literal|1
operator|)
operator|<<
name|BOUNDARY_INDEX
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_memnode_t *
argument_list|)
end_macro

begin_macro
name|apr_allocator_alloc
argument_list|(
argument|apr_allocator_t *allocator
argument_list|,
argument|apr_size_t size
argument_list|)
end_macro

begin_block
block|{
return|return
name|allocator_alloc
argument_list|(
name|allocator
argument_list|,
name|size
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_allocator_free
argument_list|(
argument|apr_allocator_t *allocator
argument_list|,
argument|apr_memnode_t *node
argument_list|)
end_macro

begin_block
block|{
name|allocator_free
argument_list|(
name|allocator
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Debug level  */
end_comment

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_GENERAL
value|0x01
end_define

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_VERBOSE
value|0x02
end_define

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_LIFETIME
value|0x04
end_define

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_OWNER
value|0x08
end_define

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_VERBOSE_ALLOC
value|0x10
end_define

begin_define
define|#
directive|define
name|APR_POOL_DEBUG_VERBOSE_ALL
value|(APR_POOL_DEBUG_VERBOSE \                                     | APR_POOL_DEBUG_VERBOSE_ALLOC)
end_define

begin_comment
comment|/*  * Structures  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cleanup_t
name|cleanup_t
typedef|;
end_typedef

begin_comment
comment|/** A list of processes */
end_comment

begin_struct
struct|struct
name|process_chain
block|{
comment|/** The process ID */
name|apr_proc_t
modifier|*
name|proc
decl_stmt|;
name|apr_kill_conditions_e
name|kill_how
decl_stmt|;
comment|/** The next process in the list */
name|struct
name|process_chain
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|APR_POOL_DEBUG
end_if

begin_typedef
typedef|typedef
name|struct
name|debug_node_t
name|debug_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|debug_node_t
block|{
name|debug_node_t
modifier|*
name|next
decl_stmt|;
name|apr_uint32_t
name|index
decl_stmt|;
name|void
modifier|*
name|beginp
index|[
literal|64
index|]
decl_stmt|;
name|void
modifier|*
name|endp
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_DEBUG_NODE_T
value|APR_ALIGN_DEFAULT(sizeof(debug_node_t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_POOL_DEBUG */
end_comment

begin_comment
comment|/* The ref field in the apr_pool_t struct holds a  * pointer to the pointer referencing this pool.  * It is used for parent, child, sibling management.  * Look at apr_pool_create_ex() and apr_pool_destroy()  * to see how it is used.  */
end_comment

begin_struct
struct|struct
name|apr_pool_t
block|{
name|apr_pool_t
modifier|*
name|parent
decl_stmt|;
name|apr_pool_t
modifier|*
name|child
decl_stmt|;
name|apr_pool_t
modifier|*
name|sibling
decl_stmt|;
name|apr_pool_t
modifier|*
modifier|*
name|ref
decl_stmt|;
name|cleanup_t
modifier|*
name|cleanups
decl_stmt|;
name|cleanup_t
modifier|*
name|free_cleanups
decl_stmt|;
name|apr_allocator_t
modifier|*
name|allocator
decl_stmt|;
name|struct
name|process_chain
modifier|*
name|subprocesses
decl_stmt|;
name|apr_abortfunc_t
name|abort_fn
decl_stmt|;
name|apr_hash_t
modifier|*
name|user_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
if|#
directive|if
operator|!
name|APR_POOL_DEBUG
name|apr_memnode_t
modifier|*
name|active
decl_stmt|;
name|apr_memnode_t
modifier|*
name|self
decl_stmt|;
comment|/* The node containing the pool itself */
name|char
modifier|*
name|self_first_avail
decl_stmt|;
else|#
directive|else
comment|/* APR_POOL_DEBUG */
name|apr_pool_t
modifier|*
name|joined
decl_stmt|;
comment|/* the caller has guaranteed that this pool                                    * will survive as long as ->joined */
name|debug_node_t
modifier|*
name|nodes
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_line
decl_stmt|;
name|apr_uint32_t
name|creation_flags
decl_stmt|;
name|unsigned
name|int
name|stat_alloc
decl_stmt|;
name|unsigned
name|int
name|stat_total_alloc
decl_stmt|;
name|unsigned
name|int
name|stat_clear
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_os_thread_t
name|owner
decl_stmt|;
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
ifdef|#
directive|ifdef
name|NETWARE
name|apr_os_proc_t
name|owner_proc
decl_stmt|;
endif|#
directive|endif
comment|/* defined(NETWARE) */
name|cleanup_t
modifier|*
name|pre_cleanups
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_POOL_T
value|APR_ALIGN_DEFAULT(sizeof(apr_pool_t))
end_define

begin_comment
comment|/*  * Variables  */
end_comment

begin_decl_stmt
specifier|static
name|apr_byte_t
name|apr_pools_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|apr_pool_t
modifier|*
name|global_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|APR_POOL_DEBUG
end_if

begin_decl_stmt
specifier|static
name|apr_allocator_t
modifier|*
name|global_allocator
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APR_POOL_DEBUG */
end_comment

begin_if
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
end_if

begin_decl_stmt
specifier|static
name|apr_file_t
modifier|*
name|file_stderr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
end_comment

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|run_cleanups
parameter_list|(
name|cleanup_t
modifier|*
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_proc_chain
parameter_list|(
name|struct
name|process_chain
modifier|*
name|procs
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|APR_POOL_DEBUG
end_if

begin_function_decl
specifier|static
name|void
name|pool_destroy_debug
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|file_line
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|APR_POOL_DEBUG
end_if

begin_comment
comment|/*  * Initialization  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_initialize
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
name|apr_pools_initialized
operator|++
condition|)
return|return
name|APR_SUCCESS
return|;
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
operator|&&
name|defined
argument_list|(
name|_SC_PAGESIZE
argument_list|)
name|boundary_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
name|boundary_index
operator|=
literal|12
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|boundary_index
operator|)
operator|<
name|boundary_size
condition|)
name|boundary_index
operator|++
expr_stmt|;
name|boundary_size
operator|=
operator|(
literal|1
operator|<<
name|boundary_index
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_allocator_create
argument_list|(
operator|&
name|global_allocator
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|apr_pools_initialized
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_pool_create_ex
argument_list|(
operator|&
name|global_pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|global_allocator
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|apr_allocator_destroy
argument_list|(
name|global_allocator
argument_list|)
expr_stmt|;
name|global_allocator
operator|=
name|NULL
expr_stmt|;
name|apr_pools_initialized
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
name|apr_pool_tag
argument_list|(
name|global_pool
argument_list|,
literal|"apr_global_pool"
argument_list|)
expr_stmt|;
comment|/* This has to happen here because mutexes might be backed by      * atomics.  It used to be snug and safe in apr_initialize().      *      * Warning: apr_atomic_init() must always be called, by any      * means possible, from apr_initialize().      */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_atomic_init
argument_list|(
name|global_pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
block|{
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|mutex
argument_list|,
name|APR_THREAD_MUTEX_DEFAULT
argument_list|,
name|global_pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|apr_allocator_mutex_set
argument_list|(
name|global_allocator
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|apr_allocator_owner_set
argument_list|(
name|global_allocator
argument_list|,
name|global_pool
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_terminate
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|apr_pools_initialized
condition|)
return|return;
if|if
condition|(
operator|--
name|apr_pools_initialized
condition|)
return|return;
name|apr_pool_destroy
argument_list|(
name|global_pool
argument_list|)
expr_stmt|;
comment|/* This will also destroy the mutex */
name|global_pool
operator|=
name|NULL
expr_stmt|;
name|global_allocator
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Node list management helper macros; list_insert() inserts 'node'  * before 'point'. */
end_comment

begin_define
define|#
directive|define
name|list_insert
parameter_list|(
name|node
parameter_list|,
name|point
parameter_list|)
value|do {           \     node->ref = point->ref;                     \     *node->ref = node;                          \     node->next = point;                         \     point->ref =&node->next;                   \ } while (0)
end_define

begin_comment
comment|/* list_remove() removes 'node' from its list. */
end_comment

begin_define
define|#
directive|define
name|list_remove
parameter_list|(
name|node
parameter_list|)
value|do {                  \     *node->ref = node->next;                    \     node->next->ref = node->ref;                \ } while (0)
end_define

begin_comment
comment|/* Returns the amount of free space in the given node. */
end_comment

begin_define
define|#
directive|define
name|node_free_space
parameter_list|(
name|node_
parameter_list|)
value|((apr_size_t)(node_->endp - node_->first_avail))
end_define

begin_comment
comment|/*  * Memory allocation  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_palloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t in_size
argument_list|)
end_macro

begin_block
block|{
name|apr_memnode_t
modifier|*
name|active
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|,
name|free_index
decl_stmt|;
name|size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|in_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|in_size
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|active
operator|=
name|pool
operator|->
name|active
expr_stmt|;
comment|/* If the active node has enough bytes left, use it. */
if|if
condition|(
name|size
operator|<=
name|node_free_space
argument_list|(
name|active
argument_list|)
condition|)
block|{
name|mem
operator|=
name|active
operator|->
name|first_avail
expr_stmt|;
name|active
operator|->
name|first_avail
operator|+=
name|size
expr_stmt|;
return|return
name|mem
return|;
block|}
name|node
operator|=
name|active
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|node_free_space
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|allocator_alloc
argument_list|(
name|pool
operator|->
name|allocator
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|node
operator|->
name|free_index
operator|=
literal|0
expr_stmt|;
name|mem
operator|=
name|node
operator|->
name|first_avail
expr_stmt|;
name|node
operator|->
name|first_avail
operator|+=
name|size
expr_stmt|;
name|list_insert
argument_list|(
name|node
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|pool
operator|->
name|active
operator|=
name|node
expr_stmt|;
name|free_index
operator|=
operator|(
name|APR_ALIGN
argument_list|(
name|active
operator|->
name|endp
operator|-
name|active
operator|->
name|first_avail
operator|+
literal|1
argument_list|,
name|BOUNDARY_SIZE
argument_list|)
operator|-
name|BOUNDARY_SIZE
operator|)
operator|>>
name|BOUNDARY_INDEX
expr_stmt|;
name|active
operator|->
name|free_index
operator|=
operator|(
name|APR_UINT32_TRUNC_CAST
operator|)
name|free_index
expr_stmt|;
name|node
operator|=
name|active
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|free_index
operator|>=
name|node
operator|->
name|free_index
condition|)
return|return
name|mem
return|;
do|do
block|{
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|free_index
operator|<
name|node
operator|->
name|free_index
condition|)
do|;
name|list_remove
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|list_insert
argument_list|(
name|active
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_block

begin_comment
comment|/* Provide an implementation of apr_pcalloc for backward compatibility  * with code built before apr_pcalloc was a macro  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|apr_pcalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|apr_pcalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_pcalloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_pcalloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|mem
return|;
block|}
end_block

begin_comment
comment|/*  * Pool creation/destruction  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_clear
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_memnode_t
modifier|*
name|active
decl_stmt|;
comment|/* Run pre destroy cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|pre_cleanups
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pre_cleanups
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the subpools.  The subpools will detach themselves from      * this pool thus this loop is safe and easy.      */
while|while
condition|(
name|pool
operator|->
name|child
condition|)
name|apr_pool_destroy
argument_list|(
name|pool
operator|->
name|child
argument_list|)
expr_stmt|;
comment|/* Run cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|cleanups
argument_list|)
expr_stmt|;
name|pool
operator|->
name|cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|free_cleanups
operator|=
name|NULL
expr_stmt|;
comment|/* Free subprocesses */
name|free_proc_chain
argument_list|(
name|pool
operator|->
name|subprocesses
argument_list|)
expr_stmt|;
name|pool
operator|->
name|subprocesses
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the user data. */
name|pool
operator|->
name|user_data
operator|=
name|NULL
expr_stmt|;
comment|/* Find the node attached to the pool structure, reset it, make      * it the active node and free the rest of the nodes.      */
name|active
operator|=
name|pool
operator|->
name|active
operator|=
name|pool
operator|->
name|self
expr_stmt|;
name|active
operator|->
name|first_avail
operator|=
name|pool
operator|->
name|self_first_avail
expr_stmt|;
if|if
condition|(
name|active
operator|->
name|next
operator|==
name|active
condition|)
return|return;
operator|*
name|active
operator|->
name|ref
operator|=
name|NULL
expr_stmt|;
name|allocator_free
argument_list|(
name|pool
operator|->
name|allocator
argument_list|,
name|active
operator|->
name|next
argument_list|)
expr_stmt|;
name|active
operator|->
name|next
operator|=
name|active
expr_stmt|;
name|active
operator|->
name|ref
operator|=
operator|&
name|active
operator|->
name|next
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_destroy
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|apr_memnode_t
modifier|*
name|active
decl_stmt|;
name|apr_allocator_t
modifier|*
name|allocator
decl_stmt|;
comment|/* Run pre destroy cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|pre_cleanups
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pre_cleanups
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the subpools.  The subpools will detach themselve from      * this pool thus this loop is safe and easy.      */
while|while
condition|(
name|pool
operator|->
name|child
condition|)
name|apr_pool_destroy
argument_list|(
name|pool
operator|->
name|child
argument_list|)
expr_stmt|;
comment|/* Run cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|cleanups
argument_list|)
expr_stmt|;
comment|/* Free subprocesses */
name|free_proc_chain
argument_list|(
name|pool
operator|->
name|subprocesses
argument_list|)
expr_stmt|;
comment|/* Remove the pool from the parents child list */
if|if
condition|(
name|pool
operator|->
name|parent
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
if|if
condition|(
operator|(
name|mutex
operator|=
name|apr_allocator_mutex_get
argument_list|(
name|pool
operator|->
name|parent
operator|->
name|allocator
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
if|if
condition|(
operator|(
operator|*
name|pool
operator|->
name|ref
operator|=
name|pool
operator|->
name|sibling
operator|)
operator|!=
name|NULL
condition|)
name|pool
operator|->
name|sibling
operator|->
name|ref
operator|=
name|pool
operator|->
name|ref
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
comment|/* Find the block attached to the pool structure.  Save a copy of the      * allocator pointer, because the pool struct soon will be no more.      */
name|allocator
operator|=
name|pool
operator|->
name|allocator
expr_stmt|;
name|active
operator|=
name|pool
operator|->
name|self
expr_stmt|;
operator|*
name|active
operator|->
name|ref
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|apr_allocator_owner_get
argument_list|(
name|allocator
argument_list|)
operator|==
name|pool
condition|)
block|{
comment|/* Make sure to remove the lock, since it is highly likely to          * be invalid now.          */
name|apr_allocator_mutex_set
argument_list|(
name|allocator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
comment|/* Free all the nodes in the pool (including the node holding the      * pool struct), by giving them back to the allocator.      */
name|allocator_free
argument_list|(
name|allocator
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/* If this pool happens to be the owner of the allocator, free      * everything in the allocator (that includes the pool struct      * and the allocator).  Don't worry about destroying the optional mutex      * in the allocator, it will have been destroyed by the cleanup function.      */
if|if
condition|(
name|apr_allocator_owner_get
argument_list|(
name|allocator
argument_list|)
operator|==
name|pool
condition|)
block|{
name|apr_allocator_destroy
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_pool_t *parent
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_memnode_t
modifier|*
name|node
decl_stmt|;
operator|*
name|newpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
name|parent
operator|=
name|global_pool
expr_stmt|;
comment|/* parent will always be non-NULL here except the first time a      * pool is created, in which case allocator is guaranteed to be      * non-NULL. */
if|if
condition|(
operator|!
name|abort_fn
operator|&&
name|parent
condition|)
name|abort_fn
operator|=
name|parent
operator|->
name|abort_fn
expr_stmt|;
if|if
condition|(
name|allocator
operator|==
name|NULL
condition|)
name|allocator
operator|=
name|parent
operator|->
name|allocator
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|allocator_alloc
argument_list|(
name|allocator
argument_list|,
name|MIN_ALLOC
operator|-
name|APR_MEMNODE_T_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|node
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|ref
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
name|pool
operator|=
operator|(
name|apr_pool_t
operator|*
operator|)
name|node
operator|->
name|first_avail
expr_stmt|;
name|node
operator|->
name|first_avail
operator|=
name|pool
operator|->
name|self_first_avail
operator|=
operator|(
name|char
operator|*
operator|)
name|pool
operator|+
name|SIZEOF_POOL_T
expr_stmt|;
name|pool
operator|->
name|allocator
operator|=
name|allocator
expr_stmt|;
name|pool
operator|->
name|active
operator|=
name|pool
operator|->
name|self
operator|=
name|node
expr_stmt|;
name|pool
operator|->
name|abort_fn
operator|=
name|abort_fn
expr_stmt|;
name|pool
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|free_cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|pre_cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|subprocesses
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|user_data
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NETWARE
name|pool
operator|->
name|owner_proc
operator|=
operator|(
name|apr_os_proc_t
operator|)
name|getnlmhandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(NETWARE) */
if|if
condition|(
operator|(
name|pool
operator|->
name|parent
operator|=
name|parent
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
if|if
condition|(
operator|(
name|mutex
operator|=
name|apr_allocator_mutex_get
argument_list|(
name|parent
operator|->
name|allocator
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
if|if
condition|(
operator|(
name|pool
operator|->
name|sibling
operator|=
name|parent
operator|->
name|child
operator|)
operator|!=
name|NULL
condition|)
name|pool
operator|->
name|sibling
operator|->
name|ref
operator|=
operator|&
name|pool
operator|->
name|sibling
expr_stmt|;
name|parent
operator|->
name|child
operator|=
name|pool
expr_stmt|;
name|pool
operator|->
name|ref
operator|=
operator|&
name|parent
operator|->
name|child
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
else|else
block|{
name|pool
operator|->
name|sibling
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|ref
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|newpool
operator|=
name|pool
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* Deprecated. Renamed to apr_pool_create_unmanaged_ex  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_core_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_create_unmanaged_ex
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_unmanaged_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_memnode_t
modifier|*
name|node
decl_stmt|;
name|apr_allocator_t
modifier|*
name|pool_allocator
decl_stmt|;
operator|*
name|newpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|apr_pools_initialized
condition|)
return|return
name|APR_ENOPOOL
return|;
if|if
condition|(
operator|(
name|pool_allocator
operator|=
name|allocator
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pool_allocator
operator|=
name|malloc
argument_list|(
name|SIZEOF_ALLOCATOR_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|memset
argument_list|(
name|pool_allocator
argument_list|,
literal|0
argument_list|,
name|SIZEOF_ALLOCATOR_T
argument_list|)
expr_stmt|;
name|pool_allocator
operator|->
name|max_free_index
operator|=
name|APR_ALLOCATOR_MAX_FREE_UNLIMITED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|node
operator|=
name|allocator_alloc
argument_list|(
name|pool_allocator
argument_list|,
name|MIN_ALLOC
operator|-
name|APR_MEMNODE_T_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|node
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|ref
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
name|pool
operator|=
operator|(
name|apr_pool_t
operator|*
operator|)
name|node
operator|->
name|first_avail
expr_stmt|;
name|node
operator|->
name|first_avail
operator|=
name|pool
operator|->
name|self_first_avail
operator|=
operator|(
name|char
operator|*
operator|)
name|pool
operator|+
name|SIZEOF_POOL_T
expr_stmt|;
name|pool
operator|->
name|allocator
operator|=
name|pool_allocator
expr_stmt|;
name|pool
operator|->
name|active
operator|=
name|pool
operator|->
name|self
operator|=
name|node
expr_stmt|;
name|pool
operator|->
name|abort_fn
operator|=
name|abort_fn
expr_stmt|;
name|pool
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|free_cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|pre_cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|subprocesses
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|user_data
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|sibling
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|ref
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|NETWARE
name|pool
operator|->
name|owner_proc
operator|=
operator|(
name|apr_os_proc_t
operator|)
name|getnlmhandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(NETWARE) */
if|if
condition|(
operator|!
name|allocator
condition|)
name|pool_allocator
operator|->
name|owner
operator|=
name|pool
expr_stmt|;
operator|*
name|newpool
operator|=
name|pool
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/*  * "Print" functions  */
end_comment

begin_comment
comment|/*  * apr_psprintf is implemented by writing directly into the current  * block of the pool, starting right at first_avail.  If there's  * insufficient room, then a new block is allocated and the earlier  * output is copied over.  The new block isn't linked into the pool  * until all the output is done.  *  * Note that this is completely safe because nothing else can  * allocate in this apr_pool_t while apr_psprintf is running.  alarms are  * blocked, and the only thing outside of apr_pools.c that's invoked  * is apr_vformatter -- which was purposefully written to be  * self-contained with no callouts.  */
end_comment

begin_struct
struct|struct
name|psprintf_data
block|{
name|apr_vformatter_buff_t
name|vbuff
decl_stmt|;
name|apr_memnode_t
modifier|*
name|node
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_byte_t
name|got_a_new_node
decl_stmt|;
name|apr_memnode_t
modifier|*
name|free
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|APR_PSPRINTF_MIN_STRINGSIZE
value|32
end_define

begin_function
specifier|static
name|int
name|psprintf_flush
parameter_list|(
name|apr_vformatter_buff_t
modifier|*
name|vbuff
parameter_list|)
block|{
name|struct
name|psprintf_data
modifier|*
name|ps
init|=
operator|(
expr|struct
name|psprintf_data
operator|*
operator|)
name|vbuff
decl_stmt|;
name|apr_memnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|active
decl_stmt|;
name|apr_size_t
name|cur_len
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|strp
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_size_t
name|free_index
decl_stmt|;
name|pool
operator|=
name|ps
operator|->
name|pool
expr_stmt|;
name|active
operator|=
name|ps
operator|->
name|node
expr_stmt|;
name|strp
operator|=
name|ps
operator|->
name|vbuff
operator|.
name|curpos
expr_stmt|;
name|cur_len
operator|=
name|strp
operator|-
name|active
operator|->
name|first_avail
expr_stmt|;
name|size
operator|=
name|cur_len
operator|<<
literal|1
expr_stmt|;
comment|/* Make sure that we don't try to use a block that has less      * than APR_PSPRINTF_MIN_STRINGSIZE bytes left in it.  This      * also catches the case where size == 0, which would result      * in reusing a block that can't even hold the NUL byte.      */
if|if
condition|(
name|size
operator|<
name|APR_PSPRINTF_MIN_STRINGSIZE
condition|)
name|size
operator|=
name|APR_PSPRINTF_MIN_STRINGSIZE
expr_stmt|;
name|node
operator|=
name|active
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|got_a_new_node
operator|&&
name|size
operator|<=
name|node_free_space
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|list_insert
argument_list|(
name|node
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|node
operator|->
name|free_index
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|active
operator|=
name|node
expr_stmt|;
name|free_index
operator|=
operator|(
name|APR_ALIGN
argument_list|(
name|active
operator|->
name|endp
operator|-
name|active
operator|->
name|first_avail
operator|+
literal|1
argument_list|,
name|BOUNDARY_SIZE
argument_list|)
operator|-
name|BOUNDARY_SIZE
operator|)
operator|>>
name|BOUNDARY_INDEX
expr_stmt|;
name|active
operator|->
name|free_index
operator|=
operator|(
name|APR_UINT32_TRUNC_CAST
operator|)
name|free_index
expr_stmt|;
name|node
operator|=
name|active
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|free_index
operator|<
name|node
operator|->
name|free_index
condition|)
block|{
do|do
block|{
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|free_index
operator|<
name|node
operator|->
name|free_index
condition|)
do|;
name|list_remove
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|list_insert
argument_list|(
name|active
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|pool
operator|->
name|active
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|allocator_alloc
argument_list|(
name|pool
operator|->
name|allocator
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ps
operator|->
name|got_a_new_node
condition|)
block|{
name|active
operator|->
name|next
operator|=
name|ps
operator|->
name|free
expr_stmt|;
name|ps
operator|->
name|free
operator|=
name|active
expr_stmt|;
block|}
name|ps
operator|->
name|got_a_new_node
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|node
operator|->
name|first_avail
argument_list|,
name|active
operator|->
name|first_avail
argument_list|,
name|cur_len
argument_list|)
expr_stmt|;
name|ps
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|ps
operator|->
name|vbuff
operator|.
name|curpos
operator|=
name|node
operator|->
name|first_avail
operator|+
name|cur_len
expr_stmt|;
name|ps
operator|->
name|vbuff
operator|.
name|endpos
operator|=
name|node
operator|->
name|endp
operator|-
literal|1
expr_stmt|;
comment|/* Save a byte for NUL terminator */
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_pvsprintf
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *fmt
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|struct
name|psprintf_data
name|ps
decl_stmt|;
name|char
modifier|*
name|strp
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|apr_memnode_t
modifier|*
name|active
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|apr_size_t
name|free_index
decl_stmt|;
name|ps
operator|.
name|node
operator|=
name|active
operator|=
name|pool
operator|->
name|active
expr_stmt|;
name|ps
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|ps
operator|.
name|vbuff
operator|.
name|curpos
operator|=
name|ps
operator|.
name|node
operator|->
name|first_avail
expr_stmt|;
comment|/* Save a byte for the NUL terminator */
name|ps
operator|.
name|vbuff
operator|.
name|endpos
operator|=
name|ps
operator|.
name|node
operator|->
name|endp
operator|-
literal|1
expr_stmt|;
name|ps
operator|.
name|got_a_new_node
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|free
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure that the first node passed to apr_vformatter has at least      * room to hold the NUL terminator.      */
if|if
condition|(
name|ps
operator|.
name|node
operator|->
name|first_avail
operator|==
name|ps
operator|.
name|node
operator|->
name|endp
condition|)
block|{
if|if
condition|(
name|psprintf_flush
argument_list|(
operator|&
name|ps
operator|.
name|vbuff
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
block|{
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|apr_vformatter
argument_list|(
name|psprintf_flush
argument_list|,
operator|&
name|ps
operator|.
name|vbuff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strp
operator|=
name|ps
operator|.
name|vbuff
operator|.
name|curpos
expr_stmt|;
operator|*
name|strp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
name|strp
operator|-
name|ps
operator|.
name|node
operator|->
name|first_avail
expr_stmt|;
name|size
operator|=
name|APR_ALIGN_DEFAULT
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|strp
operator|=
name|ps
operator|.
name|node
operator|->
name|first_avail
expr_stmt|;
name|ps
operator|.
name|node
operator|->
name|first_avail
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|free
condition|)
name|allocator_free
argument_list|(
name|pool
operator|->
name|allocator
argument_list|,
name|ps
operator|.
name|free
argument_list|)
expr_stmt|;
comment|/*      * Link the node in if it's a new one      */
if|if
condition|(
operator|!
name|ps
operator|.
name|got_a_new_node
condition|)
return|return
name|strp
return|;
name|active
operator|=
name|pool
operator|->
name|active
expr_stmt|;
name|node
operator|=
name|ps
operator|.
name|node
expr_stmt|;
name|node
operator|->
name|free_index
operator|=
literal|0
expr_stmt|;
name|list_insert
argument_list|(
name|node
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|pool
operator|->
name|active
operator|=
name|node
expr_stmt|;
name|free_index
operator|=
operator|(
name|APR_ALIGN
argument_list|(
name|active
operator|->
name|endp
operator|-
name|active
operator|->
name|first_avail
operator|+
literal|1
argument_list|,
name|BOUNDARY_SIZE
argument_list|)
operator|-
name|BOUNDARY_SIZE
operator|)
operator|>>
name|BOUNDARY_INDEX
expr_stmt|;
name|active
operator|->
name|free_index
operator|=
operator|(
name|APR_UINT32_TRUNC_CAST
operator|)
name|free_index
expr_stmt|;
name|node
operator|=
name|active
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|free_index
operator|>=
name|node
operator|->
name|free_index
condition|)
return|return
name|strp
return|;
do|do
block|{
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|free_index
operator|<
name|node
operator|->
name|free_index
condition|)
do|;
name|list_remove
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|list_insert
argument_list|(
name|active
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|strp
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* APR_POOL_DEBUG */
end_comment

begin_comment
comment|/*  * Debug helper functions  */
end_comment

begin_comment
comment|/*  * Walk the pool tree rooted at pool, depth first.  When fn returns  * anything other than 0, abort the traversal and return the value  * returned by fn.  */
end_comment

begin_function
specifier|static
name|int
name|apr_pool_walk_tree
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|apr_pool_t
modifier|*
name|child
decl_stmt|;
name|rv
operator|=
name|fn
argument_list|(
name|pool
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
name|rv
return|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|pool
operator|->
name|mutex
condition|)
block|{
name|apr_thread_mutex_lock
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|child
operator|=
name|pool
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child
condition|)
block|{
name|rv
operator|=
name|apr_pool_walk_tree
argument_list|(
name|child
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
name|child
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|pool
operator|->
name|mutex
condition|)
block|{
name|apr_thread_mutex_unlock
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
return|return
name|rv
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
end_if

begin_function
specifier|static
name|void
name|apr_pool_log_event
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|event
parameter_list|,
specifier|const
name|char
modifier|*
name|file_line
parameter_list|,
name|int
name|deref
parameter_list|)
block|{
if|if
condition|(
name|file_stderr
condition|)
block|{
if|if
condition|(
name|deref
condition|)
block|{
name|apr_file_printf
argument_list|(
name|file_stderr
argument_list|,
literal|"POOL DEBUG: "
literal|"[%lu"
if|#
directive|if
name|APR_HAS_THREADS
literal|"/%lu"
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
literal|"] "
literal|"%7s "
literal|"(%10lu/%10lu/%10lu) "
literal|"0x%pp \"%s\" "
literal|"<%s> "
literal|"(%u/%u/%u) "
literal|"\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|getpid
argument_list|()
argument_list|,
if|#
directive|if
name|APR_HAS_THREADS
operator|(
name|unsigned
name|long
operator|)
name|apr_os_thread_current
argument_list|()
argument_list|,
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|event
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|apr_pool_num_bytes
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|apr_pool_num_bytes
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|apr_pool_num_bytes
argument_list|(
name|global_pool
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
operator|->
name|tag
argument_list|,
name|file_line
argument_list|,
name|pool
operator|->
name|stat_alloc
argument_list|,
name|pool
operator|->
name|stat_total_alloc
argument_list|,
name|pool
operator|->
name|stat_clear
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_file_printf
argument_list|(
name|file_stderr
argument_list|,
literal|"POOL DEBUG: "
literal|"[%lu"
if|#
directive|if
name|APR_HAS_THREADS
literal|"/%lu"
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
literal|"] "
literal|"%7s "
literal|"                                   "
literal|"0x%pp "
literal|"<%s> "
literal|"\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|getpid
argument_list|()
argument_list|,
if|#
directive|if
name|APR_HAS_THREADS
operator|(
name|unsigned
name|long
operator|)
name|apr_os_thread_current
argument_list|()
argument_list|,
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|event
argument_list|,
name|pool
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
end_comment

begin_if
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_LIFETIME
operator|)
end_if

begin_function
specifier|static
name|int
name|pool_is_child_of
parameter_list|(
name|apr_pool_t
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
operator|(
name|apr_pool_t
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|(
name|pool
operator|==
name|parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apr_pool_is_child_of
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|apr_pool_walk_tree
argument_list|(
name|parent
argument_list|,
name|pool_is_child_of
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_LIFETIME) */
end_comment

begin_function
specifier|static
name|void
name|apr_pool_check_integrity
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Rule of thumb: use of the global pool is always      * ok, since the only user is apr_pools.c.  Unless      * people have searched for the top level parent and      * started to use that...      */
if|if
condition|(
name|pool
operator|==
name|global_pool
operator|||
name|global_pool
operator|==
name|NULL
condition|)
return|return;
comment|/* Lifetime      * This basically checks to see if the pool being used is still      * a relative to the global pool.  If not it was previously      * destroyed, in which case we abort().      */
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_LIFETIME
operator|)
if|if
condition|(
operator|!
name|apr_pool_is_child_of
argument_list|(
name|pool
argument_list|,
name|global_pool
argument_list|)
condition|)
block|{
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"LIFE"
argument_list|,
name|__FILE__
literal|":apr_pool_integrity check"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_LIFETIME) */
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_OWNER
operator|)
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
operator|!
name|apr_os_thread_equal
argument_list|(
name|pool
operator|->
name|owner
argument_list|,
name|apr_os_thread_current
argument_list|()
argument_list|)
condition|)
block|{
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"THREAD"
argument_list|,
name|__FILE__
literal|":apr_pool_integrity check"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_OWNER) */
block|}
end_function

begin_comment
comment|/*  * Initialization (debug)  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_initialize
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|char
modifier|*
name|logpath
decl_stmt|;
name|apr_file_t
modifier|*
name|debug_log
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|apr_pools_initialized
operator|++
condition|)
return|return
name|APR_SUCCESS
return|;
if|#
directive|if
name|APR_ALLOCATOR_USES_MMAP
operator|&&
name|defined
argument_list|(
name|_SC_PAGESIZE
argument_list|)
name|boundary_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
name|boundary_index
operator|=
literal|12
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|boundary_index
operator|)
operator|<
name|boundary_size
condition|)
name|boundary_index
operator|++
expr_stmt|;
name|boundary_size
operator|=
operator|(
literal|1
operator|<<
name|boundary_index
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Since the debug code works a bit differently then the      * regular pools code, we ask for a lock here.  The regular      * pools code has got this lock embedded in the global      * allocator, a concept unknown to debug mode.      */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_pool_create_ex
argument_list|(
operator|&
name|global_pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
name|apr_pool_tag
argument_list|(
name|global_pool
argument_list|,
literal|"APR global pool"
argument_list|)
expr_stmt|;
name|apr_pools_initialized
operator|=
literal|1
expr_stmt|;
comment|/* This has to happen here because mutexes might be backed by      * atomics.  It used to be snug and safe in apr_initialize().      */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_atomic_init
argument_list|(
name|global_pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
return|return
name|rv
return|;
block|}
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|rv
operator|=
name|apr_env_get
argument_list|(
operator|&
name|logpath
argument_list|,
literal|"APR_POOL_DEBUG_LOG"
argument_list|,
name|global_pool
argument_list|)
expr_stmt|;
comment|/* Don't pass file_stderr directly to apr_file_open() here, since      * apr_file_open() can call back to apr_pool_log_event() and that      * may attempt to use then then non-NULL but partially set up file      * object. */
if|if
condition|(
name|rv
operator|==
name|APR_SUCCESS
condition|)
block|{
name|apr_file_open
argument_list|(
operator|&
name|debug_log
argument_list|,
name|logpath
argument_list|,
name|APR_APPEND
operator||
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|global_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_file_open_stderr
argument_list|(
operator|&
name|debug_log
argument_list|,
name|global_pool
argument_list|)
expr_stmt|;
block|}
comment|/* debug_log is now a file handle. */
name|file_stderr
operator|=
name|debug_log
expr_stmt|;
if|if
condition|(
name|file_stderr
condition|)
block|{
name|apr_file_printf
argument_list|(
name|file_stderr
argument_list|,
literal|"POOL DEBUG: [PID"
if|#
directive|if
name|APR_HAS_THREADS
literal|"/TID"
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
literal|"] ACTION  (SIZE      /POOL SIZE /TOTAL SIZE) "
literal|"POOL       \"TAG\"<__FILE__:__LINE__> (ALLOCS/TOTAL ALLOCS/CLEARS)\n"
argument_list|)
expr_stmt|;
name|apr_pool_log_event
argument_list|(
name|global_pool
argument_list|,
literal|"GLOBAL"
argument_list|,
name|__FILE__
literal|":apr_pool_initialize"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_terminate
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|apr_pools_initialized
condition|)
return|return;
if|if
condition|(
operator|--
name|apr_pools_initialized
condition|)
return|return;
name|apr_pool_destroy
argument_list|(
name|global_pool
argument_list|)
expr_stmt|;
comment|/* This will also destroy the mutex */
name|global_pool
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|file_stderr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
block|}
end_block

begin_comment
comment|/*  * Memory allocation (debug)  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pool_alloc
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
name|debug_node_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|node
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
operator|||
name|node
operator|->
name|index
operator|==
literal|64
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
name|SIZEOF_DEBUG_NODE_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|SIZEOF_DEBUG_NODE_T
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
name|pool
operator|->
name|nodes
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|node
operator|->
name|beginp
index|[
name|node
operator|->
name|index
index|]
operator|=
name|mem
expr_stmt|;
name|node
operator|->
name|endp
index|[
name|node
operator|->
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|mem
operator|+
name|size
expr_stmt|;
name|node
operator|->
name|index
operator|++
expr_stmt|;
name|pool
operator|->
name|stat_alloc
operator|++
expr_stmt|;
name|pool
operator|->
name|stat_total_alloc
operator|++
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_palloc_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|mem
operator|=
name|pool_alloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALLOC
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"PALLOC"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALLOC) */
return|return
name|mem
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
end_macro

begin_macro
name|apr_pcalloc_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|mem
decl_stmt|;
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|mem
operator|=
name|pool_alloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALLOC
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"PCALLOC"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALLOC) */
return|return
name|mem
return|;
block|}
end_block

begin_comment
comment|/*  * Pool creation/destruction (debug)  */
end_comment

begin_define
define|#
directive|define
name|POOL_POISON_BYTE
value|'A'
end_define

begin_function
specifier|static
name|void
name|pool_clear_debug
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|file_line
parameter_list|)
block|{
name|debug_node_t
modifier|*
name|node
decl_stmt|;
name|apr_uint32_t
name|index
decl_stmt|;
comment|/* Run pre destroy cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|pre_cleanups
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pre_cleanups
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the subpools.  The subpools will detach themselves from      * this pool thus this loop is safe and easy.      */
while|while
condition|(
name|pool
operator|->
name|child
condition|)
name|pool_destroy_debug
argument_list|(
name|pool
operator|->
name|child
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
comment|/* Run cleanups */
name|run_cleanups
argument_list|(
operator|&
name|pool
operator|->
name|cleanups
argument_list|)
expr_stmt|;
name|pool
operator|->
name|free_cleanups
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|cleanups
operator|=
name|NULL
expr_stmt|;
comment|/* If new child pools showed up, this is a reason to raise a flag */
if|if
condition|(
name|pool
operator|->
name|child
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Free subprocesses */
name|free_proc_chain
argument_list|(
name|pool
operator|->
name|subprocesses
argument_list|)
expr_stmt|;
name|pool
operator|->
name|subprocesses
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the user data. */
name|pool
operator|->
name|user_data
operator|=
name|NULL
expr_stmt|;
comment|/* Free the blocks, scribbling over them first to help highlight      * use-after-free issues. */
while|while
condition|(
operator|(
name|node
operator|=
name|pool
operator|->
name|nodes
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pool
operator|->
name|nodes
operator|=
name|node
operator|->
name|next
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|node
operator|->
name|index
condition|;
name|index
operator|++
control|)
block|{
name|memset
argument_list|(
name|node
operator|->
name|beginp
index|[
name|index
index|]
argument_list|,
name|POOL_POISON_BYTE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|endp
index|[
name|index
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|beginp
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|beginp
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|node
argument_list|,
name|POOL_POISON_BYTE
argument_list|,
name|SIZEOF_DEBUG_NODE_T
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|stat_alloc
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|stat_clear
operator|++
expr_stmt|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_clear_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"CLEAR"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE) */
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|pool
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|mutex
operator|=
name|pool
operator|->
name|parent
operator|->
name|mutex
expr_stmt|;
comment|/* Lock the parent mutex before clearing so that if we have our      * own mutex it won't be accessed by apr_pool_walk_tree after      * it has been destroyed.      */
if|if
condition|(
name|mutex
operator|!=
name|NULL
operator|&&
name|mutex
operator|!=
name|pool
operator|->
name|mutex
condition|)
block|{
name|apr_thread_mutex_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pool_clear_debug
argument_list|(
name|pool
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
comment|/* If we had our own mutex, it will have been destroyed by      * the registered cleanups.  Recreate the mutex.  Unlock      * the mutex we obtained above.      */
if|if
condition|(
name|mutex
operator|!=
name|pool
operator|->
name|mutex
condition|)
block|{
operator|(
name|void
operator|)
name|apr_thread_mutex_create
argument_list|(
operator|&
name|pool
operator|->
name|mutex
argument_list|,
name|APR_THREAD_MUTEX_NESTED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|apr_thread_mutex_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
end_block

begin_function
specifier|static
name|void
name|pool_destroy_debug
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|file_line
parameter_list|)
block|{
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"DESTROY"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE) */
name|pool_clear_debug
argument_list|(
name|pool
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
comment|/* Remove the pool from the parents child list */
if|if
condition|(
name|pool
operator|->
name|parent
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_mutex_t
modifier|*
name|mutex
decl_stmt|;
if|if
condition|(
operator|(
name|mutex
operator|=
name|pool
operator|->
name|parent
operator|->
name|mutex
operator|)
operator|!=
name|NULL
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
if|if
condition|(
operator|(
operator|*
name|pool
operator|->
name|ref
operator|=
name|pool
operator|->
name|sibling
operator|)
operator|!=
name|NULL
condition|)
name|pool
operator|->
name|sibling
operator|->
name|ref
operator|=
name|pool
operator|->
name|ref
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
if|if
condition|(
name|pool
operator|->
name|allocator
operator|!=
name|NULL
operator|&&
name|apr_allocator_owner_get
argument_list|(
name|pool
operator|->
name|allocator
argument_list|)
operator|==
name|pool
condition|)
block|{
name|apr_allocator_destroy
argument_list|(
name|pool
operator|->
name|allocator
argument_list|)
expr_stmt|;
block|}
comment|/* Free the pool itself */
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_destroy_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|pool
operator|->
name|joined
condition|)
block|{
comment|/* Joined pools must not be explicitly destroyed; the caller          * has broken the guarantee. */
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE_ALL
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"LIFE"
argument_list|,
name|__FILE__
literal|":apr_pool_destroy abort on joined"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE_ALL) */
name|abort
argument_list|()
expr_stmt|;
block|}
name|pool_destroy_debug
argument_list|(
name|pool
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_pool_t *parent
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
operator|*
name|newpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
block|{
name|parent
operator|=
name|global_pool
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_check_integrity
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allocator
condition|)
name|allocator
operator|=
name|parent
operator|->
name|allocator
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|abort_fn
operator|&&
name|parent
condition|)
name|abort_fn
operator|=
name|parent
operator|->
name|abort_fn
expr_stmt|;
if|if
condition|(
operator|(
name|pool
operator|=
name|malloc
argument_list|(
name|SIZEOF_POOL_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|memset
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
name|SIZEOF_POOL_T
argument_list|)
expr_stmt|;
name|pool
operator|->
name|allocator
operator|=
name|allocator
expr_stmt|;
name|pool
operator|->
name|abort_fn
operator|=
name|abort_fn
expr_stmt|;
name|pool
operator|->
name|tag
operator|=
name|file_line
expr_stmt|;
name|pool
operator|->
name|file_line
operator|=
name|file_line
expr_stmt|;
if|if
condition|(
operator|(
name|pool
operator|->
name|parent
operator|=
name|parent
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|parent
operator|->
name|mutex
condition|)
name|apr_thread_mutex_lock
argument_list|(
name|parent
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
if|if
condition|(
operator|(
name|pool
operator|->
name|sibling
operator|=
name|parent
operator|->
name|child
operator|)
operator|!=
name|NULL
condition|)
name|pool
operator|->
name|sibling
operator|->
name|ref
operator|=
operator|&
name|pool
operator|->
name|sibling
expr_stmt|;
name|parent
operator|->
name|child
operator|=
name|pool
expr_stmt|;
name|pool
operator|->
name|ref
operator|=
operator|&
name|parent
operator|->
name|child
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|parent
operator|->
name|mutex
condition|)
name|apr_thread_mutex_unlock
argument_list|(
name|parent
operator|->
name|mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
else|else
block|{
name|pool
operator|->
name|sibling
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|ref
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
name|pool
operator|->
name|owner
operator|=
name|apr_os_thread_current
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
ifdef|#
directive|ifdef
name|NETWARE
name|pool
operator|->
name|owner_proc
operator|=
operator|(
name|apr_os_proc_t
operator|)
name|getnlmhandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(NETWARE) */
if|if
condition|(
name|parent
operator|==
name|NULL
operator|||
name|parent
operator|->
name|allocator
operator|!=
name|allocator
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_status_t
name|rv
decl_stmt|;
comment|/* No matter what the creation flags say, always create          * a lock.  Without it integrity_check and apr_pool_num_bytes          * blow up (because they traverse pools child lists that          * possibly belong to another thread, in combination with          * the pool having no lock).  However, this might actually          * hide problems like creating a child pool of a pool          * belonging to another thread.          */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|pool
operator|->
name|mutex
argument_list|,
name|APR_THREAD_MUTEX_NESTED
argument_list|,
name|pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
else|else
block|{
if|#
directive|if
name|APR_HAS_THREADS
if|if
condition|(
name|parent
condition|)
name|pool
operator|->
name|mutex
operator|=
name|parent
operator|->
name|mutex
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
operator|*
name|newpool
operator|=
name|pool
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"CREATE"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE) */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_core_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
return|return
name|apr_pool_create_unmanaged_ex_debug
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|,
name|file_line
argument_list|)
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_create_unmanaged_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_allocator_t
modifier|*
name|pool_allocator
decl_stmt|;
operator|*
name|newpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pool
operator|=
name|malloc
argument_list|(
name|SIZEOF_POOL_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|APR_ENOMEM
return|;
block|}
name|memset
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
name|SIZEOF_POOL_T
argument_list|)
expr_stmt|;
name|pool
operator|->
name|abort_fn
operator|=
name|abort_fn
expr_stmt|;
name|pool
operator|->
name|tag
operator|=
name|file_line
expr_stmt|;
name|pool
operator|->
name|file_line
operator|=
name|file_line
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|pool
operator|->
name|owner
operator|=
name|apr_os_thread_current
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
ifdef|#
directive|ifdef
name|NETWARE
name|pool
operator|->
name|owner_proc
operator|=
operator|(
name|apr_os_proc_t
operator|)
name|getnlmhandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(NETWARE) */
if|if
condition|(
operator|(
name|pool_allocator
operator|=
name|allocator
operator|)
operator|==
name|NULL
condition|)
block|{
name|apr_status_t
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_allocator_create
argument_list|(
operator|&
name|pool_allocator
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
name|abort_fn
condition|)
name|abort_fn
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|pool_allocator
operator|->
name|owner
operator|=
name|pool
expr_stmt|;
block|}
name|pool
operator|->
name|allocator
operator|=
name|pool_allocator
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|allocator
operator|!=
name|allocator
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|apr_status_t
name|rv
decl_stmt|;
comment|/* No matter what the creation flags say, always create          * a lock.  Without it integrity_check and apr_pool_num_bytes          * blow up (because they traverse pools child lists that          * possibly belong to another thread, in combination with          * the pool having no lock).  However, this might actually          * hide problems like creating a child pool of a pool          * belonging to another thread.          */
if|if
condition|(
operator|(
name|rv
operator|=
name|apr_thread_mutex_create
argument_list|(
operator|&
name|pool
operator|->
name|mutex
argument_list|,
name|APR_THREAD_MUTEX_NESTED
argument_list|,
name|pool
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
block|}
operator|*
name|newpool
operator|=
name|pool
expr_stmt|;
if|#
directive|if
operator|(
name|APR_POOL_DEBUG
operator|&
name|APR_POOL_DEBUG_VERBOSE
operator|)
name|apr_pool_log_event
argument_list|(
name|pool
argument_list|,
literal|"CREATE"
argument_list|,
name|file_line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (APR_POOL_DEBUG& APR_POOL_DEBUG_VERBOSE) */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/*  * "Print" functions (debug)  */
end_comment

begin_struct
struct|struct
name|psprintf_data
block|{
name|apr_vformatter_buff_t
name|vbuff
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|psprintf_flush
parameter_list|(
name|apr_vformatter_buff_t
modifier|*
name|vbuff
parameter_list|)
block|{
name|struct
name|psprintf_data
modifier|*
name|ps
init|=
operator|(
expr|struct
name|psprintf_data
operator|*
operator|)
name|vbuff
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|size
operator|=
name|ps
operator|->
name|vbuff
operator|.
name|curpos
operator|-
name|ps
operator|->
name|mem
expr_stmt|;
name|ps
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|->
name|mem
operator|=
name|realloc
argument_list|(
name|ps
operator|->
name|mem
argument_list|,
name|ps
operator|->
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ps
operator|->
name|vbuff
operator|.
name|curpos
operator|=
name|ps
operator|->
name|mem
operator|+
name|size
expr_stmt|;
name|ps
operator|->
name|vbuff
operator|.
name|endpos
operator|=
name|ps
operator|->
name|mem
operator|+
name|ps
operator|->
name|size
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_pvsprintf
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *fmt
argument_list|,
argument|va_list ap
argument_list|)
end_macro

begin_block
block|{
name|struct
name|psprintf_data
name|ps
decl_stmt|;
name|debug_node_t
modifier|*
name|node
decl_stmt|;
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|ps
operator|.
name|size
operator|=
literal|64
expr_stmt|;
name|ps
operator|.
name|mem
operator|=
name|malloc
argument_list|(
name|ps
operator|.
name|size
argument_list|)
expr_stmt|;
name|ps
operator|.
name|vbuff
operator|.
name|curpos
operator|=
name|ps
operator|.
name|mem
expr_stmt|;
comment|/* Save a byte for the NUL terminator */
name|ps
operator|.
name|vbuff
operator|.
name|endpos
operator|=
name|ps
operator|.
name|mem
operator|+
name|ps
operator|.
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|apr_vformatter
argument_list|(
name|psprintf_flush
argument_list|,
operator|&
name|ps
operator|.
name|vbuff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|ps
operator|.
name|vbuff
operator|.
name|curpos
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Link the node in      */
name|node
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
operator|||
name|node
operator|->
name|index
operator|==
literal|64
condition|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
name|SIZEOF_DEBUG_NODE_T
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|abort_fn
condition|)
name|pool
operator|->
name|abort_fn
argument_list|(
name|APR_ENOMEM
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|node
operator|->
name|next
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
name|pool
operator|->
name|nodes
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|node
operator|->
name|beginp
index|[
name|node
operator|->
name|index
index|]
operator|=
name|ps
operator|.
name|mem
expr_stmt|;
name|node
operator|->
name|endp
index|[
name|node
operator|->
name|index
index|]
operator|=
name|ps
operator|.
name|mem
operator|+
name|ps
operator|.
name|size
expr_stmt|;
name|node
operator|->
name|index
operator|++
expr_stmt|;
return|return
name|ps
operator|.
name|mem
return|;
block|}
end_block

begin_comment
comment|/*  * Debug functions  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_join
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|apr_pool_t *sub
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_POOL_DEBUG
if|if
condition|(
name|sub
operator|->
name|parent
operator|!=
name|p
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|sub
operator|->
name|joined
operator|=
name|p
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
specifier|static
name|int
name|pool_find
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|pmem
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|debug_node_t
modifier|*
name|node
decl_stmt|;
name|apr_uint32_t
name|index
decl_stmt|;
name|node
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|node
operator|->
name|index
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|beginp
index|[
name|index
index|]
operator|<=
operator|*
name|pmem
operator|&&
name|node
operator|->
name|endp
index|[
name|index
index|]
operator|>
operator|*
name|pmem
condition|)
block|{
operator|*
name|pmem
operator|=
name|pool
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_pool_t *
argument_list|)
end_macro

begin_macro
name|apr_pool_find
argument_list|(
argument|const void *mem
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|pool
init|=
operator|(
name|void
operator|*
operator|)
name|mem
decl_stmt|;
if|if
condition|(
name|apr_pool_walk_tree
argument_list|(
name|global_pool
argument_list|,
name|pool_find
argument_list|,
operator|&
name|pool
argument_list|)
condition|)
return|return
name|pool
return|;
return|return
name|NULL
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|pool_num_bytes
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|apr_size_t
modifier|*
name|psize
init|=
operator|(
name|apr_size_t
operator|*
operator|)
name|data
decl_stmt|;
name|debug_node_t
modifier|*
name|node
decl_stmt|;
name|apr_uint32_t
name|index
decl_stmt|;
name|node
operator|=
name|pool
operator|->
name|nodes
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|node
operator|->
name|index
condition|;
name|index
operator|++
control|)
block|{
operator|*
name|psize
operator|+=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|endp
index|[
name|index
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|beginp
index|[
name|index
index|]
expr_stmt|;
block|}
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_size_t
argument_list|)
end_macro

begin_macro
name|apr_pool_num_bytes
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|int recurse
argument_list|)
end_macro

begin_block
block|{
name|apr_size_t
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|recurse
condition|)
block|{
name|pool_num_bytes
argument_list|(
name|pool
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
name|apr_pool_walk_tree
argument_list|(
name|pool
argument_list|,
name|pool_num_bytes
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_lock
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|int flag
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APR_POOL_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETWARE
end_ifdef

begin_function
name|void
name|netware_pool_proc_cleanup
parameter_list|()
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|global_pool
operator|->
name|child
decl_stmt|;
name|apr_os_proc_t
name|owner_proc
init|=
operator|(
name|apr_os_proc_t
operator|)
name|getnlmhandle
argument_list|()
decl_stmt|;
while|while
condition|(
name|pool
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|owner_proc
operator|==
name|owner_proc
condition|)
block|{
name|apr_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|global_pool
operator|->
name|child
expr_stmt|;
block|}
else|else
block|{
name|pool
operator|=
name|pool
operator|->
name|sibling
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(NETWARE) */
end_comment

begin_comment
comment|/*  * "Print" functions (common)  */
end_comment

begin_macro
name|APR_DECLARE_NONSTD
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|apr_psprintf
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const char *fmt
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|res
operator|=
name|apr_pvsprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Pool Properties  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_abort_set
argument_list|(
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
name|pool
operator|->
name|abort_fn
operator|=
name|abort_fn
expr_stmt|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_abortfunc_t
argument_list|)
end_macro

begin_macro
name|apr_pool_abort_get
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
return|return
name|pool
operator|->
name|abort_fn
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_pool_t *
argument_list|)
end_macro

begin_macro
name|apr_pool_parent_get
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NETWARE
comment|/* On NetWare, don't return the global_pool, return the application pool         as the top most pool */
if|if
condition|(
name|pool
operator|->
name|parent
operator|==
name|global_pool
condition|)
return|return
name|pool
return|;
else|else
endif|#
directive|endif
return|return
name|pool
operator|->
name|parent
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_allocator_t *
argument_list|)
end_macro

begin_macro
name|apr_pool_allocator_get
argument_list|(
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
return|return
name|pool
operator|->
name|allocator
return|;
block|}
end_block

begin_comment
comment|/* return TRUE if a is an ancestor of b  * NULL is considered an ancestor of all pools  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|apr_pool_is_ancestor
argument_list|(
argument|apr_pool_t *a
argument_list|,
argument|apr_pool_t *b
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* Find the pool with the longest lifetime guaranteed by the      * caller: */
while|while
condition|(
name|a
operator|->
name|joined
condition|)
block|{
name|a
operator|=
name|a
operator|->
name|joined
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|b
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
literal|1
return|;
name|b
operator|=
name|b
operator|->
name|parent
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_tag
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *tag
argument_list|)
end_macro

begin_block
block|{
name|pool
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * User data management  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_userdata_set
argument_list|(
argument|const void *data
argument_list|,
argument|const char *key
argument_list|,
argument|apr_status_t (*cleanup) (void *)
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|pool
operator|->
name|user_data
operator|==
name|NULL
condition|)
name|pool
operator|->
name|user_data
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_get
argument_list|(
name|pool
operator|->
name|user_data
argument_list|,
name|key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|new_key
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|pool
operator|->
name|user_data
argument_list|,
name|new_key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_set
argument_list|(
name|pool
operator|->
name|user_data
argument_list|,
name|key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|data
argument_list|,
name|cleanup
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_userdata_setn
argument_list|(
argument|const void *data
argument_list|,
argument|const char *key
argument_list|,
argument|apr_status_t (*cleanup)(void *)
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|pool
operator|->
name|user_data
operator|==
name|NULL
condition|)
name|pool
operator|->
name|user_data
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|pool
operator|->
name|user_data
argument_list|,
name|key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|data
argument_list|,
name|cleanup
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_userdata_get
argument_list|(
argument|void **data
argument_list|,
argument|const char *key
argument_list|,
argument|apr_pool_t *pool
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|pool
operator|->
name|user_data
operator|==
name|NULL
condition|)
block|{
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|data
operator|=
name|apr_hash_get
argument_list|(
name|pool
operator|->
name|user_data
argument_list|,
name|key
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/*  * Cleanup  */
end_comment

begin_struct
struct|struct
name|cleanup_t
block|{
name|struct
name|cleanup_t
modifier|*
name|next
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|apr_status_t
function_decl|(
modifier|*
name|plain_cleanup_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
name|apr_status_t
function_decl|(
modifier|*
name|child_cleanup_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_register
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const void *data
argument_list|,
argument|apr_status_t (*plain_cleanup_fn)(void *data)
argument_list|,
argument|apr_status_t (*child_cleanup_fn)(void *data)
argument_list|)
end_macro

begin_block
block|{
name|cleanup_t
modifier|*
name|c
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|free_cleanups
condition|)
block|{
comment|/* reuse a cleanup structure */
name|c
operator|=
name|p
operator|->
name|free_cleanups
expr_stmt|;
name|p
operator|->
name|free_cleanups
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|cleanup_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|c
operator|->
name|plain_cleanup_fn
operator|=
name|plain_cleanup_fn
expr_stmt|;
name|c
operator|->
name|child_cleanup_fn
operator|=
name|child_cleanup_fn
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|cleanups
expr_stmt|;
name|p
operator|->
name|cleanups
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_pre_cleanup_register
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const void *data
argument_list|,
argument|apr_status_t (*plain_cleanup_fn)(void *data)
argument_list|)
end_macro

begin_block
block|{
name|cleanup_t
modifier|*
name|c
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|free_cleanups
condition|)
block|{
comment|/* reuse a cleanup structure */
name|c
operator|=
name|p
operator|->
name|free_cleanups
expr_stmt|;
name|p
operator|->
name|free_cleanups
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|apr_palloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|cleanup_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|c
operator|->
name|plain_cleanup_fn
operator|=
name|plain_cleanup_fn
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|pre_cleanups
expr_stmt|;
name|p
operator|->
name|pre_cleanups
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_kill
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const void *data
argument_list|,
argument|apr_status_t (*cleanup_fn)(void *)
argument_list|)
end_macro

begin_block
block|{
name|cleanup_t
modifier|*
name|c
decl_stmt|,
modifier|*
modifier|*
name|lastp
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|c
operator|=
name|p
operator|->
name|cleanups
expr_stmt|;
name|lastp
operator|=
operator|&
name|p
operator|->
name|cleanups
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* Some cheap loop detection to catch a corrupt list: */
if|if
condition|(
name|c
operator|==
name|c
operator|->
name|next
operator|||
operator|(
name|c
operator|->
name|next
operator|&&
name|c
operator|==
name|c
operator|->
name|next
operator|->
name|next
operator|)
operator|||
operator|(
name|c
operator|->
name|next
operator|&&
name|c
operator|->
name|next
operator|->
name|next
operator|&&
name|c
operator|==
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|->
name|data
operator|==
name|data
operator|&&
name|c
operator|->
name|plain_cleanup_fn
operator|==
name|cleanup_fn
condition|)
block|{
operator|*
name|lastp
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* move to freelist */
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|free_cleanups
expr_stmt|;
name|p
operator|->
name|free_cleanups
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|lastp
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
comment|/* Remove any pre-cleanup as well */
name|c
operator|=
name|p
operator|->
name|pre_cleanups
expr_stmt|;
name|lastp
operator|=
operator|&
name|p
operator|->
name|pre_cleanups
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|#
directive|if
name|APR_POOL_DEBUG
comment|/* Some cheap loop detection to catch a corrupt list: */
if|if
condition|(
name|c
operator|==
name|c
operator|->
name|next
operator|||
operator|(
name|c
operator|->
name|next
operator|&&
name|c
operator|==
name|c
operator|->
name|next
operator|->
name|next
operator|)
operator|||
operator|(
name|c
operator|->
name|next
operator|&&
name|c
operator|->
name|next
operator|->
name|next
operator|&&
name|c
operator|==
name|c
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|->
name|data
operator|==
name|data
operator|&&
name|c
operator|->
name|plain_cleanup_fn
operator|==
name|cleanup_fn
condition|)
block|{
operator|*
name|lastp
operator|=
name|c
operator|->
name|next
expr_stmt|;
comment|/* move to freelist */
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|free_cleanups
expr_stmt|;
name|p
operator|->
name|free_cleanups
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|lastp
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_child_cleanup_set
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|const void *data
argument_list|,
argument|apr_status_t (*plain_cleanup_fn)(void *)
argument_list|,
argument|apr_status_t (*child_cleanup_fn)(void *)
argument_list|)
end_macro

begin_block
block|{
name|cleanup_t
modifier|*
name|c
decl_stmt|;
if|#
directive|if
name|APR_POOL_DEBUG
name|apr_pool_check_integrity
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_POOL_DEBUG */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|c
operator|=
name|p
operator|->
name|cleanups
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|data
operator|==
name|data
operator|&&
name|c
operator|->
name|plain_cleanup_fn
operator|==
name|plain_cleanup_fn
condition|)
block|{
name|c
operator|->
name|child_cleanup_fn
operator|=
name|child_cleanup_fn
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_run
argument_list|(
argument|apr_pool_t *p
argument_list|,
argument|void *data
argument_list|,
argument|apr_status_t (*cleanup_fn)(void *)
argument_list|)
end_macro

begin_block
block|{
name|apr_pool_cleanup_kill
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|cleanup_fn
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|cleanup_fn
call|)
argument_list|(
name|data
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|run_cleanups
parameter_list|(
name|cleanup_t
modifier|*
modifier|*
name|cref
parameter_list|)
block|{
name|cleanup_t
modifier|*
name|c
init|=
operator|*
name|cref
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
operator|*
name|cref
operator|=
name|c
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|c
operator|->
name|plain_cleanup_fn
call|)
argument_list|(
operator|(
name|void
operator|*
operator|)
name|c
operator|->
name|data
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cref
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OS2
argument_list|)
end_if

begin_function
specifier|static
name|void
name|run_child_cleanups
parameter_list|(
name|cleanup_t
modifier|*
modifier|*
name|cref
parameter_list|)
block|{
name|cleanup_t
modifier|*
name|c
init|=
operator|*
name|cref
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
operator|*
name|cref
operator|=
name|c
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|c
operator|->
name|child_cleanup_fn
call|)
argument_list|(
operator|(
name|void
operator|*
operator|)
name|c
operator|->
name|data
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cref
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_pool_for_exec
parameter_list|(
name|apr_pool_t
modifier|*
name|p
parameter_list|)
block|{
name|run_child_cleanups
argument_list|(
operator|&
name|p
operator|->
name|cleanups
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|child
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|sibling
control|)
name|cleanup_pool_for_exec
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_for_exec
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|cleanup_pool_for_exec
argument_list|(
name|global_pool
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(WIN32)&& !defined(OS2) */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_for_exec
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
comment|/*      * Don't need to do anything on NT or OS/2, because       * these platforms will spawn the new process - not      * fork for exec. All handles that are not inheritable,      * will be automajically closed. The only problem is      * with file handles that are open, but there isn't      * much that can be done about that (except if the      * child decides to go out and close them, or the      * developer quits opening them shared)      */
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(WIN32)&& !defined(OS2) */
end_comment

begin_macro
name|APR_DECLARE_NONSTD
argument_list|(
argument|apr_status_t
argument_list|)
end_macro

begin_macro
name|apr_pool_cleanup_null
argument_list|(
argument|void *data
argument_list|)
end_macro

begin_block
block|{
comment|/* do nothing cleanup routine */
return|return
name|APR_SUCCESS
return|;
block|}
end_block

begin_comment
comment|/* Subprocesses don't use the generic cleanup interface because  * we don't want multiple subprocesses to result in multiple  * three-second pauses; the subprocesses have to be "freed" all  * at once.  If other resources are introduced with the same property,  * we might want to fold support for that into the generic interface.  * For now, it's a special case.  */
end_comment

begin_macro
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|apr_pool_note_subprocess
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_proc_t *proc
argument_list|,
argument|apr_kill_conditions_e how
argument_list|)
end_macro

begin_block
block|{
name|struct
name|process_chain
modifier|*
name|pc
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|process_chain
argument_list|)
argument_list|)
decl_stmt|;
name|pc
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|pc
operator|->
name|kill_how
operator|=
name|how
expr_stmt|;
name|pc
operator|->
name|next
operator|=
name|pool
operator|->
name|subprocesses
expr_stmt|;
name|pool
operator|->
name|subprocesses
operator|=
name|pc
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|free_proc_chain
parameter_list|(
name|struct
name|process_chain
modifier|*
name|procs
parameter_list|)
block|{
comment|/* Dispose of the subprocesses we've spawned off in the course of      * whatever it was we're cleaning up now.  This may involve killing      * some of them off...      */
name|struct
name|process_chain
modifier|*
name|pc
decl_stmt|;
name|int
name|need_timeout
init|=
literal|0
decl_stmt|;
name|apr_time_t
name|timeout_interval
decl_stmt|;
if|if
condition|(
operator|!
name|procs
condition|)
return|return;
comment|/* No work.  Whew! */
comment|/* First, check to see if we need to do the SIGTERM, sleep, SIGKILL      * dance with any of the processes we're cleaning up.  If we've got      * any kill-on-sight subprocesses, ditch them now as well, so they      * don't waste any more cycles doing whatever it is that they shouldn't      * be doing anymore.      */
ifndef|#
directive|ifndef
name|NEED_WAITPID
comment|/* Pick up all defunct processes */
for|for
control|(
name|pc
operator|=
name|procs
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|apr_proc_wait
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_NOWAIT
argument_list|)
operator|!=
name|APR_CHILD_NOTDONE
condition|)
name|pc
operator|->
name|kill_how
operator|=
name|APR_KILL_NEVER
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(NEED_WAITPID) */
for|for
control|(
name|pc
operator|=
name|procs
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
operator|(
name|pc
operator|->
name|kill_how
operator|==
name|APR_KILL_AFTER_TIMEOUT
operator|)
operator|||
operator|(
name|pc
operator|->
name|kill_how
operator|==
name|APR_KILL_ONLY_ONCE
operator|)
condition|)
block|{
comment|/*              * Subprocess may be dead already.  Only need the timeout if not.              * Note: apr_proc_kill on Windows is TerminateProcess(), which is              * similar to a SIGKILL, so always give the process a timeout              * under Windows before killing it.              */
if|if
condition|(
name|apr_proc_kill
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|SIGTERM
argument_list|)
operator|==
name|APR_SUCCESS
condition|)
name|need_timeout
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pc
operator|->
name|kill_how
operator|==
name|APR_KILL_ALWAYS
condition|)
block|{
else|#
directive|else
comment|/* WIN32 knows only one fast, clean method of killing processes today */
if|if
condition|(
name|pc
operator|->
name|kill_how
operator|!=
name|APR_KILL_NEVER
condition|)
block|{
name|need_timeout
operator|=
literal|1
expr_stmt|;
name|pc
operator|->
name|kill_how
operator|=
name|APR_KILL_ALWAYS
expr_stmt|;
endif|#
directive|endif
name|apr_proc_kill
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sleep only if we have to. The sleep algorithm grows      * by a factor of two on each iteration. TIMEOUT_INTERVAL      * is equal to TIMEOUT_USECS / 64.      */
if|if
condition|(
name|need_timeout
condition|)
block|{
name|timeout_interval
operator|=
name|TIMEOUT_INTERVAL
expr_stmt|;
name|apr_sleep
argument_list|(
name|timeout_interval
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* check the status of the subprocesses */
name|need_timeout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|procs
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|kill_how
operator|==
name|APR_KILL_AFTER_TIMEOUT
condition|)
block|{
if|if
condition|(
name|apr_proc_wait
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_NOWAIT
argument_list|)
operator|==
name|APR_CHILD_NOTDONE
condition|)
name|need_timeout
operator|=
literal|1
expr_stmt|;
comment|/* subprocess is still active */
else|else
name|pc
operator|->
name|kill_how
operator|=
name|APR_KILL_NEVER
expr_stmt|;
comment|/* subprocess has exited */
block|}
block|}
if|if
condition|(
name|need_timeout
condition|)
block|{
if|if
condition|(
name|timeout_interval
operator|>=
name|TIMEOUT_USECS
condition|)
block|{
break|break;
block|}
name|apr_sleep
argument_list|(
name|timeout_interval
argument_list|)
expr_stmt|;
name|timeout_interval
operator|*=
literal|2
expr_stmt|;
block|}
block|}
do|while
condition|(
name|need_timeout
condition|)
do|;
block|}
comment|/* OK, the scripts we just timed out for have had a chance to clean up      * --- now, just get rid of them, and also clean up the system accounting      * goop...      */
for|for
control|(
name|pc
operator|=
name|procs
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|kill_how
operator|==
name|APR_KILL_AFTER_TIMEOUT
condition|)
name|apr_proc_kill
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
comment|/* Now wait for all the signaled processes to die */
for|for
control|(
name|pc
operator|=
name|procs
init|;
name|pc
condition|;
name|pc
operator|=
name|pc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|kill_how
operator|!=
name|APR_KILL_NEVER
condition|)
operator|(
name|void
operator|)
name|apr_proc_wait
argument_list|(
name|pc
operator|->
name|proc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_WAIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Pool creation/destruction stubs, for people who are running  * mixed release/debug enviroments.  */
if|#
directive|if
operator|!
name|APR_POOL_DEBUG
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_palloc_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|,
argument|const char *file_line
argument_list|)
block|{
return|return
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_pcalloc_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|,
argument|const char *file_line
argument_list|)
block|{
return|return
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_clear_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *file_line
argument_list|)
block|{
name|apr_pool_clear
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_destroy_debug
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|const char *file_line
argument_list|)
block|{
name|apr_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_pool_t *parent
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
block|{
return|return
name|apr_pool_create_ex
argument_list|(
name|newpool
argument_list|,
name|parent
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_core_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
block|{
return|return
name|apr_pool_create_unmanaged_ex
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|)
return|;
block|}
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_unmanaged_ex_debug
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|,
argument|const char *file_line
argument_list|)
block|{
return|return
name|apr_pool_create_unmanaged_ex
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|)
return|;
block|}
else|#
directive|else
comment|/* APR_POOL_DEBUG */
undef|#
directive|undef
name|apr_palloc
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_palloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
empty_stmt|;
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_palloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
block|{
return|return
name|apr_palloc_debug
argument_list|(
name|pool
argument_list|,
name|size
argument_list|,
literal|"undefined"
argument_list|)
return|;
block|}
undef|#
directive|undef
name|apr_pcalloc
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_pcalloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
empty_stmt|;
name|APR_DECLARE
argument_list|(
argument|void *
argument_list|)
name|apr_pcalloc
argument_list|(
argument|apr_pool_t *pool
argument_list|,
argument|apr_size_t size
argument_list|)
block|{
return|return
name|apr_pcalloc_debug
argument_list|(
name|pool
argument_list|,
name|size
argument_list|,
literal|"undefined"
argument_list|)
return|;
block|}
undef|#
directive|undef
name|apr_pool_clear
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_clear
argument_list|(
name|apr_pool_t
operator|*
name|pool
argument_list|)
expr_stmt|;
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_clear
argument_list|(
argument|apr_pool_t *pool
argument_list|)
block|{
name|apr_pool_clear_debug
argument_list|(
name|pool
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|apr_pool_destroy
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_destroy
argument_list|(
name|apr_pool_t
operator|*
name|pool
argument_list|)
expr_stmt|;
name|APR_DECLARE
argument_list|(
argument|void
argument_list|)
name|apr_pool_destroy
argument_list|(
argument|apr_pool_t *pool
argument_list|)
block|{
name|apr_pool_destroy_debug
argument_list|(
name|pool
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|apr_pool_create_ex
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_pool_t *parent
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
empty_stmt|;
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_pool_t *parent
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
block|{
return|return
name|apr_pool_create_ex_debug
argument_list|(
name|newpool
argument_list|,
name|parent
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|,
literal|"undefined"
argument_list|)
return|;
block|}
undef|#
directive|undef
name|apr_pool_create_core_ex
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_core_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
empty_stmt|;
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_core_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
block|{
return|return
name|apr_pool_create_unmanaged_ex_debug
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|,
literal|"undefined"
argument_list|)
return|;
block|}
undef|#
directive|undef
name|apr_pool_create_unmanaged_ex
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_unmanaged_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
empty_stmt|;
name|APR_DECLARE
argument_list|(
argument|apr_status_t
argument_list|)
name|apr_pool_create_unmanaged_ex
argument_list|(
argument|apr_pool_t **newpool
argument_list|,
argument|apr_abortfunc_t abort_fn
argument_list|,
argument|apr_allocator_t *allocator
argument_list|)
block|{
return|return
name|apr_pool_create_unmanaged_ex_debug
argument_list|(
name|newpool
argument_list|,
name|abort_fn
argument_list|,
name|allocator
argument_list|,
literal|"undefined"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_POOL_DEBUG */
end_comment

end_unit

