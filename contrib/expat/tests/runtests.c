begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd    See the file COPYING for copying permission.     runtest.c : run the Expat test suite */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXPAT_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<expat_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* ptrdiff_t */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__cplusplus
end_ifndef

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"expat.h"
end_include

begin_include
include|#
directive|include
file|"chardata.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_comment
comment|/* for UNUSED_P only */
end_comment

begin_include
include|#
directive|include
file|"minicheck.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amigaos__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__USE_INLINE__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<proto/expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_LARGE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|XML_FMT_INT_MOD
value|"ll"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_FMT_INT_MOD
value|"l"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|XML_Parser
name|parser
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|basic_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Parser not created."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|basic_teardown
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|!=
name|NULL
condition|)
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a failure using the parser state to create an error message;    this should be used when the parser reports an error we weren't    expecting. */
end_comment

begin_function
specifier|static
name|void
name|_xml_failure
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|enum
name|XML_Error
name|err
init|=
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"    %d: %s (line %"
name|XML_FMT_INT_MOD
literal|"u, offset %"
expr|\
name|XML_FMT_INT_MOD
literal|"u)\n    reported from %s, line %d\n"
argument_list|,
name|err
argument_list|,
name|XML_ErrorString
argument_list|(
name|err
argument_list|)
argument_list|,
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|_fail_unless
argument_list|(
literal|0
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Status
name|_XML_Parse_SINGLE_BYTES
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|isFinal
parameter_list|)
block|{
name|enum
name|XML_Status
name|res
init|=
name|XML_STATUS_ERROR
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
name|isFinal
argument_list|)
return|;
block|}
for|for
control|(
init|;
name|offset
operator|<
name|len
condition|;
name|offset
operator|++
control|)
block|{
specifier|const
name|int
name|innerIsFinal
init|=
operator|(
name|offset
operator|==
name|len
operator|-
literal|1
operator|)
operator|&&
name|isFinal
decl_stmt|;
specifier|const
name|char
name|c
init|=
name|s
index|[
name|offset
index|]
decl_stmt|;
comment|/* to help out-of-bounds detection */
name|res
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|innerIsFinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|XML_STATUS_OK
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_define
define|#
directive|define
name|xml_failure
parameter_list|(
name|parser
parameter_list|)
value|_xml_failure((parser), __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|_expect_failure
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|enum
name|XML_Error
name|errorCode
parameter_list|,
specifier|const
name|char
modifier|*
name|errorMessage
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
comment|/* Hackish use of _fail_unless() macro, but let's us report            the right filename and line number. */
name|_fail_unless
argument_list|(
literal|0
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|,
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|errorCode
condition|)
name|_xml_failure
argument_list|(
name|parser
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|expect_failure
parameter_list|(
name|text
parameter_list|,
name|errorCode
parameter_list|,
name|errorMessage
parameter_list|)
define|\
value|_expect_failure((text), (errorCode), (errorMessage), \                         __FILE__, __LINE__)
end_define

begin_comment
comment|/* Dummy handlers for when we need to set a handler to tickle a bug,    but it doesn't need to do anything. */
end_comment

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_start_doctype_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|doctypeName
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|sysid
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|pubid
parameter_list|)
parameter_list|,
name|int
name|UNUSED_P
parameter_list|(
name|has_internal_subset
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_end_doctype_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_entity_decl_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|entityName
parameter_list|)
parameter_list|,
name|int
name|UNUSED_P
parameter_list|(
name|is_parameter_entity
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|value
parameter_list|)
parameter_list|,
name|int
name|UNUSED_P
parameter_list|(
name|value_length
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|publicId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|notationName
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_notation_decl_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|notationName
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|publicId
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_element_decl_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|XML_Content
modifier|*
name|UNUSED_P
parameter_list|(
name|model
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_attlist_decl_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|elname
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|attname
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|att_type
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|dflt
parameter_list|)
parameter_list|,
name|int
name|UNUSED_P
parameter_list|(
name|isrequired
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_comment_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|data
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_pi_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|target
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|data
parameter_list|)
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|dummy_start_element
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|name
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|UNUSED_P
parameter_list|(
name|atts
parameter_list|)
parameter_list|)
block|{}
end_function

begin_comment
comment|/*  * Character& encoding tests.  */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_nul_byte
argument_list|)
end_macro

begin_block
block|{
name|char
name|text
index|[]
init|=
literal|"<doc>\0</doc>"
decl_stmt|;
comment|/* test that a NUL byte (in US-ASCII data) is an error */
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
name|fail
argument_list|(
literal|"Parser did not report error on NUL-byte."
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_INVALID_TOKEN
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_u0000_char
parameter_list|)
block|{
comment|/* test that a NUL byte (in US-ASCII data) is an error */
name|expect_failure
argument_list|(
literal|"<doc>&#0;</doc>"
argument_list|,
name|XML_ERROR_BAD_CHAR_REF
argument_list|,
literal|"Parser did not report error on NUL-byte."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf8
parameter_list|)
block|{
comment|/* This test is really just making sure we don't core on a UTF-8 BOM. */
specifier|const
name|char
modifier|*
name|text
init|=
literal|"\357\273\277<e/>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf16_be
parameter_list|)
block|{
name|char
name|text
index|[]
init|=
literal|"\376\377\0<\0e\0/\0>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bom_utf16_le
parameter_list|)
block|{
name|char
name|text
index|[]
init|=
literal|"\377\376<\0e\0/\0>\0"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|void
name|XMLCALL
name|accumulate_characters
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|CharData_AppendXMLChars
argument_list|(
operator|(
name|CharData
operator|*
operator|)
name|userData
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|accumulate_attribute
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|name
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|storage
operator|->
name|count
operator|<
literal|0
operator|&&
name|atts
operator|!=
name|NULL
operator|&&
name|atts
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* "accumulate" the value of the first attribute we see */
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|atts
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_run_character_check
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|text
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_characters
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|_xml_failure
argument_list|(
name|parser
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|run_character_check
parameter_list|(
name|text
parameter_list|,
name|expected
parameter_list|)
define|\
value|_run_character_check(text, expected, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|_run_attribute_check
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|text
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_attribute
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|_xml_failure
argument_list|(
name|parser
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|run_attribute_check
parameter_list|(
name|text
parameter_list|,
name|expected
parameter_list|)
define|\
value|_run_attribute_check(text, expected, __FILE__, __LINE__)
end_define

begin_comment
comment|/* Regression test for SF bug #491986. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_danish_latin1
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<e>J\xF8rgen \xE6\xF8\xE5\xC6\xD8\xC5</e>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"J\xC3\xB8rgen \xC3\xA6\xC3\xB8\xC3\xA5\xC3\x86\xC3\x98\xC3\x85"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #514281. */
name|START_TEST
parameter_list|(
name|test_french_charref_hexidecimal
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>&#xE9;&#xE8;&#xE0;&#xE7;&#xEA;&#xC8;</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_charref_decimal
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>&#233;&#232;&#224;&#231;&#234;&#200;</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_latin1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<doc>\xE9\xE8\xE0\xE7\xEa\xC8</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_french_utf8
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='utf-8'?>\n"
literal|"<doc>\xC3\xA9</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #600479.    XXX There should be a test that exercises all legal XML Unicode    characters as PCDATA and attribute value content, and XML Name    characters as part of element and attribute names. */
name|START_TEST
parameter_list|(
name|test_utf8_false_rejection
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc>\xEF\xBA\xBF</doc>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xEF\xBA\xBF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #477667.    This test assures that any 8-bit character followed by a 7-bit    character will not be mistakenly interpreted as a valid UTF-8    sequence. */
name|START_TEST
parameter_list|(
name|test_illegal_utf8
parameter_list|)
block|{
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<=
literal|255
condition|;
operator|++
name|i
control|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"<e>%ccd</e>"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_OK
condition|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"expected token error for '%c' (ordinal %d) in UTF-8 text"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_INVALID_TOKEN
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Reset the parser since we use the same parser repeatedly. */
name|XML_ParserReset
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Examples, not masks: */
define|#
directive|define
name|UTF8_LEAD_1
value|"\x7f"
comment|/* 0b01111111 */
define|#
directive|define
name|UTF8_LEAD_2
value|"\xdf"
comment|/* 0b11011111 */
define|#
directive|define
name|UTF8_LEAD_3
value|"\xef"
comment|/* 0b11101111 */
define|#
directive|define
name|UTF8_LEAD_4
value|"\xf7"
comment|/* 0b11110111 */
define|#
directive|define
name|UTF8_FOLLOW
value|"\xbf"
comment|/* 0b10111111 */
name|START_TEST
parameter_list|(
name|test_utf8_auto_align
parameter_list|)
block|{
struct|struct
name|TestCase
block|{
name|ptrdiff_t
name|expectedMovementInChars
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|}
struct|;
name|struct
name|TestCase
name|cases
index|[]
init|=
block|{
block|{
literal|00
block|,
literal|""
block|}
block|,
block|{
literal|00
block|,
name|UTF8_LEAD_1
block|}
block|,
block|{
operator|-
literal|1
block|,
name|UTF8_LEAD_2
block|}
block|,
block|{
literal|00
block|,
name|UTF8_LEAD_2
name|UTF8_FOLLOW
block|}
block|,
block|{
operator|-
literal|1
block|,
name|UTF8_LEAD_3
block|}
block|,
block|{
operator|-
literal|2
block|,
name|UTF8_LEAD_3
name|UTF8_FOLLOW
block|}
block|,
block|{
literal|00
block|,
name|UTF8_LEAD_3
name|UTF8_FOLLOW
name|UTF8_FOLLOW
block|}
block|,
block|{
operator|-
literal|1
block|,
name|UTF8_LEAD_4
block|}
block|,
block|{
operator|-
literal|2
block|,
name|UTF8_LEAD_4
name|UTF8_FOLLOW
block|}
block|,
block|{
operator|-
literal|3
block|,
name|UTF8_LEAD_4
name|UTF8_FOLLOW
name|UTF8_FOLLOW
block|}
block|,
block|{
literal|00
block|,
name|UTF8_LEAD_4
name|UTF8_FOLLOW
name|UTF8_FOLLOW
name|UTF8_FOLLOW
block|}
block|,     }
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|cases
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fromLim
init|=
name|cases
index|[
name|i
index|]
operator|.
name|input
operator|+
name|strlen
argument_list|(
name|cases
index|[
name|i
index|]
operator|.
name|input
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fromLimInitially
init|=
name|fromLim
decl_stmt|;
name|ptrdiff_t
name|actualMovementInChars
decl_stmt|;
name|align_limit_to_full_utf8_characters
argument_list|(
name|cases
index|[
name|i
index|]
operator|.
name|input
argument_list|,
operator|&
name|fromLim
argument_list|)
expr_stmt|;
name|actualMovementInChars
operator|=
operator|(
name|fromLim
operator|-
name|fromLimInitially
operator|)
expr_stmt|;
if|if
condition|(
name|actualMovementInChars
operator|!=
name|cases
index|[
name|i
index|]
operator|.
name|expectedMovementInChars
condition|)
block|{
name|size_t
name|j
init|=
literal|0
decl_stmt|;
name|success
operator|=
name|false
expr_stmt|;
name|printf
argument_list|(
literal|"[-] UTF-8 case %2lu: Expected movement by %2ld chars"
literal|", actually moved by %2ld chars: \""
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|cases
index|[
name|i
index|]
operator|.
name|expectedMovementInChars
argument_list|,
name|actualMovementInChars
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|strlen
argument_list|(
name|cases
index|[
name|i
index|]
operator|.
name|input
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\\x%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|cases
index|[
name|i
index|]
operator|.
name|input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|fail
argument_list|(
literal|"UTF-8 auto-alignment is not bullet-proof\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_utf16
parameter_list|)
block|{
comment|/*<?xml version="1.0" encoding="UTF-16"?><doc a='123'>some text</doc>     */
name|char
name|text
index|[]
init|=
literal|"\000<\000?\000x\000m\000\154\000 \000v\000e\000r\000s\000i\000o"
literal|"\000n\000=\000'\0001\000.\000\060\000'\000 \000e\000n\000c\000o"
literal|"\000d\000i\000n\000g\000=\000'\000U\000T\000F\000-\0001\000\066"
literal|"\000'\000?\000>\000\n"
literal|"\000<\000d\000o\000c\000 \000a\000=\000'\0001\0002\0003\000'"
literal|"\000>\000s\000o\000m\000e\000 \000t\000e\000x\000t\000<\000/"
literal|"\000d\000o\000c\000>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_utf16_le_epilog_newline
parameter_list|)
block|{
name|unsigned
name|int
name|first_chunk_bytes
init|=
literal|17
decl_stmt|;
name|char
name|text
index|[]
init|=
literal|"\xFF\xFE"
comment|/* BOM */
literal|"<\000e\000/\000>\000"
comment|/* document element */
literal|"\r\000\n\000\r\000\n\000"
decl_stmt|;
comment|/* epilog */
if|if
condition|(
name|first_chunk_bytes
operator|>=
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
condition|)
name|fail
argument_list|(
literal|"bad value of first_chunk_bytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|first_chunk_bytes
argument_list|,
name|XML_FALSE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|XML_Status
name|rc
decl_stmt|;
name|rc
operator|=
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
operator|+
name|first_chunk_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
name|first_chunk_bytes
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #481609, #774028. */
name|START_TEST
parameter_list|(
name|test_latin1_umlauts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?>\n"
literal|"<e a='\xE4 \xF6 \xFC&#228;&#246;&#252;&#x00E4;&#x0F6;&#xFC;>'\n"
literal|">\xE4 \xF6 \xFC&#228;&#246;&#252;&#x00E4;&#x0F6;&#xFC;></e>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8
init|=
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC "
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC "
literal|"\xC3\xA4 \xC3\xB6 \xC3\xBC>"
decl_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|XML_ParserReset
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_attribute_check
argument_list|(
name|text
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #1 for SF bug #653180. */
name|START_TEST
parameter_list|(
name|test_line_number_after_parse
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<tag>\n"
literal|"\n"
literal|"\n</tag>"
decl_stmt|;
name|XML_Size
name|lineno
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_FALSE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno
operator|!=
literal|4
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"expected 4 lines, saw %"
name|XML_FMT_INT_MOD
literal|"u"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #2 for SF bug #653180. */
name|START_TEST
parameter_list|(
name|test_column_number_after_parse
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<tag></tag>"
decl_stmt|;
name|XML_Size
name|colno
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_FALSE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|colno
operator|=
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|colno
operator|!=
literal|11
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"expected 11 columns, saw %"
name|XML_FMT_INT_MOD
literal|"u"
argument_list|,
name|colno
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|void
name|XMLCALL
name|start_element_event_handler2
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|UNUSED_P
parameter_list|(
name|attr
parameter_list|)
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"<%s> at col:%"
name|XML_FMT_INT_MOD
literal|"u line:%"
expr|\
name|XML_FMT_INT_MOD
literal|"u\n"
argument_list|,
name|name
argument_list|,
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|end_element_event_handler2
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"</%s> at col:%"
name|XML_FMT_INT_MOD
literal|"u line:%"
expr|\
name|XML_FMT_INT_MOD
literal|"u\n"
argument_list|,
name|name
argument_list|,
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
argument_list|,
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test #3 for SF bug #653180. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_line_and_column_numbers_inside_handlers
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a>\n"
comment|/* Unix end-of-line */
literal|"<b>\r\n"
comment|/* Windows end-of-line */
literal|"<c/>\r"
comment|/* Mac OS end-of-line */
literal|"</b>\n"
literal|"<d>\n"
literal|"<f/>\n"
literal|"</d>\n"
literal|"</a>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
init|=
literal|"<a> at col:0 line:1\n"
literal|"<b> at col:2 line:2\n"
literal|"<c> at col:4 line:3\n"
literal|"</c> at col:8 line:3\n"
literal|"</b> at col:2 line:4\n"
literal|"<d> at col:2 line:5\n"
literal|"<f> at col:4 line:6\n"
literal|"</f> at col:8 line:6\n"
literal|"</d> at col:2 line:7\n"
literal|"</a> at col:0 line:8\n"
decl_stmt|;
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|start_element_event_handler2
argument_list|)
expr_stmt|;
name|XML_SetEndElementHandler
argument_list|(
name|parser
argument_list|,
name|end_element_event_handler2
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckString
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test #4 for SF bug #653180. */
name|START_TEST
parameter_list|(
name|test_line_number_after_error
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a>\n"
literal|"<b>\n"
literal|"</a>"
decl_stmt|;
comment|/* missing</b> */
name|XML_Size
name|lineno
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_FALSE
argument_list|)
operator|!=
name|XML_STATUS_ERROR
condition|)
name|fail
argument_list|(
literal|"Expected a parse error"
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|XML_GetCurrentLineNumber
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno
operator|!=
literal|3
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"expected 3 lines, saw %"
name|XML_FMT_INT_MOD
literal|"u"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #5 for SF bug #653180. */
name|START_TEST
parameter_list|(
name|test_column_number_after_error
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a>\n"
literal|"<b>\n"
literal|"</a>"
decl_stmt|;
comment|/* missing</b> */
name|XML_Size
name|colno
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_FALSE
argument_list|)
operator|!=
name|XML_STATUS_ERROR
condition|)
name|fail
argument_list|(
literal|"Expected a parse error"
argument_list|)
expr_stmt|;
name|colno
operator|=
name|XML_GetCurrentColumnNumber
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|colno
operator|!=
literal|4
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"expected 4 columns, saw %"
name|XML_FMT_INT_MOD
literal|"u"
argument_list|,
name|colno
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #478332. */
name|START_TEST
parameter_list|(
name|test_really_long_lines
parameter_list|)
block|{
comment|/* This parses an input line longer than INIT_DATA_BUF_SIZE        characters long (defined to be 1024 in xmlparse.c).  We take a        really cheesy approach to building the input buffer, because        this avoids writing bugs in buffer-filling code.     */
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<e>"
comment|/* 64 chars */
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
comment|/* until we have at least 1024 characters on the line: */
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"
literal|"</e>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/*  * Element event tests.  */
specifier|static
name|void
name|XMLCALL
name|end_element_event_handler
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_end_element_events
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a><b><c/></b><d><f/></d></a>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
init|=
literal|"/c/b/f/d/a"
decl_stmt|;
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetEndElementHandler
argument_list|(
name|parser
argument_list|,
name|end_element_event_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckString
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/*  * Attribute tests.  */
comment|/* Helpers used by the following test; this checks any "attr" and "refs"    attributes to make sure whitespace has been normalized.     Return true if whitespace has been normalized in a string, using    the rules for attribute value normalization.  The 'is_cdata' flag    is needed since CDATA attributes don't need to have multiple    whitespace characters collapsed to a single space, while other    attribute data types do.  (Section 3.3.3 of the recommendation.) */
specifier|static
name|int
name|is_whitespace_normalized
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|is_cdata
parameter_list|)
block|{
name|int
name|blanks
init|=
literal|0
decl_stmt|;
name|int
name|at_start
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|blanks
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
literal|'\r'
condition|)
return|return
literal|0
return|;
else|else
block|{
if|if
condition|(
name|at_start
condition|)
block|{
name|at_start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanks
operator|&&
operator|!
name|is_cdata
condition|)
comment|/* illegal leading blanks */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|blanks
operator|>
literal|1
operator|&&
operator|!
name|is_cdata
condition|)
return|return
literal|0
return|;
name|blanks
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|blanks
operator|&&
operator|!
name|is_cdata
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check the attribute whitespace checker: */
end_comment

begin_function
specifier|static
name|void
name|testhelper_is_whitespace_normalized
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|" abc def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|" abc def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc  def ghi"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc  def ghi"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi "
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|"abc def ghi "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_whitespace_normalized
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\t"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\r"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_whitespace_normalized
argument_list|(
literal|"abc\t def"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|check_attr_contains_normalized_whitespace
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|name
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|atts
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
specifier|const
name|XML_Char
modifier|*
name|attrname
init|=
name|atts
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|value
init|=
name|atts
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"attr"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"ents"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"refs"
argument_list|,
name|attrname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|is_whitespace_normalized
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"attribute value not normalized: %s='%s'"
argument_list|,
name|attrname
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_attr_whitespace_normalization
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ATTLIST doc\n"
literal|"            attr NMTOKENS #REQUIRED\n"
literal|"            ents ENTITIES #REQUIRED\n"
literal|"            refs IDREFS   #REQUIRED>\n"
literal|"]>\n"
literal|"<doc attr='    a  b c\t\td\te\t' refs=' id-1   \t  id-2\t\t'  \n"
literal|"     ents=' ent-1   \t\r\n"
literal|"            ent-2  '>\n"
literal|"<e id='id-1'/>\n"
literal|"<e id='id-2'/>\n"
literal|"</doc>"
decl_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|check_attr_contains_normalized_whitespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/*  * XML declaration tests.  */
name|START_TEST
parameter_list|(
name|test_xmldecl_misplaced
parameter_list|)
block|{
name|expect_failure
argument_list|(
literal|"\n"
literal|"<?xml version='1.0'?>\n"
literal|"<a/>"
argument_list|,
name|XML_ERROR_MISPLACED_XML_PI
argument_list|,
literal|"failed to report misplaced XML declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #584832. */
specifier|static
name|int
name|XMLCALL
name|UnknownEncodingHandler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|data
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encoding
parameter_list|,
name|XML_Encoding
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"unsupported-encoding"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|info
operator|->
name|map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|info
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|release
operator|=
name|NULL
expr_stmt|;
return|return
name|XML_STATUS_OK
return|;
block|}
return|return
name|XML_STATUS_ERROR
return|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_unknown_encoding_internal_entity
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='unsupported-encoding'?>\n"
literal|"<!DOCTYPE test [<!ENTITY foo 'bar'>]>\n"
literal|"<test a='&foo;'/>"
decl_stmt|;
name|XML_SetUnknownEncodingHandler
argument_list|(
name|parser
argument_list|,
name|UnknownEncodingHandler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #620106. */
specifier|static
name|int
name|XMLCALL
name|external_entity_loader_set_encoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|publicId
parameter_list|)
parameter_list|)
block|{
comment|/* This text says it's an unsupported encoding, but it's really        UTF-8, which we tell Expat using XML_SetEncoding().     */
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml encoding='iso-8859-3'?>"
literal|"\xC3\xA9"
decl_stmt|;
name|XML_Parser
name|extparser
decl_stmt|;
name|extparser
operator|=
name|XML_ExternalEntityParserCreate
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extparser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Could not create external entity parser."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XML_SetEncoding
argument_list|(
name|extparser
argument_list|,
literal|"utf-8"
argument_list|)
condition|)
name|fail
argument_list|(
literal|"XML_SetEncoding() ignored for external entity"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|extparser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_ext_entity_set_encoding
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ENTITY en SYSTEM 'http://xml.libexpat.org/dummy.ent'>\n"
literal|"]>\n"
literal|"<doc>&en;</doc>"
decl_stmt|;
name|XML_SetExternalEntityRefHandler
argument_list|(
name|parser
argument_list|,
name|external_entity_loader_set_encoding
argument_list|)
expr_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\xC3\xA9"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Test that no error is reported for unknown entities if we don't    read an external subset.  This was fixed in Expat 1.95.5. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_unread_external_subset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Test that an error is reported for unknown entities if we don't    have an external subset. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_no_external_subset
parameter_list|)
block|{
name|expect_failure
argument_list|(
literal|"<doc>&entity;</doc>"
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity w/out a DTD."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Test that an error is reported for unknown entities if we don't    read an external subset, but have been declared standalone. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_standalone
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='us-ascii' standalone='yes'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity (standalone)."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|int
name|XMLCALL
name|external_entity_loader
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|publicId
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|text
init|=
operator|(
name|char
operator|*
operator|)
name|XML_GetUserData
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|XML_Parser
name|extparser
decl_stmt|;
name|extparser
operator|=
name|XML_ExternalEntityParserCreate
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extparser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Could not create external entity parser."
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|extparser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
return|return
name|XML_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Test that an error is reported for unknown entities if we have read    an external subset, and standalone is true. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_wfc_undeclared_entity_with_external_subset_standalone
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='us-ascii' standalone='yes'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|char
name|foo_text
index|[]
init|=
literal|"<!ELEMENT doc (#PCDATA)*>"
decl_stmt|;
name|XML_SetParamEntityParsing
argument_list|(
name|parser
argument_list|,
name|XML_PARAM_ENTITY_PARSING_ALWAYS
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|foo_text
argument_list|)
expr_stmt|;
name|XML_SetExternalEntityRefHandler
argument_list|(
name|parser
argument_list|,
name|external_entity_loader
argument_list|)
expr_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDEFINED_ENTITY
argument_list|,
literal|"Parser did not report undefined entity (external DTD)."
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Test that no error is reported for unknown entities if we have read    an external subset, and standalone is false. */
name|START_TEST
parameter_list|(
name|test_wfc_undeclared_entity_with_external_subset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0' encoding='us-ascii'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'foo'>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|char
name|foo_text
index|[]
init|=
literal|"<!ELEMENT doc (#PCDATA)*>"
decl_stmt|;
name|XML_SetParamEntityParsing
argument_list|(
name|parser
argument_list|,
name|XML_PARAM_ENTITY_PARSING_ALWAYS
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|foo_text
argument_list|)
expr_stmt|;
name|XML_SetExternalEntityRefHandler
argument_list|(
name|parser
argument_list|,
name|external_entity_loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_wfc_no_recursive_entity_refs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ENTITY entity '&#38;entity;'>\n"
literal|"]>\n"
literal|"<doc>&entity;</doc>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_RECURSIVE_ENTITY_REF
argument_list|,
literal|"Parser did not report recursive entity reference."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #483514. */
name|START_TEST
parameter_list|(
name|test_dtd_default_handling
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ENTITY e SYSTEM 'http://xml.libexpat.org/e'>\n"
literal|"<!NOTATION n SYSTEM 'http://xml.libexpat.org/n'>\n"
literal|"<!ELEMENT doc EMPTY>\n"
literal|"<!ATTLIST doc a CDATA #IMPLIED>\n"
literal|"<?pi in dtd?>\n"
literal|"<!--comment in dtd-->\n"
literal|"]><doc/>"
decl_stmt|;
name|XML_SetDefaultHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_characters
argument_list|)
expr_stmt|;
name|XML_SetDoctypeDeclHandler
argument_list|(
name|parser
argument_list|,
name|dummy_start_doctype_handler
argument_list|,
name|dummy_end_doctype_handler
argument_list|)
expr_stmt|;
name|XML_SetEntityDeclHandler
argument_list|(
name|parser
argument_list|,
name|dummy_entity_decl_handler
argument_list|)
expr_stmt|;
name|XML_SetNotationDeclHandler
argument_list|(
name|parser
argument_list|,
name|dummy_notation_decl_handler
argument_list|)
expr_stmt|;
name|XML_SetElementDeclHandler
argument_list|(
name|parser
argument_list|,
name|dummy_element_decl_handler
argument_list|)
expr_stmt|;
name|XML_SetAttlistDeclHandler
argument_list|(
name|parser
argument_list|,
name|dummy_attlist_decl_handler
argument_list|)
expr_stmt|;
name|XML_SetProcessingInstructionHandler
argument_list|(
name|parser
argument_list|,
name|dummy_pi_handler
argument_list|)
expr_stmt|;
name|XML_SetCommentHandler
argument_list|(
name|parser
argument_list|,
name|dummy_comment_handler
argument_list|)
expr_stmt|;
name|run_character_check
argument_list|(
name|text
argument_list|,
literal|"\n\n\n\n\n\n\n<doc/>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* See related SF bug #673791.    When namespace processing is enabled, setting the namespace URI for    a prefix is not allowed; this test ensures that it *is* allowed    when namespace processing is not enabled.    (See Namespaces in XML, section 2.) */
name|START_TEST
parameter_list|(
name|test_empty_ns_without_namespaces
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc xmlns:prefix='http://www.example.com/'>\n"
literal|"<e xmlns:prefix=''/>\n"
literal|"</doc>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #824420.    Checks that an xmlns:prefix attribute set in an attribute's default    value isn't misinterpreted. */
name|START_TEST
parameter_list|(
name|test_ns_in_attribute_default_without_namespaces
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE e:element [\n"
literal|"<!ATTLIST e:element\n"
literal|"    xmlns:e CDATA 'http://example.com/'>\n"
literal|"      ]>\n"
literal|"<e:element/>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|END_TEST
specifier|static
specifier|const
name|char
modifier|*
name|long_character_data_text
init|=
literal|"<?xml version='1.0' encoding='iso-8859-1'?><s>"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"012345678901234567890123456789012345678901234567890123456789"
literal|"</s>"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XML_Bool
name|resumable
init|=
name|XML_FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clearing_aborting_character_handler
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|s
parameter_list|)
parameter_list|,
name|int
name|UNUSED_P
parameter_list|(
name|len
parameter_list|)
parameter_list|)
block|{
name|XML_StopParser
argument_list|(
name|parser
argument_list|,
name|resumable
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for SF bug #1515266: missing check of stopped    parser in doContext() 'for' loop. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_stop_parser_between_char_data_calls
argument_list|)
end_macro

begin_block
block|{
comment|/* The sample data must be big enough that there are two calls to        the character data handler from within the inner "for" loop of        the XML_TOK_DATA_CHARS case in doContent(), and the character        handler must stop the parser and clear the character data        handler.     */
specifier|const
name|char
modifier|*
name|text
init|=
name|long_character_data_text
decl_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|clearing_aborting_character_handler
argument_list|)
expr_stmt|;
name|resumable
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|!=
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_ABORTED
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #1515266: missing check of stopped    parser in doContext() 'for' loop. */
name|START_TEST
parameter_list|(
name|test_suspend_parser_between_char_data_calls
parameter_list|)
block|{
comment|/* The sample data must be big enough that there are two calls to        the character data handler from within the inner "for" loop of        the XML_TOK_DATA_CHARS case in doContent(), and the character        handler must stop the parser and clear the character data        handler.     */
specifier|const
name|char
modifier|*
name|text
init|=
name|long_character_data_text
decl_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|clearing_aborting_character_handler
argument_list|)
expr_stmt|;
name|resumable
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|!=
name|XML_STATUS_SUSPENDED
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
operator|!=
name|XML_ERROR_NONE
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_good_cdata_ascii
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a><![CDATA[<greeting>Hello, world!</greeting>]]></a>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
init|=
literal|"<greeting>Hello, world!</greeting>"
decl_stmt|;
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_characters
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_good_cdata_utf16
parameter_list|)
block|{
comment|/* Test data is:      *<?xml version='1.0' encoding='utf-16'?>      *<a><![CDATA[hello]]></a>      */
specifier|const
name|char
name|text
index|[]
init|=
literal|"\0<\0?\0x\0m\0l\0"
literal|" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"
literal|" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"
literal|"1\0"
literal|"6\0'"
literal|"\0?\0>\0\n"
literal|"\0<\0a\0>\0<\0!\0[\0C\0D\0A\0T\0A\0[\0h\0e\0l\0l\0o\0]\0]\0>\0<\0/\0a\0>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
init|=
literal|"hello"
decl_stmt|;
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|accumulate_characters
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
operator|-
literal|1
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckXMLChars
argument_list|(
operator|&
name|storage
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_bad_cdata
parameter_list|)
block|{
struct|struct
name|CaseData
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|enum
name|XML_Error
name|expectedError
decl_stmt|;
block|}
struct|;
name|struct
name|CaseData
name|cases
index|[]
init|=
block|{
block|{
literal|"<a><"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><!"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><!["
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![C"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![CD"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![CDA"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![CDAT"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![CDATA"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
block|{
literal|"<a><![CDATA["
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|,
block|{
literal|"<a><![CDATA[]"
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|,
block|{
literal|"<a><![CDATA[]]"
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|,
block|{
literal|"<a><!<a/>"
block|,
name|XML_ERROR_INVALID_TOKEN
block|}
block|,
block|{
literal|"<a><![<a/>"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
comment|/* ?! */
block|{
literal|"<a><![C<a/>"
block|,
name|XML_ERROR_UNCLOSED_TOKEN
block|}
block|,
comment|/* ?! */
block|{
literal|"<a><![CD<a/>"
block|,
name|XML_ERROR_INVALID_TOKEN
block|}
block|,
block|{
literal|"<a><![CDA<a/>"
block|,
name|XML_ERROR_INVALID_TOKEN
block|}
block|,
block|{
literal|"<a><![CDAT<a/>"
block|,
name|XML_ERROR_INVALID_TOKEN
block|}
block|,
block|{
literal|"<a><![CDATA<a/>"
block|,
name|XML_ERROR_INVALID_TOKEN
block|}
block|,
block|{
literal|"<a><![CDATA[<a/>"
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|,
block|{
literal|"<a><![CDATA[]<a/>"
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|,
block|{
literal|"<a><![CDATA[]]<a/>"
block|,
name|XML_ERROR_UNCLOSED_CDATA_SECTION
block|}
block|}
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|CaseData
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|enum
name|XML_Status
name|actualStatus
init|=
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|cases
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|strlen
argument_list|(
name|cases
index|[
name|i
index|]
operator|.
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|XML_Error
name|actualError
init|=
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|actualStatus
operator|==
name|XML_STATUS_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualError
operator|!=
name|cases
index|[
name|i
index|]
operator|.
name|expectedError
condition|)
block|{
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Expected error %d but got error %d for case %u: \"%s\"\n"
argument_list|,
name|cases
index|[
name|i
index|]
operator|.
name|expectedError
argument_list|,
name|actualError
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
operator|+
literal|1
argument_list|,
name|cases
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|XML_ParserReset
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|END_TEST
comment|/*  * Namespaces tests.  */
specifier|static
name|void
name|namespace_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|parser
operator|=
name|XML_ParserCreateNS
argument_list|(
name|NULL
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|"Parser not created."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|namespace_teardown
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_teardown
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that an element name and attribute name match the expected values.    The expected values are passed as an array reference of string pointers    provided as the userData argument; the first is the expected    element name, and the second is the expected attribute name. */
end_comment

begin_function
specifier|static
name|void
name|XMLCALL
name|triplet_start_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|elemstr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|userData
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected start string: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|1
index|]
argument_list|,
name|atts
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected attribute string: '%s'"
argument_list|,
name|atts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check that the element name passed to the end-element handler matches    the expected value.  The expected value is passed as the first element    in an array of strings passed as the userData argument. */
end_comment

begin_function
specifier|static
name|void
name|XMLCALL
name|triplet_end_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|elemstr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemstr
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unexpected end string: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_return_ns_triplet
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<foo:e xmlns:foo='http://expat.sf.net/' bar:a='12'\n"
literal|"       xmlns:bar='http://expat.sf.net/'></foo:e>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|elemstr
index|[]
init|=
block|{
literal|"http://expat.sf.net/ e foo"
block|,
literal|"http://expat.sf.net/ a bar"
block|}
decl_stmt|;
name|XML_SetReturnNSTriplet
argument_list|(
name|parser
argument_list|,
name|XML_TRUE
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|elemstr
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|triplet_start_checker
argument_list|,
name|triplet_end_checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
specifier|static
name|void
name|XMLCALL
name|overwrite_start_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"start "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|atts
operator|!=
name|NULL
condition|)
block|{
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\nattribute "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
operator|*
name|atts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atts
operator|+=
literal|2
expr_stmt|;
block|}
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|overwrite_end_checker
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|CharData
modifier|*
name|storage
init|=
operator|(
name|CharData
operator|*
operator|)
name|userData
decl_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"end "
argument_list|)
expr_stmt|;
name|CharData_AppendXMLChars
argument_list|(
name|storage
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CharData_AppendString
argument_list|(
name|storage
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_ns_tagname_overwrite_test
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
specifier|const
name|char
modifier|*
name|result
parameter_list|)
block|{
name|CharData
name|storage
decl_stmt|;
name|CharData_Init
argument_list|(
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|overwrite_start_checker
argument_list|,
name|overwrite_end_checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|CharData_CheckString
argument_list|(
operator|&
name|storage
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for SF bug #566334. */
end_comment

begin_macro
name|START_TEST
argument_list|(
argument|test_ns_tagname_overwrite
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<n:e xmlns:n='http://xml.libexpat.org/'>\n"
literal|"<n:f n:attr='foo'/>\n"
literal|"<n:g n:attr2='bar'/>\n"
literal|"</n:e>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
init|=
literal|"start http://xml.libexpat.org/ e\n"
literal|"start http://xml.libexpat.org/ f\n"
literal|"attribute http://xml.libexpat.org/ attr\n"
literal|"end http://xml.libexpat.org/ f\n"
literal|"start http://xml.libexpat.org/ g\n"
literal|"attribute http://xml.libexpat.org/ attr2\n"
literal|"end http://xml.libexpat.org/ g\n"
literal|"end http://xml.libexpat.org/ e\n"
decl_stmt|;
name|run_ns_tagname_overwrite_test
argument_list|(
name|text
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #566334. */
name|START_TEST
parameter_list|(
name|test_ns_tagname_overwrite_triplet
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<n:e xmlns:n='http://xml.libexpat.org/'>\n"
literal|"<n:f n:attr='foo'/>\n"
literal|"<n:g n:attr2='bar'/>\n"
literal|"</n:e>"
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
init|=
literal|"start http://xml.libexpat.org/ e n\n"
literal|"start http://xml.libexpat.org/ f n\n"
literal|"attribute http://xml.libexpat.org/ attr n\n"
literal|"end http://xml.libexpat.org/ f n\n"
literal|"start http://xml.libexpat.org/ g n\n"
literal|"attribute http://xml.libexpat.org/ attr2 n\n"
literal|"end http://xml.libexpat.org/ g n\n"
literal|"end http://xml.libexpat.org/ e n\n"
decl_stmt|;
name|XML_SetReturnNSTriplet
argument_list|(
name|parser
argument_list|,
name|XML_TRUE
argument_list|)
expr_stmt|;
name|run_ns_tagname_overwrite_test
argument_list|(
name|text
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #620343. */
specifier|static
name|void
name|XMLCALL
name|start_element_fail
parameter_list|(
name|void
modifier|*
name|UNUSED_P
parameter_list|(
name|userData
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|name
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|UNUSED_P
parameter_list|(
name|atts
parameter_list|)
parameter_list|)
block|{
comment|/* We should never get here. */
name|fail
argument_list|(
literal|"should never reach start_element_fail()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XMLCALL
name|start_ns_clearing_start_element
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|prefix
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|uri
parameter_list|)
parameter_list|)
block|{
name|XML_SetStartElementHandler
argument_list|(
operator|(
name|XML_Parser
operator|)
name|userData
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_start_ns_clears_start_element
argument_list|)
end_macro

begin_block
block|{
comment|/* This needs to use separate start/end tags; using the empty tag        syntax doesn't cause the problematic path through Expat to be        taken.     */
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<e xmlns='http://xml.libexpat.org/'></e>"
decl_stmt|;
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|start_element_fail
argument_list|)
expr_stmt|;
name|XML_SetStartNamespaceDeclHandler
argument_list|(
name|parser
argument_list|,
name|start_ns_clearing_start_element
argument_list|)
expr_stmt|;
name|XML_UseParserAsHandlerArg
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test for SF bug #616863. */
specifier|static
name|int
name|XMLCALL
name|external_entity_handler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|base
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|systemId
parameter_list|)
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|UNUSED_P
parameter_list|(
name|publicId
parameter_list|)
parameter_list|)
block|{
name|intptr_t
name|callno
init|=
literal|1
operator|+
operator|(
name|intptr_t
operator|)
name|XML_GetUserData
argument_list|(
name|parser
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|XML_Parser
name|p2
decl_stmt|;
if|if
condition|(
name|callno
operator|==
literal|1
condition|)
name|text
operator|=
operator|(
literal|"<!ELEMENT doc (e+)>\n"
literal|"<!ATTLIST doc xmlns CDATA #IMPLIED>\n"
literal|"<!ELEMENT e EMPTY>\n"
operator|)
expr_stmt|;
else|else
name|text
operator|=
operator|(
literal|"<?xml version='1.0' encoding='us-ascii'?>"
literal|"<e/>"
operator|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|(
name|void
operator|*
operator|)
name|callno
argument_list|)
expr_stmt|;
name|p2
operator|=
name|XML_ExternalEntityParserCreate
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|p2
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|xml_failure
argument_list|(
name|p2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|XML_ParserFree
argument_list|(
name|p2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|START_TEST
argument_list|(
argument|test_default_ns_from_ext_subset_and_ext_ge
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0'?>\n"
literal|"<!DOCTYPE doc SYSTEM 'http://xml.libexpat.org/doc.dtd' [\n"
literal|"<!ENTITY en SYSTEM 'http://xml.libexpat.org/entity.ent'>\n"
literal|"]>\n"
literal|"<doc xmlns='http://xml.libexpat.org/ns1'>\n"
literal|"&en;\n"
literal|"</doc>"
decl_stmt|;
name|XML_SetParamEntityParsing
argument_list|(
name|parser
argument_list|,
name|XML_PARAM_ENTITY_PARSING_ALWAYS
argument_list|)
expr_stmt|;
name|XML_SetExternalEntityRefHandler
argument_list|(
name|parser
argument_list|,
name|external_entity_handler
argument_list|)
expr_stmt|;
comment|/* We actually need to set this handler to tickle this bug. */
name|XML_SetStartElementHandler
argument_list|(
name|parser
argument_list|,
name|dummy_start_element
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|END_TEST
comment|/* Regression test #1 for SF bug #673791. */
name|START_TEST
parameter_list|(
name|test_ns_prefix_with_empty_uri_1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc xmlns:prefix='http://xml.libexpat.org/'>\n"
literal|"<e xmlns:prefix=''/>\n"
literal|"</doc>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDECLARING_PREFIX
argument_list|,
literal|"Did not report re-setting namespace"
literal|" URI with prefix to ''."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #2 for SF bug #673791. */
name|START_TEST
parameter_list|(
name|test_ns_prefix_with_empty_uri_2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<?xml version='1.0'?>\n"
literal|"<docelem xmlns:pre=''/>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDECLARING_PREFIX
argument_list|,
literal|"Did not report setting namespace URI with prefix to ''."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #3 for SF bug #673791. */
name|START_TEST
parameter_list|(
name|test_ns_prefix_with_empty_uri_3
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ELEMENT doc EMPTY>\n"
literal|"<!ATTLIST doc\n"
literal|"    xmlns:prefix CDATA ''>\n"
literal|"]>\n"
literal|"<doc/>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNDECLARING_PREFIX
argument_list|,
literal|"Didn't report attr default setting NS w/ prefix to ''."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test #4 for SF bug #673791. */
name|START_TEST
parameter_list|(
name|test_ns_prefix_with_empty_uri_4
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<!DOCTYPE doc [\n"
literal|"<!ELEMENT prefix:doc EMPTY>\n"
literal|"<!ATTLIST prefix:doc\n"
literal|"    xmlns:prefix CDATA 'http://xml.libexpat.org/'>\n"
literal|"]>\n"
literal|"<prefix:doc/>"
decl_stmt|;
comment|/* Packaged info expected by the end element handler;        the weird structuring lets us re-use the triplet_end_checker()        function also used for another test. */
specifier|const
name|char
modifier|*
name|elemstr
index|[]
init|=
block|{
literal|"http://xml.libexpat.org/ doc prefix"
block|}
decl_stmt|;
name|XML_SetReturnNSTriplet
argument_list|(
name|parser
argument_list|,
name|XML_TRUE
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|elemstr
argument_list|)
expr_stmt|;
name|XML_SetEndElementHandler
argument_list|(
name|parser
argument_list|,
name|triplet_end_checker
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
name|START_TEST
parameter_list|(
name|test_ns_default_with_empty_uri
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc xmlns='http://xml.libexpat.org/'>\n"
literal|"<e xmlns=''/>\n"
literal|"</doc>"
decl_stmt|;
if|if
condition|(
name|_XML_Parse_SINGLE_BYTES
argument_list|(
name|parser
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|,
name|XML_TRUE
argument_list|)
operator|==
name|XML_STATUS_ERROR
condition|)
name|xml_failure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #692964: two prefixes for one namespace. */
name|START_TEST
parameter_list|(
name|test_ns_duplicate_attrs_diff_prefixes
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc xmlns:a='http://xml.libexpat.org/a'\n"
literal|"     xmlns:b='http://xml.libexpat.org/a'\n"
literal|"     a:a='v' b:a='v' />"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_DUPLICATE_ATTRIBUTE
argument_list|,
literal|"did not report multiple attributes with same URI+name"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #695401: unbound prefix. */
name|START_TEST
parameter_list|(
name|test_ns_unbound_prefix_on_attribute
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<doc a:attr=''/>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNBOUND_PREFIX
argument_list|,
literal|"did not report unbound prefix on attribute"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
comment|/* Regression test for SF bug #695401: unbound prefix. */
name|START_TEST
parameter_list|(
name|test_ns_unbound_prefix_on_element
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
literal|"<a:doc/>"
decl_stmt|;
name|expect_failure
argument_list|(
name|text
argument_list|,
name|XML_ERROR_UNBOUND_PREFIX
argument_list|,
literal|"did not report unbound prefix on element"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|END_TEST
specifier|static
name|Suite
modifier|*
name|make_suite
parameter_list|(
name|void
parameter_list|)
block|{
name|Suite
modifier|*
name|s
init|=
name|suite_create
argument_list|(
literal|"basic"
argument_list|)
decl_stmt|;
name|TCase
modifier|*
name|tc_basic
init|=
name|tcase_create
argument_list|(
literal|"basic tests"
argument_list|)
decl_stmt|;
name|TCase
modifier|*
name|tc_namespace
init|=
name|tcase_create
argument_list|(
literal|"XML namespaces"
argument_list|)
decl_stmt|;
name|suite_add_tcase
argument_list|(
name|s
argument_list|,
name|tc_basic
argument_list|)
expr_stmt|;
name|tcase_add_checked_fixture
argument_list|(
name|tc_basic
argument_list|,
name|basic_setup
argument_list|,
name|basic_teardown
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_nul_byte
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_u0000_char
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf16_be
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bom_utf16_le
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_illegal_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf8_auto_align
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf16
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf16_le_epilog_newline
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_latin1_umlauts
argument_list|)
expr_stmt|;
comment|/* Regression test for SF bug #491986. */
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_danish_latin1
argument_list|)
expr_stmt|;
comment|/* Regression test for SF bug #514281. */
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_charref_hexidecimal
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_charref_decimal
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_latin1
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_french_utf8
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_utf8_false_rejection
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_line_number_after_parse
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_column_number_after_parse
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_line_and_column_numbers_inside_handlers
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_line_number_after_error
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_column_number_after_error
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_really_long_lines
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_end_element_events
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_attr_whitespace_normalization
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_xmldecl_misplaced
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_unknown_encoding_internal_entity
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_unread_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_no_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_standalone
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_with_external_subset
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_undeclared_entity_with_external_subset_standalone
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_wfc_no_recursive_entity_refs
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_ext_entity_set_encoding
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_dtd_default_handling
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_empty_ns_without_namespaces
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_ns_in_attribute_default_without_namespaces
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_stop_parser_between_char_data_calls
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_suspend_parser_between_char_data_calls
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_good_cdata_ascii
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_good_cdata_utf16
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_basic
argument_list|,
name|test_bad_cdata
argument_list|)
expr_stmt|;
name|suite_add_tcase
argument_list|(
name|s
argument_list|,
name|tc_namespace
argument_list|)
expr_stmt|;
name|tcase_add_checked_fixture
argument_list|(
name|tc_namespace
argument_list|,
name|namespace_setup
argument_list|,
name|namespace_teardown
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_return_ns_triplet
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_tagname_overwrite
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_tagname_overwrite_triplet
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_start_ns_clears_start_element
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_default_ns_from_ext_subset_and_ext_ge
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_prefix_with_empty_uri_1
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_prefix_with_empty_uri_2
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_prefix_with_empty_uri_3
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_prefix_with_empty_uri_4
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_default_with_empty_uri
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_duplicate_attrs_diff_prefixes
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_unbound_prefix_on_attribute
argument_list|)
expr_stmt|;
name|tcase_add_test
argument_list|(
name|tc_namespace
argument_list|,
name|test_ns_unbound_prefix_on_element
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|verbosity
init|=
name|CK_NORMAL
decl_stmt|;
name|Suite
modifier|*
name|s
init|=
name|make_suite
argument_list|()
decl_stmt|;
name|SRunner
modifier|*
name|sr
init|=
name|srunner_create
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* run the tests for internal helper functions */
name|testhelper_is_whitespace_normalized
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|opt
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--verbose"
argument_list|)
operator|==
literal|0
condition|)
name|verbosity
operator|=
name|CK_VERBOSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"-q"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
argument_list|,
literal|"--quiet"
argument_list|)
operator|==
literal|0
condition|)
name|verbosity
operator|=
name|CK_SILENT
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"runtests: unknown option '%s'\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|verbosity
operator|!=
name|CK_SILENT
condition|)
name|printf
argument_list|(
literal|"Expat version: %s\n"
argument_list|,
name|XML_ExpatVersion
argument_list|()
argument_list|)
expr_stmt|;
name|srunner_run_all
argument_list|(
name|sr
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
name|nf
operator|=
name|srunner_ntests_failed
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|srunner_free
argument_list|(
name|sr
argument_list|)
expr_stmt|;
return|return
operator|(
name|nf
operator|==
literal|0
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|EXIT_FAILURE
return|;
block|}
end_function

end_unit

