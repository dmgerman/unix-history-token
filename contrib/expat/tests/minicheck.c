begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Miniature re-implementation of the "check" library.  *  * This is intended to support just enough of check to run the Expat  * tests.  This interface is based entirely on the portion of the  * check library being used.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"minicheck.h"
end_include

begin_function
name|Suite
modifier|*
name|suite_create
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Suite
modifier|*
name|suite
init|=
operator|(
name|Suite
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Suite
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|suite
operator|!=
name|NULL
condition|)
block|{
name|suite
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
return|return
name|suite
return|;
block|}
end_function

begin_function
name|TCase
modifier|*
name|tcase_create
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|TCase
modifier|*
name|tc
init|=
operator|(
name|TCase
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TCase
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|!=
name|NULL
condition|)
block|{
name|tc
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
return|return
name|tc
return|;
block|}
end_function

begin_function
name|void
name|suite_add_tcase
parameter_list|(
name|Suite
modifier|*
name|suite
parameter_list|,
name|TCase
modifier|*
name|tc
parameter_list|)
block|{
name|assert
argument_list|(
name|suite
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tc
operator|->
name|next_tcase
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tc
operator|->
name|next_tcase
operator|=
name|suite
operator|->
name|tests
expr_stmt|;
name|suite
operator|->
name|tests
operator|=
name|tc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcase_add_checked_fixture
parameter_list|(
name|TCase
modifier|*
name|tc
parameter_list|,
name|tcase_setup_function
name|setup
parameter_list|,
name|tcase_teardown_function
name|teardown
parameter_list|)
block|{
name|assert
argument_list|(
name|tc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tc
operator|->
name|setup
operator|=
name|setup
expr_stmt|;
name|tc
operator|->
name|teardown
operator|=
name|teardown
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcase_add_test
parameter_list|(
name|TCase
modifier|*
name|tc
parameter_list|,
name|tcase_test_function
name|test
parameter_list|)
block|{
name|assert
argument_list|(
name|tc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|allocated
operator|==
name|tc
operator|->
name|ntests
condition|)
block|{
name|int
name|nalloc
init|=
name|tc
operator|->
name|allocated
operator|+
literal|100
decl_stmt|;
name|size_t
name|new_size
init|=
sizeof|sizeof
argument_list|(
name|tcase_test_function
argument_list|)
operator|*
name|nalloc
decl_stmt|;
name|tcase_test_function
modifier|*
name|new_tests
init|=
name|realloc
argument_list|(
name|tc
operator|->
name|tests
argument_list|,
name|new_size
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|new_tests
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tests
operator|!=
name|tc
operator|->
name|tests
condition|)
block|{
name|free
argument_list|(
name|tc
operator|->
name|tests
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tests
operator|=
name|new_tests
expr_stmt|;
block|}
name|tc
operator|->
name|allocated
operator|=
name|nalloc
expr_stmt|;
block|}
name|tc
operator|->
name|tests
index|[
name|tc
operator|->
name|ntests
index|]
operator|=
name|test
expr_stmt|;
name|tc
operator|->
name|ntests
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|SRunner
modifier|*
name|srunner_create
parameter_list|(
name|Suite
modifier|*
name|suite
parameter_list|)
block|{
name|SRunner
modifier|*
name|runner
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|SRunner
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|runner
operator|!=
name|NULL
condition|)
block|{
name|runner
operator|->
name|suite
operator|=
name|suite
expr_stmt|;
block|}
return|return
name|runner
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|_check_current_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_check_current_lineno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|_check_current_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_check_set_test_info
parameter_list|(
name|char
specifier|const
modifier|*
name|function
parameter_list|,
name|char
specifier|const
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|_check_current_function
operator|=
name|function
expr_stmt|;
name|_check_current_lineno
operator|=
name|lineno
expr_stmt|;
name|_check_current_filename
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_failure
parameter_list|(
name|SRunner
modifier|*
name|runner
parameter_list|,
name|int
name|verbosity
parameter_list|)
block|{
name|runner
operator|->
name|nfailures
operator|++
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|CK_VERBOSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d: %s\n"
argument_list|,
name|_check_current_filename
argument_list|,
name|_check_current_lineno
argument_list|,
name|_check_current_function
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|srunner_run_all
parameter_list|(
name|SRunner
modifier|*
name|runner
parameter_list|,
name|int
name|verbosity
parameter_list|)
block|{
name|Suite
modifier|*
name|suite
decl_stmt|;
name|TCase
modifier|*
name|tc
decl_stmt|;
name|assert
argument_list|(
name|runner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|suite
operator|=
name|runner
operator|->
name|suite
expr_stmt|;
name|tc
operator|=
name|suite
operator|->
name|tests
expr_stmt|;
while|while
condition|(
name|tc
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tc
operator|->
name|ntests
condition|;
operator|++
name|i
control|)
block|{
name|runner
operator|->
name|nchecks
operator|++
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|setup
operator|!=
name|NULL
condition|)
block|{
comment|/* setup */
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|add_failure
argument_list|(
name|runner
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tc
operator|->
name|setup
argument_list|()
expr_stmt|;
block|}
comment|/* test */
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|add_failure
argument_list|(
name|runner
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|tc
operator|->
name|tests
index|[
name|i
index|]
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* teardown */
if|if
condition|(
name|tc
operator|->
name|teardown
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|add_failure
argument_list|(
name|runner
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tc
operator|->
name|teardown
argument_list|()
expr_stmt|;
block|}
block|}
name|tc
operator|=
name|tc
operator|->
name|next_tcase
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
condition|)
block|{
name|int
name|passed
init|=
name|runner
operator|->
name|nchecks
operator|-
name|runner
operator|->
name|nfailures
decl_stmt|;
name|double
name|percentage
init|=
operator|(
operator|(
name|double
operator|)
name|passed
operator|)
operator|/
name|runner
operator|->
name|nchecks
decl_stmt|;
name|int
name|display
init|=
call|(
name|int
call|)
argument_list|(
name|percentage
operator|*
literal|100
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%d%%: Checks: %d, Failed: %d\n"
argument_list|,
name|display
argument_list|,
name|runner
operator|->
name|nchecks
argument_list|,
name|runner
operator|->
name|nfailures
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_fail_unless
parameter_list|(
name|int
name|condition
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* Always print the error message so it isn't lost.  In this case,        we have a failure, so there's no reason to be quiet about what        it is.     */
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|srunner_ntests_failed
parameter_list|(
name|SRunner
modifier|*
name|runner
parameter_list|)
block|{
name|assert
argument_list|(
name|runner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|runner
operator|->
name|nfailures
return|;
block|}
end_function

begin_function
name|void
name|srunner_free
parameter_list|(
name|SRunner
modifier|*
name|runner
parameter_list|)
block|{
name|free
argument_list|(
name|runner
operator|->
name|suite
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

