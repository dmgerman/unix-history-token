begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd    See the file COPYING for copying permission. */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset(), memcpy() */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|XML_BUILDING_EXPAT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILED_FROM_DSP
end_ifdef

begin_include
include|#
directive|include
file|"winconfig.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MACOS_CLASSIC
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"macconfig.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__amigaos4__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"amigaconfig.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"watcomconfig.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EXPAT_CONFIG_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<expat_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef COMPILED_FROM_DSP */
end_comment

begin_include
include|#
directive|include
file|"ascii.h"
end_include

begin_include
include|#
directive|include
file|"expat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XML_UNICODE
end_ifdef

begin_define
define|#
directive|define
name|XML_ENCODE_MAX
value|XML_UTF16_ENCODE_MAX
end_define

begin_define
define|#
directive|define
name|XmlConvert
value|XmlUtf16Convert
end_define

begin_define
define|#
directive|define
name|XmlGetInternalEncoding
value|XmlGetUtf16InternalEncoding
end_define

begin_define
define|#
directive|define
name|XmlGetInternalEncodingNS
value|XmlGetUtf16InternalEncodingNS
end_define

begin_define
define|#
directive|define
name|XmlEncode
value|XmlUtf16Encode
end_define

begin_comment
comment|/* Using pointer subtraction to convert to integer type. */
end_comment

begin_define
define|#
directive|define
name|MUST_CONVERT
parameter_list|(
name|enc
parameter_list|,
name|s
parameter_list|)
value|(!(enc)->isUtf16 || (((char *)(s) - (char *)NULL)& 1))
end_define

begin_typedef
typedef|typedef
name|unsigned
name|short
name|ICHAR
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_ENCODE_MAX
value|XML_UTF8_ENCODE_MAX
end_define

begin_define
define|#
directive|define
name|XmlConvert
value|XmlUtf8Convert
end_define

begin_define
define|#
directive|define
name|XmlGetInternalEncoding
value|XmlGetUtf8InternalEncoding
end_define

begin_define
define|#
directive|define
name|XmlGetInternalEncodingNS
value|XmlGetUtf8InternalEncodingNS
end_define

begin_define
define|#
directive|define
name|XmlEncode
value|XmlUtf8Encode
end_define

begin_define
define|#
directive|define
name|MUST_CONVERT
parameter_list|(
name|enc
parameter_list|,
name|s
parameter_list|)
value|(!(enc)->isUtf8)
end_define

begin_typedef
typedef|typedef
name|char
name|ICHAR
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XML_NS
end_ifndef

begin_define
define|#
directive|define
name|XmlInitEncodingNS
value|XmlInitEncoding
end_define

begin_define
define|#
directive|define
name|XmlInitUnknownEncodingNS
value|XmlInitUnknownEncoding
end_define

begin_undef
undef|#
directive|undef
name|XmlGetInternalEncodingNS
end_undef

begin_define
define|#
directive|define
name|XmlGetInternalEncodingNS
value|XmlGetInternalEncoding
end_define

begin_define
define|#
directive|define
name|XmlParseXmlDeclNS
value|XmlParseXmlDecl
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XML_UNICODE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|XML_UNICODE_WCHAR_T
end_ifdef

begin_define
define|#
directive|define
name|XML_T
parameter_list|(
name|x
parameter_list|)
value|(const wchar_t)x
end_define

begin_define
define|#
directive|define
name|XML_L
parameter_list|(
name|x
parameter_list|)
value|L ## x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_T
parameter_list|(
name|x
parameter_list|)
value|(const unsigned short)x
end_define

begin_define
define|#
directive|define
name|XML_L
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XML_T
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|XML_L
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Round up n to be a multiple of sz, where sz is a power of 2. */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|n
parameter_list|,
name|sz
parameter_list|)
value|(((n) + ((sz) - 1))& ~((sz) - 1))
end_define

begin_comment
comment|/* Handle the case where memmove() doesn't exist. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMMOVE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BCOPY
end_ifdef

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
value|bcopy((s),(d),(l))
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|memmove does not exist on this platform, nor is a substitute available
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BCOPY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MEMMOVE */
end_comment

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_include
include|#
directive|include
file|"xmltok.h"
end_include

begin_include
include|#
directive|include
file|"xmlrole.h"
end_include

begin_typedef
typedef|typedef
specifier|const
name|XML_Char
modifier|*
name|KEY
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|KEY
name|name
decl_stmt|;
block|}
name|NAMED
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|NAMED
modifier|*
modifier|*
name|v
decl_stmt|;
name|unsigned
name|char
name|power
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|used
decl_stmt|;
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|mem
decl_stmt|;
block|}
name|HASH_TABLE
typedef|;
end_typedef

begin_comment
comment|/* Basic character hash algorithm, taken from Python's string hash:    h = h * 1000003 ^ character, the constant being a prime number.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XML_UNICODE
end_ifdef

begin_define
define|#
directive|define
name|CHAR_HASH
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
define|\
value|(((h) * 0xF4243) ^ (unsigned short)(c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHAR_HASH
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
define|\
value|(((h) * 0xF4243) ^ (unsigned char)(c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For probing (after a collision) we need a step size relative prime    to the hash table size, which is a power of 2. We use double-hashing,    since we can calculate a second hash value cheaply by taking those bits    of the first hash value that were discarded (masked out) when the table    index was calculated: index = hash& mask, where mask = table->size - 1.    We limit the maximum step size to table->size / 4 (mask>> 2) and make    it odd, since odd numbers are always relative prime to a power of 2. */
end_comment

begin_define
define|#
directive|define
name|SECOND_HASH
parameter_list|(
name|hash
parameter_list|,
name|mask
parameter_list|,
name|power
parameter_list|)
define|\
value|((((hash)& ~(mask))>> ((power) - 1))& ((mask)>> 2))
end_define

begin_define
define|#
directive|define
name|PROBE_STEP
parameter_list|(
name|hash
parameter_list|,
name|mask
parameter_list|,
name|power
parameter_list|)
define|\
value|((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|NAMED
modifier|*
modifier|*
name|p
decl_stmt|;
name|NAMED
modifier|*
modifier|*
name|end
decl_stmt|;
block|}
name|HASH_TABLE_ITER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INIT_TAG_BUF_SIZE
value|32
end_define

begin_comment
comment|/* must be a multiple of sizeof(XML_Char) */
end_comment

begin_define
define|#
directive|define
name|INIT_DATA_BUF_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|INIT_ATTS_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|INIT_ATTS_VERSION
value|0xFFFFFFFF
end_define

begin_define
define|#
directive|define
name|INIT_BLOCK_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|INIT_BUFFER_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|EXPAND_SPARE
value|24
end_define

begin_typedef
typedef|typedef
struct|struct
name|binding
block|{
name|struct
name|prefix
modifier|*
name|prefix
decl_stmt|;
name|struct
name|binding
modifier|*
name|nextTagBinding
decl_stmt|;
name|struct
name|binding
modifier|*
name|prevPrefixBinding
decl_stmt|;
specifier|const
name|struct
name|attribute_id
modifier|*
name|attId
decl_stmt|;
name|XML_Char
modifier|*
name|uri
decl_stmt|;
name|int
name|uriLen
decl_stmt|;
name|int
name|uriAlloc
decl_stmt|;
block|}
name|BINDING
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|prefix
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|BINDING
modifier|*
name|binding
decl_stmt|;
block|}
name|PREFIX
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|XML_Char
modifier|*
name|str
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|localPart
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|prefix
decl_stmt|;
name|int
name|strLen
decl_stmt|;
name|int
name|uriLen
decl_stmt|;
name|int
name|prefixLen
decl_stmt|;
block|}
name|TAG_NAME
typedef|;
end_typedef

begin_comment
comment|/* TAG represents an open element.    The name of the element is stored in both the document and API    encodings.  The memory buffer 'buf' is a separately-allocated    memory area which stores the name.  During the XML_Parse()/    XMLParseBuffer() when the element is open, the memory for the 'raw'    version of the name (in the document encoding) is shared with the    document buffer.  If the element is open across calls to    XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to    contain the 'raw' name as well.     A parser re-uses these structures, maintaining a list of allocated    TAG objects in a free list. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tag
block|{
name|struct
name|tag
modifier|*
name|parent
decl_stmt|;
comment|/* parent of this element */
specifier|const
name|char
modifier|*
name|rawName
decl_stmt|;
comment|/* tagName in the original encoding */
name|int
name|rawNameLength
decl_stmt|;
name|TAG_NAME
name|name
decl_stmt|;
comment|/* tagName in the API encoding */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer for name components */
name|char
modifier|*
name|bufEnd
decl_stmt|;
comment|/* end of the buffer */
name|BINDING
modifier|*
name|bindings
decl_stmt|;
block|}
name|TAG
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|textPtr
decl_stmt|;
name|int
name|textLen
decl_stmt|;
comment|/* length in XML_Chars */
name|int
name|processed
decl_stmt|;
comment|/* # of processed bytes - when suspended */
specifier|const
name|XML_Char
modifier|*
name|systemId
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|base
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|publicId
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|notation
decl_stmt|;
name|XML_Bool
name|open
decl_stmt|;
name|XML_Bool
name|is_param
decl_stmt|;
name|XML_Bool
name|is_internal
decl_stmt|;
comment|/* true if declared in internal subset outside PE */
block|}
name|ENTITY
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|XML_Content_Type
name|type
decl_stmt|;
name|enum
name|XML_Content_Quant
name|quant
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|int
name|firstchild
decl_stmt|;
name|int
name|lastchild
decl_stmt|;
name|int
name|childcnt
decl_stmt|;
name|int
name|nextsib
decl_stmt|;
block|}
name|CONTENT_SCAFFOLD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INIT_SCAFFOLD_ELEMENTS
value|32
end_define

begin_typedef
typedef|typedef
struct|struct
name|block
block|{
name|struct
name|block
modifier|*
name|next
decl_stmt|;
name|int
name|size
decl_stmt|;
name|XML_Char
name|s
index|[
literal|1
index|]
decl_stmt|;
block|}
name|BLOCK
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BLOCK
modifier|*
name|blocks
decl_stmt|;
name|BLOCK
modifier|*
name|freeBlocks
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|end
decl_stmt|;
name|XML_Char
modifier|*
name|ptr
decl_stmt|;
name|XML_Char
modifier|*
name|start
decl_stmt|;
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|mem
decl_stmt|;
block|}
name|STRING_POOL
typedef|;
end_typedef

begin_comment
comment|/* The XML_Char before the name is used to determine whether    an attribute has been specified. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|attribute_id
block|{
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|PREFIX
modifier|*
name|prefix
decl_stmt|;
name|XML_Bool
name|maybeTokenized
decl_stmt|;
name|XML_Bool
name|xmlns
decl_stmt|;
block|}
name|ATTRIBUTE_ID
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|ATTRIBUTE_ID
modifier|*
name|id
decl_stmt|;
name|XML_Bool
name|isCdata
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|value
decl_stmt|;
block|}
name|DEFAULT_ATTRIBUTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|version
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|uriName
decl_stmt|;
block|}
name|NS_ATT
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|PREFIX
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|ATTRIBUTE_ID
modifier|*
name|idAtt
decl_stmt|;
name|int
name|nDefaultAtts
decl_stmt|;
name|int
name|allocDefaultAtts
decl_stmt|;
name|DEFAULT_ATTRIBUTE
modifier|*
name|defaultAtts
decl_stmt|;
block|}
name|ELEMENT_TYPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|HASH_TABLE
name|generalEntities
decl_stmt|;
name|HASH_TABLE
name|elementTypes
decl_stmt|;
name|HASH_TABLE
name|attributeIds
decl_stmt|;
name|HASH_TABLE
name|prefixes
decl_stmt|;
name|STRING_POOL
name|pool
decl_stmt|;
name|STRING_POOL
name|entityValuePool
decl_stmt|;
comment|/* false once a parameter entity reference has been skipped */
name|XML_Bool
name|keepProcessing
decl_stmt|;
comment|/* true once an internal or external PE reference has been encountered;      this includes the reference to an external subset */
name|XML_Bool
name|hasParamEntityRefs
decl_stmt|;
name|XML_Bool
name|standalone
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
comment|/* indicates if external PE has been read */
name|XML_Bool
name|paramEntityRead
decl_stmt|;
name|HASH_TABLE
name|paramEntities
decl_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|PREFIX
name|defaultPrefix
decl_stmt|;
comment|/* === scaffolding for building content model === */
name|XML_Bool
name|in_eldecl
decl_stmt|;
name|CONTENT_SCAFFOLD
modifier|*
name|scaffold
decl_stmt|;
name|unsigned
name|contentStringLen
decl_stmt|;
name|unsigned
name|scaffSize
decl_stmt|;
name|unsigned
name|scaffCount
decl_stmt|;
name|int
name|scaffLevel
decl_stmt|;
name|int
modifier|*
name|scaffIndex
decl_stmt|;
block|}
name|DTD
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|open_internal_entity
block|{
specifier|const
name|char
modifier|*
name|internalEventPtr
decl_stmt|;
specifier|const
name|char
modifier|*
name|internalEventEndPtr
decl_stmt|;
name|struct
name|open_internal_entity
modifier|*
name|next
decl_stmt|;
name|ENTITY
modifier|*
name|entity
decl_stmt|;
name|int
name|startTagLevel
decl_stmt|;
name|XML_Bool
name|betweenDecl
decl_stmt|;
comment|/* WFC: PE Between Declarations */
block|}
name|OPEN_INTERNAL_ENTITY
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|enum
name|XML_Error
name|PTRCALL
name|Processor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|Processor
name|prologProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|prologInitProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|contentProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|cdataSectionProcessor
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_decl_stmt
specifier|static
name|Processor
name|ignoreSectionProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalParEntProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalParEntInitProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|entityValueProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|entityValueInitProcessor
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_decl_stmt
specifier|static
name|Processor
name|epilogProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|errorProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalEntityInitProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalEntityInitProcessor2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalEntityInitProcessor3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|externalEntityContentProcessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Processor
name|internalEntityProcessor
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|handleUnknownEncoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|processXmlDecl
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|isGeneralTextEntity
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|initializeEncoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|doProlog
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
name|tok
parameter_list|,
specifier|const
name|char
modifier|*
name|next
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|processInternalEntity
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|ENTITY
modifier|*
name|entity
parameter_list|,
name|XML_Bool
name|betweenDecl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|doContent
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|startTagLevel
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|doCdataSection
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|startPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|doIgnoreSection
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|startPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|storeAtts
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|TAG_NAME
modifier|*
name|tagNamePtr
parameter_list|,
name|BINDING
modifier|*
modifier|*
name|bindingsPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|addBinding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|PREFIX
modifier|*
name|prefix
parameter_list|,
specifier|const
name|ATTRIBUTE_ID
modifier|*
name|attId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|uri
parameter_list|,
name|BINDING
modifier|*
modifier|*
name|bindingsPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|defineAttribute
parameter_list|(
name|ELEMENT_TYPE
modifier|*
name|type
parameter_list|,
name|ATTRIBUTE_ID
modifier|*
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
name|XML_Bool
name|isId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|dfltValue
parameter_list|,
name|XML_Parser
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|storeAttributeValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|STRING_POOL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|appendAttributeValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|STRING_POOL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ATTRIBUTE_ID
modifier|*
name|getAttributeId
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setElementTypePrefix
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|ELEMENT_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|XML_Error
name|storeEntityValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reportProcessingInstruction
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reportComment
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reportDefault
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|XML_Char
modifier|*
name|getContext
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Bool
name|setContext
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|normalizePublicId
parameter_list|(
name|XML_Char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DTD
modifier|*
name|dtdCreate
parameter_list|(
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* do not call if parentParser != NULL */
end_comment

begin_function_decl
specifier|static
name|void
name|dtdReset
parameter_list|(
name|DTD
modifier|*
name|p
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtdDestroy
parameter_list|(
name|DTD
modifier|*
name|p
parameter_list|,
name|XML_Bool
name|isDocEntity
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtdCopy
parameter_list|(
name|DTD
modifier|*
name|newDtd
parameter_list|,
specifier|const
name|DTD
modifier|*
name|oldDtd
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copyEntityTable
parameter_list|(
name|HASH_TABLE
modifier|*
parameter_list|,
name|STRING_POOL
modifier|*
parameter_list|,
specifier|const
name|HASH_TABLE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|NAMED
modifier|*
name|lookup
parameter_list|(
name|HASH_TABLE
modifier|*
name|table
parameter_list|,
name|KEY
name|name
parameter_list|,
name|size_t
name|createSize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|hashTableInit
parameter_list|(
name|HASH_TABLE
modifier|*
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|hashTableClear
parameter_list|(
name|HASH_TABLE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|hashTableDestroy
parameter_list|(
name|HASH_TABLE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|hashTableIterInit
parameter_list|(
name|HASH_TABLE_ITER
modifier|*
parameter_list|,
specifier|const
name|HASH_TABLE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|NAMED
modifier|*
name|FASTCALL
name|hashTableIterNext
parameter_list|(
name|HASH_TABLE_ITER
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|poolInit
parameter_list|(
name|STRING_POOL
modifier|*
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|poolClear
parameter_list|(
name|STRING_POOL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FASTCALL
name|poolDestroy
parameter_list|(
name|STRING_POOL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Char
modifier|*
name|poolAppend
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Char
modifier|*
name|poolStoreString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Bool
name|FASTCALL
name|poolGrow
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|XML_Char
modifier|*
name|FASTCALL
name|poolCopyString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|XML_Char
modifier|*
name|poolCopyStringN
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|XML_Char
modifier|*
name|FASTCALL
name|poolAppendString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|FASTCALL
name|nextScaffoldPart
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Content
modifier|*
name|build_model
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ELEMENT_TYPE
modifier|*
name|getElementType
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XML_Parser
name|parserCreate
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|memsuite
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|nameSep
parameter_list|,
name|DTD
modifier|*
name|dtd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parserInit
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|poolStart
parameter_list|(
name|pool
parameter_list|)
value|((pool)->start)
end_define

begin_define
define|#
directive|define
name|poolEnd
parameter_list|(
name|pool
parameter_list|)
value|((pool)->ptr)
end_define

begin_define
define|#
directive|define
name|poolLength
parameter_list|(
name|pool
parameter_list|)
value|((pool)->ptr - (pool)->start)
end_define

begin_define
define|#
directive|define
name|poolChop
parameter_list|(
name|pool
parameter_list|)
value|((void)--(pool->ptr))
end_define

begin_define
define|#
directive|define
name|poolLastChar
parameter_list|(
name|pool
parameter_list|)
value|(((pool)->ptr)[-1])
end_define

begin_define
define|#
directive|define
name|poolDiscard
parameter_list|(
name|pool
parameter_list|)
value|((pool)->ptr = (pool)->start)
end_define

begin_define
define|#
directive|define
name|poolFinish
parameter_list|(
name|pool
parameter_list|)
value|((pool)->start = (pool)->ptr)
end_define

begin_define
define|#
directive|define
name|poolAppendChar
parameter_list|(
name|pool
parameter_list|,
name|c
parameter_list|)
define|\
value|(((pool)->ptr == (pool)->end&& !poolGrow(pool)) \    ? 0 \    : ((*((pool)->ptr)++ = c), 1))
end_define

begin_struct
struct|struct
name|XML_ParserStruct
block|{
comment|/* The first member must be userData so that the XML_GetUserData      macro works. */
name|void
modifier|*
name|m_userData
decl_stmt|;
name|void
modifier|*
name|m_handlerArg
decl_stmt|;
name|char
modifier|*
name|m_buffer
decl_stmt|;
specifier|const
name|XML_Memory_Handling_Suite
name|m_mem
decl_stmt|;
comment|/* first character to be parsed */
specifier|const
name|char
modifier|*
name|m_bufferPtr
decl_stmt|;
comment|/* past last character to be parsed */
name|char
modifier|*
name|m_bufferEnd
decl_stmt|;
comment|/* allocated end of buffer */
specifier|const
name|char
modifier|*
name|m_bufferLim
decl_stmt|;
name|XML_Index
name|m_parseEndByteIndex
decl_stmt|;
specifier|const
name|char
modifier|*
name|m_parseEndPtr
decl_stmt|;
name|XML_Char
modifier|*
name|m_dataBuf
decl_stmt|;
name|XML_Char
modifier|*
name|m_dataBufEnd
decl_stmt|;
name|XML_StartElementHandler
name|m_startElementHandler
decl_stmt|;
name|XML_EndElementHandler
name|m_endElementHandler
decl_stmt|;
name|XML_CharacterDataHandler
name|m_characterDataHandler
decl_stmt|;
name|XML_ProcessingInstructionHandler
name|m_processingInstructionHandler
decl_stmt|;
name|XML_CommentHandler
name|m_commentHandler
decl_stmt|;
name|XML_StartCdataSectionHandler
name|m_startCdataSectionHandler
decl_stmt|;
name|XML_EndCdataSectionHandler
name|m_endCdataSectionHandler
decl_stmt|;
name|XML_DefaultHandler
name|m_defaultHandler
decl_stmt|;
name|XML_StartDoctypeDeclHandler
name|m_startDoctypeDeclHandler
decl_stmt|;
name|XML_EndDoctypeDeclHandler
name|m_endDoctypeDeclHandler
decl_stmt|;
name|XML_UnparsedEntityDeclHandler
name|m_unparsedEntityDeclHandler
decl_stmt|;
name|XML_NotationDeclHandler
name|m_notationDeclHandler
decl_stmt|;
name|XML_StartNamespaceDeclHandler
name|m_startNamespaceDeclHandler
decl_stmt|;
name|XML_EndNamespaceDeclHandler
name|m_endNamespaceDeclHandler
decl_stmt|;
name|XML_NotStandaloneHandler
name|m_notStandaloneHandler
decl_stmt|;
name|XML_ExternalEntityRefHandler
name|m_externalEntityRefHandler
decl_stmt|;
name|XML_Parser
name|m_externalEntityRefHandlerArg
decl_stmt|;
name|XML_SkippedEntityHandler
name|m_skippedEntityHandler
decl_stmt|;
name|XML_UnknownEncodingHandler
name|m_unknownEncodingHandler
decl_stmt|;
name|XML_ElementDeclHandler
name|m_elementDeclHandler
decl_stmt|;
name|XML_AttlistDeclHandler
name|m_attlistDeclHandler
decl_stmt|;
name|XML_EntityDeclHandler
name|m_entityDeclHandler
decl_stmt|;
name|XML_XmlDeclHandler
name|m_xmlDeclHandler
decl_stmt|;
specifier|const
name|ENCODING
modifier|*
name|m_encoding
decl_stmt|;
name|INIT_ENCODING
name|m_initEncoding
decl_stmt|;
specifier|const
name|ENCODING
modifier|*
name|m_internalEncoding
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_protocolEncodingName
decl_stmt|;
name|XML_Bool
name|m_ns
decl_stmt|;
name|XML_Bool
name|m_ns_triplets
decl_stmt|;
name|void
modifier|*
name|m_unknownEncodingMem
decl_stmt|;
name|void
modifier|*
name|m_unknownEncodingData
decl_stmt|;
name|void
modifier|*
name|m_unknownEncodingHandlerData
decl_stmt|;
name|void
function_decl|(
name|XMLCALL
modifier|*
name|m_unknownEncodingRelease
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|PROLOG_STATE
name|m_prologState
decl_stmt|;
name|Processor
modifier|*
name|m_processor
decl_stmt|;
name|enum
name|XML_Error
name|m_errorCode
decl_stmt|;
specifier|const
name|char
modifier|*
name|m_eventPtr
decl_stmt|;
specifier|const
name|char
modifier|*
name|m_eventEndPtr
decl_stmt|;
specifier|const
name|char
modifier|*
name|m_positionPtr
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|m_openInternalEntities
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|m_freeInternalEntities
decl_stmt|;
name|XML_Bool
name|m_defaultExpandInternalEntities
decl_stmt|;
name|int
name|m_tagLevel
decl_stmt|;
name|ENTITY
modifier|*
name|m_declEntity
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_doctypeName
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_doctypeSysid
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_doctypePubid
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_declAttributeType
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_declNotationName
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_declNotationPublicId
decl_stmt|;
name|ELEMENT_TYPE
modifier|*
name|m_declElementType
decl_stmt|;
name|ATTRIBUTE_ID
modifier|*
name|m_declAttributeId
decl_stmt|;
name|XML_Bool
name|m_declAttributeIsCdata
decl_stmt|;
name|XML_Bool
name|m_declAttributeIsId
decl_stmt|;
name|DTD
modifier|*
name|m_dtd
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|m_curBase
decl_stmt|;
name|TAG
modifier|*
name|m_tagStack
decl_stmt|;
name|TAG
modifier|*
name|m_freeTagList
decl_stmt|;
name|BINDING
modifier|*
name|m_inheritedBindings
decl_stmt|;
name|BINDING
modifier|*
name|m_freeBindingList
decl_stmt|;
name|int
name|m_attsSize
decl_stmt|;
name|int
name|m_nSpecifiedAtts
decl_stmt|;
name|int
name|m_idAttIndex
decl_stmt|;
name|ATTRIBUTE
modifier|*
name|m_atts
decl_stmt|;
name|NS_ATT
modifier|*
name|m_nsAtts
decl_stmt|;
name|unsigned
name|long
name|m_nsAttsVersion
decl_stmt|;
name|unsigned
name|char
name|m_nsAttsPower
decl_stmt|;
name|POSITION
name|m_position
decl_stmt|;
name|STRING_POOL
name|m_tempPool
decl_stmt|;
name|STRING_POOL
name|m_temp2Pool
decl_stmt|;
name|char
modifier|*
name|m_groupConnector
decl_stmt|;
name|unsigned
name|int
name|m_groupSize
decl_stmt|;
name|XML_Char
name|m_namespaceSeparator
decl_stmt|;
name|XML_Parser
name|m_parentParser
decl_stmt|;
name|XML_ParsingStatus
name|m_parsingStatus
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|XML_Bool
name|m_isParamEntity
decl_stmt|;
name|XML_Bool
name|m_useForeignDTD
decl_stmt|;
name|enum
name|XML_ParamEntityParsing
name|m_paramEntityParsing
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MALLOC
parameter_list|(
name|s
parameter_list|)
value|(parser->m_mem.malloc_fcn((s)))
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(parser->m_mem.realloc_fcn((p),(s)))
end_define

begin_define
define|#
directive|define
name|FREE
parameter_list|(
name|p
parameter_list|)
value|(parser->m_mem.free_fcn((p)))
end_define

begin_define
define|#
directive|define
name|userData
value|(parser->m_userData)
end_define

begin_define
define|#
directive|define
name|handlerArg
value|(parser->m_handlerArg)
end_define

begin_define
define|#
directive|define
name|startElementHandler
value|(parser->m_startElementHandler)
end_define

begin_define
define|#
directive|define
name|endElementHandler
value|(parser->m_endElementHandler)
end_define

begin_define
define|#
directive|define
name|characterDataHandler
value|(parser->m_characterDataHandler)
end_define

begin_define
define|#
directive|define
name|processingInstructionHandler
define|\
value|(parser->m_processingInstructionHandler)
end_define

begin_define
define|#
directive|define
name|commentHandler
value|(parser->m_commentHandler)
end_define

begin_define
define|#
directive|define
name|startCdataSectionHandler
define|\
value|(parser->m_startCdataSectionHandler)
end_define

begin_define
define|#
directive|define
name|endCdataSectionHandler
value|(parser->m_endCdataSectionHandler)
end_define

begin_define
define|#
directive|define
name|defaultHandler
value|(parser->m_defaultHandler)
end_define

begin_define
define|#
directive|define
name|startDoctypeDeclHandler
value|(parser->m_startDoctypeDeclHandler)
end_define

begin_define
define|#
directive|define
name|endDoctypeDeclHandler
value|(parser->m_endDoctypeDeclHandler)
end_define

begin_define
define|#
directive|define
name|unparsedEntityDeclHandler
define|\
value|(parser->m_unparsedEntityDeclHandler)
end_define

begin_define
define|#
directive|define
name|notationDeclHandler
value|(parser->m_notationDeclHandler)
end_define

begin_define
define|#
directive|define
name|startNamespaceDeclHandler
define|\
value|(parser->m_startNamespaceDeclHandler)
end_define

begin_define
define|#
directive|define
name|endNamespaceDeclHandler
value|(parser->m_endNamespaceDeclHandler)
end_define

begin_define
define|#
directive|define
name|notStandaloneHandler
value|(parser->m_notStandaloneHandler)
end_define

begin_define
define|#
directive|define
name|externalEntityRefHandler
define|\
value|(parser->m_externalEntityRefHandler)
end_define

begin_define
define|#
directive|define
name|externalEntityRefHandlerArg
define|\
value|(parser->m_externalEntityRefHandlerArg)
end_define

begin_define
define|#
directive|define
name|internalEntityRefHandler
define|\
value|(parser->m_internalEntityRefHandler)
end_define

begin_define
define|#
directive|define
name|skippedEntityHandler
value|(parser->m_skippedEntityHandler)
end_define

begin_define
define|#
directive|define
name|unknownEncodingHandler
value|(parser->m_unknownEncodingHandler)
end_define

begin_define
define|#
directive|define
name|elementDeclHandler
value|(parser->m_elementDeclHandler)
end_define

begin_define
define|#
directive|define
name|attlistDeclHandler
value|(parser->m_attlistDeclHandler)
end_define

begin_define
define|#
directive|define
name|entityDeclHandler
value|(parser->m_entityDeclHandler)
end_define

begin_define
define|#
directive|define
name|xmlDeclHandler
value|(parser->m_xmlDeclHandler)
end_define

begin_define
define|#
directive|define
name|encoding
value|(parser->m_encoding)
end_define

begin_define
define|#
directive|define
name|initEncoding
value|(parser->m_initEncoding)
end_define

begin_define
define|#
directive|define
name|internalEncoding
value|(parser->m_internalEncoding)
end_define

begin_define
define|#
directive|define
name|unknownEncodingMem
value|(parser->m_unknownEncodingMem)
end_define

begin_define
define|#
directive|define
name|unknownEncodingData
value|(parser->m_unknownEncodingData)
end_define

begin_define
define|#
directive|define
name|unknownEncodingHandlerData
define|\
value|(parser->m_unknownEncodingHandlerData)
end_define

begin_define
define|#
directive|define
name|unknownEncodingRelease
value|(parser->m_unknownEncodingRelease)
end_define

begin_define
define|#
directive|define
name|protocolEncodingName
value|(parser->m_protocolEncodingName)
end_define

begin_define
define|#
directive|define
name|ns
value|(parser->m_ns)
end_define

begin_define
define|#
directive|define
name|ns_triplets
value|(parser->m_ns_triplets)
end_define

begin_define
define|#
directive|define
name|prologState
value|(parser->m_prologState)
end_define

begin_define
define|#
directive|define
name|processor
value|(parser->m_processor)
end_define

begin_define
define|#
directive|define
name|errorCode
value|(parser->m_errorCode)
end_define

begin_define
define|#
directive|define
name|eventPtr
value|(parser->m_eventPtr)
end_define

begin_define
define|#
directive|define
name|eventEndPtr
value|(parser->m_eventEndPtr)
end_define

begin_define
define|#
directive|define
name|positionPtr
value|(parser->m_positionPtr)
end_define

begin_define
define|#
directive|define
name|position
value|(parser->m_position)
end_define

begin_define
define|#
directive|define
name|openInternalEntities
value|(parser->m_openInternalEntities)
end_define

begin_define
define|#
directive|define
name|freeInternalEntities
value|(parser->m_freeInternalEntities)
end_define

begin_define
define|#
directive|define
name|defaultExpandInternalEntities
define|\
value|(parser->m_defaultExpandInternalEntities)
end_define

begin_define
define|#
directive|define
name|tagLevel
value|(parser->m_tagLevel)
end_define

begin_define
define|#
directive|define
name|buffer
value|(parser->m_buffer)
end_define

begin_define
define|#
directive|define
name|bufferPtr
value|(parser->m_bufferPtr)
end_define

begin_define
define|#
directive|define
name|bufferEnd
value|(parser->m_bufferEnd)
end_define

begin_define
define|#
directive|define
name|parseEndByteIndex
value|(parser->m_parseEndByteIndex)
end_define

begin_define
define|#
directive|define
name|parseEndPtr
value|(parser->m_parseEndPtr)
end_define

begin_define
define|#
directive|define
name|bufferLim
value|(parser->m_bufferLim)
end_define

begin_define
define|#
directive|define
name|dataBuf
value|(parser->m_dataBuf)
end_define

begin_define
define|#
directive|define
name|dataBufEnd
value|(parser->m_dataBufEnd)
end_define

begin_define
define|#
directive|define
name|_dtd
value|(parser->m_dtd)
end_define

begin_define
define|#
directive|define
name|curBase
value|(parser->m_curBase)
end_define

begin_define
define|#
directive|define
name|declEntity
value|(parser->m_declEntity)
end_define

begin_define
define|#
directive|define
name|doctypeName
value|(parser->m_doctypeName)
end_define

begin_define
define|#
directive|define
name|doctypeSysid
value|(parser->m_doctypeSysid)
end_define

begin_define
define|#
directive|define
name|doctypePubid
value|(parser->m_doctypePubid)
end_define

begin_define
define|#
directive|define
name|declAttributeType
value|(parser->m_declAttributeType)
end_define

begin_define
define|#
directive|define
name|declNotationName
value|(parser->m_declNotationName)
end_define

begin_define
define|#
directive|define
name|declNotationPublicId
value|(parser->m_declNotationPublicId)
end_define

begin_define
define|#
directive|define
name|declElementType
value|(parser->m_declElementType)
end_define

begin_define
define|#
directive|define
name|declAttributeId
value|(parser->m_declAttributeId)
end_define

begin_define
define|#
directive|define
name|declAttributeIsCdata
value|(parser->m_declAttributeIsCdata)
end_define

begin_define
define|#
directive|define
name|declAttributeIsId
value|(parser->m_declAttributeIsId)
end_define

begin_define
define|#
directive|define
name|freeTagList
value|(parser->m_freeTagList)
end_define

begin_define
define|#
directive|define
name|freeBindingList
value|(parser->m_freeBindingList)
end_define

begin_define
define|#
directive|define
name|inheritedBindings
value|(parser->m_inheritedBindings)
end_define

begin_define
define|#
directive|define
name|tagStack
value|(parser->m_tagStack)
end_define

begin_define
define|#
directive|define
name|atts
value|(parser->m_atts)
end_define

begin_define
define|#
directive|define
name|attsSize
value|(parser->m_attsSize)
end_define

begin_define
define|#
directive|define
name|nSpecifiedAtts
value|(parser->m_nSpecifiedAtts)
end_define

begin_define
define|#
directive|define
name|idAttIndex
value|(parser->m_idAttIndex)
end_define

begin_define
define|#
directive|define
name|nsAtts
value|(parser->m_nsAtts)
end_define

begin_define
define|#
directive|define
name|nsAttsVersion
value|(parser->m_nsAttsVersion)
end_define

begin_define
define|#
directive|define
name|nsAttsPower
value|(parser->m_nsAttsPower)
end_define

begin_define
define|#
directive|define
name|tempPool
value|(parser->m_tempPool)
end_define

begin_define
define|#
directive|define
name|temp2Pool
value|(parser->m_temp2Pool)
end_define

begin_define
define|#
directive|define
name|groupConnector
value|(parser->m_groupConnector)
end_define

begin_define
define|#
directive|define
name|groupSize
value|(parser->m_groupSize)
end_define

begin_define
define|#
directive|define
name|namespaceSeparator
value|(parser->m_namespaceSeparator)
end_define

begin_define
define|#
directive|define
name|parentParser
value|(parser->m_parentParser)
end_define

begin_define
define|#
directive|define
name|ps_parsing
value|(parser->m_parsingStatus.parsing)
end_define

begin_define
define|#
directive|define
name|ps_finalBuffer
value|(parser->m_parsingStatus.finalBuffer)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_define
define|#
directive|define
name|isParamEntity
value|(parser->m_isParamEntity)
end_define

begin_define
define|#
directive|define
name|useForeignDTD
value|(parser->m_useForeignDTD)
end_define

begin_define
define|#
directive|define
name|paramEntityParsing
value|(parser->m_paramEntityParsing)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_function
name|XML_Parser
name|XMLCALL
name|XML_ParserCreate
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
return|return
name|XML_ParserCreate_MM
argument_list|(
name|encodingName
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|XML_Parser
name|XMLCALL
name|XML_ParserCreateNS
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|,
name|XML_Char
name|nsSep
parameter_list|)
block|{
name|XML_Char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|tmp
operator|=
name|nsSep
expr_stmt|;
return|return
name|XML_ParserCreate_MM
argument_list|(
name|encodingName
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|XML_Char
name|implicitContext
index|[]
init|=
block|{
name|ASCII_x
block|,
name|ASCII_m
block|,
name|ASCII_l
block|,
name|ASCII_EQUALS
block|,
name|ASCII_h
block|,
name|ASCII_t
block|,
name|ASCII_t
block|,
name|ASCII_p
block|,
name|ASCII_COLON
block|,
name|ASCII_SLASH
block|,
name|ASCII_SLASH
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_PERIOD
block|,
name|ASCII_w
block|,
name|ASCII_3
block|,
name|ASCII_PERIOD
block|,
name|ASCII_o
block|,
name|ASCII_r
block|,
name|ASCII_g
block|,
name|ASCII_SLASH
block|,
name|ASCII_X
block|,
name|ASCII_M
block|,
name|ASCII_L
block|,
name|ASCII_SLASH
block|,
name|ASCII_1
block|,
name|ASCII_9
block|,
name|ASCII_9
block|,
name|ASCII_8
block|,
name|ASCII_SLASH
block|,
name|ASCII_n
block|,
name|ASCII_a
block|,
name|ASCII_m
block|,
name|ASCII_e
block|,
name|ASCII_s
block|,
name|ASCII_p
block|,
name|ASCII_a
block|,
name|ASCII_c
block|,
name|ASCII_e
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|XML_Parser
name|XMLCALL
name|XML_ParserCreate_MM
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|memsuite
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|nameSep
parameter_list|)
block|{
name|XML_Parser
name|parser
init|=
name|parserCreate
argument_list|(
name|encodingName
argument_list|,
name|memsuite
argument_list|,
name|nameSep
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|!=
name|NULL
operator|&&
name|ns
condition|)
block|{
comment|/* implicit context only set for root parser, since child        parsers (i.e. external entity parsers) will inherit it     */
if|if
condition|(
operator|!
name|setContext
argument_list|(
name|parser
argument_list|,
name|implicitContext
argument_list|)
condition|)
block|{
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|parser
return|;
block|}
end_function

begin_function
specifier|static
name|XML_Parser
name|parserCreate
parameter_list|(
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|memsuite
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|nameSep
parameter_list|,
name|DTD
modifier|*
name|dtd
parameter_list|)
block|{
name|XML_Parser
name|parser
decl_stmt|;
if|if
condition|(
name|memsuite
condition|)
block|{
name|XML_Memory_Handling_Suite
modifier|*
name|mtemp
decl_stmt|;
name|parser
operator|=
operator|(
name|XML_Parser
operator|)
name|memsuite
operator|->
name|malloc_fcn
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|XML_ParserStruct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|!=
name|NULL
condition|)
block|{
name|mtemp
operator|=
operator|(
name|XML_Memory_Handling_Suite
operator|*
operator|)
operator|&
operator|(
name|parser
operator|->
name|m_mem
operator|)
expr_stmt|;
name|mtemp
operator|->
name|malloc_fcn
operator|=
name|memsuite
operator|->
name|malloc_fcn
expr_stmt|;
name|mtemp
operator|->
name|realloc_fcn
operator|=
name|memsuite
operator|->
name|realloc_fcn
expr_stmt|;
name|mtemp
operator|->
name|free_fcn
operator|=
name|memsuite
operator|->
name|free_fcn
expr_stmt|;
block|}
block|}
else|else
block|{
name|XML_Memory_Handling_Suite
modifier|*
name|mtemp
decl_stmt|;
name|parser
operator|=
operator|(
name|XML_Parser
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|XML_ParserStruct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|!=
name|NULL
condition|)
block|{
name|mtemp
operator|=
operator|(
name|XML_Memory_Handling_Suite
operator|*
operator|)
operator|&
operator|(
name|parser
operator|->
name|m_mem
operator|)
expr_stmt|;
name|mtemp
operator|->
name|malloc_fcn
operator|=
name|malloc
expr_stmt|;
name|mtemp
operator|->
name|realloc_fcn
operator|=
name|realloc
expr_stmt|;
name|mtemp
operator|->
name|free_fcn
operator|=
name|free
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|parser
condition|)
return|return
name|parser
return|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|bufferLim
operator|=
name|NULL
expr_stmt|;
name|attsSize
operator|=
name|INIT_ATTS_SIZE
expr_stmt|;
name|atts
operator|=
operator|(
name|ATTRIBUTE
operator|*
operator|)
name|MALLOC
argument_list|(
name|attsSize
operator|*
sizeof|sizeof
argument_list|(
name|ATTRIBUTE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atts
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dataBuf
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|MALLOC
argument_list|(
name|INIT_DATA_BUF_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataBuf
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|atts
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dataBufEnd
operator|=
name|dataBuf
operator|+
name|INIT_DATA_BUF_SIZE
expr_stmt|;
if|if
condition|(
name|dtd
condition|)
name|_dtd
operator|=
name|dtd
expr_stmt|;
else|else
block|{
name|_dtd
operator|=
name|dtdCreate
argument_list|(
operator|&
name|parser
operator|->
name|m_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|_dtd
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|dataBuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|atts
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|freeBindingList
operator|=
name|NULL
expr_stmt|;
name|freeTagList
operator|=
name|NULL
expr_stmt|;
name|freeInternalEntities
operator|=
name|NULL
expr_stmt|;
name|groupSize
operator|=
literal|0
expr_stmt|;
name|groupConnector
operator|=
name|NULL
expr_stmt|;
name|unknownEncodingHandler
operator|=
name|NULL
expr_stmt|;
name|unknownEncodingHandlerData
operator|=
name|NULL
expr_stmt|;
name|namespaceSeparator
operator|=
name|ASCII_EXCL
expr_stmt|;
name|ns
operator|=
name|XML_FALSE
expr_stmt|;
name|ns_triplets
operator|=
name|XML_FALSE
expr_stmt|;
name|nsAtts
operator|=
name|NULL
expr_stmt|;
name|nsAttsVersion
operator|=
literal|0
expr_stmt|;
name|nsAttsPower
operator|=
literal|0
expr_stmt|;
name|poolInit
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|&
operator|(
name|parser
operator|->
name|m_mem
operator|)
argument_list|)
expr_stmt|;
name|poolInit
argument_list|(
operator|&
name|temp2Pool
argument_list|,
operator|&
operator|(
name|parser
operator|->
name|m_mem
operator|)
argument_list|)
expr_stmt|;
name|parserInit
argument_list|(
name|parser
argument_list|,
name|encodingName
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodingName
operator|&&
operator|!
name|protocolEncodingName
condition|)
block|{
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|nameSep
condition|)
block|{
name|ns
operator|=
name|XML_TRUE
expr_stmt|;
name|internalEncoding
operator|=
name|XmlGetInternalEncodingNS
argument_list|()
expr_stmt|;
name|namespaceSeparator
operator|=
operator|*
name|nameSep
expr_stmt|;
block|}
else|else
block|{
name|internalEncoding
operator|=
name|XmlGetInternalEncoding
argument_list|()
expr_stmt|;
block|}
return|return
name|parser
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parserInit
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
name|processor
operator|=
name|prologInitProcessor
expr_stmt|;
name|XmlPrologStateInit
argument_list|(
operator|&
name|prologState
argument_list|)
expr_stmt|;
name|protocolEncodingName
operator|=
operator|(
name|encodingName
operator|!=
name|NULL
condition|?
name|poolCopyString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|encodingName
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
name|curBase
operator|=
name|NULL
expr_stmt|;
name|XmlInitEncoding
argument_list|(
operator|&
name|initEncoding
argument_list|,
operator|&
name|encoding
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|userData
operator|=
name|NULL
expr_stmt|;
name|handlerArg
operator|=
name|NULL
expr_stmt|;
name|startElementHandler
operator|=
name|NULL
expr_stmt|;
name|endElementHandler
operator|=
name|NULL
expr_stmt|;
name|characterDataHandler
operator|=
name|NULL
expr_stmt|;
name|processingInstructionHandler
operator|=
name|NULL
expr_stmt|;
name|commentHandler
operator|=
name|NULL
expr_stmt|;
name|startCdataSectionHandler
operator|=
name|NULL
expr_stmt|;
name|endCdataSectionHandler
operator|=
name|NULL
expr_stmt|;
name|defaultHandler
operator|=
name|NULL
expr_stmt|;
name|startDoctypeDeclHandler
operator|=
name|NULL
expr_stmt|;
name|endDoctypeDeclHandler
operator|=
name|NULL
expr_stmt|;
name|unparsedEntityDeclHandler
operator|=
name|NULL
expr_stmt|;
name|notationDeclHandler
operator|=
name|NULL
expr_stmt|;
name|startNamespaceDeclHandler
operator|=
name|NULL
expr_stmt|;
name|endNamespaceDeclHandler
operator|=
name|NULL
expr_stmt|;
name|notStandaloneHandler
operator|=
name|NULL
expr_stmt|;
name|externalEntityRefHandler
operator|=
name|NULL
expr_stmt|;
name|externalEntityRefHandlerArg
operator|=
name|parser
expr_stmt|;
name|skippedEntityHandler
operator|=
name|NULL
expr_stmt|;
name|elementDeclHandler
operator|=
name|NULL
expr_stmt|;
name|attlistDeclHandler
operator|=
name|NULL
expr_stmt|;
name|entityDeclHandler
operator|=
name|NULL
expr_stmt|;
name|xmlDeclHandler
operator|=
name|NULL
expr_stmt|;
name|bufferPtr
operator|=
name|buffer
expr_stmt|;
name|bufferEnd
operator|=
name|buffer
expr_stmt|;
name|parseEndByteIndex
operator|=
literal|0
expr_stmt|;
name|parseEndPtr
operator|=
name|NULL
expr_stmt|;
name|declElementType
operator|=
name|NULL
expr_stmt|;
name|declAttributeId
operator|=
name|NULL
expr_stmt|;
name|declEntity
operator|=
name|NULL
expr_stmt|;
name|doctypeName
operator|=
name|NULL
expr_stmt|;
name|doctypeSysid
operator|=
name|NULL
expr_stmt|;
name|doctypePubid
operator|=
name|NULL
expr_stmt|;
name|declAttributeType
operator|=
name|NULL
expr_stmt|;
name|declNotationName
operator|=
name|NULL
expr_stmt|;
name|declNotationPublicId
operator|=
name|NULL
expr_stmt|;
name|declAttributeIsCdata
operator|=
name|XML_FALSE
expr_stmt|;
name|declAttributeIsId
operator|=
name|XML_FALSE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|position
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|POSITION
argument_list|)
argument_list|)
expr_stmt|;
name|errorCode
operator|=
name|XML_ERROR_NONE
expr_stmt|;
name|eventPtr
operator|=
name|NULL
expr_stmt|;
name|eventEndPtr
operator|=
name|NULL
expr_stmt|;
name|positionPtr
operator|=
name|NULL
expr_stmt|;
name|openInternalEntities
operator|=
name|NULL
expr_stmt|;
name|defaultExpandInternalEntities
operator|=
name|XML_TRUE
expr_stmt|;
name|tagLevel
operator|=
literal|0
expr_stmt|;
name|tagStack
operator|=
name|NULL
expr_stmt|;
name|inheritedBindings
operator|=
name|NULL
expr_stmt|;
name|nSpecifiedAtts
operator|=
literal|0
expr_stmt|;
name|unknownEncodingMem
operator|=
name|NULL
expr_stmt|;
name|unknownEncodingRelease
operator|=
name|NULL
expr_stmt|;
name|unknownEncodingData
operator|=
name|NULL
expr_stmt|;
name|parentParser
operator|=
name|NULL
expr_stmt|;
name|ps_parsing
operator|=
name|XML_INITIALIZED
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|isParamEntity
operator|=
name|XML_FALSE
expr_stmt|;
name|useForeignDTD
operator|=
name|XML_FALSE
expr_stmt|;
name|paramEntityParsing
operator|=
name|XML_PARAM_ENTITY_PARSING_NEVER
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* moves list of bindings to freeBindingList */
end_comment

begin_function
specifier|static
name|void
name|FASTCALL
name|moveToFreeBindingList
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|BINDING
modifier|*
name|bindings
parameter_list|)
block|{
while|while
condition|(
name|bindings
condition|)
block|{
name|BINDING
modifier|*
name|b
init|=
name|bindings
decl_stmt|;
name|bindings
operator|=
name|bindings
operator|->
name|nextTagBinding
expr_stmt|;
name|b
operator|->
name|nextTagBinding
operator|=
name|freeBindingList
expr_stmt|;
name|freeBindingList
operator|=
name|b
expr_stmt|;
block|}
block|}
end_function

begin_function
name|XML_Bool
name|XMLCALL
name|XML_ParserReset
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
name|TAG
modifier|*
name|tStk
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|openEntityList
decl_stmt|;
if|if
condition|(
name|parentParser
condition|)
return|return
name|XML_FALSE
return|;
comment|/* move tagStack to freeTagList */
name|tStk
operator|=
name|tagStack
expr_stmt|;
while|while
condition|(
name|tStk
condition|)
block|{
name|TAG
modifier|*
name|tag
init|=
name|tStk
decl_stmt|;
name|tStk
operator|=
name|tStk
operator|->
name|parent
expr_stmt|;
name|tag
operator|->
name|parent
operator|=
name|freeTagList
expr_stmt|;
name|moveToFreeBindingList
argument_list|(
name|parser
argument_list|,
name|tag
operator|->
name|bindings
argument_list|)
expr_stmt|;
name|tag
operator|->
name|bindings
operator|=
name|NULL
expr_stmt|;
name|freeTagList
operator|=
name|tag
expr_stmt|;
block|}
comment|/* move openInternalEntities to freeInternalEntities */
name|openEntityList
operator|=
name|openInternalEntities
expr_stmt|;
while|while
condition|(
name|openEntityList
condition|)
block|{
name|OPEN_INTERNAL_ENTITY
modifier|*
name|openEntity
init|=
name|openEntityList
decl_stmt|;
name|openEntityList
operator|=
name|openEntity
operator|->
name|next
expr_stmt|;
name|openEntity
operator|->
name|next
operator|=
name|freeInternalEntities
expr_stmt|;
name|freeInternalEntities
operator|=
name|openEntity
expr_stmt|;
block|}
name|moveToFreeBindingList
argument_list|(
name|parser
argument_list|,
name|inheritedBindings
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|unknownEncodingMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownEncodingRelease
condition|)
name|unknownEncodingRelease
argument_list|(
name|unknownEncodingData
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
name|parserInit
argument_list|(
name|parser
argument_list|,
name|encodingName
argument_list|)
expr_stmt|;
name|dtdReset
argument_list|(
name|_dtd
argument_list|,
operator|&
name|parser
operator|->
name|m_mem
argument_list|)
expr_stmt|;
return|return
name|setContext
argument_list|(
name|parser
argument_list|,
name|implicitContext
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_SetEncoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
comment|/* Block after XML_Parse()/XML_ParseBuffer() has been called.      XXX There's no way for the caller to determine which of the      XXX possible error cases caused the XML_STATUS_ERROR return.   */
if|if
condition|(
name|ps_parsing
operator|==
name|XML_PARSING
operator|||
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
return|return
name|XML_STATUS_ERROR
return|;
if|if
condition|(
name|encodingName
operator|==
name|NULL
condition|)
name|protocolEncodingName
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|protocolEncodingName
operator|=
name|poolCopyString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|encodingName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protocolEncodingName
condition|)
return|return
name|XML_STATUS_ERROR
return|;
block|}
return|return
name|XML_STATUS_OK
return|;
block|}
end_function

begin_function
name|XML_Parser
name|XMLCALL
name|XML_ExternalEntityParserCreate
parameter_list|(
name|XML_Parser
name|oldParser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
name|XML_Parser
name|parser
init|=
name|oldParser
decl_stmt|;
name|DTD
modifier|*
name|newDtd
init|=
name|NULL
decl_stmt|;
name|DTD
modifier|*
name|oldDtd
init|=
name|_dtd
decl_stmt|;
name|XML_StartElementHandler
name|oldStartElementHandler
init|=
name|startElementHandler
decl_stmt|;
name|XML_EndElementHandler
name|oldEndElementHandler
init|=
name|endElementHandler
decl_stmt|;
name|XML_CharacterDataHandler
name|oldCharacterDataHandler
init|=
name|characterDataHandler
decl_stmt|;
name|XML_ProcessingInstructionHandler
name|oldProcessingInstructionHandler
init|=
name|processingInstructionHandler
decl_stmt|;
name|XML_CommentHandler
name|oldCommentHandler
init|=
name|commentHandler
decl_stmt|;
name|XML_StartCdataSectionHandler
name|oldStartCdataSectionHandler
init|=
name|startCdataSectionHandler
decl_stmt|;
name|XML_EndCdataSectionHandler
name|oldEndCdataSectionHandler
init|=
name|endCdataSectionHandler
decl_stmt|;
name|XML_DefaultHandler
name|oldDefaultHandler
init|=
name|defaultHandler
decl_stmt|;
name|XML_UnparsedEntityDeclHandler
name|oldUnparsedEntityDeclHandler
init|=
name|unparsedEntityDeclHandler
decl_stmt|;
name|XML_NotationDeclHandler
name|oldNotationDeclHandler
init|=
name|notationDeclHandler
decl_stmt|;
name|XML_StartNamespaceDeclHandler
name|oldStartNamespaceDeclHandler
init|=
name|startNamespaceDeclHandler
decl_stmt|;
name|XML_EndNamespaceDeclHandler
name|oldEndNamespaceDeclHandler
init|=
name|endNamespaceDeclHandler
decl_stmt|;
name|XML_NotStandaloneHandler
name|oldNotStandaloneHandler
init|=
name|notStandaloneHandler
decl_stmt|;
name|XML_ExternalEntityRefHandler
name|oldExternalEntityRefHandler
init|=
name|externalEntityRefHandler
decl_stmt|;
name|XML_SkippedEntityHandler
name|oldSkippedEntityHandler
init|=
name|skippedEntityHandler
decl_stmt|;
name|XML_UnknownEncodingHandler
name|oldUnknownEncodingHandler
init|=
name|unknownEncodingHandler
decl_stmt|;
name|XML_ElementDeclHandler
name|oldElementDeclHandler
init|=
name|elementDeclHandler
decl_stmt|;
name|XML_AttlistDeclHandler
name|oldAttlistDeclHandler
init|=
name|attlistDeclHandler
decl_stmt|;
name|XML_EntityDeclHandler
name|oldEntityDeclHandler
init|=
name|entityDeclHandler
decl_stmt|;
name|XML_XmlDeclHandler
name|oldXmlDeclHandler
init|=
name|xmlDeclHandler
decl_stmt|;
name|ELEMENT_TYPE
modifier|*
name|oldDeclElementType
init|=
name|declElementType
decl_stmt|;
name|void
modifier|*
name|oldUserData
init|=
name|userData
decl_stmt|;
name|void
modifier|*
name|oldHandlerArg
init|=
name|handlerArg
decl_stmt|;
name|XML_Bool
name|oldDefaultExpandInternalEntities
init|=
name|defaultExpandInternalEntities
decl_stmt|;
name|XML_Parser
name|oldExternalEntityRefHandlerArg
init|=
name|externalEntityRefHandlerArg
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|enum
name|XML_ParamEntityParsing
name|oldParamEntityParsing
init|=
name|paramEntityParsing
decl_stmt|;
name|int
name|oldInEntityValue
init|=
name|prologState
operator|.
name|inEntityValue
decl_stmt|;
endif|#
directive|endif
name|XML_Bool
name|oldns_triplets
init|=
name|ns_triplets
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
operator|!
name|context
condition|)
name|newDtd
operator|=
name|oldDtd
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
comment|/* Note that the magical uses of the pre-processor to make field      access look more like C++ require that `parser' be overwritten      here.  This makes this function more painful to follow than it      would be otherwise.   */
if|if
condition|(
name|ns
condition|)
block|{
name|XML_Char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|tmp
operator|=
name|namespaceSeparator
expr_stmt|;
name|parser
operator|=
name|parserCreate
argument_list|(
name|encodingName
argument_list|,
operator|&
name|parser
operator|->
name|m_mem
argument_list|,
name|tmp
argument_list|,
name|newDtd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|=
name|parserCreate
argument_list|(
name|encodingName
argument_list|,
operator|&
name|parser
operator|->
name|m_mem
argument_list|,
name|NULL
argument_list|,
name|newDtd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parser
condition|)
return|return
name|NULL
return|;
name|startElementHandler
operator|=
name|oldStartElementHandler
expr_stmt|;
name|endElementHandler
operator|=
name|oldEndElementHandler
expr_stmt|;
name|characterDataHandler
operator|=
name|oldCharacterDataHandler
expr_stmt|;
name|processingInstructionHandler
operator|=
name|oldProcessingInstructionHandler
expr_stmt|;
name|commentHandler
operator|=
name|oldCommentHandler
expr_stmt|;
name|startCdataSectionHandler
operator|=
name|oldStartCdataSectionHandler
expr_stmt|;
name|endCdataSectionHandler
operator|=
name|oldEndCdataSectionHandler
expr_stmt|;
name|defaultHandler
operator|=
name|oldDefaultHandler
expr_stmt|;
name|unparsedEntityDeclHandler
operator|=
name|oldUnparsedEntityDeclHandler
expr_stmt|;
name|notationDeclHandler
operator|=
name|oldNotationDeclHandler
expr_stmt|;
name|startNamespaceDeclHandler
operator|=
name|oldStartNamespaceDeclHandler
expr_stmt|;
name|endNamespaceDeclHandler
operator|=
name|oldEndNamespaceDeclHandler
expr_stmt|;
name|notStandaloneHandler
operator|=
name|oldNotStandaloneHandler
expr_stmt|;
name|externalEntityRefHandler
operator|=
name|oldExternalEntityRefHandler
expr_stmt|;
name|skippedEntityHandler
operator|=
name|oldSkippedEntityHandler
expr_stmt|;
name|unknownEncodingHandler
operator|=
name|oldUnknownEncodingHandler
expr_stmt|;
name|elementDeclHandler
operator|=
name|oldElementDeclHandler
expr_stmt|;
name|attlistDeclHandler
operator|=
name|oldAttlistDeclHandler
expr_stmt|;
name|entityDeclHandler
operator|=
name|oldEntityDeclHandler
expr_stmt|;
name|xmlDeclHandler
operator|=
name|oldXmlDeclHandler
expr_stmt|;
name|declElementType
operator|=
name|oldDeclElementType
expr_stmt|;
name|userData
operator|=
name|oldUserData
expr_stmt|;
if|if
condition|(
name|oldUserData
operator|==
name|oldHandlerArg
condition|)
name|handlerArg
operator|=
name|userData
expr_stmt|;
else|else
name|handlerArg
operator|=
name|parser
expr_stmt|;
if|if
condition|(
name|oldExternalEntityRefHandlerArg
operator|!=
name|oldParser
condition|)
name|externalEntityRefHandlerArg
operator|=
name|oldExternalEntityRefHandlerArg
expr_stmt|;
name|defaultExpandInternalEntities
operator|=
name|oldDefaultExpandInternalEntities
expr_stmt|;
name|ns_triplets
operator|=
name|oldns_triplets
expr_stmt|;
name|parentParser
operator|=
name|oldParser
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|paramEntityParsing
operator|=
name|oldParamEntityParsing
expr_stmt|;
name|prologState
operator|.
name|inEntityValue
operator|=
name|oldInEntityValue
expr_stmt|;
if|if
condition|(
name|context
condition|)
block|{
endif|#
directive|endif
comment|/* XML_DTD */
if|if
condition|(
operator|!
name|dtdCopy
argument_list|(
name|_dtd
argument_list|,
name|oldDtd
argument_list|,
operator|&
name|parser
operator|->
name|m_mem
argument_list|)
operator|||
operator|!
name|setContext
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
condition|)
block|{
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|processor
operator|=
name|externalEntityInitProcessor
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
block|}
else|else
block|{
comment|/* The DTD instance referenced by _dtd is shared between the document's        root parser and external PE parsers, therefore one does not need to        call setContext. In addition, one also *must* not call setContext,        because this would overwrite existing prefix->binding pointers in        _dtd with ones that get destroyed with the external PE parser.        This would leave those prefixes with dangling pointers.     */
name|isParamEntity
operator|=
name|XML_TRUE
expr_stmt|;
name|XmlPrologStateInitExternalEntity
argument_list|(
operator|&
name|prologState
argument_list|)
expr_stmt|;
name|processor
operator|=
name|externalParEntInitProcessor
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XML_DTD */
return|return
name|parser
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|destroyBindings
parameter_list|(
name|BINDING
modifier|*
name|bindings
parameter_list|,
name|XML_Parser
name|parser
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|BINDING
modifier|*
name|b
init|=
name|bindings
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
break|break;
name|bindings
operator|=
name|b
operator|->
name|nextTagBinding
expr_stmt|;
name|FREE
argument_list|(
name|b
operator|->
name|uri
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_ParserFree
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|TAG
modifier|*
name|tagList
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|entityList
decl_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
return|return;
comment|/* free tagStack and freeTagList */
name|tagList
operator|=
name|tagStack
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TAG
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tagList
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|freeTagList
operator|==
name|NULL
condition|)
break|break;
name|tagList
operator|=
name|freeTagList
expr_stmt|;
name|freeTagList
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|tagList
expr_stmt|;
name|tagList
operator|=
name|tagList
operator|->
name|parent
expr_stmt|;
name|FREE
argument_list|(
name|p
operator|->
name|buf
argument_list|)
expr_stmt|;
name|destroyBindings
argument_list|(
name|p
operator|->
name|bindings
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* free openInternalEntities and freeInternalEntities */
name|entityList
operator|=
name|openInternalEntities
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|OPEN_INTERNAL_ENTITY
modifier|*
name|openEntity
decl_stmt|;
if|if
condition|(
name|entityList
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|freeInternalEntities
operator|==
name|NULL
condition|)
break|break;
name|entityList
operator|=
name|freeInternalEntities
expr_stmt|;
name|freeInternalEntities
operator|=
name|NULL
expr_stmt|;
block|}
name|openEntity
operator|=
name|entityList
expr_stmt|;
name|entityList
operator|=
name|entityList
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|openEntity
argument_list|)
expr_stmt|;
block|}
name|destroyBindings
argument_list|(
name|freeBindingList
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|destroyBindings
argument_list|(
name|inheritedBindings
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|poolDestroy
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|poolDestroy
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
comment|/* external parameter entity parsers share the DTD structure      parser->m_dtd with the root parser, so we must not destroy it   */
if|if
condition|(
operator|!
name|isParamEntity
operator|&&
name|_dtd
condition|)
else|#
directive|else
if|if
condition|(
name|_dtd
condition|)
endif|#
directive|endif
comment|/* XML_DTD */
name|dtdDestroy
argument_list|(
name|_dtd
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|parentParser
argument_list|,
operator|&
name|parser
operator|->
name|m_mem
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|void
operator|*
operator|)
name|atts
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|groupConnector
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|dataBuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nsAtts
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|unknownEncodingMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|unknownEncodingRelease
condition|)
name|unknownEncodingRelease
argument_list|(
name|unknownEncodingData
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_UseParserAsHandlerArg
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|handlerArg
operator|=
name|parser
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|XML_Error
name|XMLCALL
name|XML_UseForeignDTD
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_Bool
name|useDTD
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XML_DTD
comment|/* block after XML_Parse()/XML_ParseBuffer() has been called */
if|if
condition|(
name|ps_parsing
operator|==
name|XML_PARSING
operator|||
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
return|return
name|XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING
return|;
name|useForeignDTD
operator|=
name|useDTD
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
else|#
directive|else
return|return
name|XML_ERROR_FEATURE_REQUIRES_XML_DTD
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetReturnNSTriplet
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|do_nst
parameter_list|)
block|{
comment|/* block after XML_Parse()/XML_ParseBuffer() has been called */
if|if
condition|(
name|ps_parsing
operator|==
name|XML_PARSING
operator|||
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
return|return;
name|ns_triplets
operator|=
name|do_nst
condition|?
name|XML_TRUE
else|:
name|XML_FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetUserData
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|handlerArg
operator|==
name|userData
condition|)
name|handlerArg
operator|=
name|userData
operator|=
name|p
expr_stmt|;
else|else
name|userData
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_SetBase
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|=
name|poolCopyString
argument_list|(
operator|&
name|_dtd
operator|->
name|pool
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|XML_STATUS_ERROR
return|;
name|curBase
operator|=
name|p
expr_stmt|;
block|}
else|else
name|curBase
operator|=
name|NULL
expr_stmt|;
return|return
name|XML_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|const
name|XML_Char
modifier|*
name|XMLCALL
name|XML_GetBase
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
return|return
name|curBase
return|;
block|}
end_function

begin_function
name|int
name|XMLCALL
name|XML_GetSpecifiedAttributeCount
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
return|return
name|nSpecifiedAtts
return|;
block|}
end_function

begin_function
name|int
name|XMLCALL
name|XML_GetIdAttributeIndex
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
return|return
name|idAttIndex
return|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetElementHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartElementHandler
name|start
parameter_list|,
name|XML_EndElementHandler
name|end
parameter_list|)
block|{
name|startElementHandler
operator|=
name|start
expr_stmt|;
name|endElementHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetStartElementHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartElementHandler
name|start
parameter_list|)
block|{
name|startElementHandler
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetEndElementHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_EndElementHandler
name|end
parameter_list|)
block|{
name|endElementHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetCharacterDataHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_CharacterDataHandler
name|handler
parameter_list|)
block|{
name|characterDataHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetProcessingInstructionHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_ProcessingInstructionHandler
name|handler
parameter_list|)
block|{
name|processingInstructionHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetCommentHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_CommentHandler
name|handler
parameter_list|)
block|{
name|commentHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetCdataSectionHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartCdataSectionHandler
name|start
parameter_list|,
name|XML_EndCdataSectionHandler
name|end
parameter_list|)
block|{
name|startCdataSectionHandler
operator|=
name|start
expr_stmt|;
name|endCdataSectionHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetStartCdataSectionHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartCdataSectionHandler
name|start
parameter_list|)
block|{
name|startCdataSectionHandler
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetEndCdataSectionHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_EndCdataSectionHandler
name|end
parameter_list|)
block|{
name|endCdataSectionHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetDefaultHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_DefaultHandler
name|handler
parameter_list|)
block|{
name|defaultHandler
operator|=
name|handler
expr_stmt|;
name|defaultExpandInternalEntities
operator|=
name|XML_FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetDefaultHandlerExpand
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_DefaultHandler
name|handler
parameter_list|)
block|{
name|defaultHandler
operator|=
name|handler
expr_stmt|;
name|defaultExpandInternalEntities
operator|=
name|XML_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetDoctypeDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartDoctypeDeclHandler
name|start
parameter_list|,
name|XML_EndDoctypeDeclHandler
name|end
parameter_list|)
block|{
name|startDoctypeDeclHandler
operator|=
name|start
expr_stmt|;
name|endDoctypeDeclHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetStartDoctypeDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartDoctypeDeclHandler
name|start
parameter_list|)
block|{
name|startDoctypeDeclHandler
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetEndDoctypeDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_EndDoctypeDeclHandler
name|end
parameter_list|)
block|{
name|endDoctypeDeclHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetUnparsedEntityDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_UnparsedEntityDeclHandler
name|handler
parameter_list|)
block|{
name|unparsedEntityDeclHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetNotationDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_NotationDeclHandler
name|handler
parameter_list|)
block|{
name|notationDeclHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetNamespaceDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartNamespaceDeclHandler
name|start
parameter_list|,
name|XML_EndNamespaceDeclHandler
name|end
parameter_list|)
block|{
name|startNamespaceDeclHandler
operator|=
name|start
expr_stmt|;
name|endNamespaceDeclHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetStartNamespaceDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_StartNamespaceDeclHandler
name|start
parameter_list|)
block|{
name|startNamespaceDeclHandler
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetEndNamespaceDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_EndNamespaceDeclHandler
name|end
parameter_list|)
block|{
name|endNamespaceDeclHandler
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetNotStandaloneHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_NotStandaloneHandler
name|handler
parameter_list|)
block|{
name|notStandaloneHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetExternalEntityRefHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_ExternalEntityRefHandler
name|handler
parameter_list|)
block|{
name|externalEntityRefHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetExternalEntityRefHandlerArg
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
condition|)
name|externalEntityRefHandlerArg
operator|=
operator|(
name|XML_Parser
operator|)
name|arg
expr_stmt|;
else|else
name|externalEntityRefHandlerArg
operator|=
name|parser
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetSkippedEntityHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_SkippedEntityHandler
name|handler
parameter_list|)
block|{
name|skippedEntityHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetUnknownEncodingHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_UnknownEncodingHandler
name|handler
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unknownEncodingHandler
operator|=
name|handler
expr_stmt|;
name|unknownEncodingHandlerData
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetElementDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_ElementDeclHandler
name|eldecl
parameter_list|)
block|{
name|elementDeclHandler
operator|=
name|eldecl
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetAttlistDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_AttlistDeclHandler
name|attdecl
parameter_list|)
block|{
name|attlistDeclHandler
operator|=
name|attdecl
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetEntityDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_EntityDeclHandler
name|handler
parameter_list|)
block|{
name|entityDeclHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_SetXmlDeclHandler
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_XmlDeclHandler
name|handler
parameter_list|)
block|{
name|xmlDeclHandler
operator|=
name|handler
expr_stmt|;
block|}
end_function

begin_function
name|int
name|XMLCALL
name|XML_SetParamEntityParsing
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|enum
name|XML_ParamEntityParsing
name|peParsing
parameter_list|)
block|{
comment|/* block after XML_Parse()/XML_ParseBuffer() has been called */
if|if
condition|(
name|ps_parsing
operator|==
name|XML_PARSING
operator|||
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|XML_DTD
name|paramEntityParsing
operator|=
name|peParsing
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
return|return
name|peParsing
operator|==
name|XML_PARAM_ENTITY_PARSING_NEVER
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_Parse
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|isFinal
parameter_list|)
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|errorCode
operator|=
name|XML_ERROR_SUSPENDED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
case|case
name|XML_FINISHED
case|:
name|errorCode
operator|=
name|XML_ERROR_FINISHED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
default|default:
name|ps_parsing
operator|=
name|XML_PARSING
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ps_finalBuffer
operator|=
operator|(
name|XML_Bool
operator|)
name|isFinal
expr_stmt|;
if|if
condition|(
operator|!
name|isFinal
condition|)
return|return
name|XML_STATUS_OK
return|;
name|positionPtr
operator|=
name|bufferPtr
expr_stmt|;
name|parseEndPtr
operator|=
name|bufferEnd
expr_stmt|;
comment|/* If data are left over from last buffer, and we now know that these        data are the final chunk of input, then we have to check them again        to detect errors based on that fact.     */
name|errorCode
operator|=
name|processor
argument_list|(
name|parser
argument_list|,
name|bufferPtr
argument_list|,
name|parseEndPtr
argument_list|,
operator|&
name|bufferPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|==
name|XML_ERROR_NONE
condition|)
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|bufferPtr
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|positionPtr
operator|=
name|bufferPtr
expr_stmt|;
return|return
name|XML_STATUS_SUSPENDED
return|;
case|case
name|XML_INITIALIZED
case|:
case|case
name|XML_PARSING
case|:
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
comment|/* fall through */
default|default:
return|return
name|XML_STATUS_OK
return|;
block|}
block|}
name|eventEndPtr
operator|=
name|eventPtr
expr_stmt|;
name|processor
operator|=
name|errorProcessor
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
ifndef|#
directive|ifndef
name|XML_CONTEXT_BYTES
elseif|else
if|if
condition|(
name|bufferPtr
operator|==
name|bufferEnd
condition|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|nLeftOver
decl_stmt|;
name|enum
name|XML_Error
name|result
decl_stmt|;
name|parseEndByteIndex
operator|+=
name|len
expr_stmt|;
name|positionPtr
operator|=
name|s
expr_stmt|;
name|ps_finalBuffer
operator|=
operator|(
name|XML_Bool
operator|)
name|isFinal
expr_stmt|;
name|errorCode
operator|=
name|processor
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|parseEndPtr
operator|=
name|s
operator|+
name|len
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|!=
name|XML_ERROR_NONE
condition|)
block|{
name|eventEndPtr
operator|=
name|eventPtr
expr_stmt|;
name|processor
operator|=
name|errorProcessor
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|result
operator|=
name|XML_STATUS_SUSPENDED
expr_stmt|;
break|break;
case|case
name|XML_INITIALIZED
case|:
case|case
name|XML_PARSING
case|:
name|result
operator|=
name|XML_STATUS_OK
expr_stmt|;
if|if
condition|(
name|isFinal
condition|)
block|{
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|end
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|nLeftOver
operator|=
name|s
operator|+
name|len
operator|-
name|end
expr_stmt|;
if|if
condition|(
name|nLeftOver
condition|)
block|{
if|if
condition|(
name|buffer
operator|==
name|NULL
operator|||
name|nLeftOver
operator|>
name|bufferLim
operator|-
name|buffer
condition|)
block|{
comment|/* FIXME avoid integer overflow */
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|buffer
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|len
operator|*
literal|2
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|REALLOC
argument_list|(
name|buffer
argument_list|,
name|len
operator|*
literal|2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
name|buffer
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
name|eventPtr
operator|=
name|eventEndPtr
operator|=
name|NULL
expr_stmt|;
name|processor
operator|=
name|errorProcessor
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
name|bufferLim
operator|=
name|buffer
operator|+
name|len
operator|*
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|end
argument_list|,
name|nLeftOver
argument_list|)
expr_stmt|;
block|}
name|bufferPtr
operator|=
name|buffer
expr_stmt|;
name|bufferEnd
operator|=
name|buffer
operator|+
name|nLeftOver
expr_stmt|;
name|positionPtr
operator|=
name|bufferPtr
expr_stmt|;
name|parseEndPtr
operator|=
name|bufferEnd
expr_stmt|;
name|eventPtr
operator|=
name|bufferPtr
expr_stmt|;
name|eventEndPtr
operator|=
name|bufferPtr
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
comment|/* not defined XML_CONTEXT_BYTES */
else|else
block|{
name|void
modifier|*
name|buff
init|=
name|XML_GetBuffer
argument_list|(
name|parser
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
name|XML_STATUS_ERROR
return|;
else|else
block|{
name|memcpy
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|XML_ParseBuffer
argument_list|(
name|parser
argument_list|,
name|len
argument_list|,
name|isFinal
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_ParseBuffer
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|isFinal
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|enum
name|XML_Status
name|result
init|=
name|XML_STATUS_OK
decl_stmt|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|errorCode
operator|=
name|XML_ERROR_SUSPENDED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
case|case
name|XML_FINISHED
case|:
name|errorCode
operator|=
name|XML_ERROR_FINISHED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
default|default:
name|ps_parsing
operator|=
name|XML_PARSING
expr_stmt|;
block|}
name|start
operator|=
name|bufferPtr
expr_stmt|;
name|positionPtr
operator|=
name|start
expr_stmt|;
name|bufferEnd
operator|+=
name|len
expr_stmt|;
name|parseEndPtr
operator|=
name|bufferEnd
expr_stmt|;
name|parseEndByteIndex
operator|+=
name|len
expr_stmt|;
name|ps_finalBuffer
operator|=
operator|(
name|XML_Bool
operator|)
name|isFinal
expr_stmt|;
name|errorCode
operator|=
name|processor
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|parseEndPtr
argument_list|,
operator|&
name|bufferPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|!=
name|XML_ERROR_NONE
condition|)
block|{
name|eventEndPtr
operator|=
name|eventPtr
expr_stmt|;
name|processor
operator|=
name|errorProcessor
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|result
operator|=
name|XML_STATUS_SUSPENDED
expr_stmt|;
break|break;
case|case
name|XML_INITIALIZED
case|:
case|case
name|XML_PARSING
case|:
if|if
condition|(
name|isFinal
condition|)
block|{
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
return|return
name|result
return|;
block|}
default|default:
empty_stmt|;
comment|/* should not happen */
block|}
block|}
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|bufferPtr
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|positionPtr
operator|=
name|bufferPtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|XMLCALL
name|XML_GetBuffer
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|errorCode
operator|=
name|XML_ERROR_SUSPENDED
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|XML_FINISHED
case|:
name|errorCode
operator|=
name|XML_ERROR_FINISHED
expr_stmt|;
return|return
name|NULL
return|;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|bufferLim
operator|-
name|bufferEnd
condition|)
block|{
comment|/* FIXME avoid integer overflow */
name|int
name|neededSize
init|=
name|len
operator|+
call|(
name|int
call|)
argument_list|(
name|bufferEnd
operator|-
name|bufferPtr
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_CONTEXT_BYTES
name|int
name|keep
init|=
call|(
name|int
call|)
argument_list|(
name|bufferPtr
operator|-
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep
operator|>
name|XML_CONTEXT_BYTES
condition|)
name|keep
operator|=
name|XML_CONTEXT_BYTES
expr_stmt|;
name|neededSize
operator|+=
name|keep
expr_stmt|;
endif|#
directive|endif
comment|/* defined XML_CONTEXT_BYTES */
if|if
condition|(
name|neededSize
operator|<=
name|bufferLim
operator|-
name|buffer
condition|)
block|{
ifdef|#
directive|ifdef
name|XML_CONTEXT_BYTES
if|if
condition|(
name|keep
operator|<
name|bufferPtr
operator|-
name|buffer
condition|)
block|{
name|int
name|offset
init|=
call|(
name|int
call|)
argument_list|(
name|bufferPtr
operator|-
name|buffer
argument_list|)
operator|-
name|keep
decl_stmt|;
name|memmove
argument_list|(
name|buffer
argument_list|,
operator|&
name|buffer
index|[
name|offset
index|]
argument_list|,
name|bufferEnd
operator|-
name|bufferPtr
operator|+
name|keep
argument_list|)
expr_stmt|;
name|bufferEnd
operator|-=
name|offset
expr_stmt|;
name|bufferPtr
operator|-=
name|offset
expr_stmt|;
block|}
else|#
directive|else
name|memmove
argument_list|(
name|buffer
argument_list|,
name|bufferPtr
argument_list|,
name|bufferEnd
operator|-
name|bufferPtr
argument_list|)
expr_stmt|;
name|bufferEnd
operator|=
name|buffer
operator|+
operator|(
name|bufferEnd
operator|-
name|bufferPtr
operator|)
expr_stmt|;
name|bufferPtr
operator|=
name|buffer
expr_stmt|;
endif|#
directive|endif
comment|/* not defined XML_CONTEXT_BYTES */
block|}
else|else
block|{
name|char
modifier|*
name|newBuf
decl_stmt|;
name|int
name|bufferSize
init|=
call|(
name|int
call|)
argument_list|(
name|bufferLim
operator|-
name|bufferPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|==
literal|0
condition|)
name|bufferSize
operator|=
name|INIT_BUFFER_SIZE
expr_stmt|;
do|do
block|{
name|bufferSize
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bufferSize
operator|<
name|neededSize
condition|)
do|;
name|newBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newBuf
operator|==
literal|0
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bufferLim
operator|=
name|newBuf
operator|+
name|bufferSize
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_CONTEXT_BYTES
if|if
condition|(
name|bufferPtr
condition|)
block|{
name|int
name|keep
init|=
call|(
name|int
call|)
argument_list|(
name|bufferPtr
operator|-
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep
operator|>
name|XML_CONTEXT_BYTES
condition|)
name|keep
operator|=
name|XML_CONTEXT_BYTES
expr_stmt|;
name|memcpy
argument_list|(
name|newBuf
argument_list|,
operator|&
name|bufferPtr
index|[
operator|-
name|keep
index|]
argument_list|,
name|bufferEnd
operator|-
name|bufferPtr
operator|+
name|keep
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|newBuf
expr_stmt|;
name|bufferEnd
operator|=
name|buffer
operator|+
operator|(
name|bufferEnd
operator|-
name|bufferPtr
operator|)
operator|+
name|keep
expr_stmt|;
name|bufferPtr
operator|=
name|buffer
operator|+
name|keep
expr_stmt|;
block|}
else|else
block|{
name|bufferEnd
operator|=
name|newBuf
operator|+
operator|(
name|bufferEnd
operator|-
name|bufferPtr
operator|)
expr_stmt|;
name|bufferPtr
operator|=
name|buffer
operator|=
name|newBuf
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|bufferPtr
condition|)
block|{
name|memcpy
argument_list|(
name|newBuf
argument_list|,
name|bufferPtr
argument_list|,
name|bufferEnd
operator|-
name|bufferPtr
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|bufferEnd
operator|=
name|newBuf
operator|+
operator|(
name|bufferEnd
operator|-
name|bufferPtr
operator|)
expr_stmt|;
name|bufferPtr
operator|=
name|buffer
operator|=
name|newBuf
expr_stmt|;
endif|#
directive|endif
comment|/* not defined XML_CONTEXT_BYTES */
block|}
block|}
return|return
name|bufferEnd
return|;
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_StopParser
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_Bool
name|resumable
parameter_list|)
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
if|if
condition|(
name|resumable
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_SUSPENDED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
break|break;
case|case
name|XML_FINISHED
case|:
name|errorCode
operator|=
name|XML_ERROR_FINISHED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
default|default:
if|if
condition|(
name|resumable
condition|)
block|{
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|isParamEntity
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_SUSPEND_PE
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
endif|#
directive|endif
name|ps_parsing
operator|=
name|XML_SUSPENDED
expr_stmt|;
block|}
else|else
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
block|}
return|return
name|XML_STATUS_OK
return|;
block|}
end_function

begin_function
name|enum
name|XML_Status
name|XMLCALL
name|XML_ResumeParser
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|enum
name|XML_Status
name|result
init|=
name|XML_STATUS_OK
decl_stmt|;
if|if
condition|(
name|ps_parsing
operator|!=
name|XML_SUSPENDED
condition|)
block|{
name|errorCode
operator|=
name|XML_ERROR_NOT_SUSPENDED
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
name|ps_parsing
operator|=
name|XML_PARSING
expr_stmt|;
name|errorCode
operator|=
name|processor
argument_list|(
name|parser
argument_list|,
name|bufferPtr
argument_list|,
name|parseEndPtr
argument_list|,
operator|&
name|bufferPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCode
operator|!=
name|XML_ERROR_NONE
condition|)
block|{
name|eventEndPtr
operator|=
name|eventPtr
expr_stmt|;
name|processor
operator|=
name|errorProcessor
expr_stmt|;
return|return
name|XML_STATUS_ERROR
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
name|result
operator|=
name|XML_STATUS_SUSPENDED
expr_stmt|;
break|break;
case|case
name|XML_INITIALIZED
case|:
case|case
name|XML_PARSING
case|:
if|if
condition|(
name|ps_finalBuffer
condition|)
block|{
name|ps_parsing
operator|=
name|XML_FINISHED
expr_stmt|;
return|return
name|result
return|;
block|}
default|default:
empty_stmt|;
block|}
block|}
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|bufferPtr
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|positionPtr
operator|=
name|bufferPtr
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_GetParsingStatus
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_ParsingStatus
modifier|*
name|status
parameter_list|)
block|{
name|assert
argument_list|(
name|status
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|parser
operator|->
name|m_parsingStatus
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|XML_Error
name|XMLCALL
name|XML_GetErrorCode
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
return|return
name|errorCode
return|;
block|}
end_function

begin_function
name|XML_Index
name|XMLCALL
name|XML_GetCurrentByteIndex
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
if|if
condition|(
name|eventPtr
condition|)
return|return
name|parseEndByteIndex
operator|-
operator|(
name|parseEndPtr
operator|-
name|eventPtr
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|XMLCALL
name|XML_GetCurrentByteCount
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
if|if
condition|(
name|eventEndPtr
operator|&&
name|eventPtr
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|eventEndPtr
operator|-
name|eventPtr
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|XMLCALL
name|XML_GetInputContext
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XML_CONTEXT_BYTES
if|if
condition|(
name|eventPtr
operator|&&
name|buffer
condition|)
block|{
operator|*
name|offset
operator|=
call|(
name|int
call|)
argument_list|(
name|eventPtr
operator|-
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
call|(
name|int
call|)
argument_list|(
name|bufferEnd
operator|-
name|buffer
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
endif|#
directive|endif
comment|/* defined XML_CONTEXT_BYTES */
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|XML_Size
name|XMLCALL
name|XML_GetCurrentLineNumber
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
if|if
condition|(
name|eventPtr
operator|&&
name|eventPtr
operator|>=
name|positionPtr
condition|)
block|{
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|eventPtr
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|positionPtr
operator|=
name|eventPtr
expr_stmt|;
block|}
return|return
name|position
operator|.
name|lineNumber
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|XML_Size
name|XMLCALL
name|XML_GetCurrentColumnNumber
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
if|if
condition|(
name|eventPtr
operator|&&
name|eventPtr
operator|>=
name|positionPtr
condition|)
block|{
name|XmlUpdatePosition
argument_list|(
name|encoding
argument_list|,
name|positionPtr
argument_list|,
name|eventPtr
argument_list|,
operator|&
name|position
argument_list|)
expr_stmt|;
name|positionPtr
operator|=
name|eventPtr
expr_stmt|;
block|}
return|return
name|position
operator|.
name|columnNumber
return|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_FreeContentModel
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|XML_Content
modifier|*
name|model
parameter_list|)
block|{
name|FREE
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|XMLCALL
name|XML_MemMalloc
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|MALLOC
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|XMLCALL
name|XML_MemRealloc
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|REALLOC
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_MemFree
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FREE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XMLCALL
name|XML_DefaultCurrent
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
if|if
condition|(
name|defaultHandler
condition|)
block|{
if|if
condition|(
name|openInternalEntities
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|internalEncoding
argument_list|,
name|openInternalEntities
operator|->
name|internalEventPtr
argument_list|,
name|openInternalEntities
operator|->
name|internalEventEndPtr
argument_list|)
expr_stmt|;
else|else
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|eventPtr
argument_list|,
name|eventEndPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|XML_LChar
modifier|*
name|XMLCALL
name|XML_ErrorString
parameter_list|(
name|enum
name|XML_Error
name|code
parameter_list|)
block|{
specifier|static
specifier|const
name|XML_LChar
modifier|*
specifier|const
name|message
index|[]
init|=
block|{
literal|0
block|,
name|XML_L
argument_list|(
literal|"out of memory"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"syntax error"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"no element found"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"not well-formed (invalid token)"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"unclosed token"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"partial character"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"mismatched tag"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"duplicate attribute"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"junk after document element"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"illegal parameter entity reference"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"undefined entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"recursive entity reference"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"asynchronous entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"reference to invalid character number"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"reference to binary entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"reference to external entity in attribute"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"XML or text declaration not at start of entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"unknown encoding"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"encoding specified in XML declaration is incorrect"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"unclosed CDATA section"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"error in processing external entity reference"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"document is not standalone"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"unexpected parser state - please send a bug report"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"entity declared in parameter entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"requested feature requires XML_DTD support in Expat"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"cannot change setting once parsing has begun"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"unbound prefix"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"must not undeclare prefix"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"incomplete markup in parameter entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"XML declaration not well-formed"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"text declaration not well-formed"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"illegal character(s) in public id"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"parser suspended"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"parser not suspended"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"parsing aborted"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"parsing finished"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"cannot suspend in external parameter entity"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"reserved prefix (xml) must not be undeclared or bound to another namespace name"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"reserved prefix (xmlns) must not be declared or undeclared"
argument_list|)
block|,
name|XML_L
argument_list|(
literal|"prefix must not be bound to one of the reserved namespace names"
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|>
literal|0
operator|&&
name|code
operator|<
sizeof|sizeof
argument_list|(
name|message
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|message
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|message
index|[
name|code
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|XML_LChar
modifier|*
name|XMLCALL
name|XML_ExpatVersion
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* V1 is used to string-ize the version number. However, it would      string-ize the actual version macro *names* unless we get them      substituted before being passed to V1. CPP is defined to expand      a macro, then rescan for more expansions. Thus, we use V2 to expand      the version macros, then CPP will expand the resulting V1() macro      with the correct numerals. */
comment|/* ### I'm assuming cpp is portable in this respect... */
define|#
directive|define
name|V1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
define|#
directive|define
name|V2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|XML_L("expat_")V1(a,b,c)
return|return
name|V2
argument_list|(
name|XML_MAJOR_VERSION
argument_list|,
name|XML_MINOR_VERSION
argument_list|,
name|XML_MICRO_VERSION
argument_list|)
return|;
undef|#
directive|undef
name|V1
undef|#
directive|undef
name|V2
block|}
end_function

begin_function
name|XML_Expat_Version
name|XMLCALL
name|XML_ExpatVersionInfo
parameter_list|(
name|void
parameter_list|)
block|{
name|XML_Expat_Version
name|version
decl_stmt|;
name|version
operator|.
name|major
operator|=
name|XML_MAJOR_VERSION
expr_stmt|;
name|version
operator|.
name|minor
operator|=
name|XML_MINOR_VERSION
expr_stmt|;
name|version
operator|.
name|micro
operator|=
name|XML_MICRO_VERSION
expr_stmt|;
return|return
name|version
return|;
block|}
end_function

begin_function
specifier|const
name|XML_Feature
modifier|*
name|XMLCALL
name|XML_GetFeatureList
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|XML_Feature
name|features
index|[]
init|=
block|{
block|{
name|XML_FEATURE_SIZEOF_XML_CHAR
block|,
name|XML_L
argument_list|(
literal|"sizeof(XML_Char)"
argument_list|)
block|,
expr|sizeof
operator|(
name|XML_Char
operator|)
block|}
block|,
block|{
name|XML_FEATURE_SIZEOF_XML_LCHAR
block|,
name|XML_L
argument_list|(
literal|"sizeof(XML_LChar)"
argument_list|)
block|,
expr|sizeof
operator|(
name|XML_LChar
operator|)
block|}
block|,
ifdef|#
directive|ifdef
name|XML_UNICODE
block|{
name|XML_FEATURE_UNICODE
block|,
name|XML_L
argument_list|(
literal|"XML_UNICODE"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_UNICODE_WCHAR_T
block|{
name|XML_FEATURE_UNICODE_WCHAR_T
block|,
name|XML_L
argument_list|(
literal|"XML_UNICODE_WCHAR_T"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_DTD
block|{
name|XML_FEATURE_DTD
block|,
name|XML_L
argument_list|(
literal|"XML_DTD"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_CONTEXT_BYTES
block|{
name|XML_FEATURE_CONTEXT_BYTES
block|,
name|XML_L
argument_list|(
literal|"XML_CONTEXT_BYTES"
argument_list|)
block|,
name|XML_CONTEXT_BYTES
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_MIN_SIZE
block|{
name|XML_FEATURE_MIN_SIZE
block|,
name|XML_L
argument_list|(
literal|"XML_MIN_SIZE"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_NS
block|{
name|XML_FEATURE_NS
block|,
name|XML_L
argument_list|(
literal|"XML_NS"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XML_LARGE_SIZE
block|{
name|XML_FEATURE_LARGE_SIZE
block|,
name|XML_L
argument_list|(
literal|"XML_LARGE_SIZE"
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|XML_FEATURE_END
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
return|return
name|features
return|;
block|}
end_function

begin_comment
comment|/* Initially tag->rawName always points into the parse buffer;    for those TAG instances opened while the current parse buffer was    processed, and not yet closed, we need to store tag->rawName in a more    permanent location, since the parse buffer is about to be discarded. */
end_comment

begin_function
specifier|static
name|XML_Bool
name|storeRawNames
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|TAG
modifier|*
name|tag
init|=
name|tagStack
decl_stmt|;
while|while
condition|(
name|tag
condition|)
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|nameLen
init|=
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|*
operator|(
name|tag
operator|->
name|name
operator|.
name|strLen
operator|+
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|rawNameBuf
init|=
name|tag
operator|->
name|buf
operator|+
name|nameLen
decl_stmt|;
comment|/* Stop if already stored.  Since tagStack is a stack, we can stop        at the first entry that has already been copied; everything        below it in the stack is already been accounted for in a        previous call to this function.     */
if|if
condition|(
name|tag
operator|->
name|rawName
operator|==
name|rawNameBuf
condition|)
break|break;
comment|/* For re-use purposes we need to ensure that the        size of tag->buf is a multiple of sizeof(XML_Char).     */
name|bufSize
operator|=
name|nameLen
operator|+
name|ROUND_UP
argument_list|(
name|tag
operator|->
name|rawNameLength
argument_list|,
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufSize
operator|>
name|tag
operator|->
name|bufEnd
operator|-
name|tag
operator|->
name|buf
condition|)
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|REALLOC
argument_list|(
name|tag
operator|->
name|buf
argument_list|,
name|bufSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_FALSE
return|;
comment|/* if tag->name.str points to tag->buf (only when namespace          processing is off) then we have to update it       */
if|if
condition|(
name|tag
operator|->
name|name
operator|.
name|str
operator|==
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|buf
condition|)
name|tag
operator|->
name|name
operator|.
name|str
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|temp
expr_stmt|;
comment|/* if tag->name.localPart is set (when namespace processing is on)          then update it as well, since it will always point into tag->buf       */
if|if
condition|(
name|tag
operator|->
name|name
operator|.
name|localPart
condition|)
name|tag
operator|->
name|name
operator|.
name|localPart
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|temp
operator|+
operator|(
name|tag
operator|->
name|name
operator|.
name|localPart
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|buf
operator|)
expr_stmt|;
name|tag
operator|->
name|buf
operator|=
name|temp
expr_stmt|;
name|tag
operator|->
name|bufEnd
operator|=
name|temp
operator|+
name|bufSize
expr_stmt|;
name|rawNameBuf
operator|=
name|temp
operator|+
name|nameLen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rawNameBuf
argument_list|,
name|tag
operator|->
name|rawName
argument_list|,
name|tag
operator|->
name|rawNameLength
argument_list|)
expr_stmt|;
name|tag
operator|->
name|rawName
operator|=
name|rawNameBuf
expr_stmt|;
name|tag
operator|=
name|tag
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|XML_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|contentProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|doContent
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|encoding
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|XML_ERROR_NONE
condition|)
block|{
if|if
condition|(
operator|!
name|storeRawNames
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalEntityInitProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|initializeEncoding
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
name|processor
operator|=
name|externalEntityInitProcessor2
expr_stmt|;
return|return
name|externalEntityInitProcessor2
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalEntityInitProcessor2
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|start
decl_stmt|;
comment|/* XmlContentTok doesn't always set the last arg */
name|int
name|tok
init|=
name|XmlContentTok
argument_list|(
name|encoding
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_BOM
case|:
comment|/* If we are at the end of the buffer, this would cause the next stage,        i.e. externalEntityInitProcessor3, to pass control directly to        doContent (by detecting XML_TOK_NONE) without processing any xml text        declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.     */
if|if
condition|(
name|next
operator|==
name|end
operator|&&
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|endPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
name|start
operator|=
name|next
expr_stmt|;
break|break;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|endPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
name|eventPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|endPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
name|eventPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
block|}
name|processor
operator|=
name|externalEntityInitProcessor3
expr_stmt|;
return|return
name|externalEntityInitProcessor3
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalEntityInitProcessor3
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|int
name|tok
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
init|=
name|start
decl_stmt|;
comment|/* XmlContentTok doesn't always set the last arg */
name|eventPtr
operator|=
name|start
expr_stmt|;
name|tok
operator|=
name|XmlContentTok
argument_list|(
name|encoding
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|eventEndPtr
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_XML_DECL
case|:
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
name|result
operator|=
name|processXmlDecl
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|start
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|endPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|endPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|endPtr
operator|=
name|start
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
block|}
name|processor
operator|=
name|externalEntityContentProcessor
expr_stmt|;
name|tagLevel
operator|=
literal|1
expr_stmt|;
return|return
name|externalEntityContentProcessor
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalEntityContentProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|doContent
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|encoding
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|XML_ERROR_NONE
condition|)
block|{
if|if
condition|(
operator|!
name|storeRawNames
argument_list|(
name|parser
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|doContent
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|startTagLevel
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
block|{
comment|/* save one level of indirection */
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventPP
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventEndPP
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
block|{
name|eventPP
operator|=
operator|&
name|eventPtr
expr_stmt|;
name|eventEndPP
operator|=
operator|&
name|eventEndPtr
expr_stmt|;
block|}
else|else
block|{
name|eventPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventPtr
operator|)
expr_stmt|;
name|eventEndPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventEndPtr
operator|)
expr_stmt|;
block|}
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|s
decl_stmt|;
comment|/* XmlContentTok doesn't always set the last arg */
name|int
name|tok
init|=
name|XmlContentTok
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
operator|*
name|eventEndPP
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_TRAILING_CR
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
operator|*
name|eventEndPP
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|characterDataHandler
condition|)
block|{
name|XML_Char
name|c
init|=
literal|0xA
decl_stmt|;
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* We are at the end of the final buffer, should we check for           XML_SUSPENDED, XML_FINISHED?        */
if|if
condition|(
name|startTagLevel
operator|==
literal|0
condition|)
return|return
name|XML_ERROR_NO_ELEMENTS
return|;
if|if
condition|(
name|tagLevel
operator|!=
name|startTagLevel
condition|)
return|return
name|XML_ERROR_ASYNC_ENTITY
return|;
operator|*
name|nextPtr
operator|=
name|end
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_NONE
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
if|if
condition|(
name|startTagLevel
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tagLevel
operator|!=
name|startTagLevel
condition|)
return|return
name|XML_ERROR_ASYNC_ENTITY
return|;
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_NO_ELEMENTS
return|;
case|case
name|XML_TOK_INVALID
case|:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_ENTITY_REF
case|:
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|ENTITY
modifier|*
name|entity
decl_stmt|;
name|XML_Char
name|ch
init|=
operator|(
name|XML_Char
operator|)
name|XmlPredefinedEntityName
argument_list|(
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
condition|)
block|{
if|if
condition|(
name|characterDataHandler
condition|)
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|name
operator|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|entity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|generalEntities
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* First, determine if a check for an existing declaration is needed;            if yes, check that the entity exists, and that it is internal,            otherwise call the skipped entity or default handler.         */
if|if
condition|(
operator|!
name|dtd
operator|->
name|hasParamEntityRefs
operator|||
name|dtd
operator|->
name|standalone
condition|)
block|{
if|if
condition|(
operator|!
name|entity
condition|)
return|return
name|XML_ERROR_UNDEFINED_ENTITY
return|;
elseif|else
if|if
condition|(
operator|!
name|entity
operator|->
name|is_internal
condition|)
return|return
name|XML_ERROR_ENTITY_DECLARED_IN_PE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entity
condition|)
block|{
if|if
condition|(
name|skippedEntityHandler
condition|)
name|skippedEntityHandler
argument_list|(
name|handlerArg
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entity
operator|->
name|open
condition|)
return|return
name|XML_ERROR_RECURSIVE_ENTITY_REF
return|;
if|if
condition|(
name|entity
operator|->
name|notation
condition|)
return|return
name|XML_ERROR_BINARY_ENTITY_REF
return|;
if|if
condition|(
name|entity
operator|->
name|textPtr
condition|)
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|defaultExpandInternalEntities
condition|)
block|{
if|if
condition|(
name|skippedEntityHandler
condition|)
name|skippedEntityHandler
argument_list|(
name|handlerArg
argument_list|,
name|entity
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|processInternalEntity
argument_list|(
name|parser
argument_list|,
name|entity
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|externalEntityRefHandler
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|context
decl_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
name|context
operator|=
name|getContext
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
operator|!
name|externalEntityRefHandler
argument_list|(
name|externalEntityRefHandlerArg
argument_list|,
name|context
argument_list|,
name|entity
operator|->
name|base
argument_list|,
name|entity
operator|->
name|systemId
argument_list|,
name|entity
operator|->
name|publicId
argument_list|)
condition|)
return|return
name|XML_ERROR_EXTERNAL_ENTITY_HANDLING
return|;
name|poolDiscard
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XML_TOK_START_TAG_NO_ATTS
case|:
comment|/* fall through */
case|case
name|XML_TOK_START_TAG_WITH_ATTS
case|:
block|{
name|TAG
modifier|*
name|tag
decl_stmt|;
name|enum
name|XML_Error
name|result
decl_stmt|;
name|XML_Char
modifier|*
name|toPtr
decl_stmt|;
if|if
condition|(
name|freeTagList
condition|)
block|{
name|tag
operator|=
name|freeTagList
expr_stmt|;
name|freeTagList
operator|=
name|freeTagList
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
operator|(
name|TAG
operator|*
operator|)
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|tag
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|INIT_TAG_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|->
name|buf
condition|)
block|{
name|FREE
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|tag
operator|->
name|bufEnd
operator|=
name|tag
operator|->
name|buf
operator|+
name|INIT_TAG_BUF_SIZE
expr_stmt|;
block|}
name|tag
operator|->
name|bindings
operator|=
name|NULL
expr_stmt|;
name|tag
operator|->
name|parent
operator|=
name|tagStack
expr_stmt|;
name|tagStack
operator|=
name|tag
expr_stmt|;
name|tag
operator|->
name|name
operator|.
name|localPart
operator|=
name|NULL
expr_stmt|;
name|tag
operator|->
name|name
operator|.
name|prefix
operator|=
name|NULL
expr_stmt|;
name|tag
operator|->
name|rawName
operator|=
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
name|tag
operator|->
name|rawNameLength
operator|=
name|XmlNameLength
argument_list|(
name|enc
argument_list|,
name|tag
operator|->
name|rawName
argument_list|)
expr_stmt|;
operator|++
name|tagLevel
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|rawNameEnd
init|=
name|tag
operator|->
name|rawName
operator|+
name|tag
operator|->
name|rawNameLength
decl_stmt|;
specifier|const
name|char
modifier|*
name|fromPtr
init|=
name|tag
operator|->
name|rawName
decl_stmt|;
name|toPtr
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|convLen
decl_stmt|;
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|fromPtr
argument_list|,
name|rawNameEnd
argument_list|,
operator|(
name|ICHAR
operator|*
operator|*
operator|)
operator|&
name|toPtr
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|tag
operator|->
name|bufEnd
operator|-
literal|1
argument_list|)
expr_stmt|;
name|convLen
operator|=
call|(
name|int
call|)
argument_list|(
name|toPtr
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromPtr
operator|==
name|rawNameEnd
condition|)
block|{
name|tag
operator|->
name|name
operator|.
name|strLen
operator|=
name|convLen
expr_stmt|;
break|break;
block|}
name|bufSize
operator|=
call|(
name|int
call|)
argument_list|(
name|tag
operator|->
name|bufEnd
operator|-
name|tag
operator|->
name|buf
argument_list|)
operator|<<
literal|1
expr_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|REALLOC
argument_list|(
name|tag
operator|->
name|buf
argument_list|,
name|bufSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|tag
operator|->
name|buf
operator|=
name|temp
expr_stmt|;
name|tag
operator|->
name|bufEnd
operator|=
name|temp
operator|+
name|bufSize
expr_stmt|;
name|toPtr
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|temp
operator|+
name|convLen
expr_stmt|;
block|}
block|}
block|}
name|tag
operator|->
name|name
operator|.
name|str
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|buf
expr_stmt|;
operator|*
name|toPtr
operator|=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|storeAtts
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
operator|&
operator|(
name|tag
operator|->
name|name
operator|)
argument_list|,
operator|&
operator|(
name|tag
operator|->
name|bindings
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|startElementHandler
condition|)
name|startElementHandler
argument_list|(
name|handlerArg
argument_list|,
name|tag
operator|->
name|name
operator|.
name|str
argument_list|,
operator|(
specifier|const
name|XML_Char
operator|*
operator|*
operator|)
name|atts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XML_TOK_EMPTY_ELEMENT_NO_ATTS
case|:
comment|/* fall through */
case|case
name|XML_TOK_EMPTY_ELEMENT_WITH_ATTS
case|:
block|{
specifier|const
name|char
modifier|*
name|rawName
init|=
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
decl_stmt|;
name|enum
name|XML_Error
name|result
decl_stmt|;
name|BINDING
modifier|*
name|bindings
init|=
name|NULL
decl_stmt|;
name|XML_Bool
name|noElmHandlers
init|=
name|XML_TRUE
decl_stmt|;
name|TAG_NAME
name|name
decl_stmt|;
name|name
operator|.
name|str
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|rawName
argument_list|,
name|rawName
operator|+
name|XmlNameLength
argument_list|(
name|enc
argument_list|,
name|rawName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|str
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|result
operator|=
name|storeAtts
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|bindings
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
if|if
condition|(
name|startElementHandler
condition|)
block|{
name|startElementHandler
argument_list|(
name|handlerArg
argument_list|,
name|name
operator|.
name|str
argument_list|,
operator|(
specifier|const
name|XML_Char
operator|*
operator|*
operator|)
name|atts
argument_list|)
expr_stmt|;
name|noElmHandlers
operator|=
name|XML_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|endElementHandler
condition|)
block|{
if|if
condition|(
name|startElementHandler
condition|)
operator|*
name|eventPP
operator|=
operator|*
name|eventEndPP
expr_stmt|;
name|endElementHandler
argument_list|(
name|handlerArg
argument_list|,
name|name
operator|.
name|str
argument_list|)
expr_stmt|;
name|noElmHandlers
operator|=
name|XML_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|noElmHandlers
operator|&&
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
while|while
condition|(
name|bindings
condition|)
block|{
name|BINDING
modifier|*
name|b
init|=
name|bindings
decl_stmt|;
if|if
condition|(
name|endNamespaceDeclHandler
condition|)
name|endNamespaceDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|b
operator|->
name|prefix
operator|->
name|name
argument_list|)
expr_stmt|;
name|bindings
operator|=
name|bindings
operator|->
name|nextTagBinding
expr_stmt|;
name|b
operator|->
name|nextTagBinding
operator|=
name|freeBindingList
expr_stmt|;
name|freeBindingList
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|prefix
operator|->
name|binding
operator|=
name|b
operator|->
name|prevPrefixBinding
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tagLevel
operator|==
literal|0
condition|)
return|return
name|epilogProcessor
argument_list|(
name|parser
argument_list|,
name|next
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
break|break;
case|case
name|XML_TOK_END_TAG
case|:
if|if
condition|(
name|tagLevel
operator|==
name|startTagLevel
condition|)
return|return
name|XML_ERROR_ASYNC_ENTITY
return|;
else|else
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|rawName
decl_stmt|;
name|TAG
modifier|*
name|tag
init|=
name|tagStack
decl_stmt|;
name|tagStack
operator|=
name|tag
operator|->
name|parent
expr_stmt|;
name|tag
operator|->
name|parent
operator|=
name|freeTagList
expr_stmt|;
name|freeTagList
operator|=
name|tag
expr_stmt|;
name|rawName
operator|=
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
operator|*
literal|2
expr_stmt|;
name|len
operator|=
name|XmlNameLength
argument_list|(
name|enc
argument_list|,
name|rawName
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|tag
operator|->
name|rawNameLength
operator|||
name|memcmp
argument_list|(
name|tag
operator|->
name|rawName
argument_list|,
name|rawName
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|eventPP
operator|=
name|rawName
expr_stmt|;
return|return
name|XML_ERROR_TAG_MISMATCH
return|;
block|}
operator|--
name|tagLevel
expr_stmt|;
if|if
condition|(
name|endElementHandler
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|localPart
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|prefix
decl_stmt|;
name|XML_Char
modifier|*
name|uri
decl_stmt|;
name|localPart
operator|=
name|tag
operator|->
name|name
operator|.
name|localPart
expr_stmt|;
if|if
condition|(
name|ns
operator|&&
name|localPart
condition|)
block|{
comment|/* localPart and prefix may have been overwritten in                tag->name.str, since this points to the binding->uri                buffer which gets re-used; so we have to add them again             */
name|uri
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|name
operator|.
name|str
operator|+
name|tag
operator|->
name|name
operator|.
name|uriLen
expr_stmt|;
comment|/* don't need to check for space - already done in storeAtts() */
while|while
condition|(
operator|*
name|localPart
condition|)
operator|*
name|uri
operator|++
operator|=
operator|*
name|localPart
operator|++
expr_stmt|;
name|prefix
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|tag
operator|->
name|name
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|ns_triplets
operator|&&
name|prefix
condition|)
block|{
operator|*
name|uri
operator|++
operator|=
name|namespaceSeparator
expr_stmt|;
while|while
condition|(
operator|*
name|prefix
condition|)
operator|*
name|uri
operator|++
operator|=
operator|*
name|prefix
operator|++
expr_stmt|;
block|}
operator|*
name|uri
operator|=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
name|endElementHandler
argument_list|(
name|handlerArg
argument_list|,
name|tag
operator|->
name|name
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|tag
operator|->
name|bindings
condition|)
block|{
name|BINDING
modifier|*
name|b
init|=
name|tag
operator|->
name|bindings
decl_stmt|;
if|if
condition|(
name|endNamespaceDeclHandler
condition|)
name|endNamespaceDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|b
operator|->
name|prefix
operator|->
name|name
argument_list|)
expr_stmt|;
name|tag
operator|->
name|bindings
operator|=
name|tag
operator|->
name|bindings
operator|->
name|nextTagBinding
expr_stmt|;
name|b
operator|->
name|nextTagBinding
operator|=
name|freeBindingList
expr_stmt|;
name|freeBindingList
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|prefix
operator|->
name|binding
operator|=
name|b
operator|->
name|prevPrefixBinding
expr_stmt|;
block|}
if|if
condition|(
name|tagLevel
operator|==
literal|0
condition|)
return|return
name|epilogProcessor
argument_list|(
name|parser
argument_list|,
name|next
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
block|}
break|break;
case|case
name|XML_TOK_CHAR_REF
case|:
block|{
name|int
name|n
init|=
name|XmlCharRefNumber
argument_list|(
name|enc
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|XML_ERROR_BAD_CHAR_REF
return|;
if|if
condition|(
name|characterDataHandler
condition|)
block|{
name|XML_Char
name|buf
index|[
name|XML_ENCODE_MAX
index|]
decl_stmt|;
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
name|buf
argument_list|,
name|XmlEncode
argument_list|(
name|n
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XML_TOK_XML_DECL
case|:
return|return
name|XML_ERROR_MISPLACED_XML_PI
return|;
case|case
name|XML_TOK_DATA_NEWLINE
case|:
if|if
condition|(
name|characterDataHandler
condition|)
block|{
name|XML_Char
name|c
init|=
literal|0xA
decl_stmt|;
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_TOK_CDATA_SECT_OPEN
case|:
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
if|if
condition|(
name|startCdataSectionHandler
condition|)
name|startCdataSectionHandler
argument_list|(
name|handlerArg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Suppose you doing a transformation on a document that involves            changing only the character data.  You set up a defaultHandler            and a characterDataHandler.  The defaultHandler simply copies            characters through.  The characterDataHandler does the            transformation and writes the characters out escaping them as            necessary.  This case will fail to work if we leave out the            following two lines (because& and< inside CDATA sections will            be incorrectly escaped).             However, now we have a start/endCdataSectionHandler, so it seems            easier to let the user deal with this.         */
if|else if (characterDataHandler)           characterDataHandler(handlerArg, dataBuf, 0);
endif|#
directive|endif
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|result
operator|=
name|doCdataSection
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
operator|&
name|next
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|,
name|haveMore
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
operator|!
name|next
condition|)
block|{
name|processor
operator|=
name|cdataSectionProcessor
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
break|break;
case|case
name|XML_TOK_TRAILING_RSQB
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
if|if
condition|(
name|characterDataHandler
condition|)
block|{
if|if
condition|(
name|MUST_CONVERT
argument_list|(
name|enc
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|ICHAR
modifier|*
name|dataPtr
init|=
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
decl_stmt|;
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|dataPtr
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|dataBufEnd
argument_list|)
expr_stmt|;
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
name|dataBuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dataPtr
operator|-
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|XML_Char
operator|*
operator|)
name|end
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* We are at the end of the final buffer, should we check for           XML_SUSPENDED, XML_FINISHED?        */
if|if
condition|(
name|startTagLevel
operator|==
literal|0
condition|)
block|{
operator|*
name|eventPP
operator|=
name|end
expr_stmt|;
return|return
name|XML_ERROR_NO_ELEMENTS
return|;
block|}
if|if
condition|(
name|tagLevel
operator|!=
name|startTagLevel
condition|)
block|{
operator|*
name|eventPP
operator|=
name|end
expr_stmt|;
return|return
name|XML_ERROR_ASYNC_ENTITY
return|;
block|}
operator|*
name|nextPtr
operator|=
name|end
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_DATA_CHARS
case|:
block|{
name|XML_CharacterDataHandler
name|charDataHandler
init|=
name|characterDataHandler
decl_stmt|;
if|if
condition|(
name|charDataHandler
condition|)
block|{
if|if
condition|(
name|MUST_CONVERT
argument_list|(
name|enc
argument_list|,
name|s
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|ICHAR
modifier|*
name|dataPtr
init|=
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
decl_stmt|;
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|s
argument_list|,
name|next
argument_list|,
operator|&
name|dataPtr
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|dataBufEnd
argument_list|)
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|charDataHandler
argument_list|(
name|handlerArg
argument_list|,
name|dataBuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dataPtr
operator|-
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|next
condition|)
break|break;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
block|}
block|}
else|else
name|charDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|XML_Char
operator|*
operator|)
name|next
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XML_TOK_PI
case|:
if|if
condition|(
operator|!
name|reportProcessingInstruction
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
case|case
name|XML_TOK_COMMENT
case|:
if|if
condition|(
operator|!
name|reportComment
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
default|default:
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|eventPP
operator|=
name|s
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
empty_stmt|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_comment
comment|/* Precondition: all arguments must be non-NULL;    Purpose:    - normalize attributes    - check attributes for well-formedness    - generate namespace aware attribute names (URI, prefix)    - build list of attributes for startElementHandler    - default attributes    - process namespace declarations (check and report them)    - generate namespace aware element name (URI, prefix) */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|storeAtts
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|attStr
parameter_list|,
name|TAG_NAME
modifier|*
name|tagNamePtr
parameter_list|,
name|BINDING
modifier|*
modifier|*
name|bindingsPtr
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|ELEMENT_TYPE
modifier|*
name|elementType
decl_stmt|;
name|int
name|nDefaultAtts
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
modifier|*
name|appAtts
decl_stmt|;
comment|/* the attribute list for the application */
name|int
name|attIndex
init|=
literal|0
decl_stmt|;
name|int
name|prefixLen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|XML_Char
modifier|*
name|uri
decl_stmt|;
name|int
name|nPrefixes
init|=
literal|0
decl_stmt|;
name|BINDING
modifier|*
name|binding
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|localPart
decl_stmt|;
comment|/* lookup the element type name */
name|elementType
operator|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|elementTypes
argument_list|,
name|tagNamePtr
operator|->
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elementType
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|name
init|=
name|poolCopyString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|tagNamePtr
operator|->
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|elementType
operator|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|elementTypes
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ELEMENT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elementType
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|ns
operator|&&
operator|!
name|setElementTypePrefix
argument_list|(
name|parser
argument_list|,
name|elementType
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|nDefaultAtts
operator|=
name|elementType
operator|->
name|nDefaultAtts
expr_stmt|;
comment|/* get the attributes from the tokenizer */
name|n
operator|=
name|XmlGetAttributes
argument_list|(
name|enc
argument_list|,
name|attStr
argument_list|,
name|attsSize
argument_list|,
name|atts
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|nDefaultAtts
operator|>
name|attsSize
condition|)
block|{
name|int
name|oldAttsSize
init|=
name|attsSize
decl_stmt|;
name|ATTRIBUTE
modifier|*
name|temp
decl_stmt|;
name|attsSize
operator|=
name|n
operator|+
name|nDefaultAtts
operator|+
name|INIT_ATTS_SIZE
expr_stmt|;
name|temp
operator|=
operator|(
name|ATTRIBUTE
operator|*
operator|)
name|REALLOC
argument_list|(
operator|(
name|void
operator|*
operator|)
name|atts
argument_list|,
name|attsSize
operator|*
sizeof|sizeof
argument_list|(
name|ATTRIBUTE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|atts
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|oldAttsSize
condition|)
name|XmlGetAttributes
argument_list|(
name|enc
argument_list|,
name|attStr
argument_list|,
name|n
argument_list|,
name|atts
argument_list|)
expr_stmt|;
block|}
name|appAtts
operator|=
operator|(
specifier|const
name|XML_Char
operator|*
operator|*
operator|)
name|atts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* add the name and value to the attribute list */
name|ATTRIBUTE_ID
modifier|*
name|attId
init|=
name|getAttributeId
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|name
operator|+
name|XmlNameLength
argument_list|(
name|enc
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|attId
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
comment|/* Detect duplicate attributes by their QNames. This does not work when        namespace processing is turned on and different prefixes for the same        namespace are used. For this case we have a check further down.     */
if|if
condition|(
operator|(
name|attId
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|atts
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
return|return
name|XML_ERROR_DUPLICATE_ATTRIBUTE
return|;
block|}
operator|(
name|attId
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|appAtts
index|[
name|attIndex
operator|++
index|]
operator|=
name|attId
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|atts
index|[
name|i
index|]
operator|.
name|normalized
condition|)
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
name|XML_Bool
name|isCdata
init|=
name|XML_TRUE
decl_stmt|;
comment|/* figure out whether declared as other than CDATA */
if|if
condition|(
name|attId
operator|->
name|maybeTokenized
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nDefaultAtts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|attId
operator|==
name|elementType
operator|->
name|defaultAtts
index|[
name|j
index|]
operator|.
name|id
condition|)
block|{
name|isCdata
operator|=
name|elementType
operator|->
name|defaultAtts
index|[
name|j
index|]
operator|.
name|isCdata
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* normalize the attribute value */
name|result
operator|=
name|storeAttributeValue
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|isCdata
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|valuePtr
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|valueEnd
argument_list|,
operator|&
name|tempPool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|appAtts
index|[
name|attIndex
index|]
operator|=
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the value did not need normalizing */
name|appAtts
index|[
name|attIndex
index|]
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|valuePtr
argument_list|,
name|atts
index|[
name|i
index|]
operator|.
name|valueEnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|appAtts
index|[
name|attIndex
index|]
operator|==
literal|0
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
comment|/* handle prefixed attribute names */
if|if
condition|(
name|attId
operator|->
name|prefix
condition|)
block|{
if|if
condition|(
name|attId
operator|->
name|xmlns
condition|)
block|{
comment|/* deal with namespace declarations here */
name|enum
name|XML_Error
name|result
init|=
name|addBinding
argument_list|(
name|parser
argument_list|,
name|attId
operator|->
name|prefix
argument_list|,
name|attId
argument_list|,
name|appAtts
index|[
name|attIndex
index|]
argument_list|,
name|bindingsPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
operator|--
name|attIndex
expr_stmt|;
block|}
else|else
block|{
comment|/* deal with other prefixed names later */
name|attIndex
operator|++
expr_stmt|;
name|nPrefixes
operator|++
expr_stmt|;
operator|(
name|attId
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
name|attIndex
operator|++
expr_stmt|;
block|}
comment|/* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */
name|nSpecifiedAtts
operator|=
name|attIndex
expr_stmt|;
if|if
condition|(
name|elementType
operator|->
name|idAtt
operator|&&
operator|(
name|elementType
operator|->
name|idAtt
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attIndex
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|appAtts
index|[
name|i
index|]
operator|==
name|elementType
operator|->
name|idAtt
operator|->
name|name
condition|)
block|{
name|idAttIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
else|else
name|idAttIndex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* do attribute defaulting */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nDefaultAtts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|DEFAULT_ATTRIBUTE
modifier|*
name|da
init|=
name|elementType
operator|->
name|defaultAtts
operator|+
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|da
operator|->
name|id
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
operator|&&
name|da
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|da
operator|->
name|id
operator|->
name|prefix
condition|)
block|{
if|if
condition|(
name|da
operator|->
name|id
operator|->
name|xmlns
condition|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|addBinding
argument_list|(
name|parser
argument_list|,
name|da
operator|->
name|id
operator|->
name|prefix
argument_list|,
name|da
operator|->
name|id
argument_list|,
name|da
operator|->
name|value
argument_list|,
name|bindingsPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
else|else
block|{
operator|(
name|da
operator|->
name|id
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|nPrefixes
operator|++
expr_stmt|;
name|appAtts
index|[
name|attIndex
operator|++
index|]
operator|=
name|da
operator|->
name|id
operator|->
name|name
expr_stmt|;
name|appAtts
index|[
name|attIndex
operator|++
index|]
operator|=
name|da
operator|->
name|value
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|da
operator|->
name|id
operator|->
name|name
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|appAtts
index|[
name|attIndex
operator|++
index|]
operator|=
name|da
operator|->
name|id
operator|->
name|name
expr_stmt|;
name|appAtts
index|[
name|attIndex
operator|++
index|]
operator|=
name|da
operator|->
name|value
expr_stmt|;
block|}
block|}
block|}
name|appAtts
index|[
name|attIndex
index|]
operator|=
literal|0
expr_stmt|;
comment|/* expand prefixed attribute names, check for duplicates,      and clear flags that say whether attributes were specified */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nPrefixes
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* hash table index */
name|unsigned
name|long
name|version
init|=
name|nsAttsVersion
decl_stmt|;
name|int
name|nsAttsSize
init|=
operator|(
name|int
operator|)
literal|1
operator|<<
name|nsAttsPower
decl_stmt|;
comment|/* size of hash table must be at least 2 * (# of prefixed attributes) */
if|if
condition|(
operator|(
name|nPrefixes
operator|<<
literal|1
operator|)
operator|>>
name|nsAttsPower
condition|)
block|{
comment|/* true for nsAttsPower = 0 */
name|NS_ATT
modifier|*
name|temp
decl_stmt|;
comment|/* hash table size must also be a power of 2 and>= 8 */
while|while
condition|(
name|nPrefixes
operator|>>
name|nsAttsPower
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|nsAttsPower
operator|<
literal|3
condition|)
name|nsAttsPower
operator|=
literal|3
expr_stmt|;
name|nsAttsSize
operator|=
operator|(
name|int
operator|)
literal|1
operator|<<
name|nsAttsPower
expr_stmt|;
name|temp
operator|=
operator|(
name|NS_ATT
operator|*
operator|)
name|REALLOC
argument_list|(
name|nsAtts
argument_list|,
name|nsAttsSize
operator|*
sizeof|sizeof
argument_list|(
name|NS_ATT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|nsAtts
operator|=
name|temp
expr_stmt|;
name|version
operator|=
literal|0
expr_stmt|;
comment|/* force re-initialization of nsAtts hash table */
block|}
comment|/* using a version flag saves us from initializing nsAtts every time */
if|if
condition|(
operator|!
name|version
condition|)
block|{
comment|/* initialize version flags when version wraps around */
name|version
operator|=
name|INIT_ATTS_VERSION
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nsAttsSize
init|;
name|j
operator|!=
literal|0
condition|;
control|)
name|nsAtts
index|[
operator|--
name|j
index|]
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
name|nsAttsVersion
operator|=
operator|--
name|version
expr_stmt|;
comment|/* expand prefixed names and check for duplicates */
for|for
control|(
init|;
name|i
operator|<
name|attIndex
condition|;
name|i
operator|+=
literal|2
control|)
block|{
specifier|const
name|XML_Char
modifier|*
name|s
init|=
name|appAtts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|2
condition|)
block|{
comment|/* prefixed */
name|ATTRIBUTE_ID
modifier|*
name|id
decl_stmt|;
specifier|const
name|BINDING
modifier|*
name|b
decl_stmt|;
name|unsigned
name|long
name|uriHash
init|=
literal|0
decl_stmt|;
operator|(
operator|(
name|XML_Char
operator|*
operator|)
name|s
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear flag */
name|id
operator|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|attributeIds
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|id
operator|->
name|prefix
operator|->
name|binding
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|XML_ERROR_UNBOUND_PREFIX
return|;
comment|/* as we expand the name we also calculate its hash value */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|uriLen
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|XML_Char
name|c
init|=
name|b
operator|->
name|uri
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|uriHash
operator|=
name|CHAR_HASH
argument_list|(
name|uriHash
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
operator|++
operator|!=
name|XML_T
argument_list|(
name|ASCII_COLON
argument_list|)
condition|)
empty_stmt|;
do|do
block|{
comment|/* copies null terminator */
specifier|const
name|XML_Char
name|c
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|uriHash
operator|=
name|CHAR_HASH
argument_list|(
name|uriHash
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
block|{
comment|/* Check hash table for duplicate of expanded name (uriName).              Derived from code in lookup(HASH_TABLE *table, ...).           */
name|unsigned
name|char
name|step
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
name|nsAttsSize
operator|-
literal|1
decl_stmt|;
name|j
operator|=
name|uriHash
operator|&
name|mask
expr_stmt|;
comment|/* index into hash table */
while|while
condition|(
name|nsAtts
index|[
name|j
index|]
operator|.
name|version
operator|==
name|version
condition|)
block|{
comment|/* for speed we compare stored hash values first */
if|if
condition|(
name|uriHash
operator|==
name|nsAtts
index|[
name|j
index|]
operator|.
name|hash
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|s1
init|=
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|s2
init|=
name|nsAtts
index|[
name|j
index|]
operator|.
name|uriName
decl_stmt|;
comment|/* s1 is null terminated, but not s2 */
for|for
control|(
init|;
operator|*
name|s1
operator|==
operator|*
name|s2
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|;
name|s1
operator|++
operator|,
name|s2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|0
condition|)
return|return
name|XML_ERROR_DUPLICATE_ATTRIBUTE
return|;
block|}
if|if
condition|(
operator|!
name|step
condition|)
name|step
operator|=
name|PROBE_STEP
argument_list|(
name|uriHash
argument_list|,
name|mask
argument_list|,
name|nsAttsPower
argument_list|)
expr_stmt|;
name|j
operator|<
name|step
condition|?
operator|(
name|j
operator|+=
name|nsAttsSize
operator|-
name|step
operator|)
else|:
operator|(
name|j
operator|-=
name|step
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ns_triplets
condition|)
block|{
comment|/* append namespace separator and prefix */
name|tempPool
operator|.
name|ptr
index|[
operator|-
literal|1
index|]
operator|=
name|namespaceSeparator
expr_stmt|;
name|s
operator|=
name|b
operator|->
name|prefix
operator|->
name|name
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
block|}
comment|/* store expanded name in attribute list */
name|s
operator|=
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|appAtts
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
comment|/* fill empty slot with new version, uriName and hash value */
name|nsAtts
index|[
name|j
index|]
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|nsAtts
index|[
name|j
index|]
operator|.
name|hash
operator|=
name|uriHash
expr_stmt|;
name|nsAtts
index|[
name|j
index|]
operator|.
name|uriName
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|nPrefixes
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* not prefixed */
operator|(
operator|(
name|XML_Char
operator|*
operator|)
name|s
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear flag */
block|}
block|}
comment|/* clear flags for the remaining attributes */
for|for
control|(
init|;
name|i
operator|<
name|attIndex
condition|;
name|i
operator|+=
literal|2
control|)
operator|(
operator|(
name|XML_Char
operator|*
operator|)
operator|(
name|appAtts
index|[
name|i
index|]
operator|)
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|binding
operator|=
operator|*
name|bindingsPtr
init|;
name|binding
condition|;
name|binding
operator|=
name|binding
operator|->
name|nextTagBinding
control|)
name|binding
operator|->
name|attId
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
return|return
name|XML_ERROR_NONE
return|;
comment|/* expand the element type name */
if|if
condition|(
name|elementType
operator|->
name|prefix
condition|)
block|{
name|binding
operator|=
name|elementType
operator|->
name|prefix
operator|->
name|binding
expr_stmt|;
if|if
condition|(
operator|!
name|binding
condition|)
return|return
name|XML_ERROR_UNBOUND_PREFIX
return|;
name|localPart
operator|=
name|tagNamePtr
operator|->
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|localPart
operator|++
operator|!=
name|XML_T
argument_list|(
name|ASCII_COLON
argument_list|)
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtd
operator|->
name|defaultPrefix
operator|.
name|binding
condition|)
block|{
name|binding
operator|=
name|dtd
operator|->
name|defaultPrefix
operator|.
name|binding
expr_stmt|;
name|localPart
operator|=
name|tagNamePtr
operator|->
name|str
expr_stmt|;
block|}
else|else
return|return
name|XML_ERROR_NONE
return|;
name|prefixLen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ns_triplets
operator|&&
name|binding
operator|->
name|prefix
operator|->
name|name
condition|)
block|{
for|for
control|(
init|;
name|binding
operator|->
name|prefix
operator|->
name|name
index|[
name|prefixLen
operator|++
index|]
condition|;
control|)
empty_stmt|;
comment|/* prefixLen includes null terminator */
block|}
name|tagNamePtr
operator|->
name|localPart
operator|=
name|localPart
expr_stmt|;
name|tagNamePtr
operator|->
name|uriLen
operator|=
name|binding
operator|->
name|uriLen
expr_stmt|;
name|tagNamePtr
operator|->
name|prefix
operator|=
name|binding
operator|->
name|prefix
operator|->
name|name
expr_stmt|;
name|tagNamePtr
operator|->
name|prefixLen
operator|=
name|prefixLen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|localPart
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
comment|/* i includes null terminator */
name|n
operator|=
name|i
operator|+
name|binding
operator|->
name|uriLen
operator|+
name|prefixLen
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|binding
operator|->
name|uriAlloc
condition|)
block|{
name|TAG
modifier|*
name|p
decl_stmt|;
name|uri
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|MALLOC
argument_list|(
operator|(
name|n
operator|+
name|EXPAND_SPARE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uri
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|binding
operator|->
name|uriAlloc
operator|=
name|n
operator|+
name|EXPAND_SPARE
expr_stmt|;
name|memcpy
argument_list|(
name|uri
argument_list|,
name|binding
operator|->
name|uri
argument_list|,
name|binding
operator|->
name|uriLen
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tagStack
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
if|if
condition|(
name|p
operator|->
name|name
operator|.
name|str
operator|==
name|binding
operator|->
name|uri
condition|)
name|p
operator|->
name|name
operator|.
name|str
operator|=
name|uri
expr_stmt|;
name|FREE
argument_list|(
name|binding
operator|->
name|uri
argument_list|)
expr_stmt|;
name|binding
operator|->
name|uri
operator|=
name|uri
expr_stmt|;
block|}
comment|/* if namespaceSeparator != '\0' then uri includes it already */
name|uri
operator|=
name|binding
operator|->
name|uri
operator|+
name|binding
operator|->
name|uriLen
expr_stmt|;
name|memcpy
argument_list|(
name|uri
argument_list|,
name|localPart
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we always have a namespace separator between localPart and prefix */
if|if
condition|(
name|prefixLen
condition|)
block|{
name|uri
operator|+=
name|i
operator|-
literal|1
expr_stmt|;
operator|*
name|uri
operator|=
name|namespaceSeparator
expr_stmt|;
comment|/* replace null terminator */
name|memcpy
argument_list|(
name|uri
operator|+
literal|1
argument_list|,
name|binding
operator|->
name|prefix
operator|->
name|name
argument_list|,
name|prefixLen
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tagNamePtr
operator|->
name|str
operator|=
name|binding
operator|->
name|uri
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
end_function

begin_comment
comment|/* addBinding() overwrites the value of prefix->binding without checking.    Therefore one must keep track of the old value outside of addBinding(). */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|addBinding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|PREFIX
modifier|*
name|prefix
parameter_list|,
specifier|const
name|ATTRIBUTE_ID
modifier|*
name|attId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|uri
parameter_list|,
name|BINDING
modifier|*
modifier|*
name|bindingsPtr
parameter_list|)
block|{
specifier|static
specifier|const
name|XML_Char
name|xmlNamespace
index|[]
init|=
block|{
name|ASCII_h
block|,
name|ASCII_t
block|,
name|ASCII_t
block|,
name|ASCII_p
block|,
name|ASCII_COLON
block|,
name|ASCII_SLASH
block|,
name|ASCII_SLASH
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_PERIOD
block|,
name|ASCII_w
block|,
name|ASCII_3
block|,
name|ASCII_PERIOD
block|,
name|ASCII_o
block|,
name|ASCII_r
block|,
name|ASCII_g
block|,
name|ASCII_SLASH
block|,
name|ASCII_X
block|,
name|ASCII_M
block|,
name|ASCII_L
block|,
name|ASCII_SLASH
block|,
name|ASCII_1
block|,
name|ASCII_9
block|,
name|ASCII_9
block|,
name|ASCII_8
block|,
name|ASCII_SLASH
block|,
name|ASCII_n
block|,
name|ASCII_a
block|,
name|ASCII_m
block|,
name|ASCII_e
block|,
name|ASCII_s
block|,
name|ASCII_p
block|,
name|ASCII_a
block|,
name|ASCII_c
block|,
name|ASCII_e
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|xmlLen
init|=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|xmlNamespace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|xmlnsNamespace
index|[]
init|=
block|{
name|ASCII_h
block|,
name|ASCII_t
block|,
name|ASCII_t
block|,
name|ASCII_p
block|,
name|ASCII_COLON
block|,
name|ASCII_SLASH
block|,
name|ASCII_SLASH
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_w
block|,
name|ASCII_PERIOD
block|,
name|ASCII_w
block|,
name|ASCII_3
block|,
name|ASCII_PERIOD
block|,
name|ASCII_o
block|,
name|ASCII_r
block|,
name|ASCII_g
block|,
name|ASCII_SLASH
block|,
name|ASCII_2
block|,
name|ASCII_0
block|,
name|ASCII_0
block|,
name|ASCII_0
block|,
name|ASCII_SLASH
block|,
name|ASCII_x
block|,
name|ASCII_m
block|,
name|ASCII_l
block|,
name|ASCII_n
block|,
name|ASCII_s
block|,
name|ASCII_SLASH
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|xmlnsLen
init|=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|xmlnsNamespace
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|-
literal|1
decl_stmt|;
name|XML_Bool
name|mustBeXML
init|=
name|XML_FALSE
decl_stmt|;
name|XML_Bool
name|isXML
init|=
name|XML_TRUE
decl_stmt|;
name|XML_Bool
name|isXMLNS
init|=
name|XML_TRUE
decl_stmt|;
name|BINDING
modifier|*
name|b
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */
if|if
condition|(
operator|*
name|uri
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
operator|&&
name|prefix
operator|->
name|name
condition|)
return|return
name|XML_ERROR_UNDECLARING_PREFIX
return|;
if|if
condition|(
name|prefix
operator|->
name|name
operator|&&
name|prefix
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_x
argument_list|)
operator|&&
name|prefix
operator|->
name|name
index|[
literal|1
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_m
argument_list|)
operator|&&
name|prefix
operator|->
name|name
index|[
literal|2
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_l
argument_list|)
condition|)
block|{
comment|/* Not allowed to bind xmlns */
if|if
condition|(
name|prefix
operator|->
name|name
index|[
literal|3
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_n
argument_list|)
operator|&&
name|prefix
operator|->
name|name
index|[
literal|4
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_s
argument_list|)
operator|&&
name|prefix
operator|->
name|name
index|[
literal|5
index|]
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|XML_ERROR_RESERVED_PREFIX_XMLNS
return|;
if|if
condition|(
name|prefix
operator|->
name|name
index|[
literal|3
index|]
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
name|mustBeXML
operator|=
name|XML_TRUE
expr_stmt|;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|uri
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|isXML
operator|&&
operator|(
name|len
operator|>
name|xmlLen
operator|||
name|uri
index|[
name|len
index|]
operator|!=
name|xmlNamespace
index|[
name|len
index|]
operator|)
condition|)
name|isXML
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|mustBeXML
operator|&&
name|isXMLNS
operator|&&
operator|(
name|len
operator|>
name|xmlnsLen
operator|||
name|uri
index|[
name|len
index|]
operator|!=
name|xmlnsNamespace
index|[
name|len
index|]
operator|)
condition|)
name|isXMLNS
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|isXML
operator|=
name|isXML
operator|&&
name|len
operator|==
name|xmlLen
expr_stmt|;
name|isXMLNS
operator|=
name|isXMLNS
operator|&&
name|len
operator|==
name|xmlnsLen
expr_stmt|;
if|if
condition|(
name|mustBeXML
operator|!=
name|isXML
condition|)
return|return
name|mustBeXML
condition|?
name|XML_ERROR_RESERVED_PREFIX_XML
else|:
name|XML_ERROR_RESERVED_NAMESPACE_URI
return|;
if|if
condition|(
name|isXMLNS
condition|)
return|return
name|XML_ERROR_RESERVED_NAMESPACE_URI
return|;
if|if
condition|(
name|namespaceSeparator
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|freeBindingList
condition|)
block|{
name|b
operator|=
name|freeBindingList
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|b
operator|->
name|uriAlloc
condition|)
block|{
name|XML_Char
modifier|*
name|temp
init|=
operator|(
name|XML_Char
operator|*
operator|)
name|REALLOC
argument_list|(
name|b
operator|->
name|uri
argument_list|,
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|*
operator|(
name|len
operator|+
name|EXPAND_SPARE
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|b
operator|->
name|uri
operator|=
name|temp
expr_stmt|;
name|b
operator|->
name|uriAlloc
operator|=
name|len
operator|+
name|EXPAND_SPARE
expr_stmt|;
block|}
name|freeBindingList
operator|=
name|b
operator|->
name|nextTagBinding
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
operator|(
name|BINDING
operator|*
operator|)
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|BINDING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|b
operator|->
name|uri
operator|=
operator|(
name|XML_Char
operator|*
operator|)
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|*
operator|(
name|len
operator|+
name|EXPAND_SPARE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|uri
condition|)
block|{
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|b
operator|->
name|uriAlloc
operator|=
name|len
operator|+
name|EXPAND_SPARE
expr_stmt|;
block|}
name|b
operator|->
name|uriLen
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|uri
argument_list|,
name|uri
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespaceSeparator
condition|)
name|b
operator|->
name|uri
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|namespaceSeparator
expr_stmt|;
name|b
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|b
operator|->
name|attId
operator|=
name|attId
expr_stmt|;
name|b
operator|->
name|prevPrefixBinding
operator|=
name|prefix
operator|->
name|binding
expr_stmt|;
comment|/* NULL binding when default namespace undeclared */
if|if
condition|(
operator|*
name|uri
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
operator|&&
name|prefix
operator|==
operator|&
name|_dtd
operator|->
name|defaultPrefix
condition|)
name|prefix
operator|->
name|binding
operator|=
name|NULL
expr_stmt|;
else|else
name|prefix
operator|->
name|binding
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|nextTagBinding
operator|=
operator|*
name|bindingsPtr
expr_stmt|;
operator|*
name|bindingsPtr
operator|=
name|b
expr_stmt|;
comment|/* if attId == NULL then we are not starting a namespace scope */
if|if
condition|(
name|attId
operator|&&
name|startNamespaceDeclHandler
condition|)
name|startNamespaceDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|prefix
operator|->
name|name
argument_list|,
name|prefix
operator|->
name|binding
condition|?
name|uri
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
end_function

begin_comment
comment|/* The idea here is to avoid using stack for each CDATA section when    the whole file is parsed with one call. */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|cdataSectionProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|doCdataSection
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
operator|&
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
if|if
condition|(
name|start
condition|)
block|{
if|if
condition|(
name|parentParser
condition|)
block|{
comment|/* we are parsing an external entity */
name|processor
operator|=
name|externalEntityContentProcessor
expr_stmt|;
return|return
name|externalEntityContentProcessor
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
else|else
block|{
name|processor
operator|=
name|contentProcessor
expr_stmt|;
return|return
name|contentProcessor
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* startPtr gets set to non-null if the section is closed, and to null if    the section is not yet closed. */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|doCdataSection
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|startPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|*
name|startPtr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventPP
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventEndPP
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
block|{
name|eventPP
operator|=
operator|&
name|eventPtr
expr_stmt|;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
name|eventEndPP
operator|=
operator|&
name|eventEndPtr
expr_stmt|;
block|}
else|else
block|{
name|eventPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventPtr
operator|)
expr_stmt|;
name|eventEndPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventEndPtr
operator|)
expr_stmt|;
block|}
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
operator|*
name|startPtr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|tok
init|=
name|XmlCdataSectionTok
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
operator|*
name|eventEndPP
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_CDATA_SECT_CLOSE
case|:
if|if
condition|(
name|endCdataSectionHandler
condition|)
name|endCdataSectionHandler
argument_list|(
name|handlerArg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* see comment under XML_TOK_CDATA_SECT_OPEN */
if|else if (characterDataHandler)         characterDataHandler(handlerArg, dataBuf, 0);
endif|#
directive|endif
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
operator|*
name|startPtr
operator|=
name|next
expr_stmt|;
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|ps_parsing
operator|==
name|XML_FINISHED
condition|)
return|return
name|XML_ERROR_ABORTED
return|;
else|else
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_DATA_NEWLINE
case|:
if|if
condition|(
name|characterDataHandler
condition|)
block|{
name|XML_Char
name|c
init|=
literal|0xA
decl_stmt|;
name|characterDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_TOK_DATA_CHARS
case|:
block|{
name|XML_CharacterDataHandler
name|charDataHandler
init|=
name|characterDataHandler
decl_stmt|;
if|if
condition|(
name|charDataHandler
condition|)
block|{
if|if
condition|(
name|MUST_CONVERT
argument_list|(
name|enc
argument_list|,
name|s
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|ICHAR
modifier|*
name|dataPtr
init|=
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
decl_stmt|;
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|s
argument_list|,
name|next
argument_list|,
operator|&
name|dataPtr
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|dataBufEnd
argument_list|)
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|next
expr_stmt|;
name|charDataHandler
argument_list|(
name|handlerArg
argument_list|,
name|dataBuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dataPtr
operator|-
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|next
condition|)
break|break;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
block|}
block|}
else|else
name|charDataHandler
argument_list|(
name|handlerArg
argument_list|,
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|XML_Char
operator|*
operator|)
name|next
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XML_TOK_INVALID
case|:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_PARTIAL
case|:
case|case
name|XML_TOK_NONE
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_UNCLOSED_CDATA_SECTION
return|;
default|default:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_UNEXPECTED_STATE
return|;
block|}
operator|*
name|eventPP
operator|=
name|s
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
empty_stmt|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_comment
comment|/* The idea here is to avoid using stack for each IGNORE section when    the whole file is parsed with one call. */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|ignoreSectionProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|doIgnoreSection
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
operator|&
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
if|if
condition|(
name|start
condition|)
block|{
name|processor
operator|=
name|prologProcessor
expr_stmt|;
return|return
name|prologProcessor
argument_list|(
name|parser
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|endPtr
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* startPtr gets set to non-null is the section is closed, and to null    if the section is not yet closed. */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|doIgnoreSection
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|startPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|tok
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
operator|*
name|startPtr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventPP
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventEndPP
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
block|{
name|eventPP
operator|=
operator|&
name|eventPtr
expr_stmt|;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
name|eventEndPP
operator|=
operator|&
name|eventEndPtr
expr_stmt|;
block|}
else|else
block|{
name|eventPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventPtr
operator|)
expr_stmt|;
name|eventEndPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventEndPtr
operator|)
expr_stmt|;
block|}
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
operator|*
name|startPtr
operator|=
name|NULL
expr_stmt|;
name|tok
operator|=
name|XmlIgnoreSectionTok
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_IGNORE_SECT
case|:
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
operator|*
name|startPtr
operator|=
name|next
expr_stmt|;
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|ps_parsing
operator|==
name|XML_FINISHED
condition|)
return|return
name|XML_ERROR_ABORTED
return|;
else|else
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_INVALID
case|:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_PARTIAL
case|:
case|case
name|XML_TOK_NONE
case|:
if|if
condition|(
name|haveMore
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_SYNTAX
return|;
comment|/* XML_ERROR_UNCLOSED_IGNORE_SECTION */
default|default:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_UNEXPECTED_STATE
return|;
block|}
comment|/* not reached */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|initializeEncoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_UNICODE
name|char
name|encodingBuf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|protocolEncodingName
condition|)
name|s
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|protocolEncodingName
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|encodingBuf
argument_list|)
operator|-
literal|1
operator|||
operator|(
name|protocolEncodingName
index|[
name|i
index|]
operator|&
operator|~
literal|0x7f
operator|)
operator|!=
literal|0
condition|)
block|{
name|encodingBuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|encodingBuf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|protocolEncodingName
index|[
name|i
index|]
expr_stmt|;
block|}
name|encodingBuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|encodingBuf
expr_stmt|;
block|}
else|#
directive|else
name|s
operator|=
name|protocolEncodingName
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ns
condition|?
name|XmlInitEncodingNS
else|:
name|XmlInitEncoding
operator|)
operator|(
operator|&
name|initEncoding
operator|,
operator|&
name|encoding
operator|,
name|s
operator|)
condition|)
return|return
name|XML_ERROR_NONE
return|;
return|return
name|handleUnknownEncoding
argument_list|(
name|parser
argument_list|,
name|protocolEncodingName
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|processXmlDecl
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|isGeneralTextEntity
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|next
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encodingName
init|=
name|NULL
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|storedEncName
init|=
name|NULL
decl_stmt|;
specifier|const
name|ENCODING
modifier|*
name|newEncoding
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|versionend
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|storedversion
init|=
name|NULL
decl_stmt|;
name|int
name|standalone
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ns
condition|?
name|XmlParseXmlDeclNS
else|:
name|XmlParseXmlDecl
operator|)
operator|(
name|isGeneralTextEntity
operator|,
name|encoding
operator|,
name|s
operator|,
name|next
operator|,
operator|&
name|eventPtr
operator|,
operator|&
name|version
operator|,
operator|&
name|versionend
operator|,
operator|&
name|encodingName
operator|,
operator|&
name|newEncoding
operator|,
operator|&
name|standalone
operator|)
condition|)
block|{
if|if
condition|(
name|isGeneralTextEntity
condition|)
return|return
name|XML_ERROR_TEXT_DECL
return|;
else|else
return|return
name|XML_ERROR_XML_DECL
return|;
block|}
if|if
condition|(
operator|!
name|isGeneralTextEntity
operator|&&
name|standalone
operator|==
literal|1
condition|)
block|{
name|_dtd
operator|->
name|standalone
operator|=
name|XML_TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|paramEntityParsing
operator|==
name|XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE
condition|)
name|paramEntityParsing
operator|=
name|XML_PARAM_ENTITY_PARSING_NEVER
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
block|}
if|if
condition|(
name|xmlDeclHandler
condition|)
block|{
if|if
condition|(
name|encodingName
operator|!=
name|NULL
condition|)
block|{
name|storedEncName
operator|=
name|poolStoreString
argument_list|(
operator|&
name|temp2Pool
argument_list|,
name|encoding
argument_list|,
name|encodingName
argument_list|,
name|encodingName
operator|+
name|XmlNameLength
argument_list|(
name|encoding
argument_list|,
name|encodingName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storedEncName
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
condition|)
block|{
name|storedversion
operator|=
name|poolStoreString
argument_list|(
operator|&
name|temp2Pool
argument_list|,
name|encoding
argument_list|,
name|version
argument_list|,
name|versionend
operator|-
name|encoding
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storedversion
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|xmlDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|storedversion
argument_list|,
name|storedEncName
argument_list|,
name|standalone
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocolEncodingName
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newEncoding
condition|)
block|{
if|if
condition|(
name|newEncoding
operator|->
name|minBytesPerChar
operator|!=
name|encoding
operator|->
name|minBytesPerChar
condition|)
block|{
name|eventPtr
operator|=
name|encodingName
expr_stmt|;
return|return
name|XML_ERROR_INCORRECT_ENCODING
return|;
block|}
name|encoding
operator|=
name|newEncoding
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encodingName
condition|)
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|storedEncName
condition|)
block|{
name|storedEncName
operator|=
name|poolStoreString
argument_list|(
operator|&
name|temp2Pool
argument_list|,
name|encoding
argument_list|,
name|encodingName
argument_list|,
name|encodingName
operator|+
name|XmlNameLength
argument_list|(
name|encoding
argument_list|,
name|encodingName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|storedEncName
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|result
operator|=
name|handleUnknownEncoding
argument_list|(
name|parser
argument_list|,
name|storedEncName
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|XML_ERROR_UNKNOWN_ENCODING
condition|)
name|eventPtr
operator|=
name|encodingName
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
if|if
condition|(
name|storedEncName
operator|||
name|storedversion
condition|)
name|poolClear
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|handleUnknownEncoding
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|encodingName
parameter_list|)
block|{
if|if
condition|(
name|unknownEncodingHandler
condition|)
block|{
name|XML_Encoding
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|info
operator|.
name|map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|.
name|convert
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|release
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unknownEncodingHandler
argument_list|(
name|unknownEncodingHandlerData
argument_list|,
name|encodingName
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
name|ENCODING
modifier|*
name|enc
decl_stmt|;
name|unknownEncodingMem
operator|=
name|MALLOC
argument_list|(
name|XmlSizeOfUnknownEncoding
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unknownEncodingMem
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|release
condition|)
name|info
operator|.
name|release
argument_list|(
name|info
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|enc
operator|=
operator|(
name|ns
condition|?
name|XmlInitUnknownEncodingNS
else|:
name|XmlInitUnknownEncoding
operator|)
operator|(
name|unknownEncodingMem
operator|,
name|info
operator|.
name|map
operator|,
name|info
operator|.
name|convert
operator|,
name|info
operator|.
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|enc
condition|)
block|{
name|unknownEncodingData
operator|=
name|info
operator|.
name|data
expr_stmt|;
name|unknownEncodingRelease
operator|=
name|info
operator|.
name|release
expr_stmt|;
name|encoding
operator|=
name|enc
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
block|}
if|if
condition|(
name|info
operator|.
name|release
operator|!=
name|NULL
condition|)
name|info
operator|.
name|release
argument_list|(
name|info
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|XML_ERROR_UNKNOWN_ENCODING
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|prologInitProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|initializeEncoding
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
name|processor
operator|=
name|prologProcessor
expr_stmt|;
return|return
name|prologProcessor
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalParEntInitProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|initializeEncoding
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
comment|/* we know now that XML_Parse(Buffer) has been called,      so we consider the external parameter entity read */
name|_dtd
operator|->
name|paramEntityRead
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|prologState
operator|.
name|inEntityValue
condition|)
block|{
name|processor
operator|=
name|entityValueInitProcessor
expr_stmt|;
return|return
name|entityValueInitProcessor
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
block|}
else|else
block|{
name|processor
operator|=
name|externalParEntProcessor
expr_stmt|;
return|return
name|externalParEntProcessor
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|entityValueInitProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
name|int
name|tok
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
init|=
name|start
decl_stmt|;
name|eventPtr
operator|=
name|start
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|eventEndPtr
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|tok
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ps_finalBuffer
operator|&&
name|tok
operator|!=
name|XML_TOK_INVALID
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_INVALID
case|:
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_NONE
case|:
comment|/* start == end */
default|default:
break|break;
block|}
comment|/* found end of entity value - can store it now */
return|return
name|storeEntityValue
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|XML_TOK_XML_DECL
condition|)
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
name|result
operator|=
name|processXmlDecl
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
block|}
comment|/* stop scanning for text declaration - we found one */
name|processor
operator|=
name|entityValueProcessor
expr_stmt|;
return|return
name|entityValueProcessor
argument_list|(
name|parser
argument_list|,
name|next
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
block|}
comment|/* If we are at the end of the buffer, this would cause XmlPrologTok to        return XML_TOK_NONE on the next call, which would then cause the        function to exit with *nextPtr set to s - that is what we want for other        tokens, but not for the BOM - we would rather like to skip it;        then, when this routine is entered the next time, XmlPrologTok will        return XML_TOK_INVALID, since the BOM is still in the buffer     */
elseif|else
if|if
condition|(
name|tok
operator|==
name|XML_TOK_BOM
operator|&&
name|next
operator|==
name|end
operator|&&
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
name|start
operator|=
name|next
expr_stmt|;
name|eventPtr
operator|=
name|start
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|externalParEntProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|s
decl_stmt|;
name|int
name|tok
decl_stmt|;
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ps_finalBuffer
operator|&&
name|tok
operator|!=
name|XML_TOK_INVALID
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_INVALID
case|:
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_NONE
case|:
comment|/* start == end */
default|default:
break|break;
block|}
block|}
comment|/* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.      However, when parsing an external subset, doProlog will not accept a BOM      as valid, and report a syntax error, so we have to skip the BOM   */
elseif|else
if|if
condition|(
name|tok
operator|==
name|XML_TOK_BOM
condition|)
block|{
name|s
operator|=
name|next
expr_stmt|;
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
name|processor
operator|=
name|prologProcessor
expr_stmt|;
return|return
name|doProlog
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|tok
argument_list|,
name|next
argument_list|,
name|nextPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|entityValueProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
init|=
name|s
decl_stmt|;
specifier|const
name|ENCODING
modifier|*
name|enc
init|=
name|encoding
decl_stmt|;
name|int
name|tok
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|enc
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ps_finalBuffer
operator|&&
name|tok
operator|!=
name|XML_TOK_INVALID
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_INVALID
case|:
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_NONE
case|:
comment|/* start == end */
default|default:
break|break;
block|}
comment|/* found end of entity value - can store it now */
return|return
name|storeEntityValue
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|)
return|;
block|}
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|prologProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|s
decl_stmt|;
name|int
name|tok
init|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
return|return
name|doProlog
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|tok
argument_list|,
name|next
argument_list|,
name|nextPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|doProlog
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
name|tok
parameter_list|,
specifier|const
name|char
modifier|*
name|next
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|,
name|XML_Bool
name|haveMore
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XML_DTD
specifier|static
specifier|const
name|XML_Char
name|externalSubsetName
index|[]
init|=
block|{
name|ASCII_HASH
block|,
literal|'\0'
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
specifier|static
specifier|const
name|XML_Char
name|atypeCDATA
index|[]
init|=
block|{
name|ASCII_C
block|,
name|ASCII_D
block|,
name|ASCII_A
block|,
name|ASCII_T
block|,
name|ASCII_A
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeID
index|[]
init|=
block|{
name|ASCII_I
block|,
name|ASCII_D
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeIDREF
index|[]
init|=
block|{
name|ASCII_I
block|,
name|ASCII_D
block|,
name|ASCII_R
block|,
name|ASCII_E
block|,
name|ASCII_F
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeIDREFS
index|[]
init|=
block|{
name|ASCII_I
block|,
name|ASCII_D
block|,
name|ASCII_R
block|,
name|ASCII_E
block|,
name|ASCII_F
block|,
name|ASCII_S
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeENTITY
index|[]
init|=
block|{
name|ASCII_E
block|,
name|ASCII_N
block|,
name|ASCII_T
block|,
name|ASCII_I
block|,
name|ASCII_T
block|,
name|ASCII_Y
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeENTITIES
index|[]
init|=
block|{
name|ASCII_E
block|,
name|ASCII_N
block|,
name|ASCII_T
block|,
name|ASCII_I
block|,
name|ASCII_T
block|,
name|ASCII_I
block|,
name|ASCII_E
block|,
name|ASCII_S
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeNMTOKEN
index|[]
init|=
block|{
name|ASCII_N
block|,
name|ASCII_M
block|,
name|ASCII_T
block|,
name|ASCII_O
block|,
name|ASCII_K
block|,
name|ASCII_E
block|,
name|ASCII_N
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|atypeNMTOKENS
index|[]
init|=
block|{
name|ASCII_N
block|,
name|ASCII_M
block|,
name|ASCII_T
block|,
name|ASCII_O
block|,
name|ASCII_K
block|,
name|ASCII_E
block|,
name|ASCII_N
block|,
name|ASCII_S
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|notationPrefix
index|[]
init|=
block|{
name|ASCII_N
block|,
name|ASCII_O
block|,
name|ASCII_T
block|,
name|ASCII_A
block|,
name|ASCII_T
block|,
name|ASCII_I
block|,
name|ASCII_O
block|,
name|ASCII_N
block|,
name|ASCII_LPAREN
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|enumValueSep
index|[]
init|=
block|{
name|ASCII_PIPE
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|XML_Char
name|enumValueStart
index|[]
init|=
block|{
name|ASCII_LPAREN
block|,
literal|'\0'
block|}
decl_stmt|;
comment|/* save one level of indirection */
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventPP
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventEndPP
decl_stmt|;
name|enum
name|XML_Content_Quant
name|quant
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
block|{
name|eventPP
operator|=
operator|&
name|eventPtr
expr_stmt|;
name|eventEndPP
operator|=
operator|&
name|eventEndPtr
expr_stmt|;
block|}
else|else
block|{
name|eventPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventPtr
operator|)
expr_stmt|;
name|eventEndPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventEndPtr
operator|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|role
decl_stmt|;
name|XML_Bool
name|handleDefault
init|=
name|XML_TRUE
decl_stmt|;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|tok
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|haveMore
operator|&&
name|tok
operator|!=
name|XML_TOK_INVALID
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_INVALID
case|:
operator|*
name|eventPP
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
case|case
name|XML_TOK_NONE
case|:
ifdef|#
directive|ifdef
name|XML_DTD
comment|/* for internal PE NOT referenced between declarations */
if|if
condition|(
name|enc
operator|!=
name|encoding
operator|&&
operator|!
name|openInternalEntities
operator|->
name|betweenDecl
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
comment|/* WFC: PE Between Declarations - must check that PE contains            complete markup, not only for external PEs, but also for            internal PEs if the reference occurs between declarations.         */
if|if
condition|(
name|isParamEntity
operator|||
name|enc
operator|!=
name|encoding
condition|)
block|{
if|if
condition|(
name|XmlTokenRole
argument_list|(
operator|&
name|prologState
argument_list|,
name|XML_TOK_NONE
argument_list|,
name|end
argument_list|,
name|end
argument_list|,
name|enc
argument_list|)
operator|==
name|XML_ROLE_ERROR
condition|)
return|return
name|XML_ERROR_INCOMPLETE_PE
return|;
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
endif|#
directive|endif
comment|/* XML_DTD */
return|return
name|XML_ERROR_NO_ELEMENTS
return|;
default|default:
name|tok
operator|=
operator|-
name|tok
expr_stmt|;
break|break;
block|}
block|}
name|role
operator|=
name|XmlTokenRole
argument_list|(
operator|&
name|prologState
argument_list|,
name|tok
argument_list|,
name|s
argument_list|,
name|next
argument_list|,
name|enc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|role
condition|)
block|{
case|case
name|XML_ROLE_XML_DECL
case|:
block|{
name|enum
name|XML_Error
name|result
init|=
name|processXmlDecl
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
name|enc
operator|=
name|encoding
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_DOCTYPE_NAME
case|:
if|if
condition|(
name|startDoctypeDeclHandler
condition|)
block|{
name|doctypeName
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doctypeName
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|doctypePubid
operator|=
name|NULL
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|doctypeSysid
operator|=
name|NULL
expr_stmt|;
comment|/* always initialize to NULL */
break|break;
case|case
name|XML_ROLE_DOCTYPE_INTERNAL_SUBSET
case|:
if|if
condition|(
name|startDoctypeDeclHandler
condition|)
block|{
name|startDoctypeDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|doctypeName
argument_list|,
name|doctypeSysid
argument_list|,
name|doctypePubid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|doctypeName
operator|=
name|NULL
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|XML_DTD
case|case
name|XML_ROLE_TEXT_DECL
case|:
block|{
name|enum
name|XML_Error
name|result
init|=
name|processXmlDecl
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
name|enc
operator|=
name|encoding
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* XML_DTD */
case|case
name|XML_ROLE_DOCTYPE_PUBLIC_ID
case|:
ifdef|#
directive|ifdef
name|XML_DTD
name|useForeignDTD
operator|=
name|XML_FALSE
expr_stmt|;
name|declEntity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|externalSubsetName
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
endif|#
directive|endif
comment|/* XML_DTD */
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|startDoctypeDeclHandler
condition|)
block|{
if|if
condition|(
operator|!
name|XmlIsPublicId
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|,
name|eventPP
argument_list|)
condition|)
return|return
name|XML_ERROR_PUBLICID
return|;
name|doctypePubid
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doctypePubid
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|normalizePublicId
argument_list|(
operator|(
name|XML_Char
operator|*
operator|)
name|doctypePubid
argument_list|)
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
goto|goto
name|alreadyChecked
goto|;
block|}
comment|/* fall through */
case|case
name|XML_ROLE_ENTITY_PUBLIC_ID
case|:
if|if
condition|(
operator|!
name|XmlIsPublicId
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|,
name|eventPP
argument_list|)
condition|)
return|return
name|XML_ERROR_PUBLICID
return|;
name|alreadyChecked
label|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|declEntity
condition|)
block|{
name|XML_Char
modifier|*
name|tem
init|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|normalizePublicId
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|declEntity
operator|->
name|publicId
operator|=
name|tem
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entityDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_DOCTYPE_CLOSE
case|:
if|if
condition|(
name|doctypeName
condition|)
block|{
name|startDoctypeDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|doctypeName
argument_list|,
name|doctypeSysid
argument_list|,
name|doctypePubid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
comment|/* doctypeSysid will be non-NULL in the case of a previous          XML_ROLE_DOCTYPE_SYSTEM_ID, even if startDoctypeDeclHandler          was not set, indicating an external subset       */
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|doctypeSysid
operator|||
name|useForeignDTD
condition|)
block|{
name|XML_Bool
name|hadParamEntityRefs
init|=
name|dtd
operator|->
name|hasParamEntityRefs
decl_stmt|;
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|paramEntityParsing
operator|&&
name|externalEntityRefHandler
condition|)
block|{
name|ENTITY
modifier|*
name|entity
init|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|externalSubsetName
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|useForeignDTD
condition|)
name|entity
operator|->
name|base
operator|=
name|curBase
expr_stmt|;
name|dtd
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|externalEntityRefHandler
argument_list|(
name|externalEntityRefHandlerArg
argument_list|,
literal|0
argument_list|,
name|entity
operator|->
name|base
argument_list|,
name|entity
operator|->
name|systemId
argument_list|,
name|entity
operator|->
name|publicId
argument_list|)
condition|)
return|return
name|XML_ERROR_EXTERNAL_ENTITY_HANDLING
return|;
if|if
condition|(
name|dtd
operator|->
name|paramEntityRead
condition|)
block|{
if|if
condition|(
operator|!
name|dtd
operator|->
name|standalone
operator|&&
name|notStandaloneHandler
operator|&&
operator|!
name|notStandaloneHandler
argument_list|(
name|handlerArg
argument_list|)
condition|)
return|return
name|XML_ERROR_NOT_STANDALONE
return|;
block|}
comment|/* if we didn't read the foreign DTD then this means that there              is no external subset and we must reset dtd->hasParamEntityRefs           */
elseif|else
if|if
condition|(
operator|!
name|doctypeSysid
condition|)
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|hadParamEntityRefs
expr_stmt|;
comment|/* end of DTD - no need to update dtd->keepProcessing */
block|}
name|useForeignDTD
operator|=
name|XML_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XML_DTD */
if|if
condition|(
name|endDoctypeDeclHandler
condition|)
block|{
name|endDoctypeDeclHandler
argument_list|(
name|handlerArg
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_INSTANCE_START
case|:
ifdef|#
directive|ifdef
name|XML_DTD
comment|/* if there is no DOCTYPE declaration then now is the          last chance to read the foreign DTD       */
if|if
condition|(
name|useForeignDTD
condition|)
block|{
name|XML_Bool
name|hadParamEntityRefs
init|=
name|dtd
operator|->
name|hasParamEntityRefs
decl_stmt|;
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|paramEntityParsing
operator|&&
name|externalEntityRefHandler
condition|)
block|{
name|ENTITY
modifier|*
name|entity
init|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|externalSubsetName
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|entity
operator|->
name|base
operator|=
name|curBase
expr_stmt|;
name|dtd
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|externalEntityRefHandler
argument_list|(
name|externalEntityRefHandlerArg
argument_list|,
literal|0
argument_list|,
name|entity
operator|->
name|base
argument_list|,
name|entity
operator|->
name|systemId
argument_list|,
name|entity
operator|->
name|publicId
argument_list|)
condition|)
return|return
name|XML_ERROR_EXTERNAL_ENTITY_HANDLING
return|;
if|if
condition|(
name|dtd
operator|->
name|paramEntityRead
condition|)
block|{
if|if
condition|(
operator|!
name|dtd
operator|->
name|standalone
operator|&&
name|notStandaloneHandler
operator|&&
operator|!
name|notStandaloneHandler
argument_list|(
name|handlerArg
argument_list|)
condition|)
return|return
name|XML_ERROR_NOT_STANDALONE
return|;
block|}
comment|/* if we didn't read the foreign DTD then this means that there              is no external subset and we must reset dtd->hasParamEntityRefs           */
else|else
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|hadParamEntityRefs
expr_stmt|;
comment|/* end of DTD - no need to update dtd->keepProcessing */
block|}
block|}
endif|#
directive|endif
comment|/* XML_DTD */
name|processor
operator|=
name|contentProcessor
expr_stmt|;
return|return
name|contentProcessor
argument_list|(
name|parser
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|)
return|;
case|case
name|XML_ROLE_ATTLIST_ELEMENT_NAME
case|:
name|declElementType
operator|=
name|getElementType
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declElementType
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_NAME
case|:
name|declAttributeId
operator|=
name|getAttributeId
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declAttributeId
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declAttributeIsCdata
operator|=
name|XML_FALSE
expr_stmt|;
name|declAttributeType
operator|=
name|NULL
expr_stmt|;
name|declAttributeIsId
operator|=
name|XML_FALSE
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_CDATA
case|:
name|declAttributeIsCdata
operator|=
name|XML_TRUE
expr_stmt|;
name|declAttributeType
operator|=
name|atypeCDATA
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_ID
case|:
name|declAttributeIsId
operator|=
name|XML_TRUE
expr_stmt|;
name|declAttributeType
operator|=
name|atypeID
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_IDREF
case|:
name|declAttributeType
operator|=
name|atypeIDREF
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_IDREFS
case|:
name|declAttributeType
operator|=
name|atypeIDREFS
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_ENTITY
case|:
name|declAttributeType
operator|=
name|atypeENTITY
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_ENTITIES
case|:
name|declAttributeType
operator|=
name|atypeENTITIES
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN
case|:
name|declAttributeType
operator|=
name|atypeNMTOKEN
expr_stmt|;
goto|goto
name|checkAttListDeclHandler
goto|;
case|case
name|XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS
case|:
name|declAttributeType
operator|=
name|atypeNMTOKENS
expr_stmt|;
name|checkAttListDeclHandler
label|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|attlistDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_ATTRIBUTE_ENUM_VALUE
case|:
case|case
name|XML_ROLE_ATTRIBUTE_NOTATION_VALUE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|attlistDeclHandler
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|declAttributeType
condition|)
block|{
name|prefix
operator|=
name|enumValueSep
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
operator|(
name|role
operator|==
name|XML_ROLE_ATTRIBUTE_NOTATION_VALUE
condition|?
name|notationPrefix
else|:
name|enumValueStart
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|poolAppendString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
operator|!
name|poolAppend
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declAttributeType
operator|=
name|tempPool
operator|.
name|start
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_IMPLIED_ATTRIBUTE_VALUE
case|:
case|case
name|XML_ROLE_REQUIRED_ATTRIBUTE_VALUE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
condition|)
block|{
if|if
condition|(
operator|!
name|defineAttribute
argument_list|(
name|declElementType
argument_list|,
name|declAttributeId
argument_list|,
name|declAttributeIsCdata
argument_list|,
name|declAttributeIsId
argument_list|,
literal|0
argument_list|,
name|parser
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|attlistDeclHandler
operator|&&
name|declAttributeType
condition|)
block|{
if|if
condition|(
operator|*
name|declAttributeType
operator|==
name|XML_T
argument_list|(
name|ASCII_LPAREN
argument_list|)
operator|||
operator|(
operator|*
name|declAttributeType
operator|==
name|XML_T
argument_list|(
name|ASCII_N
argument_list|)
operator|&&
name|declAttributeType
index|[
literal|1
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_O
argument_list|)
operator|)
condition|)
block|{
comment|/* Enumerated or Notation type */
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
name|ASCII_RPAREN
argument_list|)
argument_list|)
operator|||
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declAttributeType
operator|=
name|tempPool
operator|.
name|start
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|attlistDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declElementType
operator|->
name|name
argument_list|,
name|declAttributeId
operator|->
name|name
argument_list|,
name|declAttributeType
argument_list|,
literal|0
argument_list|,
name|role
operator|==
name|XML_ROLE_REQUIRED_ATTRIBUTE_VALUE
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_ROLE_DEFAULT_ATTRIBUTE_VALUE
case|:
case|case
name|XML_ROLE_FIXED_ATTRIBUTE_VALUE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|attVal
decl_stmt|;
name|enum
name|XML_Error
name|result
init|=
name|storeAttributeValue
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|declAttributeIsCdata
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|,
operator|&
name|dtd
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|attVal
operator|=
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* ID attributes aren't allowed to have a default */
if|if
condition|(
operator|!
name|defineAttribute
argument_list|(
name|declElementType
argument_list|,
name|declAttributeId
argument_list|,
name|declAttributeIsCdata
argument_list|,
name|XML_FALSE
argument_list|,
name|attVal
argument_list|,
name|parser
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|attlistDeclHandler
operator|&&
name|declAttributeType
condition|)
block|{
if|if
condition|(
operator|*
name|declAttributeType
operator|==
name|XML_T
argument_list|(
name|ASCII_LPAREN
argument_list|)
operator|||
operator|(
operator|*
name|declAttributeType
operator|==
name|XML_T
argument_list|(
name|ASCII_N
argument_list|)
operator|&&
name|declAttributeType
index|[
literal|1
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_O
argument_list|)
operator|)
condition|)
block|{
comment|/* Enumerated or Notation type */
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
name|ASCII_RPAREN
argument_list|)
argument_list|)
operator|||
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declAttributeType
operator|=
name|tempPool
operator|.
name|start
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|attlistDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declElementType
operator|->
name|name
argument_list|,
name|declAttributeId
operator|->
name|name
argument_list|,
name|declAttributeType
argument_list|,
name|attVal
argument_list|,
name|role
operator|==
name|XML_ROLE_FIXED_ATTRIBUTE_VALUE
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_ROLE_ENTITY_VALUE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
condition|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|storeEntityValue
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|declEntity
condition|)
block|{
name|declEntity
operator|->
name|textPtr
operator|=
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|entityValuePool
argument_list|)
expr_stmt|;
name|declEntity
operator|->
name|textLen
operator|=
call|(
name|int
call|)
argument_list|(
name|poolLength
argument_list|(
operator|&
name|dtd
operator|->
name|entityValuePool
argument_list|)
argument_list|)
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|entityValuePool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entityDeclHandler
condition|)
block|{
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|entityDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declEntity
operator|->
name|name
argument_list|,
name|declEntity
operator|->
name|is_param
argument_list|,
name|declEntity
operator|->
name|textPtr
argument_list|,
name|declEntity
operator|->
name|textLen
argument_list|,
name|curBase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
else|else
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|entityValuePool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
block|}
break|break;
case|case
name|XML_ROLE_DOCTYPE_SYSTEM_ID
case|:
ifdef|#
directive|ifdef
name|XML_DTD
name|useForeignDTD
operator|=
name|XML_FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
name|startDoctypeDeclHandler
condition|)
block|{
name|doctypeSysid
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|doctypeSysid
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XML_DTD
else|else
comment|/* use externalSubsetName to make doctypeSysid non-NULL            for the case where no startDoctypeDeclHandler is set */
name|doctypeSysid
operator|=
name|externalSubsetName
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
if|if
condition|(
operator|!
name|dtd
operator|->
name|standalone
ifdef|#
directive|ifdef
name|XML_DTD
operator|&&
operator|!
name|paramEntityParsing
endif|#
directive|endif
comment|/* XML_DTD */
operator|&&
name|notStandaloneHandler
operator|&&
operator|!
name|notStandaloneHandler
argument_list|(
name|handlerArg
argument_list|)
condition|)
return|return
name|XML_ERROR_NOT_STANDALONE
return|;
ifndef|#
directive|ifndef
name|XML_DTD
break|break;
else|#
directive|else
comment|/* XML_DTD */
if|if
condition|(
operator|!
name|declEntity
condition|)
block|{
name|declEntity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|externalSubsetName
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declEntity
operator|->
name|publicId
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* fall through */
endif|#
directive|endif
comment|/* XML_DTD */
case|case
name|XML_ROLE_ENTITY_SYSTEM_ID
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|declEntity
condition|)
block|{
name|declEntity
operator|->
name|systemId
operator|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
operator|->
name|systemId
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declEntity
operator|->
name|base
operator|=
name|curBase
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entityDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_ENTITY_COMPLETE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|declEntity
operator|&&
name|entityDeclHandler
condition|)
block|{
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|entityDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declEntity
operator|->
name|name
argument_list|,
name|declEntity
operator|->
name|is_param
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|declEntity
operator|->
name|base
argument_list|,
name|declEntity
operator|->
name|systemId
argument_list|,
name|declEntity
operator|->
name|publicId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_ENTITY_NOTATION_NAME
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|declEntity
condition|)
block|{
name|declEntity
operator|->
name|notation
operator|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
operator|->
name|notation
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|unparsedEntityDeclHandler
condition|)
block|{
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|unparsedEntityDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declEntity
operator|->
name|name
argument_list|,
name|declEntity
operator|->
name|base
argument_list|,
name|declEntity
operator|->
name|systemId
argument_list|,
name|declEntity
operator|->
name|publicId
argument_list|,
name|declEntity
operator|->
name|notation
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entityDeclHandler
condition|)
block|{
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|entityDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declEntity
operator|->
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|declEntity
operator|->
name|base
argument_list|,
name|declEntity
operator|->
name|systemId
argument_list|,
name|declEntity
operator|->
name|publicId
argument_list|,
name|declEntity
operator|->
name|notation
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_ROLE_GENERAL_ENTITY_NAME
case|:
block|{
if|if
condition|(
name|XmlPredefinedEntityName
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|declEntity
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|name
init|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declEntity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|generalEntities
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|declEntity
operator|->
name|name
operator|!=
name|name
condition|)
block|{
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|->
name|publicId
operator|=
name|NULL
expr_stmt|;
name|declEntity
operator|->
name|is_param
operator|=
name|XML_FALSE
expr_stmt|;
comment|/* if we have a parent parser or are reading an internal parameter                entity, then the entity declaration is not considered "internal"             */
name|declEntity
operator|->
name|is_internal
operator|=
operator|!
operator|(
name|parentParser
operator|||
name|openInternalEntities
operator|)
expr_stmt|;
if|if
condition|(
name|entityDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_ROLE_PARAM_ENTITY_NAME
case|:
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|name
init|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|declEntity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declEntity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
if|if
condition|(
name|declEntity
operator|->
name|name
operator|!=
name|name
condition|)
block|{
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|->
name|publicId
operator|=
name|NULL
expr_stmt|;
name|declEntity
operator|->
name|is_param
operator|=
name|XML_TRUE
expr_stmt|;
comment|/* if we have a parent parser or are reading an internal parameter              entity, then the entity declaration is not considered "internal"           */
name|declEntity
operator|->
name|is_internal
operator|=
operator|!
operator|(
name|parentParser
operator|||
name|openInternalEntities
operator|)
expr_stmt|;
if|if
condition|(
name|entityDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|declEntity
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
comment|/* not XML_DTD */
name|declEntity
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
break|break;
case|case
name|XML_ROLE_NOTATION_NAME
case|:
name|declNotationPublicId
operator|=
name|NULL
expr_stmt|;
name|declNotationName
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|notationDeclHandler
condition|)
block|{
name|declNotationName
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declNotationName
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_NOTATION_PUBLIC_ID
case|:
if|if
condition|(
operator|!
name|XmlIsPublicId
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|,
name|eventPP
argument_list|)
condition|)
return|return
name|XML_ERROR_PUBLICID
return|;
if|if
condition|(
name|declNotationName
condition|)
block|{
comment|/* means notationDeclHandler != NULL */
name|XML_Char
modifier|*
name|tem
init|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|normalizePublicId
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|declNotationPublicId
operator|=
name|tem
expr_stmt|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_NOTATION_SYSTEM_ID
case|:
if|if
condition|(
name|declNotationName
operator|&&
name|notationDeclHandler
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|systemId
init|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|systemId
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|notationDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declNotationName
argument_list|,
name|curBase
argument_list|,
name|systemId
argument_list|,
name|declNotationPublicId
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_ROLE_NOTATION_NO_SYSTEM_ID
case|:
if|if
condition|(
name|declNotationPublicId
operator|&&
name|notationDeclHandler
condition|)
block|{
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|notationDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declNotationName
argument_list|,
name|curBase
argument_list|,
literal|0
argument_list|,
name|declNotationPublicId
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_ROLE_ERROR
case|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_PARAM_ENTITY_REF
case|:
comment|/* PE references in internal subset are            not allowed within declarations. */
return|return
name|XML_ERROR_PARAM_ENTITY_REF
return|;
case|case
name|XML_TOK_XML_DECL
case|:
return|return
name|XML_ERROR_MISPLACED_XML_PI
return|;
default|default:
return|return
name|XML_ERROR_SYNTAX
return|;
block|}
ifdef|#
directive|ifdef
name|XML_DTD
case|case
name|XML_ROLE_IGNORE_SECT
case|:
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
name|result
operator|=
name|doIgnoreSection
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
operator|&
name|next
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|,
name|haveMore
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
operator|!
name|next
condition|)
block|{
name|processor
operator|=
name|ignoreSectionProcessor
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* XML_DTD */
case|case
name|XML_ROLE_GROUP_OPEN
case|:
if|if
condition|(
name|prologState
operator|.
name|level
operator|>=
name|groupSize
condition|)
block|{
if|if
condition|(
name|groupSize
condition|)
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|REALLOC
argument_list|(
name|groupConnector
argument_list|,
name|groupSize
operator|*=
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|groupConnector
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|scaffIndex
condition|)
block|{
name|int
modifier|*
name|temp
init|=
operator|(
name|int
operator|*
operator|)
name|REALLOC
argument_list|(
name|dtd
operator|->
name|scaffIndex
argument_list|,
name|groupSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|dtd
operator|->
name|scaffIndex
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|groupConnector
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|groupSize
operator|=
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|groupConnector
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
block|}
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
condition|)
block|{
name|int
name|myindex
init|=
name|nextScaffoldPart
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|myindex
operator|<
literal|0
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
index|]
operator|=
name|myindex
expr_stmt|;
name|dtd
operator|->
name|scaffLevel
operator|++
expr_stmt|;
name|dtd
operator|->
name|scaffold
index|[
name|myindex
index|]
operator|.
name|type
operator|=
name|XML_CTYPE_SEQ
expr_stmt|;
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_GROUP_SEQUENCE
case|:
if|if
condition|(
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|==
name|ASCII_PIPE
condition|)
return|return
name|XML_ERROR_SYNTAX
return|;
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|=
name|ASCII_COMMA
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
operator|&&
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_GROUP_CHOICE
case|:
if|if
condition|(
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|==
name|ASCII_COMMA
condition|)
return|return
name|XML_ERROR_SYNTAX
return|;
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
operator|&&
operator|!
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|&&
operator|(
name|dtd
operator|->
name|scaffold
index|[
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
operator|-
literal|1
index|]
index|]
operator|.
name|type
operator|!=
name|XML_CTYPE_MIXED
operator|)
condition|)
block|{
name|dtd
operator|->
name|scaffold
index|[
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
operator|-
literal|1
index|]
index|]
operator|.
name|type
operator|=
name|XML_CTYPE_CHOICE
expr_stmt|;
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|groupConnector
index|[
name|prologState
operator|.
name|level
index|]
operator|=
name|ASCII_PIPE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_PARAM_ENTITY_REF
case|:
ifdef|#
directive|ifdef
name|XML_DTD
case|case
name|XML_ROLE_INNER_PARAM_ENTITY_REF
case|:
name|dtd
operator|->
name|hasParamEntityRefs
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|paramEntityParsing
condition|)
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
else|else
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|ENTITY
modifier|*
name|entity
decl_stmt|;
name|name
operator|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|s
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|entity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* first, determine if a check for an existing declaration is needed;            if yes, check that the entity exists, and that it is internal,            otherwise call the skipped entity handler         */
if|if
condition|(
name|prologState
operator|.
name|documentEntity
operator|&&
operator|(
name|dtd
operator|->
name|standalone
condition|?
operator|!
name|openInternalEntities
else|:
operator|!
name|dtd
operator|->
name|hasParamEntityRefs
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|entity
condition|)
return|return
name|XML_ERROR_UNDEFINED_ENTITY
return|;
elseif|else
if|if
condition|(
operator|!
name|entity
operator|->
name|is_internal
condition|)
return|return
name|XML_ERROR_ENTITY_DECLARED_IN_PE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entity
condition|)
block|{
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
comment|/* cannot report skipped entities in declarations */
if|if
condition|(
operator|(
name|role
operator|==
name|XML_ROLE_PARAM_ENTITY_REF
operator|)
operator|&&
name|skippedEntityHandler
condition|)
block|{
name|skippedEntityHandler
argument_list|(
name|handlerArg
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|entity
operator|->
name|open
condition|)
return|return
name|XML_ERROR_RECURSIVE_ENTITY_REF
return|;
if|if
condition|(
name|entity
operator|->
name|textPtr
condition|)
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
name|XML_Bool
name|betweenDecl
init|=
operator|(
name|role
operator|==
name|XML_ROLE_PARAM_ENTITY_REF
condition|?
name|XML_TRUE
else|:
name|XML_FALSE
operator|)
decl_stmt|;
name|result
operator|=
name|processInternalEntity
argument_list|(
name|parser
argument_list|,
name|entity
argument_list|,
name|betweenDecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|externalEntityRefHandler
condition|)
block|{
name|dtd
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|externalEntityRefHandler
argument_list|(
name|externalEntityRefHandlerArg
argument_list|,
literal|0
argument_list|,
name|entity
operator|->
name|base
argument_list|,
name|entity
operator|->
name|systemId
argument_list|,
name|entity
operator|->
name|publicId
argument_list|)
condition|)
block|{
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
return|return
name|XML_ERROR_EXTERNAL_ENTITY_HANDLING
return|;
block|}
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|dtd
operator|->
name|paramEntityRead
condition|)
block|{
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* XML_DTD */
if|if
condition|(
operator|!
name|dtd
operator|->
name|standalone
operator|&&
name|notStandaloneHandler
operator|&&
operator|!
name|notStandaloneHandler
argument_list|(
name|handlerArg
argument_list|)
condition|)
return|return
name|XML_ERROR_NOT_STANDALONE
return|;
break|break;
comment|/* Element declaration stuff */
case|case
name|XML_ROLE_ELEMENT_NAME
case|:
if|if
condition|(
name|elementDeclHandler
condition|)
block|{
name|declElementType
operator|=
name|getElementType
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declElementType
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|dtd
operator|->
name|scaffLevel
operator|=
literal|0
expr_stmt|;
name|dtd
operator|->
name|scaffCount
operator|=
literal|0
expr_stmt|;
name|dtd
operator|->
name|in_eldecl
operator|=
name|XML_TRUE
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_CONTENT_ANY
case|:
case|case
name|XML_ROLE_CONTENT_EMPTY
case|:
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
condition|)
block|{
if|if
condition|(
name|elementDeclHandler
condition|)
block|{
name|XML_Content
modifier|*
name|content
init|=
operator|(
name|XML_Content
operator|*
operator|)
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|XML_Content
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|content
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|content
operator|->
name|quant
operator|=
name|XML_CQUANT_NONE
expr_stmt|;
name|content
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|content
operator|->
name|numchildren
operator|=
literal|0
expr_stmt|;
name|content
operator|->
name|children
operator|=
name|NULL
expr_stmt|;
name|content
operator|->
name|type
operator|=
operator|(
operator|(
name|role
operator|==
name|XML_ROLE_CONTENT_ANY
operator|)
condition|?
name|XML_CTYPE_ANY
else|:
name|XML_CTYPE_EMPTY
operator|)
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|elementDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declElementType
operator|->
name|name
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
name|dtd
operator|->
name|in_eldecl
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_CONTENT_PCDATA
case|:
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
condition|)
block|{
name|dtd
operator|->
name|scaffold
index|[
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
operator|-
literal|1
index|]
index|]
operator|.
name|type
operator|=
name|XML_CTYPE_MIXED
expr_stmt|;
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_CONTENT_ELEMENT
case|:
name|quant
operator|=
name|XML_CQUANT_NONE
expr_stmt|;
goto|goto
name|elementContent
goto|;
case|case
name|XML_ROLE_CONTENT_ELEMENT_OPT
case|:
name|quant
operator|=
name|XML_CQUANT_OPT
expr_stmt|;
goto|goto
name|elementContent
goto|;
case|case
name|XML_ROLE_CONTENT_ELEMENT_REP
case|:
name|quant
operator|=
name|XML_CQUANT_REP
expr_stmt|;
goto|goto
name|elementContent
goto|;
case|case
name|XML_ROLE_CONTENT_ELEMENT_PLUS
case|:
name|quant
operator|=
name|XML_CQUANT_PLUS
expr_stmt|;
name|elementContent
label|:
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
condition|)
block|{
name|ELEMENT_TYPE
modifier|*
name|el
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|int
name|nameLen
decl_stmt|;
specifier|const
name|char
modifier|*
name|nxt
init|=
operator|(
name|quant
operator|==
name|XML_CQUANT_NONE
condition|?
name|next
else|:
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
operator|)
decl_stmt|;
name|int
name|myindex
init|=
name|nextScaffoldPart
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|myindex
operator|<
literal|0
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|dtd
operator|->
name|scaffold
index|[
name|myindex
index|]
operator|.
name|type
operator|=
name|XML_CTYPE_NAME
expr_stmt|;
name|dtd
operator|->
name|scaffold
index|[
name|myindex
index|]
operator|.
name|quant
operator|=
name|quant
expr_stmt|;
name|el
operator|=
name|getElementType
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|name
operator|=
name|el
operator|->
name|name
expr_stmt|;
name|dtd
operator|->
name|scaffold
index|[
name|myindex
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|nameLen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|name
index|[
name|nameLen
operator|++
index|]
condition|;
control|)
empty_stmt|;
name|dtd
operator|->
name|contentStringLen
operator|+=
name|nameLen
expr_stmt|;
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|XML_ROLE_GROUP_CLOSE
case|:
name|quant
operator|=
name|XML_CQUANT_NONE
expr_stmt|;
goto|goto
name|closeGroup
goto|;
case|case
name|XML_ROLE_GROUP_CLOSE_OPT
case|:
name|quant
operator|=
name|XML_CQUANT_OPT
expr_stmt|;
goto|goto
name|closeGroup
goto|;
case|case
name|XML_ROLE_GROUP_CLOSE_REP
case|:
name|quant
operator|=
name|XML_CQUANT_REP
expr_stmt|;
goto|goto
name|closeGroup
goto|;
case|case
name|XML_ROLE_GROUP_CLOSE_PLUS
case|:
name|quant
operator|=
name|XML_CQUANT_PLUS
expr_stmt|;
name|closeGroup
label|:
if|if
condition|(
name|dtd
operator|->
name|in_eldecl
condition|)
block|{
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
name|dtd
operator|->
name|scaffLevel
operator|--
expr_stmt|;
name|dtd
operator|->
name|scaffold
index|[
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
index|]
index|]
operator|.
name|quant
operator|=
name|quant
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|scaffLevel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|handleDefault
condition|)
block|{
name|XML_Content
modifier|*
name|model
init|=
name|build_model
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|model
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|elementDeclHandler
argument_list|(
name|handlerArg
argument_list|,
name|declElementType
operator|->
name|name
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
name|dtd
operator|->
name|in_eldecl
operator|=
name|XML_FALSE
expr_stmt|;
name|dtd
operator|->
name|contentStringLen
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
comment|/* End element declaration stuff */
case|case
name|XML_ROLE_PI
case|:
if|if
condition|(
operator|!
name|reportProcessingInstruction
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_COMMENT
case|:
if|if
condition|(
operator|!
name|reportComment
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_NONE
case|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_BOM
case|:
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|XML_ROLE_DOCTYPE_NONE
case|:
if|if
condition|(
name|startDoctypeDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_ENTITY_NONE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|entityDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_NOTATION_NONE
case|:
if|if
condition|(
name|notationDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_ATTLIST_NONE
case|:
if|if
condition|(
name|dtd
operator|->
name|keepProcessing
operator|&&
name|attlistDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
case|case
name|XML_ROLE_ELEMENT_NONE
case|:
if|if
condition|(
name|elementDeclHandler
condition|)
name|handleDefault
operator|=
name|XML_FALSE
expr_stmt|;
break|break;
block|}
comment|/* end of big switch */
if|if
condition|(
name|handleDefault
operator|&&
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
name|s
operator|=
name|next
expr_stmt|;
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|enc
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|epilogProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
name|processor
operator|=
name|epilogProcessor
expr_stmt|;
name|eventPtr
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|int
name|tok
init|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
name|eventEndPtr
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
comment|/* report partial linebreak - it might be the last token */
case|case
operator|-
name|XML_TOK_PROLOG_S
case|:
if|if
condition|(
name|defaultHandler
condition|)
block|{
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_parsing
operator|==
name|XML_FINISHED
condition|)
return|return
name|XML_ERROR_ABORTED
return|;
block|}
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_NONE
case|:
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_PROLOG_S
case|:
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_TOK_PI
case|:
if|if
condition|(
operator|!
name|reportProcessingInstruction
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
case|case
name|XML_TOK_COMMENT
case|:
if|if
condition|(
operator|!
name|reportComment
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
case|case
name|XML_TOK_INVALID
case|:
name|eventPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_UNCLOSED_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL_CHAR
case|:
if|if
condition|(
operator|!
name|ps_finalBuffer
condition|)
block|{
operator|*
name|nextPtr
operator|=
name|s
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
block|}
return|return
name|XML_ERROR_PARTIAL_CHAR
return|;
default|default:
return|return
name|XML_ERROR_JUNK_AFTER_DOC_ELEMENT
return|;
block|}
name|eventPtr
operator|=
name|s
operator|=
name|next
expr_stmt|;
switch|switch
condition|(
name|ps_parsing
condition|)
block|{
case|case
name|XML_SUSPENDED
case|:
operator|*
name|nextPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_FINISHED
case|:
return|return
name|XML_ERROR_ABORTED
return|;
default|default:
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|processInternalEntity
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|ENTITY
modifier|*
name|entity
parameter_list|,
name|XML_Bool
name|betweenDecl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|textStart
decl_stmt|,
modifier|*
name|textEnd
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|enum
name|XML_Error
name|result
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|openEntity
decl_stmt|;
if|if
condition|(
name|freeInternalEntities
condition|)
block|{
name|openEntity
operator|=
name|freeInternalEntities
expr_stmt|;
name|freeInternalEntities
operator|=
name|openEntity
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|openEntity
operator|=
operator|(
name|OPEN_INTERNAL_ENTITY
operator|*
operator|)
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|OPEN_INTERNAL_ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openEntity
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
name|entity
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|openEntity
operator|->
name|next
operator|=
name|openInternalEntities
expr_stmt|;
name|openInternalEntities
operator|=
name|openEntity
expr_stmt|;
name|openEntity
operator|->
name|entity
operator|=
name|entity
expr_stmt|;
name|openEntity
operator|->
name|startTagLevel
operator|=
name|tagLevel
expr_stmt|;
name|openEntity
operator|->
name|betweenDecl
operator|=
name|betweenDecl
expr_stmt|;
name|openEntity
operator|->
name|internalEventPtr
operator|=
name|NULL
expr_stmt|;
name|openEntity
operator|->
name|internalEventEndPtr
operator|=
name|NULL
expr_stmt|;
name|textStart
operator|=
operator|(
name|char
operator|*
operator|)
name|entity
operator|->
name|textPtr
expr_stmt|;
name|textEnd
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|entity
operator|->
name|textPtr
operator|+
name|entity
operator|->
name|textLen
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|entity
operator|->
name|is_param
condition|)
block|{
name|int
name|tok
init|=
name|XmlPrologTok
argument_list|(
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
name|result
operator|=
name|doProlog
argument_list|(
name|parser
argument_list|,
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
name|tok
argument_list|,
name|next
argument_list|,
operator|&
name|next
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* XML_DTD */
name|result
operator|=
name|doContent
argument_list|(
name|parser
argument_list|,
name|tagLevel
argument_list|,
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
operator|&
name|next
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|XML_ERROR_NONE
condition|)
block|{
if|if
condition|(
name|textEnd
operator|!=
name|next
operator|&&
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
block|{
name|entity
operator|->
name|processed
operator|=
call|(
name|int
call|)
argument_list|(
name|next
operator|-
name|textStart
argument_list|)
expr_stmt|;
name|processor
operator|=
name|internalEntityProcessor
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
name|openInternalEntities
operator|=
name|openEntity
operator|->
name|next
expr_stmt|;
comment|/* put openEntity back in list of free instances */
name|openEntity
operator|->
name|next
operator|=
name|freeInternalEntities
expr_stmt|;
name|freeInternalEntities
operator|=
name|openEntity
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|internalEntityProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
name|ENTITY
modifier|*
name|entity
decl_stmt|;
specifier|const
name|char
modifier|*
name|textStart
decl_stmt|,
modifier|*
name|textEnd
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|enum
name|XML_Error
name|result
decl_stmt|;
name|OPEN_INTERNAL_ENTITY
modifier|*
name|openEntity
init|=
name|openInternalEntities
decl_stmt|;
if|if
condition|(
operator|!
name|openEntity
condition|)
return|return
name|XML_ERROR_UNEXPECTED_STATE
return|;
name|entity
operator|=
name|openEntity
operator|->
name|entity
expr_stmt|;
name|textStart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|entity
operator|->
name|textPtr
operator|)
operator|+
name|entity
operator|->
name|processed
expr_stmt|;
name|textEnd
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|entity
operator|->
name|textPtr
operator|+
name|entity
operator|->
name|textLen
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|entity
operator|->
name|is_param
condition|)
block|{
name|int
name|tok
init|=
name|XmlPrologTok
argument_list|(
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
name|result
operator|=
name|doProlog
argument_list|(
name|parser
argument_list|,
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
name|tok
argument_list|,
name|next
argument_list|,
operator|&
name|next
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* XML_DTD */
name|result
operator|=
name|doContent
argument_list|(
name|parser
argument_list|,
name|openEntity
operator|->
name|startTagLevel
argument_list|,
name|internalEncoding
argument_list|,
name|textStart
argument_list|,
name|textEnd
argument_list|,
operator|&
name|next
argument_list|,
name|XML_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|result
return|;
elseif|else
if|if
condition|(
name|textEnd
operator|!=
name|next
operator|&&
name|ps_parsing
operator|==
name|XML_SUSPENDED
condition|)
block|{
name|entity
operator|->
name|processed
operator|=
call|(
name|int
call|)
argument_list|(
name|next
operator|-
operator|(
name|char
operator|*
operator|)
name|entity
operator|->
name|textPtr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
name|openInternalEntities
operator|=
name|openEntity
operator|->
name|next
expr_stmt|;
comment|/* put openEntity back in list of free instances */
name|openEntity
operator|->
name|next
operator|=
name|freeInternalEntities
expr_stmt|;
name|freeInternalEntities
operator|=
name|openEntity
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|entity
operator|->
name|is_param
condition|)
block|{
name|int
name|tok
decl_stmt|;
name|processor
operator|=
name|prologProcessor
expr_stmt|;
name|tok
operator|=
name|XmlPrologTok
argument_list|(
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
return|return
name|doProlog
argument_list|(
name|parser
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|tok
argument_list|,
name|next
argument_list|,
name|nextPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
comment|/* XML_DTD */
block|{
name|processor
operator|=
name|contentProcessor
expr_stmt|;
comment|/* see externalEntityContentProcessor vs contentProcessor */
return|return
name|doContent
argument_list|(
name|parser
argument_list|,
name|parentParser
condition|?
literal|1
else|:
literal|0
argument_list|,
name|encoding
argument_list|,
name|s
argument_list|,
name|end
argument_list|,
name|nextPtr
argument_list|,
operator|(
name|XML_Bool
operator|)
operator|!
name|ps_finalBuffer
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|PTRCALL
name|errorProcessor
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextPtr
parameter_list|)
block|{
return|return
name|errorCode
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|storeAttributeValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
block|{
name|enum
name|XML_Error
name|result
init|=
name|appendAttributeValue
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|isCdata
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|isCdata
operator|&&
name|poolLength
argument_list|(
name|pool
argument_list|)
operator|&&
name|poolLastChar
argument_list|(
name|pool
argument_list|)
operator|==
literal|0x20
condition|)
name|poolChop
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
return|return
name|XML_ERROR_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|appendAttributeValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|tok
init|=
name|XmlAttributeValueTok
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_NONE
case|:
return|return
name|XML_ERROR_NONE
return|;
case|case
name|XML_TOK_INVALID
case|:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|next
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_INVALID_TOKEN
return|;
case|case
name|XML_TOK_CHAR_REF
case|:
block|{
name|XML_Char
name|buf
index|[
name|XML_ENCODE_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|XmlCharRefNumber
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_BAD_CHAR_REF
return|;
block|}
if|if
condition|(
operator|!
name|isCdata
operator|&&
name|n
operator|==
literal|0x20
comment|/* space */
operator|&&
operator|(
name|poolLength
argument_list|(
name|pool
argument_list|)
operator|==
literal|0
operator|||
name|poolLastChar
argument_list|(
name|pool
argument_list|)
operator|==
literal|0x20
operator|)
condition|)
break|break;
name|n
operator|=
name|XmlEncode
argument_list|(
name|n
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_BAD_CHAR_REF
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
block|}
break|break;
case|case
name|XML_TOK_DATA_CHARS
case|:
if|if
condition|(
operator|!
name|poolAppend
argument_list|(
name|pool
argument_list|,
name|enc
argument_list|,
name|ptr
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
case|case
name|XML_TOK_TRAILING_CR
case|:
name|next
operator|=
name|ptr
operator|+
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
comment|/* fall through */
case|case
name|XML_TOK_ATTRIBUTE_VALUE_S
case|:
case|case
name|XML_TOK_DATA_NEWLINE
case|:
if|if
condition|(
operator|!
name|isCdata
operator|&&
operator|(
name|poolLength
argument_list|(
name|pool
argument_list|)
operator|==
literal|0
operator|||
name|poolLastChar
argument_list|(
name|pool
argument_list|)
operator|==
literal|0x20
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
literal|0x20
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
case|case
name|XML_TOK_ENTITY_REF
case|:
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|ENTITY
modifier|*
name|entity
decl_stmt|;
name|char
name|checkEntityDecl
decl_stmt|;
name|XML_Char
name|ch
init|=
operator|(
name|XML_Char
operator|)
name|XmlPredefinedEntityName
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
condition|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
name|ch
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
break|break;
block|}
name|name
operator|=
name|poolStoreString
argument_list|(
operator|&
name|temp2Pool
argument_list|,
name|enc
argument_list|,
name|ptr
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
name|entity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|generalEntities
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poolDiscard
argument_list|(
operator|&
name|temp2Pool
argument_list|)
expr_stmt|;
comment|/* First, determine if a check for an existing declaration is needed;            if yes, check that the entity exists, and that it is internal.         */
if|if
condition|(
name|pool
operator|==
operator|&
name|dtd
operator|->
name|pool
condition|)
comment|/* are we called from prolog? */
name|checkEntityDecl
operator|=
ifdef|#
directive|ifdef
name|XML_DTD
name|prologState
operator|.
name|documentEntity
operator|&&
endif|#
directive|endif
comment|/* XML_DTD */
operator|(
name|dtd
operator|->
name|standalone
condition|?
operator|!
name|openInternalEntities
else|:
operator|!
name|dtd
operator|->
name|hasParamEntityRefs
operator|)
expr_stmt|;
else|else
comment|/* if (pool ==&tempPool): we are called from content */
name|checkEntityDecl
operator|=
operator|!
name|dtd
operator|->
name|hasParamEntityRefs
operator|||
name|dtd
operator|->
name|standalone
expr_stmt|;
if|if
condition|(
name|checkEntityDecl
condition|)
block|{
if|if
condition|(
operator|!
name|entity
condition|)
return|return
name|XML_ERROR_UNDEFINED_ENTITY
return|;
elseif|else
if|if
condition|(
operator|!
name|entity
operator|->
name|is_internal
condition|)
return|return
name|XML_ERROR_ENTITY_DECLARED_IN_PE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entity
condition|)
block|{
comment|/* Cannot report skipped entity here - see comments on              skippedEntityHandler.           if (skippedEntityHandler)             skippedEntityHandler(handlerArg, name, 0);           */
comment|/* Cannot call the default handler because this would be              out of sync with the call to the startElementHandler.           if ((pool ==&tempPool)&& defaultHandler)             reportDefault(parser, enc, ptr, next);           */
break|break;
block|}
if|if
condition|(
name|entity
operator|->
name|open
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_RECURSIVE_ENTITY_REF
return|;
block|}
if|if
condition|(
name|entity
operator|->
name|notation
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_BINARY_ENTITY_REF
return|;
block|}
if|if
condition|(
operator|!
name|entity
operator|->
name|textPtr
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF
return|;
block|}
else|else
block|{
name|enum
name|XML_Error
name|result
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|textEnd
init|=
name|entity
operator|->
name|textPtr
operator|+
name|entity
operator|->
name|textLen
decl_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
name|result
operator|=
name|appendAttributeValue
argument_list|(
name|parser
argument_list|,
name|internalEncoding
argument_list|,
name|isCdata
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entity
operator|->
name|textPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|textEnd
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_ERROR_UNEXPECTED_STATE
return|;
block|}
name|ptr
operator|=
name|next
expr_stmt|;
block|}
comment|/* not reached */
block|}
end_function

begin_function
specifier|static
name|enum
name|XML_Error
name|storeEntityValue
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|entityTextPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|entityTextEnd
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|STRING_POOL
modifier|*
name|pool
init|=
operator|&
operator|(
name|dtd
operator|->
name|entityValuePool
operator|)
decl_stmt|;
name|enum
name|XML_Error
name|result
init|=
name|XML_ERROR_NONE
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|int
name|oldInEntityValue
init|=
name|prologState
operator|.
name|inEntityValue
decl_stmt|;
name|prologState
operator|.
name|inEntityValue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
comment|/* never return Null for the value argument in EntityDeclHandler,      since this would indicate an external entity; therefore we      have to make sure that entityValuePool.start is not null */
if|if
condition|(
operator|!
name|pool
operator|->
name|blocks
condition|)
block|{
if|if
condition|(
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
return|return
name|XML_ERROR_NO_MEMORY
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|tok
init|=
name|XmlEntityValueTok
argument_list|(
name|enc
argument_list|,
name|entityTextPtr
argument_list|,
name|entityTextEnd
argument_list|,
operator|&
name|next
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_PARAM_ENTITY_REF
case|:
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
name|isParamEntity
operator|||
name|enc
operator|!=
name|encoding
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
name|ENTITY
modifier|*
name|entity
decl_stmt|;
name|name
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|entityTextPtr
operator|+
name|enc
operator|->
name|minBytesPerChar
argument_list|,
name|next
operator|-
name|enc
operator|->
name|minBytesPerChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|result
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
name|entity
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|paramEntities
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poolDiscard
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entity
condition|)
block|{
comment|/* not a well-formedness error - see XML 1.0: WFC Entity Declared */
comment|/* cannot report skipped entity here - see comments on              skippedEntityHandler           if (skippedEntityHandler)             skippedEntityHandler(handlerArg, name, 0);           */
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
if|if
condition|(
name|entity
operator|->
name|open
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_RECURSIVE_ENTITY_REF
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
if|if
condition|(
name|entity
operator|->
name|systemId
condition|)
block|{
if|if
condition|(
name|externalEntityRefHandler
condition|)
block|{
name|dtd
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|externalEntityRefHandler
argument_list|(
name|externalEntityRefHandlerArg
argument_list|,
literal|0
argument_list|,
name|entity
operator|->
name|base
argument_list|,
name|entity
operator|->
name|systemId
argument_list|,
name|entity
operator|->
name|publicId
argument_list|)
condition|)
block|{
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
name|result
operator|=
name|XML_ERROR_EXTERNAL_ENTITY_HANDLING
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|dtd
operator|->
name|paramEntityRead
condition|)
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
block|}
else|else
name|dtd
operator|->
name|keepProcessing
operator|=
name|dtd
operator|->
name|standalone
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
name|result
operator|=
name|storeEntityValue
argument_list|(
name|parser
argument_list|,
name|internalEncoding
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entity
operator|->
name|textPtr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|entity
operator|->
name|textPtr
operator|+
name|entity
operator|->
name|textLen
operator|)
argument_list|)
expr_stmt|;
name|entity
operator|->
name|open
operator|=
name|XML_FALSE
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|endEntityValue
goto|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* XML_DTD */
comment|/* In the internal subset, PE references are not legal          within markup declarations, e.g entity values in this case. */
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_PARAM_ENTITY_REF
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
case|case
name|XML_TOK_NONE
case|:
name|result
operator|=
name|XML_ERROR_NONE
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
case|case
name|XML_TOK_ENTITY_REF
case|:
case|case
name|XML_TOK_DATA_CHARS
case|:
if|if
condition|(
operator|!
name|poolAppend
argument_list|(
name|pool
argument_list|,
name|enc
argument_list|,
name|entityTextPtr
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|result
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
break|break;
case|case
name|XML_TOK_TRAILING_CR
case|:
name|next
operator|=
name|entityTextPtr
operator|+
name|enc
operator|->
name|minBytesPerChar
expr_stmt|;
comment|/* fall through */
case|case
name|XML_TOK_DATA_NEWLINE
case|:
if|if
condition|(
name|pool
operator|->
name|end
operator|==
name|pool
operator|->
name|ptr
operator|&&
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
block|{
name|result
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
operator|*
operator|(
name|pool
operator|->
name|ptr
operator|)
operator|++
operator|=
literal|0xA
expr_stmt|;
break|break;
case|case
name|XML_TOK_CHAR_REF
case|:
block|{
name|XML_Char
name|buf
index|[
name|XML_ENCODE_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
name|XmlCharRefNumber
argument_list|(
name|enc
argument_list|,
name|entityTextPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_BAD_CHAR_REF
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
name|n
operator|=
name|XmlEncode
argument_list|(
name|n
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_BAD_CHAR_REF
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pool
operator|->
name|end
operator|==
name|pool
operator|->
name|ptr
operator|&&
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
block|{
name|result
operator|=
name|XML_ERROR_NO_MEMORY
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
operator|*
operator|(
name|pool
operator|->
name|ptr
operator|)
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XML_TOK_PARTIAL
case|:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_INVALID_TOKEN
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
case|case
name|XML_TOK_INVALID
case|:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|next
expr_stmt|;
name|result
operator|=
name|XML_ERROR_INVALID_TOKEN
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
default|default:
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
name|eventPtr
operator|=
name|entityTextPtr
expr_stmt|;
name|result
operator|=
name|XML_ERROR_UNEXPECTED_STATE
expr_stmt|;
goto|goto
name|endEntityValue
goto|;
block|}
name|entityTextPtr
operator|=
name|next
expr_stmt|;
block|}
name|endEntityValue
label|:
ifdef|#
directive|ifdef
name|XML_DTD
name|prologState
operator|.
name|inEntityValue
operator|=
name|oldInEntityValue
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|normalizeLines
parameter_list|(
name|XML_Char
modifier|*
name|s
parameter_list|)
block|{
name|XML_Char
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|*
name|s
operator|==
literal|0xD
condition|)
break|break;
block|}
name|p
operator|=
name|s
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|0xD
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0xA
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|0xA
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
condition|)
do|;
operator|*
name|p
operator|=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|reportProcessingInstruction
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|XML_Char
modifier|*
name|target
decl_stmt|;
name|XML_Char
modifier|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|processingInstructionHandler
condition|)
block|{
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|start
operator|+=
name|enc
operator|->
name|minBytesPerChar
operator|*
literal|2
expr_stmt|;
name|tem
operator|=
name|start
operator|+
name|XmlNameLength
argument_list|(
name|enc
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|target
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|start
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
return|return
literal|0
return|;
name|poolFinish
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
name|data
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|XmlSkipS
argument_list|(
name|enc
argument_list|,
name|tem
argument_list|)
argument_list|,
name|end
operator|-
name|enc
operator|->
name|minBytesPerChar
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|0
return|;
name|normalizeLines
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|processingInstructionHandler
argument_list|(
name|handlerArg
argument_list|,
name|target
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reportComment
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|XML_Char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|commentHandler
condition|)
block|{
if|if
condition|(
name|defaultHandler
condition|)
name|reportDefault
argument_list|(
name|parser
argument_list|,
name|enc
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|data
operator|=
name|poolStoreString
argument_list|(
operator|&
name|tempPool
argument_list|,
name|enc
argument_list|,
name|start
operator|+
name|enc
operator|->
name|minBytesPerChar
operator|*
literal|4
argument_list|,
name|end
operator|-
name|enc
operator|->
name|minBytesPerChar
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|0
return|;
name|normalizeLines
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|commentHandler
argument_list|(
name|handlerArg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reportDefault
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|MUST_CONVERT
argument_list|(
name|enc
argument_list|,
name|s
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|eventPP
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|eventEndPP
decl_stmt|;
if|if
condition|(
name|enc
operator|==
name|encoding
condition|)
block|{
name|eventPP
operator|=
operator|&
name|eventPtr
expr_stmt|;
name|eventEndPP
operator|=
operator|&
name|eventEndPtr
expr_stmt|;
block|}
else|else
block|{
name|eventPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventPtr
operator|)
expr_stmt|;
name|eventEndPP
operator|=
operator|&
operator|(
name|openInternalEntities
operator|->
name|internalEventEndPtr
operator|)
expr_stmt|;
block|}
do|do
block|{
name|ICHAR
modifier|*
name|dataPtr
init|=
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
decl_stmt|;
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|s
argument_list|,
name|end
argument_list|,
operator|&
name|dataPtr
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|dataBufEnd
argument_list|)
expr_stmt|;
operator|*
name|eventEndPP
operator|=
name|s
expr_stmt|;
name|defaultHandler
argument_list|(
name|handlerArg
argument_list|,
name|dataBuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dataPtr
operator|-
operator|(
name|ICHAR
operator|*
operator|)
name|dataBuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|eventPP
operator|=
name|s
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|end
condition|)
do|;
block|}
else|else
name|defaultHandler
argument_list|(
name|handlerArg
argument_list|,
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|XML_Char
operator|*
operator|)
name|end
operator|-
operator|(
name|XML_Char
operator|*
operator|)
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|defineAttribute
parameter_list|(
name|ELEMENT_TYPE
modifier|*
name|type
parameter_list|,
name|ATTRIBUTE_ID
modifier|*
name|attId
parameter_list|,
name|XML_Bool
name|isCdata
parameter_list|,
name|XML_Bool
name|isId
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|value
parameter_list|,
name|XML_Parser
name|parser
parameter_list|)
block|{
name|DEFAULT_ATTRIBUTE
modifier|*
name|att
decl_stmt|;
if|if
condition|(
name|value
operator|||
name|isId
condition|)
block|{
comment|/* The handling of default attributes gets messed up if we have        a default which duplicates a non-default. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|type
operator|->
name|nDefaultAtts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|attId
operator|==
name|type
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|id
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|isId
operator|&&
operator|!
name|type
operator|->
name|idAtt
operator|&&
operator|!
name|attId
operator|->
name|xmlns
condition|)
name|type
operator|->
name|idAtt
operator|=
name|attId
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|->
name|nDefaultAtts
operator|==
name|type
operator|->
name|allocDefaultAtts
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|allocDefaultAtts
operator|==
literal|0
condition|)
block|{
name|type
operator|->
name|allocDefaultAtts
operator|=
literal|8
expr_stmt|;
name|type
operator|->
name|defaultAtts
operator|=
operator|(
name|DEFAULT_ATTRIBUTE
operator|*
operator|)
name|MALLOC
argument_list|(
name|type
operator|->
name|allocDefaultAtts
operator|*
sizeof|sizeof
argument_list|(
name|DEFAULT_ATTRIBUTE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|->
name|defaultAtts
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|DEFAULT_ATTRIBUTE
modifier|*
name|temp
decl_stmt|;
name|int
name|count
init|=
name|type
operator|->
name|allocDefaultAtts
operator|*
literal|2
decl_stmt|;
name|temp
operator|=
operator|(
name|DEFAULT_ATTRIBUTE
operator|*
operator|)
name|REALLOC
argument_list|(
name|type
operator|->
name|defaultAtts
argument_list|,
operator|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|DEFAULT_ATTRIBUTE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|type
operator|->
name|allocDefaultAtts
operator|=
name|count
expr_stmt|;
name|type
operator|->
name|defaultAtts
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|att
operator|=
name|type
operator|->
name|defaultAtts
operator|+
name|type
operator|->
name|nDefaultAtts
expr_stmt|;
name|att
operator|->
name|id
operator|=
name|attId
expr_stmt|;
name|att
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|att
operator|->
name|isCdata
operator|=
name|isCdata
expr_stmt|;
if|if
condition|(
operator|!
name|isCdata
condition|)
name|attId
operator|->
name|maybeTokenized
operator|=
name|XML_TRUE
expr_stmt|;
name|type
operator|->
name|nDefaultAtts
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setElementTypePrefix
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|ELEMENT_TYPE
modifier|*
name|elementType
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|name
operator|=
name|elementType
operator|->
name|name
init|;
operator|*
name|name
condition|;
name|name
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
name|XML_T
argument_list|(
name|ASCII_COLON
argument_list|)
condition|)
block|{
name|PREFIX
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|elementType
operator|->
name|name
init|;
name|s
operator|!=
name|name
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|prefixes
argument_list|,
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|prefix
operator|->
name|name
operator|==
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
condition|)
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
name|elementType
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ATTRIBUTE_ID
modifier|*
name|getAttributeId
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|ATTRIBUTE_ID
modifier|*
name|id
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
comment|/* skip quotation mark - its storage will be re-used (like in name[-1]) */
operator|++
name|name
expr_stmt|;
name|id
operator|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|attributeIds
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ATTRIBUTE_ID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|id
operator|->
name|name
operator|!=
name|name
condition|)
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_x
argument_list|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_m
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_l
argument_list|)
operator|&&
name|name
index|[
literal|3
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_n
argument_list|)
operator|&&
name|name
index|[
literal|4
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_s
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|5
index|]
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
operator|||
name|name
index|[
literal|5
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_COLON
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|5
index|]
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
name|id
operator|->
name|prefix
operator|=
operator|&
name|dtd
operator|->
name|defaultPrefix
expr_stmt|;
else|else
name|id
operator|->
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|prefixes
argument_list|,
name|name
operator|+
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|xmlns
operator|=
name|XML_TRUE
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* attributes without prefix are *not* in the default namespace */
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
name|XML_T
argument_list|(
name|ASCII_COLON
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|name
index|[
name|j
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|id
operator|->
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|prefixes
argument_list|,
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|prefix
operator|->
name|name
operator|==
name|poolStart
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
condition|)
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|id
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONTEXT_SEP
value|XML_T(ASCII_FF)
end_define

begin_function
specifier|static
specifier|const
name|XML_Char
modifier|*
name|getContext
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|HASH_TABLE_ITER
name|iter
decl_stmt|;
name|XML_Bool
name|needSep
init|=
name|XML_FALSE
decl_stmt|;
if|if
condition|(
name|dtd
operator|->
name|defaultPrefix
operator|.
name|binding
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
name|ASCII_EQUALS
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|dtd
operator|->
name|defaultPrefix
operator|.
name|binding
operator|->
name|uriLen
expr_stmt|;
if|if
condition|(
name|namespaceSeparator
condition|)
name|len
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|dtd
operator|->
name|defaultPrefix
operator|.
name|binding
operator|->
name|uri
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
name|needSep
operator|=
name|XML_TRUE
expr_stmt|;
block|}
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|dtd
operator|->
name|prefixes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|s
decl_stmt|;
name|PREFIX
modifier|*
name|prefix
init|=
operator|(
name|PREFIX
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
break|break;
if|if
condition|(
operator|!
name|prefix
operator|->
name|binding
condition|)
continue|continue;
if|if
condition|(
name|needSep
operator|&&
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|CONTEXT_SEP
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|s
operator|=
name|prefix
operator|->
name|name
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
name|ASCII_EQUALS
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|prefix
operator|->
name|binding
operator|->
name|uriLen
expr_stmt|;
if|if
condition|(
name|namespaceSeparator
condition|)
name|len
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|prefix
operator|->
name|binding
operator|->
name|uri
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
name|needSep
operator|=
name|XML_TRUE
expr_stmt|;
block|}
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|dtd
operator|->
name|generalEntities
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|XML_Char
modifier|*
name|s
decl_stmt|;
name|ENTITY
modifier|*
name|e
init|=
operator|(
name|ENTITY
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
operator|!
name|e
operator|->
name|open
condition|)
continue|continue;
if|if
condition|(
name|needSep
operator|&&
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|CONTEXT_SEP
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|s
operator|=
name|e
operator|->
name|name
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|needSep
operator|=
name|XML_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|tempPool
operator|.
name|start
return|;
block|}
end_function

begin_function
specifier|static
name|XML_Bool
name|setContext
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|context
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
specifier|const
name|XML_Char
modifier|*
name|s
init|=
name|context
decl_stmt|;
while|while
condition|(
operator|*
name|context
operator|!=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|CONTEXT_SEP
operator|||
operator|*
name|s
operator|==
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
block|{
name|ENTITY
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_FALSE
return|;
name|e
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|generalEntities
argument_list|,
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|e
operator|->
name|open
operator|=
name|XML_TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|context
operator|=
name|s
expr_stmt|;
name|poolDiscard
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|XML_T
argument_list|(
name|ASCII_EQUALS
argument_list|)
condition|)
block|{
name|PREFIX
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|poolLength
argument_list|(
operator|&
name|tempPool
argument_list|)
operator|==
literal|0
condition|)
name|prefix
operator|=
operator|&
name|dtd
operator|->
name|defaultPrefix
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_FALSE
return|;
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|prefixes
argument_list|,
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
return|return
name|XML_FALSE
return|;
if|if
condition|(
name|prefix
operator|->
name|name
operator|==
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
condition|)
block|{
name|prefix
operator|->
name|name
operator|=
name|poolCopyString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|prefix
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
operator|->
name|name
condition|)
return|return
name|XML_FALSE
return|;
block|}
name|poolDiscard
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|context
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|context
operator|!=
name|CONTEXT_SEP
operator|&&
operator|*
name|context
operator|!=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|;
name|context
operator|++
control|)
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|context
argument_list|)
condition|)
return|return
name|XML_FALSE
return|;
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
name|XML_FALSE
return|;
if|if
condition|(
name|addBinding
argument_list|(
name|parser
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|,
name|poolStart
argument_list|(
operator|&
name|tempPool
argument_list|)
argument_list|,
operator|&
name|inheritedBindings
argument_list|)
operator|!=
name|XML_ERROR_NONE
condition|)
return|return
name|XML_FALSE
return|;
name|poolDiscard
argument_list|(
operator|&
name|tempPool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|context
operator|!=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
condition|)
operator|++
name|context
expr_stmt|;
name|s
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
name|tempPool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|XML_FALSE
return|;
name|s
operator|++
expr_stmt|;
block|}
block|}
return|return
name|XML_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|normalizePublicId
parameter_list|(
name|XML_Char
modifier|*
name|publicId
parameter_list|)
block|{
name|XML_Char
modifier|*
name|p
init|=
name|publicId
decl_stmt|;
name|XML_Char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|publicId
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|0x20
case|:
case|case
literal|0xD
case|:
case|case
literal|0xA
case|:
if|if
condition|(
name|p
operator|!=
name|publicId
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|0x20
condition|)
operator|*
name|p
operator|++
operator|=
literal|0x20
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|publicId
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|0x20
condition|)
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|DTD
modifier|*
name|dtdCreate
parameter_list|(
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|DTD
modifier|*
name|p
init|=
operator|(
name|DTD
operator|*
operator|)
name|ms
operator|->
name|malloc_fcn
argument_list|(
sizeof|sizeof
argument_list|(
name|DTD
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|p
return|;
name|poolInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|pool
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|poolInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|entityValuePool
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|hashTableInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|generalEntities
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|hashTableInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|elementTypes
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|hashTableInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|attributeIds
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|hashTableInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|prefixes
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|p
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
name|hashTableInit
argument_list|(
operator|&
operator|(
name|p
operator|->
name|paramEntities
operator|)
argument_list|,
name|ms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|p
operator|->
name|defaultPrefix
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|defaultPrefix
operator|.
name|binding
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|in_eldecl
operator|=
name|XML_FALSE
expr_stmt|;
name|p
operator|->
name|scaffIndex
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|scaffold
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|scaffLevel
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|scaffSize
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|scaffCount
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|contentStringLen
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|keepProcessing
operator|=
name|XML_TRUE
expr_stmt|;
name|p
operator|->
name|hasParamEntityRefs
operator|=
name|XML_FALSE
expr_stmt|;
name|p
operator|->
name|standalone
operator|=
name|XML_FALSE
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtdReset
parameter_list|(
name|DTD
modifier|*
name|p
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|HASH_TABLE_ITER
name|iter
decl_stmt|;
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|p
operator|->
name|elementTypes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ELEMENT_TYPE
modifier|*
name|e
init|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
name|e
operator|->
name|allocDefaultAtts
operator|!=
literal|0
condition|)
name|ms
operator|->
name|free_fcn
argument_list|(
name|e
operator|->
name|defaultAtts
argument_list|)
expr_stmt|;
block|}
name|hashTableClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|generalEntities
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|p
operator|->
name|paramEntityRead
operator|=
name|XML_FALSE
expr_stmt|;
name|hashTableClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|paramEntities
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|hashTableClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|elementTypes
operator|)
argument_list|)
expr_stmt|;
name|hashTableClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|attributeIds
operator|)
argument_list|)
expr_stmt|;
name|hashTableClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|prefixes
operator|)
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|pool
operator|)
argument_list|)
expr_stmt|;
name|poolClear
argument_list|(
operator|&
operator|(
name|p
operator|->
name|entityValuePool
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|defaultPrefix
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|defaultPrefix
operator|.
name|binding
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|in_eldecl
operator|=
name|XML_FALSE
expr_stmt|;
name|ms
operator|->
name|free_fcn
argument_list|(
name|p
operator|->
name|scaffIndex
argument_list|)
expr_stmt|;
name|p
operator|->
name|scaffIndex
operator|=
name|NULL
expr_stmt|;
name|ms
operator|->
name|free_fcn
argument_list|(
name|p
operator|->
name|scaffold
argument_list|)
expr_stmt|;
name|p
operator|->
name|scaffold
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|scaffLevel
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|scaffSize
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|scaffCount
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|contentStringLen
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|keepProcessing
operator|=
name|XML_TRUE
expr_stmt|;
name|p
operator|->
name|hasParamEntityRefs
operator|=
name|XML_FALSE
expr_stmt|;
name|p
operator|->
name|standalone
operator|=
name|XML_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtdDestroy
parameter_list|(
name|DTD
modifier|*
name|p
parameter_list|,
name|XML_Bool
name|isDocEntity
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|HASH_TABLE_ITER
name|iter
decl_stmt|;
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|p
operator|->
name|elementTypes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ELEMENT_TYPE
modifier|*
name|e
init|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
name|e
operator|->
name|allocDefaultAtts
operator|!=
literal|0
condition|)
name|ms
operator|->
name|free_fcn
argument_list|(
name|e
operator|->
name|defaultAtts
argument_list|)
expr_stmt|;
block|}
name|hashTableDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|generalEntities
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XML_DTD
name|hashTableDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|paramEntities
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|hashTableDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|elementTypes
operator|)
argument_list|)
expr_stmt|;
name|hashTableDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|attributeIds
operator|)
argument_list|)
expr_stmt|;
name|hashTableDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|prefixes
operator|)
argument_list|)
expr_stmt|;
name|poolDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|pool
operator|)
argument_list|)
expr_stmt|;
name|poolDestroy
argument_list|(
operator|&
operator|(
name|p
operator|->
name|entityValuePool
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDocEntity
condition|)
block|{
name|ms
operator|->
name|free_fcn
argument_list|(
name|p
operator|->
name|scaffIndex
argument_list|)
expr_stmt|;
name|ms
operator|->
name|free_fcn
argument_list|(
name|p
operator|->
name|scaffold
argument_list|)
expr_stmt|;
block|}
name|ms
operator|->
name|free_fcn
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.    The new DTD has already been initialized. */
end_comment

begin_function
specifier|static
name|int
name|dtdCopy
parameter_list|(
name|DTD
modifier|*
name|newDtd
parameter_list|,
specifier|const
name|DTD
modifier|*
name|oldDtd
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|HASH_TABLE_ITER
name|iter
decl_stmt|;
comment|/* Copy the prefix table. */
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|oldDtd
operator|->
name|prefixes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
specifier|const
name|PREFIX
modifier|*
name|oldP
init|=
operator|(
name|PREFIX
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldP
condition|)
break|break;
name|name
operator|=
name|poolCopyString
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
name|oldP
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|prefixes
operator|)
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|PREFIX
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|oldDtd
operator|->
name|attributeIds
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the attribute id table. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ATTRIBUTE_ID
modifier|*
name|newA
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
specifier|const
name|ATTRIBUTE_ID
modifier|*
name|oldA
init|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldA
condition|)
break|break;
comment|/* Remember to allocate the scratch byte before the name. */
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
name|XML_T
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|poolCopyString
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
name|oldA
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
operator|++
name|name
expr_stmt|;
name|newA
operator|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|attributeIds
operator|)
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ATTRIBUTE_ID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newA
condition|)
return|return
literal|0
return|;
name|newA
operator|->
name|maybeTokenized
operator|=
name|oldA
operator|->
name|maybeTokenized
expr_stmt|;
if|if
condition|(
name|oldA
operator|->
name|prefix
condition|)
block|{
name|newA
operator|->
name|xmlns
operator|=
name|oldA
operator|->
name|xmlns
expr_stmt|;
if|if
condition|(
name|oldA
operator|->
name|prefix
operator|==
operator|&
name|oldDtd
operator|->
name|defaultPrefix
condition|)
name|newA
operator|->
name|prefix
operator|=
operator|&
name|newDtd
operator|->
name|defaultPrefix
expr_stmt|;
else|else
name|newA
operator|->
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|prefixes
operator|)
argument_list|,
name|oldA
operator|->
name|prefix
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the element type table. */
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
operator|&
operator|(
name|oldDtd
operator|->
name|elementTypes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|ELEMENT_TYPE
modifier|*
name|newE
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
specifier|const
name|ELEMENT_TYPE
modifier|*
name|oldE
init|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldE
condition|)
break|break;
name|name
operator|=
name|poolCopyString
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
name|oldE
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
name|newE
operator|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|elementTypes
operator|)
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ELEMENT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oldE
operator|->
name|nDefaultAtts
condition|)
block|{
name|newE
operator|->
name|defaultAtts
operator|=
operator|(
name|DEFAULT_ATTRIBUTE
operator|*
operator|)
name|ms
operator|->
name|malloc_fcn
argument_list|(
name|oldE
operator|->
name|nDefaultAtts
operator|*
sizeof|sizeof
argument_list|(
name|DEFAULT_ATTRIBUTE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newE
operator|->
name|defaultAtts
condition|)
block|{
name|ms
operator|->
name|free_fcn
argument_list|(
name|newE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|oldE
operator|->
name|idAtt
condition|)
name|newE
operator|->
name|idAtt
operator|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|attributeIds
operator|)
argument_list|,
name|oldE
operator|->
name|idAtt
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newE
operator|->
name|allocDefaultAtts
operator|=
name|newE
operator|->
name|nDefaultAtts
operator|=
name|oldE
operator|->
name|nDefaultAtts
expr_stmt|;
if|if
condition|(
name|oldE
operator|->
name|prefix
condition|)
name|newE
operator|->
name|prefix
operator|=
operator|(
name|PREFIX
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|prefixes
operator|)
argument_list|,
name|oldE
operator|->
name|prefix
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newE
operator|->
name|nDefaultAtts
condition|;
name|i
operator|++
control|)
block|{
name|newE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|id
operator|=
operator|(
name|ATTRIBUTE_ID
operator|*
operator|)
name|lookup
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|attributeIds
operator|)
argument_list|,
name|oldE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|id
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|isCdata
operator|=
name|oldE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|isCdata
expr_stmt|;
if|if
condition|(
name|oldE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|newE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|poolCopyString
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
name|oldE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|value
condition|)
return|return
literal|0
return|;
block|}
else|else
name|newE
operator|->
name|defaultAtts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Copy the entity tables. */
if|if
condition|(
operator|!
name|copyEntityTable
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|generalEntities
operator|)
argument_list|,
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
operator|&
operator|(
name|oldDtd
operator|->
name|generalEntities
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|XML_DTD
if|if
condition|(
operator|!
name|copyEntityTable
argument_list|(
operator|&
operator|(
name|newDtd
operator|->
name|paramEntities
operator|)
argument_list|,
operator|&
operator|(
name|newDtd
operator|->
name|pool
operator|)
argument_list|,
operator|&
operator|(
name|oldDtd
operator|->
name|paramEntities
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|newDtd
operator|->
name|paramEntityRead
operator|=
name|oldDtd
operator|->
name|paramEntityRead
expr_stmt|;
endif|#
directive|endif
comment|/* XML_DTD */
name|newDtd
operator|->
name|keepProcessing
operator|=
name|oldDtd
operator|->
name|keepProcessing
expr_stmt|;
name|newDtd
operator|->
name|hasParamEntityRefs
operator|=
name|oldDtd
operator|->
name|hasParamEntityRefs
expr_stmt|;
name|newDtd
operator|->
name|standalone
operator|=
name|oldDtd
operator|->
name|standalone
expr_stmt|;
comment|/* Don't want deep copying for scaffolding */
name|newDtd
operator|->
name|in_eldecl
operator|=
name|oldDtd
operator|->
name|in_eldecl
expr_stmt|;
name|newDtd
operator|->
name|scaffold
operator|=
name|oldDtd
operator|->
name|scaffold
expr_stmt|;
name|newDtd
operator|->
name|contentStringLen
operator|=
name|oldDtd
operator|->
name|contentStringLen
expr_stmt|;
name|newDtd
operator|->
name|scaffSize
operator|=
name|oldDtd
operator|->
name|scaffSize
expr_stmt|;
name|newDtd
operator|->
name|scaffLevel
operator|=
name|oldDtd
operator|->
name|scaffLevel
expr_stmt|;
name|newDtd
operator|->
name|scaffIndex
operator|=
name|oldDtd
operator|->
name|scaffIndex
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End dtdCopy */
end_comment

begin_function
specifier|static
name|int
name|copyEntityTable
parameter_list|(
name|HASH_TABLE
modifier|*
name|newTable
parameter_list|,
name|STRING_POOL
modifier|*
name|newPool
parameter_list|,
specifier|const
name|HASH_TABLE
modifier|*
name|oldTable
parameter_list|)
block|{
name|HASH_TABLE_ITER
name|iter
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|cachedOldBase
init|=
name|NULL
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|cachedNewBase
init|=
name|NULL
decl_stmt|;
name|hashTableIterInit
argument_list|(
operator|&
name|iter
argument_list|,
name|oldTable
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ENTITY
modifier|*
name|newE
decl_stmt|;
specifier|const
name|XML_Char
modifier|*
name|name
decl_stmt|;
specifier|const
name|ENTITY
modifier|*
name|oldE
init|=
operator|(
name|ENTITY
operator|*
operator|)
name|hashTableIterNext
argument_list|(
operator|&
name|iter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldE
condition|)
break|break;
name|name
operator|=
name|poolCopyString
argument_list|(
name|newPool
argument_list|,
name|oldE
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
name|newE
operator|=
operator|(
name|ENTITY
operator|*
operator|)
name|lookup
argument_list|(
name|newTable
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTITY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oldE
operator|->
name|systemId
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|tem
init|=
name|poolCopyString
argument_list|(
name|newPool
argument_list|,
name|oldE
operator|->
name|systemId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
literal|0
return|;
name|newE
operator|->
name|systemId
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|oldE
operator|->
name|base
condition|)
block|{
if|if
condition|(
name|oldE
operator|->
name|base
operator|==
name|cachedOldBase
condition|)
name|newE
operator|->
name|base
operator|=
name|cachedNewBase
expr_stmt|;
else|else
block|{
name|cachedOldBase
operator|=
name|oldE
operator|->
name|base
expr_stmt|;
name|tem
operator|=
name|poolCopyString
argument_list|(
name|newPool
argument_list|,
name|cachedOldBase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
literal|0
return|;
name|cachedNewBase
operator|=
name|newE
operator|->
name|base
operator|=
name|tem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldE
operator|->
name|publicId
condition|)
block|{
name|tem
operator|=
name|poolCopyString
argument_list|(
name|newPool
argument_list|,
name|oldE
operator|->
name|publicId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
literal|0
return|;
name|newE
operator|->
name|publicId
operator|=
name|tem
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|XML_Char
modifier|*
name|tem
init|=
name|poolCopyStringN
argument_list|(
name|newPool
argument_list|,
name|oldE
operator|->
name|textPtr
argument_list|,
name|oldE
operator|->
name|textLen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
literal|0
return|;
name|newE
operator|->
name|textPtr
operator|=
name|tem
expr_stmt|;
name|newE
operator|->
name|textLen
operator|=
name|oldE
operator|->
name|textLen
expr_stmt|;
block|}
if|if
condition|(
name|oldE
operator|->
name|notation
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|tem
init|=
name|poolCopyString
argument_list|(
name|newPool
argument_list|,
name|oldE
operator|->
name|notation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
literal|0
return|;
name|newE
operator|->
name|notation
operator|=
name|tem
expr_stmt|;
block|}
name|newE
operator|->
name|is_param
operator|=
name|oldE
operator|->
name|is_param
expr_stmt|;
name|newE
operator|->
name|is_internal
operator|=
name|oldE
operator|->
name|is_internal
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INIT_POWER
value|6
end_define

begin_function
specifier|static
name|XML_Bool
name|FASTCALL
name|keyeq
parameter_list|(
name|KEY
name|s1
parameter_list|,
name|KEY
name|s2
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|s1
operator|==
operator|*
name|s2
condition|;
name|s1
operator|++
operator|,
name|s2
operator|++
control|)
if|if
condition|(
operator|*
name|s1
operator|==
literal|0
condition|)
return|return
name|XML_TRUE
return|;
return|return
name|XML_FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|FASTCALL
name|hash
parameter_list|(
name|KEY
name|s
parameter_list|)
block|{
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|h
operator|=
name|CHAR_HASH
argument_list|(
name|h
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|NAMED
modifier|*
name|lookup
parameter_list|(
name|HASH_TABLE
modifier|*
name|table
parameter_list|,
name|KEY
name|name
parameter_list|,
name|size_t
name|createSize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|size_t
name|tsize
decl_stmt|;
if|if
condition|(
operator|!
name|createSize
condition|)
return|return
name|NULL
return|;
name|table
operator|->
name|power
operator|=
name|INIT_POWER
expr_stmt|;
comment|/* table->size is a power of 2 */
name|table
operator|->
name|size
operator|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|INIT_POWER
expr_stmt|;
name|tsize
operator|=
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|NAMED
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|v
operator|=
operator|(
name|NAMED
operator|*
operator|*
operator|)
name|table
operator|->
name|mem
operator|->
name|malloc_fcn
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|v
condition|)
block|{
name|table
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|table
operator|->
name|v
argument_list|,
literal|0
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|i
operator|=
name|hash
argument_list|(
name|name
argument_list|)
operator|&
operator|(
operator|(
name|unsigned
name|long
operator|)
name|table
operator|->
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|h
init|=
name|hash
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
operator|(
name|unsigned
name|long
operator|)
name|table
operator|->
name|size
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|step
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|h
operator|&
name|mask
expr_stmt|;
while|while
condition|(
name|table
operator|->
name|v
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|keyeq
argument_list|(
name|name
argument_list|,
name|table
operator|->
name|v
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|table
operator|->
name|v
index|[
name|i
index|]
return|;
if|if
condition|(
operator|!
name|step
condition|)
name|step
operator|=
name|PROBE_STEP
argument_list|(
name|h
argument_list|,
name|mask
argument_list|,
name|table
operator|->
name|power
argument_list|)
expr_stmt|;
name|i
operator|<
name|step
condition|?
operator|(
name|i
operator|+=
name|table
operator|->
name|size
operator|-
name|step
operator|)
else|:
operator|(
name|i
operator|-=
name|step
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|createSize
condition|)
return|return
name|NULL
return|;
comment|/* check for overflow (table is half full) */
if|if
condition|(
name|table
operator|->
name|used
operator|>>
operator|(
name|table
operator|->
name|power
operator|-
literal|1
operator|)
condition|)
block|{
name|unsigned
name|char
name|newPower
init|=
name|table
operator|->
name|power
operator|+
literal|1
decl_stmt|;
name|size_t
name|newSize
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|newPower
decl_stmt|;
name|unsigned
name|long
name|newMask
init|=
operator|(
name|unsigned
name|long
operator|)
name|newSize
operator|-
literal|1
decl_stmt|;
name|size_t
name|tsize
init|=
name|newSize
operator|*
sizeof|sizeof
argument_list|(
name|NAMED
operator|*
argument_list|)
decl_stmt|;
name|NAMED
modifier|*
modifier|*
name|newV
init|=
operator|(
name|NAMED
operator|*
operator|*
operator|)
name|table
operator|->
name|mem
operator|->
name|malloc_fcn
argument_list|(
name|tsize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newV
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|newV
argument_list|,
literal|0
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|v
index|[
name|i
index|]
condition|)
block|{
name|unsigned
name|long
name|newHash
init|=
name|hash
argument_list|(
name|table
operator|->
name|v
index|[
name|i
index|]
operator|->
name|name
argument_list|)
decl_stmt|;
name|size_t
name|j
init|=
name|newHash
operator|&
name|newMask
decl_stmt|;
name|step
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newV
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|step
condition|)
name|step
operator|=
name|PROBE_STEP
argument_list|(
name|newHash
argument_list|,
name|newMask
argument_list|,
name|newPower
argument_list|)
expr_stmt|;
name|j
operator|<
name|step
condition|?
operator|(
name|j
operator|+=
name|newSize
operator|-
name|step
operator|)
else|:
operator|(
name|j
operator|-=
name|step
operator|)
expr_stmt|;
block|}
name|newV
index|[
name|j
index|]
operator|=
name|table
operator|->
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
name|table
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|table
operator|->
name|v
argument_list|)
expr_stmt|;
name|table
operator|->
name|v
operator|=
name|newV
expr_stmt|;
name|table
operator|->
name|power
operator|=
name|newPower
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|newSize
expr_stmt|;
name|i
operator|=
name|h
operator|&
name|newMask
expr_stmt|;
name|step
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|table
operator|->
name|v
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|step
condition|)
name|step
operator|=
name|PROBE_STEP
argument_list|(
name|h
argument_list|,
name|newMask
argument_list|,
name|newPower
argument_list|)
expr_stmt|;
name|i
operator|<
name|step
condition|?
operator|(
name|i
operator|+=
name|newSize
operator|-
name|step
operator|)
else|:
operator|(
name|i
operator|-=
name|step
operator|)
expr_stmt|;
block|}
block|}
block|}
name|table
operator|->
name|v
index|[
name|i
index|]
operator|=
operator|(
name|NAMED
operator|*
operator|)
name|table
operator|->
name|mem
operator|->
name|malloc_fcn
argument_list|(
name|createSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|v
index|[
name|i
index|]
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|table
operator|->
name|v
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|createSize
argument_list|)
expr_stmt|;
name|table
operator|->
name|v
index|[
name|i
index|]
operator|->
name|name
operator|=
name|name
expr_stmt|;
operator|(
name|table
operator|->
name|used
operator|)
operator|++
expr_stmt|;
return|return
name|table
operator|->
name|v
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|hashTableClear
parameter_list|(
name|HASH_TABLE
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|table
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|table
operator|->
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|table
operator|->
name|v
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|table
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|hashTableDestroy
parameter_list|(
name|HASH_TABLE
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|table
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|table
operator|->
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|table
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|table
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|hashTableInit
parameter_list|(
name|HASH_TABLE
modifier|*
name|p
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|p
operator|->
name|power
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|v
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|mem
operator|=
name|ms
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|hashTableIterInit
parameter_list|(
name|HASH_TABLE_ITER
modifier|*
name|iter
parameter_list|,
specifier|const
name|HASH_TABLE
modifier|*
name|table
parameter_list|)
block|{
name|iter
operator|->
name|p
operator|=
name|table
operator|->
name|v
expr_stmt|;
name|iter
operator|->
name|end
operator|=
name|iter
operator|->
name|p
operator|+
name|table
operator|->
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NAMED
modifier|*
name|FASTCALL
name|hashTableIterNext
parameter_list|(
name|HASH_TABLE_ITER
modifier|*
name|iter
parameter_list|)
block|{
while|while
condition|(
name|iter
operator|->
name|p
operator|!=
name|iter
operator|->
name|end
condition|)
block|{
name|NAMED
modifier|*
name|tem
init|=
operator|*
operator|(
name|iter
operator|->
name|p
operator|)
operator|++
decl_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|poolInit
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Memory_Handling_Suite
modifier|*
name|ms
parameter_list|)
block|{
name|pool
operator|->
name|blocks
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|freeBlocks
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|mem
operator|=
name|ms
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|poolClear
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pool
operator|->
name|freeBlocks
condition|)
name|pool
operator|->
name|freeBlocks
operator|=
name|pool
operator|->
name|blocks
expr_stmt|;
else|else
block|{
name|BLOCK
modifier|*
name|p
init|=
name|pool
operator|->
name|blocks
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|BLOCK
modifier|*
name|tem
init|=
name|p
operator|->
name|next
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|pool
operator|->
name|freeBlocks
expr_stmt|;
name|pool
operator|->
name|freeBlocks
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|tem
expr_stmt|;
block|}
block|}
name|pool
operator|->
name|blocks
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FASTCALL
name|poolDestroy
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
block|{
name|BLOCK
modifier|*
name|p
init|=
name|pool
operator|->
name|blocks
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|BLOCK
modifier|*
name|tem
init|=
name|p
operator|->
name|next
decl_stmt|;
name|pool
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|tem
expr_stmt|;
block|}
name|p
operator|=
name|pool
operator|->
name|freeBlocks
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|BLOCK
modifier|*
name|tem
init|=
name|p
operator|->
name|next
decl_stmt|;
name|pool
operator|->
name|mem
operator|->
name|free_fcn
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|tem
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|XML_Char
modifier|*
name|poolAppend
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pool
operator|->
name|ptr
operator|&&
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|XmlConvert
argument_list|(
name|enc
argument_list|,
operator|&
name|ptr
argument_list|,
name|end
argument_list|,
operator|(
name|ICHAR
operator|*
operator|*
operator|)
operator|&
operator|(
name|pool
operator|->
name|ptr
operator|)
argument_list|,
operator|(
name|ICHAR
operator|*
operator|)
name|pool
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
break|break;
if|if
condition|(
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|pool
operator|->
name|start
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|XML_Char
modifier|*
name|FASTCALL
name|poolCopyString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
name|s
operator|=
name|pool
operator|->
name|start
expr_stmt|;
name|poolFinish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|XML_Char
modifier|*
name|poolCopyStringN
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pool
operator|->
name|ptr
operator|&&
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|s
operator|=
name|pool
operator|->
name|start
expr_stmt|;
name|poolFinish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|XML_Char
modifier|*
name|FASTCALL
name|poolAppendString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|poolAppendChar
argument_list|(
name|pool
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|pool
operator|->
name|start
return|;
block|}
end_function

begin_function
specifier|static
name|XML_Char
modifier|*
name|poolStoreString
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
operator|!
name|poolAppend
argument_list|(
name|pool
argument_list|,
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pool
operator|->
name|ptr
operator|==
name|pool
operator|->
name|end
operator|&&
operator|!
name|poolGrow
argument_list|(
name|pool
argument_list|)
condition|)
return|return
name|NULL
return|;
operator|*
operator|(
name|pool
operator|->
name|ptr
operator|)
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|pool
operator|->
name|start
return|;
block|}
end_function

begin_function
specifier|static
name|XML_Bool
name|FASTCALL
name|poolGrow
parameter_list|(
name|STRING_POOL
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|->
name|freeBlocks
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|start
operator|==
literal|0
condition|)
block|{
name|pool
operator|->
name|blocks
operator|=
name|pool
operator|->
name|freeBlocks
expr_stmt|;
name|pool
operator|->
name|freeBlocks
operator|=
name|pool
operator|->
name|freeBlocks
operator|->
name|next
expr_stmt|;
name|pool
operator|->
name|blocks
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|pool
operator|->
name|blocks
operator|->
name|s
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|pool
operator|->
name|start
operator|+
name|pool
operator|->
name|blocks
operator|->
name|size
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|pool
operator|->
name|start
expr_stmt|;
return|return
name|XML_TRUE
return|;
block|}
if|if
condition|(
name|pool
operator|->
name|end
operator|-
name|pool
operator|->
name|start
operator|<
name|pool
operator|->
name|freeBlocks
operator|->
name|size
condition|)
block|{
name|BLOCK
modifier|*
name|tem
init|=
name|pool
operator|->
name|freeBlocks
operator|->
name|next
decl_stmt|;
name|pool
operator|->
name|freeBlocks
operator|->
name|next
operator|=
name|pool
operator|->
name|blocks
expr_stmt|;
name|pool
operator|->
name|blocks
operator|=
name|pool
operator|->
name|freeBlocks
expr_stmt|;
name|pool
operator|->
name|freeBlocks
operator|=
name|tem
expr_stmt|;
name|memcpy
argument_list|(
name|pool
operator|->
name|blocks
operator|->
name|s
argument_list|,
name|pool
operator|->
name|start
argument_list|,
operator|(
name|pool
operator|->
name|end
operator|-
name|pool
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|pool
operator|->
name|blocks
operator|->
name|s
operator|+
operator|(
name|pool
operator|->
name|ptr
operator|-
name|pool
operator|->
name|start
operator|)
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|pool
operator|->
name|blocks
operator|->
name|s
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|pool
operator|->
name|start
operator|+
name|pool
operator|->
name|blocks
operator|->
name|size
expr_stmt|;
return|return
name|XML_TRUE
return|;
block|}
block|}
if|if
condition|(
name|pool
operator|->
name|blocks
operator|&&
name|pool
operator|->
name|start
operator|==
name|pool
operator|->
name|blocks
operator|->
name|s
condition|)
block|{
name|int
name|blockSize
init|=
call|(
name|int
call|)
argument_list|(
name|pool
operator|->
name|end
operator|-
name|pool
operator|->
name|start
argument_list|)
operator|*
literal|2
decl_stmt|;
name|pool
operator|->
name|blocks
operator|=
operator|(
name|BLOCK
operator|*
operator|)
name|pool
operator|->
name|mem
operator|->
name|realloc_fcn
argument_list|(
name|pool
operator|->
name|blocks
argument_list|,
operator|(
name|offsetof
argument_list|(
name|BLOCK
argument_list|,
name|s
argument_list|)
operator|+
name|blockSize
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|blocks
operator|==
name|NULL
condition|)
return|return
name|XML_FALSE
return|;
name|pool
operator|->
name|blocks
operator|->
name|size
operator|=
name|blockSize
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|pool
operator|->
name|blocks
operator|->
name|s
operator|+
operator|(
name|pool
operator|->
name|ptr
operator|-
name|pool
operator|->
name|start
operator|)
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|pool
operator|->
name|blocks
operator|->
name|s
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|pool
operator|->
name|start
operator|+
name|blockSize
expr_stmt|;
block|}
else|else
block|{
name|BLOCK
modifier|*
name|tem
decl_stmt|;
name|int
name|blockSize
init|=
call|(
name|int
call|)
argument_list|(
name|pool
operator|->
name|end
operator|-
name|pool
operator|->
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockSize
operator|<
name|INIT_BLOCK_SIZE
condition|)
name|blockSize
operator|=
name|INIT_BLOCK_SIZE
expr_stmt|;
else|else
name|blockSize
operator|*=
literal|2
expr_stmt|;
name|tem
operator|=
operator|(
name|BLOCK
operator|*
operator|)
name|pool
operator|->
name|mem
operator|->
name|malloc_fcn
argument_list|(
name|offsetof
argument_list|(
name|BLOCK
argument_list|,
name|s
argument_list|)
operator|+
name|blockSize
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
return|return
name|XML_FALSE
return|;
name|tem
operator|->
name|size
operator|=
name|blockSize
expr_stmt|;
name|tem
operator|->
name|next
operator|=
name|pool
operator|->
name|blocks
expr_stmt|;
name|pool
operator|->
name|blocks
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|ptr
operator|!=
name|pool
operator|->
name|start
condition|)
name|memcpy
argument_list|(
name|tem
operator|->
name|s
argument_list|,
name|pool
operator|->
name|start
argument_list|,
operator|(
name|pool
operator|->
name|ptr
operator|-
name|pool
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|ptr
operator|=
name|tem
operator|->
name|s
operator|+
operator|(
name|pool
operator|->
name|ptr
operator|-
name|pool
operator|->
name|start
operator|)
expr_stmt|;
name|pool
operator|->
name|start
operator|=
name|tem
operator|->
name|s
expr_stmt|;
name|pool
operator|->
name|end
operator|=
name|tem
operator|->
name|s
operator|+
name|blockSize
expr_stmt|;
block|}
return|return
name|XML_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FASTCALL
name|nextScaffoldPart
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|CONTENT_SCAFFOLD
modifier|*
name|me
decl_stmt|;
name|int
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|dtd
operator|->
name|scaffIndex
condition|)
block|{
name|dtd
operator|->
name|scaffIndex
operator|=
operator|(
name|int
operator|*
operator|)
name|MALLOC
argument_list|(
name|groupSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtd
operator|->
name|scaffIndex
condition|)
return|return
operator|-
literal|1
return|;
name|dtd
operator|->
name|scaffIndex
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dtd
operator|->
name|scaffCount
operator|>=
name|dtd
operator|->
name|scaffSize
condition|)
block|{
name|CONTENT_SCAFFOLD
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|dtd
operator|->
name|scaffold
condition|)
block|{
name|temp
operator|=
operator|(
name|CONTENT_SCAFFOLD
operator|*
operator|)
name|REALLOC
argument_list|(
name|dtd
operator|->
name|scaffold
argument_list|,
name|dtd
operator|->
name|scaffSize
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|CONTENT_SCAFFOLD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|dtd
operator|->
name|scaffSize
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|CONTENT_SCAFFOLD
operator|*
operator|)
name|MALLOC
argument_list|(
name|INIT_SCAFFOLD_ELEMENTS
operator|*
sizeof|sizeof
argument_list|(
name|CONTENT_SCAFFOLD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|dtd
operator|->
name|scaffSize
operator|=
name|INIT_SCAFFOLD_ELEMENTS
expr_stmt|;
block|}
name|dtd
operator|->
name|scaffold
operator|=
name|temp
expr_stmt|;
block|}
name|next
operator|=
name|dtd
operator|->
name|scaffCount
operator|++
expr_stmt|;
name|me
operator|=
operator|&
name|dtd
operator|->
name|scaffold
index|[
name|next
index|]
expr_stmt|;
if|if
condition|(
name|dtd
operator|->
name|scaffLevel
condition|)
block|{
name|CONTENT_SCAFFOLD
modifier|*
name|parent
init|=
operator|&
name|dtd
operator|->
name|scaffold
index|[
name|dtd
operator|->
name|scaffIndex
index|[
name|dtd
operator|->
name|scaffLevel
operator|-
literal|1
index|]
index|]
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|lastchild
condition|)
block|{
name|dtd
operator|->
name|scaffold
index|[
name|parent
operator|->
name|lastchild
index|]
operator|.
name|nextsib
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parent
operator|->
name|childcnt
condition|)
name|parent
operator|->
name|firstchild
operator|=
name|next
expr_stmt|;
name|parent
operator|->
name|lastchild
operator|=
name|next
expr_stmt|;
name|parent
operator|->
name|childcnt
operator|++
expr_stmt|;
block|}
name|me
operator|->
name|firstchild
operator|=
name|me
operator|->
name|lastchild
operator|=
name|me
operator|->
name|childcnt
operator|=
name|me
operator|->
name|nextsib
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_node
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
name|int
name|src_node
parameter_list|,
name|XML_Content
modifier|*
name|dest
parameter_list|,
name|XML_Content
modifier|*
modifier|*
name|contpos
parameter_list|,
name|XML_Char
modifier|*
modifier|*
name|strpos
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|dest
operator|->
name|type
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|src_node
index|]
operator|.
name|type
expr_stmt|;
name|dest
operator|->
name|quant
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|src_node
index|]
operator|.
name|quant
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|==
name|XML_CTYPE_NAME
condition|)
block|{
specifier|const
name|XML_Char
modifier|*
name|src
decl_stmt|;
name|dest
operator|->
name|name
operator|=
operator|*
name|strpos
expr_stmt|;
name|src
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|src_node
index|]
operator|.
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
operator|(
operator|*
name|strpos
operator|)
operator|++
operator|=
operator|*
name|src
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|src
condition|)
break|break;
name|src
operator|++
expr_stmt|;
block|}
name|dest
operator|->
name|numchildren
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|children
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|cn
decl_stmt|;
name|dest
operator|->
name|numchildren
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|src_node
index|]
operator|.
name|childcnt
expr_stmt|;
name|dest
operator|->
name|children
operator|=
operator|*
name|contpos
expr_stmt|;
operator|*
name|contpos
operator|+=
name|dest
operator|->
name|numchildren
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cn
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|src_node
index|]
operator|.
name|firstchild
init|;
name|i
operator|<
name|dest
operator|->
name|numchildren
condition|;
name|i
operator|++
operator|,
name|cn
operator|=
name|dtd
operator|->
name|scaffold
index|[
name|cn
index|]
operator|.
name|nextsib
control|)
block|{
name|build_node
argument_list|(
name|parser
argument_list|,
name|cn
argument_list|,
operator|&
operator|(
name|dest
operator|->
name|children
index|[
name|i
index|]
operator|)
argument_list|,
name|contpos
argument_list|,
name|strpos
argument_list|)
expr_stmt|;
block|}
name|dest
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|XML_Content
modifier|*
name|build_model
parameter_list|(
name|XML_Parser
name|parser
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
name|XML_Content
modifier|*
name|ret
decl_stmt|;
name|XML_Content
modifier|*
name|cpos
decl_stmt|;
name|XML_Char
modifier|*
name|str
decl_stmt|;
name|int
name|allocsize
init|=
operator|(
name|dtd
operator|->
name|scaffCount
operator|*
sizeof|sizeof
argument_list|(
name|XML_Content
argument_list|)
operator|+
operator|(
name|dtd
operator|->
name|contentStringLen
operator|*
sizeof|sizeof
argument_list|(
name|XML_Char
argument_list|)
operator|)
operator|)
decl_stmt|;
name|ret
operator|=
operator|(
name|XML_Content
operator|*
operator|)
name|MALLOC
argument_list|(
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
name|str
operator|=
operator|(
name|XML_Char
operator|*
operator|)
operator|(
operator|&
name|ret
index|[
name|dtd
operator|->
name|scaffCount
index|]
operator|)
expr_stmt|;
name|cpos
operator|=
operator|&
name|ret
index|[
literal|1
index|]
expr_stmt|;
name|build_node
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
operator|&
name|cpos
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|ELEMENT_TYPE
modifier|*
name|getElementType
parameter_list|(
name|XML_Parser
name|parser
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|DTD
modifier|*
specifier|const
name|dtd
init|=
name|_dtd
decl_stmt|;
comment|/* save one level of indirection */
specifier|const
name|XML_Char
modifier|*
name|name
init|=
name|poolStoreString
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|,
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|ELEMENT_TYPE
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
operator|(
name|ELEMENT_TYPE
operator|*
operator|)
name|lookup
argument_list|(
operator|&
name|dtd
operator|->
name|elementTypes
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ELEMENT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ret
operator|->
name|name
operator|!=
name|name
condition|)
name|poolDiscard
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
name|poolFinish
argument_list|(
operator|&
name|dtd
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setElementTypePrefix
argument_list|(
name|parser
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

