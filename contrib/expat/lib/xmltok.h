begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd    See the file COPYING for copying permission. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XmlTok_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|XmlTok_INCLUDED
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* The following token may be returned by XmlContentTok */
define|#
directive|define
name|XML_TOK_TRAILING_RSQB
value|-5
comment|/* ] or ]] at the end of the scan; might be                                     start of illegal ]]> sequence */
comment|/* The following tokens may be returned by both XmlPrologTok and    XmlContentTok. */
define|#
directive|define
name|XML_TOK_NONE
value|-4
comment|/* The string to be scanned is empty */
define|#
directive|define
name|XML_TOK_TRAILING_CR
value|-3
comment|/* A CR at the end of the scan;                                     might be part of CRLF sequence */
define|#
directive|define
name|XML_TOK_PARTIAL_CHAR
value|-2
comment|/* only part of a multibyte sequence */
define|#
directive|define
name|XML_TOK_PARTIAL
value|-1
comment|/* only part of a token */
define|#
directive|define
name|XML_TOK_INVALID
value|0
comment|/* The following tokens are returned by XmlContentTok; some are also    returned by XmlAttributeValueTok, XmlEntityTok, XmlCdataSectionTok. */
define|#
directive|define
name|XML_TOK_START_TAG_WITH_ATTS
value|1
define|#
directive|define
name|XML_TOK_START_TAG_NO_ATTS
value|2
define|#
directive|define
name|XML_TOK_EMPTY_ELEMENT_WITH_ATTS
value|3
comment|/* empty element tag<e/> */
define|#
directive|define
name|XML_TOK_EMPTY_ELEMENT_NO_ATTS
value|4
define|#
directive|define
name|XML_TOK_END_TAG
value|5
define|#
directive|define
name|XML_TOK_DATA_CHARS
value|6
define|#
directive|define
name|XML_TOK_DATA_NEWLINE
value|7
define|#
directive|define
name|XML_TOK_CDATA_SECT_OPEN
value|8
define|#
directive|define
name|XML_TOK_ENTITY_REF
value|9
define|#
directive|define
name|XML_TOK_CHAR_REF
value|10
comment|/* numeric character reference */
comment|/* The following tokens may be returned by both XmlPrologTok and    XmlContentTok. */
define|#
directive|define
name|XML_TOK_PI
value|11
comment|/* processing instruction */
define|#
directive|define
name|XML_TOK_XML_DECL
value|12
comment|/* XML decl or text decl */
define|#
directive|define
name|XML_TOK_COMMENT
value|13
define|#
directive|define
name|XML_TOK_BOM
value|14
comment|/* Byte order mark */
comment|/* The following tokens are returned only by XmlPrologTok */
define|#
directive|define
name|XML_TOK_PROLOG_S
value|15
define|#
directive|define
name|XML_TOK_DECL_OPEN
value|16
comment|/*<!foo */
define|#
directive|define
name|XML_TOK_DECL_CLOSE
value|17
comment|/*> */
define|#
directive|define
name|XML_TOK_NAME
value|18
define|#
directive|define
name|XML_TOK_NMTOKEN
value|19
define|#
directive|define
name|XML_TOK_POUND_NAME
value|20
comment|/* #name */
define|#
directive|define
name|XML_TOK_OR
value|21
comment|/* | */
define|#
directive|define
name|XML_TOK_PERCENT
value|22
define|#
directive|define
name|XML_TOK_OPEN_PAREN
value|23
define|#
directive|define
name|XML_TOK_CLOSE_PAREN
value|24
define|#
directive|define
name|XML_TOK_OPEN_BRACKET
value|25
define|#
directive|define
name|XML_TOK_CLOSE_BRACKET
value|26
define|#
directive|define
name|XML_TOK_LITERAL
value|27
define|#
directive|define
name|XML_TOK_PARAM_ENTITY_REF
value|28
define|#
directive|define
name|XML_TOK_INSTANCE_START
value|29
comment|/* The following occur only in element type declarations */
define|#
directive|define
name|XML_TOK_NAME_QUESTION
value|30
comment|/* name? */
define|#
directive|define
name|XML_TOK_NAME_ASTERISK
value|31
comment|/* name* */
define|#
directive|define
name|XML_TOK_NAME_PLUS
value|32
comment|/* name+ */
define|#
directive|define
name|XML_TOK_COND_SECT_OPEN
value|33
comment|/*<![ */
define|#
directive|define
name|XML_TOK_COND_SECT_CLOSE
value|34
comment|/* ]]> */
define|#
directive|define
name|XML_TOK_CLOSE_PAREN_QUESTION
value|35
comment|/* )? */
define|#
directive|define
name|XML_TOK_CLOSE_PAREN_ASTERISK
value|36
comment|/* )* */
define|#
directive|define
name|XML_TOK_CLOSE_PAREN_PLUS
value|37
comment|/* )+ */
define|#
directive|define
name|XML_TOK_COMMA
value|38
comment|/* The following token is returned only by XmlAttributeValueTok */
define|#
directive|define
name|XML_TOK_ATTRIBUTE_VALUE_S
value|39
comment|/* The following token is returned only by XmlCdataSectionTok */
define|#
directive|define
name|XML_TOK_CDATA_SECT_CLOSE
value|40
comment|/* With namespace processing this is returned by XmlPrologTok for a    name with a colon. */
define|#
directive|define
name|XML_TOK_PREFIXED_NAME
value|41
ifdef|#
directive|ifdef
name|XML_DTD
define|#
directive|define
name|XML_TOK_IGNORE_SECT
value|42
endif|#
directive|endif
comment|/* XML_DTD */
ifdef|#
directive|ifdef
name|XML_DTD
define|#
directive|define
name|XML_N_STATES
value|4
else|#
directive|else
comment|/* not XML_DTD */
define|#
directive|define
name|XML_N_STATES
value|3
endif|#
directive|endif
comment|/* not XML_DTD */
define|#
directive|define
name|XML_PROLOG_STATE
value|0
define|#
directive|define
name|XML_CONTENT_STATE
value|1
define|#
directive|define
name|XML_CDATA_SECTION_STATE
value|2
ifdef|#
directive|ifdef
name|XML_DTD
define|#
directive|define
name|XML_IGNORE_SECTION_STATE
value|3
endif|#
directive|endif
comment|/* XML_DTD */
define|#
directive|define
name|XML_N_LITERAL_TYPES
value|2
define|#
directive|define
name|XML_ATTRIBUTE_VALUE_LITERAL
value|0
define|#
directive|define
name|XML_ENTITY_VALUE_LITERAL
value|1
comment|/* The size of the buffer passed to XmlUtf8Encode must be at least this. */
define|#
directive|define
name|XML_UTF8_ENCODE_MAX
value|4
comment|/* The size of the buffer passed to XmlUtf16Encode must be at least this. */
define|#
directive|define
name|XML_UTF16_ENCODE_MAX
value|2
typedef|typedef
struct|struct
name|position
block|{
comment|/* first line and first column are 0 not 1 */
name|XML_Size
name|lineNumber
decl_stmt|;
name|XML_Size
name|columnNumber
decl_stmt|;
block|}
name|POSITION
typedef|;
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|valuePtr
decl_stmt|;
specifier|const
name|char
modifier|*
name|valueEnd
decl_stmt|;
name|char
name|normalized
decl_stmt|;
block|}
name|ATTRIBUTE
typedef|;
struct_decl|struct
name|encoding
struct_decl|;
typedef|typedef
name|struct
name|encoding
name|ENCODING
typedef|;
typedef|typedef
name|int
function_decl|(
name|PTRCALL
modifier|*
name|SCANNER
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
struct|struct
name|encoding
block|{
name|SCANNER
name|scanners
index|[
name|XML_N_STATES
index|]
decl_stmt|;
name|SCANNER
name|literalScanners
index|[
name|XML_N_LITERAL_TYPES
index|]
decl_stmt|;
name|int
function_decl|(
name|PTRCALL
modifier|*
name|sameName
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRCALL
modifier|*
name|nameMatchesAscii
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRFASTCALL
modifier|*
name|nameLength
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
function_decl|(
name|PTRFASTCALL
modifier|*
name|skipS
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRCALL
modifier|*
name|getAtts
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|attsMax
parameter_list|,
name|ATTRIBUTE
modifier|*
name|atts
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRFASTCALL
modifier|*
name|charRefNumber
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRCALL
modifier|*
name|predefinedEntityName
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
name|PTRCALL
modifier|*
name|updatePosition
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|POSITION
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
name|PTRCALL
modifier|*
name|isPublicId
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|badPtr
parameter_list|)
function_decl|;
name|void
function_decl|(
name|PTRCALL
modifier|*
name|utf8Convert
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|char
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|char
modifier|*
name|toLim
parameter_list|)
function_decl|;
name|void
function_decl|(
name|PTRCALL
modifier|*
name|utf16Convert
function_decl|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fromP
parameter_list|,
specifier|const
name|char
modifier|*
name|fromLim
parameter_list|,
name|unsigned
name|short
modifier|*
modifier|*
name|toP
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|toLim
parameter_list|)
function_decl|;
name|int
name|minBytesPerChar
decl_stmt|;
name|char
name|isUtf8
decl_stmt|;
name|char
name|isUtf16
decl_stmt|;
block|}
struct|;
comment|/* Scan the string starting at ptr until the end of the next complete    token, but do not scan past eptr.  Return an integer giving the    type of token.     Return XML_TOK_NONE when ptr == eptr; nextTokPtr will not be set.     Return XML_TOK_PARTIAL when the string does not contain a complete    token; nextTokPtr will not be set.     Return XML_TOK_INVALID when the string does not start a valid    token; nextTokPtr will be set to point to the character which made    the token invalid.     Otherwise the string starts with a valid token; nextTokPtr will be    set to point to the character following the end of that token.     Each data character counts as a single token, but adjacent data    characters may be returned together.  Similarly for characters in    the prolog outside literals, comments and processing instructions. */
define|#
directive|define
name|XmlTok
parameter_list|(
name|enc
parameter_list|,
name|state
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|(((enc)->scanners[state])(enc, ptr, end, nextTokPtr))
define|#
directive|define
name|XmlPrologTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlTok(enc, XML_PROLOG_STATE, ptr, end, nextTokPtr)
define|#
directive|define
name|XmlContentTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlTok(enc, XML_CONTENT_STATE, ptr, end, nextTokPtr)
define|#
directive|define
name|XmlCdataSectionTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlTok(enc, XML_CDATA_SECTION_STATE, ptr, end, nextTokPtr)
ifdef|#
directive|ifdef
name|XML_DTD
define|#
directive|define
name|XmlIgnoreSectionTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlTok(enc, XML_IGNORE_SECTION_STATE, ptr, end, nextTokPtr)
endif|#
directive|endif
comment|/* XML_DTD */
comment|/* This is used for performing a 2nd-level tokenization on the content    of a literal that has already been returned by XmlTok. */
define|#
directive|define
name|XmlLiteralTok
parameter_list|(
name|enc
parameter_list|,
name|literalType
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|(((enc)->literalScanners[literalType])(enc, ptr, end, nextTokPtr))
define|#
directive|define
name|XmlAttributeValueTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlLiteralTok(enc, XML_ATTRIBUTE_VALUE_LITERAL, ptr, end, nextTokPtr)
define|#
directive|define
name|XmlEntityValueTok
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|XmlLiteralTok(enc, XML_ENTITY_VALUE_LITERAL, ptr, end, nextTokPtr)
define|#
directive|define
name|XmlSameName
parameter_list|(
name|enc
parameter_list|,
name|ptr1
parameter_list|,
name|ptr2
parameter_list|)
value|(((enc)->sameName)(enc, ptr1, ptr2))
define|#
directive|define
name|XmlNameMatchesAscii
parameter_list|(
name|enc
parameter_list|,
name|ptr1
parameter_list|,
name|end1
parameter_list|,
name|ptr2
parameter_list|)
define|\
value|(((enc)->nameMatchesAscii)(enc, ptr1, end1, ptr2))
define|#
directive|define
name|XmlNameLength
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(((enc)->nameLength)(enc, ptr))
define|#
directive|define
name|XmlSkipS
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(((enc)->skipS)(enc, ptr))
define|#
directive|define
name|XmlGetAttributes
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|attsMax
parameter_list|,
name|atts
parameter_list|)
define|\
value|(((enc)->getAtts)(enc, ptr, attsMax, atts))
define|#
directive|define
name|XmlCharRefNumber
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(((enc)->charRefNumber)(enc, ptr))
define|#
directive|define
name|XmlPredefinedEntityName
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|)
define|\
value|(((enc)->predefinedEntityName)(enc, ptr, end))
define|#
directive|define
name|XmlUpdatePosition
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|pos
parameter_list|)
define|\
value|(((enc)->updatePosition)(enc, ptr, end, pos))
define|#
directive|define
name|XmlIsPublicId
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|badPtr
parameter_list|)
define|\
value|(((enc)->isPublicId)(enc, ptr, end, badPtr))
define|#
directive|define
name|XmlUtf8Convert
parameter_list|(
name|enc
parameter_list|,
name|fromP
parameter_list|,
name|fromLim
parameter_list|,
name|toP
parameter_list|,
name|toLim
parameter_list|)
define|\
value|(((enc)->utf8Convert)(enc, fromP, fromLim, toP, toLim))
define|#
directive|define
name|XmlUtf16Convert
parameter_list|(
name|enc
parameter_list|,
name|fromP
parameter_list|,
name|fromLim
parameter_list|,
name|toP
parameter_list|,
name|toLim
parameter_list|)
define|\
value|(((enc)->utf16Convert)(enc, fromP, fromLim, toP, toLim))
typedef|typedef
struct|struct
block|{
name|ENCODING
name|initEnc
decl_stmt|;
specifier|const
name|ENCODING
modifier|*
modifier|*
name|encPtr
decl_stmt|;
block|}
name|INIT_ENCODING
typedef|;
name|int
name|XmlParseXmlDecl
parameter_list|(
name|int
name|isGeneralTextEntity
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|badPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionEndPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|encodingNamePtr
parameter_list|,
specifier|const
name|ENCODING
modifier|*
modifier|*
name|namedEncodingPtr
parameter_list|,
name|int
modifier|*
name|standalonePtr
parameter_list|)
function_decl|;
name|int
name|XmlInitEncoding
parameter_list|(
name|INIT_ENCODING
modifier|*
parameter_list|,
specifier|const
name|ENCODING
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|const
name|ENCODING
modifier|*
name|XmlGetUtf8InternalEncoding
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|ENCODING
modifier|*
name|XmlGetUtf16InternalEncoding
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|FASTCALL
name|XmlUtf8Encode
parameter_list|(
name|int
name|charNumber
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
name|int
name|FASTCALL
name|XmlUtf16Encode
parameter_list|(
name|int
name|charNumber
parameter_list|,
name|unsigned
name|short
modifier|*
name|buf
parameter_list|)
function_decl|;
name|int
name|XmlSizeOfUnknownEncoding
parameter_list|(
name|void
parameter_list|)
function_decl|;
typedef|typedef
name|int
function_decl|(
name|XMLCALL
modifier|*
name|CONVERTER
function_decl|)
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
name|ENCODING
modifier|*
name|XmlInitUnknownEncoding
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
modifier|*
name|table
parameter_list|,
name|CONVERTER
name|convert
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
function_decl|;
name|int
name|XmlParseXmlDeclNS
parameter_list|(
name|int
name|isGeneralTextEntity
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|badPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|versionEndPtr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|encodingNamePtr
parameter_list|,
specifier|const
name|ENCODING
modifier|*
modifier|*
name|namedEncodingPtr
parameter_list|,
name|int
modifier|*
name|standalonePtr
parameter_list|)
function_decl|;
name|int
name|XmlInitEncodingNS
parameter_list|(
name|INIT_ENCODING
modifier|*
parameter_list|,
specifier|const
name|ENCODING
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|const
name|ENCODING
modifier|*
name|XmlGetUtf8InternalEncodingNS
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|const
name|ENCODING
modifier|*
name|XmlGetUtf16InternalEncodingNS
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ENCODING
modifier|*
name|XmlInitUnknownEncodingNS
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
modifier|*
name|table
parameter_list|,
name|CONVERTER
name|convert
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not XmlTok_INCLUDED */
end_comment

end_unit

