begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A tar (tape archiver) program.     Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001    Free Software Foundation, Inc.     Written by John Gilmore, starting 1985-08-25.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
name|SIGCHLD
operator|&&
name|defined
name|SIGCLD
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following causes "common.h" to produce definitions of all the global    variables, rather than just "extern" declarations of them.  GNU tar does    depend on the system loader to preset all GLOBAL variables to neutral (or    zero) values; explicit initialization is usually not done.  */
end_comment

begin_define
define|#
directive|define
name|GLOBAL
end_define

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|<print-copyr.h>
end_include

begin_include
include|#
directive|include
file|<localedir.h>
end_include

begin_include
include|#
directive|include
file|<prepargs.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|<xstrtol.h>
end_include

begin_function_decl
name|time_t
name|get_date
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Local declarations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCHIVE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCHIVE
value|"tar.out"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_BLOCKING
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_BLOCKING
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous.  */
end_comment

begin_comment
comment|/* Name of option using stdin.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|stdin_used_by
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Doesn't return if stdin already requested.  */
end_comment

begin_function
name|void
name|request_stdin
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
name|stdin_used_by
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Options `-%s' and `-%s' both want standard input"
argument_list|)
operator|,
name|stdin_used_by
operator|,
name|option
operator|)
argument_list|)
expr_stmt|;
name|stdin_used_by
operator|=
name|option
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if and only if the user typed 'y' or 'Y'.  */
end_comment

begin_function
name|int
name|confirm
parameter_list|(
specifier|const
name|char
modifier|*
name|message_action
parameter_list|,
specifier|const
name|char
modifier|*
name|message_name
parameter_list|)
block|{
specifier|static
name|FILE
modifier|*
name|confirm_file
decl_stmt|;
specifier|static
name|int
name|confirm_file_EOF
decl_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
block|{
if|if
condition|(
name|archive
operator|==
literal|0
operator|||
name|stdin_used_by
condition|)
block|{
name|confirm_file
operator|=
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
name|open_fatal
argument_list|(
name|TTY_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|request_stdin
argument_list|(
literal|"-w"
argument_list|)
expr_stmt|;
name|confirm_file
operator|=
name|stdin
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|"%s %s?"
argument_list|,
name|message_action
argument_list|,
name|quote
argument_list|(
name|message_name
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdlis
argument_list|)
expr_stmt|;
block|{
name|int
name|reply
init|=
name|confirm_file_EOF
condition|?
name|EOF
else|:
name|getc
argument_list|(
name|confirm_file
argument_list|)
decl_stmt|;
name|int
name|character
decl_stmt|;
for|for
control|(
name|character
operator|=
name|reply
init|;
name|character
operator|!=
literal|'\n'
condition|;
name|character
operator|=
name|getc
argument_list|(
name|confirm_file
argument_list|)
control|)
if|if
condition|(
name|character
operator|==
name|EOF
condition|)
block|{
name|confirm_file_EOF
operator|=
literal|1
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdlis
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdlis
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|reply
operator|==
literal|'y'
operator|||
name|reply
operator|==
literal|'Y'
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Options.  */
end_comment

begin_comment
comment|/* For long options that unconditionally set a single flag, we have getopt    do it.  For the others, we share the code for the equivalent short    named option, the name of which is stored in the otherwise-unused `val'    field of the `struct option'; for long options that have no equivalent    short option, we use non-characters as pseudo short options,    starting at CHAR_MAX + 1 and going upwards.  */
end_comment

begin_enum
enum|enum
block|{
name|ANCHORED_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|BACKUP_OPTION
block|,
name|DELETE_OPTION
block|,
name|EXCLUDE_OPTION
block|,
name|GROUP_OPTION
block|,
name|IGNORE_CASE_OPTION
block|,
name|MODE_OPTION
block|,
name|NEWER_MTIME_OPTION
block|,
name|NO_ANCHORED_OPTION
block|,
name|NO_IGNORE_CASE_OPTION
block|,
name|NO_WILDCARDS_OPTION
block|,
name|NO_WILDCARDS_MATCH_SLASH_OPTION
block|,
name|NULL_OPTION
block|,
name|OVERWRITE_OPTION
block|,
name|OVERWRITE_DIR_OPTION
block|,
name|OWNER_OPTION
block|,
name|POSIX_OPTION
block|,
name|PRESERVE_OPTION
block|,
name|RECORD_SIZE_OPTION
block|,
name|RSH_COMMAND_OPTION
block|,
name|SUFFIX_OPTION
block|,
name|USE_COMPRESS_PROGRAM_OPTION
block|,
name|VOLNO_FILE_OPTION
block|,
name|WILDCARDS_OPTION
block|,
name|WILDCARDS_MATCH_SLASH_OPTION
block|,
comment|/* Some cleanup is being made in GNU tar long options.  Using old names is      allowed for a while, but will also send a warning to stderr.  Take old      names out in 1.14, or in summer 1997, whichever happens last.  */
name|OBSOLETE_ABSOLUTE_NAMES
block|,
name|OBSOLETE_BLOCK_COMPRESS
block|,
name|OBSOLETE_BLOCKING_FACTOR
block|,
name|OBSOLETE_BLOCK_NUMBER
block|,
name|OBSOLETE_READ_FULL_RECORDS
block|,
name|OBSOLETE_TOUCH
block|,
name|OBSOLETE_VERSION_CONTROL
block|}
enum|;
end_enum

begin_comment
comment|/* If nonzero, display usage information and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, print the version on standard output and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"absolute-names"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'P'
block|}
block|,
block|{
literal|"absolute-paths"
block|,
name|no_argument
block|,
literal|0
block|,
name|OBSOLETE_ABSOLUTE_NAMES
block|}
block|,
block|{
literal|"after-date"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"anchored"
block|,
name|no_argument
block|,
literal|0
block|,
name|ANCHORED_OPTION
block|}
block|,
block|{
literal|"append"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"atime-preserve"
block|,
name|no_argument
block|,
operator|&
name|atime_preserve_option
block|,
literal|1
block|}
block|,
block|{
literal|"backup"
block|,
name|optional_argument
block|,
literal|0
block|,
name|BACKUP_OPTION
block|}
block|,
block|{
literal|"block-compress"
block|,
name|no_argument
block|,
literal|0
block|,
name|OBSOLETE_BLOCK_COMPRESS
block|}
block|,
block|{
literal|"block-number"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"block-size"
block|,
name|required_argument
block|,
literal|0
block|,
name|OBSOLETE_BLOCKING_FACTOR
block|}
block|,
block|{
literal|"blocking-factor"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"bzip"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"bzip2"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"bunzip2"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"catenate"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"checkpoint"
block|,
name|no_argument
block|,
operator|&
name|checkpoint_option
block|,
literal|1
block|}
block|,
block|{
literal|"compare"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"compress"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
block|{
literal|"concatenate"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"confirmation"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
comment|/* FIXME: --selective as a synonym for --confirmation?  */
block|{
literal|"create"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"delete"
block|,
name|no_argument
block|,
literal|0
block|,
name|DELETE_OPTION
block|}
block|,
block|{
literal|"dereference"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"diff"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"exclude"
block|,
name|required_argument
block|,
literal|0
block|,
name|EXCLUDE_OPTION
block|}
block|,
block|{
literal|"exclude-from"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"extract"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"fast-read"
block|,
name|no_argument
block|,
operator|&
name|fast_read_option
block|,
literal|1
block|}
block|,
block|{
literal|"file"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"files-from"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"force-local"
block|,
name|no_argument
block|,
operator|&
name|force_local_option
block|,
literal|1
block|}
block|,
block|{
literal|"get"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"group"
block|,
name|required_argument
block|,
literal|0
block|,
name|GROUP_OPTION
block|}
block|,
block|{
literal|"gunzip"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"gzip"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|show_help
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
literal|0
block|,
name|IGNORE_CASE_OPTION
block|}
block|,
block|{
literal|"ignore-failed-read"
block|,
name|no_argument
block|,
operator|&
name|ignore_failed_read_option
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-zeros"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
comment|/* FIXME: --ignore-end as a new name for --ignore-zeros?  */
block|{
literal|"incremental"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'G'
block|}
block|,
block|{
literal|"info-script"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"interactive"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"keep-old-files"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'k'
block|}
block|,
block|{
literal|"label"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"list"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"listed-incremental"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"mode"
block|,
name|required_argument
block|,
literal|0
block|,
name|MODE_OPTION
block|}
block|,
block|{
literal|"modification-time"
block|,
name|no_argument
block|,
literal|0
block|,
name|OBSOLETE_TOUCH
block|}
block|,
block|{
literal|"multi-volume"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'M'
block|}
block|,
block|{
literal|"new-volume-script"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"newer"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"newer-mtime"
block|,
name|required_argument
block|,
literal|0
block|,
name|NEWER_MTIME_OPTION
block|}
block|,
block|{
literal|"null"
block|,
name|no_argument
block|,
literal|0
block|,
name|NULL_OPTION
block|}
block|,
block|{
literal|"no-anchored"
block|,
name|no_argument
block|,
literal|0
block|,
name|NO_ANCHORED_OPTION
block|}
block|,
block|{
literal|"no-ignore-case"
block|,
name|no_argument
block|,
literal|0
block|,
name|NO_IGNORE_CASE_OPTION
block|}
block|,
block|{
literal|"no-wildcards"
block|,
name|no_argument
block|,
literal|0
block|,
name|NO_WILDCARDS_OPTION
block|}
block|,
block|{
literal|"no-wildcards-match-slash"
block|,
name|no_argument
block|,
literal|0
block|,
name|NO_WILDCARDS_MATCH_SLASH_OPTION
block|}
block|,
block|{
literal|"norecurse"
block|,
name|no_argument
block|,
operator|&
name|recursion_option
block|,
literal|0
block|}
block|,
block|{
literal|"no-recursion"
block|,
name|no_argument
block|,
operator|&
name|recursion_option
block|,
literal|0
block|}
block|,
block|{
literal|"no-same-owner"
block|,
name|no_argument
block|,
operator|&
name|same_owner_option
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"no-same-permissions"
block|,
name|no_argument
block|,
operator|&
name|same_permissions_option
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"numeric-owner"
block|,
name|no_argument
block|,
operator|&
name|numeric_owner_option
block|,
literal|1
block|}
block|,
block|{
literal|"old-archive"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"one-file-system"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"overwrite"
block|,
name|no_argument
block|,
literal|0
block|,
name|OVERWRITE_OPTION
block|}
block|,
block|{
literal|"overwrite-dir"
block|,
name|no_argument
block|,
literal|0
block|,
name|OVERWRITE_DIR_OPTION
block|}
block|,
block|{
literal|"owner"
block|,
name|required_argument
block|,
literal|0
block|,
name|OWNER_OPTION
block|}
block|,
block|{
literal|"portability"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"posix"
block|,
name|no_argument
block|,
literal|0
block|,
name|POSIX_OPTION
block|}
block|,
block|{
literal|"preserve"
block|,
name|no_argument
block|,
literal|0
block|,
name|PRESERVE_OPTION
block|}
block|,
block|{
literal|"preserve-order"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"preserve-permissions"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"recursion"
block|,
name|no_argument
block|,
operator|&
name|recursion_option
block|,
name|FNM_LEADING_DIR
block|}
block|,
block|{
literal|"recursive-unlink"
block|,
name|no_argument
block|,
operator|&
name|recursive_unlink_option
block|,
literal|1
block|}
block|,
block|{
literal|"read-full-blocks"
block|,
name|no_argument
block|,
literal|0
block|,
name|OBSOLETE_READ_FULL_RECORDS
block|}
block|,
block|{
literal|"read-full-records"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'B'
block|}
block|,
comment|/* FIXME: --partial-blocks might be a synonym for --read-full-records?  */
block|{
literal|"record-number"
block|,
name|no_argument
block|,
literal|0
block|,
name|OBSOLETE_BLOCK_NUMBER
block|}
block|,
block|{
literal|"record-size"
block|,
name|required_argument
block|,
literal|0
block|,
name|RECORD_SIZE_OPTION
block|}
block|,
block|{
literal|"remove-files"
block|,
name|no_argument
block|,
operator|&
name|remove_files_option
block|,
literal|1
block|}
block|,
block|{
literal|"rsh-command"
block|,
name|required_argument
block|,
literal|0
block|,
name|RSH_COMMAND_OPTION
block|}
block|,
block|{
literal|"same-order"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"same-owner"
block|,
name|no_argument
block|,
operator|&
name|same_owner_option
block|,
literal|1
block|}
block|,
block|{
literal|"same-permissions"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"show-omitted-dirs"
block|,
name|no_argument
block|,
operator|&
name|show_omitted_dirs_option
block|,
literal|1
block|}
block|,
block|{
literal|"sparse"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"starting-file"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"suffix"
block|,
name|required_argument
block|,
literal|0
block|,
name|SUFFIX_OPTION
block|}
block|,
block|{
literal|"tape-length"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"totals"
block|,
name|no_argument
block|,
operator|&
name|totals_option
block|,
literal|1
block|}
block|,
block|{
literal|"touch"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'m'
block|}
block|,
block|{
literal|"uncompress"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
block|{
literal|"ungzip"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"unlink"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"unlink-first"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"update"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
block|{
literal|"use-compress-program"
block|,
name|required_argument
block|,
literal|0
block|,
name|USE_COMPRESS_PROGRAM_OPTION
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"verify"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|show_version
block|,
literal|1
block|}
block|,
block|{
literal|"version-control"
block|,
name|required_argument
block|,
literal|0
block|,
name|OBSOLETE_VERSION_CONTROL
block|}
block|,
block|{
literal|"volno-file"
block|,
name|required_argument
block|,
literal|0
block|,
name|VOLNO_FILE_OPTION
block|}
block|,
block|{
literal|"wildcards"
block|,
name|no_argument
block|,
literal|0
block|,
name|WILDCARDS_OPTION
block|}
block|,
block|{
literal|"wildcards-match-slash"
block|,
name|no_argument
block|,
literal|0
block|,
name|WILDCARDS_MATCH_SLASH_OPTION
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a usage message and exit with STATUS.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
name|TAREXIT_SUCCESS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ GNU `tar' saves many files together into a single tape or disk archive, and\n\ can restore individual files from the archive.\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nUsage: %s [OPTION]... [FILE]...\n\ \n\ Examples:\n\   %s -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n\   %s -tvf archive.tar         # List all files in archive.tar verbosely.\n\   %s -xf archive.tar          # Extract all files from archive.tar.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ If a long option shows an argument as mandatory, then it is mandatory\n\ for the equivalent short option also.  Similarly for optional arguments.\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Main operation mode:\n\   -t, --list              list the contents of an archive\n\   -x, --extract, --get    extract files from an archive\n\   -c, --create            create a new archive\n\   -d, --diff, --compare   find differences between archive and file system\n\   -r, --append            append files to the end of an archive\n\   -u, --update            only append files newer than copy in archive\n\   -A, --catenate          append tar files to an archive\n\       --concatenate       same as -A\n\       --delete            delete from the archive (not on mag tapes!)\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Operation modifiers:\n\   -W, --verify               attempt to verify the archive after writing it\n\       --remove-files         remove files after adding them to the archive\n\   -k, --keep-old-files       don't replace existing files when extracting\n\       --overwrite            overwrite existing files when extracting\n\       --overwrite-dir        overwrite directory metadata when extracting\n\   -U, --unlink,\n\       --unlink-first         remove each file prior to extracting over it\n\       --recursive-unlink     empty hierarchies prior to extracting directory\n\   -S, --sparse               handle sparse files efficiently\n\   -O, --to-stdout            extract files to standard output\n\   -G, --incremental          handle old GNU-format incremental backup\n\   -g, --listed-incremental=FILE\n\                              handle new GNU-format incremental backup\n\       --ignore-failed-read   do not exit with nonzero on unreadable files\n\       --fast-read            stop after desired names in archive have been found\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Handling of file attributes:\n\       --owner=NAME             force NAME as owner for added files\n\       --group=NAME             force NAME as group for added files\n\       --mode=CHANGES           force (symbolic) mode CHANGES for added files\n\       --atime-preserve         don't change access times on dumped files\n\   -m, --modification-time      don't extract file modified time\n\       --same-owner             try extracting files with the same ownership\n\       --show-omitted-dirs      show omitted directories while processing the\n\                                archive\n\       --no-same-owner          extract files as yourself\n\       --numeric-owner          always use numbers for user/group names\n\   -p, --same-permissions       extract permissions information\n\       --no-same-permissions    do not extract permissions information\n\       --preserve-permissions   same as -p\n\   -s, --same-order             sort names to extract to match archive\n\       --preserve-order         same as -s\n\       --preserve               same as both -p and -s\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Device selection and switching:\n\   -f, --file=ARCHIVE             use archive file or device ARCHIVE\n\       --force-local              archive file is local even if it has a colon\n\       --rsh-command=COMMAND      use remote COMMAND instead of rsh\n\   -[0-7][lmh]                    specify drive and density\n\   -M, --multi-volume             create/list/extract multi-volume archive\n\   -L, --tape-length=NUM          change tape after writing NUM x 1024 bytes\n\   -F, --info-script=FILE         run script at end of each tape (implies -M)\n\       --new-volume-script=FILE   same as -F FILE\n\       --volno-file=FILE          use/update the volume number in FILE\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Device blocking:\n\   -b, --blocking-factor=BLOCKS   BLOCKS x 512 bytes per record\n\       --record-size=SIZE         SIZE bytes per record, multiple of 512\n\   -i, --ignore-zeros             ignore zeroed blocks in archive (means EOF)\n\   -B, --read-full-records        reblock as we read (for 4.2BSD pipes)\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Archive format selection:\n\   -V, --label=NAME                   create archive with volume name NAME\n\               PATTERN                at list/extract time, a globbing PATTERN\n\   -o, --old-archive, --portability   write a V7 format archive\n\       --posix                        write a POSIX format archive\n\   -j, -y, --bzip, --bzip2, --bunzip2 filter the archive through bzip2\n\   -z, --gzip, --ungzip               filter the archive through gzip\n\   -Z, --compress, --uncompress       filter the archive through compress\n\       --use-compress-program=PROG    filter through PROG (must accept -d)\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Local file selection:\n\   -C, --directory=DIR          change to directory DIR\n\   -T, -I, --files-from=NAME    get names to extract or create from file NAME\n\       --null                   -T reads null-terminated names, disable -C\n\       --exclude=PATTERN        exclude files, given as a a globbing PATTERN\n\   -X, --exclude-from=FILE      exclude patterns listed in FILE\n\       --anchored               exclude patterns match file name start (default)\n\       --no-anchored            exclude patterns match after any /\n\       --ignore-case            exclusion ignores case\n\       --no-ignore-case         exclusion is case sensitive (default)\n\       --wildcards              exclude patterns use wildcards (default)\n\       --no-wildcards           exclude patterns are plain strings\n\       --wildcards-match-slash  exclude pattern wildcards match '/' (default)\n\       --no-wildcards-match-slash exclude pattern wildcards do not match '/'\n\   -P, --absolute-names         don't strip leading `/'s from file names\n\   -h, --dereference            dump instead the files symlinks point to\n\   -n, --norecurse\n\       --no-recursion           avoid descending automatically in directories\n\   -l, --one-file-system        stay in local file system when creating archive\n\   -K, --starting-file=NAME     begin at file NAME in the archive\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|MSDOS
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\   -N, --newer=DATE             only store files with creation time newer than\n\                                DATE\n\       --newer-mtime=DATE       only store files with modification time newer\n\                                than DATE\n\       --after-date=DATE        same as -N\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\       --backup[=CONTROL]       backup before removal, choose version control\n\       --suffix=SUFFIX          backup before removal, override usual suffix\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Informative output:\n\       --help            print this help, then exit\n\       --version         print tar program version number, then exit\n\   -v, --verbose         verbosely list files processed\n\       --checkpoint      print number of buffer reads/writes\n\       --totals          print total bytes written while creating archive\n\   -R, --block-number    show block number within archive with each message\n\   -w, --interactive     ask for confirmation for every action\n\       --confirmation    same as -w\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\ \n\ The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n\ The version control may be set with --backup or VERSION_CONTROL, values are:\n\ \n\   t, numbered     make numbered backups\n\   nil, existing   numbered if numbered backups exist, simple otherwise\n\   never, simple   always make simple backups\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ GNU tar cannot read nor produce `--posix' archives.  If POSIXLY_CORRECT\n\ is set in the environment, GNU extensions are disallowed with `--posix'.\n\ Support for POSIX is only partially implemented, don't count on it yet.\n\ ARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE may be a textual date\n\ or a file name starting with `/' or `.', in which case the file's date is used.\n\ *This* `tar' defaults to `-f%s -b%d'.\n"
argument_list|)
argument_list|,
name|DEFAULT_ARCHIVE
argument_list|,
name|DEFAULT_BLOCKING
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\nReport bugs to<bug-tar@gnu.org>.\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the options for tar.  */
end_comment

begin_comment
comment|/* Available option letters are DEHIJQY and aenqy.  Some are reserved:     e  exit immediately with a nonzero exit status if unexpected errors occur    E  use extended headers (draft POSIX headers, that is)    I  same as T (for compatibility with Solaris tar)    n  the archive is quickly seekable, so don't worry about random seeks    q  stop after extracting the first occurrence of the named file    y  per-file gzip compression    Y  per-block gzip compression */
end_comment

begin_define
define|#
directive|define
name|OPTION_STRING
define|\
value|"-01234567ABC:F:GI:K:L:MnN:OPRST:UV:WX:Zb:cdf:g:hijklmoprstuvwxyz"
end_define

begin_function
specifier|static
name|void
name|set_subcommand_option
parameter_list|(
name|enum
name|subcommand
name|subcommand
parameter_list|)
block|{
if|if
condition|(
name|subcommand_option
operator|!=
name|UNKNOWN_SUBCOMMAND
operator|&&
name|subcommand_option
operator|!=
name|subcommand
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"You may not specify more than one `-Acdtrux' option"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|subcommand_option
operator|=
name|subcommand
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_use_compress_program_option
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|use_compress_program_option
operator|&&
name|strcmp
argument_list|(
name|use_compress_program_option
argument_list|,
name|string
argument_list|)
operator|!=
literal|0
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Conflicting compression options"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|use_compress_program_option
operator|=
name|string
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|optchar
decl_stmt|;
comment|/* option letter */
name|int
name|input_files
decl_stmt|;
comment|/* number of input files */
specifier|const
name|char
modifier|*
name|backup_suffix_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|version_control_string
init|=
literal|0
decl_stmt|;
name|int
name|exclude_options
init|=
name|EXCLUDE_WILDCARDS
decl_stmt|;
comment|/* Set some default option values.  */
name|subcommand_option
operator|=
name|UNKNOWN_SUBCOMMAND
expr_stmt|;
name|archive_format
operator|=
name|DEFAULT_FORMAT
expr_stmt|;
name|blocking_factor
operator|=
name|DEFAULT_BLOCKING
expr_stmt|;
name|record_size
operator|=
name|DEFAULT_BLOCKING
operator|*
name|BLOCKSIZE
expr_stmt|;
name|excluded
operator|=
name|new_exclude
argument_list|()
expr_stmt|;
name|newer_mtime_option
operator|=
name|TYPE_MINIMUM
argument_list|(
name|time_t
argument_list|)
expr_stmt|;
name|recursion_option
operator|=
name|FNM_LEADING_DIR
expr_stmt|;
name|namelist_freed
operator|=
literal|0
expr_stmt|;
name|owner_option
operator|=
operator|-
literal|1
expr_stmt|;
name|group_option
operator|=
operator|-
literal|1
expr_stmt|;
name|backup_suffix_string
operator|=
name|getenv
argument_list|(
literal|"SIMPLE_BACKUP_SUFFIX"
argument_list|)
expr_stmt|;
comment|/* Convert old-style tar call by exploding option element and rearranging      options accordingly.  */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|int
name|new_argc
decl_stmt|;
comment|/* argc value for rearranged arguments */
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
comment|/* argv value for rearranged arguments */
name|char
modifier|*
specifier|const
modifier|*
name|in
decl_stmt|;
comment|/* cursor into original argv */
name|char
modifier|*
modifier|*
name|out
decl_stmt|;
comment|/* cursor into rearranged argv */
specifier|const
name|char
modifier|*
name|letter
decl_stmt|;
comment|/* cursor into old option letters */
name|char
name|buffer
index|[
literal|3
index|]
decl_stmt|;
comment|/* constructed option buffer */
specifier|const
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* cursor in OPTION_STRING */
comment|/* Initialize a constructed option.  */
name|buffer
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Allocate a new argument array, and copy program name in it.  */
name|new_argc
operator|=
name|argc
operator|-
literal|1
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new_argv
operator|=
name|xmalloc
argument_list|(
name|new_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|argv
expr_stmt|;
name|out
operator|=
name|new_argv
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
comment|/* Copy each old letter option as a separate option, and have the 	 corresponding argument moved next to it.  */
for|for
control|(
name|letter
operator|=
operator|*
name|in
operator|++
init|;
operator|*
name|letter
condition|;
name|letter
operator|++
control|)
block|{
name|buffer
index|[
literal|1
index|]
operator|=
operator|*
name|letter
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|xstrdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|strchr
argument_list|(
name|OPTION_STRING
argument_list|,
operator|*
name|letter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|&&
name|cursor
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|in
operator|<
name|argv
operator|+
name|argc
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
else|else
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Old option `%c' requires an argument."
argument_list|)
operator|,
operator|*
name|letter
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy all remaining options.  */
while|while
condition|(
name|in
operator|<
name|argv
operator|+
name|argc
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
comment|/* Replace the old option list by the new one.  */
name|argc
operator|=
name|new_argc
expr_stmt|;
name|argv
operator|=
name|new_argv
expr_stmt|;
block|}
comment|/* Parse all options and non-options as they appear.  */
name|input_files
operator|=
literal|0
expr_stmt|;
name|prepend_default_options
argument_list|(
name|getenv
argument_list|(
literal|"TAR_OPTIONS"
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
name|optchar
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTION_STRING
argument_list|,
name|long_options
argument_list|,
literal|0
argument_list|)
operator|,
name|optchar
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|optchar
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|TAREXIT_FAILURE
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
comment|/* File name or non-parsed option, because of RETURN_IN_ORDER 	   ordering triggered by the leading dash in OPTION_STRING.  */
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|input_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|set_subcommand_option
argument_list|(
name|CAT_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBSOLETE_BLOCK_COMPRESS
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option, now implied by --blocking-factor"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBSOLETE_BLOCKING_FACTOR
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --blocking-factor"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'b'
case|:
block|{
name|uintmax_t
name|u
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|u
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
operator|&&
name|u
operator|==
operator|(
name|blocking_factor
operator|=
name|u
operator|)
operator|&&
literal|0
operator|<
name|blocking_factor
operator|&&
name|u
operator|==
operator|(
name|record_size
operator|=
name|u
operator|*
name|BLOCKSIZE
operator|)
operator|/
name|BLOCKSIZE
operator|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s: %s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|,
name|_
argument_list|(
literal|"Invalid blocking factor"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OBSOLETE_READ_FULL_RECORDS
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --read-full-records"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'B'
case|:
comment|/* Try to reblock input records.  For reading 4.2BSD pipes.  */
comment|/* It would surely make sense to exchange -B and -R, but it seems 	   that -B has been used for a long while in Sun tar ans most 	   BSD-derived systems.  This is a consequence of the block/record 	   terminology confusion.  */
name|read_full_records_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|set_subcommand_option
argument_list|(
name|CREATE_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|name_add
argument_list|(
literal|"-C"
argument_list|)
expr_stmt|;
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|set_subcommand_option
argument_list|(
name|DIFF_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|archive_names
operator|==
name|allocated_archive_names
condition|)
block|{
name|allocated_archive_names
operator|*=
literal|2
expr_stmt|;
name|archive_name_array
operator|=
name|xrealloc
argument_list|(
name|archive_name_array
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|allocated_archive_names
argument_list|)
expr_stmt|;
block|}
name|archive_name_array
index|[
name|archive_names
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Since -F is only useful with -M, make it implied.  Run this 	   script at the end of each tape.  */
name|info_script_option
operator|=
name|optarg
expr_stmt|;
name|multi_volume_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|listed_incremental_option
operator|=
name|optarg
expr_stmt|;
name|after_date_option
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'G'
case|:
comment|/* We are making an incremental dump (FIXME: are we?); save 	   directories at the beginning of the archive, and include in each 	   directory its contents.  */
name|incremental_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Follow symbolic links.  */
name|dereference_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Ignore zero blocks (eofs).  This can't be the default, 	   because Unix tar writes two blocks of zeros, then pads out 	   the record with garbage.  */
name|ignore_zeros_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'y'
case|:
name|set_use_compress_program_option
argument_list|(
literal|"bzip2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Don't replace existing files.  */
name|old_files_option
operator|=
name|KEEP_OLD_FILES
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|starting_file_option
operator|=
literal|1
expr_stmt|;
name|addname
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* When dumping directories, don't dump files/subdirectories 	   that are on other filesystems.  */
name|one_file_system_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
block|{
name|uintmax_t
name|u
decl_stmt|;
if|if
condition|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|u
argument_list|,
literal|""
argument_list|)
operator|!=
name|LONGINT_OK
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s: %s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|,
name|_
argument_list|(
literal|"Invalid tape length"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tape_length_option
operator|=
literal|1024
operator|*
operator|(
name|tarlong
operator|)
name|u
expr_stmt|;
name|multi_volume_option
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OBSOLETE_TOUCH
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --touch"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'m'
case|:
name|touch_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Make multivolume archive: when we can't write any more into 	   the archive, re-open it, and continue writing.  */
name|multi_volume_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|recursion_option
operator|=
literal|0
expr_stmt|;
break|break;
if|#
directive|if
operator|!
name|MSDOS
case|case
literal|'N'
case|:
name|after_date_option
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|NEWER_MTIME_OPTION
case|:
if|if
condition|(
name|newer_mtime_option
operator|!=
name|TYPE_MINIMUM
argument_list|(
name|time_t
argument_list|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"More than one threshold date"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|optarg
argument_list|)
operator|!=
literal|0
operator|||
name|ISSLASH
argument_list|(
operator|*
name|optarg
argument_list|)
operator|||
operator|*
name|optarg
operator|==
literal|'.'
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|optarg
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Date file not found"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|newer_mtime_option
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
block|{
name|newer_mtime_option
operator|=
name|get_date
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newer_mtime_option
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Substituting %s for unknown date format %s"
argument_list|)
operator|,
name|tartime
argument_list|(
name|newer_mtime_option
argument_list|)
operator|,
name|quote
argument_list|(
name|optarg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* not MSDOS */
case|case
literal|'o'
case|:
if|if
condition|(
name|archive_format
operator|==
name|DEFAULT_FORMAT
condition|)
name|archive_format
operator|=
name|V7_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|!=
name|V7_FORMAT
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Conflicting archive format options"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|to_stdout_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|same_permissions_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OBSOLETE_ABSOLUTE_NAMES
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --absolute-names"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'P'
case|:
name|absolute_names_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|set_subcommand_option
argument_list|(
name|APPEND_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBSOLETE_BLOCK_NUMBER
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --block-number"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'R'
case|:
comment|/* Print block numbers for debugging bad tar archives.  */
comment|/* It would surely make sense to exchange -B and -R, but it seems 	   that -B has been used for a long while in Sun tar ans most 	   BSD-derived systems.  This is a consequence of the block/record 	   terminology confusion.  */
name|block_number_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Names to extr are sorted.  */
name|same_order_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sparse_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|set_subcommand_option
argument_list|(
name|LIST_SUBCOMMAND
argument_list|)
expr_stmt|;
name|verbose_option
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'I'
case|:
name|files_from_option
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|set_subcommand_option
argument_list|(
name|UPDATE_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|old_files_option
operator|=
name|UNLINK_FIRST_OLD_FILES
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose_option
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|volume_label_option
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|interactive_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|verify_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|set_subcommand_option
argument_list|(
name|EXTRACT_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|add_exclude_file
argument_list|(
name|add_exclude
argument_list|,
name|excluded
argument_list|,
name|optarg
argument_list|,
name|exclude_options
operator||
name|recursion_option
argument_list|,
literal|'\n'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
literal|"%s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
name|set_use_compress_program_option
argument_list|(
literal|"gzip"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|set_use_compress_program_option
argument_list|(
literal|"compress"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBSOLETE_VERSION_CONTROL
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Obsolete option name replaced by --backup"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|ANCHORED_OPTION
case|:
name|exclude_options
operator||=
name|EXCLUDE_ANCHORED
expr_stmt|;
break|break;
case|case
name|BACKUP_OPTION
case|:
name|backup_option
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
name|version_control_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|DELETE_OPTION
case|:
name|set_subcommand_option
argument_list|(
name|DELETE_SUBCOMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCLUDE_OPTION
case|:
name|add_exclude
argument_list|(
name|excluded
argument_list|,
name|optarg
argument_list|,
name|exclude_options
operator||
name|recursion_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE_CASE_OPTION
case|:
name|exclude_options
operator||=
name|FNM_CASEFOLD
expr_stmt|;
break|break;
case|case
name|GROUP_OPTION
case|:
if|if
condition|(
operator|!
operator|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|<
name|GNAME_FIELD_SIZE
operator|&&
name|gname_to_gid
argument_list|(
name|optarg
argument_list|,
operator|&
name|group_option
argument_list|)
operator|)
condition|)
block|{
name|uintmax_t
name|g
decl_stmt|;
if|if
condition|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|g
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
operator|&&
name|g
operator|==
operator|(
name|gid_t
operator|)
name|g
condition|)
name|group_option
operator|=
name|g
expr_stmt|;
else|else
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s: %s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|,
name|_
argument_list|(
literal|"%s: Invalid group"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODE_OPTION
case|:
name|mode_option
operator|=
name|mode_compile
argument_list|(
name|optarg
argument_list|,
name|MODE_MASK_EQUALS
operator||
name|MODE_MASK_PLUS
operator||
name|MODE_MASK_MINUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_option
operator|==
name|MODE_INVALID
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Invalid mode given on option"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_option
operator|==
name|MODE_MEMORY_EXHAUSTED
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_ANCHORED_OPTION
case|:
name|exclude_options
operator|&=
operator|~
name|EXCLUDE_ANCHORED
expr_stmt|;
break|break;
case|case
name|NO_IGNORE_CASE_OPTION
case|:
name|exclude_options
operator|&=
operator|~
name|FNM_CASEFOLD
expr_stmt|;
break|break;
case|case
name|NO_WILDCARDS_OPTION
case|:
name|exclude_options
operator|&=
operator|~
name|EXCLUDE_WILDCARDS
expr_stmt|;
break|break;
case|case
name|NO_WILDCARDS_MATCH_SLASH_OPTION
case|:
name|exclude_options
operator||=
name|FNM_FILE_NAME
expr_stmt|;
break|break;
case|case
name|NULL_OPTION
case|:
name|filename_terminator
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|OVERWRITE_OPTION
case|:
name|old_files_option
operator|=
name|OVERWRITE_OLD_FILES
expr_stmt|;
break|break;
case|case
name|OVERWRITE_DIR_OPTION
case|:
name|old_files_option
operator|=
name|OVERWRITE_OLD_DIRS
expr_stmt|;
break|break;
case|case
name|OWNER_OPTION
case|:
if|if
condition|(
operator|!
operator|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|<
name|UNAME_FIELD_SIZE
operator|&&
name|uname_to_uid
argument_list|(
name|optarg
argument_list|,
operator|&
name|owner_option
argument_list|)
operator|)
condition|)
block|{
name|uintmax_t
name|u
decl_stmt|;
if|if
condition|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|u
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
operator|&&
name|u
operator|==
operator|(
name|uid_t
operator|)
name|u
condition|)
name|owner_option
operator|=
name|u
expr_stmt|;
else|else
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s: %s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|,
name|_
argument_list|(
literal|"Invalid owner"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POSIX_OPTION
case|:
if|#
directive|if
name|OLDGNU_COMPATIBILITY
if|if
condition|(
name|archive_format
operator|==
name|DEFAULT_FORMAT
condition|)
name|archive_format
operator|=
name|GNU_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|!=
name|GNU_FORMAT
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Conflicting archive format options"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|archive_format
operator|==
name|DEFAULT_FORMAT
condition|)
name|archive_format
operator|=
name|POSIX_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_format
operator|!=
name|POSIX_FORMAT
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Conflicting archive format options"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PRESERVE_OPTION
case|:
name|same_permissions_option
operator|=
literal|1
expr_stmt|;
name|same_order_option
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RECORD_SIZE_OPTION
case|:
block|{
name|uintmax_t
name|u
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|u
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
operator|&&
name|u
operator|==
operator|(
name|size_t
operator|)
name|u
operator|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s: %s"
operator|,
name|quotearg_colon
argument_list|(
name|optarg
argument_list|)
operator|,
name|_
argument_list|(
literal|"Invalid record size"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|record_size
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|record_size
operator|%
name|BLOCKSIZE
operator|!=
literal|0
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Record size must be a multiple of %d."
argument_list|)
operator|,
name|BLOCKSIZE
operator|)
argument_list|)
expr_stmt|;
name|blocking_factor
operator|=
name|record_size
operator|/
name|BLOCKSIZE
expr_stmt|;
block|}
break|break;
case|case
name|RSH_COMMAND_OPTION
case|:
name|rsh_command_option
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|SUFFIX_OPTION
case|:
name|backup_option
operator|=
literal|1
expr_stmt|;
name|backup_suffix_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|USE_COMPRESS_PROGRAM_OPTION
case|:
name|set_use_compress_program_option
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOLNO_FILE_OPTION
case|:
name|volno_file_option
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|WILDCARDS_OPTION
case|:
name|exclude_options
operator||=
name|EXCLUDE_WILDCARDS
expr_stmt|;
break|break;
case|case
name|WILDCARDS_MATCH_SLASH_OPTION
case|:
name|exclude_options
operator|&=
operator|~
name|FNM_FILE_NAME
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
ifdef|#
directive|ifdef
name|DEVICE_PREFIX
block|{
name|int
name|device
init|=
name|optchar
operator|-
literal|'0'
decl_stmt|;
name|int
name|density
decl_stmt|;
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
name|DEVICE_PREFIX
operator|+
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
name|density
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lmh"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|DEVICE_PREFIX
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DENSITY_LETTER
name|sprintf
argument_list|(
name|cursor
argument_list|,
literal|"%d%c"
argument_list|,
name|device
argument_list|,
name|density
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not DENSITY_LETTER */
switch|switch
condition|(
name|density
condition|)
block|{
case|case
literal|'l'
case|:
ifdef|#
directive|ifdef
name|LOW_NUM
name|device
operator|+=
name|LOW_NUM
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|MID_NUM
name|device
operator|+=
name|MID_NUM
expr_stmt|;
else|#
directive|else
name|device
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'h'
case|:
ifdef|#
directive|ifdef
name|HGH_NUM
name|device
operator|+=
name|HGH_NUM
expr_stmt|;
else|#
directive|else
name|device
operator|+=
literal|16
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|usage
argument_list|(
name|TAREXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cursor
argument_list|,
literal|"%d"
argument_list|,
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DENSITY_LETTER */
if|if
condition|(
name|archive_names
operator|==
name|allocated_archive_names
condition|)
block|{
name|allocated_archive_names
operator|*=
literal|2
expr_stmt|;
name|archive_name_array
operator|=
name|xrealloc
argument_list|(
name|archive_name_array
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|allocated_archive_names
argument_list|)
expr_stmt|;
block|}
name|archive_name_array
index|[
name|archive_names
operator|++
index|]
operator|=
name|buf
expr_stmt|;
comment|/* FIXME: How comes this works for many archives when buf is 	     not xstrdup'ed?  */
block|}
break|break;
else|#
directive|else
comment|/* not DEVICE_PREFIX */
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Options `-[0-7][lmh]' not supported by *this* tar"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DEVICE_PREFIX */
block|}
comment|/* Handle operands after any "--" argument.  */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|name_add
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|input_files
operator|++
expr_stmt|;
block|}
comment|/* Process trivial options.  */
if|if
condition|(
name|show_version
condition|)
block|{
name|printf
argument_list|(
literal|"tar (GNU %s) %s\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|print_copyright
argument_list|(
literal|"2001 Free Software Foundation, Inc."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ This program comes with NO WARRANTY, to the extent permitted by law.\n\ You may redistribute it under the terms of the GNU General Public License;\n\ see the file named COPYING for details."
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"Written by John Gilmore and Jay Fenlason."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TAREXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_help
condition|)
name|usage
argument_list|(
name|TAREXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Derive option values and check option consistency.  */
if|if
condition|(
name|archive_format
operator|==
name|DEFAULT_FORMAT
condition|)
block|{
if|#
directive|if
name|OLDGNU_COMPATIBILITY
name|archive_format
operator|=
name|OLDGNU_FORMAT
expr_stmt|;
else|#
directive|else
name|archive_format
operator|=
name|GNU_FORMAT
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|archive_format
operator|==
name|GNU_FORMAT
operator|&&
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|)
name|archive_format
operator|=
name|POSIX_FORMAT
expr_stmt|;
if|if
condition|(
operator|(
name|volume_label_option
operator|||
name|incremental_option
operator|||
name|multi_volume_option
operator|||
name|sparse_option
operator|)
operator|&&
name|archive_format
operator|!=
name|OLDGNU_FORMAT
operator|&&
name|archive_format
operator|!=
name|GNU_FORMAT
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"GNU features wanted on incompatible archive format"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_names
operator|==
literal|0
condition|)
block|{
comment|/* If no archive file name given, try TAPE from the environment, or 	 else, DEFAULT_ARCHIVE from the configuration process.  */
name|archive_names
operator|=
literal|1
expr_stmt|;
name|archive_name_array
index|[
literal|0
index|]
operator|=
name|getenv
argument_list|(
literal|"TAPE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|archive_name_array
index|[
literal|0
index|]
condition|)
name|archive_name_array
index|[
literal|0
index|]
operator|=
name|DEFAULT_ARCHIVE
expr_stmt|;
block|}
comment|/* Allow multiple archives only with `-M'.  */
if|if
condition|(
name|archive_names
operator|>
literal|1
operator|&&
operator|!
name|multi_volume_option
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Multiple archive files requires `-M' option"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|listed_incremental_option
operator|&&
name|newer_mtime_option
operator|!=
name|TYPE_MINIMUM
argument_list|(
name|time_t
argument_list|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot combine --listed-incremental with --newer"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume_label_option
condition|)
block|{
name|size_t
name|volume_label_max_len
init|=
operator|(
sizeof|sizeof
name|current_header
operator|->
name|header
operator|.
name|name
operator|-
literal|1
comment|/* for trailing '\0' */
operator|-
operator|(
name|multi_volume_option
condition|?
operator|(
sizeof|sizeof
expr|" Volume "
operator|-
literal|1
comment|/* for null at end of " Volume " */
operator|+
name|INT_STRLEN_BOUND
argument_list|(
name|int
argument_list|)
comment|/* for volume number */
operator|-
literal|1
comment|/* for sign, as 0<= volno */
operator|)
else|:
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|volume_label_max_len
operator|<
name|strlen
argument_list|(
name|volume_label_option
argument_list|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Volume label is too long (limit is %lu bytes)"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|volume_label_option
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|volume_label_max_len
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If ready to unlink hierarchies, so we are for simpler files.  */
if|if
condition|(
name|recursive_unlink_option
condition|)
name|old_files_option
operator|=
name|UNLINK_FIRST_OLD_FILES
expr_stmt|;
comment|/* Forbid using -c with no input files whatsoever.  Check that `-f -',      explicit or implied, is used correctly.  */
switch|switch
condition|(
name|subcommand_option
condition|)
block|{
case|case
name|CREATE_SUBCOMMAND
case|:
if|if
condition|(
name|input_files
operator|==
literal|0
operator|&&
operator|!
name|files_from_option
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cowardly refusing to create an empty archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTRACT_SUBCOMMAND
case|:
case|case
name|LIST_SUBCOMMAND
case|:
case|case
name|DIFF_SUBCOMMAND
case|:
for|for
control|(
name|archive_name_cursor
operator|=
name|archive_name_array
init|;
name|archive_name_cursor
operator|<
name|archive_name_array
operator|+
name|archive_names
condition|;
name|archive_name_cursor
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
literal|"-"
argument_list|)
condition|)
name|request_stdin
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAT_SUBCOMMAND
case|:
case|case
name|UPDATE_SUBCOMMAND
case|:
case|case
name|APPEND_SUBCOMMAND
case|:
for|for
control|(
name|archive_name_cursor
operator|=
name|archive_name_array
init|;
name|archive_name_cursor
operator|<
name|archive_name_array
operator|+
name|archive_names
condition|;
name|archive_name_cursor
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
literal|"-"
argument_list|)
condition|)
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Options `-Aru' are incompatible with `-f -'"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
name|archive_name_cursor
operator|=
name|archive_name_array
expr_stmt|;
comment|/* Prepare for generating backup names.  */
if|if
condition|(
name|backup_suffix_string
condition|)
name|simple_backup_suffix
operator|=
name|xstrdup
argument_list|(
name|backup_suffix_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|backup_type
operator|=
name|xget_version
argument_list|(
literal|"--backup"
argument_list|,
name|version_control_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tar proper.  */
end_comment

begin_comment
comment|/* Main routine for tar.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|#
directive|if
name|HAVE_CLOCK_GETTIME
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|start_timespec
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|start_time
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|TAREXIT_SUCCESS
expr_stmt|;
name|filename_terminator
operator|=
literal|'\n'
expr_stmt|;
name|set_quoting_style
argument_list|(
literal|0
argument_list|,
name|escape_quoting_style
argument_list|)
expr_stmt|;
comment|/* Pre-allocate a few structures.  */
name|allocated_archive_names
operator|=
literal|10
expr_stmt|;
name|archive_name_array
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|allocated_archive_names
argument_list|)
expr_stmt|;
name|archive_names
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* System V fork+wait does not work if SIGCHLD is ignored.  */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_names
argument_list|()
expr_stmt|;
comment|/* Decode options.  */
name|decode_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|name_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Main command execution.  */
if|if
condition|(
name|volno_file_option
condition|)
name|init_volume_number
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|subcommand_option
condition|)
block|{
case|case
name|UNKNOWN_SUBCOMMAND
case|:
name|USAGE_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"You must specify one of the `-Acdtrux' options"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
case|case
name|CAT_SUBCOMMAND
case|:
case|case
name|UPDATE_SUBCOMMAND
case|:
case|case
name|APPEND_SUBCOMMAND
case|:
name|update_archive
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_SUBCOMMAND
case|:
name|delete_archive_members
argument_list|()
expr_stmt|;
break|break;
case|case
name|CREATE_SUBCOMMAND
case|:
name|create_archive
argument_list|()
expr_stmt|;
name|name_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|totals_option
condition|)
name|print_total_written
argument_list|()
expr_stmt|;
break|break;
case|case
name|EXTRACT_SUBCOMMAND
case|:
name|extr_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|extract_archive
argument_list|)
expr_stmt|;
name|extract_finish
argument_list|()
expr_stmt|;
break|break;
case|case
name|LIST_SUBCOMMAND
case|:
name|read_and
argument_list|(
name|list_archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_SUBCOMMAND
case|:
name|diff_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|diff_archive
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|volno_file_option
condition|)
name|closeout_volume_number
argument_list|()
expr_stmt|;
comment|/* Dispose of allocated memory, and return.  */
name|free
argument_list|(
name|archive_name_array
argument_list|)
expr_stmt|;
name|name_term
argument_list|()
expr_stmt|;
if|if
condition|(
name|stdlis
operator|==
name|stdout
operator|&&
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Error in writing to standard output"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
name|TAREXIT_FAILURE
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error exit delayed from previous errors"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

