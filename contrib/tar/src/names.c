begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Various processing of names.     Copyright 1988, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<hash.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* User and group names.  */
end_comment

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|HAVE_DECL_GETPWUID
end_if

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_DECL_GETGRGID
end_if

begin_function_decl
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make sure you link with the proper libraries if you are running the    Yellow Peril (thanks for the good laugh, Ian J.!), or, euh... NIS.    This code should also be modified for non-UNIX systems to do something    reasonable.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cached_uname
index|[
name|UNAME_FIELD_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cached_gname
index|[
name|GNAME_FIELD_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uid_t
name|cached_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid only if cached_uname is not empty */
end_comment

begin_decl_stmt
specifier|static
name|gid_t
name|cached_gid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid only if cached_gname is not empty */
end_comment

begin_comment
comment|/* These variables are valid only if nonempty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cached_no_such_uname
index|[
name|UNAME_FIELD_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cached_no_such_gname
index|[
name|GNAME_FIELD_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are valid only if nonzero.  It's not worth optimizing    the case for weird systems where 0 is not a valid uid or gid.  */
end_comment

begin_decl_stmt
specifier|static
name|uid_t
name|cached_no_such_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gid_t
name|cached_no_such_gid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given UID, find the corresponding UNAME.  */
end_comment

begin_function
name|void
name|uid_to_uname
parameter_list|(
name|uid_t
name|uid
parameter_list|,
name|char
name|uname
index|[
name|UNAME_FIELD_SIZE
index|]
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|;
if|if
condition|(
name|uid
operator|!=
literal|0
operator|&&
name|uid
operator|==
name|cached_no_such_uid
condition|)
block|{
operator|*
name|uname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cached_uname
index|[
literal|0
index|]
operator|||
name|uid
operator|!=
name|cached_uid
condition|)
block|{
name|passwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd
condition|)
block|{
name|cached_uid
operator|=
name|uid
expr_stmt|;
name|strncpy
argument_list|(
name|cached_uname
argument_list|,
name|passwd
operator|->
name|pw_name
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cached_no_such_uid
operator|=
name|uid
expr_stmt|;
operator|*
name|uname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
block|}
name|strncpy
argument_list|(
name|uname
argument_list|,
name|cached_uname
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given GID, find the corresponding GNAME.  */
end_comment

begin_function
name|void
name|gid_to_gname
parameter_list|(
name|gid_t
name|gid
parameter_list|,
name|char
name|gname
index|[
name|GNAME_FIELD_SIZE
index|]
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
if|if
condition|(
name|gid
operator|!=
literal|0
operator|&&
name|gid
operator|==
name|cached_no_such_gid
condition|)
block|{
operator|*
name|gname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cached_gname
index|[
literal|0
index|]
operator|||
name|gid
operator|!=
name|cached_gid
condition|)
block|{
name|group
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
condition|)
block|{
name|cached_gid
operator|=
name|gid
expr_stmt|;
name|strncpy
argument_list|(
name|cached_gname
argument_list|,
name|group
operator|->
name|gr_name
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cached_no_such_gid
operator|=
name|gid
expr_stmt|;
operator|*
name|gname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
block|}
name|strncpy
argument_list|(
name|gname
argument_list|,
name|cached_gname
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given UNAME, set the corresponding UID and return 1, or else, return 0.  */
end_comment

begin_function
name|int
name|uname_to_uid
parameter_list|(
name|char
name|uname
index|[
name|UNAME_FIELD_SIZE
index|]
parameter_list|,
name|uid_t
modifier|*
name|uidp
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|;
if|if
condition|(
name|cached_no_such_uname
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|uname
argument_list|,
name|cached_no_such_uname
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cached_uname
index|[
literal|0
index|]
operator|||
name|uname
index|[
literal|0
index|]
operator|!=
name|cached_uname
index|[
literal|0
index|]
operator|||
name|strncmp
argument_list|(
name|uname
argument_list|,
name|cached_uname
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|passwd
operator|=
name|getpwnam
argument_list|(
name|uname
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwd
condition|)
block|{
name|cached_uid
operator|=
name|passwd
operator|->
name|pw_uid
expr_stmt|;
name|strncpy
argument_list|(
name|cached_uname
argument_list|,
name|uname
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|cached_no_such_uname
argument_list|,
name|uname
argument_list|,
name|UNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|uidp
operator|=
name|cached_uid
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given GNAME, set the corresponding GID and return 1, or else, return 0.  */
end_comment

begin_function
name|int
name|gname_to_gid
parameter_list|(
name|char
name|gname
index|[
name|GNAME_FIELD_SIZE
index|]
parameter_list|,
name|gid_t
modifier|*
name|gidp
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
if|if
condition|(
name|cached_no_such_gname
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|gname
argument_list|,
name|cached_no_such_gname
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cached_gname
index|[
literal|0
index|]
operator|||
name|gname
index|[
literal|0
index|]
operator|!=
name|cached_gname
index|[
literal|0
index|]
operator|||
name|strncmp
argument_list|(
name|gname
argument_list|,
name|cached_gname
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|group
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
condition|)
block|{
name|cached_gid
operator|=
name|group
operator|->
name|gr_gid
expr_stmt|;
name|strncpy
argument_list|(
name|cached_gname
argument_list|,
name|gname
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|cached_no_such_gname
argument_list|,
name|gname
argument_list|,
name|GNAME_FIELD_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|gidp
operator|=
name|cached_gid
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Names from the command call.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|name
modifier|*
name|namelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first name in list, if any */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|name
modifier|*
modifier|*
name|nametail
init|=
operator|&
name|namelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of name list */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|name_array
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* store an array of names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how big is the array? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many entries does it have? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|name_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many of the entries have we scanned? */
end_comment

begin_comment
comment|/* Initialize structures.  */
end_comment

begin_function
name|void
name|init_names
parameter_list|(
name|void
parameter_list|)
block|{
name|allocated_names
operator|=
literal|10
expr_stmt|;
name|name_array
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|allocated_names
argument_list|)
expr_stmt|;
name|names
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add NAME at end of name_array, reallocating it as necessary.  */
end_comment

begin_function
name|void
name|name_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|names
operator|==
name|allocated_names
condition|)
block|{
name|allocated_names
operator|*=
literal|2
expr_stmt|;
name|name_array
operator|=
name|xrealloc
argument_list|(
name|name_array
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|allocated_names
argument_list|)
expr_stmt|;
block|}
name|name_array
index|[
name|names
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Names from external name file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|name_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to read names from */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer to hold the current file name */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|name_buffer_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocated length of name_buffer */
end_comment

begin_comment
comment|/* FIXME: I should better check more closely.  It seems at first glance that    is_pattern is only used when reading a file, and ignored for all    command line arguments.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|strchr
argument_list|(
name|string
argument_list|,
literal|'*'
argument_list|)
operator|||
name|strchr
argument_list|(
name|string
argument_list|,
literal|'['
argument_list|)
operator|||
name|strchr
argument_list|(
name|string
argument_list|,
literal|'?'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set up to gather file names for tar.  They can either come from a    file or were saved from decoding arguments.  */
end_comment

begin_function
name|void
name|name_init
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|name_buffer
operator|=
name|xmalloc
argument_list|(
name|NAME_FIELD_SIZE
operator|+
literal|2
argument_list|)
expr_stmt|;
name|name_buffer_length
operator|=
name|NAME_FIELD_SIZE
expr_stmt|;
if|if
condition|(
name|files_from_option
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|files_from_option
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|request_stdin
argument_list|(
literal|"-T"
argument_list|)
expr_stmt|;
name|name_file
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name_file
operator|=
name|fopen
argument_list|(
name|files_from_option
argument_list|,
literal|"r"
argument_list|)
operator|,
operator|!
name|name_file
condition|)
name|open_fatal
argument_list|(
name|files_from_option
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|name_term
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the next filename from name_file and null-terminate it.  Put    it into name_buffer, reallocating and adjusting name_buffer_length    if necessary.  Return 0 at end of file, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|read_name_from_file
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|character
decl_stmt|;
name|size_t
name|counter
init|=
literal|0
decl_stmt|;
comment|/* FIXME: getc may be called even if character was EOF the last time here.  */
comment|/* FIXME: This + 2 allocation might serve no purpose.  */
while|while
condition|(
name|character
operator|=
name|getc
argument_list|(
name|name_file
argument_list|)
operator|,
name|character
operator|!=
name|EOF
operator|&&
name|character
operator|!=
name|filename_terminator
condition|)
block|{
if|if
condition|(
name|counter
operator|==
name|name_buffer_length
condition|)
block|{
if|if
condition|(
name|name_buffer_length
operator|*
literal|2
operator|<
name|name_buffer_length
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|name_buffer_length
operator|*=
literal|2
expr_stmt|;
name|name_buffer
operator|=
name|xrealloc
argument_list|(
name|name_buffer
argument_list|,
name|name_buffer_length
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|name_buffer
index|[
name|counter
operator|++
index|]
operator|=
name|character
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|==
literal|0
operator|&&
name|character
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|counter
operator|==
name|name_buffer_length
condition|)
block|{
if|if
condition|(
name|name_buffer_length
operator|*
literal|2
operator|<
name|name_buffer_length
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|name_buffer_length
operator|*=
literal|2
expr_stmt|;
name|name_buffer
operator|=
name|xrealloc
argument_list|(
name|name_buffer
argument_list|,
name|name_buffer_length
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|name_buffer
index|[
name|counter
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get the next name from ARGV or the file of names.  Result is in    static storage and can't be relied upon across two calls.     If CHANGE_DIRS is true, treat a filename of the form "-C" as    meaning that the next filename is the name of a directory to change    to.  If filename_terminator is NUL, CHANGE_DIRS is effectively    always false.  */
end_comment

begin_function
name|char
modifier|*
name|name_next
parameter_list|(
name|int
name|change_dirs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
name|int
name|chdir_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|filename_terminator
operator|==
literal|'\0'
condition|)
name|change_dirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get a name, either from file or from saved arguments.  */
if|if
condition|(
name|name_index
operator|==
name|names
condition|)
block|{
if|if
condition|(
operator|!
name|name_file
condition|)
break|break;
if|if
condition|(
operator|!
name|read_name_from_file
argument_list|()
condition|)
break|break;
block|}
else|else
block|{
name|size_t
name|source_len
decl_stmt|;
name|source
operator|=
name|name_array
index|[
name|name_index
operator|++
index|]
expr_stmt|;
name|source_len
operator|=
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_buffer_length
operator|<
name|source_len
condition|)
block|{
do|do
block|{
name|name_buffer_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|name_buffer_length
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|name_buffer_length
operator|<
name|source_len
condition|)
do|;
name|free
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
name|name_buffer
operator|=
name|xmalloc
argument_list|(
name|name_buffer_length
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|name_buffer
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
comment|/* Zap trailing slashes.  */
name|cursor
operator|=
name|name_buffer
operator|+
name|strlen
argument_list|(
name|name_buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cursor
operator|>
name|name_buffer
operator|&&
name|ISSLASH
argument_list|(
operator|*
name|cursor
argument_list|)
condition|)
operator|*
name|cursor
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir_flag
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|name_buffer
argument_list|)
operator|<
literal|0
condition|)
name|chdir_fatal
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
name|chdir_flag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|change_dirs
operator|&&
name|strcmp
argument_list|(
name|name_buffer
argument_list|,
literal|"-C"
argument_list|)
operator|==
literal|0
condition|)
name|chdir_flag
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unquote_string
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
return|return
name|name_buffer
return|;
block|}
block|}
comment|/* No more names in file.  */
if|if
condition|(
name|name_file
operator|&&
name|chdir_flag
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Missing file name after -C"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the name file, if any.  */
end_comment

begin_function
name|void
name|name_close
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|name_file
operator|&&
name|name_file
operator|!=
name|stdin
condition|)
if|if
condition|(
name|fclose
argument_list|(
name|name_file
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gather names in a list for scanning.  Could hash them later if we    really care.     If the names are already sorted to match the archive, we just read    them one by one.  name_gather reads the first one, and it is called    by name_match as appropriate to read the next ones.  At EOF, the    last name read is just left in the buffer.  This option lets users    of small machines extract an arbitrary number of files by doing    "tar t" and editing down the list of files.  */
end_comment

begin_function
name|void
name|name_gather
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Buffer able to hold a single name.  */
specifier|static
name|struct
name|name
modifier|*
name|buffer
decl_stmt|;
specifier|static
name|size_t
name|allocated_size
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|same_order_option
condition|)
block|{
specifier|static
name|int
name|change_dir
decl_stmt|;
if|if
condition|(
name|allocated_size
operator|==
literal|0
condition|)
block|{
name|allocated_size
operator|=
name|offsetof
argument_list|(
expr|struct
name|name
argument_list|,
name|name
argument_list|)
operator|+
name|NAME_FIELD_SIZE
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|allocated_size
argument_list|)
expr_stmt|;
comment|/* FIXME: This memset is overkill, and ugly...  */
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|allocated_size
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-C"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|dir
init|=
name|name_next
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Missing file name after -C"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|change_dir
operator|=
name|chdir_arg
argument_list|(
name|xstrdup
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|size_t
name|needed_size
decl_stmt|;
name|buffer
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|needed_size
operator|=
name|offsetof
argument_list|(
expr|struct
name|name
argument_list|,
name|name
argument_list|)
operator|+
name|buffer
operator|->
name|length
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|allocated_size
operator|<
name|needed_size
condition|)
block|{
do|do
block|{
name|allocated_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|allocated_size
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|allocated_size
operator|<
name|needed_size
condition|)
do|;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|allocated_size
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|->
name|change_dir
operator|=
name|change_dir
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|namelist
operator|=
name|buffer
expr_stmt|;
name|nametail
operator|=
operator|&
name|namelist
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Non sorted names -- read them all in.  */
name|int
name|change_dir
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|change_dir0
init|=
name|change_dir
decl_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-C"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|dir
init|=
name|name_next
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Missing file name after -C"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|change_dir
operator|=
name|chdir_arg
argument_list|(
name|xstrdup
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
name|addname
argument_list|(
name|name
argument_list|,
name|change_dir
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|change_dir
operator|!=
name|change_dir0
condition|)
name|addname
argument_list|(
literal|0
argument_list|,
name|change_dir
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Add a name to the namelist.  */
end_comment

begin_function
name|struct
name|name
modifier|*
name|addname
parameter_list|(
name|char
specifier|const
modifier|*
name|string
parameter_list|,
name|int
name|change_dir
parameter_list|)
block|{
name|size_t
name|length
init|=
name|string
condition|?
name|strlen
argument_list|(
name|string
argument_list|)
else|:
literal|0
decl_stmt|;
name|struct
name|name
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|name
argument_list|,
name|name
argument_list|)
operator|+
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|name
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|->
name|name
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: This initialization (and the byte of memory that it 	 initializes) is probably not needed, but we are currently in 	 bug-fix mode so we'll leave it in for now.  */
name|name
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|name
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|name
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|regexp
operator|=
literal|0
expr_stmt|;
comment|/* assume not a regular expression */
name|name
operator|->
name|firstch
operator|=
literal|1
expr_stmt|;
comment|/* assume first char is literal */
name|name
operator|->
name|change_dir
operator|=
name|change_dir
expr_stmt|;
name|name
operator|->
name|dir_contents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|string
operator|&&
name|is_pattern
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|name
operator|->
name|regexp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'['
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|name
operator|->
name|firstch
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|nametail
operator|=
name|name
expr_stmt|;
name|nametail
operator|=
operator|&
name|name
operator|->
name|next
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Find a match for PATH (whose string length is LENGTH) in the name    list.  */
end_comment

begin_function
specifier|static
name|struct
name|name
modifier|*
name|namelist_match
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|struct
name|name
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|namelist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* If first chars don't match, quick skip.  */
if|if
condition|(
name|p
operator|->
name|firstch
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|path
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|regexp
condition|?
name|fnmatch
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|recursion_option
argument_list|)
operator|==
literal|0
else|:
operator|(
name|p
operator|->
name|length
operator|<=
name|length
operator|&&
operator|(
name|path
index|[
name|p
operator|->
name|length
index|]
operator|==
literal|'\0'
operator|||
name|ISSLASH
argument_list|(
name|path
index|[
name|p
operator|->
name|length
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|length
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if and only if name PATH (from an archive) matches any    name from the namelist.  */
end_comment

begin_function
name|int
name|name_match
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|name
modifier|*
name|cursor
init|=
name|namelist
decl_stmt|;
name|struct
name|name
modifier|*
name|tmpnlp
decl_stmt|;
if|if
condition|(
operator|!
name|cursor
condition|)
return|return
operator|!
name|files_from_option
return|;
if|if
condition|(
name|cursor
operator|->
name|fake
condition|)
block|{
name|chdir_do
argument_list|(
name|cursor
operator|->
name|change_dir
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
name|nametail
operator|=
operator|&
name|namelist
expr_stmt|;
return|return
operator|!
name|files_from_option
return|;
block|}
name|cursor
operator|=
name|namelist_match
argument_list|(
name|path
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
condition|)
block|{
name|cursor
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* remember it matched */
if|if
condition|(
name|starting_file_option
condition|)
block|{
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
name|nametail
operator|=
operator|&
name|namelist
expr_stmt|;
block|}
name|chdir_do
argument_list|(
name|cursor
operator|->
name|change_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast_read_option
condition|)
block|{
comment|/* remove the current entry, since we found a match */
if|if
condition|(
name|namelist
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* the list contains one element */
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
name|nametail
operator|=
operator|&
name|namelist
expr_stmt|;
comment|/* set a boolean to decide wether we started with a */
comment|/* non-empty  namelist, that was emptied */
name|namelist_freed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cursor
operator|==
name|namelist
condition|)
block|{
comment|/* the first element is the one */
name|tmpnlp
operator|=
name|namelist
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
name|tmpnlp
expr_stmt|;
block|}
else|else
block|{
name|tmpnlp
operator|=
name|namelist
expr_stmt|;
while|while
condition|(
name|tmpnlp
operator|->
name|next
operator|!=
name|cursor
condition|)
name|tmpnlp
operator|=
name|tmpnlp
operator|->
name|next
expr_stmt|;
name|tmpnlp
operator|->
name|next
operator|=
name|cursor
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We got a match.  */
return|return
literal|1
return|;
block|}
comment|/* Filename from archive not found in namelist.  If we have the whole 	 namelist here, just return 0.  Otherwise, read the next name in and 	 compare it.  If this was the last name, namelist->found will remain 	 on.  If not, we loop to compare the newly read name.  */
if|if
condition|(
name|same_order_option
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* read one more */
if|if
condition|(
name|namelist
operator|->
name|found
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print the names of things in the namelist that were not matched.  */
end_comment

begin_function
name|void
name|names_notfound
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|name
specifier|const
modifier|*
name|cursor
decl_stmt|;
for|for
control|(
name|cursor
operator|=
name|namelist
init|;
name|cursor
condition|;
name|cursor
operator|=
name|cursor
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|cursor
operator|->
name|found
operator|&&
operator|!
name|cursor
operator|->
name|fake
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Not found in archive"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|cursor
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't bother freeing the name list; we're about to exit.  */
name|namelist
operator|=
literal|0
expr_stmt|;
name|nametail
operator|=
operator|&
name|namelist
expr_stmt|;
if|if
condition|(
name|same_order_option
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
while|while
condition|(
name|name
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
operator|,
name|name
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Not found in archive"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sorting name lists.  */
end_comment

begin_comment
comment|/* Sort linked LIST of names, of given LENGTH, using COMPARE to order    names.  Return the sorted list.  Apart from the type `struct name'    and the definition of SUCCESSOR, this is a generic list-sorting    function, but it's too painful to make it both generic and portable    in C.  */
end_comment

begin_function
specifier|static
name|struct
name|name
modifier|*
name|merge_sort
parameter_list|(
name|struct
name|name
modifier|*
name|list
parameter_list|,
name|int
name|length
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
name|struct
name|name
specifier|const
modifier|*
parameter_list|,
name|struct
name|name
specifier|const
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|name
modifier|*
name|first_list
decl_stmt|;
name|struct
name|name
modifier|*
name|second_list
decl_stmt|;
name|int
name|first_length
decl_stmt|;
name|int
name|second_length
decl_stmt|;
name|struct
name|name
modifier|*
name|result
decl_stmt|;
name|struct
name|name
modifier|*
modifier|*
name|merge_point
decl_stmt|;
name|struct
name|name
modifier|*
name|cursor
decl_stmt|;
name|int
name|counter
decl_stmt|;
define|#
directive|define
name|SUCCESSOR
parameter_list|(
name|name
parameter_list|)
value|((name)->next)
if|if
condition|(
name|length
operator|==
literal|1
condition|)
return|return
name|list
return|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|list
argument_list|,
name|SUCCESSOR
argument_list|(
name|list
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|SUCCESSOR
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|SUCCESSOR
argument_list|(
name|result
argument_list|)
operator|=
name|list
expr_stmt|;
name|SUCCESSOR
argument_list|(
name|list
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|list
return|;
block|}
name|first_list
operator|=
name|list
expr_stmt|;
name|first_length
operator|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|second_length
operator|=
name|length
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|cursor
operator|=
name|list
operator|,
name|counter
operator|=
name|first_length
operator|-
literal|1
init|;
name|counter
condition|;
name|cursor
operator|=
name|SUCCESSOR
argument_list|(
name|cursor
argument_list|)
operator|,
name|counter
operator|--
control|)
continue|continue;
name|second_list
operator|=
name|SUCCESSOR
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|SUCCESSOR
argument_list|(
name|cursor
argument_list|)
operator|=
literal|0
expr_stmt|;
name|first_list
operator|=
name|merge_sort
argument_list|(
name|first_list
argument_list|,
name|first_length
argument_list|,
name|compare
argument_list|)
expr_stmt|;
name|second_list
operator|=
name|merge_sort
argument_list|(
name|second_list
argument_list|,
name|second_length
argument_list|,
name|compare
argument_list|)
expr_stmt|;
name|merge_point
operator|=
operator|&
name|result
expr_stmt|;
while|while
condition|(
name|first_list
operator|&&
name|second_list
condition|)
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|first_list
argument_list|,
name|second_list
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cursor
operator|=
name|SUCCESSOR
argument_list|(
name|first_list
argument_list|)
expr_stmt|;
operator|*
name|merge_point
operator|=
name|first_list
expr_stmt|;
name|merge_point
operator|=
operator|&
name|SUCCESSOR
argument_list|(
name|first_list
argument_list|)
expr_stmt|;
name|first_list
operator|=
name|cursor
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|=
name|SUCCESSOR
argument_list|(
name|second_list
argument_list|)
expr_stmt|;
operator|*
name|merge_point
operator|=
name|second_list
expr_stmt|;
name|merge_point
operator|=
operator|&
name|SUCCESSOR
argument_list|(
name|second_list
argument_list|)
expr_stmt|;
name|second_list
operator|=
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|first_list
condition|)
operator|*
name|merge_point
operator|=
name|first_list
expr_stmt|;
else|else
operator|*
name|merge_point
operator|=
name|second_list
expr_stmt|;
return|return
name|result
return|;
undef|#
directive|undef
name|SUCCESSOR
block|}
end_function

begin_comment
comment|/* A comparison function for sorting names.  Put found names last;    break ties by string comparison.  */
end_comment

begin_function
specifier|static
name|int
name|compare_names
parameter_list|(
name|struct
name|name
specifier|const
modifier|*
name|n1
parameter_list|,
name|struct
name|name
specifier|const
modifier|*
name|n2
parameter_list|)
block|{
name|int
name|found_diff
init|=
name|n2
operator|->
name|found
operator|-
name|n1
operator|->
name|found
decl_stmt|;
return|return
name|found_diff
condition|?
name|found_diff
else|:
name|strcmp
argument_list|(
name|n1
operator|->
name|name
argument_list|,
name|n2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add all the dirs under NAME, which names a directory, to the namelist.    If any of the files is a directory, recurse on the subdirectory.    DEVICE is the device not to leave, if the -l option is specified.  */
end_comment

begin_function
specifier|static
name|void
name|add_hierarchy_to_namelist
parameter_list|(
name|struct
name|name
modifier|*
name|name
parameter_list|,
name|dev_t
name|device
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|name
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|get_directory_contents
argument_list|(
name|path
argument_list|,
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
name|name
operator|->
name|dir_contents
operator|=
literal|"\0\0\0\0"
expr_stmt|;
else|else
block|{
name|size_t
name|name_length
init|=
name|name
operator|->
name|length
decl_stmt|;
name|size_t
name|allocated_length
init|=
operator|(
name|name_length
operator|>=
name|NAME_FIELD_SIZE
condition|?
name|name_length
operator|+
name|NAME_FIELD_SIZE
else|:
name|NAME_FIELD_SIZE
operator|)
decl_stmt|;
name|char
modifier|*
name|name_buffer
init|=
name|xmalloc
argument_list|(
name|allocated_length
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* FIXME: + 2 above?  */
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|string_length
decl_stmt|;
name|int
name|change_dir
init|=
name|name
operator|->
name|change_dir
decl_stmt|;
name|name
operator|->
name|dir_contents
operator|=
name|buffer
expr_stmt|;
name|strcpy
argument_list|(
name|name_buffer
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSLASH
argument_list|(
name|name_buffer
index|[
name|name_length
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|name_buffer
index|[
name|name_length
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|name_buffer
index|[
name|name_length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|string
operator|=
name|buffer
init|;
operator|*
name|string
condition|;
name|string
operator|+=
name|string_length
operator|+
literal|1
control|)
block|{
name|string_length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'D'
condition|)
block|{
if|if
condition|(
name|allocated_length
operator|<=
name|name_length
operator|+
name|string_length
condition|)
block|{
do|do
block|{
name|allocated_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|allocated_length
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|allocated_length
operator|<=
name|name_length
operator|+
name|string_length
condition|)
do|;
name|name_buffer
operator|=
name|xrealloc
argument_list|(
name|name_buffer
argument_list|,
name|allocated_length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|name_buffer
operator|+
name|name_length
argument_list|,
name|string
operator|+
literal|1
argument_list|)
expr_stmt|;
name|add_hierarchy_to_namelist
argument_list|(
name|addname
argument_list|(
name|name_buffer
argument_list|,
name|change_dir
argument_list|)
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Collect all the names from argv[] (or whatever), expand them into a    directory tree, and sort them.  This gets only subdirectories, not    all files.  */
end_comment

begin_function
name|void
name|collect_and_sort_names
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|name
modifier|*
name|name
decl_stmt|;
name|struct
name|name
modifier|*
name|next_name
decl_stmt|;
name|int
name|num_names
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|name_gather
argument_list|()
expr_stmt|;
if|if
condition|(
name|listed_incremental_option
condition|)
name|read_directory_file
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|namelist
condition|)
name|addname
argument_list|(
literal|"."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|namelist
init|;
name|name
condition|;
name|name
operator|=
name|next_name
control|)
block|{
name|next_name
operator|=
name|name
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|found
operator|||
name|name
operator|->
name|dir_contents
condition|)
continue|continue;
if|if
condition|(
name|name
operator|->
name|regexp
condition|)
comment|/* FIXME: just skip regexps for now */
continue|continue;
name|chdir_do
argument_list|(
name|name
operator|->
name|change_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|fake
condition|)
continue|continue;
if|if
condition|(
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|name
operator|->
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|stat_warn
argument_list|(
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|stat_error
argument_list|(
name|name
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|add_hierarchy_to_namelist
argument_list|(
name|name
argument_list|,
name|statbuf
operator|.
name|st_dev
argument_list|)
expr_stmt|;
block|}
block|}
name|num_names
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|name
operator|=
name|namelist
init|;
name|name
condition|;
name|name
operator|=
name|name
operator|->
name|next
control|)
name|num_names
operator|++
expr_stmt|;
name|namelist
operator|=
name|merge_sort
argument_list|(
name|namelist
argument_list|,
name|num_names
argument_list|,
name|compare_names
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|namelist
init|;
name|name
condition|;
name|name
operator|=
name|name
operator|->
name|next
control|)
name|name
operator|->
name|found
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like name_match, except that it returns a pointer to the    name it matched, and doesn't set FOUND in structure.  The caller    will have to do that if it wants to.  Oh, and if the namelist is    empty, it returns null, unlike name_match, which returns TRUE.  */
end_comment

begin_function
name|struct
name|name
modifier|*
name|name_scan
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|name
modifier|*
name|cursor
init|=
name|namelist_match
argument_list|(
name|path
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
condition|)
return|return
name|cursor
return|;
comment|/* Filename from archive not found in namelist.  If we have the whole 	 namelist here, just return 0.  Otherwise, read the next name in and 	 compare it.  If this was the last name, namelist->found will remain 	 on.  If not, we loop to compare the newly read name.  */
if|if
condition|(
name|same_order_option
operator|&&
name|namelist
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* read one more */
if|if
condition|(
name|namelist
operator|->
name|found
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This returns a name from the namelist which doesn't have ->found    set.  It sets ->found before returning, so successive calls will    find and return all the non-found names in the namelist.  */
end_comment

begin_decl_stmt
name|struct
name|name
modifier|*
name|gnu_list_name
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|name_from_list
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gnu_list_name
condition|)
name|gnu_list_name
operator|=
name|namelist
expr_stmt|;
while|while
condition|(
name|gnu_list_name
operator|&&
operator|(
name|gnu_list_name
operator|->
name|found
operator||
name|gnu_list_name
operator|->
name|fake
operator|)
condition|)
name|gnu_list_name
operator|=
name|gnu_list_name
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gnu_list_name
condition|)
block|{
name|gnu_list_name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|chdir_do
argument_list|(
name|gnu_list_name
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
name|gnu_list_name
operator|->
name|name
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|blank_name_list
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|name
modifier|*
name|name
decl_stmt|;
name|gnu_list_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|name
operator|=
name|namelist
init|;
name|name
condition|;
name|name
operator|=
name|name
operator|->
name|next
control|)
name|name
operator|->
name|found
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Yield a newly allocated file name consisting of PATH concatenated to    NAME, with an intervening slash if PATH does not already end in one.  */
end_comment

begin_function
name|char
modifier|*
name|new_name
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|slash
init|=
name|pathlen
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|path
index|[
name|pathlen
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|pathlen
operator|+
name|slash
operator|+
name|namesize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|buffer
index|[
name|pathlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|pathlen
operator|+
name|slash
argument_list|,
name|name
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if file NAME is excluded.  Exclude a name if its    prefix matches a pattern that contains slashes, or if one of its    components matches a pattern that contains no slashes.  */
end_comment

begin_function
name|bool
name|excluded_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
return|return
name|excluded_filename
argument_list|(
name|excluded
argument_list|,
name|name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Names to avoid dumping.  */
end_comment

begin_decl_stmt
specifier|static
name|Hash_table
modifier|*
name|avoided_name_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculate the hash of an avoided name.  */
end_comment

begin_function
specifier|static
name|unsigned
name|hash_avoided_name
parameter_list|(
name|void
specifier|const
modifier|*
name|name
parameter_list|,
name|unsigned
name|n_buckets
parameter_list|)
block|{
return|return
name|hash_string
argument_list|(
name|name
argument_list|,
name|n_buckets
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two avoided names for equality.  */
end_comment

begin_function
specifier|static
name|bool
name|compare_avoided_names
parameter_list|(
name|void
specifier|const
modifier|*
name|name1
parameter_list|,
name|void
specifier|const
modifier|*
name|name2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remember to not archive NAME.  */
end_comment

begin_function
name|void
name|add_avoided_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|avoided_name_table
operator|||
operator|(
name|avoided_name_table
operator|=
name|hash_initialize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hash_avoided_name
argument_list|,
name|compare_avoided_names
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|&&
name|hash_insert
argument_list|(
name|avoided_name_table
argument_list|,
name|xstrdup
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should NAME be avoided when archiving?  */
end_comment

begin_function
name|int
name|is_avoided_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
return|return
name|avoided_name_table
operator|&&
name|hash_lookup
argument_list|(
name|avoided_name_table
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

end_unit

