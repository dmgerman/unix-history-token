begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer management for tar.     Copyright 1988, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001 Free    Software Foundation, Inc.     Written by John Gilmore, on 1985-08-25.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|XENIX
end_if

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<human.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_define
define|#
directive|define
name|PREAD
value|0
end_define

begin_comment
comment|/* read file descriptor from pipe() */
end_comment

begin_define
define|#
directive|define
name|PWRITE
value|1
end_define

begin_comment
comment|/* write file descriptor from pipe() */
end_comment

begin_comment
comment|/* Number of retries before giving up on read.  */
end_comment

begin_define
define|#
directive|define
name|READ_ERROR_MAX
value|10
end_define

begin_comment
comment|/* Globbing pattern to append to volume label if initial match failed.  */
end_comment

begin_define
define|#
directive|define
name|VOLUME_LABEL_APPEND
value|" Volume [1-9]*"
end_define

begin_escape
end_escape

begin_comment
comment|/* Variables.  */
end_comment

begin_decl_stmt
specifier|static
name|tarlong
name|prev_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes written on previous volumes */
end_comment

begin_decl_stmt
specifier|static
name|tarlong
name|bytes_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes written on this volume */
end_comment

begin_comment
comment|/* FIXME: The following variables should ideally be static to this    module.  However, this cannot be done yet.  The cleanup continues!  */
end_comment

begin_decl_stmt
name|union
name|block
modifier|*
name|record_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of record of archive */
end_comment

begin_decl_stmt
name|union
name|block
modifier|*
name|record_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last+1 block of archive record */
end_comment

begin_decl_stmt
name|union
name|block
modifier|*
name|current_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current block of archive */
end_comment

begin_decl_stmt
name|enum
name|access_mode
name|access_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how do we handle the archive */
end_comment

begin_decl_stmt
name|off_t
name|records_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of records read from this archive */
end_comment

begin_decl_stmt
name|off_t
name|records_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* likewise, for records written */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|archive_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stat block for archive file */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|record_start_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* block ordinal at record_start */
end_comment

begin_comment
comment|/* Where we write list messages (not errors, not interactions) to.  Stdout    unless we're writing a pipe, in which case stderr.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|stdlis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|backspace_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_volume
name|PARAMS
argument_list|(
operator|(
expr|enum
name|access_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|archive_write_error
name|PARAMS
argument_list|(
operator|(
name|ssize_t
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|archive_read_error
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|MSDOS
end_if

begin_comment
comment|/* Obnoxious test to see if dimwit is trying to dump the archive.  */
end_comment

begin_decl_stmt
name|dev_t
name|ar_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ar_ino
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PID of child program, if compress_option or remote archive access.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|child_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error recovery stuff  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|read_error_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we hit EOF yet?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Checkpointing counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|checkpoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're reading, but we just read the last block and its time to update.  */
end_comment

begin_comment
comment|/* As least EXTERN like this one as possible.  FIXME!  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|time_to_start_writing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file_to_switch_to
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if remote update, close archive, and use 				   this descriptor to write to */
end_comment

begin_decl_stmt
specifier|static
name|int
name|volno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which volume of a multi-volume tape we're 				   on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_volno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* volume number to print in external 				   messages */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|grandchild_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pointer save_name, which is set in function dump_file() of module    create.c, points to the original long filename instead of the new,    shorter mangled name that is set in start_header() of module create.c.    The pointer save_name is only used in multi-volume mode when the file    being processed is non-sparse; if a file is split between volumes, the    save_name is used in generating the LF_MULTIVOL record on the second    volume.  (From Pierce Cantrell, 1991-08-13.)  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|save_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the file we are currently writing */
end_comment

begin_decl_stmt
name|off_t
name|save_totsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of file we are writing, only 				   valid if save_name is nonzero */
end_comment

begin_decl_stmt
name|off_t
name|save_sizeleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where we are in the file we are writing, 				   only valid if save_name is nonzero */
end_comment

begin_decl_stmt
name|bool
name|write_archive_to_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by flush_read and flush_write to store the real info about saved    names.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|real_s_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|real_s_totsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|real_s_sizeleft
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Functions.  */
end_comment

begin_function
name|void
name|print_total_written
parameter_list|(
name|void
parameter_list|)
block|{
name|tarlong
name|written
init|=
name|prev_written
operator|+
name|bytes_written
decl_stmt|;
name|char
name|bytes
index|[
sizeof|sizeof
argument_list|(
name|tarlong
argument_list|)
operator|*
name|CHAR_BIT
index|]
decl_stmt|;
name|char
name|abbr
index|[
name|LONGEST_HUMAN_READABLE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|rate
index|[
name|LONGEST_HUMAN_READABLE
operator|+
literal|1
index|]
decl_stmt|;
name|double
name|seconds
decl_stmt|;
if|#
directive|if
name|HAVE_CLOCK_GETTIME
name|struct
name|timespec
name|now
decl_stmt|;
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|now
argument_list|)
operator|==
literal|0
condition|)
name|seconds
operator|=
operator|(
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|start_timespec
operator|.
name|tv_sec
operator|)
operator|+
operator|(
name|now
operator|.
name|tv_nsec
operator|-
name|start_timespec
operator|.
name|tv_nsec
operator|)
operator|/
literal|1e9
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|seconds
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|-
name|start_time
expr_stmt|;
name|sprintf
argument_list|(
name|bytes
argument_list|,
name|TARLONG_FORMAT
argument_list|,
name|written
argument_list|)
expr_stmt|;
comment|/* Amanda 2.4.1p1 looks for "Total bytes written: [0-9][0-9]*".  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Total bytes written: %s (%sB, %sB/s)\n"
argument_list|)
argument_list|,
name|bytes
argument_list|,
name|human_readable
argument_list|(
operator|(
name|uintmax_t
operator|)
name|written
argument_list|,
name|abbr
argument_list|,
literal|1
argument_list|,
operator|-
literal|1024
argument_list|)
argument_list|,
operator|(
literal|0
operator|<
name|seconds
operator|&&
name|written
operator|/
name|seconds
operator|<
operator|(
name|uintmax_t
operator|)
operator|-
literal|1
condition|?
name|human_readable
argument_list|(
call|(
name|uintmax_t
call|)
argument_list|(
name|written
operator|/
name|seconds
argument_list|)
argument_list|,
name|rate
argument_list|,
literal|1
argument_list|,
operator|-
literal|1024
argument_list|)
else|:
literal|"?"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute and return the block ordinal at current_block.  */
end_comment

begin_function
name|off_t
name|current_block_ordinal
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|record_start_block
operator|+
operator|(
name|current_block
operator|-
name|record_start
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If the EOF flag is set, reset it, as well as current_block, etc.  */
end_comment

begin_function
name|void
name|reset_eof
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|hit_eof
condition|)
block|{
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|current_block
operator|=
name|record_start
expr_stmt|;
name|record_end
operator|=
name|record_start
operator|+
name|blocking_factor
expr_stmt|;
name|access_mode
operator|=
name|ACCESS_WRITE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the location of the next available input or output block.    Return zero for EOF.  Once we have returned zero, we just keep returning    it, to avoid accidentally going on to the next file on the tape.  */
end_comment

begin_function
name|union
name|block
modifier|*
name|find_next_block
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_block
operator|==
name|record_end
condition|)
block|{
if|if
condition|(
name|hit_eof
condition|)
return|return
literal|0
return|;
name|flush_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_block
operator|==
name|record_end
condition|)
block|{
name|hit_eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|current_block
return|;
block|}
end_function

begin_comment
comment|/* Indicate that we have used all blocks up thru BLOCK.    FIXME: should the arg have an off-by-1?  */
end_comment

begin_function
name|void
name|set_next_block_after
parameter_list|(
name|union
name|block
modifier|*
name|block
parameter_list|)
block|{
while|while
condition|(
name|block
operator|>=
name|current_block
condition|)
name|current_block
operator|++
expr_stmt|;
comment|/* Do *not* flush the archive here.  If we do, the same argument to      set_next_block_after could mean the next block (if the input record      is exactly one block long), which is not what is intended.  */
if|if
condition|(
name|current_block
operator|>
name|record_end
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes comprising the space between POINTER    through the end of the current buffer of blocks.  This space is    available for filling with data, or taking data from.  POINTER is    usually (but not always) the result previous find_next_block call.  */
end_comment

begin_function
name|size_t
name|available_space_after
parameter_list|(
name|union
name|block
modifier|*
name|pointer
parameter_list|)
block|{
return|return
name|record_end
operator|->
name|buffer
operator|-
name|pointer
operator|->
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Close file having descriptor FD, and abort if close unsuccessful.  */
end_comment

begin_function
specifier|static
name|void
name|xclose
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|_
argument_list|(
literal|"(pipe)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Duplicate file descriptor FROM into becoming INTO.    INTO is closed first and has to be the next available slot.  */
end_comment

begin_function
specifier|static
name|void
name|xdup2
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|into
parameter_list|)
block|{
if|if
condition|(
name|from
operator|!=
name|into
condition|)
block|{
name|int
name|status
init|=
name|close
argument_list|(
name|into
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EBADF
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"Cannot close"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|dup
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|into
condition|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"Cannot dup"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|xclose
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_comment
comment|/* Set ARCHIVE for writing, then compressing an archive.  */
end_comment

begin_function
specifier|static
name|void
name|child_open_for_compress
parameter_list|(
name|void
parameter_list|)
block|{
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot use compressed or remote archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set ARCHIVE for uncompressing, then reading an archive.  */
end_comment

begin_function
specifier|static
name|void
name|child_open_for_uncompress
parameter_list|(
name|void
parameter_list|)
block|{
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot use compressed or remote archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MSDOS */
end_comment

begin_comment
comment|/* Return nonzero if NAME is the name of a regular file, or if the file    does not exist (so it would be created as a regular file).  */
end_comment

begin_function
specifier|static
name|int
name|is_regular_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
name|S_ISREG
argument_list|(
name|stbuf
operator|.
name|st_mode
argument_list|)
return|;
else|else
return|return
name|errno
operator|==
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|write_archive_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|ssize_t
name|status
decl_stmt|;
name|ssize_t
name|written
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|status
operator|=
name|rmtwrite
argument_list|(
name|archive
argument_list|,
name|record_start
operator|->
name|buffer
operator|+
name|written
argument_list|,
name|record_size
operator|-
name|written
argument_list|)
operator|)
condition|)
block|{
name|written
operator|+=
name|status
expr_stmt|;
if|if
condition|(
name|written
operator|==
name|record_size
operator|||
name|_isrmt
argument_list|(
name|archive
argument_list|)
operator|||
operator|!
operator|(
name|S_ISFIFO
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISSOCK
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return
name|written
condition|?
name|written
else|:
name|status
return|;
block|}
end_function

begin_comment
comment|/* Set ARCHIVE for writing, then compressing an archive.  */
end_comment

begin_function
specifier|static
name|void
name|child_open_for_compress
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|parent_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|child_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|xpipe
argument_list|(
name|parent_pipe
argument_list|)
expr_stmt|;
name|child_pid
operator|=
name|xfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child_pid
operator|>
literal|0
condition|)
block|{
comment|/* The parent tar is still here!  Just clean up.  */
name|archive
operator|=
name|parent_pipe
index|[
name|PWRITE
index|]
expr_stmt|;
name|xclose
argument_list|(
name|parent_pipe
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The new born child tar is here!  */
name|program_name
operator|=
name|_
argument_list|(
literal|"tar (child)"
argument_list|)
expr_stmt|;
name|xdup2
argument_list|(
name|parent_pipe
index|[
name|PREAD
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|parent_pipe
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
comment|/* Check if we need a grandchild tar.  This happens only if either:      a) we are writing stdout: to force reblocking;      b) the file is to be accessed by rmt: compressor doesn't know how;      c) the file is not a plain file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|_remdev
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
operator|&&
name|is_regular_file
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|backup_option
condition|)
name|maybe_backup_file
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't need a grandchild tar.  Open the archive and launch the 	 compressor.  */
name|archive
operator|=
name|creat
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|MODE_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|open_fatal
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|xdup2
argument_list|(
name|archive
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|use_compress_program_option
argument_list|,
name|use_compress_program_option
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exec_fatal
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
block|}
comment|/* We do need a grandchild tar.  */
name|xpipe
argument_list|(
name|child_pipe
argument_list|)
expr_stmt|;
name|grandchild_pid
operator|=
name|xfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|grandchild_pid
operator|==
literal|0
condition|)
block|{
comment|/* The newborn grandchild tar is here!  Launch the compressor.  */
name|program_name
operator|=
name|_
argument_list|(
literal|"tar (grandchild)"
argument_list|)
expr_stmt|;
name|xdup2
argument_list|(
name|child_pipe
index|[
name|PWRITE
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|child_pipe
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|use_compress_program_option
argument_list|,
name|use_compress_program_option
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exec_fatal
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
block|}
comment|/* The child tar is still here!  */
comment|/* Prepare for reblocking the data from the compressor into the archive.  */
name|xdup2
argument_list|(
name|child_pipe
index|[
name|PREAD
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|child_pipe
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|archive
operator|=
name|STDOUT_FILENO
expr_stmt|;
else|else
block|{
name|archive
operator|=
name|rmtcreat
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
name|open_fatal
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Let's read out of the stdin pipe and write an archive.  */
while|while
condition|(
literal|1
condition|)
block|{
name|ssize_t
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* Assemble a record.  */
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|cursor
operator|=
name|record_start
operator|->
name|buffer
init|;
name|length
operator|<
name|record_size
condition|;
name|length
operator|+=
name|status
operator|,
name|cursor
operator|+=
name|status
control|)
block|{
name|size_t
name|size
init|=
name|record_size
operator|-
name|length
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|BLOCKSIZE
condition|)
name|size
operator|=
name|BLOCKSIZE
expr_stmt|;
name|status
operator|=
name|safe_read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|cursor
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|read_fatal
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
comment|/* Copy the record.  */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* We hit the end of the file.  Write last record at 	     full length, as the only role of the grandchild is 	     doing proper reblocking.  */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|record_start
operator|->
name|buffer
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|record_size
operator|-
name|length
argument_list|)
expr_stmt|;
name|status
operator|=
name|write_archive_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|record_size
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* There is nothing else to read, break out.  */
break|break;
block|}
name|status
operator|=
name|write_archive_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|record_size
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|close_archive ();
endif|#
directive|endif
comment|/* Propagate any failure of the grandchild back to the parent.  */
while|while
condition|(
name|waitpid
argument_list|(
name|grandchild_pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|waitpid_error
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
name|kill
argument_list|(
name|child_pid
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|TAREXIT_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|!=
literal|0
condition|)
name|exit_status
operator|=
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_propagate
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|kill
argument_list|(
name|grandchild_pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TAREXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set ARCHIVE for uncompressing, then reading an archive.  */
end_comment

begin_function
specifier|static
name|void
name|child_open_for_uncompress
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|parent_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|child_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|xpipe
argument_list|(
name|parent_pipe
argument_list|)
expr_stmt|;
name|child_pid
operator|=
name|xfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child_pid
operator|>
literal|0
condition|)
block|{
comment|/* The parent tar is still here!  Just clean up.  */
name|read_full_records_option
operator|=
literal|1
expr_stmt|;
name|archive
operator|=
name|parent_pipe
index|[
name|PREAD
index|]
expr_stmt|;
name|xclose
argument_list|(
name|parent_pipe
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The newborn child tar is here!  */
name|program_name
operator|=
name|_
argument_list|(
literal|"tar (child)"
argument_list|)
expr_stmt|;
name|xdup2
argument_list|(
name|parent_pipe
index|[
name|PWRITE
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|parent_pipe
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
comment|/* Check if we need a grandchild tar.  This happens only if either:      a) we're reading stdin: to force unblocking;      b) the file is to be accessed by rmt: compressor doesn't know how;      c) the file is not a plain file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|_remdev
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
operator|&&
name|is_regular_file
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* We don't need a grandchild tar.  Open the archive and lauch the 	 uncompressor.  */
name|archive
operator|=
name|open
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
name|open_fatal
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xdup2
argument_list|(
name|archive
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|use_compress_program_option
argument_list|,
name|use_compress_program_option
argument_list|,
literal|"-d"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exec_fatal
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
block|}
comment|/* We do need a grandchild tar.  */
name|xpipe
argument_list|(
name|child_pipe
argument_list|)
expr_stmt|;
name|grandchild_pid
operator|=
name|xfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|grandchild_pid
operator|==
literal|0
condition|)
block|{
comment|/* The newborn grandchild tar is here!  Launch the uncompressor.  */
name|program_name
operator|=
name|_
argument_list|(
literal|"tar (grandchild)"
argument_list|)
expr_stmt|;
name|xdup2
argument_list|(
name|child_pipe
index|[
name|PREAD
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|child_pipe
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|use_compress_program_option
argument_list|,
name|use_compress_program_option
argument_list|,
literal|"-d"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exec_fatal
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
block|}
comment|/* The child tar is still here!  */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sig_propagate
argument_list|)
expr_stmt|;
comment|/* Prepare for unblocking the data from the archive into the      uncompressor.  */
name|xdup2
argument_list|(
name|child_pipe
index|[
name|PWRITE
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|xclose
argument_list|(
name|child_pipe
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|archive
operator|=
name|STDIN_FILENO
expr_stmt|;
else|else
name|archive
operator|=
name|rmtopen
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
name|open_fatal
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Let's read the archive and pipe it into stdout.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
name|size_t
name|maximum
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|ssize_t
name|status
decl_stmt|;
name|read_error_count
operator|=
literal|0
expr_stmt|;
name|error_loop
label|:
name|status
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|record_start
operator|->
name|buffer
argument_list|,
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|archive_read_error
argument_list|()
expr_stmt|;
goto|goto
name|error_loop
goto|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
break|break;
name|cursor
operator|=
name|record_start
operator|->
name|buffer
expr_stmt|;
name|maximum
operator|=
name|status
expr_stmt|;
while|while
condition|(
name|maximum
condition|)
block|{
name|count
operator|=
name|maximum
operator|<
name|BLOCKSIZE
condition|?
name|maximum
else|:
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|cursor
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
name|write_error
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
name|cursor
operator|+=
name|count
expr_stmt|;
name|maximum
operator|-=
name|count
expr_stmt|;
block|}
block|}
name|xclose
argument_list|(
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|close_archive ();
endif|#
directive|endif
comment|/* Propagate any failure of the grandchild back to the parent.  */
while|while
condition|(
name|waitpid
argument_list|(
name|grandchild_pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|waitpid_error
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
name|kill
argument_list|(
name|child_pid
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|TAREXIT_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|!=
literal|0
condition|)
name|exit_status
operator|=
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MSDOS */
end_comment

begin_comment
comment|/* Check the LABEL block against the volume label, seen as a globbing    pattern.  Return true if the pattern matches.  In case of failure,    retry matching a volume sequence number before giving up in    multi-volume mode.  */
end_comment

begin_function
specifier|static
name|int
name|check_label_pattern
parameter_list|(
name|union
name|block
modifier|*
name|label
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|memchr
argument_list|(
name|label
operator|->
name|header
operator|.
name|name
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|label
operator|->
name|header
operator|.
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fnmatch
argument_list|(
name|volume_label_option
argument_list|,
name|label
operator|->
name|header
operator|.
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|multi_volume_option
condition|)
return|return
literal|0
return|;
name|string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|volume_label_option
argument_list|)
operator|+
sizeof|sizeof
name|VOLUME_LABEL_APPEND
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|volume_label_option
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|VOLUME_LABEL_APPEND
argument_list|)
expr_stmt|;
name|result
operator|=
name|fnmatch
argument_list|(
name|string
argument_list|,
name|label
operator|->
name|header
operator|.
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Open an archive file.  The argument specifies whether we are    reading or writing, or both.  */
end_comment

begin_function
name|void
name|open_archive
parameter_list|(
name|enum
name|access_mode
name|wanted_access
parameter_list|)
block|{
name|int
name|backed_up_flag
init|=
literal|0
decl_stmt|;
name|stdlis
operator|=
name|to_stdout_option
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
if|if
condition|(
name|record_size
operator|==
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Invalid value for record_size"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_names
operator|==
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"No archive name given"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|current_file_name
operator|=
literal|0
expr_stmt|;
name|current_link_name
operator|=
literal|0
expr_stmt|;
name|save_name
operator|=
literal|0
expr_stmt|;
name|real_s_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
block|{
if|if
condition|(
name|verify_option
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot verify multi-volume archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|record_start
operator|=
name|valloc
argument_list|(
name|record_size
operator|+
operator|(
literal|2
operator|*
name|BLOCKSIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|record_start
condition|)
name|record_start
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|record_start
operator|=
name|valloc
argument_list|(
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|record_start
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot allocate memory for blocking factor %d"
argument_list|)
operator|,
name|blocking_factor
operator|)
argument_list|)
expr_stmt|;
name|current_block
operator|=
name|record_start
expr_stmt|;
name|record_end
operator|=
name|record_start
operator|+
name|blocking_factor
expr_stmt|;
comment|/* When updating the archive, we start with reading.  */
name|access_mode
operator|=
name|wanted_access
operator|==
name|ACCESS_UPDATE
condition|?
name|ACCESS_READ
else|:
name|wanted_access
expr_stmt|;
if|if
condition|(
name|use_compress_program_option
condition|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot use multi-volume compressed archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_option
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot verify compressed archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wanted_access
condition|)
block|{
case|case
name|ACCESS_READ
case|:
name|child_open_for_uncompress
argument_list|()
expr_stmt|;
break|break;
case|case
name|ACCESS_WRITE
case|:
name|child_open_for_compress
argument_list|()
expr_stmt|;
break|break;
case|case
name|ACCESS_UPDATE
case|:
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot update compressed archives"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wanted_access
operator|==
name|ACCESS_WRITE
operator|&&
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|stdlis
operator|=
name|stderr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_full_records_option
operator|=
literal|1
expr_stmt|;
comment|/* could be a pipe, be safe */
if|if
condition|(
name|verify_option
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot verify stdin/stdout archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wanted_access
condition|)
block|{
case|case
name|ACCESS_READ
case|:
name|archive
operator|=
name|STDIN_FILENO
expr_stmt|;
break|break;
case|case
name|ACCESS_WRITE
case|:
name|archive
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|stdlis
operator|=
name|stderr
expr_stmt|;
break|break;
case|case
name|ACCESS_UPDATE
case|:
name|archive
operator|=
name|STDIN_FILENO
expr_stmt|;
name|stdlis
operator|=
name|stderr
expr_stmt|;
name|write_archive_to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|verify_option
condition|)
name|archive
operator|=
name|rmtopen
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|wanted_access
condition|)
block|{
case|case
name|ACCESS_READ
case|:
name|archive
operator|=
name|rmtopen
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCESS_WRITE
case|:
if|if
condition|(
name|backup_option
condition|)
block|{
name|maybe_backup_file
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|backed_up_flag
operator|=
literal|1
expr_stmt|;
block|}
name|archive
operator|=
name|rmtcreat
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCESS_UPDATE
case|:
name|archive
operator|=
name|rmtopen
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_BINARY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|archive
operator|<
literal|0
operator|||
operator|(
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
operator|&&
name|fstat
argument_list|(
name|archive
argument_list|,
operator|&
name|archive_stat
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|backed_up_flag
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|open_fatal
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|MSDOS
comment|/* Detect if outputting to "/dev/null".  */
block|{
specifier|static
name|char
specifier|const
name|dev_null
index|[]
init|=
literal|"/dev/null"
decl_stmt|;
name|struct
name|stat
name|dev_null_stat
decl_stmt|;
name|dev_null_output
operator|=
operator|(
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|dev_null
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
operator|&&
name|S_ISCHR
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
operator|&&
name|stat
argument_list|(
name|dev_null
argument_list|,
operator|&
name|dev_null_stat
argument_list|)
operator|==
literal|0
operator|&&
name|archive_stat
operator|.
name|st_dev
operator|==
name|dev_null_stat
operator|.
name|st_dev
operator|&&
name|archive_stat
operator|.
name|st_ino
operator|==
name|dev_null_stat
operator|.
name|st_ino
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|ar_dev
operator|=
name|archive_stat
operator|.
name|st_dev
expr_stmt|;
name|ar_ino
operator|=
name|archive_stat
operator|.
name|st_ino
expr_stmt|;
block|}
else|else
name|ar_dev
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not MSDOS */
if|#
directive|if
name|MSDOS
name|setmode
argument_list|(
name|archive
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|wanted_access
condition|)
block|{
case|case
name|ACCESS_UPDATE
case|:
name|records_written
operator|=
literal|0
expr_stmt|;
case|case
name|ACCESS_READ
case|:
name|records_read
operator|=
literal|0
expr_stmt|;
name|record_end
operator|=
name|record_start
expr_stmt|;
comment|/* set up for 1st record = # 0 */
name|find_next_block
argument_list|()
expr_stmt|;
comment|/* read it in, check for EOF */
if|if
condition|(
name|volume_label_option
condition|)
block|{
name|union
name|block
modifier|*
name|label
init|=
name|find_next_block
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|label
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive not labeled to match %s"
argument_list|)
operator|,
name|quote
argument_list|(
name|volume_label_option
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_label_pattern
argument_list|(
name|label
argument_list|)
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Volume %s does not match %s"
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|0
argument_list|,
name|label
operator|->
name|header
operator|.
name|name
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|volume_label_option
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACCESS_WRITE
case|:
name|records_written
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|volume_label_option
condition|)
block|{
name|memset
argument_list|(
name|record_start
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|sprintf
argument_list|(
name|record_start
operator|->
name|header
operator|.
name|name
argument_list|,
literal|"%s Volume 1"
argument_list|,
name|volume_label_option
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|record_start
operator|->
name|header
operator|.
name|name
argument_list|,
name|volume_label_option
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|current_file_name
argument_list|,
name|record_start
operator|->
name|header
operator|.
name|name
argument_list|)
expr_stmt|;
name|record_start
operator|->
name|header
operator|.
name|typeflag
operator|=
name|GNUTYPE_VOLHDR
expr_stmt|;
name|TIME_TO_CHARS
argument_list|(
name|start_time
argument_list|,
name|record_start
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|finish_header
argument_list|(
name|record_start
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|current_block++;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Perform a write to flush the buffer.  */
end_comment

begin_function
name|void
name|flush_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|copy_back
decl_stmt|;
name|ssize_t
name|status
decl_stmt|;
if|if
condition|(
name|checkpoint_option
operator|&&
operator|!
operator|(
operator|++
name|checkpoint
operator|%
literal|10
operator|)
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Write checkpoint %d"
argument_list|)
operator|,
name|checkpoint
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_length_option
operator|&&
name|tape_length_option
operator|<=
name|bytes_written
condition|)
block|{
name|errno
operator|=
name|ENOSPC
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev_null_output
condition|)
name|status
operator|=
name|record_size
expr_stmt|;
else|else
name|status
operator|=
name|write_archive_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|record_size
operator|&&
operator|!
name|multi_volume_option
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|records_written
operator|++
expr_stmt|;
name|bytes_written
operator|+=
name|status
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|record_size
condition|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
if|if
condition|(
operator|!
name|save_name
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|real_s_totsize
operator|=
literal|0
expr_stmt|;
name|real_s_sizeleft
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cursor
operator|=
name|save_name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|save_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
operator|*
name|cursor
argument_list|)
condition|)
name|cursor
operator|++
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
block|}
return|return;
block|}
comment|/* We're multivol.  Panic if we didn't get the right kind of response.  */
comment|/* ENXIO is for the UNIX PC.  */
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSPC
operator|&&
name|errno
operator|!=
name|EIO
operator|&&
name|errno
operator|!=
name|ENXIO
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* If error indicates a short write, we just move to the next tape.  */
if|if
condition|(
operator|!
name|new_volume
argument_list|(
name|ACCESS_WRITE
argument_list|)
condition|)
return|return;
if|if
condition|(
name|totals_option
condition|)
name|prev_written
operator|+=
name|bytes_written
expr_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|volume_label_option
operator|&&
name|real_s_name
condition|)
block|{
name|copy_back
operator|=
literal|2
expr_stmt|;
name|record_start
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|volume_label_option
operator|||
name|real_s_name
condition|)
block|{
name|copy_back
operator|=
literal|1
expr_stmt|;
name|record_start
operator|--
expr_stmt|;
block|}
else|else
name|copy_back
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|volume_label_option
condition|)
block|{
name|memset
argument_list|(
name|record_start
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|record_start
operator|->
name|header
operator|.
name|name
argument_list|,
literal|"%s Volume %d"
argument_list|,
name|volume_label_option
argument_list|,
name|volno
argument_list|)
expr_stmt|;
name|TIME_TO_CHARS
argument_list|(
name|start_time
argument_list|,
name|record_start
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|record_start
operator|->
name|header
operator|.
name|typeflag
operator|=
name|GNUTYPE_VOLHDR
expr_stmt|;
name|finish_header
argument_list|(
name|record_start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|real_s_name
condition|)
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|volume_label_option
condition|)
name|record_start
operator|++
expr_stmt|;
name|memset
argument_list|(
name|record_start
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* FIXME: Michael P Urban writes: [a long name file] is being written 	 when a new volume rolls around [...]  Looks like the wrong value is 	 being preserved in real_s_name, though.  */
name|strcpy
argument_list|(
name|record_start
operator|->
name|header
operator|.
name|name
argument_list|,
name|real_s_name
argument_list|)
expr_stmt|;
name|record_start
operator|->
name|header
operator|.
name|typeflag
operator|=
name|GNUTYPE_MULTIVOL
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|real_s_sizeleft
argument_list|,
name|record_start
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|real_s_totsize
operator|-
name|real_s_sizeleft
argument_list|,
name|record_start
operator|->
name|oldgnu_header
operator|.
name|offset
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|verbose_option
expr_stmt|;
name|verbose_option
operator|=
literal|0
expr_stmt|;
name|finish_header
argument_list|(
name|record_start
argument_list|)
expr_stmt|;
name|verbose_option
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|volume_label_option
condition|)
name|record_start
operator|--
expr_stmt|;
block|}
name|status
operator|=
name|write_archive_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|record_size
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|bytes_written
operator|+=
name|status
expr_stmt|;
if|if
condition|(
name|copy_back
condition|)
block|{
name|record_start
operator|+=
name|copy_back
expr_stmt|;
name|memcpy
argument_list|(
name|current_block
argument_list|,
name|record_start
operator|+
name|blocking_factor
operator|-
name|copy_back
argument_list|,
name|copy_back
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|current_block
operator|+=
name|copy_back
expr_stmt|;
if|if
condition|(
name|real_s_sizeleft
operator|>=
name|copy_back
operator|*
name|BLOCKSIZE
condition|)
name|real_s_sizeleft
operator|-=
name|copy_back
operator|*
name|BLOCKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|real_s_sizeleft
operator|+
name|BLOCKSIZE
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
operator|<=
name|copy_back
condition|)
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cursor
init|=
name|save_name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|save_name
argument_list|)
decl_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
operator|*
name|cursor
argument_list|)
condition|)
name|cursor
operator|++
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
block|}
name|copy_back
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle write errors on the archive.  Write errors are always fatal.    Hitting the end of a volume does not cause a write error unless the    write was the first record of the volume.  */
end_comment

begin_function
specifier|static
name|void
name|archive_write_error
parameter_list|(
name|ssize_t
name|status
parameter_list|)
block|{
comment|/* It might be useful to know how much was written before the error      occurred.  */
if|if
condition|(
name|totals_option
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|print_total_written
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
block|}
name|write_fatal_details
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
name|status
argument_list|,
name|record_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle read errors on the archive.  If the read should be retried,    return to the caller.  */
end_comment

begin_function
specifier|static
name|void
name|archive_read_error
parameter_list|(
name|void
parameter_list|)
block|{
name|read_error
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|record_start_block
operator|==
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"At beginning of tape, quitting now"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Read error in mid archive.  We retry up to READ_ERROR_MAX times and      then give up on reading the archive.  */
if|if
condition|(
name|read_error_count
operator|++
operator|>
name|READ_ERROR_MAX
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Too many errors, quitting"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Perform a read to flush the buffer.  */
end_comment

begin_function
name|void
name|flush_read
parameter_list|(
name|void
parameter_list|)
block|{
name|ssize_t
name|status
decl_stmt|;
comment|/* result from system call */
name|size_t
name|left
decl_stmt|;
comment|/* bytes left */
name|char
modifier|*
name|more
decl_stmt|;
comment|/* pointer to next byte to read */
if|if
condition|(
name|checkpoint_option
operator|&&
operator|!
operator|(
operator|++
name|checkpoint
operator|%
literal|10
operator|)
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Read checkpoint %d"
argument_list|)
operator|,
name|checkpoint
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear the count of errors.  This only applies to a single call to      flush_read.  */
name|read_error_count
operator|=
literal|0
expr_stmt|;
comment|/* clear error count */
if|if
condition|(
name|write_archive_to_stdout
operator|&&
name|record_start_block
operator|!=
literal|0
condition|)
block|{
name|archive
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|status
operator|=
name|write_archive_buffer
argument_list|()
expr_stmt|;
name|archive
operator|=
name|STDIN_FILENO
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|record_size
condition|)
name|archive_write_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multi_volume_option
condition|)
block|{
if|if
condition|(
name|save_name
condition|)
block|{
name|char
modifier|*
name|cursor
init|=
name|save_name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|save_name
argument_list|)
decl_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
operator|*
name|cursor
argument_list|)
condition|)
name|cursor
operator|++
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
block|}
else|else
block|{
name|assign_string
argument_list|(
operator|&
name|real_s_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|real_s_totsize
operator|=
literal|0
expr_stmt|;
name|real_s_sizeleft
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|error_loop
label|:
name|status
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|record_start
operator|->
name|buffer
argument_list|,
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|record_size
condition|)
block|{
name|records_read
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|||
operator|(
name|status
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOSPC
operator|)
operator|||
operator|(
name|status
operator|>
literal|0
operator|&&
operator|!
name|read_full_records_option
operator|)
operator|)
operator|&&
name|multi_volume_option
condition|)
block|{
name|union
name|block
modifier|*
name|cursor
decl_stmt|;
name|try_volume
label|:
switch|switch
condition|(
name|subcommand_option
condition|)
block|{
case|case
name|APPEND_SUBCOMMAND
case|:
case|case
name|CAT_SUBCOMMAND
case|:
case|case
name|UPDATE_SUBCOMMAND
case|:
if|if
condition|(
operator|!
name|new_volume
argument_list|(
name|ACCESS_UPDATE
argument_list|)
condition|)
return|return;
break|break;
default|default:
if|if
condition|(
operator|!
name|new_volume
argument_list|(
name|ACCESS_READ
argument_list|)
condition|)
return|return;
break|break;
block|}
name|vol_error
label|:
name|status
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|record_start
operator|->
name|buffer
argument_list|,
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|archive_read_error
argument_list|()
expr_stmt|;
goto|goto
name|vol_error
goto|;
block|}
if|if
condition|(
name|status
operator|!=
name|record_size
condition|)
goto|goto
name|short_read
goto|;
name|cursor
operator|=
name|record_start
expr_stmt|;
if|if
condition|(
name|cursor
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_VOLHDR
condition|)
block|{
if|if
condition|(
name|volume_label_option
condition|)
block|{
if|if
condition|(
operator|!
name|check_label_pattern
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Volume %s does not match %s"
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|0
argument_list|,
name|cursor
operator|->
name|header
operator|.
name|name
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|volume_label_option
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|volno
operator|--
expr_stmt|;
name|global_volno
operator|--
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
block|}
if|if
condition|(
name|verbose_option
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"Reading %s\n"
argument_list|)
argument_list|,
name|quote
argument_list|(
name|cursor
operator|->
name|header
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|volume_label_option
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"WARNING: No volume header"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_s_name
condition|)
block|{
name|uintmax_t
name|s1
decl_stmt|,
name|s2
decl_stmt|;
if|if
condition|(
name|cursor
operator|->
name|header
operator|.
name|typeflag
operator|!=
name|GNUTYPE_MULTIVOL
operator|||
name|strcmp
argument_list|(
name|cursor
operator|->
name|header
operator|.
name|name
argument_list|,
name|real_s_name
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s is not continued on this volume"
argument_list|)
operator|,
name|quote
argument_list|(
name|real_s_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|volno
operator|--
expr_stmt|;
name|global_volno
operator|--
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
name|s1
operator|=
name|UINTMAX_FROM_HEADER
argument_list|(
name|cursor
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|s2
operator|=
name|UINTMAX_FROM_HEADER
argument_list|(
name|cursor
operator|->
name|oldgnu_header
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_s_totsize
operator|!=
name|s1
operator|+
name|s2
operator|||
name|s1
operator|+
name|s2
operator|<
name|s2
condition|)
block|{
name|char
name|totsizebuf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|char
name|s1buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|char
name|s2buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s is the wrong size (%s != %s + %s)"
argument_list|)
operator|,
name|quote
argument_list|(
name|cursor
operator|->
name|header
operator|.
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|save_totsize
argument_list|,
name|totsizebuf
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|s1
argument_list|,
name|s1buf
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|s2
argument_list|,
name|s2buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|volno
operator|--
expr_stmt|;
name|global_volno
operator|--
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
if|if
condition|(
name|real_s_totsize
operator|-
name|real_s_sizeleft
operator|!=
name|OFF_FROM_HEADER
argument_list|(
name|cursor
operator|->
name|oldgnu_header
operator|.
name|offset
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"This volume is out of sequence"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|volno
operator|--
expr_stmt|;
name|global_volno
operator|--
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
name|cursor
operator|++
expr_stmt|;
block|}
name|current_block
operator|=
name|cursor
expr_stmt|;
name|records_read
operator|++
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|archive_read_error
argument_list|()
expr_stmt|;
goto|goto
name|error_loop
goto|;
comment|/* try again */
block|}
name|short_read
label|:
name|more
operator|=
name|record_start
operator|->
name|buffer
operator|+
name|status
expr_stmt|;
name|left
operator|=
name|record_size
operator|-
name|status
expr_stmt|;
while|while
condition|(
name|left
operator|%
name|BLOCKSIZE
operator|!=
literal|0
operator|||
operator|(
name|left
operator|&&
name|status
operator|&&
name|read_full_records_option
operator|)
condition|)
block|{
if|if
condition|(
name|status
condition|)
while|while
condition|(
operator|(
name|status
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|more
argument_list|,
name|left
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|archive_read_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|read_full_records_option
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unaligned block (%lu bytes) in archive"
argument_list|)
operator|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|record_size
operator|-
name|left
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* User warned us about this.  Fix up.  */
name|left
operator|-=
name|status
expr_stmt|;
name|more
operator|+=
name|status
expr_stmt|;
block|}
comment|/* FIXME: for size=0, multi-volume support.  On the first record, warn      about the problem.  */
if|if
condition|(
operator|!
name|read_full_records_option
operator|&&
name|verbose_option
operator|&&
name|record_start_block
operator|==
literal|0
operator|&&
name|status
operator|>
literal|0
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Record size = %lu blocks"
argument_list|)
operator|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|record_size
operator|-
name|left
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|record_end
operator|=
name|record_start
operator|+
operator|(
name|record_size
operator|-
name|left
operator|)
operator|/
name|BLOCKSIZE
expr_stmt|;
name|records_read
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Flush the current buffer to/from the archive.  */
end_comment

begin_function
name|void
name|flush_archive
parameter_list|(
name|void
parameter_list|)
block|{
name|record_start_block
operator|+=
name|record_end
operator|-
name|record_start
expr_stmt|;
name|current_block
operator|=
name|record_start
expr_stmt|;
name|record_end
operator|=
name|record_start
operator|+
name|blocking_factor
expr_stmt|;
if|if
condition|(
name|access_mode
operator|==
name|ACCESS_READ
operator|&&
name|time_to_start_writing
condition|)
block|{
name|access_mode
operator|=
name|ACCESS_WRITE
expr_stmt|;
name|time_to_start_writing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_to_switch_to
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|!=
literal|0
condition|)
name|close_warn
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
expr_stmt|;
name|archive
operator|=
name|file_to_switch_to
expr_stmt|;
block|}
else|else
name|backspace_output
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|access_mode
condition|)
block|{
case|case
name|ACCESS_READ
case|:
name|flush_read
argument_list|()
expr_stmt|;
break|break;
case|case
name|ACCESS_WRITE
case|:
name|flush_write
argument_list|()
expr_stmt|;
break|break;
case|case
name|ACCESS_UPDATE
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Backspace the archive descriptor by one record worth.  If it's a    tape, MTIOCTOP will work.  If it's something else, try to seek on    it.  If we can't seek, we lose!  */
end_comment

begin_function
specifier|static
name|void
name|backspace_output
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MTIOCTOP
block|{
name|struct
name|mtop
name|operation
decl_stmt|;
name|operation
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|operation
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
operator|>=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
block|{
name|off_t
name|position
init|=
name|rmtlseek
argument_list|(
name|archive
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
comment|/* Seek back to the beginning of this record and start writing there.  */
name|position
operator|-=
name|record_size
expr_stmt|;
if|if
condition|(
name|position
operator|<
literal|0
condition|)
name|position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rmtlseek
argument_list|(
name|archive
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|position
condition|)
block|{
comment|/* Lseek failed.  Try a different method.  */
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot backspace archive file; it may be unreadable without -i"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Replace the first part of the record with NULs.  */
if|if
condition|(
name|record_start
operator|->
name|buffer
operator|!=
name|output_start
condition|)
name|memset
argument_list|(
name|record_start
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|output_start
operator|-
name|record_start
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Close the archive file.  */
end_comment

begin_function
name|void
name|close_archive
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|time_to_start_writing
operator|||
name|access_mode
operator|==
name|ACCESS_WRITE
condition|)
name|flush_archive
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|MSDOS
comment|/* Manage to fully drain a pipe we might be reading, so to not break it on      the producer after the EOF block.  FIXME: one of these days, GNU tar      might become clever enough to just stop working, once there is no more      work to do, we might have to revise this area in such time.  */
if|if
condition|(
name|fast_read_option
operator|&&
name|namelist_freed
operator|&&
name|child_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|child_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_mode
operator|==
name|ACCESS_READ
operator|&&
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISSOCK
argument_list|(
name|archive_stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
while|while
condition|(
name|rmtread
argument_list|(
name|archive
argument_list|,
name|record_start
operator|->
name|buffer
argument_list|,
name|record_size
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|verify_option
condition|)
name|verify_volume
argument_list|()
expr_stmt|;
if|if
condition|(
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|!=
literal|0
condition|)
name|close_warn
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|MSDOS
if|if
condition|(
name|child_pid
condition|)
block|{
name|int
name|wait_status
decl_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
name|child_pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|waitpid_error
argument_list|(
name|use_compress_program_option
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fast_read_option
operator|||
operator|!
name|namelist_freed
condition|)
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Child died with signal %d"
argument_list|)
operator|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|!=
literal|0
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Child returned status %d"
argument_list|)
operator|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !MSDOS */
if|if
condition|(
name|current_file_name
condition|)
name|free
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_link_name
condition|)
name|free
argument_list|(
name|current_link_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_name
condition|)
name|free
argument_list|(
name|save_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_s_name
condition|)
name|free
argument_list|(
name|real_s_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|multi_volume_option
condition|?
name|record_start
operator|-
literal|2
else|:
name|record_start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to initialize the global volume number.  */
end_comment

begin_function
name|void
name|init_volume_number
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|volno_file_option
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|global_volno
argument_list|)
operator|!=
literal|1
operator|||
name|global_volno
operator|<
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: contains invalid volume number"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|volno_file_option
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
name|read_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|open_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to write out the closing global volume number.  */
end_comment

begin_function
name|void
name|closeout_volume_number
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|volno_file_option
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
name|global_volno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
name|write_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
block|}
else|else
name|open_error
argument_list|(
name|volno_file_option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've hit the end of the old volume.  Close it and open the next one.    Return nonzero on success.  */
end_comment

begin_function
specifier|static
name|int
name|new_volume
parameter_list|(
name|enum
name|access_mode
name|access
parameter_list|)
block|{
specifier|static
name|FILE
modifier|*
name|read_file
decl_stmt|;
specifier|static
name|int
name|looped
decl_stmt|;
if|if
condition|(
operator|!
name|read_file
operator|&&
operator|!
name|info_script_option
condition|)
comment|/* FIXME: if fopen is used, it will never be closed.  */
name|read_file
operator|=
name|archive
operator|==
name|STDIN_FILENO
condition|?
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
name|now_verifying
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|verify_option
condition|)
name|verify_volume
argument_list|()
expr_stmt|;
if|if
condition|(
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|!=
literal|0
condition|)
name|close_warn
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
expr_stmt|;
name|global_volno
operator|++
expr_stmt|;
if|if
condition|(
name|global_volno
operator|<
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Volume number overflow"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|volno
operator|++
expr_stmt|;
name|archive_name_cursor
operator|++
expr_stmt|;
if|if
condition|(
name|archive_name_cursor
operator|==
name|archive_name_array
operator|+
name|archive_names
condition|)
block|{
name|archive_name_cursor
operator|=
name|archive_name_array
expr_stmt|;
name|looped
operator|=
literal|1
expr_stmt|;
block|}
name|tryagain
label|:
if|if
condition|(
name|looped
condition|)
block|{
comment|/* We have to prompt from now on.  */
if|if
condition|(
name|info_script_option
condition|)
block|{
if|if
condition|(
name|volno_file_option
condition|)
name|closeout_volume_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|info_script_option
argument_list|)
operator|!=
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"`%s' command failed"
argument_list|)
operator|,
name|info_script_option
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|input_buffer
index|[
literal|80
index|]
decl_stmt|;
name|fputc
argument_list|(
literal|'\007'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Prepare volume #%d for %s and hit return: "
argument_list|)
argument_list|,
name|global_volno
argument_list|,
name|quote
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|input_buffer
argument_list|,
sizeof|sizeof
name|input_buffer
argument_list|,
name|read_file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"EOF where user reply was expected"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand_option
operator|!=
name|EXTRACT_SUBCOMMAND
operator|&&
name|subcommand_option
operator|!=
name|LIST_SUBCOMMAND
operator|&&
name|subcommand_option
operator|!=
name|DIFF_SUBCOMMAND
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"WARNING: Archive is incomplete"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|input_buffer
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
break|break;
switch|switch
condition|(
name|input_buffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\  n [name]   Give a new file name for the next (and subsequent) volume(s)\n\  q          Abort tar\n\  !          Spawn a subshell\n\  ?          Print this list\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* Quit.  */
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"No new volume; exiting.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand_option
operator|!=
name|EXTRACT_SUBCOMMAND
operator|&&
name|subcommand_option
operator|!=
name|LIST_SUBCOMMAND
operator|&&
name|subcommand_option
operator|!=
name|DIFF_SUBCOMMAND
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"WARNING: Archive is incomplete"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|()
expr_stmt|;
case|case
literal|'n'
case|:
comment|/* Get new file name.  */
block|{
name|char
modifier|*
name|name
init|=
operator|&
name|input_buffer
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|' '
operator|||
operator|*
name|name
operator|==
literal|'\t'
condition|)
name|name
operator|++
expr_stmt|;
name|cursor
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|cursor
operator|&&
operator|*
name|cursor
operator|!=
literal|'\n'
condition|)
name|cursor
operator|++
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
comment|/* FIXME: the following allocation is never reclaimed.  */
operator|*
name|archive_name_cursor
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
if|#
directive|if
name|MSDOS
name|spawnl
argument_list|(
name|P_WAIT
argument_list|,
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not MSDOS */
block|{
name|pid_t
name|child
decl_stmt|;
specifier|const
name|char
modifier|*
name|shell
init|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shell
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
name|child
operator|=
name|xfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|0
condition|)
block|{
name|execlp
argument_list|(
name|shell
argument_list|,
literal|"-sh"
argument_list|,
literal|"-i"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exec_fatal
argument_list|(
name|shell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|wait_status
decl_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|waitpid_error
argument_list|(
name|shell
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* not MSDOS */
break|break;
block|}
block|}
block|}
if|if
condition|(
name|verify_option
condition|)
name|archive
operator|=
name|rmtopen
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|access
condition|)
block|{
case|case
name|ACCESS_READ
case|:
name|archive
operator|=
name|rmtopen
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
name|O_RDONLY
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCESS_WRITE
case|:
if|if
condition|(
name|backup_option
condition|)
name|maybe_backup_file
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|archive
operator|=
name|rmtcreat
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACCESS_UPDATE
case|:
name|archive
operator|=
name|rmtopen
argument_list|(
operator|*
name|archive_name_cursor
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|MODE_RW
argument_list|,
name|rsh_command_option
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|open_warn
argument_list|(
operator|*
name|archive_name_cursor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verify_option
operator|&&
name|access
operator|==
name|ACCESS_WRITE
operator|&&
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|#
directive|if
name|MSDOS
name|setmode
argument_list|(
name|archive
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

end_unit

