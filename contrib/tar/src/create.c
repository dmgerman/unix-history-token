begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Create a tar archive.    Copyright 1985,92,93,94,96,97,99,2000, 2001 Free Software Foundation, Inc.    Written by John Gilmore, on 1985-08-25.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_if
if|#
directive|if
operator|!
name|MSDOS
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|<hash.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_decl_stmt
specifier|extern
name|dev_t
name|ar_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ino_t
name|ar_ino
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|link
block|{
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The maximum uintmax_t value that can be represented with DIGITS digits,    assuming that each digit is BITS_PER_DIGIT wide.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VAL_WITH_DIGITS
parameter_list|(
name|digits
parameter_list|,
name|bits_per_digit
parameter_list|)
define|\
value|((digits) * (bits_per_digit)< sizeof (uintmax_t) * CHAR_BIT \     ? ((uintmax_t) 1<< ((digits) * (bits_per_digit))) - 1 \     : (uintmax_t) -1)
end_define

begin_comment
comment|/* Convert VALUE to an octal representation suitable for tar headers.    Output to buffer WHERE with size SIZE.    The result is undefined if SIZE is 0 or if VALUE is too large to fit.  */
end_comment

begin_function
specifier|static
name|void
name|to_octal
parameter_list|(
name|uintmax_t
name|value
parameter_list|,
name|char
modifier|*
name|where
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uintmax_t
name|v
init|=
name|value
decl_stmt|;
name|size_t
name|i
init|=
name|size
decl_stmt|;
do|do
block|{
name|where
index|[
operator|--
name|i
index|]
operator|=
literal|'0'
operator|+
operator|(
name|v
operator|&
operator|(
operator|(
literal|1
operator|<<
name|LG_8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|v
operator|>>=
name|LG_8
expr_stmt|;
block|}
do|while
condition|(
name|i
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Convert NEGATIVE VALUE to a base-256 representation suitable for    tar headers.  NEGATIVE is 1 if VALUE was negative before being cast    to uintmax_t, 0 otherwise.  Output to buffer WHERE with size SIZE.    The result is undefined if SIZE is 0 or if VALUE is too large to    fit.  */
end_comment

begin_function
specifier|static
name|void
name|to_base256
parameter_list|(
name|int
name|negative
parameter_list|,
name|uintmax_t
name|value
parameter_list|,
name|char
modifier|*
name|where
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uintmax_t
name|v
init|=
name|value
decl_stmt|;
name|uintmax_t
name|propagated_sign_bits
init|=
operator|(
operator|(
name|uintmax_t
operator|)
operator|-
name|negative
operator|<<
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
name|v
operator|-
name|LG_256
operator|)
operator|)
decl_stmt|;
name|size_t
name|i
init|=
name|size
decl_stmt|;
do|do
block|{
name|where
index|[
operator|--
name|i
index|]
operator|=
name|v
operator|&
operator|(
operator|(
literal|1
operator|<<
name|LG_256
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|v
operator|=
name|propagated_sign_bits
operator||
operator|(
name|v
operator|>>
name|LG_256
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|i
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Convert NEGATIVE VALUE (which was originally of size VALSIZE) to    external form, using SUBSTITUTE (...) if VALUE won't fit.  Output    to buffer WHERE with size SIZE.  NEGATIVE is 1 iff VALUE was    negative before being cast to uintmax_t; its original bitpattern    can be deduced from VALSIZE, its original size before casting.    TYPE is the kind of value being output (useful for diagnostics).    Prefer the POSIX format of SIZE - 1 octal digits (with leading zero    digits), followed by '\0'.  If this won't work, and if GNU or    OLDGNU format is allowed, use '\200' followed by base-256, or (if    NEGATIVE is nonzero) '\377' followed by two's complement base-256.    If neither format works, use SUBSTITUTE (...)  instead.  Pass to    SUBSTITUTE the address of an 0-or-1 flag recording whether the    substitute value is negative.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|to_chars
argument_list|(
name|int
name|negative
argument_list|,
name|uintmax_t
name|value
argument_list|,
name|size_t
name|valsize
argument_list|,
name|uintmax_t
argument_list|(
argument|*substitute
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
argument_list|,
name|char
operator|*
name|where
argument_list|,
name|size_t
name|size
argument_list|,
specifier|const
name|char
operator|*
name|type
argument_list|)
block|{
name|int
name|base256_allowed
init|=
operator|(
name|archive_format
operator|==
name|GNU_FORMAT
operator|||
name|archive_format
operator|==
name|OLDGNU_FORMAT
operator|)
decl_stmt|;
comment|/* Generate the POSIX octal representation if the number fits.  */
if|if
condition|(
operator|!
name|negative
operator|&&
name|value
operator|<=
name|MAX_VAL_WITH_DIGITS
argument_list|(
name|size
operator|-
literal|1
argument_list|,
name|LG_8
argument_list|)
condition|)
block|{
name|where
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to_octal
argument_list|(
name|value
argument_list|,
name|where
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, generate the base-256 representation if we are      generating an old or new GNU format and if the number fits.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|negative
condition|?
operator|-
literal|1
operator|-
name|value
else|:
name|value
operator|)
operator|<=
name|MAX_VAL_WITH_DIGITS
argument_list|(
name|size
operator|-
literal|1
argument_list|,
name|LG_256
argument_list|)
operator|)
operator|&&
name|base256_allowed
condition|)
block|{
name|where
index|[
literal|0
index|]
operator|=
name|negative
condition|?
operator|-
literal|1
else|:
literal|1
operator|<<
operator|(
name|LG_256
operator|-
literal|1
operator|)
expr_stmt|;
name|to_base256
argument_list|(
name|negative
argument_list|,
name|value
argument_list|,
name|where
operator|+
literal|1
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, if the number is negative, and if it would not cause      ambiguity on this host by confusing positive with negative      values, then generate the POSIX octal representation of the value      modulo 2**(field bits).  The resulting tar file is      machine-dependent, since it depends on the host word size.  Yuck!      But this is the traditional behavior.  */
elseif|else
if|if
condition|(
name|negative
operator|&&
name|valsize
operator|*
name|CHAR_BIT
operator|<=
operator|(
name|size
operator|-
literal|1
operator|)
operator|*
name|LG_8
condition|)
block|{
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Generating negative octal headers"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|where
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to_octal
argument_list|(
name|value
operator|&
name|MAX_VAL_WITH_DIGITS
argument_list|(
name|valsize
operator|*
name|CHAR_BIT
argument_list|,
literal|1
argument_list|)
argument_list|,
name|where
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, output a substitute value if possible (with a      warning), and an error message if not.  */
else|else
block|{
name|uintmax_t
name|maxval
init|=
operator|(
name|base256_allowed
condition|?
name|MAX_VAL_WITH_DIGITS
argument_list|(
name|size
operator|-
literal|1
argument_list|,
name|LG_256
argument_list|)
else|:
name|MAX_VAL_WITH_DIGITS
argument_list|(
name|size
operator|-
literal|1
argument_list|,
name|LG_8
argument_list|)
operator|)
decl_stmt|;
name|char
name|valbuf
index|[
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|maxbuf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|char
name|minbuf
index|[
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|minval_string
decl_stmt|;
name|char
specifier|const
modifier|*
name|maxval_string
init|=
name|STRINGIFY_BIGINT
argument_list|(
name|maxval
argument_list|,
name|maxbuf
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|value_string
decl_stmt|;
if|if
condition|(
name|base256_allowed
condition|)
block|{
name|uintmax_t
name|m
init|=
name|maxval
operator|+
literal|1
condition|?
name|maxval
operator|+
literal|1
else|:
name|maxval
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|STRINGIFY_BIGINT
argument_list|(
name|m
argument_list|,
name|minbuf
operator|+
literal|1
argument_list|)
decl_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
name|minval_string
operator|=
name|p
expr_stmt|;
block|}
else|else
name|minval_string
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|STRINGIFY_BIGINT
argument_list|(
operator|-
name|value
argument_list|,
name|valbuf
operator|+
literal|1
argument_list|)
decl_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
name|value_string
operator|=
name|p
expr_stmt|;
block|}
else|else
name|value_string
operator|=
name|STRINGIFY_BIGINT
argument_list|(
name|value
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|substitute
condition|)
block|{
name|int
name|negsub
decl_stmt|;
name|uintmax_t
name|sub
init|=
name|substitute
argument_list|(
operator|&
name|negsub
argument_list|)
operator|&
name|maxval
decl_stmt|;
name|uintmax_t
name|s
init|=
operator|(
name|negsub
operator|&=
name|archive_format
operator|==
name|GNU_FORMAT
operator|)
condition|?
operator|-
name|sub
else|:
name|sub
decl_stmt|;
name|char
name|subbuf
index|[
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|sub_string
init|=
name|STRINGIFY_BIGINT
argument_list|(
name|s
argument_list|,
name|subbuf
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|negsub
condition|)
operator|*
operator|--
name|sub_string
operator|=
literal|'-'
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"value %s out of %s range %s..%s; substituting %s"
argument_list|)
operator|,
name|value_string
operator|,
name|type
operator|,
name|minval_string
operator|,
name|maxval_string
operator|,
name|sub_string
operator|)
argument_list|)
expr_stmt|;
name|to_chars
argument_list|(
name|negsub
argument_list|,
name|s
argument_list|,
name|valsize
argument_list|,
literal|0
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"value %s out of %s range %s..%s"
argument_list|)
operator|,
name|value_string
operator|,
name|type
operator|,
name|minval_string
operator|,
name|maxval_string
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|uintmax_t
name|gid_substitute
parameter_list|(
name|int
modifier|*
name|negative
parameter_list|)
block|{
name|gid_t
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|GID_NOBODY
name|r
operator|=
name|GID_NOBODY
expr_stmt|;
else|#
directive|else
specifier|static
name|gid_t
name|gid_nobody
decl_stmt|;
if|if
condition|(
operator|!
name|gid_nobody
operator|&&
operator|!
name|gname_to_gid
argument_list|(
literal|"nobody"
argument_list|,
operator|&
name|gid_nobody
argument_list|)
condition|)
name|gid_nobody
operator|=
operator|-
literal|2
expr_stmt|;
name|r
operator|=
name|gid_nobody
expr_stmt|;
endif|#
directive|endif
operator|*
name|negative
operator|=
name|r
operator|<
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|gid_to_chars
parameter_list|(
name|gid_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
name|gid_substitute
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"gid_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|major_to_chars
parameter_list|(
name|major_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"major_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|minor_to_chars
parameter_list|(
name|minor_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"minor_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mode_to_chars
parameter_list|(
name|mode_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
comment|/* In the common case where the internal and external mode bits are the same,      and we are not using POSIX or GNU format,      propagate all unknown bits to the external mode.      This matches historical practice.      Otherwise, just copy the bits we know about.  */
name|int
name|negative
decl_stmt|;
name|uintmax_t
name|u
decl_stmt|;
if|if
condition|(
name|S_ISUID
operator|==
name|TSUID
operator|&&
name|S_ISGID
operator|==
name|TSGID
operator|&&
name|S_ISVTX
operator|==
name|TSVTX
operator|&&
name|S_IRUSR
operator|==
name|TUREAD
operator|&&
name|S_IWUSR
operator|==
name|TUWRITE
operator|&&
name|S_IXUSR
operator|==
name|TUEXEC
operator|&&
name|S_IRGRP
operator|==
name|TGREAD
operator|&&
name|S_IWGRP
operator|==
name|TGWRITE
operator|&&
name|S_IXGRP
operator|==
name|TGEXEC
operator|&&
name|S_IROTH
operator|==
name|TOREAD
operator|&&
name|S_IWOTH
operator|==
name|TOWRITE
operator|&&
name|S_IXOTH
operator|==
name|TOEXEC
operator|&&
name|archive_format
operator|!=
name|POSIX_FORMAT
operator|&&
name|archive_format
operator|!=
name|GNU_FORMAT
condition|)
block|{
name|negative
operator|=
name|v
operator|<
literal|0
expr_stmt|;
name|u
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|negative
operator|=
literal|0
expr_stmt|;
name|u
operator|=
operator|(
operator|(
name|v
operator|&
name|S_ISUID
condition|?
name|TSUID
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_ISGID
condition|?
name|TSGID
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_ISVTX
condition|?
name|TSVTX
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IRUSR
condition|?
name|TUREAD
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IWUSR
condition|?
name|TUWRITE
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IXUSR
condition|?
name|TUEXEC
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IRGRP
condition|?
name|TGREAD
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IWGRP
condition|?
name|TGWRITE
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IXGRP
condition|?
name|TGEXEC
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IROTH
condition|?
name|TOREAD
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IWOTH
condition|?
name|TOWRITE
else|:
literal|0
operator|)
operator||
operator|(
name|v
operator|&
name|S_IXOTH
condition|?
name|TOEXEC
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
name|to_chars
argument_list|(
name|negative
argument_list|,
name|u
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"mode_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|off_to_chars
parameter_list|(
name|off_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"off_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|size_to_chars
parameter_list|(
name|size_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"size_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|time_to_chars
parameter_list|(
name|time_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"time_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uintmax_t
name|uid_substitute
parameter_list|(
name|int
modifier|*
name|negative
parameter_list|)
block|{
name|uid_t
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|UID_NOBODY
name|r
operator|=
name|UID_NOBODY
expr_stmt|;
else|#
directive|else
specifier|static
name|uid_t
name|uid_nobody
decl_stmt|;
if|if
condition|(
operator|!
name|uid_nobody
operator|&&
operator|!
name|uname_to_uid
argument_list|(
literal|"nobody"
argument_list|,
operator|&
name|uid_nobody
argument_list|)
condition|)
name|uid_nobody
operator|=
operator|-
literal|2
expr_stmt|;
name|r
operator|=
name|uid_nobody
expr_stmt|;
endif|#
directive|endif
operator|*
name|negative
operator|=
name|r
operator|<
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|uid_to_chars
parameter_list|(
name|uid_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
name|v
operator|<
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
name|uid_substitute
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"uid_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uintmax_to_chars
parameter_list|(
name|uintmax_t
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|to_chars
argument_list|(
literal|0
argument_list|,
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
literal|"uintmax_t"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Writing routines.  */
end_comment

begin_comment
comment|/* Zero out the buffer so we don't confuse ourselves with leftover    data.  */
end_comment

begin_function
specifier|static
name|void
name|clear_buffer
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the EOT block(s).  Zero at least two blocks, through the end    of the record.  Old tar, as previous versions of GNU tar, writes    garbage after two zeroed blocks.  */
end_comment

begin_function
name|void
name|write_eot
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|block
modifier|*
name|pointer
init|=
name|find_next_block
argument_list|()
decl_stmt|;
name|memset
argument_list|(
name|pointer
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|pointer
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|available_space_after
argument_list|(
name|pointer
argument_list|)
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a GNUTYPE_LONGLINK or GNUTYPE_LONGNAME block.  */
end_comment

begin_comment
comment|/* FIXME: Cross recursion between start_header and write_long!  */
end_comment

begin_decl_stmt
specifier|static
name|union
name|block
modifier|*
name|start_header
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|write_long
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|char
name|type
parameter_list|)
block|{
name|size_t
name|size
init|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|union
name|block
modifier|*
name|header
decl_stmt|;
name|struct
name|stat
name|foo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|foo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|foo
argument_list|)
expr_stmt|;
name|foo
operator|.
name|st_size
operator|=
name|size
expr_stmt|;
name|header
operator|=
name|start_header
argument_list|(
literal|"././@LongLink"
argument_list|,
operator|&
name|foo
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|type
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|header
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|available_space_after
argument_list|(
name|header
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufsize
operator|<
name|size
condition|)
block|{
name|memcpy
argument_list|(
name|header
operator|->
name|buffer
argument_list|,
name|p
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|p
operator|+=
name|bufsize
expr_stmt|;
name|size
operator|-=
name|bufsize
expr_stmt|;
name|set_next_block_after
argument_list|(
name|header
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|header
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|available_space_after
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|header
operator|->
name|buffer
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|header
operator|->
name|buffer
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|bufsize
operator|-
name|size
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|header
operator|+
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a suffix of the file NAME that is a relative file name.    Warn about `..' in file names.  But return NAME if the user wants    absolute file names.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|relativize
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|absolute_names_option
condition|)
block|{
block|{
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
operator|&&
name|contains_dot_dot
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Member names contain `..'"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|size_t
name|prefix_len
init|=
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
name|name
index|[
name|prefix_len
index|]
argument_list|)
condition|)
name|prefix_len
operator|++
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
block|{
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Removing leading `%.*s' from member names"
argument_list|)
operator|,
operator|(
name|int
operator|)
name|prefix_len
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|+=
name|prefix_len
expr_stmt|;
block|}
block|}
block|}
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Header handling.  */
end_comment

begin_comment
comment|/* Make a header block for the file whose stat info is st,    and return its address.  */
end_comment

begin_function
specifier|static
name|union
name|block
modifier|*
name|start_header
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|union
name|block
modifier|*
name|header
decl_stmt|;
name|name
operator|=
name|relativize
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|name
operator|<=
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
name|write_long
argument_list|(
name|name
argument_list|,
name|GNUTYPE_LONGNAME
argument_list|)
expr_stmt|;
name|header
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|header
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|current_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|NAME_FIELD_SIZE
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|name
index|[
name|NAME_FIELD_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Override some stat fields, if requested to do so.  */
if|if
condition|(
name|owner_option
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
name|st
operator|->
name|st_uid
operator|=
name|owner_option
expr_stmt|;
if|if
condition|(
name|group_option
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|st
operator|->
name|st_gid
operator|=
name|group_option
expr_stmt|;
if|if
condition|(
name|mode_option
condition|)
name|st
operator|->
name|st_mode
operator|=
operator|(
operator|(
name|st
operator|->
name|st_mode
operator|&
operator|~
name|MODE_ALL
operator|)
operator||
name|mode_adjust
argument_list|(
name|st
operator|->
name|st_mode
argument_list|,
name|mode_option
argument_list|)
operator|)
expr_stmt|;
comment|/* Paul Eggert tried the trivial test ($WRITER cf a b; $READER tvf a)      for a few tars and came up with the following interoperability      matrix:  	      WRITER 	1 2 3 4 5 6 7 8 9   READER 	. . . . . . . . .   1 = SunOS 4.2 tar 	# . . # # . . # #   2 = NEC SVR4.0.2 tar 	. . . # # . . # .   3 = Solaris 2.1 tar 	. . . . . . . . .   4 = GNU tar 1.11.1 	. . . . . . . . .   5 = HP-UX 8.07 tar 	. . . . . . . . .   6 = Ultrix 4.1 	. . . . . . . . .   7 = AIX 3.2 	. . . . . . . . .   8 = Hitachi HI-UX 1.03 	. . . . . . . . .   9 = Omron UNIOS-B 4.3BSD 1.60Beta  	     . = works 	     # = ``impossible file type''       The following mask for old archive removes the `#'s in column 4      above, thus making GNU tar both a universal donor and a universal      acceptor for Paul's test.  */
if|if
condition|(
name|archive_format
operator|==
name|V7_FORMAT
condition|)
name|MODE_TO_CHARS
argument_list|(
name|st
operator|->
name|st_mode
operator|&
name|MODE_ALL
argument_list|,
name|header
operator|->
name|header
operator|.
name|mode
argument_list|)
expr_stmt|;
else|else
name|MODE_TO_CHARS
argument_list|(
name|st
operator|->
name|st_mode
argument_list|,
name|header
operator|->
name|header
operator|.
name|mode
argument_list|)
expr_stmt|;
name|UID_TO_CHARS
argument_list|(
name|st
operator|->
name|st_uid
argument_list|,
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
name|GID_TO_CHARS
argument_list|(
name|st
operator|->
name|st_gid
argument_list|,
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|st
operator|->
name|st_size
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|TIME_TO_CHARS
argument_list|(
name|st
operator|->
name|st_mtime
argument_list|,
name|header
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental_option
condition|)
if|if
condition|(
name|archive_format
operator|==
name|OLDGNU_FORMAT
condition|)
block|{
name|TIME_TO_CHARS
argument_list|(
name|st
operator|->
name|st_atime
argument_list|,
name|header
operator|->
name|oldgnu_header
operator|.
name|atime
argument_list|)
expr_stmt|;
name|TIME_TO_CHARS
argument_list|(
name|st
operator|->
name|st_ctime
argument_list|,
name|header
operator|->
name|oldgnu_header
operator|.
name|ctime
argument_list|)
expr_stmt|;
block|}
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|archive_format
operator|==
name|V7_FORMAT
condition|?
name|AREGTYPE
else|:
name|REGTYPE
expr_stmt|;
switch|switch
condition|(
name|archive_format
condition|)
block|{
case|case
name|V7_FORMAT
case|:
break|break;
case|case
name|OLDGNU_FORMAT
case|:
comment|/* Overwrite header->header.magic and header.version in one blow.  */
name|strcpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|OLDGNU_MAGIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSIX_FORMAT
case|:
case|case
name|GNU_FORMAT
case|:
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|TMAGIC
argument_list|,
name|TMAGLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|version
argument_list|,
name|TVERSION
argument_list|,
name|TVERSLEN
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|archive_format
operator|==
name|V7_FORMAT
operator|||
name|numeric_owner_option
condition|)
block|{
comment|/* header->header.[ug]name are left as the empty string.  */
block|}
else|else
block|{
name|uid_to_uname
argument_list|(
name|st
operator|->
name|st_uid
argument_list|,
name|header
operator|->
name|header
operator|.
name|uname
argument_list|)
expr_stmt|;
name|gid_to_gname
argument_list|(
name|st
operator|->
name|st_gid
argument_list|,
name|header
operator|->
name|header
operator|.
name|gname
argument_list|)
expr_stmt|;
block|}
return|return
name|header
return|;
block|}
end_function

begin_comment
comment|/* Finish off a filled-in header block and write it out.  We also    print the file name and/or full info if verbose is on.  */
end_comment

begin_function
name|void
name|finish_header
parameter_list|(
name|union
name|block
modifier|*
name|header
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|sum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|memcpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|,
name|CHKBLANKS
argument_list|,
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
expr|*
name|header
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
comment|/* We can't use unsigned char here because of old compilers, e.g. V7.  */
name|sum
operator|+=
literal|0xFF
operator|&
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Fill in the checksum field.  It's formatted differently from the      other fields: it has [6] digits, a null, then a space -- rather than      digits, then a null.  We use to_chars.      The final space is already there, from      checksumming, and to_chars doesn't modify it.       This is a fast way to do:       sprintf(header->header.chksum, "%6o", sum);  */
name|uintmax_to_chars
argument_list|(
operator|(
name|uintmax_t
operator|)
name|sum
argument_list|,
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_option
operator|&&
name|header
operator|->
name|header
operator|.
name|typeflag
operator|!=
name|GNUTYPE_LONGLINK
operator|&&
name|header
operator|->
name|header
operator|.
name|typeflag
operator|!=
name|GNUTYPE_LONGNAME
condition|)
block|{
comment|/* These globals are parameters to print_header, sigh.  */
name|current_header
operator|=
name|header
expr_stmt|;
comment|/* current_stat is already set up.  */
name|current_format
operator|=
name|archive_format
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
name|set_next_block_after
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sparse file processing.  */
end_comment

begin_comment
comment|/* Takes a blockful of data and basically cruises through it to see if    it's made *entirely* of zeros, returning a 0 the instant it finds    something that is a nonzero, i.e., useful data.  */
end_comment

begin_function
specifier|static
name|int
name|zero_block_p
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|counter
decl_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|BLOCKSIZE
condition|;
name|counter
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|counter
index|]
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sparsearray
parameter_list|(
name|void
parameter_list|)
block|{
name|sp_array_size
operator|=
literal|10
expr_stmt|;
comment|/* Make room for our scratch space -- initially is 10 elts long.  */
name|sparsearray
operator|=
name|xmalloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|find_new_file_size
parameter_list|(
name|int
name|sparses
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|off_t
name|s
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sparses
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Make one pass over the file NAME, studying where any non-zero data    is, that is, how far into the file each instance of data is, and    how many bytes are there.  Save this information in the    sparsearray, which will later be translated into header    information.  */
end_comment

begin_comment
comment|/* There is little point in trimming small amounts of null data at the head    and tail of blocks, only avoid dumping full null blocks.  */
end_comment

begin_comment
comment|/* FIXME: this routine might accept bits of algorithmic cleanup, it is    too kludgey for my taste...  */
end_comment

begin_function
specifier|static
name|int
name|deal_with_sparse
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|union
name|block
modifier|*
name|header
parameter_list|)
block|{
name|size_t
name|numbytes
init|=
literal|0
decl_stmt|;
name|off_t
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|file
decl_stmt|;
name|int
name|sparses
init|=
literal|0
decl_stmt|;
name|ssize_t
name|count
decl_stmt|;
name|char
name|buffer
index|[
name|BLOCKSIZE
index|]
decl_stmt|;
if|if
condition|(
name|archive_format
operator|==
name|OLDGNU_FORMAT
condition|)
name|header
operator|->
name|oldgnu_header
operator|.
name|isextended
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|,
name|file
operator|<
literal|0
condition|)
comment|/* This problem will be caught later on, so just return.  */
return|return
literal|0
return|;
name|init_sparsearray
argument_list|()
expr_stmt|;
name|clear_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Realloc the scratch area as necessary.  FIXME: should reallocate 	 only at beginning of a new instance of non-zero data.  */
if|if
condition|(
name|sp_array_size
operator|<=
name|sparses
condition|)
block|{
name|sparsearray
operator|=
name|xrealloc
argument_list|(
name|sparsearray
argument_list|,
literal|2
operator|*
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
block|}
name|count
operator|=
name|safe_read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
break|break;
comment|/* Process one block.  */
if|if
condition|(
name|count
operator|==
sizeof|sizeof
name|buffer
condition|)
if|if
condition|(
name|zero_block_p
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|numbytes
condition|)
block|{
name|sparsearray
index|[
name|sparses
operator|++
index|]
operator|.
name|numbytes
operator|=
name|numbytes
expr_stmt|;
name|numbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|numbytes
condition|)
name|sparsearray
index|[
name|sparses
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|numbytes
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
comment|/* Since count< sizeof buffer, we have the last bit of the file.  */
if|if
condition|(
operator|!
name|zero_block_p
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|numbytes
condition|)
name|sparsearray
index|[
name|sparses
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|numbytes
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
comment|/* The next two lines are suggested by Andreas Degert, who says 	     they are required for trailing full blocks to be written to the 	     archive, when all zeroed.  Yet, it seems to me that the case 	     does not apply.  Further, at restore time, the file is not as 	     sparse as it should.  So, some serious cleanup is *also* needed 	     in this area.  Just one more... :-(.  FIXME.  */
if|if
condition|(
name|numbytes
condition|)
name|numbytes
operator|+=
name|count
expr_stmt|;
comment|/* Prepare for next block.  */
name|offset
operator|+=
name|count
expr_stmt|;
comment|/* FIXME: do not clear unless necessary.  */
name|clear_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numbytes
condition|)
name|sparsearray
index|[
name|sparses
operator|++
index|]
operator|.
name|numbytes
operator|=
name|numbytes
expr_stmt|;
else|else
block|{
name|sparsearray
index|[
name|sparses
index|]
operator|.
name|offset
operator|=
name|offset
operator|-
literal|1
expr_stmt|;
name|sparsearray
index|[
name|sparses
operator|++
index|]
operator|.
name|numbytes
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|close
argument_list|(
name|file
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|<=
name|count
condition|?
name|sparses
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finish_sparse_file
parameter_list|(
name|int
name|file
parameter_list|,
name|off_t
modifier|*
name|sizeleft
parameter_list|,
name|off_t
name|fullsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|union
name|block
modifier|*
name|start
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|sparses
init|=
literal|0
decl_stmt|;
name|ssize_t
name|count
decl_stmt|;
while|while
condition|(
operator|*
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|start
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|start
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|sparsearray
index|[
name|sparses
index|]
operator|.
name|numbytes
expr_stmt|;
if|if
condition|(
operator|!
name|bufsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|file
argument_list|,
name|sparsearray
index|[
name|sparses
operator|++
index|]
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|ignore_failed_read_option
condition|?
name|seek_warn_details
else|:
name|seek_error_details
operator|)
operator|(
name|name
operator|,
name|sparsearray
index|[
name|sparses
operator|-
literal|1
index|]
operator|.
name|offset
operator|)
expr_stmt|;
break|break;
block|}
comment|/* If the number of bytes to be written here exceeds the size of 	 the temporary buffer, do it in steps.  */
while|while
condition|(
name|bufsize
operator|>
name|BLOCKSIZE
condition|)
block|{
name|count
operator|=
name|safe_read
argument_list|(
name|file
argument_list|,
name|start
operator|->
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
operator|(
name|ignore_failed_read_option
condition|?
name|read_warn_details
else|:
name|read_error_details
operator|)
operator|(
name|name
operator|,
name|fullsize
operator|-
operator|*
name|sizeleft
operator|,
name|bufsize
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bufsize
operator|-=
name|count
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|set_next_block_after
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|start
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
block|{
name|char
name|buffer
index|[
name|BLOCKSIZE
index|]
decl_stmt|;
name|clear_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|count
operator|=
name|safe_read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|start
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
operator|(
name|ignore_failed_read_option
condition|?
name|read_warn_details
else|:
name|read_error_details
operator|)
operator|(
name|name
operator|,
name|fullsize
operator|-
operator|*
name|sizeleft
operator|,
name|bufsize
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|set_next_block_after
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|set_next_block_after (start + (count - 1) / BLOCKSIZE);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main functions of this module.  */
end_comment

begin_function
name|void
name|create_archive
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|open_archive
argument_list|(
name|ACCESS_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental_option
condition|)
block|{
name|size_t
name|buffer_size
init|=
literal|1000
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|collect_and_sort_names
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|name_from_list
argument_list|()
operator|,
name|p
condition|)
if|if
condition|(
operator|!
name|excluded_name
argument_list|(
name|p
argument_list|)
condition|)
name|dump_file
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|blank_name_list
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|name_from_list
argument_list|()
operator|,
name|p
condition|)
if|if
condition|(
operator|!
name|excluded_name
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|size_t
name|plen
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer_size
operator|<=
name|plen
condition|)
block|{
while|while
condition|(
operator|(
name|buffer_size
operator|*=
literal|2
operator|)
operator|<=
name|plen
condition|)
continue|continue;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|p
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSLASH
argument_list|(
name|buffer
index|[
name|plen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buffer
index|[
name|plen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|q
operator|=
name|gnu_list_name
operator|->
name|dir_contents
expr_stmt|;
if|if
condition|(
name|q
condition|)
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|size_t
name|qlen
init|=
name|strlen
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'Y'
condition|)
block|{
if|if
condition|(
name|buffer_size
operator|<
name|plen
operator|+
name|qlen
condition|)
block|{
while|while
condition|(
operator|(
name|buffer_size
operator|*=
literal|2
operator|)
operator|<
name|plen
operator|+
name|qlen
condition|)
continue|continue;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buffer
operator|+
name|plen
argument_list|,
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_file
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|q
operator|+=
name|qlen
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|p
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
operator|,
name|p
condition|)
if|if
condition|(
operator|!
name|excluded_name
argument_list|(
name|p
argument_list|)
condition|)
name|dump_file
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|listed_incremental_option
condition|)
name|write_directory_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the hash of a link.  */
end_comment

begin_function
specifier|static
name|unsigned
name|hash_link
parameter_list|(
name|void
specifier|const
modifier|*
name|entry
parameter_list|,
name|unsigned
name|n_buckets
parameter_list|)
block|{
name|struct
name|link
specifier|const
modifier|*
name|link
init|=
name|entry
decl_stmt|;
return|return
call|(
name|uintmax_t
call|)
argument_list|(
name|link
operator|->
name|dev
operator|^
name|link
operator|->
name|ino
argument_list|)
operator|%
name|n_buckets
return|;
block|}
end_function

begin_comment
comment|/* Compare two links for equality.  */
end_comment

begin_function
specifier|static
name|bool
name|compare_links
parameter_list|(
name|void
specifier|const
modifier|*
name|entry1
parameter_list|,
name|void
specifier|const
modifier|*
name|entry2
parameter_list|)
block|{
name|struct
name|link
specifier|const
modifier|*
name|link1
init|=
name|entry1
decl_stmt|;
name|struct
name|link
specifier|const
modifier|*
name|link2
init|=
name|entry2
decl_stmt|;
return|return
operator|(
operator|(
name|link1
operator|->
name|dev
operator|^
name|link2
operator|->
name|dev
operator|)
operator||
operator|(
name|link1
operator|->
name|ino
operator|^
name|link2
operator|->
name|ino
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dump a single file, recursing on directories.  P is the file name    to dump.  TOP_LEVEL tells whether this is a top-level call; zero    means no, positive means yes, and negative means an incremental    dump.  PARENT_DEVICE is the device of P's    parent directory; it is examined only if TOP_LEVEL is zero.     Set global CURRENT_STAT to stat output for this file.  */
end_comment

begin_comment
comment|/* FIXME: One should make sure that for *every* path leading to setting    exit_status to failure, a clear diagnostic has been issued.  */
end_comment

begin_function
name|void
name|dump_file
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|top_level
parameter_list|,
name|dev_t
name|parent_device
parameter_list|)
block|{
name|union
name|block
modifier|*
name|header
decl_stmt|;
name|char
name|type
decl_stmt|;
name|union
name|block
modifier|*
name|exhdr
decl_stmt|;
name|char
name|save_typeflag
decl_stmt|;
name|time_t
name|original_ctime
decl_stmt|;
name|struct
name|utimbuf
name|restore_times
decl_stmt|;
comment|/* FIXME: `header' might be used uninitialized in this      function.  Reported by Bruno Haible.  */
if|if
condition|(
name|interactive_option
operator|&&
operator|!
name|confirm
argument_list|(
literal|"add"
argument_list|,
name|p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|stat_warn
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|stat_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|original_ctime
operator|=
name|current_stat
operator|.
name|st_ctime
expr_stmt|;
name|restore_times
operator|.
name|actime
operator|=
name|current_stat
operator|.
name|st_atime
expr_stmt|;
name|restore_times
operator|.
name|modtime
operator|=
name|current_stat
operator|.
name|st_mtime
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISHIDDEN
if|if
condition|(
name|S_ISHIDDEN
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|p
operator|=
name|new
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* See if we want only new files, and check if this one is too old to      put in the archive.  */
if|if
condition|(
operator|(
literal|0
operator|<
name|top_level
operator|||
operator|!
name|incremental_option
operator|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
operator|&&
name|current_stat
operator|.
name|st_mtime
operator|<
name|newer_mtime_option
operator|&&
operator|(
operator|!
name|after_date_option
operator|||
name|current_stat
operator|.
name|st_ctime
operator|<
name|newer_ctime_option
operator|)
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|top_level
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: file is unchanged; not dumped"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* FIXME: recheck this return.  */
return|return;
block|}
if|#
directive|if
operator|!
name|MSDOS
comment|/* See if we are trying to dump the archive.  */
if|if
condition|(
name|ar_dev
operator|&&
name|current_stat
operator|.
name|st_dev
operator|==
name|ar_dev
operator|&&
name|current_stat
operator|.
name|st_ino
operator|==
name|ar_ino
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: file is the archive; not dumped"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|S_ISDIR
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|directory
decl_stmt|;
name|char
specifier|const
modifier|*
name|entry
decl_stmt|;
name|size_t
name|entrylen
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|dev_t
name|our_device
init|=
name|current_stat
operator|.
name|st_dev
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|directory
operator|=
name|savedir
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|directory
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|savedir_warn
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|savedir_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build new prototype name.  Ensure exactly one trailing slash.  */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|len
operator|+
name|NAME_FIELD_SIZE
expr_stmt|;
name|namebuf
operator|=
name|xmalloc
argument_list|(
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|namebuf
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|1
operator|&&
name|ISSLASH
argument_list|(
name|namebuf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|namebuf
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|namebuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|is_avoided_name
argument_list|(
name|namebuf
argument_list|)
condition|)
block|{
comment|/* The condition above used to be "archive_format != V7_FORMAT". 	     GNU tar was not writing directory blocks at all.  Daniel Trinkle 	     writes: ``All old versions of tar I have ever seen have 	     correctly archived an empty directory.  The really old ones I 	     checked included HP-UX 7 and Mt. Xinu More/BSD.  There may be 	     some subtle reason for the exclusion that I don't know, but the 	     current behavior is broken.''  I do not know those subtle 	     reasons either, so until these are reported (anew?), just allow 	     directory blocks to be written even with old archives.  */
name|current_stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* force 0 size on dir */
comment|/* FIXME: If people could really read standard archives, this 	     should be:  	     header 	       = start_header (standard_option ? p : namebuf,&current_stat);  	     but since they'd interpret DIRTYPE blocks as regular 	     files, we'd better put the / on the name.  */
name|header
operator|=
name|start_header
argument_list|(
name|namebuf
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental_option
condition|)
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|GNUTYPE_DUMPDIR
expr_stmt|;
else|else
comment|/* if (standard_option) */
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|DIRTYPE
expr_stmt|;
comment|/* If we're gnudumping, we aren't done yet so don't close it.  */
if|if
condition|(
operator|!
name|incremental_option
condition|)
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* done with directory header */
block|}
if|if
condition|(
name|incremental_option
operator|&&
name|gnu_list_name
operator|->
name|dir_contents
condition|)
block|{
name|off_t
name|sizeleft
decl_stmt|;
name|off_t
name|totsize
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|union
name|block
modifier|*
name|start
decl_stmt|;
name|ssize_t
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|p_buffer
decl_stmt|;
name|buffer
operator|=
name|gnu_list_name
operator|->
name|dir_contents
expr_stmt|;
comment|/* FOO */
name|totsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p_buffer
operator|=
name|buffer
init|;
name|p_buffer
operator|&&
operator|*
name|p_buffer
condition|;
control|)
block|{
name|size_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|p_buffer
argument_list|)
operator|+
literal|1
expr_stmt|;
name|totsize
operator|+=
name|tmp
expr_stmt|;
name|p_buffer
operator|+=
name|tmp
expr_stmt|;
block|}
name|totsize
operator|++
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|totsize
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|p_buffer
operator|=
name|buffer
expr_stmt|;
name|sizeleft
operator|=
name|totsize
expr_stmt|;
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|save_totsize
operator|=
name|totsize
expr_stmt|;
block|}
name|start
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|available_space_after
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeleft
operator|<
name|bufsize
condition|)
block|{
name|bufsize
operator|=
name|sizeleft
expr_stmt|;
name|count
operator|=
name|bufsize
operator|%
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|memset
argument_list|(
name|start
operator|->
name|buffer
operator|+
name|sizeleft
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|start
operator|->
name|buffer
argument_list|,
name|p_buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|sizeleft
operator|-=
name|bufsize
expr_stmt|;
name|p_buffer
operator|+=
name|bufsize
expr_stmt|;
name|set_next_block_after
argument_list|(
name|start
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|finish_dir
goto|;
block|}
comment|/* See if we are about to recurse into a directory, and avoid doing 	 so if the user wants that we do not descend into directories.  */
if|if
condition|(
operator|!
name|recursion_option
condition|)
goto|goto
name|finish_dir
goto|;
comment|/* See if we are crossing from one file system to another, and 	 avoid doing so if the user only wants to dump one file system.  */
if|if
condition|(
name|one_file_system_option
operator|&&
operator|!
name|top_level
operator|&&
name|parent_device
operator|!=
name|current_stat
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|verbose_option
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: file is on a different filesystem; not dumped"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|finish_dir
goto|;
block|}
comment|/* Now output all the files in the directory.  */
comment|/* FIXME: Should speed this up by cd-ing into the dir.  */
for|for
control|(
name|entry
operator|=
name|directory
init|;
operator|(
name|entrylen
operator|=
name|strlen
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|entry
operator|+=
name|entrylen
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|buflen
operator|<=
name|len
operator|+
name|entrylen
condition|)
block|{
name|buflen
operator|=
name|len
operator|+
name|entrylen
expr_stmt|;
name|namebuf
operator|=
name|xrealloc
argument_list|(
name|namebuf
argument_list|,
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|namebuf
operator|+
name|len
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|excluded_name
argument_list|(
name|namebuf
argument_list|)
condition|)
name|dump_file
argument_list|(
name|namebuf
argument_list|,
literal|0
argument_list|,
name|our_device
argument_list|)
expr_stmt|;
block|}
name|finish_dir
label|:
name|free
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|atime_preserve_option
condition|)
name|utime
argument_list|(
name|p
argument_list|,
operator|&
name|restore_times
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|is_avoided_name
argument_list|(
name|p
argument_list|)
condition|)
return|return;
else|else
block|{
comment|/* Check for multiple links.  	 We maintain a table of all such files that we've written so 	 far.  Any time we see another, we check the table and avoid 	 dumping the data again if we've done it once already.  */
if|if
condition|(
literal|1
operator|<
name|current_stat
operator|.
name|st_nlink
condition|)
block|{
specifier|static
name|Hash_table
modifier|*
name|link_table
decl_stmt|;
name|struct
name|link
modifier|*
name|lp
init|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|link
argument_list|,
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|link
modifier|*
name|dup
decl_stmt|;
name|lp
operator|->
name|ino
operator|=
name|current_stat
operator|.
name|st_ino
expr_stmt|;
name|lp
operator|->
name|dev
operator|=
name|current_stat
operator|.
name|st_dev
expr_stmt|;
name|strcpy
argument_list|(
name|lp
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|link_table
operator|||
operator|(
name|link_table
operator|=
name|hash_initialize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hash_link
argument_list|,
name|compare_links
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|dup
operator|=
name|hash_insert
argument_list|(
name|link_table
argument_list|,
name|lp
argument_list|)
operator|)
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
if|if
condition|(
name|dup
operator|!=
name|lp
condition|)
block|{
comment|/* We found a link.  */
name|char
specifier|const
modifier|*
name|link_name
init|=
name|relativize
argument_list|(
name|dup
operator|->
name|name
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NAME_FIELD_SIZE
operator|<=
name|strlen
argument_list|(
name|link_name
argument_list|)
condition|)
name|write_long
argument_list|(
name|link_name
argument_list|,
name|GNUTYPE_LONGLINK
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|current_link_name
argument_list|,
name|link_name
argument_list|)
expr_stmt|;
name|current_stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|,
name|link_name
argument_list|,
name|NAME_FIELD_SIZE
argument_list|)
expr_stmt|;
comment|/* Force null termination.  */
name|header
operator|->
name|header
operator|.
name|linkname
index|[
name|NAME_FIELD_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|LNKTYPE
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* FIXME: Maybe remove from table after all links found?  */
if|if
condition|(
name|remove_files_option
operator|&&
name|unlink
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|unlink_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* We dumped it.  */
return|return;
block|}
block|}
comment|/* This is not a link to a previously dumped file, so dump it.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISCTG
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|int
name|f
decl_stmt|;
comment|/* file descriptor */
name|size_t
name|bufsize
decl_stmt|;
name|ssize_t
name|count
decl_stmt|;
name|off_t
name|sizeleft
decl_stmt|;
name|union
name|block
modifier|*
name|start
decl_stmt|;
name|int
name|header_moved
decl_stmt|;
name|char
name|isextended
init|=
literal|0
decl_stmt|;
name|int
name|sparses
init|=
literal|0
decl_stmt|;
name|header_moved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sparse_option
condition|)
block|{
comment|/* Check the size of the file against the number of blocks 		 allocated for it, counting both data and indirect blocks. 		 If there is a smaller number of blocks that would be 		 necessary to accommodate a file of this size, this is safe 		 to say that we have a sparse file: at least one of those 		 blocks in the file is just a useless hole.  For sparse 		 files not having more hole blocks than indirect blocks, the 		 sparseness will go undetected.  */
comment|/* Bruno Haible sent me these statistics for Linux.  It seems 		 that some filesystems count indirect blocks in st_blocks, 		 while others do not seem to:  		 minix-fs   tar: size=7205, st_blocks=18 and ST_NBLOCKS=18 		 extfs      tar: size=7205, st_blocks=18 and ST_NBLOCKS=18 		 ext2fs     tar: size=7205, st_blocks=16 and ST_NBLOCKS=16 		 msdos-fs   tar: size=7205, st_blocks=16 and ST_NBLOCKS=16  		 Dick Streefland reports the previous numbers as misleading, 		 because ext2fs use 12 direct blocks, while minix-fs uses only 		 6 direct blocks.  Dick gets:  		 ext2	size=20480	ls listed blocks=21 		 minix	size=20480	ls listed blocks=21 		 msdos	size=20480	ls listed blocks=20  		 It seems that indirect blocks *are* included in st_blocks. 		 The minix filesystem does not account for phantom blocks in 		 st_blocks, so `du' and `ls -s' give wrong results.  So, the 		 --sparse option would not work on a minix filesystem.  */
if|if
condition|(
name|ST_NBLOCKS
argument_list|(
name|current_stat
argument_list|)
operator|<
operator|(
name|current_stat
operator|.
name|st_size
operator|/
name|ST_NBLOCKSIZE
operator|+
operator|(
name|current_stat
operator|.
name|st_size
operator|%
name|ST_NBLOCKSIZE
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|int
name|counter
decl_stmt|;
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|GNUTYPE_SPARSE
expr_stmt|;
name|header_moved
operator|=
literal|1
expr_stmt|;
comment|/* Call the routine that figures out the layout of the 		     sparse file in question.  SPARSES is the index of the 		     first unused element of the "sparsearray," i.e., 		     the number of elements it needed to describe the file.  */
name|sparses
operator|=
name|deal_with_sparse
argument_list|(
name|p
argument_list|,
name|header
argument_list|)
expr_stmt|;
comment|/* See if we'll need an extended header later.  */
if|if
condition|(
name|SPARSES_IN_OLDGNU_HEADER
operator|<
name|sparses
condition|)
name|header
operator|->
name|oldgnu_header
operator|.
name|isextended
operator|=
literal|1
expr_stmt|;
comment|/* We store the "real" file size so we can show that in 		     case someone wants to list the archive, i.e., tar tvf<file>.  It might be kind of disconcerting if the 		     shrunken file size was the one that showed up.  */
name|OFF_TO_CHARS
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|header
operator|->
name|oldgnu_header
operator|.
name|realsize
argument_list|)
expr_stmt|;
comment|/* This will be the new "size" of the file, i.e., the size 		     of the file minus the blocks of holes that we're 		     skipping over.  */
name|current_stat
operator|.
name|st_size
operator|=
name|find_new_file_size
argument_list|(
name|sparses
argument_list|)
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|sparses
operator|&&
name|counter
operator|<
name|SPARSES_IN_OLDGNU_HEADER
condition|;
name|counter
operator|++
control|)
block|{
name|OFF_TO_CHARS
argument_list|(
name|sparsearray
index|[
name|counter
index|]
operator|.
name|offset
argument_list|,
name|header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|SIZE_TO_CHARS
argument_list|(
name|sparsearray
index|[
name|counter
index|]
operator|.
name|numbytes
argument_list|,
name|header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sizeleft
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
comment|/* Don't bother opening empty, world readable files.  Also do not open 	     files when archive is meant for /dev/null.  */
if|if
condition|(
name|dev_null_output
operator|||
operator|(
name|sizeleft
operator|==
literal|0
operator|&&
name|MODE_R
operator|==
operator|(
name|MODE_R
operator|&
name|current_stat
operator|.
name|st_mode
operator|)
operator|)
condition|)
name|f
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|f
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|top_level
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: File removed before we read it"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|ignore_failed_read_option
condition|?
name|open_warn
else|:
name|open_error
operator|)
operator|(
name|p
operator|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If the file is sparse, we've already taken care of this.  */
if|if
condition|(
operator|!
name|header_moved
condition|)
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
comment|/* Mark contiguous files, if we support them.  */
if|if
condition|(
name|archive_format
operator|!=
name|V7_FORMAT
operator|&&
name|S_ISCTG
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|CONTTYPE
expr_stmt|;
name|isextended
operator|=
name|header
operator|->
name|oldgnu_header
operator|.
name|isextended
expr_stmt|;
name|save_typeflag
operator|=
name|header
operator|->
name|header
operator|.
name|typeflag
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|isextended
condition|)
block|{
name|int
name|sparses_emitted
init|=
name|SPARSES_IN_OLDGNU_HEADER
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|exhdr
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|exhdr
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|SPARSES_IN_SPARSE_HEADER
operator|&&
name|sparses_emitted
operator|+
name|i
operator|<
name|sparses
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|SIZE_TO_CHARS
argument_list|(
name|sparsearray
index|[
name|sparses_emitted
operator|+
name|i
index|]
operator|.
name|numbytes
argument_list|,
name|exhdr
operator|->
name|sparse_header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
name|OFF_TO_CHARS
argument_list|(
name|sparsearray
index|[
name|sparses_emitted
operator|+
name|i
index|]
operator|.
name|offset
argument_list|,
name|exhdr
operator|->
name|sparse_header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
name|sparses_emitted
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|sparses
operator|==
name|sparses_emitted
condition|)
break|break;
name|exhdr
operator|->
name|sparse_header
operator|.
name|isextended
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_typeflag
operator|==
name|GNUTYPE_SPARSE
condition|)
block|{
if|if
condition|(
name|f
operator|<
literal|0
operator|||
name|finish_sparse_file
argument_list|(
name|f
argument_list|,
operator|&
name|sizeleft
argument_list|,
name|current_stat
operator|.
name|st_size
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|padit
goto|;
block|}
else|else
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|save_totsize
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
block|}
name|start
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|available_space_after
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizeleft
operator|<
name|bufsize
condition|)
block|{
comment|/* Last read -- zero out area beyond.  */
name|bufsize
operator|=
name|sizeleft
expr_stmt|;
name|count
operator|=
name|bufsize
operator|%
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|memset
argument_list|(
name|start
operator|->
name|buffer
operator|+
name|sizeleft
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
name|count
operator|=
name|bufsize
expr_stmt|;
else|else
name|count
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|start
operator|->
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
operator|(
name|ignore_failed_read_option
condition|?
name|read_warn_details
else|:
name|read_error_details
operator|)
operator|(
name|p
operator|,
name|current_stat
operator|.
name|st_size
operator|-
name|sizeleft
operator|,
name|bufsize
operator|)
expr_stmt|;
goto|goto
name|padit
goto|;
block|}
name|sizeleft
operator|-=
name|bufsize
expr_stmt|;
comment|/* This is nonportable (the type of set_next_block_after's arg).  */
name|set_next_block_after
argument_list|(
name|start
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|bufsize
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|memset
argument_list|(
name|start
operator|->
name|buffer
operator|+
name|count
argument_list|,
literal|0
argument_list|,
name|bufsize
operator|-
name|count
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: File shrank by %s bytes; padding with zeros"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|sizeleft
argument_list|,
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_failed_read_option
condition|)
name|exit_status
operator|=
name|TAREXIT_FAILURE
expr_stmt|;
goto|goto
name|padit
goto|;
comment|/* short read */
block|}
block|}
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|struct
name|stat
name|final_stat
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|final_stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|stat_warn
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|stat_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final_stat
operator|.
name|st_ctime
operator|!=
name|original_ctime
condition|)
block|{
name|char
specifier|const
modifier|*
name|qp
init|=
name|quotearg_colon
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: file changed as we read it"
argument_list|)
operator|,
name|qp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_failed_read_option
condition|)
name|exit_status
operator|=
name|TAREXIT_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|close_warn
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|close_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atime_preserve_option
condition|)
name|utime
argument_list|(
name|p
argument_list|,
operator|&
name|restore_times
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remove_files_option
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|unlink_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* File shrunk or gave error, pad out tape to match the size we 	     specified in the header.  */
name|padit
label|:
while|while
condition|(
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|save_sizeleft
operator|=
name|sizeleft
expr_stmt|;
name|start
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|start
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|sizeleft
operator|-=
name|BLOCKSIZE
expr_stmt|;
block|}
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|atime_preserve_option
condition|)
name|utime
argument_list|(
name|p
argument_list|,
operator|&
name|restore_times
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_READLINK
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size_t
name|linklen
init|=
name|current_stat
operator|.
name|st_size
decl_stmt|;
if|if
condition|(
name|linklen
operator|!=
name|current_stat
operator|.
name|st_size
operator|||
name|linklen
operator|+
literal|1
operator|==
literal|0
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|linklen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|readlink
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|,
name|linklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|readlink_warn
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|readlink_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|NAME_FIELD_SIZE
condition|)
name|write_long
argument_list|(
name|buffer
argument_list|,
name|GNUTYPE_LONGLINK
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|current_link_name
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|current_stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* force 0 size on symlink */
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|->
name|header
operator|.
name|linkname
argument_list|,
name|buffer
argument_list|,
name|NAME_FIELD_SIZE
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|linkname
index|[
name|NAME_FIELD_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|SYMTYPE
expr_stmt|;
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* nothing more to do to it */
if|if
condition|(
name|remove_files_option
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|unlink_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|type
operator|=
name|CHRTYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|type
operator|=
name|BLKTYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
name|type
operator|=
name|FIFOTYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: socket ignored"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|S_ISDOOR
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: door ignored"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
goto|goto
name|unknown
goto|;
block|}
if|if
condition|(
name|archive_format
operator|==
name|V7_FORMAT
condition|)
goto|goto
name|unknown
goto|;
name|current_stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* force 0 size */
name|header
operator|=
name|start_header
argument_list|(
name|p
argument_list|,
operator|&
name|current_stat
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|typeflag
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|FIFOTYPE
condition|)
block|{
name|MAJOR_TO_CHARS
argument_list|(
name|major
argument_list|(
name|current_stat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|header
operator|->
name|header
operator|.
name|devmajor
argument_list|)
expr_stmt|;
name|MINOR_TO_CHARS
argument_list|(
name|minor
argument_list|(
name|current_stat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|header
operator|->
name|header
operator|.
name|devminor
argument_list|)
expr_stmt|;
block|}
name|finish_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_files_option
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|unlink_error
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return;
name|unknown
label|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Unknown file type; file ignored"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_failed_read_option
condition|)
name|exit_status
operator|=
name|TAREXIT_FAILURE
expr_stmt|;
block|}
end_function

end_unit

