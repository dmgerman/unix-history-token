begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote connection server.     Copyright (C) 1994, 1995, 1996, 1997, 1999, 2000, 2001 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Copyright (C) 1983 Regents of the University of California.    All rights reserved.     Redistribution and use in source and binary forms are permitted provided    that the above copyright notice and this paragraph are duplicated in all    such forms and that any documentation, advertising materials, and other    materials related to such distribution and use acknowledge that the    software was developed by the University of California, Berkeley.  The    name of the University may not be used to endorse or promote products    derived from this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED    WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<print-copyr.h>
end_include

begin_include
include|#
directive|include
file|<localedir.h>
end_include

begin_include
include|#
directive|include
file|<safe-read.h>
end_include

begin_include
include|#
directive|include
file|<full-write.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef

begin_define
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_SUCCESS
end_ifndef

begin_define
define|#
directive|define
name|EXIT_SUCCESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum size of a string from the requesting program.  */
end_comment

begin_define
define|#
directive|define
name|STRING_SIZE
value|64
end_define

begin_comment
comment|/* Name of executing program.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of the tape device, or negative if none open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tape
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer containing transferred data, and its allocated size.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|record_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|allocated_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for constructing the reply.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reply_buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging tools.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|debug_file
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|File
parameter_list|)
define|\
value|if (debug_file) fprintf(debug_file, File)
end_define

begin_define
define|#
directive|define
name|DEBUG1
parameter_list|(
name|File
parameter_list|,
name|Arg
parameter_list|)
define|\
value|if (debug_file) fprintf(debug_file, File, Arg)
end_define

begin_define
define|#
directive|define
name|DEBUG2
parameter_list|(
name|File
parameter_list|,
name|Arg1
parameter_list|,
name|Arg2
parameter_list|)
define|\
value|if (debug_file) fprintf(debug_file, File, Arg1, Arg2)
end_define

begin_comment
comment|/* Return an error string, given an error number.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_STRERROR
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|strerror
end_ifndef

begin_function_decl
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|char
modifier|*
name|private_strerror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
if|if
condition|(
name|errnum
operator|>
literal|0
operator|&&
name|errnum
operator|<=
name|sys_nerr
condition|)
return|return
name|_
argument_list|(
name|sys_errlist
index|[
name|errnum
index|]
argument_list|)
return|;
return|return
name|_
argument_list|(
literal|"Unknown system error"
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|strerror
value|private_strerror
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|report_error_message
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|DEBUG1
argument_list|(
literal|"rmtd: E 0 (%s)\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"E0\n%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_numbered_error
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|DEBUG2
argument_list|(
literal|"rmtd: E %d (%s)\n"
argument_list|,
name|num
argument_list|,
name|strerror
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"E%d\n%s\n"
argument_list|,
name|num
argument_list|,
name|strerror
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|counter
decl_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|STRING_SIZE
condition|;
name|counter
operator|++
control|)
block|{
if|if
condition|(
name|safe_read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|string
operator|+
name|counter
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
index|[
name|counter
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|string
index|[
name|counter
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prepare_record_buffer
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|allocated_size
condition|)
return|return;
if|if
condition|(
name|record_buffer
condition|)
name|free
argument_list|(
name|record_buffer
argument_list|)
expr_stmt|;
name|record_buffer
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|record_buffer
condition|)
block|{
name|DEBUG
argument_list|(
name|_
argument_list|(
literal|"rmtd: Cannot allocate buffer space\n"
argument_list|)
argument_list|)
expr_stmt|;
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Cannot allocate buffer space"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* exit status used to be 4 */
block|}
name|allocated_size
operator|=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_RCVBUF
while|while
condition|(
name|size
operator|>
literal|1024
operator|&&
operator|(
name|setsockopt
argument_list|(
name|STDIN_FILENO
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
name|size
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|size
operator|-=
literal|1024
expr_stmt|;
else|#
directive|else
comment|/* FIXME: I do not see any purpose to the following line...  Sigh! */
name|size
operator|=
literal|1
operator|+
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|%
literal|1024
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Decode OFLAG_STRING, which represents the 2nd argument to `open'.    OFLAG_STRING should contain an optional integer, followed by an optional    symbolic representation of an open flag using only '|' to separate its    components (e.g. "O_WRONLY|O_CREAT|O_TRUNC").  Prefer the symbolic    representation if available, falling back on the numeric    representation, or to zero if both formats are absent.     This function should be the inverse of encode_oflag.  The numeric    representation is not portable from one host to another, but it is    for backward compatibility with old-fashioned clients that do not    emit symbolic open flags.  */
end_comment

begin_function
specifier|static
name|int
name|decode_oflag
parameter_list|(
name|char
specifier|const
modifier|*
name|oflag_string
parameter_list|)
block|{
name|char
modifier|*
name|oflag_num_end
decl_stmt|;
name|int
name|numeric_oflag
init|=
name|strtol
argument_list|(
name|oflag_string
argument_list|,
operator|&
name|oflag_num_end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|symbolic_oflag
init|=
literal|0
decl_stmt|;
name|oflag_string
operator|=
name|oflag_num_end
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oflag_string
argument_list|)
condition|)
name|oflag_string
operator|++
expr_stmt|;
do|do
block|{
struct|struct
name|name_value_pair
block|{
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|name_value_pair
specifier|const
name|table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|O_APPEND
block|{
literal|"APPEND"
block|,
name|O_APPEND
block|}
block|,
endif|#
directive|endif
block|{
literal|"CREAT"
block|,
name|O_CREAT
block|}
block|,
ifdef|#
directive|ifdef
name|O_DSYNC
block|{
literal|"DSYNC"
block|,
name|O_DSYNC
block|}
block|,
endif|#
directive|endif
block|{
literal|"EXCL"
block|,
name|O_EXCL
block|}
block|,
ifdef|#
directive|ifdef
name|O_LARGEFILE
block|{
literal|"LARGEFILE"
block|,
name|O_LARGEFILE
block|}
block|,
comment|/* LFS extension for opening large files */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NOCTTY
block|{
literal|"NOCTTY"
block|,
name|O_NOCTTY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NONBLOCK
block|{
literal|"NONBLOCK"
block|,
name|O_NONBLOCK
block|}
block|,
endif|#
directive|endif
block|{
literal|"RDONLY"
block|,
name|O_RDONLY
block|}
block|,
block|{
literal|"RDWR"
block|,
name|O_RDWR
block|}
block|,
ifdef|#
directive|ifdef
name|O_RSYNC
block|{
literal|"RSYNC"
block|,
name|O_RSYNC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SYNC
block|{
literal|"SYNC"
block|,
name|O_SYNC
block|}
block|,
endif|#
directive|endif
block|{
literal|"TRUNC"
block|,
name|O_TRUNC
block|}
block|,
block|{
literal|"WRONLY"
block|,
name|O_WRONLY
block|}
block|}
decl_stmt|;
name|struct
name|name_value_pair
specifier|const
modifier|*
name|t
decl_stmt|;
name|size_t
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|oflag_string
operator|++
operator|!=
literal|'O'
operator|||
operator|*
name|oflag_string
operator|++
operator|!=
literal|'_'
condition|)
return|return
name|numeric_oflag
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
operator|(
name|strncmp
argument_list|(
name|oflag_string
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|s
operator|=
name|strlen
argument_list|(
name|t
operator|->
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|oflag_string
index|[
name|s
index|]
operator|&&
name|strchr
argument_list|(
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"
argument_list|,
name|oflag_string
index|[
name|s
index|]
argument_list|)
operator|)
operator|)
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|t
operator|==
name|table
operator|+
sizeof|sizeof
name|table
operator|/
sizeof|sizeof
expr|*
name|table
operator|-
literal|1
condition|)
return|return
name|numeric_oflag
return|;
name|symbolic_oflag
operator||=
name|t
operator|->
name|value
expr_stmt|;
name|oflag_string
operator|+=
name|s
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|oflag_string
operator|++
operator|==
literal|'|'
condition|)
do|;
return|return
name|symbolic_oflag
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|long_opts
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
name|EXIT_SUCCESS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]\n\ Manipulate a tape drive, accepting commands from a remote process.\n\ \n\   --version  Output version info.\n\   --help  Output this help.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\nReport bugs to<bug-tar@gnu.org>.\n"
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|command
decl_stmt|;
name|ssize_t
name|status
decl_stmt|;
comment|/* FIXME: Localization is meaningless, unless --help and --version are      locally used.  Localization would be best accomplished by the calling      tar, on messages found within error packets.  */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_opts
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
default|default:
name|usage
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
block|{
name|printf
argument_list|(
literal|"rmt (GNU %s) %s\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|print_copyright
argument_list|(
literal|"2001 Free Software Foundation, Inc."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ This program comes with NO WARRANTY, to the extent permitted by law.\n\ You may redistribute it under the terms of the GNU General Public License;\n\ see the file named COPYING for details."
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
case|case
operator|-
literal|1
case|:
break|break;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|debug_file
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_file
operator|==
literal|0
condition|)
block|{
name|report_numbered_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|debug_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|top
label|:
name|errno
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|safe_read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|command
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|EXIT_SUCCESS
return|;
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* FIXME: Maybe 'H' and 'V' for --help and --version output?  */
case|case
literal|'O'
case|:
block|{
name|char
name|device_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|char
name|oflag_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|get_string
argument_list|(
name|device_string
argument_list|)
expr_stmt|;
name|get_string
argument_list|(
name|oflag_string
argument_list|)
expr_stmt|;
name|DEBUG2
argument_list|(
literal|"rmtd: O %s %s\n"
argument_list|,
name|device_string
argument_list|,
name|oflag_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|tape
argument_list|)
expr_stmt|;
name|tape
operator|=
name|open
argument_list|(
name|device_string
argument_list|,
name|decode_oflag
argument_list|(
name|oflag_string
argument_list|)
argument_list|,
name|MODE_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
goto|goto
name|respond
goto|;
block|}
case|case
literal|'C'
case|:
block|{
name|char
name|device_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|get_string
argument_list|(
name|device_string
argument_list|)
expr_stmt|;
comment|/* discard */
name|DEBUG
argument_list|(
literal|"rmtd: C\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|tape
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
name|tape
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|respond
goto|;
block|}
case|case
literal|'L'
case|:
block|{
name|char
name|count_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|char
name|position_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|off_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|negative
decl_stmt|;
name|int
name|whence
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|get_string
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|get_string
argument_list|(
name|position_string
argument_list|)
expr_stmt|;
name|DEBUG2
argument_list|(
literal|"rmtd: L %s %s\n"
argument_list|,
name|count_string
argument_list|,
name|position_string
argument_list|)
expr_stmt|;
comment|/* Parse count_string, taking care to check for overflow. 	   We can't use standard functions, 	   since off_t might be longer than long.  */
for|for
control|(
name|p
operator|=
name|count_string
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
continue|continue;
name|negative
operator|=
operator|*
name|p
operator|==
literal|'-'
expr_stmt|;
name|p
operator|+=
name|negative
operator|||
operator|*
name|p
operator|==
literal|'+'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|digit
init|=
operator|*
name|p
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|9
operator|<
operator|(
name|unsigned
operator|)
name|digit
condition|)
break|break;
else|else
block|{
name|off_t
name|c10
init|=
literal|10
operator|*
name|count
decl_stmt|;
name|off_t
name|nc
init|=
name|negative
condition|?
name|c10
operator|-
name|digit
else|:
name|c10
operator|+
name|digit
decl_stmt|;
if|if
condition|(
name|c10
operator|/
literal|10
operator|!=
name|count
operator|||
operator|(
name|negative
condition|?
name|c10
operator|<
name|nc
else|:
name|nc
operator|<
name|c10
operator|)
condition|)
block|{
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Seek offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|nc
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|atoi
argument_list|(
name|position_string
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|whence
operator|=
name|SEEK_SET
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|whence
operator|=
name|SEEK_CUR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|whence
operator|=
name|SEEK_END
expr_stmt|;
break|break;
default|default:
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Seek direction out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|lseek
argument_list|(
name|tape
argument_list|,
name|count
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
comment|/* Convert count back to string for reply. 	   We can't use sprintf, since off_t might be longer than long.  */
name|p
operator|=
name|count_string
operator|+
sizeof|sizeof
name|count_string
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|count
operator|%
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|count
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
name|DEBUG1
argument_list|(
literal|"rmtd: A %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"A%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
case|case
literal|'W'
case|:
block|{
name|char
name|count_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|counter
decl_stmt|;
name|get_string
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|size
operator|=
name|atol
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"rmtd: W %s\n"
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
name|prepare_record_buffer
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|size
condition|;
name|counter
operator|+=
name|status
control|)
block|{
name|status
operator|=
name|safe_read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|record_buffer
index|[
name|counter
index|]
argument_list|,
name|size
operator|-
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
name|_
argument_list|(
literal|"rmtd: Premature eof\n"
argument_list|)
argument_list|)
expr_stmt|;
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Premature end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* exit status used to be 2 */
block|}
block|}
name|status
operator|=
name|full_write
argument_list|(
name|tape
argument_list|,
name|record_buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
goto|goto
name|respond
goto|;
block|}
case|case
literal|'R'
case|:
block|{
name|char
name|count_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|get_string
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|DEBUG1
argument_list|(
literal|"rmtd: R %s\n"
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
name|size
operator|=
name|atol
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|prepare_record_buffer
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|status
operator|=
name|safe_read
argument_list|(
name|tape
argument_list|,
name|record_buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"A%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|status
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|record_buffer
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
case|case
literal|'I'
case|:
block|{
name|char
name|operation_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|char
name|count_string
index|[
name|STRING_SIZE
index|]
decl_stmt|;
name|get_string
argument_list|(
name|operation_string
argument_list|)
expr_stmt|;
name|get_string
argument_list|(
name|count_string
argument_list|)
expr_stmt|;
name|DEBUG2
argument_list|(
literal|"rmtd: I %s %s\n"
argument_list|,
name|operation_string
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MTIOCTOP
block|{
name|struct
name|mtop
name|mtop
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|off_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|negative
decl_stmt|;
comment|/* Parse count_string, taking care to check for overflow. 	     We can't use standard functions, 	     since off_t might be longer than long.  */
for|for
control|(
name|p
operator|=
name|count_string
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
continue|continue;
name|negative
operator|=
operator|*
name|p
operator|==
literal|'-'
expr_stmt|;
name|p
operator|+=
name|negative
operator|||
operator|*
name|p
operator|==
literal|'+'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|digit
init|=
operator|*
name|p
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|9
operator|<
operator|(
name|unsigned
operator|)
name|digit
condition|)
break|break;
else|else
block|{
name|off_t
name|c10
init|=
literal|10
operator|*
name|count
decl_stmt|;
name|off_t
name|nc
init|=
name|negative
condition|?
name|c10
operator|-
name|digit
else|:
name|c10
operator|+
name|digit
decl_stmt|;
if|if
condition|(
name|c10
operator|/
literal|10
operator|!=
name|count
operator|||
operator|(
name|negative
condition|?
name|c10
operator|<
name|nc
else|:
name|nc
operator|<
name|c10
operator|)
condition|)
block|{
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Seek offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|nc
expr_stmt|;
block|}
block|}
name|mtop
operator|.
name|mt_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|mtop
operator|.
name|mt_count
operator|!=
name|count
condition|)
block|{
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Seek offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|mtop
operator|.
name|mt_op
operator|=
name|atoi
argument_list|(
name|operation_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tape
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mtop
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
block|}
endif|#
directive|endif
goto|goto
name|respond
goto|;
block|}
case|case
literal|'S'
case|:
comment|/* status */
block|{
name|DEBUG
argument_list|(
literal|"rmtd: S\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MTIOCGET
block|{
name|struct
name|mtget
name|operation
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tape
argument_list|,
name|MTIOCGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|ioerror
goto|;
name|status
operator|=
sizeof|sizeof
name|operation
expr_stmt|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"A%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|status
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|,
sizeof|sizeof
name|operation
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|top
goto|;
block|}
default|default:
name|DEBUG1
argument_list|(
name|_
argument_list|(
literal|"rmtd: Garbage command %c\n"
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|report_error_message
argument_list|(
name|N_
argument_list|(
literal|"Garbage command"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* exit status used to be 3 */
block|}
name|respond
label|:
name|DEBUG1
argument_list|(
literal|"rmtd: A %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|status
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|reply_buffer
argument_list|,
literal|"A%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|status
argument_list|)
expr_stmt|;
name|full_write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|reply_buffer
argument_list|,
name|strlen
argument_list|(
name|reply_buffer
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
name|ioerror
label|:
name|report_numbered_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
end_function

end_unit

