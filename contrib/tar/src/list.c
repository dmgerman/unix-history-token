begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List a tar archive, with support routines for reading a tar archive.     Copyright 1988, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000,    2001 Free Software Foundation, Inc.     Written by John Gilmore, on 1985-08-26.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Define to non-zero for forcing old ctime format instead of ISO format.  */
end_comment

begin_undef
undef|#
directive|undef
name|USE_OLD_CTIME
end_undef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_CODESET
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (b) : (a))
end_define

begin_decl_stmt
name|union
name|block
modifier|*
name|current_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to current archive header */
end_comment

begin_decl_stmt
name|struct
name|stat
name|current_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stat struct corresponding */
end_comment

begin_decl_stmt
name|enum
name|archive_format
name|current_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recognized format */
end_comment

begin_decl_stmt
name|union
name|block
modifier|*
name|recent_long_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recent long name header and contents */
end_comment

begin_decl_stmt
name|union
name|block
modifier|*
name|recent_long_link
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* likewise, for long link */
end_comment

begin_decl_stmt
name|size_t
name|recent_long_name_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks in recent_long_name */
end_comment

begin_decl_stmt
name|size_t
name|recent_long_link_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* likewise, for long link */
end_comment

begin_decl_stmt
specifier|static
name|uintmax_t
name|from_header
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
specifier|const
name|char
operator|*
operator|,
name|uintmax_t
operator|,
name|uintmax_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base 64 digits; see Internet RFC 2045 Table 1.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|base_64_digits
index|[
literal|64
index|]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of base-64 digit values indexed by unsigned chars.    The value is 64 for unsigned chars that are not base-64 digits.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|base64_map
index|[
name|UCHAR_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|base64_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|base64_map
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
name|base64_map
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|base64_map
index|[
operator|(
name|int
operator|)
name|base_64_digits
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main loop for reading an archive.  */
end_comment

begin_function
name|void
name|read_and
parameter_list|(
name|void
function_decl|(
modifier|*
name|do_something
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|enum
name|read_header
name|status
init|=
name|HEADER_STILL_UNREAD
decl_stmt|;
name|enum
name|read_header
name|prev_status
decl_stmt|;
name|base64_init
argument_list|()
expr_stmt|;
name|name_gather
argument_list|()
expr_stmt|;
name|open_archive
argument_list|(
name|ACCESS_READ
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|prev_status
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* check if the namelist got emptied during the course of reading */
comment|/* the tape, if so stop by setting status to EOF */
if|if
condition|(
name|namelist_freed
condition|)
name|status
operator|=
name|HEADER_END_OF_FILE
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|HEADER_SUCCESS
case|:
comment|/* Valid header.  We should decode next field (mode) first. 	     Ensure incoming names are null terminated.  */
if|if
condition|(
operator|!
name|name_match
argument_list|(
name|current_file_name
argument_list|)
operator|||
operator|(
name|newer_mtime_option
operator|!=
name|TYPE_MINIMUM
argument_list|(
name|time_t
argument_list|)
comment|/* FIXME: We get mtime now, and again later; this causes 		     duplicate diagnostics if header.mtime is bogus.  */
operator|&&
operator|(
operator|(
name|current_stat
operator|.
name|st_mtime
operator|=
name|TIME_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|header
operator|.
name|mtime
argument_list|)
operator|)
operator|<
name|newer_mtime_option
operator|)
operator|)
operator|||
name|excluded_name
argument_list|(
name|current_file_name
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
case|case
name|GNUTYPE_VOLHDR
case|:
case|case
name|GNUTYPE_MULTIVOL
case|:
case|case
name|GNUTYPE_NAMES
case|:
break|break;
case|case
name|DIRTYPE
case|:
if|if
condition|(
name|show_omitted_dirs_option
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Omitting"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|current_file_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|skip_member
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
call|(
modifier|*
name|do_something
call|)
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|HEADER_ZERO_BLOCK
case|:
if|if
condition|(
name|block_number_option
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"block %s: ** Block of NULs **\n"
argument_list|)
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|current_block_ordinal
argument_list|()
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
name|status
operator|=
name|prev_status
expr_stmt|;
if|if
condition|(
name|ignore_zeros_option
condition|)
continue|continue;
break|break;
case|case
name|HEADER_END_OF_FILE
case|:
if|if
condition|(
name|block_number_option
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"block %s: ** End of File **\n"
argument_list|)
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|current_block_ordinal
argument_list|()
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HEADER_FAILURE
case|:
comment|/* If the previous header was good, tell them that we are 	     skipping bad ones.  */
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prev_status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"This does not look like a tar archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_ZERO_BLOCK
case|:
case|case
name|HEADER_SUCCESS
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Skipping to next header"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEADER_END_OF_FILE
case|:
case|case
name|HEADER_FAILURE
case|:
comment|/* We are in the middle of a cascade of errors.  */
break|break;
block|}
continue|continue;
block|}
break|break;
block|}
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
comment|/* print names not found */
block|}
end_function

begin_comment
comment|/* Print a header block, based on tar options.  */
end_comment

begin_function
name|void
name|list_archive
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Print the header block.  */
if|if
condition|(
name|verbose_option
condition|)
block|{
if|if
condition|(
name|verbose_option
operator|>
literal|1
condition|)
name|decode_header
argument_list|(
name|current_header
argument_list|,
operator|&
name|current_stat
argument_list|,
operator|&
name|current_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|incremental_option
operator|&&
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_DUMPDIR
condition|)
block|{
name|off_t
name|size
decl_stmt|;
name|size_t
name|written
decl_stmt|,
name|check
decl_stmt|;
name|union
name|block
modifier|*
name|data_block
decl_stmt|;
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|save_totsize
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
block|}
for|for
control|(
name|size
operator|=
name|current_stat
operator|.
name|st_size
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|written
control|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
name|save_sizeleft
operator|=
name|size
expr_stmt|;
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: What happens, then?  */
block|}
name|written
operator|=
name|available_space_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|check
operator|=
name|fwrite
argument_list|(
name|data_block
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|written
argument_list|,
name|stdlis
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
name|data_block
operator|->
name|buffer
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|written
condition|)
block|{
name|write_error_details
argument_list|(
name|current_file_name
argument_list|,
name|check
argument_list|,
name|written
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
name|size
operator|-
name|written
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdlis
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdlis
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a block that's supposed to be a header block.  Return its    address in "current_header", and if it is good, the file's size in    current_stat.st_size.     Return 1 for success, 0 if the checksum is bad, EOF on eof, 2 for a    block full of zeros (EOF marker).     If RAW_EXTENDED_HEADERS is nonzero, do not automagically fold the    GNU long name and link headers into later headers.     You must always set_next_block_after(current_header) to skip past    the header which this routine reads.  */
end_comment

begin_comment
comment|/* The standard BSD tar sources create the checksum by adding up the    bytes in the header as type char.  I think the type char was unsigned    on the PDP-11, but it's signed on the Next and Sun.  It looks like the    sources to BSD tar were never changed to compute the checksum    correctly, so both the Sun and Next add the bytes of the header as    signed chars.  This doesn't cause a problem until you get a file with    a name containing characters with the high bit set.  So read_header    computes two checksums -- signed and unsigned.  */
end_comment

begin_function
name|enum
name|read_header
name|read_header
parameter_list|(
name|bool
name|raw_extended_headers
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|unsigned_sum
decl_stmt|;
comment|/* the POSIX one :-) */
name|int
name|signed_sum
decl_stmt|;
comment|/* the Sun one :-( */
name|int
name|recorded_sum
decl_stmt|;
name|uintmax_t
name|parsed_sum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|union
name|block
modifier|*
name|header
decl_stmt|;
name|union
name|block
modifier|*
name|header_copy
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|union
name|block
modifier|*
name|data_block
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|written
decl_stmt|;
name|union
name|block
modifier|*
name|next_long_name
init|=
literal|0
decl_stmt|;
name|union
name|block
modifier|*
name|next_long_link
init|=
literal|0
decl_stmt|;
name|size_t
name|next_long_name_blocks
decl_stmt|;
name|size_t
name|next_long_link_blocks
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|header
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
name|current_header
operator|=
name|header
expr_stmt|;
if|if
condition|(
operator|!
name|header
condition|)
return|return
name|HEADER_END_OF_FILE
return|;
name|unsigned_sum
operator|=
literal|0
expr_stmt|;
name|signed_sum
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
expr|*
name|header
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
block|{
name|unsigned_sum
operator|+=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
expr_stmt|;
name|signed_sum
operator|+=
call|(
name|signed
name|char
call|)
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_sum
operator|==
literal|0
condition|)
return|return
name|HEADER_ZERO_BLOCK
return|;
comment|/* Adjust checksum to count the "chksum" field as blanks.  */
for|for
control|(
name|i
operator|=
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
block|{
name|unsigned_sum
operator|-=
operator|(
name|unsigned
name|char
operator|)
name|header
operator|->
name|header
operator|.
name|chksum
index|[
name|i
index|]
expr_stmt|;
name|signed_sum
operator|-=
call|(
name|signed
name|char
call|)
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|unsigned_sum
operator|+=
literal|' '
operator|*
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
expr_stmt|;
name|signed_sum
operator|+=
literal|' '
operator|*
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
expr_stmt|;
name|parsed_sum
operator|=
name|from_header
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|,
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|,
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsed_sum
operator|==
operator|(
name|uintmax_t
operator|)
operator|-
literal|1
condition|)
return|return
name|HEADER_FAILURE
return|;
name|recorded_sum
operator|=
name|parsed_sum
expr_stmt|;
if|if
condition|(
name|unsigned_sum
operator|!=
name|recorded_sum
operator|&&
name|signed_sum
operator|!=
name|recorded_sum
condition|)
return|return
name|HEADER_FAILURE
return|;
comment|/* Good block.  Decode file size and return.  */
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|LNKTYPE
condition|)
name|current_stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* links 0 size on tape */
else|else
name|current_stat
operator|.
name|st_size
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_LONGNAME
operator|||
name|header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_LONGLINK
condition|)
block|{
if|if
condition|(
name|raw_extended_headers
condition|)
return|return
name|HEADER_SUCCESS_EXTENDED
return|;
else|else
block|{
name|size_t
name|name_size
init|=
name|current_stat
operator|.
name|st_size
decl_stmt|;
name|size
operator|=
name|name_size
operator|-
name|name_size
operator|%
name|BLOCKSIZE
operator|+
literal|2
operator|*
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|name_size
operator|!=
name|current_stat
operator|.
name|st_size
operator|||
name|size
operator|<
name|name_size
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
name|header_copy
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_LONGNAME
condition|)
block|{
if|if
condition|(
name|next_long_name
condition|)
name|free
argument_list|(
name|next_long_name
argument_list|)
expr_stmt|;
name|next_long_name
operator|=
name|header_copy
expr_stmt|;
name|next_long_name_blocks
operator|=
name|size
operator|/
name|BLOCKSIZE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|next_long_link
condition|)
name|free
argument_list|(
name|next_long_link
argument_list|)
expr_stmt|;
name|next_long_link
operator|=
name|header_copy
expr_stmt|;
name|next_long_link_blocks
operator|=
name|size
operator|/
name|BLOCKSIZE
expr_stmt|;
block|}
name|set_next_block_after
argument_list|(
name|header
argument_list|)
expr_stmt|;
operator|*
name|header_copy
operator|=
operator|*
name|header
expr_stmt|;
name|bp
operator|=
name|header_copy
operator|->
name|buffer
operator|+
name|BLOCKSIZE
expr_stmt|;
for|for
control|(
name|size
operator|-=
name|BLOCKSIZE
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|written
control|)
block|{
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|written
operator|=
name|available_space_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|written
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|written
expr_stmt|;
name|set_next_block_after
argument_list|(
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
name|data_block
operator|->
name|buffer
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Loop!  */
block|}
else|else
block|{
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|struct
name|posix_header
specifier|const
modifier|*
name|h
init|=
operator|&
name|current_header
operator|->
name|header
decl_stmt|;
name|char
name|namebuf
index|[
sizeof|sizeof
name|h
operator|->
name|prefix
operator|+
literal|1
operator|+
name|NAME_FIELD_SIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|recent_long_name
condition|)
name|free
argument_list|(
name|recent_long_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_long_name
condition|)
block|{
name|name
operator|=
name|next_long_name
operator|->
name|buffer
operator|+
name|BLOCKSIZE
expr_stmt|;
name|recent_long_name
operator|=
name|next_long_name
expr_stmt|;
name|recent_long_name_blocks
operator|=
name|next_long_name_blocks
expr_stmt|;
block|}
else|else
block|{
comment|/* Accept file names as specified by POSIX.1-1996                  section 10.1.1.  */
name|char
modifier|*
name|np
init|=
name|namebuf
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|prefix
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|magic
argument_list|,
name|TMAGIC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|np
argument_list|,
name|h
operator|->
name|prefix
argument_list|,
sizeof|sizeof
name|h
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|np
index|[
sizeof|sizeof
name|h
operator|->
name|prefix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|np
operator|+=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
operator|*
name|np
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Prevent later references to current_header from 		     mistakenly treating this as an old GNU header. 		     This assignment invalidates h->prefix.  */
name|current_header
operator|->
name|oldgnu_header
operator|.
name|isextended
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|np
argument_list|,
name|h
operator|->
name|name
argument_list|,
sizeof|sizeof
name|h
operator|->
name|name
argument_list|)
expr_stmt|;
name|np
index|[
sizeof|sizeof
name|h
operator|->
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|namebuf
expr_stmt|;
name|recent_long_name
operator|=
literal|0
expr_stmt|;
name|recent_long_name_blocks
operator|=
literal|0
expr_stmt|;
block|}
name|assign_string
argument_list|(
operator|&
name|current_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|recent_long_link
condition|)
name|free
argument_list|(
name|recent_long_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_long_link
condition|)
block|{
name|name
operator|=
name|next_long_link
operator|->
name|buffer
operator|+
name|BLOCKSIZE
expr_stmt|;
name|recent_long_link
operator|=
name|next_long_link
expr_stmt|;
name|recent_long_link_blocks
operator|=
name|next_long_link_blocks
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|namebuf
argument_list|,
name|h
operator|->
name|linkname
argument_list|,
sizeof|sizeof
name|h
operator|->
name|linkname
argument_list|)
expr_stmt|;
name|namebuf
index|[
sizeof|sizeof
name|h
operator|->
name|linkname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|namebuf
expr_stmt|;
name|recent_long_link
operator|=
literal|0
expr_stmt|;
name|recent_long_link_blocks
operator|=
literal|0
expr_stmt|;
block|}
name|assign_string
argument_list|(
operator|&
name|current_link_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|HEADER_SUCCESS
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Decode things from a file HEADER block into STAT_INFO, also setting    *FORMAT_POINTER depending on the header block format.  If    DO_USER_GROUP, decode the user/group information (this is useful    for extraction, but waste time when merely listing).     read_header() has already decoded the checksum and length, so we don't.     This routine should *not* be called twice for the same block, since    the two calls might use different DO_USER_GROUP values and thus    might end up with different uid/gid for the two calls.  If anybody    wants the uid/gid they should decode it first, and other callers    should decode it without uid/gid before calling a routine,    e.g. print_header, that assumes decoded data.  */
end_comment

begin_function
name|void
name|decode_header
parameter_list|(
name|union
name|block
modifier|*
name|header
parameter_list|,
name|struct
name|stat
modifier|*
name|stat_info
parameter_list|,
name|enum
name|archive_format
modifier|*
name|format_pointer
parameter_list|,
name|int
name|do_user_group
parameter_list|)
block|{
name|enum
name|archive_format
name|format
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|TMAGIC
argument_list|)
operator|==
literal|0
condition|)
name|format
operator|=
name|POSIX_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|OLDGNU_MAGIC
argument_list|)
operator|==
literal|0
condition|)
name|format
operator|=
name|OLDGNU_FORMAT
expr_stmt|;
else|else
name|format
operator|=
name|V7_FORMAT
expr_stmt|;
operator|*
name|format_pointer
operator|=
name|format
expr_stmt|;
name|stat_info
operator|->
name|st_mode
operator|=
name|MODE_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|mode
argument_list|)
expr_stmt|;
name|stat_info
operator|->
name|st_mtime
operator|=
name|TIME_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|OLDGNU_FORMAT
operator|&&
name|incremental_option
condition|)
block|{
name|stat_info
operator|->
name|st_atime
operator|=
name|TIME_FROM_HEADER
argument_list|(
name|header
operator|->
name|oldgnu_header
operator|.
name|atime
argument_list|)
expr_stmt|;
name|stat_info
operator|->
name|st_ctime
operator|=
name|TIME_FROM_HEADER
argument_list|(
name|header
operator|->
name|oldgnu_header
operator|.
name|ctime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|==
name|V7_FORMAT
condition|)
block|{
name|stat_info
operator|->
name|st_uid
operator|=
name|UID_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
name|stat_info
operator|->
name|st_gid
operator|=
name|GID_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
name|stat_info
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_user_group
condition|)
block|{
comment|/* FIXME: Decide if this should somewhat depend on -p.  */
if|if
condition|(
name|numeric_owner_option
operator|||
operator|!
operator|*
name|header
operator|->
name|header
operator|.
name|uname
operator|||
operator|!
name|uname_to_uid
argument_list|(
name|header
operator|->
name|header
operator|.
name|uname
argument_list|,
operator|&
name|stat_info
operator|->
name|st_uid
argument_list|)
condition|)
name|stat_info
operator|->
name|st_uid
operator|=
name|UID_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_owner_option
operator|||
operator|!
operator|*
name|header
operator|->
name|header
operator|.
name|gname
operator|||
operator|!
name|gname_to_gid
argument_list|(
name|header
operator|->
name|header
operator|.
name|gname
argument_list|,
operator|&
name|stat_info
operator|->
name|st_gid
argument_list|)
condition|)
name|stat_info
operator|->
name|st_gid
operator|=
name|GID_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
case|case
name|BLKTYPE
case|:
name|stat_info
operator|->
name|st_rdev
operator|=
name|makedev
argument_list|(
name|MAJOR_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|devmajor
argument_list|)
argument_list|,
name|MINOR_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHRTYPE
case|:
name|stat_info
operator|->
name|st_rdev
operator|=
name|makedev
argument_list|(
name|MAJOR_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|devmajor
argument_list|)
argument_list|,
name|MINOR_FROM_HEADER
argument_list|(
name|header
operator|->
name|header
operator|.
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|stat_info
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Convert buffer at WHERE0 of size DIGS from external format to    uintmax_t.  The data is of type TYPE.  The buffer must represent a    value in the range -MINUS_MINVAL through MAXVAL.  DIGS must be    positive.  Return -1 on error, diagnosing the error if TYPE is    nonzero.  */
end_comment

begin_function
specifier|static
name|uintmax_t
name|from_header
parameter_list|(
name|char
specifier|const
modifier|*
name|where0
parameter_list|,
name|size_t
name|digs
parameter_list|,
name|char
specifier|const
modifier|*
name|type
parameter_list|,
name|uintmax_t
name|minus_minval
parameter_list|,
name|uintmax_t
name|maxval
parameter_list|)
block|{
name|uintmax_t
name|value
decl_stmt|;
name|char
specifier|const
modifier|*
name|where
init|=
name|where0
decl_stmt|;
name|char
specifier|const
modifier|*
name|lim
init|=
name|where
operator|+
name|digs
decl_stmt|;
name|int
name|negative
init|=
literal|0
decl_stmt|;
comment|/* Accommodate buggy tar of unknown vintage, which outputs leading      NUL if the previous field overflows.  */
name|where
operator|+=
operator|!
operator|*
name|where
expr_stmt|;
comment|/* Accommodate older tars, which output leading spaces.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|where
operator|==
name|lim
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Blanks in header where numeric %s value expected"
argument_list|)
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
argument_list|)
condition|)
break|break;
name|where
operator|++
expr_stmt|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISODIGIT
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|where1
init|=
name|where
decl_stmt|;
name|uintmax_t
name|overflow
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|value
operator|+=
operator|*
name|where
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|lim
operator|||
operator|!
name|ISODIGIT
argument_list|(
operator|*
name|where
argument_list|)
condition|)
break|break;
name|overflow
operator||=
name|value
operator|^
operator|(
name|value
operator|<<
name|LG_8
operator|>>
name|LG_8
operator|)
expr_stmt|;
name|value
operator|<<=
name|LG_8
expr_stmt|;
block|}
comment|/* Parse the output of older, unportable tars, which generate          negative values in two's complement octal.  If the leading          nonzero digit is 1, we can't recover the original value          reliably; so do this only if the digit is 2 or more.  This          catches the common case of 32-bit negative time stamps.  */
if|if
condition|(
operator|(
name|overflow
operator|||
name|maxval
operator|<
name|value
operator|)
operator|&&
literal|'2'
operator|<=
operator|*
name|where1
operator|&&
name|type
condition|)
block|{
comment|/* Compute the negative of the input value, assuming two's 	     complement.  */
name|int
name|digit
init|=
operator|(
operator|*
name|where1
operator|-
literal|'0'
operator|)
operator||
literal|4
decl_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|where
operator|=
name|where1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|value
operator|+=
literal|7
operator|-
name|digit
expr_stmt|;
name|where
operator|++
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|lim
operator|||
operator|!
name|ISODIGIT
argument_list|(
operator|*
name|where
argument_list|)
condition|)
break|break;
name|digit
operator|=
operator|*
name|where
operator|-
literal|'0'
expr_stmt|;
name|overflow
operator||=
name|value
operator|^
operator|(
name|value
operator|<<
name|LG_8
operator|>>
name|LG_8
operator|)
expr_stmt|;
name|value
operator|<<=
name|LG_8
expr_stmt|;
block|}
name|value
operator|++
expr_stmt|;
name|overflow
operator||=
operator|!
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|overflow
operator|&&
name|value
operator|<=
name|minus_minval
condition|)
block|{
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive octal value %.*s is out of %s range; assuming two's complement"
argument_list|)
operator|,
call|(
name|int
call|)
argument_list|(
name|where
operator|-
name|where1
argument_list|)
operator|,
name|where1
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|overflow
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive octal value %.*s is out of %s range"
argument_list|)
operator|,
call|(
name|int
call|)
argument_list|(
name|where
operator|-
name|where1
argument_list|)
operator|,
name|where1
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|where
operator|==
literal|'-'
operator|||
operator|*
name|where
operator|==
literal|'+'
condition|)
block|{
comment|/* Parse base-64 output produced only by tar test versions 	 1.13.6 (1999-08-11) through 1.13.11 (1999-08-23). 	 Support for this will be withdrawn in future releases.  */
name|int
name|dig
decl_stmt|;
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive contains obsolescent base-64 headers"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|negative
operator|=
operator|*
name|where
operator|++
operator|==
literal|'-'
expr_stmt|;
while|while
condition|(
name|where
operator|!=
name|lim
operator|&&
operator|(
name|dig
operator|=
name|base64_map
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
index|]
operator|)
operator|<
literal|64
condition|)
block|{
if|if
condition|(
name|value
operator|<<
name|LG_64
operator|>>
name|LG_64
operator|!=
name|value
condition|)
block|{
name|char
modifier|*
name|string
init|=
name|alloca
argument_list|(
name|digs
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|string
argument_list|,
name|where0
argument_list|,
name|digs
argument_list|)
expr_stmt|;
name|string
index|[
name|digs
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive signed base-64 string %s is out of %s range"
argument_list|)
operator|,
name|quote
argument_list|(
name|string
argument_list|)
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|value
operator|=
operator|(
name|value
operator|<<
name|LG_64
operator|)
operator||
name|dig
expr_stmt|;
name|where
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|where
operator|==
literal|'\200'
comment|/* positive base-256 */
operator|||
operator|*
name|where
operator|==
literal|'\377'
comment|/* negative base-256 */
condition|)
block|{
comment|/* Parse base-256 output.  A nonnegative number N is 	 represented as (256**DIGS)/2 + N; a negative number -N is 	 represented as (256**DIGS) - N, i.e. as two's complement. 	 The representation guarantees that the leading bit is 	 always on, so that we don't confuse this format with the 	 others (assuming ASCII bytes of 8 bits or more).  */
name|int
name|signbit
init|=
operator|*
name|where
operator|&
operator|(
literal|1
operator|<<
operator|(
name|LG_256
operator|-
literal|2
operator|)
operator|)
decl_stmt|;
name|uintmax_t
name|topbits
init|=
operator|(
operator|(
operator|(
name|uintmax_t
operator|)
operator|-
name|signbit
operator|)
operator|<<
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|-
name|LG_256
operator|-
operator|(
name|LG_256
operator|-
literal|2
operator|)
operator|)
operator|)
decl_stmt|;
name|value
operator|=
operator|(
operator|*
name|where
operator|++
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|LG_256
operator|-
literal|2
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
name|signbit
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
name|LG_256
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
operator|++
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|lim
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|value
operator|<<
name|LG_256
operator|>>
name|LG_256
operator|)
operator||
name|topbits
operator|)
operator|!=
name|value
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive base-256 value is out of %s range"
argument_list|)
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|negative
operator|=
name|signbit
expr_stmt|;
if|if
condition|(
name|negative
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|!=
name|lim
operator|&&
operator|*
name|where
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
comment|/* Big enough to represent any header.  */
specifier|static
name|struct
name|quoting_options
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
block|{
name|o
operator|=
name|clone_quoting_options
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_quoting_style
argument_list|(
name|o
argument_list|,
name|locale_quoting_style
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|where0
operator|!=
name|lim
operator|&&
operator|!
name|lim
index|[
operator|-
literal|1
index|]
condition|)
name|lim
operator|--
expr_stmt|;
name|quotearg_buffer
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|where0
argument_list|,
name|lim
operator|-
name|where
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive contains %.*s where numeric %s value expected"
argument_list|)
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
name|buf
operator|,
name|buf
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|value
operator|<=
operator|(
name|negative
condition|?
name|minus_minval
else|:
name|maxval
operator|)
condition|)
return|return
name|negative
condition|?
operator|-
name|value
else|:
name|value
return|;
if|if
condition|(
name|type
condition|)
block|{
name|char
name|minval_buf
index|[
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|maxval_buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|char
name|value_buf
index|[
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|minval_string
init|=
name|STRINGIFY_BIGINT
argument_list|(
name|minus_minval
argument_list|,
name|minval_buf
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value_string
init|=
name|STRINGIFY_BIGINT
argument_list|(
name|value
argument_list|,
name|value_buf
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|negative
condition|)
operator|*
operator|--
name|value_string
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|minus_minval
condition|)
operator|*
operator|--
name|minval_string
operator|=
literal|'-'
expr_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Archive value %s is out of %s range %s..%s"
argument_list|)
operator|,
name|value_string
operator|,
name|type
operator|,
name|minval_string
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|maxval
argument_list|,
name|maxval_buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|gid_t
name|gid_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"gid_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|gid_t
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|gid_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|major_t
name|major_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"major_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|major_t
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|major_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|minor_t
name|minor_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"minor_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|minor_t
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|minor_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|mode_t
name|mode_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
comment|/* Do not complain about unrecognized mode bits.  */
name|unsigned
name|u
init|=
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"mode_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|mode_t
argument_list|)
argument_list|,
name|TYPE_MAXIMUM
argument_list|(
name|uintmax_t
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|u
operator|&
name|TSUID
condition|?
name|S_ISUID
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TSGID
condition|?
name|S_ISGID
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TSVTX
condition|?
name|S_ISVTX
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TUREAD
condition|?
name|S_IRUSR
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TUWRITE
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TUEXEC
condition|?
name|S_IXUSR
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TGREAD
condition|?
name|S_IRGRP
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TGWRITE
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TGEXEC
condition|?
name|S_IXGRP
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TOREAD
condition|?
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TOWRITE
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator||
operator|(
name|u
operator|&
name|TOEXEC
condition|?
name|S_IXOTH
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|off_t
name|off_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
comment|/* Negative offsets are not allowed in tar files, so invoke      from_header with minimum value 0, not TYPE_MINIMUM (off_t).  */
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"off_t"
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|off_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|size_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"size_t"
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|size_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|time_t
name|time_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"time_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|time_t
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|time_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uid_t
name|uid_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"uid_t"
argument_list|,
operator|-
operator|(
name|uintmax_t
operator|)
name|TYPE_MINIMUM
argument_list|(
name|uid_t
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|uid_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uintmax_t
name|uintmax_from_header
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|from_header
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
literal|"uintmax_t"
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
name|TYPE_MAXIMUM
argument_list|(
name|uintmax_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format O as a null-terminated decimal string into BUF _backwards_;    return pointer to start of result.  */
end_comment

begin_function
name|char
modifier|*
name|stringify_uintmax_t_backwards
parameter_list|(
name|uintmax_t
name|o
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
operator|*
operator|--
name|buf
operator|=
literal|'\0'
expr_stmt|;
do|do
operator|*
operator|--
name|buf
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|o
operator|%
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|o
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return a printable representation of T.  The result points to    static storage that can be reused in the next call to this    function, to ctime, or to asctime.  */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|tartime
parameter_list|(
name|time_t
name|t
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LANGINFO_CODESET
argument_list|)
specifier|static
name|char
name|buffer
index|[
name|max
argument_list|(
name|UINTMAX_STRSIZE_BOUND
operator|+
literal|1
argument_list|,
name|INT_STRLEN_BOUND
argument_list|(
name|int
argument_list|)
operator|+
literal|16
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|USE_OLD_CTIME
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|char
specifier|const
modifier|*
name|time_stamp
init|=
name|p
operator|+
literal|4
decl_stmt|;
for|for
control|(
name|p
operator|+=
literal|16
init|;
name|p
index|[
literal|3
index|]
operator|!=
literal|'\n'
condition|;
name|p
operator|++
control|)
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|time_stamp
return|;
block|}
else|#
directive|else
comment|/* Use ISO 8610 format.  See:      http://www.cl.cam.ac.uk/~mgk25/iso-time.html  */
name|struct
name|tm
modifier|*
name|tm
init|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|tm
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
endif|#
directive|endif
comment|/* The time stamp cannot be broken down, most likely because it      is out of range.  Convert it as an integer,      right-adjusted in a field with the same width as the usual      19-byte 4-year ISO time format.  */
name|p
operator|=
name|stringify_uintmax_t_backwards
argument_list|(
name|t
operator|<
literal|0
condition|?
operator|-
operator|(
name|uintmax_t
operator|)
name|t
else|:
operator|(
name|uintmax_t
operator|)
name|t
argument_list|,
name|buffer
operator|+
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
while|while
condition|(
name|buffer
operator|+
sizeof|sizeof
name|buffer
operator|-
literal|19
operator|-
literal|1
operator|<
name|p
condition|)
operator|*
operator|--
name|p
operator|=
literal|' '
expr_stmt|;
return|return
name|p
return|;
else|#
directive|else
comment|/* __FreeBSD__ */
specifier|static
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
specifier|static
name|int
name|d_first
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|d_first
operator|<
literal|0
condition|)
name|d_first
operator|=
operator|(
operator|*
name|nl_langinfo
argument_list|(
name|D_MD_ORDER
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
name|strftime
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|d_first
condition|?
literal|"%e %b %R %Y"
else|:
literal|"%b %e %R %Y"
argument_list|,
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
block|}
end_function

begin_comment
comment|/* Actually print it.     Plain and fancy file header block logging.  Non-verbose just prints    the name, e.g. for "tar t" or "tar x".  This should just contain    file names, so it can be fed back into tar with xargs or the "-T"    option.  The verbose option can give a bunch of info, one line per    file.  I doubt anybody tries to parse its format, or if they do,    they shouldn't.  Unix tar is pretty random here anyway.  */
end_comment

begin_comment
comment|/* FIXME: Note that print_header uses the globals HEAD, HSTAT, and    HEAD_STANDARD, which must be set up in advance.  Not very clean...  */
end_comment

begin_comment
comment|/* UGSWIDTH starts with 18, so with user and group names<= 8 chars, the    columns never shift during the listing.  */
end_comment

begin_define
define|#
directive|define
name|UGSWIDTH
value|18
end_define

begin_decl_stmt
specifier|static
name|int
name|ugswidth
init|=
name|UGSWIDTH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum width encountered so far */
end_comment

begin_comment
comment|/* DATEWIDTH is the number of columns taken by the date and time fields.  */
end_comment

begin_if
if|#
directive|if
name|USE_OLD_CDATE
end_if

begin_define
define|#
directive|define
name|DATEWIDTH
value|19
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DATEWIDTH
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_header
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|modes
index|[
literal|11
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|time_stamp
decl_stmt|;
comment|/* These hold formatted ints.  */
name|char
name|uform
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|,
name|gform
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|char
name|size
index|[
literal|2
operator|*
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
comment|/* holds formatted size or major,minor */
name|char
name|uintbuf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|pad
decl_stmt|;
if|if
condition|(
name|block_number_option
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"block %s: "
argument_list|)
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|current_block_ordinal
argument_list|()
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_option
operator|<=
literal|1
condition|)
block|{
comment|/* Just the fax, mam.  */
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|"%s\n"
argument_list|,
name|quotearg
argument_list|(
name|current_file_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* File type and modes.  */
name|modes
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
switch|switch
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
case|case
name|GNUTYPE_VOLHDR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'V'
expr_stmt|;
break|break;
case|case
name|GNUTYPE_MULTIVOL
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'M'
expr_stmt|;
break|break;
case|case
name|GNUTYPE_NAMES
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'N'
expr_stmt|;
break|break;
case|case
name|GNUTYPE_LONGNAME
case|:
case|case
name|GNUTYPE_LONGLINK
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Visible longname error"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_SPARSE
case|:
case|case
name|REGTYPE
case|:
case|case
name|AREGTYPE
case|:
case|case
name|LNKTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|current_file_name
index|[
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|GNUTYPE_DUMPDIR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|DIRTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|SYMTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
name|BLKTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|CHRTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|FIFOTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'p'
expr_stmt|;
break|break;
case|case
name|CONTTYPE
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
break|break;
block|}
name|decode_mode
argument_list|(
name|current_stat
operator|.
name|st_mode
argument_list|,
name|modes
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Time stamp.  */
name|time_stamp
operator|=
name|tartime
argument_list|(
name|current_stat
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
comment|/* User and group names.  */
if|if
condition|(
operator|*
name|current_header
operator|->
name|header
operator|.
name|uname
operator|&&
name|current_format
operator|!=
name|V7_FORMAT
operator|&&
operator|!
name|numeric_owner_option
condition|)
name|user
operator|=
name|current_header
operator|->
name|header
operator|.
name|uname
expr_stmt|;
else|else
block|{
comment|/* Try parsing it as an unsigned integer first, and as a 	     uid_t if that fails.  This method can list positive user 	     ids that are too large to fit in a uid_t.  */
name|uintmax_t
name|u
init|=
name|from_header
argument_list|(
name|current_header
operator|->
name|header
operator|.
name|uid
argument_list|,
sizeof|sizeof
name|current_header
operator|->
name|header
operator|.
name|uid
argument_list|,
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|uintmax_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|!=
operator|-
literal|1
condition|)
name|user
operator|=
name|STRINGIFY_BIGINT
argument_list|(
name|u
argument_list|,
name|uform
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|uform
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|UID_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|header
operator|.
name|uid
argument_list|)
argument_list|)
expr_stmt|;
name|user
operator|=
name|uform
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|current_header
operator|->
name|header
operator|.
name|gname
operator|&&
name|current_format
operator|!=
name|V7_FORMAT
operator|&&
operator|!
name|numeric_owner_option
condition|)
name|group
operator|=
name|current_header
operator|->
name|header
operator|.
name|gname
expr_stmt|;
else|else
block|{
comment|/* Try parsing it as an unsigned integer first, and as a 	     gid_t if that fails.  This method can list positive group 	     ids that are too large to fit in a gid_t.  */
name|uintmax_t
name|g
init|=
name|from_header
argument_list|(
name|current_header
operator|->
name|header
operator|.
name|gid
argument_list|,
sizeof|sizeof
name|current_header
operator|->
name|header
operator|.
name|gid
argument_list|,
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
literal|0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TYPE_MAXIMUM
argument_list|(
name|uintmax_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
operator|-
literal|1
condition|)
name|group
operator|=
name|STRINGIFY_BIGINT
argument_list|(
name|g
argument_list|,
name|gform
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|gform
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|GID_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|header
operator|.
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|=
name|gform
expr_stmt|;
block|}
block|}
comment|/* Format the file size or major/minor device numbers.  */
switch|switch
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
case|case
name|CHRTYPE
case|:
case|case
name|BLKTYPE
case|:
name|strcpy
argument_list|(
name|size
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|major
argument_list|(
name|current_stat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|uintbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|size
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|size
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|minor
argument_list|(
name|current_stat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|uintbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_SPARSE
case|:
name|strcpy
argument_list|(
name|size
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|UINTMAX_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|realsize
argument_list|)
argument_list|,
name|uintbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|size
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|uintbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Figure out padding and print the whole line.  */
name|pad
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
name|strlen
argument_list|(
name|group
argument_list|)
operator|+
name|strlen
argument_list|(
name|size
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pad
operator|>
name|ugswidth
condition|)
name|ugswidth
operator|=
name|pad
expr_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|"%s %s/%s %*s%s %s"
argument_list|,
name|modes
argument_list|,
name|user
argument_list|,
name|group
argument_list|,
name|ugswidth
operator|-
name|pad
argument_list|,
literal|""
argument_list|,
name|size
argument_list|,
name|time_stamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|" %s"
argument_list|,
name|quotearg
argument_list|(
name|current_file_name
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
case|case
name|SYMTYPE
case|:
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|" -> %s\n"
argument_list|,
name|quotearg
argument_list|(
name|current_link_name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LNKTYPE
case|:
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|" link to %s\n"
argument_list|)
argument_list|,
name|quotearg
argument_list|(
name|current_link_name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|type_string
index|[
literal|2
index|]
decl_stmt|;
name|type_string
index|[
literal|0
index|]
operator|=
name|current_header
operator|->
name|header
operator|.
name|typeflag
expr_stmt|;
name|type_string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|" unknown file type %s\n"
argument_list|)
argument_list|,
name|quote
argument_list|(
name|type_string
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AREGTYPE
case|:
case|case
name|REGTYPE
case|:
case|case
name|GNUTYPE_SPARSE
case|:
case|case
name|CHRTYPE
case|:
case|case
name|BLKTYPE
case|:
case|case
name|DIRTYPE
case|:
case|case
name|FIFOTYPE
case|:
case|case
name|CONTTYPE
case|:
case|case
name|GNUTYPE_DUMPDIR
case|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdlis
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_VOLHDR
case|:
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"--Volume Header--\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_MULTIVOL
case|:
name|strcpy
argument_list|(
name|size
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|UINTMAX_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|offset
argument_list|)
argument_list|,
name|uintbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"--Continued at byte %s--\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_NAMES
case|:
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"--Mangled file names--\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fflush
argument_list|(
name|stdlis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a similar line when we make a directory automatically.  */
end_comment

begin_function
name|void
name|print_for_mkdir
parameter_list|(
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|length
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|char
name|modes
index|[
literal|11
index|]
decl_stmt|;
if|if
condition|(
name|verbose_option
operator|>
literal|1
condition|)
block|{
comment|/* File type and modes.  */
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
name|decode_mode
argument_list|(
name|mode
argument_list|,
name|modes
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_number_option
condition|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"block %s: "
argument_list|)
argument_list|,
name|STRINGIFY_BIGINT
argument_list|(
name|current_block_ordinal
argument_list|()
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|"%s %*s %.*s\n"
argument_list|,
name|modes
argument_list|,
name|ugswidth
operator|+
name|DATEWIDTH
argument_list|,
name|_
argument_list|(
literal|"Creating directory:"
argument_list|)
argument_list|,
name|length
argument_list|,
name|quotearg
argument_list|(
name|pathname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip over SIZE bytes of data in blocks in the archive.  */
end_comment

begin_function
name|void
name|skip_file
parameter_list|(
name|off_t
name|size
parameter_list|)
block|{
name|union
name|block
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|save_totsize
operator|=
name|size
expr_stmt|;
name|save_sizeleft
operator|=
name|size
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|save_sizeleft
operator|-=
name|BLOCKSIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip the current member in the archive.  */
end_comment

begin_function
name|void
name|skip_member
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|save_typeflag
init|=
name|current_header
operator|->
name|header
operator|.
name|typeflag
decl_stmt|;
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|isextended
condition|)
block|{
name|union
name|block
modifier|*
name|exhdr
decl_stmt|;
do|do
block|{
name|exhdr
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exhdr
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|exhdr
operator|->
name|sparse_header
operator|.
name|isextended
condition|)
do|;
block|}
if|if
condition|(
name|save_typeflag
operator|!=
name|DIRTYPE
condition|)
name|skip_file
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

