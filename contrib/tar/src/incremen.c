begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU dump extensions to tar.     Copyright 1988, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<getline.h>
end_include

begin_include
include|#
directive|include
file|<hash.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Variable sized generic character buffers.  */
end_comment

begin_struct
struct|struct
name|accumulator
block|{
name|size_t
name|allocated
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Amount of space guaranteed just after a reallocation.  */
end_comment

begin_define
define|#
directive|define
name|ACCUMULATOR_SLACK
value|50
end_define

begin_comment
comment|/* Return the accumulated data from an ACCUMULATOR buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_accumulator
parameter_list|(
name|struct
name|accumulator
modifier|*
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
operator|->
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* Allocate and return a new accumulator buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|accumulator
modifier|*
name|new_accumulator
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|accumulator
modifier|*
name|accumulator
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|accumulator
argument_list|)
argument_list|)
decl_stmt|;
name|accumulator
operator|->
name|allocated
operator|=
name|ACCUMULATOR_SLACK
expr_stmt|;
name|accumulator
operator|->
name|pointer
operator|=
name|xmalloc
argument_list|(
name|ACCUMULATOR_SLACK
argument_list|)
expr_stmt|;
name|accumulator
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|accumulator
return|;
block|}
end_function

begin_comment
comment|/* Deallocate an ACCUMULATOR buffer.  */
end_comment

begin_function
specifier|static
name|void
name|delete_accumulator
parameter_list|(
name|struct
name|accumulator
modifier|*
name|accumulator
parameter_list|)
block|{
name|free
argument_list|(
name|accumulator
operator|->
name|pointer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|accumulator
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of an ACCUMULATOR buffer, add a DATA block of SIZE bytes.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_accumulator
parameter_list|(
name|struct
name|accumulator
modifier|*
name|accumulator
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|accumulator
operator|->
name|length
operator|+
name|size
operator|>
name|accumulator
operator|->
name|allocated
condition|)
block|{
name|accumulator
operator|->
name|allocated
operator|=
name|accumulator
operator|->
name|length
operator|+
name|size
operator|+
name|ACCUMULATOR_SLACK
expr_stmt|;
name|accumulator
operator|->
name|pointer
operator|=
name|xrealloc
argument_list|(
name|accumulator
operator|->
name|pointer
argument_list|,
name|accumulator
operator|->
name|allocated
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|accumulator
operator|->
name|pointer
operator|+
name|accumulator
operator|->
name|length
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|accumulator
operator|->
name|length
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Incremental dump specialities.  */
end_comment

begin_comment
comment|/* Which child files to save under a directory.  */
end_comment

begin_enum
enum|enum
name|children
block|{
name|NO_CHILDREN
block|,
name|CHANGED_CHILDREN
block|,
name|ALL_CHILDREN
block|}
enum|;
end_enum

begin_comment
comment|/* Directory attributes.  */
end_comment

begin_struct
struct|struct
name|directory
block|{
name|dev_t
name|device_number
decl_stmt|;
comment|/* device number for directory */
name|ino_t
name|inode_number
decl_stmt|;
comment|/* inode number for directory */
name|enum
name|children
name|children
decl_stmt|;
name|char
name|nfs
decl_stmt|;
name|char
name|found
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
comment|/* path name of directory */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|Hash_table
modifier|*
name|directory_table
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_ST_FSTYPE_STRING
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
name|nfs_string
index|[]
init|=
literal|"nfs"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NFS_FILE_STAT
parameter_list|(
name|st
parameter_list|)
value|(strcmp ((st).st_fstype, nfs_string) == 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ST_DEV_MSB
parameter_list|(
name|st
parameter_list|)
value|(~ (dev_t) 0<< (sizeof (st).st_dev * CHAR_BIT - 1))
end_define

begin_define
define|#
directive|define
name|NFS_FILE_STAT
parameter_list|(
name|st
parameter_list|)
value|(((st).st_dev& ST_DEV_MSB (st)) != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Calculate the hash of a directory.  */
end_comment

begin_function
specifier|static
name|unsigned
name|hash_directory
parameter_list|(
name|void
specifier|const
modifier|*
name|entry
parameter_list|,
name|unsigned
name|n_buckets
parameter_list|)
block|{
name|struct
name|directory
specifier|const
modifier|*
name|directory
init|=
name|entry
decl_stmt|;
return|return
name|hash_string
argument_list|(
name|directory
operator|->
name|name
argument_list|,
name|n_buckets
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two directories for equality.  */
end_comment

begin_function
specifier|static
name|bool
name|compare_directories
parameter_list|(
name|void
specifier|const
modifier|*
name|entry1
parameter_list|,
name|void
specifier|const
modifier|*
name|entry2
parameter_list|)
block|{
name|struct
name|directory
specifier|const
modifier|*
name|directory1
init|=
name|entry1
decl_stmt|;
name|struct
name|directory
specifier|const
modifier|*
name|directory2
init|=
name|entry2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|directory1
operator|->
name|name
argument_list|,
name|directory2
operator|->
name|name
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create and link a new directory entry for directory NAME, having a    device number DEV and an inode number INO, with NFS indicating    whether it is an NFS device and FOUND indicating whether we have    found that the directory exists.  */
end_comment

begin_function
specifier|static
name|struct
name|directory
modifier|*
name|note_directory
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|bool
name|nfs
parameter_list|,
name|bool
name|found
parameter_list|)
block|{
name|size_t
name|size
init|=
name|offsetof
argument_list|(
expr|struct
name|directory
argument_list|,
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|struct
name|directory
modifier|*
name|directory
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|directory
operator|->
name|device_number
operator|=
name|dev
expr_stmt|;
name|directory
operator|->
name|inode_number
operator|=
name|ino
expr_stmt|;
name|directory
operator|->
name|children
operator|=
name|CHANGED_CHILDREN
expr_stmt|;
name|directory
operator|->
name|nfs
operator|=
name|nfs
expr_stmt|;
name|directory
operator|->
name|found
operator|=
name|found
expr_stmt|;
name|strcpy
argument_list|(
name|directory
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|directory_table
operator|||
operator|(
name|directory_table
operator|=
name|hash_initialize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hash_directory
argument_list|,
name|compare_directories
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|&&
name|hash_insert
argument_list|(
name|directory_table
argument_list|,
name|directory
argument_list|)
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|directory
return|;
block|}
end_function

begin_comment
comment|/* Return a directory entry for a given path NAME, or zero if none found.  */
end_comment

begin_function
specifier|static
name|struct
name|directory
modifier|*
name|find_directory
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|directory_table
condition|)
return|return
literal|0
return|;
else|else
block|{
name|size_t
name|size
init|=
name|offsetof
argument_list|(
expr|struct
name|directory
argument_list|,
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|struct
name|directory
modifier|*
name|dir
init|=
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dir
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|hash_lookup
argument_list|(
name|directory_table
argument_list|,
name|dir
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compare_dirents
parameter_list|(
specifier|const
name|void
modifier|*
name|first
parameter_list|,
specifier|const
name|void
modifier|*
name|second
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|first
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|*
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|second
operator|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_directory_contents
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|dev_t
name|device
parameter_list|)
block|{
name|struct
name|accumulator
modifier|*
name|accumulator
decl_stmt|;
comment|/* Recursively scan the given PATH.  */
block|{
name|char
modifier|*
name|dirp
init|=
name|savedir
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|/* for scanning directory */
name|char
specifier|const
modifier|*
name|entry
decl_stmt|;
comment|/* directory entry being scanned */
name|size_t
name|entrylen
decl_stmt|;
comment|/* length of directory entry */
name|char
modifier|*
name|name_buffer
decl_stmt|;
comment|/* directory, `/', and directory member */
name|size_t
name|name_buffer_size
decl_stmt|;
comment|/* allocated size of name_buffer, minus 2 */
name|size_t
name|name_length
decl_stmt|;
comment|/* used length in name_buffer */
name|struct
name|directory
modifier|*
name|directory
decl_stmt|;
comment|/* for checking if already already seen */
name|enum
name|children
name|children
decl_stmt|;
if|if
condition|(
operator|!
name|dirp
condition|)
name|savedir_error
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|name_buffer_size
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|NAME_FIELD_SIZE
expr_stmt|;
name|name_buffer
operator|=
name|xmalloc
argument_list|(
name|name_buffer_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_buffer
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISSLASH
argument_list|(
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|strcat
argument_list|(
name|name_buffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
name|directory
operator|=
name|find_directory
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|children
operator|=
name|directory
condition|?
name|directory
operator|->
name|children
else|:
name|CHANGED_CHILDREN
expr_stmt|;
name|accumulator
operator|=
name|new_accumulator
argument_list|()
expr_stmt|;
if|if
condition|(
name|children
operator|!=
name|NO_CHILDREN
condition|)
for|for
control|(
name|entry
operator|=
name|dirp
init|;
operator|(
name|entrylen
operator|=
name|strlen
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|entry
operator|+=
name|entrylen
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|name_buffer_size
operator|<=
name|entrylen
operator|+
name|name_length
condition|)
block|{
do|do
name|name_buffer_size
operator|+=
name|NAME_FIELD_SIZE
expr_stmt|;
do|while
condition|(
name|name_buffer_size
operator|<=
name|entrylen
operator|+
name|name_length
condition|)
do|;
name|name_buffer
operator|=
name|xrealloc
argument_list|(
name|name_buffer
argument_list|,
name|name_buffer_size
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|name_buffer
operator|+
name|name_length
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|excluded_name
argument_list|(
name|name_buffer
argument_list|)
condition|)
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|stat
name|stat_data
decl_stmt|;
if|if
condition|(
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|name_buffer
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
block|{
if|if
condition|(
name|ignore_failed_read_option
condition|)
name|stat_warn
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
else|else
name|stat_error
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|bool
name|nfs
init|=
name|NFS_FILE_STAT
argument_list|(
name|stat_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|directory
operator|=
name|find_directory
argument_list|(
name|name_buffer
argument_list|)
operator|,
name|directory
condition|)
block|{
comment|/* With NFS, the same file can have two different devices 			 if an NFS directory is mounted in multiple locations, 			 which is relatively common when automounting. 			 To avoid spurious incremental redumping of 			 directories, consider all NFS devices as equal, 			 relying on the i-node to establish differences.  */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|directory
operator|->
name|nfs
operator|&
name|nfs
operator|)
operator|||
name|directory
operator|->
name|device_number
operator|==
name|stat_data
operator|.
name|st_dev
operator|)
operator|&&
name|directory
operator|->
name|inode_number
operator|==
name|stat_data
operator|.
name|st_ino
operator|)
condition|)
block|{
if|if
condition|(
name|verbose_option
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Directory has been renamed"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name_buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|directory
operator|->
name|children
operator|=
name|ALL_CHILDREN
expr_stmt|;
name|directory
operator|->
name|nfs
operator|=
name|nfs
expr_stmt|;
name|directory
operator|->
name|device_number
operator|=
name|stat_data
operator|.
name|st_dev
expr_stmt|;
name|directory
operator|->
name|inode_number
operator|=
name|stat_data
operator|.
name|st_ino
expr_stmt|;
block|}
name|directory
operator|->
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose_option
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Directory is new"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name_buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|directory
operator|=
name|note_directory
argument_list|(
name|name_buffer
argument_list|,
name|stat_data
operator|.
name|st_dev
argument_list|,
name|stat_data
operator|.
name|st_ino
argument_list|,
name|nfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|directory
operator|->
name|children
operator|=
operator|(
operator|(
name|listed_incremental_option
operator|||
name|newer_mtime_option
operator|<=
name|stat_data
operator|.
name|st_mtime
operator|||
operator|(
name|after_date_option
operator|&&
name|newer_ctime_option
operator|<=
name|stat_data
operator|.
name|st_ctime
operator|)
operator|)
condition|?
name|ALL_CHILDREN
else|:
name|CHANGED_CHILDREN
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|one_file_system_option
operator|&&
name|device
operator|!=
name|stat_data
operator|.
name|st_dev
condition|)
name|directory
operator|->
name|children
operator|=
name|NO_CHILDREN
expr_stmt|;
elseif|else
if|if
condition|(
name|children
operator|==
name|ALL_CHILDREN
condition|)
name|directory
operator|->
name|children
operator|=
name|ALL_CHILDREN
expr_stmt|;
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|one_file_system_option
operator|&&
name|device
operator|!=
name|stat_data
operator|.
name|st_dev
condition|)
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISHIDDEN
elseif|else
if|if
condition|(
name|S_ISHIDDEN
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"D"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
name|entry
argument_list|,
name|entrylen
argument_list|)
expr_stmt|;
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"A"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|children
operator|==
name|CHANGED_CHILDREN
operator|&&
name|stat_data
operator|.
name|st_mtime
operator|<
name|newer_mtime_option
operator|&&
operator|(
operator|!
name|after_date_option
operator|||
name|stat_data
operator|.
name|st_ctime
operator|<
name|newer_ctime_option
operator|)
condition|)
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"Y"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
name|entry
argument_list|,
name|entrylen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_to_accumulator
argument_list|(
name|accumulator
argument_list|,
literal|"\000\000"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the contents of the directory, now that we have it all.  */
block|{
name|char
modifier|*
name|pointer
init|=
name|get_accumulator
argument_list|(
name|accumulator
argument_list|)
decl_stmt|;
name|size_t
name|counter
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
name|char
modifier|*
modifier|*
name|array_cursor
decl_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cursor
operator|=
name|pointer
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|+=
name|strlen
argument_list|(
name|cursor
argument_list|)
operator|+
literal|1
control|)
name|counter
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|counter
condition|)
block|{
name|delete_accumulator
argument_list|(
name|accumulator
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|array
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|counter
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|array_cursor
operator|=
name|array
expr_stmt|;
for|for
control|(
name|cursor
operator|=
name|pointer
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|+=
name|strlen
argument_list|(
name|cursor
argument_list|)
operator|+
literal|1
control|)
operator|*
name|array_cursor
operator|++
operator|=
name|cursor
expr_stmt|;
operator|*
name|array_cursor
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|array
argument_list|,
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_dirents
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|cursor
operator|-
name|pointer
operator|+
literal|2
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|array_cursor
operator|=
name|array
init|;
operator|*
name|array_cursor
condition|;
name|array_cursor
operator|++
control|)
block|{
name|char
modifier|*
name|string
init|=
operator|*
name|array_cursor
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|cursor
operator|++
operator|=
operator|*
name|string
operator|++
operator|)
condition|)
continue|continue;
block|}
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
name|delete_accumulator
argument_list|(
name|accumulator
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|listed_incremental_stream
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|read_directory_file
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
comment|/* Open the file for both read and write.  That way, we can write      it later without having to reopen it, and don't have to worry if      we chdir in the meantime.  */
name|fd
operator|=
name|open
argument_list|(
name|listed_incremental_option
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|MODE_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|open_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|open_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|listed_incremental_stream
operator|=
name|fp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|getline
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ebuf
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|lineno
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|u
init|=
operator|(
name|errno
operator|=
literal|0
expr|,
name|strtoul
argument_list|(
name|buf
argument_list|,
operator|&
name|ebuf
argument_list|,
literal|10
argument_list|)
operator|)
decl_stmt|;
name|time_t
name|t
init|=
name|u
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|ebuf
operator|||
operator|(
name|u
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:1: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|_
argument_list|(
literal|"Invalid time stamp"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|!=
name|u
operator|||
operator|(
name|u
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ERANGE
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:1: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|_
argument_list|(
literal|"Time stamp out of range"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|newer_mtime_option
operator|=
name|t
expr_stmt|;
while|while
condition|(
literal|0
operator|<
operator|(
name|n
operator|=
name|getline
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
block|{
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|nfs
init|=
name|buf
index|[
literal|0
index|]
operator|==
literal|'+'
decl_stmt|;
name|char
modifier|*
name|strp
init|=
name|buf
operator|+
name|nfs
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|u
operator|=
name|strtoul
argument_list|(
name|strp
argument_list|,
operator|&
name|ebuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|strp
operator|==
name|ebuf
operator|||
operator|(
name|u
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:%ld: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|lineno
operator|,
name|_
argument_list|(
literal|"Invalid device number"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|!=
name|u
operator|||
operator|(
name|u
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ERANGE
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:%ld: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|lineno
operator|,
name|_
argument_list|(
literal|"Device number out of range"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strp
operator|=
name|ebuf
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ino
operator|=
name|u
operator|=
name|strtoul
argument_list|(
name|strp
argument_list|,
operator|&
name|ebuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|strp
operator|==
name|ebuf
operator|||
operator|(
name|u
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:%ld: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|lineno
operator|,
name|_
argument_list|(
literal|"Invalid inode number"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ino
operator|!=
name|u
operator|||
operator|(
name|u
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ERANGE
operator|)
condition|)
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s:%ld: %s"
operator|,
name|quotearg_colon
argument_list|(
name|listed_incremental_option
argument_list|)
operator|,
name|lineno
operator|,
name|_
argument_list|(
literal|"Inode number out of range"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strp
operator|=
name|ebuf
expr_stmt|;
name|strp
operator|++
expr_stmt|;
name|unquote_string
argument_list|(
name|strp
argument_list|)
expr_stmt|;
name|note_directory
argument_list|(
name|strp
argument_list|,
name|dev
argument_list|,
name|ino
argument_list|,
name|nfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|read_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output incremental data for the directory ENTRY to the file DATA.    Return nonzero if successful, preserving errno on write failure.  */
end_comment

begin_function
specifier|static
name|bool
name|write_directory_file_entry
parameter_list|(
name|void
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|directory
specifier|const
modifier|*
name|directory
init|=
name|entry
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|directory
operator|->
name|found
condition|)
block|{
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|quote_copy_string
argument_list|(
name|directory
operator|->
name|name
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"+%lu %lu %s\n"
operator|+
operator|!
name|directory
operator|->
name|nfs
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|directory
operator|->
name|device_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|directory
operator|->
name|inode_number
argument_list|,
name|str
condition|?
name|str
else|:
name|directory
operator|->
name|name
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
block|}
return|return
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|write_directory_file
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|listed_incremental_stream
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|seek_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|truncate_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|directory_table
condition|)
name|hash_do_for_each
argument_list|(
name|directory_table
argument_list|,
name|write_directory_file_entry
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|write_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|listed_incremental_option
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Restoration of incremental dumps.  */
end_comment

begin_function
name|void
name|gnu_restore
parameter_list|(
name|size_t
name|skipcrud
parameter_list|)
block|{
name|char
modifier|*
name|archive_dir
decl_stmt|;
name|char
modifier|*
name|current_dir
decl_stmt|;
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|arc
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|copied
decl_stmt|;
name|union
name|block
modifier|*
name|data_block
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
define|#
directive|define
name|CURRENT_FILE_NAME
value|(skipcrud + current_file_name)
name|current_dir
operator|=
name|savedir
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_dir
condition|)
block|{
comment|/* The directory doesn't exist now.  It'll be created.  In any 	 case, we don't have to delete any files out of it.  */
name|skip_member
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|current_stat
operator|.
name|st_size
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|archive_dir
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|to
operator|=
name|archive_dir
expr_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|copied
control|)
block|{
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: What happens then?  */
block|}
name|copied
operator|=
name|available_space_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied
operator|>
name|size
condition|)
name|copied
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|copied
argument_list|)
expr_stmt|;
name|to
operator|+=
name|copied
expr_stmt|;
name|set_next_block_after
argument_list|(
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
name|data_block
operator|->
name|buffer
operator|+
name|copied
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cur
operator|=
name|current_dir
init|;
operator|*
name|cur
condition|;
name|cur
operator|+=
name|strlen
argument_list|(
name|cur
argument_list|)
operator|+
literal|1
control|)
block|{
for|for
control|(
name|arc
operator|=
name|archive_dir
init|;
operator|*
name|arc
condition|;
name|arc
operator|+=
name|strlen
argument_list|(
name|arc
argument_list|)
operator|+
literal|1
control|)
block|{
name|arc
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arc
argument_list|,
name|cur
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|arc
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|new_name
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|interactive_option
operator|||
name|confirm
argument_list|(
literal|"delete"
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose_option
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"%s: Deleting %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|quote
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remove_any_file
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot remove"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|current_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|archive_dir
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CURRENT_FILE_NAME
block|}
end_function

end_unit

