begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Diff files from a tar archive.     Copyright 1988, 1992, 1993, 1994, 1996, 1997, 1999, 2000, 2001 Free    Software Foundation, Inc.     Written by John Gilmore, on 1987-04-30.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LINUX_FD_H
end_if

begin_include
include|#
directive|include
file|<linux/fd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_comment
comment|/* Spare space for messages, hopefully safe even after gettext.  */
end_comment

begin_define
define|#
directive|define
name|MESSAGE_BUFFER_SIZE
value|100
end_define

begin_comment
comment|/* Nonzero if we are verifying at the moment.  */
end_comment

begin_decl_stmt
name|int
name|now_verifying
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor for the file we are diffing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|diff_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Area for reading file contents into.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|diff_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize for a diff operation.  */
end_comment

begin_function
name|void
name|diff_init
parameter_list|(
name|void
parameter_list|)
block|{
name|diff_buffer
operator|=
name|valloc
argument_list|(
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diff_buffer
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sigh about something that differs by writing a MESSAGE to stdlis,    given MESSAGE is nonzero.  Also set the exit status if not already.  */
end_comment

begin_function
specifier|static
name|void
name|report_difference
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|quotearg_colon
argument_list|(
name|current_file_name
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
name|TAREXIT_SUCCESS
condition|)
name|exit_status
operator|=
name|TAREXIT_DIFFERS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a buffer returned by read_and_process and do nothing with it.  */
end_comment

begin_function
specifier|static
name|int
name|process_noop
parameter_list|(
name|size_t
name|size
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
comment|/* Yes, I know.  SIZE and DATA are unused in this function.  Some      compilers may even report it.  That's OK, just relax!  */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_rawdata
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|ssize_t
name|status
init|=
name|safe_read
argument_list|(
name|diff_handle
argument_list|,
name|diff_buffer
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
name|char
name|message
index|[
name|MESSAGE_BUFFER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|bytes
condition|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|read_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|_
argument_list|(
literal|"Could only read %lu of %lu bytes"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|status
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|diff_buffer
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Contents differ"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Directory contents, only for GNUTYPE_DUMPDIR.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dumpdir_cursor
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|process_dumpdir
parameter_list|(
name|size_t
name|bytes
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|dumpdir_cursor
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Contents differ"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dumpdir_cursor
operator|+=
name|bytes
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Some other routine wants SIZE bytes in the archive.  For each chunk    of the archive, call PROCESSOR with the size of the chunk, and the    address of the chunk it can work with.  The PROCESSOR should return    nonzero for success.  It it return error once, continue skipping    without calling PROCESSOR anymore.  */
end_comment

begin_function
specifier|static
name|void
name|read_and_process
parameter_list|(
name|off_t
name|size
parameter_list|,
name|int
function_decl|(
modifier|*
name|processor
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|union
name|block
modifier|*
name|data_block
decl_stmt|;
name|size_t
name|data_size
decl_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|save_sizeleft
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|data_size
operator|=
name|available_space_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_size
operator|>
name|size
condition|)
name|data_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|processor
call|)
argument_list|(
name|data_size
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|)
condition|)
name|processor
operator|=
name|process_noop
expr_stmt|;
name|set_next_block_after
argument_list|(
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
name|data_block
operator|->
name|buffer
operator|+
name|data_size
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|data_size
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|save_sizeleft
operator|-=
name|data_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* JK This routine should be used more often than it is ... look into    that.  Anyhow, what it does is translate the sparse information on the    header, and in any subsequent extended headers, into an array of    structures with true numbers, as opposed to character strings.  It    simply makes our life much easier, doing so many comparisons and such.    */
end_comment

begin_function
specifier|static
name|void
name|fill_in_sparse_array
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|counter
decl_stmt|;
comment|/* Allocate space for our scratch space; it's initially 10 elements      long, but can change in this routine if necessary.  */
name|sp_array_size
operator|=
literal|10
expr_stmt|;
name|sparsearray
operator|=
name|xmalloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There are at most five of these structures in the header itself;      read these in first.  */
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|SPARSES_IN_OLDGNU_HEADER
condition|;
name|counter
operator|++
control|)
block|{
comment|/* Compare to 0, or use !(int)..., for Pyramid's dumb compiler.  */
if|if
condition|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|numbytes
operator|==
literal|0
condition|)
break|break;
name|sparsearray
index|[
name|counter
index|]
operator|.
name|offset
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|counter
index|]
operator|.
name|numbytes
operator|=
name|SIZE_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
comment|/* If the header's extended, we gotta read in exhdr's till we're done.  */
if|if
condition|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|isextended
condition|)
block|{
comment|/* How far into the sparsearray we are `so far'.  */
specifier|static
name|int
name|so_far_ind
init|=
name|SPARSES_IN_OLDGNU_HEADER
decl_stmt|;
name|union
name|block
modifier|*
name|exhdr
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|exhdr
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exhdr
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|SPARSES_IN_SPARSE_HEADER
condition|;
name|counter
operator|++
control|)
block|{
if|if
condition|(
name|counter
operator|+
name|so_far_ind
operator|>
name|sp_array_size
operator|-
literal|1
condition|)
block|{
comment|/* We just ran out of room in our scratch area - 		     realloc it.  */
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
name|sparsearray
operator|=
name|xrealloc
argument_list|(
name|sparsearray
argument_list|,
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the character strings into offsets and sizes.  */
name|sparsearray
index|[
name|counter
operator|+
name|so_far_ind
index|]
operator|.
name|offset
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|exhdr
operator|->
name|sparse_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|counter
operator|+
name|so_far_ind
index|]
operator|.
name|numbytes
operator|=
name|SIZE_FROM_HEADER
argument_list|(
name|exhdr
operator|->
name|sparse_header
operator|.
name|sp
index|[
name|counter
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the last extended header for this file, we can 	     stop.  */
if|if
condition|(
operator|!
name|exhdr
operator|->
name|sparse_header
operator|.
name|isextended
condition|)
break|break;
name|so_far_ind
operator|+=
name|SPARSES_IN_SPARSE_HEADER
expr_stmt|;
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
comment|/* Be sure to skip past the last one.  */
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* JK Diff'ing a sparse file with its counterpart on the tar file is a    bit of a different story than a normal file.  First, we must know what    areas of the file to skip through, i.e., we need to construct a    sparsearray, which will hold all the information we need.  We must    compare small amounts of data at a time as we find it.  */
end_comment

begin_comment
comment|/* FIXME: This does not look very solid to me, at first glance.  Zero areas    are not checked, spurious sparse entries seemingly goes undetected, and    I'm not sure overall identical sparsity is verified.  */
end_comment

begin_function
specifier|static
name|void
name|diff_sparse_files
parameter_list|(
name|off_t
name|size_of_file
parameter_list|)
block|{
name|off_t
name|remaining_size
init|=
name|size_of_file
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|BLOCKSIZE
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|buffer_size
init|=
name|BLOCKSIZE
decl_stmt|;
name|union
name|block
modifier|*
name|data_block
init|=
literal|0
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|different
init|=
literal|0
decl_stmt|;
name|fill_in_sparse_array
argument_list|()
expr_stmt|;
while|while
condition|(
name|remaining_size
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|status
decl_stmt|;
name|size_t
name|chunk_size
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
if|#
directive|if
literal|0
block|off_t amount_read = 0;
endif|#
directive|endif
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|chunk_size
operator|=
name|sparsearray
index|[
name|counter
index|]
operator|.
name|numbytes
expr_stmt|;
if|if
condition|(
operator|!
name|chunk_size
condition|)
break|break;
name|offset
operator|=
name|sparsearray
index|[
name|counter
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|diff_handle
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|seek_error_details
argument_list|(
name|current_file_name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Take care to not run out of room in our buffer.  */
while|while
condition|(
name|buffer_size
operator|<
name|chunk_size
condition|)
block|{
if|if
condition|(
name|buffer_size
operator|*
literal|2
operator|<
name|buffer_size
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|buffer_size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|chunk_size
operator|>
name|BLOCKSIZE
condition|)
block|{
if|if
condition|(
name|status
operator|=
name|safe_read
argument_list|(
name|diff_handle
argument_list|,
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|,
name|status
operator|!=
name|BLOCKSIZE
condition|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|read_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|message
index|[
name|MESSAGE_BUFFER_SIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|_
argument_list|(
literal|"Could only read %lu of %lu bytes"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|status
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|chunk_size
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|)
condition|)
block|{
name|different
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|chunk_size
operator|-=
name|status
expr_stmt|;
name|remaining_size
operator|-=
name|status
expr_stmt|;
name|set_next_block_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|=
name|safe_read
argument_list|(
name|diff_handle
argument_list|,
name|buffer
argument_list|,
name|chunk_size
argument_list|)
operator|,
name|status
operator|!=
name|chunk_size
condition|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|read_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|message
index|[
name|MESSAGE_BUFFER_SIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|_
argument_list|(
literal|"Could only read %lu of %lu bytes"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|status
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|chunk_size
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|chunk_size
argument_list|)
condition|)
block|{
name|different
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|amount_read += chunk_size;       if (amount_read>= BLOCKSIZE) 	{ 	  amount_read = 0; 	  set_next_block_after (data_block); 	  data_block = find_next_block (); 	  if (!data_block) 	    FATAL_ERROR ((0, 0, _("Unexpected EOF in archive"))); 	}
endif|#
directive|endif
name|set_next_block_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
name|remaining_size
operator|-=
name|chunk_size
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If the number of bytes read isn't the number of bytes supposedly in      the file, they're different.  */
block|if (amount_read != size_of_file)     different = 1;
endif|#
directive|endif
name|set_next_block_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
if|if
condition|(
name|different
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Contents differ"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call either stat or lstat over STAT_DATA, depending on    --dereference (-h), for a file which should exist.  Diagnose any    problem.  Return nonzero for success, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_stat_data
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|struct
name|stat
modifier|*
name|stat_data
parameter_list|)
block|{
name|int
name|status
init|=
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|file_name
argument_list|,
name|stat_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"does not exist"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stat_error
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Diff a file against the archive.  */
end_comment

begin_function
name|void
name|diff_archive
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|stat_data
decl_stmt|;
name|size_t
name|name_length
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|utimbuf
name|restore_times
decl_stmt|;
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
name|decode_header
argument_list|(
name|current_header
argument_list|,
operator|&
name|current_stat
argument_list|,
operator|&
name|current_format
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Print the block from current_header and current_stat.  */
if|if
condition|(
name|verbose_option
condition|)
block|{
if|if
condition|(
name|now_verifying
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"Verify "
argument_list|)
argument_list|)
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
condition|)
block|{
default|default:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Unknown file type '%c', diffed as normal file"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|current_file_name
argument_list|)
operator|,
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|AREGTYPE
case|:
case|case
name|REGTYPE
case|:
case|case
name|GNUTYPE_SPARSE
case|:
case|case
name|CONTTYPE
case|:
comment|/* Appears to be a file.  See if it's really a directory.  */
name|name_length
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ISSLASH
argument_list|(
name|current_file_name
index|[
name|name_length
index|]
argument_list|)
condition|)
goto|goto
name|really_dir
goto|;
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
block|{
name|skip_member
argument_list|()
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"File type differs"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
operator|(
name|current_stat
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
operator|!=
operator|(
name|stat_data
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Mode differs"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|MSDOS
comment|/* stat() in djgpp's C library gives a constant number of 42 as the 	 uid and gid of a file.  So, comparing an FTP'ed archive just after 	 unpack would fail on MSDOS.  */
if|if
condition|(
name|stat_data
operator|.
name|st_uid
operator|!=
name|current_stat
operator|.
name|st_uid
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Uid differs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_data
operator|.
name|st_gid
operator|!=
name|current_stat
operator|.
name|st_gid
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Gid differs"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat_data
operator|.
name|st_mtime
operator|!=
name|current_stat
operator|.
name|st_mtime
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Mod time differs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|!=
name|GNUTYPE_SPARSE
operator|&&
name|stat_data
operator|.
name|st_size
operator|!=
name|current_stat
operator|.
name|st_size
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Size differs"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|diff_handle
operator|=
name|open
argument_list|(
name|current_file_name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_handle
operator|<
literal|0
condition|)
block|{
name|open_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|restore_times
operator|.
name|actime
operator|=
name|stat_data
operator|.
name|st_atime
expr_stmt|;
name|restore_times
operator|.
name|modtime
operator|=
name|stat_data
operator|.
name|st_mtime
expr_stmt|;
comment|/* Need to treat sparse files completely differently here.  */
if|if
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|GNUTYPE_SPARSE
condition|)
name|diff_sparse_files
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|save_totsize
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
comment|/* save_sizeleft is set in read_and_process.  */
block|}
name|read_and_process
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|process_rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|close
argument_list|(
name|diff_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|atime_preserve_option
condition|)
name|utime
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|restore_times
argument_list|)
expr_stmt|;
name|quit
label|:
break|break;
if|#
directive|if
operator|!
name|MSDOS
case|case
name|LNKTYPE
case|:
block|{
name|struct
name|stat
name|link_data
decl_stmt|;
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_link_name
argument_list|,
operator|&
name|link_data
argument_list|)
condition|)
break|break;
if|if
condition|(
name|stat_data
operator|.
name|st_dev
operator|!=
name|link_data
operator|.
name|st_dev
operator|||
name|stat_data
operator|.
name|st_ino
operator|!=
name|link_data
operator|.
name|st_ino
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|xmalloc
argument_list|(
name|MESSAGE_BUFFER_SIZE
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|current_link_name
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|_
argument_list|(
literal|"Not linked to %s"
argument_list|)
argument_list|,
name|quote
argument_list|(
name|current_link_name
argument_list|)
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* not MSDOS */
ifdef|#
directive|ifdef
name|HAVE_READLINK
case|case
name|SYMTYPE
case|:
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|current_link_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|linkbuf
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|status
operator|=
name|readlink
argument_list|(
name|current_file_name
argument_list|,
name|linkbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|readlink_warn
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
else|else
name|readlink_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|len
operator|||
name|strncmp
argument_list|(
name|current_link_name
argument_list|,
name|linkbuf
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Symlink differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|CHRTYPE
case|:
case|case
name|BLKTYPE
case|:
case|case
name|FIFOTYPE
case|:
comment|/* FIXME: deal with umask.  */
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
break|break;
if|if
condition|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|CHRTYPE
condition|?
operator|!
name|S_ISCHR
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
else|:
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|BLKTYPE
condition|?
operator|!
name|S_ISBLK
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
else|:
comment|/* current_header->header.typeflag == FIFOTYPE */
operator|!
name|S_ISFIFO
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"File type differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|CHRTYPE
operator|||
name|current_header
operator|->
name|header
operator|.
name|typeflag
operator|==
name|BLKTYPE
operator|)
operator|&&
name|current_stat
operator|.
name|st_rdev
operator|!=
name|stat_data
operator|.
name|st_rdev
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Device number differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|current_stat
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
operator|!=
operator|(
name|stat_data
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Mode differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GNUTYPE_DUMPDIR
case|:
block|{
name|char
modifier|*
name|dumpdir_buffer
init|=
name|get_directory_contents
argument_list|(
name|current_file_name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|save_totsize
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
comment|/* save_sizeleft is set in read_and_process.  */
block|}
if|if
condition|(
name|dumpdir_buffer
condition|)
block|{
name|dumpdir_cursor
operator|=
name|dumpdir_buffer
expr_stmt|;
name|read_and_process
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|process_dumpdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dumpdir_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|read_and_process
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|process_noop
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
block|}
case|case
name|DIRTYPE
case|:
comment|/* Check for trailing /.  */
name|name_length
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|really_dir
label|:
while|while
condition|(
name|name_length
operator|&&
name|ISSLASH
argument_list|(
name|current_file_name
index|[
name|name_length
index|]
argument_list|)
condition|)
name|current_file_name
index|[
name|name_length
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* zap / */
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"File type differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|current_stat
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
operator|!=
operator|(
name|stat_data
operator|.
name|st_mode
operator|&
name|MODE_ALL
operator|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Mode differs"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GNUTYPE_VOLHDR
case|:
break|break;
case|case
name|GNUTYPE_MULTIVOL
case|:
block|{
name|off_t
name|offset
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ISSLASH
argument_list|(
name|current_file_name
index|[
name|name_length
index|]
argument_list|)
condition|)
goto|goto
name|really_dir
goto|;
if|if
condition|(
operator|!
name|get_stat_data
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|stat_data
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|stat_data
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"File type differs"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
break|break;
block|}
name|offset
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_data
operator|.
name|st_size
operator|!=
name|current_stat
operator|.
name|st_size
operator|+
name|offset
condition|)
block|{
name|report_difference
argument_list|(
name|_
argument_list|(
literal|"Size differs"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
break|break;
block|}
name|diff_handle
operator|=
name|open
argument_list|(
name|current_file_name
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_handle
operator|<
literal|0
condition|)
block|{
name|open_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|diff_handle
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|seek_error_details
argument_list|(
name|current_file_name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|report_difference
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|save_totsize
operator|=
name|stat_data
operator|.
name|st_size
expr_stmt|;
comment|/* save_sizeleft is set in read_and_process.  */
block|}
name|read_and_process
argument_list|(
name|current_stat
operator|.
name|st_size
argument_list|,
name|process_rawdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|close
argument_list|(
name|diff_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|verify_volume
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|diff_buffer
condition|)
name|diff_init
argument_list|()
expr_stmt|;
comment|/* Verifying an archive is meant to check if the physical media got it      correctly, so try to defeat clever in-memory buffering pertaining to      this particular media.  On Linux, for example, the floppy drive would      not even be accessed for the whole verification.       The code was using fsync only when the ioctl is unavailable, but      Marty Leisner says that the ioctl does not work when not preceded by      fsync.  So, until we know better, or maybe to please Marty, let's do it      the unbelievable way :-).  */
if|#
directive|if
name|HAVE_FSYNC
name|fsync
argument_list|(
name|archive
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FDFLUSH
name|ioctl
argument_list|(
name|archive
argument_list|,
name|FDFLUSH
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MTIOCTOP
block|{
name|struct
name|mtop
name|operation
decl_stmt|;
name|int
name|status
decl_stmt|;
name|operation
operator|.
name|mt_op
operator|=
name|MTBSF
expr_stmt|;
name|operation
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|status
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
operator|,
name|status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EIO
operator|||
operator|(
name|status
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
operator|,
name|status
operator|<
literal|0
operator|)
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|rmtlseek
argument_list|(
name|archive
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Lseek failed.  Try a different method.  */
name|seek_warn
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MTIOCTOP
block|}
block|}
block|}
endif|#
directive|endif
name|access_mode
operator|=
name|ACCESS_READ
expr_stmt|;
name|now_verifying
operator|=
literal|1
expr_stmt|;
name|flush_read
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|read_header
name|status
init|=
name|read_header
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|HEADER_FAILURE
condition|)
block|{
name|int
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|status
operator|==
name|HEADER_FAILURE
condition|)
empty_stmt|;
block|{
name|counter
operator|++
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"VERIFY FAILURE: %d invalid header(s) detected"
argument_list|)
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|HEADER_ZERO_BLOCK
operator|||
name|status
operator|==
name|HEADER_END_OF_FILE
condition|)
break|break;
name|diff_archive
argument_list|()
expr_stmt|;
block|}
name|access_mode
operator|=
name|ACCESS_WRITE
expr_stmt|;
name|now_verifying
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

