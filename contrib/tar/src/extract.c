begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extract files from a tar archive.     Copyright 1988, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000,    2001 Free Software Foundation, Inc.     Written by John Gilmore, on 1985-11-19.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UTIME_H
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_decl_stmt
name|int
name|we_are_root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if our effective uid == 0 */
end_comment

begin_decl_stmt
specifier|static
name|mode_t
name|newdir_umask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* umask when creating new directories */
end_comment

begin_decl_stmt
specifier|static
name|mode_t
name|current_umask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current umask (which is set to 0 if -p) */
end_comment

begin_comment
comment|/* Status of the permissions of a file that we are extracting.  */
end_comment

begin_enum
enum|enum
name|permstatus
block|{
comment|/* This file may have existed already; its permissions are unknown.  */
name|UNKNOWN_PERMSTATUS
block|,
comment|/* This file was created using the permissions from the archive.  */
name|ARCHIVED_PERMSTATUS
block|,
comment|/* This is an intermediate directory; the archive did not specify      its permissions.  */
name|INTERDIR_PERMSTATUS
block|}
enum|;
end_enum

begin_comment
comment|/* List of directories whose statuses we need to extract after we've    finished extracting their subsidiary files.  If you consider each    contiguous subsequence of elements of the form [D]?[^D]*, where [D]    represents an element where AFTER_SYMLINKS is nonzero and [^D]    represents an element where AFTER_SYMLINKS is zero, then the head    of the subsequence has the longest name, and each non-head element    in the prefix is an ancestor (in the directory hierarchy) of the    preceding element.  */
end_comment

begin_struct
struct|struct
name|delayed_set_stat
block|{
name|struct
name|delayed_set_stat
modifier|*
name|next
decl_stmt|;
name|struct
name|stat
name|stat_info
decl_stmt|;
name|size_t
name|file_name_len
decl_stmt|;
name|mode_t
name|invert_permissions
decl_stmt|;
name|enum
name|permstatus
name|permstatus
decl_stmt|;
name|bool
name|after_symlinks
decl_stmt|;
name|char
name|file_name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|delayed_set_stat
modifier|*
name|delayed_set_stat_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of symbolic links whose creation we have delayed.  */
end_comment

begin_struct
struct|struct
name|delayed_symlink
block|{
comment|/* The next delayed symbolic link in the list.  */
name|struct
name|delayed_symlink
modifier|*
name|next
decl_stmt|;
comment|/* The device, inode number and last-modified time of the placeholder.  */
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
comment|/* The desired owner and group of the symbolic link.  */
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
comment|/* A list of sources for this symlink.  The sources are all to be        hard-linked together.  */
name|struct
name|string_list
modifier|*
name|sources
decl_stmt|;
comment|/* The desired target of the desired link.  */
name|char
name|target
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|delayed_symlink
modifier|*
name|delayed_symlink_head
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|string_list
block|{
name|struct
name|string_list
modifier|*
name|next
decl_stmt|;
name|char
name|string
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  Set up to extract files.  */
end_comment

begin_function
name|void
name|extr_init
parameter_list|(
name|void
parameter_list|)
block|{
name|we_are_root
operator|=
name|geteuid
argument_list|()
operator|==
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|same_permissions_option
operator|+=
name|we_are_root
expr_stmt|;
endif|#
directive|endif
name|same_owner_option
operator|+=
name|we_are_root
expr_stmt|;
name|xalloc_fail_func
operator|=
name|extract_finish
expr_stmt|;
comment|/* Option -p clears the kernel umask, so it does not affect proper      restoration of file permissions.  New intermediate directories will      comply with umask at start of program.  */
name|newdir_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|same_permissions_option
condition|)
name|current_umask
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|umask
argument_list|(
name|newdir_umask
argument_list|)
expr_stmt|;
comment|/* restore the kernel umask */
name|current_umask
operator|=
name|newdir_umask
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|same_permissions_option
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* If restoring permissions, restore the mode for FILE_NAME from    information given in *STAT_INFO (where *CURRENT_STAT_INFO gives    the current status if CURRENT_STAT_INFO is nonzero); otherwise invert the    INVERT_PERMISSIONS bits from the file's current permissions.    PERMSTATUS specifies the status of the file's permissions.    TYPEFLAG specifies the type of the file.  */
end_comment

begin_function
specifier|static
name|void
name|set_mode
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|stat_info
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|current_stat_info
parameter_list|,
name|mode_t
name|invert_permissions
parameter_list|,
name|enum
name|permstatus
name|permstatus
parameter_list|,
name|char
name|typeflag
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|same_permissions_option
operator|&&
name|permstatus
operator|!=
name|INTERDIR_PERMSTATUS
condition|)
block|{
name|mode
operator|=
name|stat_info
operator|->
name|st_mode
expr_stmt|;
comment|/* If we created the file and it has a usual mode, then its mode 	 is normally set correctly already.  But on many hosts, some 	 directories inherit the setgid bits from their parents, so we 	 we must set directories' modes explicitly.  */
if|if
condition|(
name|permstatus
operator|==
name|ARCHIVED_PERMSTATUS
operator|&&
operator|!
operator|(
name|mode
operator|&
operator|~
name|MODE_RWX
operator|)
operator|&&
name|typeflag
operator|!=
name|DIRTYPE
operator|&&
name|typeflag
operator|!=
name|GNUTYPE_DUMPDIR
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|invert_permissions
condition|)
return|return;
else|else
block|{
comment|/* We must inspect a directory's current permissions, since the 	 directory may have inherited its setgid bit from its parent.  	 INVERT_PERMISSIONS happens to be nonzero only for directories 	 that we created, so there's no point optimizing this code for 	 other cases.  */
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|current_stat_info
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_stat_info
operator|=
operator|&
name|st
expr_stmt|;
block|}
name|mode
operator|=
name|current_stat_info
operator|->
name|st_mode
operator|^
name|invert_permissions
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|file_name
argument_list|,
name|mode
operator|&
operator|~
name|current_umask
argument_list|)
operator|!=
literal|0
condition|)
name|chmod_error_details
argument_list|(
name|file_name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check time after successfully setting FILE_NAME's time stamp to T.  */
end_comment

begin_function
specifier|static
name|void
name|check_time
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|time_t
name|t
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|start_time
operator|<
name|t
operator|&&
operator|(
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
name|t
condition|)
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: time stamp %s is %lu s in the future"
argument_list|)
operator|,
name|file_name
operator|,
name|tartime
argument_list|(
name|t
argument_list|)
operator|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|t
operator|-
name|now
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore stat attributes (owner, group, mode and times) for    FILE_NAME, using information given in *STAT_INFO.    If CURRENT_STAT_INFO is nonzero, *CURRENT_STAT_INFO is the    file's currernt status.    If not restoring permissions, invert the    INVERT_PERMISSIONS bits from the file's current permissions.    PERMSTATUS specifies the status of the file's permissions.    TYPEFLAG specifies the type of the file.  */
end_comment

begin_comment
comment|/* FIXME: About proper restoration of symbolic link attributes, we still do    not have it right.  Pretesters' reports tell us we need further study and    probably more configuration.  For now, just use lchown if it exists, and    punt for the rest.  Sigh!  */
end_comment

begin_function
specifier|static
name|void
name|set_stat
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|stat_info
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|current_stat_info
parameter_list|,
name|mode_t
name|invert_permissions
parameter_list|,
name|enum
name|permstatus
name|permstatus
parameter_list|,
name|char
name|typeflag
parameter_list|)
block|{
name|struct
name|utimbuf
name|utimbuf
decl_stmt|;
if|if
condition|(
name|typeflag
operator|!=
name|SYMTYPE
condition|)
block|{
comment|/* We do the utime before the chmod because some versions of utime are 	 broken and trash the modes of the file.  */
if|if
condition|(
operator|!
name|touch_option
operator|&&
name|permstatus
operator|!=
name|INTERDIR_PERMSTATUS
condition|)
block|{
comment|/* We set the accessed time to `now', which is really the time we 	     started extracting files, unless incremental_option is used, in 	     which case .st_atime is used.  */
comment|/* FIXME: incremental_option should set ctime too, but how?  */
if|if
condition|(
name|incremental_option
condition|)
name|utimbuf
operator|.
name|actime
operator|=
name|stat_info
operator|->
name|st_atime
expr_stmt|;
else|else
name|utimbuf
operator|.
name|actime
operator|=
name|start_time
expr_stmt|;
name|utimbuf
operator|.
name|modtime
operator|=
name|stat_info
operator|->
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file_name
argument_list|,
operator|&
name|utimbuf
argument_list|)
operator|<
literal|0
condition|)
name|utime_error
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
else|else
block|{
name|check_time
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_atime
argument_list|)
expr_stmt|;
name|check_time
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Some systems allow non-root users to give files away.  Once this 	 done, it is not possible anymore to change file permissions, so we 	 have to set permissions prior to possibly giving files away.  */
name|set_mode
argument_list|(
name|file_name
argument_list|,
name|stat_info
argument_list|,
name|current_stat_info
argument_list|,
name|invert_permissions
argument_list|,
name|permstatus
argument_list|,
name|typeflag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
name|same_owner_option
operator|&&
name|permstatus
operator|!=
name|INTERDIR_PERMSTATUS
condition|)
block|{
comment|/* When lchown exists, it should be used to change the attributes of 	 the symbolic link itself.  In this case, a mere chown would change 	 the attributes of the file the symbolic link is pointing to, and 	 should be avoided.  */
if|if
condition|(
name|typeflag
operator|==
name|SYMTYPE
condition|)
block|{
if|#
directive|if
name|HAVE_LCHOWN
if|if
condition|(
name|lchown
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_uid
argument_list|,
name|stat_info
operator|->
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
name|chown_error_details
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_uid
argument_list|,
name|stat_info
operator|->
name|st_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|chown
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_uid
argument_list|,
name|stat_info
operator|->
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
name|chown_error_details
argument_list|(
name|file_name
argument_list|,
name|stat_info
operator|->
name|st_uid
argument_list|,
name|stat_info
operator|->
name|st_gid
argument_list|)
expr_stmt|;
comment|/* On a few systems, and in particular, those allowing to give files 	     away, changing the owner or group destroys the suid or sgid bits. 	     So let's attempt setting these bits once more.  */
if|if
condition|(
name|stat_info
operator|->
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
condition|)
name|set_mode
argument_list|(
name|file_name
argument_list|,
name|stat_info
argument_list|,
literal|0
argument_list|,
name|invert_permissions
argument_list|,
name|permstatus
argument_list|,
name|typeflag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remember to restore stat attributes (owner, group, mode and times)    for the directory FILE_NAME, using information given in *STAT_INFO,    once we stop extracting files into that directory.    If not restoring permissions, remember to invert the    INVERT_PERMISSIONS bits from the file's current permissions.    PERMSTATUS specifies the status of the file's permissions.  */
end_comment

begin_function
specifier|static
name|void
name|delay_set_stat
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|stat_info
parameter_list|,
name|mode_t
name|invert_permissions
parameter_list|,
name|enum
name|permstatus
name|permstatus
parameter_list|)
block|{
name|size_t
name|file_name_len
init|=
name|strlen
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
name|struct
name|delayed_set_stat
modifier|*
name|data
init|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|delayed_set_stat
argument_list|,
name|file_name
argument_list|)
operator|+
name|file_name_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|data
operator|->
name|file_name_len
operator|=
name|file_name_len
expr_stmt|;
name|strcpy
argument_list|(
name|data
operator|->
name|file_name
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|data
operator|->
name|invert_permissions
operator|=
name|invert_permissions
expr_stmt|;
name|data
operator|->
name|permstatus
operator|=
name|permstatus
expr_stmt|;
name|data
operator|->
name|after_symlinks
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|stat_info
operator|=
operator|*
name|stat_info
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|delayed_set_stat_head
expr_stmt|;
name|delayed_set_stat_head
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the delayed_set_stat info for an intermediate directory    created on the path to DIR_NAME.  The intermediate directory turned    out to be the same as this directory, e.g. due to ".." or symbolic    links.  *DIR_STAT_INFO is the status of the directory.  */
end_comment

begin_function
specifier|static
name|void
name|repair_delayed_set_stat
parameter_list|(
name|char
specifier|const
modifier|*
name|dir_name
parameter_list|,
name|struct
name|stat
specifier|const
modifier|*
name|dir_stat_info
parameter_list|)
block|{
name|struct
name|delayed_set_stat
modifier|*
name|data
decl_stmt|;
for|for
control|(
name|data
operator|=
name|delayed_set_stat_head
init|;
name|data
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|data
operator|->
name|file_name
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|data
operator|->
name|file_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|st
operator|.
name|st_dev
operator|==
name|dir_stat_info
operator|->
name|st_dev
operator|&&
name|st
operator|.
name|st_ino
operator|==
name|dir_stat_info
operator|->
name|st_ino
condition|)
block|{
name|data
operator|->
name|stat_info
operator|=
name|current_stat
expr_stmt|;
name|data
operator|->
name|invert_permissions
operator|=
operator|(
name|MODE_RWX
operator|&
operator|(
name|current_stat
operator|.
name|st_mode
operator|^
name|st
operator|.
name|st_mode
operator|)
operator|)
expr_stmt|;
name|data
operator|->
name|permstatus
operator|=
name|ARCHIVED_PERMSTATUS
expr_stmt|;
return|return;
block|}
block|}
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Unexpected inconsistency when making directory"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|dir_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After a file/link/symlink/directory creation has failed, see if    it's because some required directory was not present, and if so,    create all required directories.  Return non-zero if a directory    was created.  */
end_comment

begin_function
specifier|static
name|int
name|make_directories
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|char
modifier|*
name|cursor0
init|=
name|file_name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* points into path */
name|int
name|did_something
init|=
literal|0
decl_stmt|;
comment|/* did we do anything yet? */
name|int
name|mode
decl_stmt|;
name|int
name|invert_permissions
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|cursor
operator|=
name|cursor0
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISSLASH
argument_list|(
operator|*
name|cursor
argument_list|)
condition|)
continue|continue;
comment|/* Avoid mkdir of empty string, if leading or double '/'.  */
if|if
condition|(
name|cursor
operator|==
name|cursor0
operator|||
name|ISSLASH
argument_list|(
name|cursor
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Avoid mkdir where last part of path is "." or "..".  */
if|if
condition|(
name|cursor
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|cursor
operator|==
name|cursor0
operator|+
literal|1
operator|||
name|ISSLASH
argument_list|(
name|cursor
index|[
operator|-
literal|2
index|]
argument_list|)
operator|||
operator|(
name|cursor
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|cursor
operator|==
name|cursor0
operator|+
literal|2
operator|||
name|ISSLASH
argument_list|(
name|cursor
index|[
operator|-
literal|3
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
continue|continue;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate the path there */
name|mode
operator|=
name|MODE_RWX
operator|&
operator|~
name|newdir_umask
expr_stmt|;
name|invert_permissions
operator|=
name|we_are_root
condition|?
literal|0
else|:
name|MODE_WXUSR
operator|&
operator|~
name|mode
expr_stmt|;
name|status
operator|=
name|mkdir
argument_list|(
name|file_name
argument_list|,
name|mode
operator|^
name|invert_permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* Create a struct delayed_set_stat even if 	     invert_permissions is zero, because 	     repair_delayed_set_stat may need to update the struct.  */
name|delay_set_stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|current_stat
comment|/* ignored */
argument_list|,
name|invert_permissions
argument_list|,
name|INTERDIR_PERMSTATUS
argument_list|)
expr_stmt|;
name|print_for_mkdir
argument_list|(
name|file_name
argument_list|,
name|cursor
operator|-
name|file_name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|did_something
operator|=
literal|1
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
operator|*
name|cursor
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
if|#
directive|if
name|MSDOS
comment|/* Turbo C mkdir gives a funny errno.  */
operator|||
name|errno
operator|==
name|EACCES
endif|#
directive|endif
condition|)
comment|/* Directory already exists.  */
continue|continue;
comment|/* Some other error in the mkdir.  We return to the caller.  */
break|break;
block|}
return|return
name|did_something
return|;
comment|/* tell them to retry if we made one */
block|}
end_function

begin_comment
comment|/* Prepare to extract a file.    Return zero if extraction should not proceed.  */
end_comment

begin_function
specifier|static
name|int
name|prepare_to_extract
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|)
block|{
if|if
condition|(
name|to_stdout_option
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|old_files_option
operator|==
name|UNLINK_FIRST_OLD_FILES
operator|&&
operator|!
name|remove_any_file
argument_list|(
name|file_name
argument_list|,
name|recursive_unlink_option
argument_list|)
operator|&&
name|errno
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|unlink_error
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt repairing what went wrong with the extraction.  Delete an    already existing file or create missing intermediate directories.    Return nonzero if we somewhat increased our chances at a successful    extraction.  errno is properly restored on zero return.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_recoverable
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|int
modifier|*
name|interdir_made
parameter_list|)
block|{
if|if
condition|(
operator|*
name|interdir_made
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* Remove an old file, if the options allow this.  */
switch|switch
condition|(
name|old_files_option
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|DEFAULT_OLD_FILES
case|:
case|case
name|OVERWRITE_OLD_DIRS
case|:
case|case
name|OVERWRITE_OLD_FILES
case|:
block|{
name|int
name|r
init|=
name|remove_any_file
argument_list|(
name|file_name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
case|case
name|ENOENT
case|:
comment|/* Attempt creating missing intermediate directories.  */
if|if
condition|(
operator|!
name|make_directories
argument_list|(
name|file_name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|interdir_made
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
default|default:
comment|/* Just say we can't do anything about it...  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|extract_sparse_file
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
modifier|*
name|sizeleft
parameter_list|,
name|off_t
name|totalsize
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|sparse_ind
init|=
literal|0
decl_stmt|;
comment|/* assuming sizeleft is initially totalsize */
while|while
condition|(
operator|*
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|union
name|block
modifier|*
name|data_block
init|=
name|find_next_block
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|seek_error_details
argument_list|(
name|name
argument_list|,
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
name|written
operator|=
name|sparsearray
index|[
name|sparse_ind
operator|++
index|]
operator|.
name|numbytes
expr_stmt|;
while|while
condition|(
name|written
operator|>
name|BLOCKSIZE
condition|)
block|{
name|count
operator|=
name|full_write
argument_list|(
name|fd
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|written
operator|-=
name|count
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|BLOCKSIZE
condition|)
block|{
name|write_error_details
argument_list|(
name|name
argument_list|,
name|count
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_next_block_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|count
operator|=
name|full_write
argument_list|(
name|fd
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|written
argument_list|)
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|written
condition|)
block|{
name|write_error_details
argument_list|(
name|name
argument_list|,
name|count
argument_list|,
name|written
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_next_block_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fix the statuses of all directories whose statuses need fixing, and    which are not ancestors of FILE_NAME.  If AFTER_SYMLINKS is    nonzero, do this for all such directories; otherwise, stop at the    first directory that is marked to be fixed up only after delayed    symlinks are applied.  */
end_comment

begin_function
specifier|static
name|void
name|apply_nonancestor_delayed_set_stat
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|bool
name|after_symlinks
parameter_list|)
block|{
name|size_t
name|file_name_len
init|=
name|strlen
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
name|bool
name|check_for_renamed_directories
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|delayed_set_stat_head
condition|)
block|{
name|struct
name|delayed_set_stat
modifier|*
name|data
init|=
name|delayed_set_stat_head
decl_stmt|;
name|bool
name|skip_this_one
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|stat
specifier|const
modifier|*
name|current_stat_info
init|=
literal|0
decl_stmt|;
name|check_for_renamed_directories
operator||=
name|data
operator|->
name|after_symlinks
expr_stmt|;
if|if
condition|(
name|after_symlinks
operator|<
name|data
operator|->
name|after_symlinks
operator|||
operator|(
name|data
operator|->
name|file_name_len
operator|<
name|file_name_len
operator|&&
name|file_name
index|[
name|data
operator|->
name|file_name_len
index|]
operator|&&
operator|(
name|ISSLASH
argument_list|(
name|file_name
index|[
name|data
operator|->
name|file_name_len
index|]
argument_list|)
operator|||
name|ISSLASH
argument_list|(
name|file_name
index|[
name|data
operator|->
name|file_name_len
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|file_name
argument_list|,
name|data
operator|->
name|file_name
argument_list|,
name|data
operator|->
name|file_name_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|check_for_renamed_directories
condition|)
block|{
name|current_stat_info
operator|=
operator|&
name|st
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|data
operator|->
name|file_name
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|data
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|skip_this_one
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|st
operator|.
name|st_dev
operator|==
name|data
operator|->
name|stat_info
operator|.
name|st_dev
operator|&&
operator|(
name|st
operator|.
name|st_ino
operator|==
name|data
operator|->
name|stat_info
operator|.
name|st_ino
operator|)
operator|)
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Directory renamed before its status could be extracted"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|data
operator|->
name|file_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_this_one
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip_this_one
condition|)
name|set_stat
argument_list|(
name|data
operator|->
name|file_name
argument_list|,
operator|&
name|data
operator|->
name|stat_info
argument_list|,
name|current_stat_info
argument_list|,
name|data
operator|->
name|invert_permissions
argument_list|,
name|data
operator|->
name|permstatus
argument_list|,
name|DIRTYPE
argument_list|)
expr_stmt|;
name|delayed_set_stat_head
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extract a file from the archive.  */
end_comment

begin_function
name|void
name|extract_archive
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|block
modifier|*
name|data_block
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|name_length
decl_stmt|;
name|size_t
name|written
decl_stmt|;
name|int
name|openflag
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|size_t
name|skipcrud
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|int
name|interdir_made
init|=
literal|0
decl_stmt|;
name|char
name|typeflag
decl_stmt|;
name|union
name|block
modifier|*
name|exhdr
decl_stmt|;
define|#
directive|define
name|CURRENT_FILE_NAME
value|(skipcrud + current_file_name)
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
name|decode_header
argument_list|(
name|current_header
argument_list|,
operator|&
name|current_stat
argument_list|,
operator|&
name|current_format
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive_option
operator|&&
operator|!
name|confirm
argument_list|(
literal|"extract"
argument_list|,
name|current_file_name
argument_list|)
condition|)
block|{
name|skip_member
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Print the block from current_header and current_stat.  */
if|if
condition|(
name|verbose_option
condition|)
name|print_header
argument_list|()
expr_stmt|;
comment|/* Check for fully specified file names and other atrocities.  */
name|skipcrud
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|absolute_names_option
condition|)
block|{
if|if
condition|(
name|contains_dot_dot
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Member name contains `..'"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
return|return;
block|}
name|skipcrud
operator|=
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
name|CURRENT_FILE_NAME
index|[
literal|0
index|]
argument_list|)
condition|)
name|skipcrud
operator|++
expr_stmt|;
if|if
condition|(
name|skipcrud
condition|)
block|{
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Removing leading `%.*s' from member names"
argument_list|)
operator|,
operator|(
name|int
operator|)
name|skipcrud
operator|,
name|current_file_name
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|apply_nonancestor_delayed_set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Take a safety backup of a previously existing file.  */
if|if
condition|(
name|backup_option
operator|&&
operator|!
name|to_stdout_option
condition|)
if|if
condition|(
operator|!
name|maybe_backup_file
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Was unable to backup this file"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Extract the archive entry according to its type.  */
name|typeflag
operator|=
name|current_header
operator|->
name|header
operator|.
name|typeflag
expr_stmt|;
switch|switch
condition|(
name|typeflag
condition|)
block|{
comment|/* JK - What we want to do if the file is sparse is loop through 	 the array of sparse structures in the header and read in and 	 translate the character strings representing 1) the offset at 	 which to write and 2) how many bytes to write into numbers, 	 which we store into the scratch array, "sparsearray".  This 	 array makes our life easier the same way it did in creating the 	 tar file that had to deal with a sparse file.  	 After we read in the first five (at most) sparse structures, we 	 check to see if the file has an extended header, i.e., if more 	 sparse structures are needed to describe the contents of the new 	 file.  If so, we read in the extended headers and continue to 	 store their contents into the sparsearray.  */
case|case
name|GNUTYPE_SPARSE
case|:
name|sp_array_size
operator|=
literal|10
expr_stmt|;
name|sparsearray
operator|=
name|xmalloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|SPARSES_IN_OLDGNU_HEADER
condition|;
name|counter
operator|++
control|)
block|{
name|struct
name|sparse
specifier|const
modifier|*
name|s
init|=
operator|&
name|current_header
operator|->
name|oldgnu_header
operator|.
name|sp
index|[
name|counter
index|]
decl_stmt|;
name|sparsearray
index|[
name|counter
index|]
operator|.
name|offset
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|s
operator|->
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|counter
index|]
operator|.
name|numbytes
operator|=
name|SIZE_FROM_HEADER
argument_list|(
name|s
operator|->
name|numbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sparsearray
index|[
name|counter
index|]
operator|.
name|numbytes
condition|)
break|break;
block|}
if|if
condition|(
name|current_header
operator|->
name|oldgnu_header
operator|.
name|isextended
condition|)
block|{
comment|/* Read in the list of extended headers and translate them 	     into the sparsearray as before.  Note that this 	     invalidates current_header.  */
comment|/* static */
name|int
name|ind
init|=
name|SPARSES_IN_OLDGNU_HEADER
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|exhdr
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exhdr
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|SPARSES_IN_SPARSE_HEADER
condition|;
name|counter
operator|++
control|)
block|{
name|struct
name|sparse
specifier|const
modifier|*
name|s
init|=
operator|&
name|exhdr
operator|->
name|sparse_header
operator|.
name|sp
index|[
name|counter
index|]
decl_stmt|;
if|if
condition|(
name|counter
operator|+
name|ind
operator|>
name|sp_array_size
operator|-
literal|1
condition|)
block|{
comment|/* Realloc the scratch area since we've run out of 			 room.  */
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
name|sparsearray
operator|=
name|xrealloc
argument_list|(
name|sparsearray
argument_list|,
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|numbytes
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
name|sparsearray
index|[
name|counter
operator|+
name|ind
index|]
operator|.
name|offset
operator|=
name|OFF_FROM_HEADER
argument_list|(
name|s
operator|->
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|counter
operator|+
name|ind
index|]
operator|.
name|numbytes
operator|=
name|SIZE_FROM_HEADER
argument_list|(
name|s
operator|->
name|numbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exhdr
operator|->
name|sparse_header
operator|.
name|isextended
condition|)
break|break;
else|else
block|{
name|ind
operator|+=
name|SPARSES_IN_SPARSE_HEADER
expr_stmt|;
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
name|set_next_block_after
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|AREGTYPE
case|:
case|case
name|REGTYPE
case|:
case|case
name|CONTTYPE
case|:
comment|/* Appears to be a file.  But BSD tar uses the convention that a slash 	 suffix means a directory.  */
name|name_length
operator|=
name|strlen
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|<
name|name_length
operator|&&
name|CURRENT_FILE_NAME
index|[
name|name_length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|really_dir
goto|;
comment|/* FIXME: deal with protection issues.  */
name|again_file
label|:
name|openflag
operator|=
operator|(
name|O_WRONLY
operator||
name|O_BINARY
operator||
name|O_CREAT
operator||
operator|(
name|old_files_option
operator|==
name|OVERWRITE_OLD_FILES
condition|?
name|O_TRUNC
else|:
name|O_EXCL
operator|)
operator|)
expr_stmt|;
name|mode
operator|=
name|current_stat
operator|.
name|st_mode
operator|&
name|MODE_RWX
operator|&
operator|~
name|current_umask
expr_stmt|;
if|if
condition|(
name|to_stdout_option
condition|)
block|{
name|fd
operator|=
name|STDOUT_FILENO
expr_stmt|;
goto|goto
name|extract_file
goto|;
block|}
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
block|{
name|skip_member
argument_list|()
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|O_CTG
comment|/* Contiguous files (on the Masscomp) have to specify the size in 	 the open call that creates them.  */
if|if
condition|(
name|typeflag
operator|==
name|CONTTYPE
condition|)
name|fd
operator|=
name|open
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|openflag
operator||
name|O_CTG
argument_list|,
name|mode
argument_list|,
name|current_stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|open
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|openflag
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not O_CTG */
if|if
condition|(
name|typeflag
operator|==
name|CONTTYPE
condition|)
block|{
specifier|static
name|int
name|conttype_diagnosed
decl_stmt|;
if|if
condition|(
operator|!
name|conttype_diagnosed
condition|)
block|{
name|conttype_diagnosed
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Extracting contiguous files as regular files"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fd
operator|=
name|open
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|openflag
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not O_CTG */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
goto|goto
name|again_file
goto|;
name|open_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
block|}
name|extract_file
label|:
if|if
condition|(
name|typeflag
operator|==
name|GNUTYPE_SPARSE
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|name_length_bis
decl_stmt|;
comment|/* Kludge alert.  NAME is assigned to header.name because 	     during the extraction, the space that contains the header 	     will get scribbled on, and the name will get munged, so any 	     error messages that happen to contain the filename will look 	     REAL interesting unless we do this.  */
name|name_length_bis
operator|=
name|strlen
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|name_length_bis
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|CURRENT_FILE_NAME
argument_list|,
name|name_length_bis
argument_list|)
expr_stmt|;
name|size
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
name|extract_sparse_file
argument_list|(
name|fd
argument_list|,
operator|&
name|size
argument_list|,
name|current_stat
operator|.
name|st_size
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|size
operator|=
name|current_stat
operator|.
name|st_size
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|multi_volume_option
condition|)
block|{
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|save_totsize
operator|=
name|current_stat
operator|.
name|st_size
expr_stmt|;
name|save_sizeleft
operator|=
name|size
expr_stmt|;
block|}
comment|/* Locate data, determine max length writeable, write it, 	       block that we have used the data, then check if the write 	       worked.  */
name|data_block
operator|=
name|find_next_block
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data_block
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Unexpected EOF in archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: What happens, then?  */
block|}
name|written
operator|=
name|available_space_after
argument_list|(
name|data_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|full_write
argument_list|(
name|fd
argument_list|,
name|data_block
operator|->
name|buffer
argument_list|,
name|written
argument_list|)
expr_stmt|;
name|size
operator|-=
name|count
expr_stmt|;
name|set_next_block_after
argument_list|(
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
name|data_block
operator|->
name|buffer
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|written
condition|)
block|{
name|write_error_details
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|count
argument_list|,
name|written
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|skip_file
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_volume_option
condition|)
name|assign_string
argument_list|(
operator|&
name|save_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If writing to stdout, don't try to do anything to the filename; 	 it doesn't exist, or we don't want to touch it anyway.  */
if|if
condition|(
name|to_stdout_option
condition|)
break|break;
name|status
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|close_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
block|}
name|set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|current_stat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|old_files_option
operator|==
name|OVERWRITE_OLD_FILES
condition|?
name|UNKNOWN_PERMSTATUS
else|:
name|ARCHIVED_PERMSTATUS
operator|)
argument_list|,
name|typeflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMTYPE
case|:
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
break|break;
if|if
condition|(
name|absolute_names_option
operator|||
operator|!
operator|(
name|ISSLASH
argument_list|(
name|current_link_name
index|[
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|current_link_name
argument_list|)
index|]
argument_list|)
operator|||
name|contains_dot_dot
argument_list|(
name|current_link_name
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|status
operator|=
name|symlink
argument_list|(
name|current_link_name
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
operator|,
name|status
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|current_stat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SYMTYPE
argument_list|)
expr_stmt|;
else|else
name|symlink_error
argument_list|(
name|current_link_name
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbolic link is potentially dangerous.  Don't 	     create it now; instead, create a placeholder file, which 	     will be replaced after other extraction is done.  */
name|struct
name|stat
name|st
decl_stmt|;
while|while
condition|(
name|fd
operator|=
name|open
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0
argument_list|)
operator|,
name|fd
operator|<
literal|0
condition|)
if|if
condition|(
operator|!
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
break|break;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|open_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stat_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|delayed_set_stat
modifier|*
name|h
decl_stmt|;
name|struct
name|delayed_symlink
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|delayed_symlink
argument_list|,
name|target
argument_list|)
operator|+
name|strlen
argument_list|(
name|current_link_name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|delayed_symlink_head
expr_stmt|;
name|delayed_symlink_head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|p
operator|->
name|ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|p
operator|->
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|p
operator|->
name|uid
operator|=
name|current_stat
operator|.
name|st_uid
expr_stmt|;
name|p
operator|->
name|gid
operator|=
name|current_stat
operator|.
name|st_gid
expr_stmt|;
name|p
operator|->
name|sources
operator|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|string_list
argument_list|,
name|string
argument_list|)
operator|+
name|strlen
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|sources
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|sources
operator|->
name|string
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|target
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
name|h
operator|=
name|delayed_set_stat_head
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|!
name|h
operator|->
name|after_symlinks
operator|&&
name|strncmp
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|h
operator|->
name|file_name
argument_list|,
name|h
operator|->
name|file_name_len
argument_list|)
operator|==
literal|0
operator|&&
name|ISSLASH
argument_list|(
name|CURRENT_FILE_NAME
index|[
name|h
operator|->
name|file_name_len
index|]
argument_list|)
operator|&&
operator|(
name|base_name
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|==
name|CURRENT_FILE_NAME
operator|+
name|h
operator|->
name|file_name_len
operator|+
literal|1
operator|)
condition|)
block|{
do|do
block|{
name|h
operator|->
name|after_symlinks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|h
operator|->
name|file_name
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
name|stat_error
argument_list|(
name|h
operator|->
name|file_name
argument_list|)
expr_stmt|;
else|else
block|{
name|h
operator|->
name|stat_info
operator|.
name|st_dev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|h
operator|->
name|stat_info
operator|.
name|st_ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|h
operator|=
name|h
operator|->
name|next
operator|)
operator|&&
operator|!
name|h
operator|->
name|after_symlinks
condition|)
do|;
block|}
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
else|#
directive|else
block|{
specifier|static
name|int
name|warned_once
decl_stmt|;
if|if
condition|(
operator|!
name|warned_once
condition|)
block|{
name|warned_once
operator|=
literal|1
expr_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Attempting extraction of symbolic links as hard links"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|typeflag
operator|=
name|LNKTYPE
expr_stmt|;
comment|/* Fall through.  */
endif|#
directive|endif
case|case
name|LNKTYPE
case|:
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
break|break;
name|again_link
label|:
block|{
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
name|int
name|e
decl_stmt|;
name|size_t
name|skiplinkcrud
decl_stmt|;
if|if
condition|(
name|absolute_names_option
condition|)
name|skiplinkcrud
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|skiplinkcrud
operator|=
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|current_link_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSLASH
argument_list|(
name|current_link_name
index|[
name|skiplinkcrud
index|]
argument_list|)
condition|)
name|skiplinkcrud
operator|++
expr_stmt|;
block|}
comment|/* MSDOS does not implement links.  However, djgpp's link() actually 	   copies the file.  */
name|status
operator|=
name|link
argument_list|(
name|current_link_name
operator|+
name|skiplinkcrud
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|struct
name|delayed_symlink
modifier|*
name|ds
init|=
name|delayed_symlink_head
decl_stmt|;
if|if
condition|(
name|ds
operator|&&
name|stat
argument_list|(
name|current_link_name
argument_list|,
operator|&
name|st1
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
init|;
name|ds
condition|;
name|ds
operator|=
name|ds
operator|->
name|next
control|)
if|if
condition|(
name|ds
operator|->
name|dev
operator|==
name|st1
operator|.
name|st_dev
operator|&&
name|ds
operator|->
name|ino
operator|==
name|st1
operator|.
name|st_ino
operator|&&
name|ds
operator|->
name|mtime
operator|==
name|st1
operator|.
name|st_mtime
condition|)
block|{
name|struct
name|string_list
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|string_list
argument_list|,
name|string
argument_list|)
operator|+
name|strlen
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|ds
operator|->
name|sources
expr_stmt|;
name|ds
operator|->
name|sources
operator|=
name|p
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
goto|goto
name|again_link
goto|;
if|if
condition|(
name|incremental_option
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
break|break;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|current_link_name
argument_list|,
operator|&
name|st1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|st2
argument_list|)
operator|==
literal|0
operator|&&
name|st1
operator|.
name|st_dev
operator|==
name|st2
operator|.
name|st_dev
operator|&&
name|st1
operator|.
name|st_ino
operator|==
name|st2
operator|.
name|st_ino
condition|)
break|break;
name|link_error
argument_list|(
name|current_link_name
argument_list|,
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|S_IFCHR
case|case
name|CHRTYPE
case|:
name|current_stat
operator|.
name|st_mode
operator||=
name|S_IFCHR
expr_stmt|;
goto|goto
name|make_node
goto|;
endif|#
directive|endif
if|#
directive|if
name|S_IFBLK
case|case
name|BLKTYPE
case|:
name|current_stat
operator|.
name|st_mode
operator||=
name|S_IFBLK
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|S_IFCHR
operator|||
name|S_IFBLK
name|make_node
label|:
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
break|break;
name|status
operator|=
name|mknod
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|current_stat
operator|.
name|st_mode
argument_list|,
name|current_stat
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
goto|goto
name|make_node
goto|;
name|mknod_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|current_stat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ARCHIVED_PERMSTATUS
argument_list|,
name|typeflag
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|HAVE_MKFIFO
operator|||
name|defined
name|mkfifo
case|case
name|FIFOTYPE
case|:
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
break|break;
while|while
condition|(
name|status
operator|=
name|mkfifo
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|current_stat
operator|.
name|st_mode
argument_list|)
operator|,
name|status
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|current_stat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ARCHIVED_PERMSTATUS
argument_list|,
name|typeflag
argument_list|)
expr_stmt|;
else|else
block|{
name|mkfifo_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|DIRTYPE
case|:
case|case
name|GNUTYPE_DUMPDIR
case|:
name|name_length
operator|=
name|strlen
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
name|really_dir
label|:
comment|/* Remove any redundant trailing "/"s.  */
while|while
condition|(
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|<
name|name_length
operator|&&
name|CURRENT_FILE_NAME
index|[
name|name_length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|name_length
operator|--
expr_stmt|;
name|CURRENT_FILE_NAME
index|[
name|name_length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|incremental_option
condition|)
block|{
comment|/* Read the entry and delete files that aren't listed in the 	     archive.  */
name|gnu_restore
argument_list|(
name|skipcrud
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeflag
operator|==
name|GNUTYPE_DUMPDIR
condition|)
name|skip_member
argument_list|()
expr_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
if|if
condition|(
operator|!
name|prepare_to_extract
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
condition|)
break|break;
block|}
name|mode
operator|=
operator|(
operator|(
name|current_stat
operator|.
name|st_mode
operator||
operator|(
name|we_are_root
condition|?
literal|0
else|:
name|MODE_WXUSR
operator|)
operator|)
operator|&
name|MODE_RWX
operator|)
expr_stmt|;
name|again_dir
label|:
name|status
operator|=
name|mkdir
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
operator|&&
operator|(
name|interdir_made
operator|||
name|old_files_option
operator|==
name|OVERWRITE_OLD_DIRS
operator|||
name|old_files_option
operator|==
name|OVERWRITE_OLD_FILES
operator|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interdir_made
condition|)
block|{
name|repair_delayed_set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|mode
operator|=
name|st
operator|.
name|st_mode
operator|&
operator|~
name|current_umask
expr_stmt|;
goto|goto
name|directory_exists
goto|;
block|}
block|}
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|maybe_recoverable
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|interdir_made
argument_list|)
condition|)
goto|goto
name|again_dir
goto|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|mkdir_error
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|directory_exists
label|:
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|old_files_option
operator|==
name|OVERWRITE_OLD_DIRS
operator|||
name|old_files_option
operator|==
name|OVERWRITE_OLD_FILES
condition|)
name|delay_set_stat
argument_list|(
name|CURRENT_FILE_NAME
argument_list|,
operator|&
name|current_stat
argument_list|,
name|MODE_RWX
operator|&
operator|(
name|mode
operator|^
name|current_stat
operator|.
name|st_mode
operator|)
argument_list|,
operator|(
name|status
operator|==
literal|0
condition|?
name|ARCHIVED_PERMSTATUS
else|:
name|UNKNOWN_PERMSTATUS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_VOLHDR
case|:
if|if
condition|(
name|verbose_option
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"Reading %s\n"
argument_list|)
argument_list|,
name|quote
argument_list|(
name|current_file_name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GNUTYPE_NAMES
case|:
if|if
condition|(
name|allow_name_mangling_option
condition|)
name|extract_mangle
argument_list|()
expr_stmt|;
else|else
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"GNUTYPE_NAMES mangling ignored"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GNUTYPE_MULTIVOL
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Cannot extract -- file is continued from another volume"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|current_file_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
case|case
name|GNUTYPE_LONGNAME
case|:
case|case
name|GNUTYPE_LONGLINK
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Visible long name error"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_member
argument_list|()
expr_stmt|;
if|if
condition|(
name|backup_option
condition|)
name|undo_last_backup
argument_list|()
expr_stmt|;
break|break;
default|default:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Unknown file type '%c', extracted as normal file"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|CURRENT_FILE_NAME
argument_list|)
operator|,
name|typeflag
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|again_file
goto|;
block|}
undef|#
directive|undef
name|CURRENT_FILE_NAME
block|}
end_function

begin_comment
comment|/* Extract the symbolic links whose final extraction were delayed.  */
end_comment

begin_function
specifier|static
name|void
name|apply_delayed_symlinks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|delayed_symlink
modifier|*
name|ds
decl_stmt|;
for|for
control|(
name|ds
operator|=
name|delayed_symlink_head
init|;
name|ds
condition|;
control|)
block|{
name|struct
name|string_list
modifier|*
name|sources
init|=
name|ds
operator|->
name|sources
decl_stmt|;
name|char
specifier|const
modifier|*
name|valid_source
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sources
operator|=
name|ds
operator|->
name|sources
init|;
name|sources
condition|;
name|sources
operator|=
name|sources
operator|->
name|next
control|)
block|{
name|char
specifier|const
modifier|*
name|source
init|=
name|sources
operator|->
name|string
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* Make sure the placeholder file is still there.  If not, 	     don't create a symlink, as the placeholder was probably 	     removed by a later extraction.  */
if|if
condition|(
name|lstat
argument_list|(
name|source
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_dev
operator|==
name|ds
operator|->
name|dev
operator|&&
name|st
operator|.
name|st_ino
operator|==
name|ds
operator|->
name|ino
operator|&&
name|st
operator|.
name|st_mtime
operator|==
name|ds
operator|->
name|mtime
condition|)
block|{
comment|/* Unlink the placeholder, then create a hard link if possible, 		 a symbolic link otherwise.  */
if|if
condition|(
name|unlink
argument_list|(
name|source
argument_list|)
operator|!=
literal|0
condition|)
name|unlink_error
argument_list|(
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valid_source
operator|&&
name|link
argument_list|(
name|valid_source
argument_list|,
name|source
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|symlink
argument_list|(
name|ds
operator|->
name|target
argument_list|,
name|source
argument_list|)
operator|!=
literal|0
condition|)
name|symlink_error
argument_list|(
name|ds
operator|->
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
block|{
name|valid_source
operator|=
name|source
expr_stmt|;
name|st
operator|.
name|st_uid
operator|=
name|ds
operator|->
name|uid
expr_stmt|;
name|st
operator|.
name|st_gid
operator|=
name|ds
operator|->
name|gid
expr_stmt|;
name|set_stat
argument_list|(
name|source
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SYMTYPE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|sources
operator|=
name|ds
operator|->
name|sources
init|;
name|sources
condition|;
control|)
block|{
name|struct
name|string_list
modifier|*
name|next
init|=
name|sources
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|sources
argument_list|)
expr_stmt|;
name|sources
operator|=
name|next
expr_stmt|;
block|}
block|{
name|struct
name|delayed_symlink
modifier|*
name|next
init|=
name|ds
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|=
name|next
expr_stmt|;
block|}
block|}
name|delayed_symlink_head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the extraction of an archive.  */
end_comment

begin_function
name|void
name|extract_finish
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* First, fix the status of ordinary directories that need fixing.  */
name|apply_nonancestor_delayed_set_stat
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then, apply delayed symlinks, so that they don't affect delayed      directory status-setting for ordinary directories.  */
name|apply_delayed_symlinks
argument_list|()
expr_stmt|;
comment|/* Finally, fix the status of directories that are ancestors      of delayed symlinks.  */
name|apply_nonancestor_delayed_set_stat
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|extract_finish
argument_list|()
expr_stmt|;
name|error
argument_list|(
name|TAREXIT_FAILURE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Error is not recoverable: exiting now"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

