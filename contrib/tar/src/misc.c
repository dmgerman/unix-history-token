begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Miscellaneous functions, not really specific to GNU tar.     Copyright 1988, 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2001 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|<save-cwd.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|call_arg_fatal
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Handling strings.  */
end_comment

begin_comment
comment|/* Assign STRING to a copy of VALUE if not zero, or to zero.  If    STRING was nonzero, it is freed first.  */
end_comment

begin_function
name|void
name|assign_string
parameter_list|(
name|char
modifier|*
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|*
name|string
condition|)
name|free
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
operator|*
name|string
operator|=
name|value
condition|?
name|xstrdup
argument_list|(
name|value
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a copy of the string quoted as in C, and returns that.  If    the string does not have to be quoted, it returns a null pointer.    The allocated copy should normally be freed with free() after the    caller is done with it.     This is used in one context only: generating the directory file in    incremental dumps.  The quoted string is not intended for human    consumption; it is intended only for unquote_string.  The quoting    is locale-independent, so that users needn't worry about locale    when reading directory files.  This means that we can't use    quotearg, as quotearg is locale-dependent and is meant for human    consumption.  */
end_comment

begin_function
name|char
modifier|*
name|quote_copy_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|source
init|=
name|string
decl_stmt|;
name|char
modifier|*
name|destination
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
literal|0
decl_stmt|;
name|int
name|copying
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|source
condition|)
block|{
name|int
name|character
init|=
operator|*
name|source
operator|++
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\\'
case|:
if|if
condition|(
operator|!
name|copying
condition|)
block|{
name|size_t
name|length
init|=
operator|(
name|source
operator|-
name|string
operator|)
operator|-
literal|1
decl_stmt|;
name|copying
operator|=
literal|1
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|2
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|source
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|destination
operator|=
name|buffer
operator|+
name|length
expr_stmt|;
block|}
operator|*
name|destination
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|destination
operator|++
operator|=
name|character
operator|==
literal|'\\'
condition|?
literal|'\\'
else|:
literal|'n'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|copying
condition|)
operator|*
name|destination
operator|++
operator|=
name|character
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|copying
condition|)
block|{
operator|*
name|destination
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Takes a quoted C string (like those produced by quote_copy_string)    and turns it back into the un-quoted original.  This is done in    place.  Returns 0 only if the string was not properly quoted, but    completes the unquoting anyway.  									       This is used for reading the saved directory file in incremental    dumps.  It is used for decoding old `N' records (demangling names).    But also, it is used for decoding file arguments, would they come    from the shell or a -T file, and for decoding the --exclude    argument.  */
end_comment

begin_function
name|int
name|unquote_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|source
init|=
name|string
decl_stmt|;
name|char
modifier|*
name|destination
init|=
name|string
decl_stmt|;
comment|/* Escape sequences other than \\ and \n are no longer generated by      quote_copy_string, but accept them for backwards compatibility,      and also because unquote_string is used for purposes other than      parsing the output of quote_copy_string.  */
while|while
condition|(
operator|*
name|source
condition|)
if|if
condition|(
operator|*
name|source
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|source
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\f'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\b'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|destination
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|*
name|destination
operator|++
operator|=
literal|0177
expr_stmt|;
name|source
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|int
name|value
init|=
operator|*
name|source
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
operator|*
name|source
operator|<
literal|'0'
operator|||
operator|*
name|source
operator|>
literal|'7'
condition|)
block|{
operator|*
name|destination
operator|++
operator|=
name|value
expr_stmt|;
break|break;
block|}
name|value
operator|=
name|value
operator|*
literal|8
operator|+
operator|*
name|source
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|source
operator|<
literal|'0'
operator|||
operator|*
name|source
operator|>
literal|'7'
condition|)
block|{
operator|*
name|destination
operator|++
operator|=
name|value
expr_stmt|;
break|break;
block|}
name|value
operator|=
name|value
operator|*
literal|8
operator|+
operator|*
name|source
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|destination
operator|++
operator|=
name|value
expr_stmt|;
break|break;
block|}
default|default:
name|result
operator|=
literal|0
expr_stmt|;
operator|*
name|destination
operator|++
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
operator|*
name|source
condition|)
operator|*
name|destination
operator|++
operator|=
operator|*
name|source
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|source
operator|!=
name|destination
condition|)
operator|*
name|destination
operator|++
operator|=
operator|*
name|source
operator|++
expr_stmt|;
else|else
name|source
operator|++
operator|,
name|destination
operator|++
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|destination
condition|)
operator|*
name|destination
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if NAME contains ".." as a path name component.  */
end_comment

begin_function
name|int
name|contains_dot_dot
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|p
init|=
name|name
operator|+
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|ISSLASH
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|p
index|[
literal|2
index|]
operator|)
condition|)
return|return
literal|1
return|;
do|do
block|{
if|if
condition|(
operator|!
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|!
name|ISSLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File handling.  */
end_comment

begin_comment
comment|/* Saved names in case backup needs to be undone.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|before_backup_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|after_backup_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some implementations of rmdir let you remove the working directory.    Report an error with errno set to zero for obvious cases of this;    otherwise call rmdir.  */
end_comment

begin_function
specifier|static
name|int
name|safer_rmdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
while|while
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ISSLASH
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|path
operator|++
expr_stmt|;
do|do
name|path
operator|++
expr_stmt|;
do|while
condition|(
name|ISSLASH
argument_list|(
operator|*
name|path
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|path
index|[
literal|0
index|]
operator|||
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|rmdir
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove PATH.  If PATH is a directory, then if RECURSE is set remove    it recursively; otherwise, remove it only if it is empty.  Return 0    on error, with errno set; if PATH is obviously the working    directory return zero with errno set to zero.  */
end_comment

begin_function
name|int
name|remove_any_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
comment|/* Try unlink first if we are not root, as this saves us a system      call in the common case where we're removing a non-directory.  */
if|if
condition|(
operator|!
name|we_are_root
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|safer_rmdir
argument_list|(
name|path
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTDIR
case|:
return|return
name|we_are_root
operator|&&
name|unlink
argument_list|(
name|path
argument_list|)
operator|==
literal|0
return|;
case|case
literal|0
case|:
case|case
name|EEXIST
case|:
if|#
directive|if
name|defined
name|ENOTEMPTY
operator|&&
name|ENOTEMPTY
operator|!=
name|EEXIST
case|case
name|ENOTEMPTY
case|:
endif|#
directive|endif
if|if
condition|(
name|recurse
condition|)
block|{
name|char
modifier|*
name|directory
init|=
name|savedir
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|entry
decl_stmt|;
name|size_t
name|entrylen
decl_stmt|;
if|if
condition|(
operator|!
name|directory
condition|)
return|return
literal|0
return|;
for|for
control|(
name|entry
operator|=
name|directory
init|;
operator|(
name|entrylen
operator|=
name|strlen
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|entry
operator|+=
name|entrylen
operator|+
literal|1
control|)
block|{
name|char
modifier|*
name|path_buffer
init|=
name|new_name
argument_list|(
name|path
argument_list|,
name|entry
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|remove_any_file
argument_list|(
name|path_buffer
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|path_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|free
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|free
argument_list|(
name|directory
argument_list|)
expr_stmt|;
return|return
name|safer_rmdir
argument_list|(
name|path
argument_list|)
operator|==
literal|0
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check if PATH already exists and make a backup of it right now.    Return success (nonzero) only if the backup in either unneeded, or    successful.  For now, directories are considered to never need    backup.  If ARCHIVE is nonzero, this is the archive and so, we do    not have to backup block or character devices, nor remote entities.  */
end_comment

begin_function
name|int
name|maybe_backup_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|archive
parameter_list|)
block|{
name|struct
name|stat
name|file_stat
decl_stmt|;
comment|/* Check if we really need to backup the file.  */
if|if
condition|(
name|archive
operator|&&
name|_remdev
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|1
return|;
name|stat_error
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|archive
operator|&&
operator|(
name|S_ISBLK
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|file_stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
name|assign_string
argument_list|(
operator|&
name|before_backup_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* A run situation may exist between Emacs or other GNU programs trying to      make a backup for the same file simultaneously.  If theoretically      possible, real problems are unlikely.  Doing any better would require a      convention, GNU-wide, for all programs doing backups.  */
name|assign_string
argument_list|(
operator|&
name|after_backup_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|after_backup_name
operator|=
name|find_backup_file_name
argument_list|(
name|path
argument_list|,
name|backup_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|after_backup_name
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|before_backup_name
argument_list|,
name|after_backup_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose_option
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"Renaming %s to %s\n"
argument_list|)
argument_list|,
name|quote_n
argument_list|(
literal|0
argument_list|,
name|before_backup_name
argument_list|)
argument_list|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|after_backup_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* The backup operation failed.  */
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot rename to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|before_backup_name
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|after_backup_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|after_backup_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Try to restore the recently backed up file to its original name.    This is usually only needed after a failed extraction.  */
end_comment

begin_function
name|void
name|undo_last_backup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|after_backup_name
condition|)
block|{
if|if
condition|(
name|rename
argument_list|(
name|after_backup_name
argument_list|,
name|before_backup_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot rename to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|after_backup_name
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|before_backup_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_option
condition|)
name|fprintf
argument_list|(
name|stdlis
argument_list|,
name|_
argument_list|(
literal|"Renaming %s back to %s\n"
argument_list|)
argument_list|,
name|quote_n
argument_list|(
literal|0
argument_list|,
name|after_backup_name
argument_list|)
argument_list|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|before_backup_name
argument_list|)
argument_list|)
expr_stmt|;
name|assign_string
argument_list|(
operator|&
name|after_backup_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Depending on DEREF, apply either stat or lstat to (NAME, BUF).  */
end_comment

begin_function
name|int
name|deref_stat
parameter_list|(
name|int
name|deref
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|struct
name|stat
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|deref
condition|?
name|stat
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
else|:
name|lstat
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A description of a working directory.  */
end_comment

begin_struct
struct|struct
name|wd
block|{
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|saved
decl_stmt|;
name|struct
name|saved_cwd
name|saved_cwd
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A vector of chdir targets.  wd[0] is the initial working directory.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wd
modifier|*
name|wd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of working directories in the vector.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|wds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The allocated size of the vector.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|wd_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DIR is the operand of a -C option; add it to vector of chdir targets,    and return the index of its location.  */
end_comment

begin_function
name|int
name|chdir_arg
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|)
block|{
if|if
condition|(
name|wds
operator|==
name|wd_alloc
condition|)
block|{
name|wd_alloc
operator|=
literal|2
operator|*
operator|(
name|wd_alloc
operator|+
literal|1
operator|)
expr_stmt|;
name|wd
operator|=
name|xrealloc
argument_list|(
name|wd
argument_list|,
sizeof|sizeof
expr|*
name|wd
operator|*
name|wd_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wds
condition|)
block|{
name|wd
index|[
name|wds
index|]
operator|.
name|name
operator|=
literal|"."
expr_stmt|;
name|wd
index|[
name|wds
index|]
operator|.
name|saved
operator|=
literal|0
expr_stmt|;
name|wds
operator|++
expr_stmt|;
block|}
block|}
comment|/* Optimize the common special case of the working directory,      or the working directory as a prefix.  */
if|if
condition|(
name|dir
index|[
literal|0
index|]
condition|)
block|{
while|while
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ISSLASH
argument_list|(
name|dir
index|[
literal|1
index|]
argument_list|)
condition|)
for|for
control|(
name|dir
operator|+=
literal|2
init|;
name|ISSLASH
argument_list|(
operator|*
name|dir
argument_list|)
condition|;
name|dir
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
name|dir
index|[
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
index|]
condition|)
return|return
name|wds
operator|-
literal|1
return|;
block|}
name|wd
index|[
name|wds
index|]
operator|.
name|name
operator|=
name|dir
expr_stmt|;
name|wd
index|[
name|wds
index|]
operator|.
name|saved
operator|=
literal|0
expr_stmt|;
return|return
name|wds
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Change to directory I.  If I is 0, change to the initial working    directory; otherwise, I must be a value returned by chdir_arg.  */
end_comment

begin_function
name|void
name|chdir_do
parameter_list|(
name|int
name|i
parameter_list|)
block|{
specifier|static
name|int
name|previous
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
name|i
condition|)
block|{
name|struct
name|wd
modifier|*
name|prev
init|=
operator|&
name|wd
index|[
name|previous
index|]
decl_stmt|;
name|struct
name|wd
modifier|*
name|curr
init|=
operator|&
name|wd
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|prev
operator|->
name|saved
condition|)
block|{
name|prev
operator|->
name|saved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|prev
operator|->
name|saved_cwd
argument_list|)
operator|!=
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot save working directory"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curr
operator|->
name|saved
condition|)
block|{
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|curr
operator|->
name|saved_cwd
argument_list|,
name|curr
operator|->
name|name
argument_list|,
name|prev
operator|->
name|name
argument_list|)
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Cannot change working directory"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|&&
operator|!
name|ISSLASH
argument_list|(
name|curr
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
name|chdir_do
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|curr
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|chdir_fatal
argument_list|(
name|curr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|previous
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode MODE from its binary form in a stat structure, and encode it    into a 9-byte string STRING, terminated with a NUL.  */
end_comment

begin_function
name|void
name|decode_mode
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IRUSR
condition|?
literal|'r'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IWUSR
condition|?
literal|'w'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
operator|(
name|mode
operator|&
name|S_ISUID
condition|?
operator|(
name|mode
operator|&
name|S_IXUSR
condition|?
literal|'s'
else|:
literal|'S'
operator|)
else|:
operator|(
name|mode
operator|&
name|S_IXUSR
condition|?
literal|'x'
else|:
literal|'-'
operator|)
operator|)
expr_stmt|;
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IRGRP
condition|?
literal|'r'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IWGRP
condition|?
literal|'w'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
operator|(
name|mode
operator|&
name|S_ISGID
condition|?
operator|(
name|mode
operator|&
name|S_IXGRP
condition|?
literal|'s'
else|:
literal|'S'
operator|)
else|:
operator|(
name|mode
operator|&
name|S_IXGRP
condition|?
literal|'x'
else|:
literal|'-'
operator|)
operator|)
expr_stmt|;
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IROTH
condition|?
literal|'r'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
name|mode
operator|&
name|S_IWOTH
condition|?
literal|'w'
else|:
literal|'-'
expr_stmt|;
operator|*
name|string
operator|++
operator|=
operator|(
name|mode
operator|&
name|S_ISVTX
condition|?
operator|(
name|mode
operator|&
name|S_IXOTH
condition|?
literal|'t'
else|:
literal|'T'
operator|)
else|:
operator|(
name|mode
operator|&
name|S_IXOTH
condition|?
literal|'x'
else|:
literal|'-'
operator|)
operator|)
expr_stmt|;
operator|*
name|string
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error associated with the system call CALL and the    optional name NAME.  */
end_comment

begin_function
specifier|static
name|void
name|call_arg_error
parameter_list|(
name|char
specifier|const
modifier|*
name|call
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|call
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a fatal error associated with the system call CALL and    the optional file name NAME.  */
end_comment

begin_function
specifier|static
name|void
name|call_arg_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|call
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|call
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning associated with the system call CALL and    the optional file name NAME.  */
end_comment

begin_function
specifier|static
name|void
name|call_arg_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|call
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Warning: Cannot %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|call
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chdir_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"chdir"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chmod_error_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot change mode to 0%o"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chown_error_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot change ownership to uid %lu, gid %lu"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|uid
operator|,
operator|(
name|unsigned
name|long
operator|)
name|gid
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"close"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"close"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"close"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exec_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"exec"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|link_error
parameter_list|(
name|char
specifier|const
modifier|*
name|target
parameter_list|,
name|char
specifier|const
modifier|*
name|source
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot hard link to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|source
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|target
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mkdir_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"mkdir"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mkfifo_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"mkfifo"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mknod_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"mknod"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|open_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"open"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|open_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"open"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|open_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"open"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"read"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_error_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Read error at byte %s, reading %lu bytes"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_warn_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Warning: Read error at byte %s, reading %lu bytes"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"read"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_fatal_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Read error at byte %s, reading %lu bytes"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|readlink_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"readlink"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|readlink_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"readlink"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savedir_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"savedir"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savedir_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"savedir"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seek_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"seek"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seek_error_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot seek to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seek_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"seek"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seek_warn_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Warning: Cannot seek to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|symlink_error
parameter_list|(
name|char
specifier|const
modifier|*
name|contents
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
name|e
operator|,
name|_
argument_list|(
literal|"%s: Cannot create symlink to %s"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|name
argument_list|)
operator|,
name|quote_n
argument_list|(
literal|1
argument_list|,
name|contents
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stat_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"stat"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stat_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"stat"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|truncate_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"truncate"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|truncate_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_warn
argument_list|(
literal|"truncate"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unlink_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"unlink"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|utime_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"utime"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|waitpid_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"waitpid"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_error
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_error
argument_list|(
literal|"write"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_error_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|ssize_t
name|status
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|write_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: Wrote only %lu of %lu bytes"
argument_list|)
operator|,
name|name
operator|,
operator|(
name|unsigned
name|long
operator|)
name|status
operator|,
operator|(
name|unsigned
name|long
operator|)
name|record_size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|call_arg_fatal
argument_list|(
literal|"write"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_fatal_details
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|ssize_t
name|status
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|write_error_details
argument_list|(
name|name
argument_list|,
name|status
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork, aborting if unsuccessful.  */
end_comment

begin_function
name|pid_t
name|xfork
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|p
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
name|call_arg_fatal
argument_list|(
literal|"fork"
argument_list|,
name|_
argument_list|(
literal|"child process"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Create a pipe, aborting if unsuccessful.  */
end_comment

begin_function
name|void
name|xpipe
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|call_arg_fatal
argument_list|(
literal|"pipe"
argument_list|,
name|_
argument_list|(
literal|"interprocess channel"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an unambiguous printable representation, allocated in slot N,    for NAME, suitable for diagnostics.  */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|quote_n
parameter_list|(
name|int
name|n
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
return|return
name|quotearg_n_style
argument_list|(
name|n
argument_list|,
name|locale_quoting_style
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an unambiguous printable representation of NAME, suitable    for diagnostics.  */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|quote
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
return|return
name|quote_n
argument_list|(
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

end_unit

