begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Delete entries from a tar archive.     Copyright (C) 1988, 1992, 1994, 1996, 1997, 2000, 2001 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_decl_stmt
specifier|static
name|union
name|block
modifier|*
name|new_record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|acting_as_filter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: This module should not directly handle the following    variables, instead, the interface should be cleaned up.  */
end_comment

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|record_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|record_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|current_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|recent_long_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|recent_long_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|size_t
name|recent_long_name_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|size_t
name|recent_long_link_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|off_t
name|records_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|off_t
name|records_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of records skipped at the start of the archive, when    passing over members that are not deleted.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|records_skipped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move archive descriptor by COUNT records worth.  If COUNT is    positive we move forward, else we move negative.  If it's a tape,    MTIOCTOP had better work.  If it's something else, we try to seek    on it.  If we can't seek, we lose!  */
end_comment

begin_function
specifier|static
name|void
name|move_archive
parameter_list|(
name|off_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|MTIOCTOP
block|{
name|struct
name|mtop
name|operation
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|?
operator|(
name|operation
operator|.
name|mt_op
operator|=
name|MTBSR
operator|,
name|operation
operator|.
name|mt_count
operator|=
operator|-
name|count
operator|,
name|operation
operator|.
name|mt_count
operator|==
operator|-
name|count
operator|)
else|:
operator|(
name|operation
operator|.
name|mt_op
operator|=
name|MTFSR
operator|,
name|operation
operator|.
name|mt_count
operator|=
name|count
operator|,
name|operation
operator|.
name|mt_count
operator|==
name|count
operator|)
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
condition|)
return|return;
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
literal|0
operator|<=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|operation
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* MTIOCTOP */
block|{
name|off_t
name|position0
init|=
name|rmtlseek
argument_list|(
name|archive
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
name|off_t
name|increment
init|=
name|record_size
operator|*
operator|(
name|off_t
operator|)
name|count
decl_stmt|;
name|off_t
name|position
init|=
name|position0
operator|+
name|increment
decl_stmt|;
if|if
condition|(
name|increment
operator|/
name|count
operator|!=
name|record_size
operator|||
operator|(
name|position
operator|<
name|position0
operator|)
operator|!=
operator|(
name|increment
operator|<
literal|0
operator|)
operator|||
operator|(
name|position
operator|=
name|position
operator|<
literal|0
condition|?
literal|0
else|:
name|position
operator|,
name|rmtlseek
argument_list|(
name|archive
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|position
operator|)
condition|)
name|seek_error_details
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
name|position
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Write out the record which has been filled.  If MOVE_BACK_FLAG,    backspace to where we started.  */
end_comment

begin_function
specifier|static
name|void
name|write_record
parameter_list|(
name|int
name|move_back_flag
parameter_list|)
block|{
name|union
name|block
modifier|*
name|save_record
init|=
name|record_start
decl_stmt|;
name|record_start
operator|=
name|new_record
expr_stmt|;
if|if
condition|(
name|acting_as_filter
condition|)
block|{
name|archive
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|flush_write
argument_list|()
expr_stmt|;
name|archive
operator|=
name|STDIN_FILENO
expr_stmt|;
block|}
else|else
block|{
name|move_archive
argument_list|(
operator|(
name|records_written
operator|+
name|records_skipped
operator|)
operator|-
name|records_read
argument_list|)
expr_stmt|;
name|flush_write
argument_list|()
expr_stmt|;
block|}
name|record_start
operator|=
name|save_record
expr_stmt|;
if|if
condition|(
name|move_back_flag
condition|)
block|{
comment|/* Move the tape head back to where we were.  */
if|if
condition|(
operator|!
name|acting_as_filter
condition|)
name|move_archive
argument_list|(
name|records_read
operator|-
operator|(
name|records_written
operator|+
name|records_skipped
operator|)
argument_list|)
expr_stmt|;
block|}
name|new_blocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_recent_blocks
parameter_list|(
name|union
name|block
modifier|*
name|h
parameter_list|,
name|size_t
name|blocks
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocks
condition|;
name|i
operator|++
control|)
block|{
name|new_record
index|[
name|new_blocks
operator|++
index|]
operator|=
name|h
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new_blocks
operator|==
name|blocking_factor
condition|)
name|write_record
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|delete_archive_members
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|read_header
name|logical_status
init|=
name|HEADER_STILL_UNREAD
decl_stmt|;
name|enum
name|read_header
name|previous_status
init|=
name|HEADER_STILL_UNREAD
decl_stmt|;
comment|/* FIXME: Should clean the routine before cleaning these variables :-( */
name|struct
name|name
modifier|*
name|name
decl_stmt|;
name|off_t
name|blocks_to_skip
init|=
literal|0
decl_stmt|;
name|off_t
name|blocks_to_keep
init|=
literal|0
decl_stmt|;
name|int
name|kept_blocks_in_record
decl_stmt|;
name|name_gather
argument_list|()
expr_stmt|;
name|open_archive
argument_list|(
name|ACCESS_UPDATE
argument_list|)
expr_stmt|;
name|acting_as_filter
operator|=
name|strcmp
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
expr_stmt|;
do|do
block|{
name|enum
name|read_header
name|status
init|=
name|read_header
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|HEADER_SUCCESS
case|:
if|if
condition|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
operator|,
operator|!
name|name
condition|)
block|{
name|skip_member
argument_list|()
expr_stmt|;
break|break;
block|}
name|name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_SUCCESS_EXTENDED
case|:
name|logical_status
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|HEADER_ZERO_BLOCK
case|:
if|if
condition|(
name|ignore_zeros_option
condition|)
block|{
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|HEADER_END_OF_FILE
case|:
name|logical_status
operator|=
name|HEADER_END_OF_FILE
expr_stmt|;
break|break;
case|case
name|HEADER_FAILURE
case|:
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|previous_status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"This does not look like a tar archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_SUCCESS
case|:
case|case
name|HEADER_ZERO_BLOCK
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Skipping to next header"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_FAILURE
case|:
break|break;
case|case
name|HEADER_END_OF_FILE
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|previous_status
operator|=
name|status
expr_stmt|;
block|}
do|while
condition|(
name|logical_status
operator|==
name|HEADER_STILL_UNREAD
condition|)
do|;
name|records_skipped
operator|=
name|records_read
operator|-
literal|1
expr_stmt|;
name|new_record
operator|=
name|xmalloc
argument_list|(
name|record_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical_status
operator|==
name|HEADER_SUCCESS
operator|||
name|logical_status
operator|==
name|HEADER_SUCCESS_EXTENDED
condition|)
block|{
name|write_archive_to_stdout
operator|=
literal|0
expr_stmt|;
comment|/* Save away blocks before this one in this record.  */
name|new_blocks
operator|=
name|current_block
operator|-
name|record_start
expr_stmt|;
if|if
condition|(
name|new_blocks
condition|)
name|memcpy
argument_list|(
name|new_record
argument_list|,
name|record_start
argument_list|,
name|new_blocks
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical_status
operator|==
name|HEADER_SUCCESS
condition|)
block|{
comment|/* FIXME: Pheew!  This is crufty code!  */
name|logical_status
operator|=
name|HEADER_STILL_UNREAD
expr_stmt|;
goto|goto
name|flush_file
goto|;
block|}
comment|/* FIXME: Solaris 2.4 Sun cc (the ANSI one, not the old K&R) says: 	 "delete.c", line 223: warning: loop not entered at top 	 Reported by Bruno Haible.  */
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|read_header
name|status
decl_stmt|;
comment|/* Fill in a record.  */
if|if
condition|(
name|current_block
operator|==
name|record_end
condition|)
name|flush_archive
argument_list|()
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|HEADER_ZERO_BLOCK
operator|&&
name|ignore_zeros_option
condition|)
block|{
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|status
operator|==
name|HEADER_END_OF_FILE
operator|||
name|status
operator|==
name|HEADER_ZERO_BLOCK
condition|)
block|{
name|logical_status
operator|=
name|HEADER_END_OF_FILE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|HEADER_FAILURE
condition|)
block|{
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Deleting non-header from archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Found another header.  */
if|if
condition|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
operator|,
name|name
condition|)
block|{
name|name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|flush_file
label|:
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
name|blocks_to_skip
operator|=
operator|(
name|current_stat
operator|.
name|st_size
operator|+
name|BLOCKSIZE
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
expr_stmt|;
while|while
condition|(
name|record_end
operator|-
name|current_block
operator|<=
name|blocks_to_skip
condition|)
block|{
name|blocks_to_skip
operator|-=
operator|(
name|record_end
operator|-
name|current_block
operator|)
expr_stmt|;
name|flush_archive
argument_list|()
expr_stmt|;
block|}
name|current_block
operator|+=
name|blocks_to_skip
expr_stmt|;
name|blocks_to_skip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Copy header.  */
name|write_recent_blocks
argument_list|(
name|recent_long_name
argument_list|,
name|recent_long_name_blocks
argument_list|)
expr_stmt|;
name|write_recent_blocks
argument_list|(
name|recent_long_link
argument_list|,
name|recent_long_link_blocks
argument_list|)
expr_stmt|;
name|new_record
index|[
name|new_blocks
index|]
operator|=
operator|*
name|current_header
expr_stmt|;
name|new_blocks
operator|++
expr_stmt|;
name|blocks_to_keep
operator|=
operator|(
name|current_stat
operator|.
name|st_size
operator|+
name|BLOCKSIZE
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
expr_stmt|;
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_blocks
operator|==
name|blocking_factor
condition|)
name|write_record
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy data.  */
name|kept_blocks_in_record
operator|=
name|record_end
operator|-
name|current_block
expr_stmt|;
if|if
condition|(
name|kept_blocks_in_record
operator|>
name|blocks_to_keep
condition|)
name|kept_blocks_in_record
operator|=
name|blocks_to_keep
expr_stmt|;
while|while
condition|(
name|blocks_to_keep
condition|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|current_block
operator|==
name|record_end
condition|)
block|{
name|flush_read
argument_list|()
expr_stmt|;
name|current_block
operator|=
name|record_start
expr_stmt|;
name|kept_blocks_in_record
operator|=
name|blocking_factor
expr_stmt|;
if|if
condition|(
name|kept_blocks_in_record
operator|>
name|blocks_to_keep
condition|)
name|kept_blocks_in_record
operator|=
name|blocks_to_keep
expr_stmt|;
block|}
name|count
operator|=
name|kept_blocks_in_record
expr_stmt|;
if|if
condition|(
name|blocking_factor
operator|-
name|new_blocks
operator|<
name|count
condition|)
name|count
operator|=
name|blocking_factor
operator|-
name|new_blocks
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|new_record
operator|+
name|new_blocks
argument_list|,
name|current_block
argument_list|,
name|count
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|new_blocks
operator|+=
name|count
expr_stmt|;
name|current_block
operator|+=
name|count
expr_stmt|;
name|blocks_to_keep
operator|-=
name|count
expr_stmt|;
name|kept_blocks_in_record
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|new_blocks
operator|==
name|blocking_factor
condition|)
name|write_record
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|logical_status
operator|==
name|HEADER_END_OF_FILE
condition|)
block|{
comment|/* Write the end of tape.  FIXME: we can't use write_eot here, 	 as it gets confused when the input is at end of file.  */
name|int
name|total_zero_blocks
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|zero_blocks
init|=
name|blocking_factor
operator|-
name|new_blocks
decl_stmt|;
name|memset
argument_list|(
name|new_record
operator|+
name|new_blocks
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
operator|*
name|zero_blocks
argument_list|)
expr_stmt|;
name|total_zero_blocks
operator|+=
name|zero_blocks
expr_stmt|;
name|write_record
argument_list|(
name|total_zero_blocks
operator|<
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|total_zero_blocks
operator|<
literal|2
condition|)
do|;
block|}
name|free
argument_list|(
name|new_record
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acting_as_filter
operator|&&
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
condition|)
block|{
if|#
directive|if
name|MSDOS
name|int
name|status
init|=
name|write
argument_list|(
name|archive
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
else|#
directive|else
name|off_t
name|pos
init|=
name|lseek
argument_list|(
name|archive
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
name|int
name|status
init|=
name|pos
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|ftruncate
argument_list|(
name|archive
argument_list|,
name|pos
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|truncate_warn
argument_list|(
name|archive_name_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

