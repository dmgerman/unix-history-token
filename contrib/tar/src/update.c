begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Update a tar archive.     Copyright (C) 1988, 1992, 1994, 1996, 1997, 1999, 2000, 2001 Free    Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Implement the 'r', 'u' and 'A' options for tar.  'A' means that the    file names are tar files, and they should simply be appended to the end    of the archive.  No attempt is made to record the reads from the args; if    they're on raw tape or something like that, it'll probably lose...  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_comment
comment|/* FIXME: This module should not directly handle the following variable,    instead, this should be done in buffer.c only.  */
end_comment

begin_decl_stmt
specifier|extern
name|union
name|block
modifier|*
name|current_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We've hit the end of the old stuff, and its time to start writing new    stuff to the tape.  This involves seeking back one record and    re-writing the current record (which has been changed).  */
end_comment

begin_decl_stmt
name|int
name|time_to_start_writing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to where we started to write in the first record we write out.    This is used if we can't backspace the output and have to null out the    first part of the record.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Catenate file PATH to the archive without creating a header for it.    It had better be a tar file or the archive is screwed.  */
end_comment

begin_function
specifier|static
name|void
name|append_file
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|handle
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
decl_stmt|;
name|struct
name|stat
name|stat_data
decl_stmt|;
if|if
condition|(
name|handle
operator|<
literal|0
condition|)
block|{
name|open_error
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|handle
argument_list|,
operator|&
name|stat_data
argument_list|)
operator|!=
literal|0
condition|)
name|stat_error
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|off_t
name|bytes_left
init|=
name|stat_data
operator|.
name|st_size
decl_stmt|;
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|union
name|block
modifier|*
name|start
init|=
name|find_next_block
argument_list|()
decl_stmt|;
name|size_t
name|buffer_size
init|=
name|available_space_after
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|ssize_t
name|status
decl_stmt|;
name|char
name|buf
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|buffer_size
condition|)
block|{
name|buffer_size
operator|=
name|bytes_left
expr_stmt|;
name|status
operator|=
name|buffer_size
operator|%
name|BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memset
argument_list|(
name|start
operator|->
name|buffer
operator|+
name|bytes_left
argument_list|,
literal|0
argument_list|,
name|BLOCKSIZE
operator|-
name|status
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|safe_read
argument_list|(
name|handle
argument_list|,
name|start
operator|->
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|read_fatal_details
argument_list|(
name|path
argument_list|,
name|stat_data
operator|.
name|st_size
operator|-
name|bytes_left
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|FATAL_ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"%s: File shrank by %s bytes"
argument_list|)
operator|,
name|quotearg_colon
argument_list|(
name|path
argument_list|)
operator|,
name|STRINGIFY_BIGINT
argument_list|(
name|bytes_left
argument_list|,
name|buf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bytes_left
operator|-=
name|status
expr_stmt|;
name|set_next_block_after
argument_list|(
name|start
operator|+
operator|(
name|status
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|close
argument_list|(
name|handle
argument_list|)
operator|!=
literal|0
condition|)
name|close_error
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement the 'r' (add files to end of archive), and 'u' (add files    to end of archive if they aren't there, or are more up to date than    the version in the archive) commands.  */
end_comment

begin_function
name|void
name|update_archive
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|read_header
name|previous_status
init|=
name|HEADER_STILL_UNREAD
decl_stmt|;
name|int
name|found_end
init|=
literal|0
decl_stmt|;
name|name_gather
argument_list|()
expr_stmt|;
name|open_archive
argument_list|(
name|ACCESS_UPDATE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|found_end
condition|)
block|{
name|enum
name|read_header
name|status
init|=
name|read_header
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|HEADER_SUCCESS
case|:
block|{
name|struct
name|name
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|subcommand_option
operator|==
name|UPDATE_SUBCOMMAND
operator|&&
operator|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
operator|,
name|name
operator|)
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|enum
name|archive_format
name|unused
decl_stmt|;
name|decode_header
argument_list|(
name|current_header
argument_list|,
operator|&
name|current_stat
argument_list|,
operator|&
name|unused
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chdir_do
argument_list|(
name|name
operator|->
name|change_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_stat
argument_list|(
name|dereference_option
argument_list|,
name|current_file_name
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|.
name|st_mtime
operator|<=
name|current_stat
operator|.
name|st_mtime
condition|)
name|add_avoided_name
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|skip_member
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|HEADER_ZERO_BLOCK
case|:
name|current_block
operator|=
name|current_header
expr_stmt|;
name|found_end
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HEADER_END_OF_FILE
case|:
name|found_end
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HEADER_FAILURE
case|:
name|set_next_block_after
argument_list|(
name|current_header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|previous_status
condition|)
block|{
case|case
name|HEADER_STILL_UNREAD
case|:
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"This does not look like a tar archive"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_SUCCESS
case|:
case|case
name|HEADER_ZERO_BLOCK
case|:
name|ERROR
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
literal|"Skipping to next header"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|HEADER_FAILURE
case|:
break|break;
case|case
name|HEADER_END_OF_FILE
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|previous_status
operator|=
name|status
expr_stmt|;
block|}
name|reset_eof
argument_list|()
expr_stmt|;
name|time_to_start_writing
operator|=
literal|1
expr_stmt|;
name|output_start
operator|=
name|current_block
operator|->
name|buffer
expr_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
while|while
condition|(
name|path
operator|=
name|name_from_list
argument_list|()
operator|,
name|path
condition|)
block|{
if|if
condition|(
name|excluded_name
argument_list|(
name|path
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|interactive_option
operator|&&
operator|!
name|confirm
argument_list|(
literal|"add"
argument_list|,
name|path
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|subcommand_option
operator|==
name|CAT_SUBCOMMAND
condition|)
name|append_file
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
name|dump_file
argument_list|(
name|path
argument_list|,
literal|1
argument_list|,
operator|(
name|dev_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

