begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A Bison parser, made from getdate.y    by GNU bison 1.29.  */
end_comment

begin_define
define|#
directive|define
name|YYBISON
value|1
end_define

begin_comment
comment|/* Identify Bison output.  */
end_comment

begin_define
define|#
directive|define
name|tAGO
value|257
end_define

begin_define
define|#
directive|define
name|tDST
value|258
end_define

begin_define
define|#
directive|define
name|tDAY
value|259
end_define

begin_define
define|#
directive|define
name|tDAY_UNIT
value|260
end_define

begin_define
define|#
directive|define
name|tDAYZONE
value|261
end_define

begin_define
define|#
directive|define
name|tHOUR_UNIT
value|262
end_define

begin_define
define|#
directive|define
name|tLOCAL_ZONE
value|263
end_define

begin_define
define|#
directive|define
name|tMERIDIAN
value|264
end_define

begin_define
define|#
directive|define
name|tMINUTE_UNIT
value|265
end_define

begin_define
define|#
directive|define
name|tMONTH
value|266
end_define

begin_define
define|#
directive|define
name|tMONTH_UNIT
value|267
end_define

begin_define
define|#
directive|define
name|tSEC_UNIT
value|268
end_define

begin_define
define|#
directive|define
name|tYEAR_UNIT
value|269
end_define

begin_define
define|#
directive|define
name|tZONE
value|270
end_define

begin_define
define|#
directive|define
name|tSNUMBER
value|271
end_define

begin_define
define|#
directive|define
name|tUNUMBER
value|272
end_define

begin_line
line|#
directive|line
number|1
file|"getdate.y"
end_line

begin_comment
comment|/* Parse a string into an internal time stamp.    Copyright 1999, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Originally written by Steven M. Bellovin<smb@research.att.com> while    at the University of North Carolina at Chapel Hill.  Later tweaked by    a couple of people on Usenet.  Completely overhauled by Rich $alz<rsalz@bbn.com> and Jim Berets<jberets@bbn.com> in August, 1990.     Modified by Paul Eggert<eggert@twinsun.com> in August 1999 to do    the right thing about local DST.  Unlike previous versions, this    version is reentrant.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Since the code of getdate.y is not included in the Emacs executable    itself, there is no need to #define static in this file.  Even if    the code were included in the Emacs executable, it probably    wouldn't do any harm to #undef it here; this will only cause    problems if we try to write to a static variable, which I don't    think this code needs to do.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_undef
undef|#
directive|undef
name|static
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for `free'; used by Bison 1.27 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STDC_HEADERS
operator|||
operator|(
operator|!
name|defined
name|isascii
operator|&&
operator|!
name|HAVE_ISASCII
operator|)
end_if

begin_define
define|#
directive|define
name|IN_CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IN_CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|isascii (c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|(IN_CTYPE_DOMAIN (c)&& isspace (c))
end_define

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|c
parameter_list|)
value|(IN_CTYPE_DOMAIN (c)&& isalpha (c))
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|c
parameter_list|)
value|(IN_CTYPE_DOMAIN (c)&& islower (c))
end_define

begin_define
define|#
directive|define
name|ISDIGIT_LOCALE
parameter_list|(
name|c
parameter_list|)
value|(IN_CTYPE_DOMAIN (c)&& isdigit (c))
end_define

begin_comment
comment|/* ISDIGIT differs from ISDIGIT_LOCALE, as follows:    - Its arg may be any int or unsigned int; it need not be an unsigned char.    - It's guaranteed to evaluate its argument exactly once.    - It's typically faster.    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless    it's important to use the locale's definition of `digit' even when the    host does not conform to Posix.  */
end_comment

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|((unsigned) (c) - '0'<= 9)
end_define

begin_if
if|#
directive|if
name|STDC_HEADERS
operator|||
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__GNUC__
operator|<
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|8
operator|)
operator|||
name|__STRICT_ANSI__
end_if

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTRIBUTE_UNUSED
end_ifndef

begin_define
define|#
directive|define
name|ATTRIBUTE_UNUSED
value|__attribute__ ((__unused__))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EPOCH_YEAR
value|1970
end_define

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_define
define|#
directive|define
name|HOUR
parameter_list|(
name|x
parameter_list|)
value|((x) * 60)
end_define

begin_comment
comment|/* An integer value, and the number of digits in its textual    representation.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|value
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|}
name|textint
typedef|;
end_typedef

begin_comment
comment|/* An entry in the lexical lookup table.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|table
typedef|;
end_typedef

begin_comment
comment|/* Meridian: am, pm, or 24-hour style.  */
end_comment

begin_enum
enum|enum
block|{
name|MERam
block|,
name|MERpm
block|,
name|MER24
block|}
enum|;
end_enum

begin_comment
comment|/* Information passed to and from the parser.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The input string remaining to be parsed. */
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
comment|/* N, if this is the Nth Tuesday.  */
name|int
name|day_ordinal
decl_stmt|;
comment|/* Day of week; Sunday is 0.  */
name|int
name|day_number
decl_stmt|;
comment|/* tm_isdst flag for the local zone.  */
name|int
name|local_isdst
decl_stmt|;
comment|/* Time zone, in minutes east of UTC.  */
name|int
name|time_zone
decl_stmt|;
comment|/* Style used for time.  */
name|int
name|meridian
decl_stmt|;
comment|/* Gregorian year, month, day, hour, minutes, and seconds.  */
name|textint
name|year
decl_stmt|;
name|int
name|month
decl_stmt|;
name|int
name|day
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|int
name|minutes
decl_stmt|;
name|int
name|seconds
decl_stmt|;
comment|/* Relative year, month, day, hour, minutes, and seconds.  */
name|int
name|rel_year
decl_stmt|;
name|int
name|rel_month
decl_stmt|;
name|int
name|rel_day
decl_stmt|;
name|int
name|rel_hour
decl_stmt|;
name|int
name|rel_minutes
decl_stmt|;
name|int
name|rel_seconds
decl_stmt|;
comment|/* Counts of nonterminals of various flavors parsed so far.  */
name|int
name|dates_seen
decl_stmt|;
name|int
name|days_seen
decl_stmt|;
name|int
name|local_zones_seen
decl_stmt|;
name|int
name|rels_seen
decl_stmt|;
name|int
name|times_seen
decl_stmt|;
name|int
name|zones_seen
decl_stmt|;
comment|/* Table of local time zone abbrevations, terminated by a null entry.  */
name|table
name|local_time_zone_table
index|[
literal|3
index|]
decl_stmt|;
block|}
name|parser_control
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PC
value|(* (parser_control *) parm)
end_define

begin_define
define|#
directive|define
name|YYLEX_PARAM
value|parm
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM
value|parm
end_define

begin_function_decl
specifier|static
name|int
name|yyerror
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|yylex
parameter_list|()
function_decl|;
end_function_decl

begin_line
line|#
directive|line
number|172
file|"getdate.y"
end_line

begin_typedef
typedef|typedef
union|union
block|{
name|int
name|intval
decl_stmt|;
name|textint
name|textintval
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|YYFINAL
value|64
end_define

begin_define
define|#
directive|define
name|YYFLAG
value|-32768
end_define

begin_define
define|#
directive|define
name|YYNTBASE
value|22
end_define

begin_comment
comment|/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
end_comment

begin_define
define|#
directive|define
name|YYTRANSLATE
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x)<= 272 ? yytranslate[x] : 33)
end_define

begin_comment
comment|/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|yytranslate
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|20
block|,
literal|2
block|,
literal|2
block|,
literal|21
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|19
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
end_if

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyprhs
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|38
block|,
literal|45
block|,
literal|47
block|,
literal|50
block|,
literal|52
block|,
literal|54
block|,
literal|57
block|,
literal|59
block|,
literal|62
block|,
literal|65
block|,
literal|69
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|86
block|,
literal|91
block|,
literal|94
block|,
literal|98
block|,
literal|101
block|,
literal|103
block|,
literal|106
block|,
literal|109
block|,
literal|111
block|,
literal|114
block|,
literal|117
block|,
literal|119
block|,
literal|122
block|,
literal|125
block|,
literal|127
block|,
literal|130
block|,
literal|133
block|,
literal|135
block|,
literal|138
block|,
literal|141
block|,
literal|143
block|,
literal|146
block|,
literal|149
block|,
literal|151
block|,
literal|153
block|,
literal|154
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrhs
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|22
block|,
literal|23
block|,
literal|0
block|,
literal|24
block|,
literal|0
block|,
literal|25
block|,
literal|0
block|,
literal|26
block|,
literal|0
block|,
literal|28
block|,
literal|0
block|,
literal|27
block|,
literal|0
block|,
literal|29
block|,
literal|0
block|,
literal|31
block|,
literal|0
block|,
literal|18
block|,
literal|10
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|32
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|32
block|,
literal|0
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
literal|9
block|,
literal|4
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|16
block|,
literal|4
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|5
block|,
literal|20
block|,
literal|0
block|,
literal|18
block|,
literal|5
block|,
literal|0
block|,
literal|18
block|,
literal|21
block|,
literal|18
block|,
literal|0
block|,
literal|18
block|,
literal|21
block|,
literal|18
block|,
literal|21
block|,
literal|18
block|,
literal|0
block|,
literal|18
block|,
literal|17
block|,
literal|17
block|,
literal|0
block|,
literal|18
block|,
literal|12
block|,
literal|17
block|,
literal|0
block|,
literal|12
block|,
literal|18
block|,
literal|0
block|,
literal|12
block|,
literal|18
block|,
literal|20
block|,
literal|18
block|,
literal|0
block|,
literal|18
block|,
literal|12
block|,
literal|0
block|,
literal|18
block|,
literal|12
block|,
literal|18
block|,
literal|0
block|,
literal|30
block|,
literal|3
block|,
literal|0
block|,
literal|30
block|,
literal|0
block|,
literal|18
block|,
literal|15
block|,
literal|0
block|,
literal|17
block|,
literal|15
block|,
literal|0
block|,
literal|15
block|,
literal|0
block|,
literal|18
block|,
literal|13
block|,
literal|0
block|,
literal|17
block|,
literal|13
block|,
literal|0
block|,
literal|13
block|,
literal|0
block|,
literal|18
block|,
literal|6
block|,
literal|0
block|,
literal|17
block|,
literal|6
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|18
block|,
literal|8
block|,
literal|0
block|,
literal|17
block|,
literal|8
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|18
block|,
literal|11
block|,
literal|0
block|,
literal|17
block|,
literal|11
block|,
literal|0
block|,
literal|11
block|,
literal|0
block|,
literal|18
block|,
literal|14
block|,
literal|0
block|,
literal|17
block|,
literal|14
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|18
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
end_if

begin_comment
comment|/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrline
index|[]
init|=
block|{
literal|0
block|,
literal|189
block|,
literal|191
block|,
literal|194
block|,
literal|197
block|,
literal|199
block|,
literal|201
block|,
literal|203
block|,
literal|205
block|,
literal|207
block|,
literal|210
block|,
literal|218
block|,
literal|225
block|,
literal|233
block|,
literal|240
block|,
literal|251
block|,
literal|254
block|,
literal|258
block|,
literal|261
block|,
literal|263
block|,
literal|267
block|,
literal|273
block|,
literal|278
block|,
literal|285
block|,
literal|291
block|,
literal|311
block|,
literal|318
block|,
literal|326
block|,
literal|331
block|,
literal|337
block|,
literal|342
block|,
literal|350
block|,
literal|360
block|,
literal|363
block|,
literal|366
block|,
literal|368
block|,
literal|370
block|,
literal|372
block|,
literal|374
block|,
literal|376
block|,
literal|378
block|,
literal|380
block|,
literal|382
block|,
literal|384
block|,
literal|386
block|,
literal|388
block|,
literal|390
block|,
literal|392
block|,
literal|394
block|,
literal|396
block|,
literal|398
block|,
literal|402
block|,
literal|438
block|,
literal|441
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
operator|||
name|defined
name|YYERROR_VERBOSE
end_if

begin_comment
comment|/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|yytname
index|[]
init|=
block|{
literal|"$"
block|,
literal|"error"
block|,
literal|"$undefined."
block|,
literal|"tAGO"
block|,
literal|"tDST"
block|,
literal|"tDAY"
block|,
literal|"tDAY_UNIT"
block|,
literal|"tDAYZONE"
block|,
literal|"tHOUR_UNIT"
block|,
literal|"tLOCAL_ZONE"
block|,
literal|"tMERIDIAN"
block|,
literal|"tMINUTE_UNIT"
block|,
literal|"tMONTH"
block|,
literal|"tMONTH_UNIT"
block|,
literal|"tSEC_UNIT"
block|,
literal|"tYEAR_UNIT"
block|,
literal|"tZONE"
block|,
literal|"tSNUMBER"
block|,
literal|"tUNUMBER"
block|,
literal|"':'"
block|,
literal|"','"
block|,
literal|"'/'"
block|,
literal|"spec"
block|,
literal|"item"
block|,
literal|"time"
block|,
literal|"local_zone"
block|,
literal|"zone"
block|,
literal|"day"
block|,
literal|"date"
block|,
literal|"rel"
block|,
literal|"relunit"
block|,
literal|"number"
block|,
literal|"o_merid"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|22
block|,
literal|22
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|25
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|26
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|29
block|,
literal|29
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|,
literal|6
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE    doesn't specify something else to do.  Zero means the default is an    error. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefact
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|20
block|,
literal|41
block|,
literal|18
block|,
literal|44
block|,
literal|15
block|,
literal|47
block|,
literal|0
block|,
literal|38
block|,
literal|50
block|,
literal|35
block|,
literal|17
block|,
literal|0
block|,
literal|51
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|6
block|,
literal|8
block|,
literal|32
block|,
literal|9
block|,
literal|21
block|,
literal|16
block|,
literal|27
block|,
literal|19
block|,
literal|40
block|,
literal|43
block|,
literal|46
block|,
literal|37
block|,
literal|49
block|,
literal|34
block|,
literal|22
block|,
literal|39
block|,
literal|42
block|,
literal|10
block|,
literal|45
block|,
literal|29
block|,
literal|36
block|,
literal|48
block|,
literal|33
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|31
block|,
literal|0
block|,
literal|26
block|,
literal|30
block|,
literal|25
block|,
literal|52
block|,
literal|23
block|,
literal|28
block|,
literal|53
block|,
literal|12
block|,
literal|0
block|,
literal|11
block|,
literal|0
block|,
literal|52
block|,
literal|24
block|,
literal|14
block|,
literal|13
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefgoto
index|[]
init|=
block|{
literal|1
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|57
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypact
index|[]
init|=
block|{
operator|-
literal|32768
block|,
literal|0
block|,
literal|1
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|19
block|,
operator|-
literal|32768
block|,
operator|-
literal|14
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|32
block|,
literal|26
block|,
literal|14
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|27
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|22
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|16
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|29
block|,
literal|25
block|,
literal|30
block|,
operator|-
literal|32768
block|,
literal|31
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|28
block|,
literal|23
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|33
block|,
operator|-
literal|32768
block|,
literal|34
block|,
operator|-
literal|7
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
literal|50
block|,
operator|-
literal|32768
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yypgoto
index|[]
init|=
block|{
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|32768
block|,
operator|-
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYLAST
value|53
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yytable
index|[]
init|=
block|{
literal|63
block|,
literal|48
block|,
literal|49
block|,
literal|54
block|,
literal|26
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|61
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|34
block|,
literal|35
block|,
literal|24
block|,
literal|36
block|,
literal|25
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|46
block|,
literal|43
block|,
literal|28
block|,
literal|44
block|,
literal|29
block|,
literal|45
block|,
literal|27
block|,
literal|30
block|,
literal|54
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|47
block|,
literal|51
block|,
literal|58
block|,
literal|55
block|,
literal|50
block|,
literal|56
block|,
literal|52
block|,
literal|53
block|,
literal|64
block|,
literal|59
block|,
literal|60
block|,
literal|62
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yycheck
index|[]
init|=
block|{
literal|0
block|,
literal|17
block|,
literal|18
block|,
literal|10
block|,
literal|18
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|17
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|5
block|,
literal|6
block|,
literal|20
block|,
literal|8
block|,
literal|4
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|3
block|,
literal|17
block|,
literal|6
block|,
literal|19
block|,
literal|8
block|,
literal|21
block|,
literal|4
block|,
literal|11
block|,
literal|10
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|20
block|,
literal|18
block|,
literal|21
block|,
literal|17
block|,
literal|17
block|,
literal|19
block|,
literal|18
block|,
literal|18
block|,
literal|0
block|,
literal|18
block|,
literal|18
block|,
literal|59
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYPURE
value|1
end_define

begin_comment
comment|/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
end_comment

begin_line
line|#
directive|line
number|3
file|"/opt/reb/share/bison/bison.simple"
end_line

begin_comment
comment|/* Skeleton output parser for bison,    Copyright 1984, 1989, 1990, 2000, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, when this file is copied by Bison into a    Bison output file, you may use that output file without restriction.    This special exception was added by the Free Software Foundation    in version 1.24 of Bison.  */
end_comment

begin_comment
comment|/* This is the parser code that is written into each bison parser when    the %semantic_parser declaration is not specified in the grammar.    It was written by Richard Stallman by simplifying the hairy parser    used when %semantic_parser is specified.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTACK_USE_ALLOCA
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|alloca
end_ifdef

begin_define
define|#
directive|define
name|YYSTACK_USE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* alloca not defined */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|YYSTACK_USE_ALLOCA
value|1
end_define

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not GNU C.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|sparc
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|YYSTACK_USE_ALLOCA
value|1
end_define

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not sparc */
end_comment

begin_comment
comment|/* We think this test detects Watcom and Microsoft C.  */
end_comment

begin_comment
comment|/* This used to test MSDOS, but that is a bad idea since that 	symbol is in the user namespace.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSDOS_
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__TURBOC__
argument_list|)
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* No need for malloc.h, which pollutes the namespace; instead, 	  just don't use alloca.  */
end_comment

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MSDOS, or __TURBOC__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_comment
comment|/* I don't know what this was needed for, but it pollutes the 	  namespace.  So I turned it off.  rms, 2 May 1997.  */
end_comment

begin_comment
comment|/* #include<malloc.h>  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_define
define|#
directive|define
name|YYSTACK_USE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MSDOS, or __TURBOC__, or _AIX */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* haible@ilog.fr says this works for HPUX 9.05 and up, and on 	   HPUX 10.  Eventually we can turn this on.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|YYSTACK_USE_ALLOCA
value|1
end_define

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MSDOS, or __TURBOC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sparc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not GNU C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca not defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYSTACK_USE_ALLOCA not defined */
end_comment

begin_if
if|#
directive|if
name|YYSTACK_USE_ALLOCA
end_if

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|alloca
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACK_ALLOC
value|malloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrstatus = 0)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|-2
end_define

begin_define
define|#
directive|define
name|YYEOF
value|0
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyacceptlab
end_define

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabortlab
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab1
end_define

begin_comment
comment|/* Like YYERROR except do call yyerror.  This remains here temporarily    to ease the transition to the new meaning of YYERROR, for GCC.    Once GCC version 2 has supplanted version 1, this can go.  */
end_comment

begin_define
define|#
directive|define
name|YYFAIL
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(!!yyerrstatus)
end_define

begin_define
define|#
directive|define
name|YYBACKUP
parameter_list|(
name|Token
parameter_list|,
name|Value
parameter_list|)
define|\
value|do								\   if (yychar == YYEMPTY&& yylen == 1)				\     {								\       yychar = (Token);						\       yylval = (Value);						\       yychar1 = YYTRANSLATE (yychar);				\       YYPOPSTACK;						\       goto yybackup;						\     }								\   else								\     { 								\       yyerror ("syntax error: cannot back up");			\       YYERROR;							\     }								\ while (0)
end_define

begin_define
define|#
directive|define
name|YYTERROR
value|1
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_comment
comment|/* YYLLOC_DEFAULT -- Compute the default location (before the actions    are run).     When YYLLOC_DEFAULT is run, CURRENT is set the location of the    first token.  By default, to implement support for ranges, extend    its range to the last symbol.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYLLOC_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|YYLLOC_DEFAULT
parameter_list|(
name|Current
parameter_list|,
name|Rhs
parameter_list|,
name|N
parameter_list|)
define|\
value|Current.last_line   = Rhs[N].last_line;	\    Current.last_column = Rhs[N].last_column;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYLEX -- calling `yylex' with the right arguments.  */
end_comment

begin_if
if|#
directive|if
name|YYPURE
end_if

begin_if
if|#
directive|if
name|YYLSP_NEEDED
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval,&yylloc, YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval,&yylloc)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYLSP_NEEDED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval, YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX
value|yylex (&yylval)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYLSP_NEEDED */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYPURE */
end_comment

begin_define
define|#
directive|define
name|YYLEX
value|yylex ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYPURE */
end_comment

begin_comment
comment|/* Enable debugging if requested.  */
end_comment

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
define|\
value|do {						\   if (yydebug)					\     fprintf Args;				\ } while (0)
end_define

begin_comment
comment|/* Nonzero means print parse trace. [The following comment makes no    sense to me.  Could someone clarify it?  --akim] Since this is    uninitialized, it does not stop multiple parsers from coexisting.    */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_define
define|#
directive|define
name|YYDPRINTF
parameter_list|(
name|Args
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYDEBUG */
end_comment

begin_comment
comment|/* YYINITDEPTH -- initial size of the parser's stacks.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYINITDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYINITDEPTH
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only    if the built-in stack extension method is used).  */
end_comment

begin_if
if|#
directive|if
name|YYMAXDEPTH
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Define __yy_memcpy.  Note that the size argument    should be passed with type unsigned int, because that is what the non-GCC    definitions require.  With GCC, __builtin_memcpy takes an arg    of type size_t, but it can handle unsigned int.  */
end_comment

begin_if
if|#
directive|if
name|__GNUC__
operator|>
literal|1
end_if

begin_comment
comment|/* GNU C and GNU C++ define this.  */
end_comment

begin_define
define|#
directive|define
name|__yy_memcpy
parameter_list|(
name|To
parameter_list|,
name|From
parameter_list|,
name|Count
parameter_list|)
value|__builtin_memcpy (To, From, Count)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not GNU C or C++ */
end_comment

begin_comment
comment|/* This is the most reliable way to avoid incompatibilities    in available built-in functions on various systems.  */
end_comment

begin_function
specifier|static
name|void
ifndef|#
directive|ifndef
name|__cplusplus
name|__yy_memcpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
else|#
directive|else
comment|/* __cplusplus */
function|__yy_memcpy
parameter_list|(
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
specifier|const
name|char
modifier|*
name|f
init|=
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
init|=
name|to
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|count
decl_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_line
line|#
directive|line
number|212
file|"/opt/reb/share/bison/bison.simple"
end_line

begin_comment
comment|/* The user can define YYPARSE_PARAM as the name of an argument to be passed    into yyparse.  The argument should have type void *.    It should actually point to an object.    Grammar actions can access the variable by casting it    to the proper pointer type.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
value|void *YYPARSE_PARAM
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__cplusplus */
end_comment

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
value|YYPARSE_PARAM
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
value|void *YYPARSE_PARAM;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__cplusplus */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !YYPARSE_PARAM */
end_comment

begin_define
define|#
directive|define
name|YYPARSE_PARAM_ARG
end_define

begin_define
define|#
directive|define
name|YYPARSE_PARAM_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !YYPARSE_PARAM */
end_comment

begin_comment
comment|/* Prevent warning if -Wstrict-prototypes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YY_DECL_VARIABLES -- depending whether we use a pure parser,    variables are global, or local to YYPARSE.  */
end_comment

begin_define
define|#
directive|define
name|_YY_DECL_VARIABLES
define|\
comment|/* The lookahead symbol.  */
define|\
value|int yychar;						\ 							\
comment|/* The semantic value of the lookahead symbol. */
value|\ YYSTYPE yylval;						\ 							\
comment|/* Number of parse errors so far.  */
value|\ int yynerrs;
end_define

begin_if
if|#
directive|if
name|YYLSP_NEEDED
end_if

begin_define
define|#
directive|define
name|YY_DECL_VARIABLES
define|\
value|_YY_DECL_VARIABLES				\ 						\
comment|/* Location data for the lookahead symbol.  */
value|\ YYLTYPE yylloc;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YY_DECL_VARIABLES
define|\
value|_YY_DECL_VARIABLES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If nonreentrant, generate the variables here. */
end_comment

begin_if
if|#
directive|if
operator|!
name|YYPURE
end_if

begin_function
name|YY_DECL_VARIABLES
endif|#
directive|endif
comment|/* !YYPURE */
name|int
name|yyparse
parameter_list|(
name|YYPARSE_PARAM_ARG
parameter_list|)
function|YYPARSE_PARAM_DECL
block|{
comment|/* If reentrant, generate the variables here. */
if|#
directive|if
name|YYPURE
name|YY_DECL_VARIABLES
endif|#
directive|endif
comment|/* !YYPURE */
specifier|register
name|int
name|yystate
decl_stmt|;
specifier|register
name|int
name|yyn
decl_stmt|;
comment|/* Number of tokens to shift before error messages enabled.  */
name|int
name|yyerrstatus
decl_stmt|;
comment|/* Lookahead token as an internal (translated) token number.  */
name|int
name|yychar1
init|=
literal|0
decl_stmt|;
comment|/* Three stacks and their tools:      `yyss': related to states,      `yysv': related to semantic values,      `yyls': related to locations.       Refer to the stacks thru separate pointers, to allow yyoverflow      to reallocate them elsewhere.  */
comment|/* The state stack. */
name|short
name|yyssa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|short
modifier|*
name|yyss
init|=
name|yyssa
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyssp
decl_stmt|;
comment|/* The semantic value stack.  */
name|YYSTYPE
name|yyvsa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|YYSTYPE
modifier|*
name|yyvs
init|=
name|yyvsa
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yyvsp
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
comment|/* The location stack.  */
name|YYLTYPE
name|yylsa
index|[
name|YYINITDEPTH
index|]
decl_stmt|;
name|YYLTYPE
modifier|*
name|yyls
init|=
name|yylsa
decl_stmt|;
name|YYLTYPE
modifier|*
name|yylsp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYLSP_NEEDED
define|#
directive|define
name|YYPOPSTACK
value|(yyvsp--, yyssp--, yylsp--)
else|#
directive|else
define|#
directive|define
name|YYPOPSTACK
value|(yyvsp--, yyssp--)
endif|#
directive|endif
name|int
name|yystacksize
init|=
name|YYINITDEPTH
decl_stmt|;
name|int
name|yyfree_stacks
init|=
literal|0
decl_stmt|;
comment|/* The variables used to return semantic value and location from the      action routines.  */
name|YYSTYPE
name|yyval
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|YYLTYPE
name|yyloc
decl_stmt|;
endif|#
directive|endif
comment|/* When reducing, the number of symbols on the RHS of the reduced      rule. */
name|int
name|yylen
decl_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Starting parse\n"
operator|)
argument_list|)
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yyerrstatus
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
comment|/* Cause a token to be read.  */
comment|/* Initialize stack pointers.      Waste one element of value and location stack      so that they stay on the same level as the state stack.      The wasted elements are never initialized.  */
name|yyssp
operator|=
name|yyss
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
expr_stmt|;
endif|#
directive|endif
goto|goto
name|yysetstate
goto|;
comment|/*------------------------------------------------------------. | yynewstate -- Push a new state, which is found in yystate.  | `------------------------------------------------------------*/
name|yynewstate
label|:
comment|/* In all cases, when you get here, the value and location stacks      have just been pushed. so pushing a state here evens the stacks.      */
name|yyssp
operator|++
expr_stmt|;
name|yysetstate
label|:
operator|*
name|yyssp
operator|=
name|yystate
expr_stmt|;
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
block|{
comment|/* Give user a chance to reallocate the stack. Use copies of 	 these so that the&'s don't force the real ones into memory. 	 */
name|YYSTYPE
modifier|*
name|yyvs1
init|=
name|yyvs
decl_stmt|;
name|short
modifier|*
name|yyss1
init|=
name|yyss
decl_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|YYLTYPE
modifier|*
name|yyls1
init|=
name|yyls
decl_stmt|;
endif|#
directive|endif
comment|/* Get the current used size of the three stacks, in elements.  */
name|int
name|size
init|=
name|yyssp
operator|-
name|yyss
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|yyoverflow
comment|/* Each stack pointer address is followed by the size of the 	 data in use in that stack, in bytes.  */
if|#
directive|if
name|YYLSP_NEEDED
comment|/* This used to be a conditional around just the two extra args, 	 but that might be undefined if yyoverflow is a macro.  */
name|yyoverflow
argument_list|(
literal|"parser stack overflow"
argument_list|,
operator|&
name|yyss1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
operator|&
name|yyls1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|,
operator|&
name|yystacksize
argument_list|)
expr_stmt|;
else|#
directive|else
name|yyoverflow
argument_list|(
literal|"parser stack overflow"
argument_list|,
operator|&
name|yyss1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|,
operator|&
name|yyvs1
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|,
operator|&
name|yystacksize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyss
operator|=
name|yyss1
expr_stmt|;
name|yyvs
operator|=
name|yyvs1
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yyls
operator|=
name|yyls1
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* no yyoverflow */
comment|/* Extend the stack our own way.  */
if|if
condition|(
name|yystacksize
operator|>=
name|YYMAXDEPTH
condition|)
block|{
name|yyerror
argument_list|(
literal|"parser stack overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyfree_stacks
condition|)
block|{
name|free
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvs
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|free
argument_list|(
name|yyls
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|2
return|;
block|}
name|yystacksize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|yystacksize
operator|>
name|YYMAXDEPTH
condition|)
name|yystacksize
operator|=
name|YYMAXDEPTH
expr_stmt|;
ifndef|#
directive|ifndef
name|YYSTACK_USE_ALLOCA
name|yyfree_stacks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|yyss
operator|=
operator|(
name|short
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|yystacksize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyss
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyss1
argument_list|,
name|size
operator|*
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|yyssp
argument_list|)
argument_list|)
expr_stmt|;
name|yyvs
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|yystacksize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyvs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyvs1
argument_list|,
name|size
operator|*
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|yyvsp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yyls
operator|=
operator|(
name|YYLTYPE
operator|*
operator|)
name|YYSTACK_ALLOC
argument_list|(
name|yystacksize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|)
expr_stmt|;
name|__yy_memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yyls
argument_list|,
operator|(
name|char
operator|*
operator|)
name|yyls1
argument_list|,
name|size
operator|*
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|yylsp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* no yyoverflow */
name|yyssp
operator|=
name|yyss
operator|+
name|size
operator|-
literal|1
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
operator|+
name|size
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|=
name|yyls
operator|+
name|size
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Stack size increased to %d\n"
operator|,
name|yystacksize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
name|YYABORT
expr_stmt|;
block|}
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Entering state %d\n"
operator|,
name|yystate
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|yybackup
goto|;
comment|/*-----------. | yybackup.  | `-----------*/
name|yybackup
label|:
comment|/* Do appropriate processing given the current state.  */
comment|/* Read a lookahead token if we need one and don't already have one.  */
comment|/* yyresume: */
comment|/* First try to decide what to do without reference to lookahead token.  */
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* Not known => get a lookahead token if don't already have one.  */
comment|/* yychar is either YYEMPTY or YYEOF      or a valid token in external form.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
block|{
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Reading a token: "
operator|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYLEX
expr_stmt|;
block|}
comment|/* Convert token to internal form (in yychar1) for indexing tables with */
if|if
condition|(
name|yychar
operator|<=
literal|0
condition|)
comment|/* This means end of input. */
block|{
name|yychar1
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEOF
expr_stmt|;
comment|/* Don't call YYLEX any more */
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Now at end of input.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yychar1
operator|=
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYDEBUG
comment|/* We have to keep this `#if YYDEBUG', since we use variables 	which are defined only if `YYDEBUG' is set.  */
if|if
condition|(
name|yydebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Next token is %d (%s"
argument_list|,
name|yychar
argument_list|,
name|yytname
index|[
name|yychar1
index|]
argument_list|)
expr_stmt|;
comment|/* Give the individual parser a way to print the precise 	     meaning of a token, for further debugging info.  */
ifdef|#
directive|ifdef
name|YYPRINT
name|YYPRINT
argument_list|(
name|stderr
argument_list|,
name|yychar
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|yyn
operator|+=
name|yychar1
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|yychar1
condition|)
goto|goto
name|yydefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
comment|/* yyn is what to do for this token type in this state.      Negative => reduce, -yyn is rule number.      Positive => shift, yyn is new state.        New state is final state => don't bother to shift,        just return success.      0, or most negative number => error.  */
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrlab
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
comment|/* Shift the lookahead token.  */
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Shifting token %d (%s), "
operator|,
name|yychar
operator|,
name|yytname
index|[
name|yychar1
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Discard the token being shifted unless it is eof.  */
if|if
condition|(
name|yychar
operator|!=
name|YYEOF
condition|)
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
comment|/* Count tokens shifted since error; after three, turn off error      status.  */
if|if
condition|(
name|yyerrstatus
condition|)
name|yyerrstatus
operator|--
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-----------------------------------------------------------. | yydefault -- do the default action for the current state.  | `-----------------------------------------------------------*/
name|yydefault
label|:
name|yyn
operator|=
name|yydefact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrlab
goto|;
goto|goto
name|yyreduce
goto|;
comment|/*-----------------------------. | yyreduce -- Do a reduction.  | `-----------------------------*/
name|yyreduce
label|:
comment|/* yyn is the number of a rule to reduce with.  */
name|yylen
operator|=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
comment|/* If YYLEN is nonzero, implement the default value of the action:      `$$ = $1'.       Otherwise, the following line sets YYVAL to the semantic value of      the lookahead token.  This behavior is undocumented and Bison      users should not rely upon it.  Assigning to YYVAL      unconditionally makes the parser a bit smaller, and it avoids a      GCC warning that YYVAL may be used uninitialized.  */
name|yyval
operator|=
name|yyvsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
comment|/* Similarly for the default location.  Let the user run additional      commands if for instance locations are ranges.  */
name|yyloc
operator|=
name|yylsp
index|[
literal|1
operator|-
name|yylen
index|]
expr_stmt|;
name|YYLLOC_DEFAULT
argument_list|(
name|yyloc
argument_list|,
operator|(
name|yylsp
operator|-
name|yylen
operator|)
argument_list|,
name|yylen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
comment|/* We have to keep this `#if YYDEBUG', since we use variables which      are defined only if `YYDEBUG' is set.  */
if|if
condition|(
name|yydebug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reducing via rule %d (line %d), "
argument_list|,
name|yyn
argument_list|,
name|yyrline
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
comment|/* Print the symbols being reduced, and their result.  */
for|for
control|(
name|i
operator|=
name|yyprhs
index|[
name|yyn
index|]
init|;
name|yyrhs
index|[
name|i
index|]
operator|>
literal|0
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|yytname
index|[
name|yyrhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> %s\n"
argument_list|,
name|yytname
index|[
name|yyr1
index|[
name|yyn
index|]
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|3
case|:
line|#
directive|line
number|196
file|"getdate.y"
block|{
name|PC
operator|.
name|times_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|4
case|:
line|#
directive|line
number|198
file|"getdate.y"
block|{
name|PC
operator|.
name|local_zones_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|5
case|:
line|#
directive|line
number|200
file|"getdate.y"
block|{
name|PC
operator|.
name|zones_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|6
case|:
line|#
directive|line
number|202
file|"getdate.y"
block|{
name|PC
operator|.
name|dates_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|7
case|:
line|#
directive|line
number|204
file|"getdate.y"
block|{
name|PC
operator|.
name|days_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|8
case|:
line|#
directive|line
number|206
file|"getdate.y"
block|{
name|PC
operator|.
name|rels_seen
operator|++
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|10
case|:
line|#
directive|line
number|212
file|"getdate.y"
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
literal|0
expr_stmt|;
name|PC
operator|.
name|seconds
operator|=
literal|0
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|11
case|:
line|#
directive|line
number|219
file|"getdate.y"
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|seconds
operator|=
literal|0
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|12
case|:
line|#
directive|line
number|226
file|"getdate.y"
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|MER24
expr_stmt|;
name|PC
operator|.
name|zones_seen
operator|++
expr_stmt|;
name|PC
operator|.
name|time_zone
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|%
literal|100
operator|+
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|/
literal|100
operator|)
operator|*
literal|60
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|13
case|:
line|#
directive|line
number|234
file|"getdate.y"
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|seconds
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|14
case|:
line|#
directive|line
number|241
file|"getdate.y"
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
operator|-
literal|5
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|seconds
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|MER24
expr_stmt|;
name|PC
operator|.
name|zones_seen
operator|++
expr_stmt|;
name|PC
operator|.
name|time_zone
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|%
literal|100
operator|+
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|/
literal|100
operator|)
operator|*
literal|60
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|15
case|:
line|#
directive|line
number|253
file|"getdate.y"
block|{
name|PC
operator|.
name|local_isdst
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|16
case|:
line|#
directive|line
number|255
file|"getdate.y"
block|{
name|PC
operator|.
name|local_isdst
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|<
literal|0
condition|?
literal|1
else|:
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|+
literal|1
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|17
case|:
line|#
directive|line
number|260
file|"getdate.y"
block|{
name|PC
operator|.
name|time_zone
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|18
case|:
line|#
directive|line
number|262
file|"getdate.y"
block|{
name|PC
operator|.
name|time_zone
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
operator|+
literal|60
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|19
case|:
line|#
directive|line
number|264
file|"getdate.y"
block|{
name|PC
operator|.
name|time_zone
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|+
literal|60
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|20
case|:
line|#
directive|line
number|269
file|"getdate.y"
block|{
name|PC
operator|.
name|day_ordinal
operator|=
literal|1
expr_stmt|;
name|PC
operator|.
name|day_number
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|21
case|:
line|#
directive|line
number|274
file|"getdate.y"
block|{
name|PC
operator|.
name|day_ordinal
operator|=
literal|1
expr_stmt|;
name|PC
operator|.
name|day_number
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|22
case|:
line|#
directive|line
number|279
file|"getdate.y"
block|{
name|PC
operator|.
name|day_ordinal
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|day_number
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|23
case|:
line|#
directive|line
number|287
file|"getdate.y"
block|{
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|24
case|:
line|#
directive|line
number|292
file|"getdate.y"
block|{
comment|/* Interpret as YYYY/MM/DD if the first value has 4 or more digits, 	   otherwise as MM/DD/YY. 	   The goal in recognizing YYYY/MM/DD is solely to support legacy 	   machine-generated dates like those in an RCS log listing.  If 	   you want portability, use the ISO 8601 format.  */
if|if
condition|(
literal|4
operator|<=
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|textintval
operator|.
name|digits
condition|)
block|{
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|textintval
expr_stmt|;
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|4
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
expr_stmt|;
block|}
empty_stmt|;
break|break;
block|}
case|case
literal|25
case|:
line|#
directive|line
number|312
file|"getdate.y"
block|{
comment|/* ISO 8601 format.  YYYY-MM-DD.  */
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
expr_stmt|;
name|PC
operator|.
name|month
operator|=
operator|-
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|day
operator|=
operator|-
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|26
case|:
line|#
directive|line
number|319
file|"getdate.y"
block|{
comment|/* e.g. 17-JUN-1992.  */
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|PC
operator|.
name|year
operator|.
name|value
operator|=
operator|-
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|year
operator|.
name|digits
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|digits
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|27
case|:
line|#
directive|line
number|327
file|"getdate.y"
block|{
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|28
case|:
line|#
directive|line
number|332
file|"getdate.y"
block|{
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|.
name|intval
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|29
case|:
line|#
directive|line
number|338
file|"getdate.y"
block|{
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|30
case|:
line|#
directive|line
number|343
file|"getdate.y"
block|{
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|month
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|31
case|:
line|#
directive|line
number|352
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_seconds
operator|=
operator|-
name|PC
operator|.
name|rel_seconds
expr_stmt|;
name|PC
operator|.
name|rel_minutes
operator|=
operator|-
name|PC
operator|.
name|rel_minutes
expr_stmt|;
name|PC
operator|.
name|rel_hour
operator|=
operator|-
name|PC
operator|.
name|rel_hour
expr_stmt|;
name|PC
operator|.
name|rel_day
operator|=
operator|-
name|PC
operator|.
name|rel_day
expr_stmt|;
name|PC
operator|.
name|rel_month
operator|=
operator|-
name|PC
operator|.
name|rel_month
expr_stmt|;
name|PC
operator|.
name|rel_year
operator|=
operator|-
name|PC
operator|.
name|rel_year
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|33
case|:
line|#
directive|line
number|365
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_year
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|34
case|:
line|#
directive|line
number|367
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_year
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|35
case|:
line|#
directive|line
number|369
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_year
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|36
case|:
line|#
directive|line
number|371
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_month
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|37
case|:
line|#
directive|line
number|373
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_month
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|38
case|:
line|#
directive|line
number|375
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_month
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|39
case|:
line|#
directive|line
number|377
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_day
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|40
case|:
line|#
directive|line
number|379
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_day
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|41
case|:
line|#
directive|line
number|381
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_day
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
break|break;
block|}
case|case
literal|42
case|:
line|#
directive|line
number|383
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_hour
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|43
case|:
line|#
directive|line
number|385
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_hour
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|44
case|:
line|#
directive|line
number|387
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_hour
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
break|break;
block|}
case|case
literal|45
case|:
line|#
directive|line
number|389
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_minutes
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|46
case|:
line|#
directive|line
number|391
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_minutes
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|47
case|:
line|#
directive|line
number|393
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_minutes
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
break|break;
block|}
case|case
literal|48
case|:
line|#
directive|line
number|395
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_seconds
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|49
case|:
line|#
directive|line
number|397
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_seconds
operator|+=
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|.
name|textintval
operator|.
name|value
operator|*
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|50
case|:
line|#
directive|line
number|399
file|"getdate.y"
block|{
name|PC
operator|.
name|rel_seconds
operator|+=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|51
case|:
line|#
directive|line
number|404
file|"getdate.y"
block|{
if|if
condition|(
name|PC
operator|.
name|dates_seen
operator|&&
operator|!
name|PC
operator|.
name|rels_seen
operator|&&
operator|(
name|PC
operator|.
name|times_seen
operator|||
literal|2
operator|<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|digits
operator|)
condition|)
name|PC
operator|.
name|year
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
expr_stmt|;
else|else
block|{
if|if
condition|(
literal|4
operator|<
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|digits
condition|)
block|{
name|PC
operator|.
name|dates_seen
operator|++
expr_stmt|;
name|PC
operator|.
name|day
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|%
literal|100
expr_stmt|;
name|PC
operator|.
name|month
operator|=
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|/
literal|100
operator|)
operator|%
literal|100
expr_stmt|;
name|PC
operator|.
name|year
operator|.
name|value
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|/
literal|10000
expr_stmt|;
name|PC
operator|.
name|year
operator|.
name|digits
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|digits
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|PC
operator|.
name|times_seen
operator|++
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|digits
operator|<=
literal|2
condition|)
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|PC
operator|.
name|hour
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|/
literal|100
expr_stmt|;
name|PC
operator|.
name|minutes
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|textintval
operator|.
name|value
operator|%
literal|100
expr_stmt|;
block|}
name|PC
operator|.
name|seconds
operator|=
literal|0
expr_stmt|;
name|PC
operator|.
name|meridian
operator|=
name|MER24
expr_stmt|;
block|}
block|}
empty_stmt|;
break|break;
block|}
case|case
literal|52
case|:
line|#
directive|line
number|440
file|"getdate.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|MER24
expr_stmt|;
empty_stmt|;
break|break;
block|}
case|case
literal|53
case|:
line|#
directive|line
number|442
file|"getdate.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|yyvsp
index|[
literal|0
index|]
operator|.
name|intval
expr_stmt|;
empty_stmt|;
break|break;
block|}
block|}
line|#
directive|line
number|606
file|"/opt/reb/share/bison/bison.simple"
name|yyvsp
operator|-=
name|yylen
expr_stmt|;
name|yyssp
operator|-=
name|yylen
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|-=
name|yylen
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|ssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssp1
operator|!=
name|yyssp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|ssp1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yyloc
expr_stmt|;
endif|#
directive|endif
comment|/* Now `shift' the result of the reduction.  Determine what state      that goes to, based on the state we popped back to and the rule      number reduced by.  */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yystate
operator|=
name|yypgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
operator|+
operator|*
name|yyssp
expr_stmt|;
if|if
condition|(
name|yystate
operator|>=
literal|0
operator|&&
name|yystate
operator|<=
name|YYLAST
operator|&&
name|yycheck
index|[
name|yystate
index|]
operator|==
operator|*
name|yyssp
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yystate
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydefgoto
index|[
name|yyn
operator|-
name|YYNTBASE
index|]
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*------------------------------------. | yyerrlab -- here on detecting error | `------------------------------------*/
name|yyerrlab
label|:
comment|/* If not already recovering from an error, report this error.  */
if|if
condition|(
operator|!
name|yyerrstatus
condition|)
block|{
operator|++
name|yynerrs
expr_stmt|;
ifdef|#
directive|ifdef
name|YYERROR_VERBOSE
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|>
name|YYFLAG
operator|&&
name|yyn
operator|<
name|YYLAST
condition|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|x
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
for|for
control|(
name|x
operator|=
operator|(
name|yyn
operator|<
literal|0
condition|?
operator|-
name|yyn
else|:
literal|0
operator|)
init|;
name|x
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|x
operator|+
name|yyn
index|]
operator|==
name|x
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|yytname
index|[
name|x
index|]
argument_list|)
operator|+
literal|15
operator|,
name|count
operator|++
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
literal|"parse error, unexpected `"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|msg
argument_list|,
literal|"parse error, unexpected `"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|yychar
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|5
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|(
name|yyn
operator|<
literal|0
condition|?
operator|-
name|yyn
else|:
literal|0
operator|)
init|;
name|x
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|yytname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|yycheck
index|[
name|x
operator|+
name|yyn
index|]
operator|==
name|x
condition|)
block|{
name|strcat
argument_list|(
name|msg
argument_list|,
name|count
operator|==
literal|0
condition|?
literal|", expecting `"
else|:
literal|" or `"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|yytname
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|yyerror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
name|yyerror
argument_list|(
literal|"parse error; also virtual memory exceeded"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* YYERROR_VERBOSE */
name|yyerror
argument_list|(
literal|"parse error"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|yyerrlab1
goto|;
comment|/*--------------------------------------------------. | yyerrlab1 -- error raised explicitly by an action | `--------------------------------------------------*/
name|yyerrlab1
label|:
if|if
condition|(
name|yyerrstatus
operator|==
literal|3
condition|)
block|{
comment|/* If just tried and failed to reuse lookahead token after an 	 error, discard it.  */
comment|/* return failure if at end of input */
if|if
condition|(
name|yychar
operator|==
name|YYEOF
condition|)
name|YYABORT
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Discarding token %d (%s).\n"
operator|,
name|yychar
operator|,
name|yytname
index|[
name|yychar1
index|]
operator|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
block|}
comment|/* Else will try to reuse lookahead token after shifting the error      token.  */
name|yyerrstatus
operator|=
literal|3
expr_stmt|;
comment|/* Each real token shifted decrements this */
goto|goto
name|yyerrhandle
goto|;
comment|/*-------------------------------------------------------------------. | yyerrdefault -- current state does not do anything special for the | | error token.                                                       | `-------------------------------------------------------------------*/
name|yyerrdefault
label|:
if|#
directive|if
literal|0
comment|/* This is wrong; only states that explicitly want error tokens      should shift them.  */
comment|/* If its default is to accept any token, ok.  Otherwise pop it.  */
block|yyn = yydefact[yystate];   if (yyn)     goto yydefault;
endif|#
directive|endif
comment|/*---------------------------------------------------------------. | yyerrpop -- pop the current state because it cannot handle the | | error token                                                    | `---------------------------------------------------------------*/
name|yyerrpop
label|:
if|if
condition|(
name|yyssp
operator|==
name|yyss
condition|)
name|YYABORT
expr_stmt|;
name|yyvsp
operator|--
expr_stmt|;
name|yystate
operator|=
operator|*
operator|--
name|yyssp
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|yylsp
operator|--
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|short
modifier|*
name|ssp1
init|=
name|yyss
operator|-
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: state stack now"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssp1
operator|!=
name|yyssp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
operator|*
operator|++
name|ssp1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*--------------. | yyerrhandle.  | `--------------*/
name|yyerrhandle
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|+=
name|YYTERROR
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
operator|||
name|yyn
operator|>
name|YYLAST
operator|||
name|yycheck
index|[
name|yyn
index|]
operator|!=
name|YYTERROR
condition|)
goto|goto
name|yyerrdefault
goto|;
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|yyn
operator|==
name|YYFLAG
condition|)
goto|goto
name|yyerrpop
goto|;
name|yyn
operator|=
operator|-
name|yyn
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
elseif|else
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
goto|goto
name|yyerrpop
goto|;
if|if
condition|(
name|yyn
operator|==
name|YYFINAL
condition|)
name|YYACCEPT
expr_stmt|;
name|YYDPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"Shifting error token, "
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
operator|*
operator|++
name|yylsp
operator|=
name|yylloc
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|yyn
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/*-------------------------------------. | yyacceptlab -- YYACCEPT comes here.  | `-------------------------------------*/
name|yyacceptlab
label|:
if|if
condition|(
name|yyfree_stacks
condition|)
block|{
name|free
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvs
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|free
argument_list|(
name|yyls
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
comment|/*-----------------------------------. | yyabortlab -- YYABORT comes here.  | `-----------------------------------*/
name|yyabortlab
label|:
if|if
condition|(
name|yyfree_stacks
condition|)
block|{
name|free
argument_list|(
name|yyss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yyvs
argument_list|)
expr_stmt|;
if|#
directive|if
name|YYLSP_NEEDED
name|free
argument_list|(
name|yyls
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_line
line|#
directive|line
number|445
file|"getdate.y"
end_line

begin_comment
comment|/* Include this file down here because bison inserts code above which    may define-away `const'.  We want the prototype for get_date to have    the same signature as the function definition.  */
end_comment

begin_include
include|#
directive|include
file|"getdate.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|gmtime
end_ifndef

begin_function_decl
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|localtime
end_ifndef

begin_function_decl
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|mktime
end_ifndef

begin_function_decl
name|time_t
name|mktime
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|table
specifier|const
name|meridian_table
index|[]
init|=
block|{
block|{
literal|"AM"
block|,
name|tMERIDIAN
block|,
name|MERam
block|}
block|,
block|{
literal|"A.M."
block|,
name|tMERIDIAN
block|,
name|MERam
block|}
block|,
block|{
literal|"PM"
block|,
name|tMERIDIAN
block|,
name|MERpm
block|}
block|,
block|{
literal|"P.M."
block|,
name|tMERIDIAN
block|,
name|MERpm
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|table
specifier|const
name|dst_table
index|[]
init|=
block|{
block|{
literal|"DST"
block|,
name|tDST
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|table
specifier|const
name|month_and_day_table
index|[]
init|=
block|{
block|{
literal|"JANUARY"
block|,
name|tMONTH
block|,
literal|1
block|}
block|,
block|{
literal|"FEBRUARY"
block|,
name|tMONTH
block|,
literal|2
block|}
block|,
block|{
literal|"MARCH"
block|,
name|tMONTH
block|,
literal|3
block|}
block|,
block|{
literal|"APRIL"
block|,
name|tMONTH
block|,
literal|4
block|}
block|,
block|{
literal|"MAY"
block|,
name|tMONTH
block|,
literal|5
block|}
block|,
block|{
literal|"JUNE"
block|,
name|tMONTH
block|,
literal|6
block|}
block|,
block|{
literal|"JULY"
block|,
name|tMONTH
block|,
literal|7
block|}
block|,
block|{
literal|"AUGUST"
block|,
name|tMONTH
block|,
literal|8
block|}
block|,
block|{
literal|"SEPTEMBER"
block|,
name|tMONTH
block|,
literal|9
block|}
block|,
block|{
literal|"SEPT"
block|,
name|tMONTH
block|,
literal|9
block|}
block|,
block|{
literal|"OCTOBER"
block|,
name|tMONTH
block|,
literal|10
block|}
block|,
block|{
literal|"NOVEMBER"
block|,
name|tMONTH
block|,
literal|11
block|}
block|,
block|{
literal|"DECEMBER"
block|,
name|tMONTH
block|,
literal|12
block|}
block|,
block|{
literal|"SUNDAY"
block|,
name|tDAY
block|,
literal|0
block|}
block|,
block|{
literal|"MONDAY"
block|,
name|tDAY
block|,
literal|1
block|}
block|,
block|{
literal|"TUESDAY"
block|,
name|tDAY
block|,
literal|2
block|}
block|,
block|{
literal|"TUES"
block|,
name|tDAY
block|,
literal|2
block|}
block|,
block|{
literal|"WEDNESDAY"
block|,
name|tDAY
block|,
literal|3
block|}
block|,
block|{
literal|"WEDNES"
block|,
name|tDAY
block|,
literal|3
block|}
block|,
block|{
literal|"THURSDAY"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"THUR"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"THURS"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|"FRIDAY"
block|,
name|tDAY
block|,
literal|5
block|}
block|,
block|{
literal|"SATURDAY"
block|,
name|tDAY
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|table
specifier|const
name|time_units_table
index|[]
init|=
block|{
block|{
literal|"YEAR"
block|,
name|tYEAR_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"MONTH"
block|,
name|tMONTH_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"FORTNIGHT"
block|,
name|tDAY_UNIT
block|,
literal|14
block|}
block|,
block|{
literal|"WEEK"
block|,
name|tDAY_UNIT
block|,
literal|7
block|}
block|,
block|{
literal|"DAY"
block|,
name|tDAY_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"HOUR"
block|,
name|tHOUR_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"MINUTE"
block|,
name|tMINUTE_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"MIN"
block|,
name|tMINUTE_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"SECOND"
block|,
name|tSEC_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|"SEC"
block|,
name|tSEC_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assorted relative-time words. */
end_comment

begin_decl_stmt
specifier|static
name|table
specifier|const
name|relative_time_table
index|[]
init|=
block|{
block|{
literal|"TOMORROW"
block|,
name|tMINUTE_UNIT
block|,
literal|24
operator|*
literal|60
block|}
block|,
block|{
literal|"YESTERDAY"
block|,
name|tMINUTE_UNIT
block|,
operator|-
operator|(
literal|24
operator|*
literal|60
operator|)
block|}
block|,
block|{
literal|"TODAY"
block|,
name|tMINUTE_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|"NOW"
block|,
name|tMINUTE_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|"LAST"
block|,
name|tUNUMBER
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"THIS"
block|,
name|tUNUMBER
block|,
literal|0
block|}
block|,
block|{
literal|"NEXT"
block|,
name|tUNUMBER
block|,
literal|1
block|}
block|,
block|{
literal|"FIRST"
block|,
name|tUNUMBER
block|,
literal|1
block|}
block|,
comment|/*{ "SECOND",	tUNUMBER,	 2 }, */
block|{
literal|"THIRD"
block|,
name|tUNUMBER
block|,
literal|3
block|}
block|,
block|{
literal|"FOURTH"
block|,
name|tUNUMBER
block|,
literal|4
block|}
block|,
block|{
literal|"FIFTH"
block|,
name|tUNUMBER
block|,
literal|5
block|}
block|,
block|{
literal|"SIXTH"
block|,
name|tUNUMBER
block|,
literal|6
block|}
block|,
block|{
literal|"SEVENTH"
block|,
name|tUNUMBER
block|,
literal|7
block|}
block|,
block|{
literal|"EIGHTH"
block|,
name|tUNUMBER
block|,
literal|8
block|}
block|,
block|{
literal|"NINTH"
block|,
name|tUNUMBER
block|,
literal|9
block|}
block|,
block|{
literal|"TENTH"
block|,
name|tUNUMBER
block|,
literal|10
block|}
block|,
block|{
literal|"ELEVENTH"
block|,
name|tUNUMBER
block|,
literal|11
block|}
block|,
block|{
literal|"TWELFTH"
block|,
name|tUNUMBER
block|,
literal|12
block|}
block|,
block|{
literal|"AGO"
block|,
name|tAGO
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time zone table.  This table is necessarily incomplete, as time    zone abbreviations are ambiguous; e.g. Australians interpret "EST"    as Eastern time in Australia, not as US Eastern Standard Time.    You cannot rely on getdate to handle arbitrary time zone    abbreviations; use numeric abbreviations like `-0500' instead.  */
end_comment

begin_decl_stmt
specifier|static
name|table
specifier|const
name|time_zone_table
index|[]
init|=
block|{
block|{
literal|"GMT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Greenwich Mean */
block|{
literal|"UT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Universal (Coordinated) */
block|{
literal|"UTC"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
literal|"WET"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Western European */
block|{
literal|"WEST"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* Western European Summer */
block|{
literal|"BST"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* British Summer */
block|{
literal|"ART"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Argentina */
block|{
literal|"BRT"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Brazil */
block|{
literal|"BRST"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Brazil Summer */
block|{
literal|"NST"
block|,
name|tZONE
block|,
operator|-
operator|(
name|HOUR
argument_list|(
literal|3
argument_list|)
operator|+
literal|30
operator|)
block|}
block|,
comment|/* Newfoundland Standard */
block|{
literal|"NDT"
block|,
name|tDAYZONE
block|,
operator|-
operator|(
name|HOUR
argument_list|(
literal|3
argument_list|)
operator|+
literal|30
operator|)
block|}
block|,
comment|/* Newfoundland Daylight */
block|{
literal|"AST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Atlantic Standard */
block|{
literal|"ADT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Atlantic Daylight */
block|{
literal|"CLT"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Chile */
block|{
literal|"CLST"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/* Chile Summer */
block|{
literal|"EST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* Eastern Standard */
block|{
literal|"EDT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* Eastern Daylight */
block|{
literal|"CST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/* Central Standard */
block|{
literal|"CDT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/* Central Daylight */
block|{
literal|"MST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* Mountain Standard */
block|{
literal|"MDT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
comment|/* Mountain Daylight */
block|{
literal|"PST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* Pacific Standard */
block|{
literal|"PDT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* Pacific Daylight */
block|{
literal|"AKST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Alaska Standard */
block|{
literal|"AKDT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Alaska Daylight */
block|{
literal|"HST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Hawaii Standard */
block|{
literal|"HAST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Hawaii-Aleutian Standard */
block|{
literal|"HADT"
block|,
name|tDAYZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Hawaii-Aleutian Daylight */
block|{
literal|"SST"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* Samoa Standard */
block|{
literal|"WAT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* West Africa */
block|{
literal|"CET"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Central European */
block|{
literal|"CEST"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Central European Summer */
block|{
literal|"MET"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European */
block|{
literal|"MEZ"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European */
block|{
literal|"MEST"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European Summer */
block|{
literal|"MESZ"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
comment|/* Middle European Summer */
block|{
literal|"EET"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* Eastern European */
block|{
literal|"EEST"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* Eastern European Summer */
block|{
literal|"CAT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* Central Africa */
block|{
literal|"SAST"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/* South Africa Standard */
block|{
literal|"EAT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* East Africa */
block|{
literal|"MSK"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Moscow */
block|{
literal|"MSD"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/* Moscow Daylight */
block|{
literal|"IST"
block|,
name|tZONE
block|,
operator|(
name|HOUR
argument_list|(
literal|5
argument_list|)
operator|+
literal|30
operator|)
block|}
block|,
comment|/* India Standard */
block|{
literal|"SGT"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* Singapore */
block|{
literal|"KST"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Korea Standard */
block|{
literal|"JST"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* Japan Standard */
block|{
literal|"GST"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/* Guam Standard */
block|{
literal|"NZST"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* New Zealand Standard */
block|{
literal|"NZDT"
block|,
name|tDAYZONE
block|,
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* New Zealand Daylight */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Military time zone table. */
end_comment

begin_decl_stmt
specifier|static
name|table
specifier|const
name|military_table
index|[]
init|=
block|{
block|{
literal|"A"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
block|{
literal|"B"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
block|{
literal|"C"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
block|{
literal|"D"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
block|{
literal|"E"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
block|{
literal|"F"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
block|{
literal|"G"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
block|{
literal|"H"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
block|{
literal|"I"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
block|{
literal|"K"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
block|{
literal|"L"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|11
argument_list|)
block|}
block|,
block|{
literal|"M"
block|,
name|tZONE
block|,
operator|-
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
block|{
literal|"N"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|1
argument_list|)
block|}
block|,
block|{
literal|"O"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|2
argument_list|)
block|}
block|,
block|{
literal|"P"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|3
argument_list|)
block|}
block|,
block|{
literal|"Q"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|4
argument_list|)
block|}
block|,
block|{
literal|"R"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|5
argument_list|)
block|}
block|,
block|{
literal|"S"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|6
argument_list|)
block|}
block|,
block|{
literal|"T"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|7
argument_list|)
block|}
block|,
block|{
literal|"U"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|8
argument_list|)
block|}
block|,
block|{
literal|"V"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|9
argument_list|)
block|}
block|,
block|{
literal|"W"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|10
argument_list|)
block|}
block|,
block|{
literal|"X"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|11
argument_list|)
block|}
block|,
block|{
literal|"Y"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|12
argument_list|)
block|}
block|,
block|{
literal|"Z"
block|,
name|tZONE
block|,
name|HOUR
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|to_hour
parameter_list|(
name|int
name|hours
parameter_list|,
name|int
name|meridian
parameter_list|)
block|{
switch|switch
condition|(
name|meridian
condition|)
block|{
case|case
name|MER24
case|:
return|return
literal|0
operator|<=
name|hours
operator|&&
name|hours
operator|<
literal|24
condition|?
name|hours
else|:
operator|-
literal|1
return|;
case|case
name|MERam
case|:
return|return
literal|0
operator|<
name|hours
operator|&&
name|hours
operator|<
literal|12
condition|?
name|hours
else|:
name|hours
operator|==
literal|12
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
name|MERpm
case|:
return|return
literal|0
operator|<
name|hours
operator|&&
name|hours
operator|<
literal|12
condition|?
name|hours
operator|+
literal|12
else|:
name|hours
operator|==
literal|12
condition|?
literal|12
else|:
operator|-
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|int
name|to_year
parameter_list|(
name|textint
name|textyear
parameter_list|)
block|{
name|int
name|year
init|=
name|textyear
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|year
operator|<
literal|0
condition|)
name|year
operator|=
operator|-
name|year
expr_stmt|;
comment|/* XPG4 suggests that years 00-68 map to 2000-2068, and      years 69-99 map to 1969-1999.  */
if|if
condition|(
name|textyear
operator|.
name|digits
operator|==
literal|2
condition|)
name|year
operator|+=
name|year
operator|<
literal|69
condition|?
literal|2000
else|:
literal|1900
expr_stmt|;
return|return
name|year
return|;
block|}
end_function

begin_function
specifier|static
name|table
specifier|const
modifier|*
name|lookup_zone
parameter_list|(
name|parser_control
specifier|const
modifier|*
name|pc
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|table
specifier|const
modifier|*
name|tp
decl_stmt|;
comment|/* Try local zone abbreviations first; they're more likely to be right.  */
for|for
control|(
name|tp
operator|=
name|pc
operator|->
name|local_time_zone_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
for|for
control|(
name|tp
operator|=
name|time_zone_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|HAVE_TM_GMTOFF
end_if

begin_comment
comment|/* Yield the difference between *A and *B,    measured in seconds, ignoring leap seconds.    The body of this function is taken directly from the GNU C Library;    see src/strftime.c.  */
end_comment

begin_function
specifier|static
name|int
name|tm_diff
parameter_list|(
name|struct
name|tm
specifier|const
modifier|*
name|a
parameter_list|,
name|struct
name|tm
specifier|const
modifier|*
name|b
parameter_list|)
block|{
comment|/* Compute intervening leap days correctly even if year is negative.      Take care to avoid int overflow in leap day calculations,      but it's OK to assume that A and B are close to each other.  */
name|int
name|a4
init|=
operator|(
name|a
operator|->
name|tm_year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|a
operator|->
name|tm_year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|b4
init|=
operator|(
name|b
operator|->
name|tm_year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|b
operator|->
name|tm_year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|a100
init|=
name|a4
operator|/
literal|25
operator|-
operator|(
name|a4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|b100
init|=
name|b4
operator|/
literal|25
operator|-
operator|(
name|b4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|a400
init|=
name|a100
operator|>>
literal|2
decl_stmt|;
name|int
name|b400
init|=
name|b100
operator|>>
literal|2
decl_stmt|;
name|int
name|intervening_leap_days
init|=
operator|(
name|a4
operator|-
name|b4
operator|)
operator|-
operator|(
name|a100
operator|-
name|b100
operator|)
operator|+
operator|(
name|a400
operator|-
name|b400
operator|)
decl_stmt|;
name|int
name|years
init|=
name|a
operator|->
name|tm_year
operator|-
name|b
operator|->
name|tm_year
decl_stmt|;
name|int
name|days
init|=
operator|(
literal|365
operator|*
name|years
operator|+
name|intervening_leap_days
operator|+
operator|(
name|a
operator|->
name|tm_yday
operator|-
name|b
operator|->
name|tm_yday
operator|)
operator|)
decl_stmt|;
return|return
operator|(
literal|60
operator|*
operator|(
literal|60
operator|*
operator|(
literal|24
operator|*
name|days
operator|+
operator|(
name|a
operator|->
name|tm_hour
operator|-
name|b
operator|->
name|tm_hour
operator|)
operator|)
operator|+
operator|(
name|a
operator|->
name|tm_min
operator|-
name|b
operator|->
name|tm_min
operator|)
operator|)
operator|+
operator|(
name|a
operator|->
name|tm_sec
operator|-
name|b
operator|->
name|tm_sec
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_TM_GMTOFF */
end_comment

begin_function
specifier|static
name|table
specifier|const
modifier|*
name|lookup_word
parameter_list|(
name|parser_control
specifier|const
modifier|*
name|pc
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|size_t
name|wordlen
decl_stmt|;
name|table
specifier|const
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|abbrev
decl_stmt|;
comment|/* Make it uppercase.  */
for|for
control|(
name|p
operator|=
name|word
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|meridian_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
comment|/* See if we have an abbreviation for a month. */
name|wordlen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|wordlen
operator|==
literal|3
operator|||
operator|(
name|wordlen
operator|==
literal|4
operator|&&
name|word
index|[
literal|3
index|]
operator|==
literal|'.'
operator|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|month_and_day_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
operator|(
name|abbrev
condition|?
name|strncmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|,
literal|3
argument_list|)
else|:
name|strcmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
if|if
condition|(
operator|(
name|tp
operator|=
name|lookup_zone
argument_list|(
name|pc
argument_list|,
name|word
argument_list|)
operator|)
condition|)
return|return
name|tp
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|dst_table
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|dst_table
return|;
for|for
control|(
name|tp
operator|=
name|time_units_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
comment|/* Strip off any plural and try the units table again. */
if|if
condition|(
name|word
index|[
name|wordlen
operator|-
literal|1
index|]
operator|==
literal|'S'
condition|)
block|{
name|word
index|[
name|wordlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|time_units_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
name|word
index|[
name|wordlen
operator|-
literal|1
index|]
operator|=
literal|'S'
expr_stmt|;
comment|/* For "this" in relative_time_table.  */
block|}
for|for
control|(
name|tp
operator|=
name|relative_time_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|tp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
return|;
comment|/* Military time zones. */
if|if
condition|(
name|wordlen
operator|==
literal|1
condition|)
for|for
control|(
name|tp
operator|=
name|military_table
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|word
index|[
literal|0
index|]
operator|==
name|tp
operator|->
name|name
index|[
literal|0
index|]
condition|)
return|return
name|tp
return|;
comment|/* Drop out any periods and try the time zone table again. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|q
operator|=
name|word
init|;
operator|(
operator|*
name|p
operator|=
operator|*
name|q
operator|)
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|(
name|tp
operator|=
name|lookup_zone
argument_list|(
name|pc
argument_list|,
name|word
argument_list|)
operator|)
condition|)
return|return
name|tp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|yylex
parameter_list|(
name|YYSTYPE
modifier|*
name|lvalp
parameter_list|,
name|parser_control
modifier|*
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|pc
operator|->
name|input
operator|,
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
name|pc
operator|->
name|input
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|sign
operator|=
name|c
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|pc
operator|->
name|input
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
comment|/* skip the '-' sign */
continue|continue;
block|}
else|else
name|sign
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|pc
operator|->
name|input
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|value
operator|=
literal|10
operator|*
name|value
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|lvalp
operator|->
name|textintval
operator|.
name|value
operator|=
name|sign
operator|<
literal|0
condition|?
operator|-
name|value
else|:
name|value
expr_stmt|;
name|lvalp
operator|->
name|textintval
operator|.
name|digits
operator|=
name|p
operator|-
name|pc
operator|->
name|input
expr_stmt|;
name|pc
operator|->
name|input
operator|=
name|p
expr_stmt|;
return|return
name|sign
condition|?
name|tSNUMBER
else|:
name|tUNUMBER
return|;
block|}
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
decl_stmt|;
name|table
specifier|const
modifier|*
name|tp
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|<
name|buff
operator|+
sizeof|sizeof
name|buff
operator|-
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|pc
operator|->
name|input
expr_stmt|;
block|}
do|while
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|)
do|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tp
operator|=
name|lookup_word
argument_list|(
name|pc
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
literal|'?'
return|;
name|lvalp
operator|->
name|intval
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
return|return
operator|*
name|pc
operator|->
name|input
operator|++
return|;
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|pc
operator|->
name|input
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|count
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* Do nothing if the parser reports an error.  */
end_comment

begin_function
specifier|static
name|int
name|yyerror
parameter_list|(
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a date/time string P.  Return the corresponding time_t value,    or (time_t) -1 if there is an error.  P can be an incomplete or    relative time specification; if so, use *NOW as the basis for the    returned time.  */
end_comment

begin_function
name|time_t
name|get_date
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|time_t
modifier|*
name|now
parameter_list|)
block|{
name|time_t
name|Start
init|=
name|now
condition|?
operator|*
name|now
else|:
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
init|=
name|localtime
argument_list|(
operator|&
name|Start
argument_list|)
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|struct
name|tm
name|tm0
decl_stmt|;
name|parser_control
name|pc
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
operator|-
literal|1
return|;
name|pc
operator|.
name|input
operator|=
name|p
expr_stmt|;
name|pc
operator|.
name|year
operator|.
name|value
operator|=
name|tmp
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
expr_stmt|;
name|pc
operator|.
name|year
operator|.
name|digits
operator|=
literal|4
expr_stmt|;
name|pc
operator|.
name|month
operator|=
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|pc
operator|.
name|day
operator|=
name|tmp
operator|->
name|tm_mday
expr_stmt|;
name|pc
operator|.
name|hour
operator|=
name|tmp
operator|->
name|tm_hour
expr_stmt|;
name|pc
operator|.
name|minutes
operator|=
name|tmp
operator|->
name|tm_min
expr_stmt|;
name|pc
operator|.
name|seconds
operator|=
name|tmp
operator|->
name|tm_sec
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
name|tmp
operator|->
name|tm_isdst
expr_stmt|;
name|pc
operator|.
name|meridian
operator|=
name|MER24
expr_stmt|;
name|pc
operator|.
name|rel_seconds
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rel_minutes
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rel_hour
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rel_day
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rel_month
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rel_year
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|dates_seen
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|days_seen
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|rels_seen
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|times_seen
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|local_zones_seen
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|zones_seen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HAVE_TM_ZONE
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|tmp
operator|->
name|tm_zone
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|tLOCAL_ZONE
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|tmp
operator|->
name|tm_isdst
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Probe the names used in the next three calendar quarters, looking      for a tm_isdst different from the one we already have.  */
block|{
name|int
name|quarter
decl_stmt|;
for|for
control|(
name|quarter
operator|=
literal|1
init|;
name|quarter
operator|<=
literal|3
condition|;
name|quarter
operator|++
control|)
block|{
name|time_t
name|probe
init|=
name|Start
operator|+
name|quarter
operator|*
operator|(
literal|90
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|probe_tm
init|=
name|localtime
argument_list|(
operator|&
name|probe
argument_list|)
decl_stmt|;
if|if
condition|(
name|probe_tm
operator|&&
name|probe_tm
operator|->
name|tm_zone
operator|&&
name|probe_tm
operator|->
name|tm_isdst
operator|!=
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|value
condition|)
block|{
block|{
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|probe_tm
operator|->
name|tm_zone
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|tLOCAL_ZONE
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|value
operator|=
name|probe_tm
operator|->
name|tm_isdst
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|2
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_TZNAME
block|{
ifndef|#
directive|ifndef
name|tzname
specifier|extern
name|char
modifier|*
name|tzname
index|[]
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|pc
operator|.
name|local_time_zone_table
index|[
name|i
index|]
operator|.
name|name
operator|=
name|tzname
index|[
name|i
index|]
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
name|i
index|]
operator|.
name|type
operator|=
name|tLOCAL_ZONE
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
name|i
index|]
operator|.
name|value
operator|=
name|i
expr_stmt|;
block|}
name|pc
operator|.
name|local_time_zone_table
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|name
operator|&&
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
comment|/* This locale uses the same abbrevation for standard and 	 daylight times.  So if we see that abbreviation, we don't 	 know whether it's daylight time.  */
name|pc
operator|.
name|local_time_zone_table
index|[
literal|0
index|]
operator|.
name|value
operator|=
operator|-
literal|1
expr_stmt|;
name|pc
operator|.
name|local_time_zone_table
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|yyparse
argument_list|(
operator|&
name|pc
argument_list|)
operator|!=
literal|0
operator|||
literal|1
operator|<
name|pc
operator|.
name|times_seen
operator|||
literal|1
operator|<
name|pc
operator|.
name|dates_seen
operator|||
literal|1
operator|<
name|pc
operator|.
name|days_seen
operator|||
literal|1
operator|<
operator|(
name|pc
operator|.
name|local_zones_seen
operator|+
name|pc
operator|.
name|zones_seen
operator|)
operator|||
operator|(
name|pc
operator|.
name|local_zones_seen
operator|&&
literal|1
operator|<
name|pc
operator|.
name|local_isdst
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_year
operator|=
name|to_year
argument_list|(
name|pc
operator|.
name|year
argument_list|)
operator|-
name|TM_YEAR_BASE
operator|+
name|pc
operator|.
name|rel_year
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|pc
operator|.
name|month
operator|-
literal|1
operator|+
name|pc
operator|.
name|rel_month
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|pc
operator|.
name|day
operator|+
name|pc
operator|.
name|rel_day
expr_stmt|;
if|if
condition|(
name|pc
operator|.
name|times_seen
operator|||
operator|(
name|pc
operator|.
name|rels_seen
operator|&&
operator|!
name|pc
operator|.
name|dates_seen
operator|&&
operator|!
name|pc
operator|.
name|days_seen
operator|)
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|=
name|to_hour
argument_list|(
name|pc
operator|.
name|hour
argument_list|,
name|pc
operator|.
name|meridian
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_hour
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_min
operator|=
name|pc
operator|.
name|minutes
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|pc
operator|.
name|seconds
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Let mktime deduce tm_isdst if we have an absolute time stamp,      or if the relative time stamp mentions days, months, or years.  */
if|if
condition|(
name|pc
operator|.
name|dates_seen
operator||
name|pc
operator|.
name|days_seen
operator||
name|pc
operator|.
name|times_seen
operator||
name|pc
operator|.
name|rel_day
operator||
name|pc
operator|.
name|rel_month
operator||
name|pc
operator|.
name|rel_year
condition|)
name|tm
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* But if the input explicitly specifies local time with or without      DST, give mktime that information.  */
if|if
condition|(
name|pc
operator|.
name|local_zones_seen
condition|)
name|tm
operator|.
name|tm_isdst
operator|=
name|pc
operator|.
name|local_isdst
expr_stmt|;
name|tm0
operator|=
name|tm
expr_stmt|;
name|Start
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|Start
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Guard against falsely reporting errors near the time_t boundaries          when parsing times in other time zones.  For example, if the min          time_t value is 1970-01-01 00:00:00 UTC and we are 8 hours ahead          of UTC, then the min localtime value is 1970-01-01 08:00:00; if          we apply mktime to 1970-01-01 00:00:00 we will get an error, so          we apply mktime to 1970-01-02 08:00:00 instead and adjust the time          zone by 24 hours to compensate.  This algorithm assumes that          there is no DST transition within a day of the time_t boundaries.  */
if|if
condition|(
name|pc
operator|.
name|zones_seen
condition|)
block|{
name|tm
operator|=
name|tm0
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|<=
name|EPOCH_YEAR
operator|-
name|TM_YEAR_BASE
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|++
expr_stmt|;
name|pc
operator|.
name|time_zone
operator|+=
literal|24
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|.
name|tm_mday
operator|--
expr_stmt|;
name|pc
operator|.
name|time_zone
operator|-=
literal|24
operator|*
literal|60
expr_stmt|;
block|}
name|Start
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Start
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
name|Start
return|;
block|}
if|if
condition|(
name|pc
operator|.
name|days_seen
operator|&&
operator|!
name|pc
operator|.
name|dates_seen
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|+=
operator|(
operator|(
name|pc
operator|.
name|day_number
operator|-
name|tm
operator|.
name|tm_wday
operator|+
literal|7
operator|)
operator|%
literal|7
operator|+
literal|7
operator|*
operator|(
name|pc
operator|.
name|day_ordinal
operator|-
operator|(
literal|0
operator|<
name|pc
operator|.
name|day_ordinal
operator|)
operator|)
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
name|Start
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|Start
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
name|Start
return|;
block|}
if|if
condition|(
name|pc
operator|.
name|zones_seen
condition|)
block|{
name|int
name|delta
init|=
name|pc
operator|.
name|time_zone
operator|*
literal|60
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TM_GMTOFF
name|delta
operator|-=
name|tm
operator|.
name|tm_gmtoff
expr_stmt|;
else|#
directive|else
name|struct
name|tm
modifier|*
name|gmt
init|=
name|gmtime
argument_list|(
operator|&
name|Start
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gmt
condition|)
return|return
operator|-
literal|1
return|;
name|delta
operator|-=
name|tm_diff
argument_list|(
operator|&
name|tm
argument_list|,
name|gmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|Start
operator|<
name|Start
operator|-
name|delta
operator|)
operator|!=
operator|(
name|delta
operator|<
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* time_t overflow */
name|Start
operator|-=
name|delta
expr_stmt|;
block|}
comment|/* Add relative hours, minutes, and seconds.  Ignore leap seconds;      i.e. "+ 10 minutes" means 600 seconds, even if one of them is a      leap second.  Typically this is not what the user wants, but it's      too hard to do it the other way, because the time zone indicator      must be applied before relative times, and if mktime is applied      again the time zone will be lost.  */
block|{
name|time_t
name|t0
init|=
name|Start
decl_stmt|;
name|long
name|d1
init|=
literal|60
operator|*
literal|60
operator|*
operator|(
name|long
operator|)
name|pc
operator|.
name|rel_hour
decl_stmt|;
name|time_t
name|t1
init|=
name|t0
operator|+
name|d1
decl_stmt|;
name|long
name|d2
init|=
literal|60
operator|*
operator|(
name|long
operator|)
name|pc
operator|.
name|rel_minutes
decl_stmt|;
name|time_t
name|t2
init|=
name|t1
operator|+
name|d2
decl_stmt|;
name|int
name|d3
init|=
name|pc
operator|.
name|rel_seconds
decl_stmt|;
name|time_t
name|t3
init|=
name|t2
operator|+
name|d3
decl_stmt|;
if|if
condition|(
operator|(
name|d1
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
operator|^
name|pc
operator|.
name|rel_hour
operator|)
operator||
operator|(
name|d2
operator|/
literal|60
operator|^
name|pc
operator|.
name|rel_minutes
operator|)
operator||
operator|(
operator|(
name|t0
operator|+
name|d1
operator|<
name|t0
operator|)
operator|^
operator|(
name|d1
operator|<
literal|0
operator|)
operator|)
operator||
operator|(
operator|(
name|t1
operator|+
name|d2
operator|<
name|t1
operator|)
operator|^
operator|(
name|d2
operator|<
literal|0
operator|)
operator|)
operator||
operator|(
operator|(
name|t2
operator|+
name|d3
operator|<
name|t2
operator|)
operator|^
operator|(
name|d3
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|Start
operator|=
name|t3
expr_stmt|;
block|}
return|return
name|Start
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TEST
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|time_t
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"Enter date, or blank line to exit.\n\t> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buff
index|[
name|BUFSIZ
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
operator|&&
name|buff
index|[
literal|0
index|]
condition|)
block|{
name|d
operator|=
name|get_date
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Bad format - couldn't convert.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined TEST */
end_comment

end_unit

