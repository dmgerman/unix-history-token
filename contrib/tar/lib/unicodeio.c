begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Unicode character output to streams with locale dependent encoding.     Copyright (C) 2000, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Bruno Haible<haible@clisp.cons.org>.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDDEF_H
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_ICONV
end_if

begin_include
include|#
directive|include
file|<iconv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some systems, like SunOS 4, don't have EILSEQ.  On these systems,    define EILSEQ to some value other than EINVAL, because our invokers    may want to distinguish EINVAL from EILSEQ.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EILSEQ
end_ifndef

begin_define
define|#
directive|define
name|EILSEQ
value|ENOENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ENOTSUP
end_ifndef

begin_define
define|#
directive|define
name|ENOTSUP
value|EINVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LANGINFO_CODESET
operator|&&
operator|!
name|USE_INCLUDED_LIBINTL
end_if

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unicodeio.h"
end_include

begin_comment
comment|/* When we pass a Unicode character to iconv(), we must pass it in a    suitable encoding. The standardized Unicode encodings are    UTF-8, UCS-2, UCS-4, UTF-16, UTF-16BE, UTF-16LE, UTF-7.    UCS-2 supports only characters up to \U0000FFFF.    UTF-16 and variants support only characters up to \U0010FFFF.    UTF-7 is way too complex and not supported by glibc-2.1.    UCS-4 specification leaves doubts about endianness and byte order    mark. glibc currently interprets it as big endian without byte order    mark, but this is not backed by an RFC.    So we use UTF-8. It supports characters up to \U7FFFFFFF and is    unambiguously defined.  */
end_comment

begin_comment
comment|/* Stores the UTF-8 representation of the Unicode character wc in r[0..5].    Returns the number of bytes stored, or -1 if wc is out of range.  */
end_comment

begin_function
specifier|static
name|int
name|utf8_wctomb
parameter_list|(
name|unsigned
name|char
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|wc
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x80
condition|)
name|count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<
literal|0x800
condition|)
name|count
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<
literal|0x10000
condition|)
name|count
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<
literal|0x200000
condition|)
name|count
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<
literal|0x4000000
condition|)
name|count
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7fffffff
condition|)
name|count
operator|=
literal|6
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|count
condition|)
block|{
comment|/* Note: code falls through cases! */
case|case
literal|6
case|:
name|r
index|[
literal|5
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|=
name|wc
operator|>>
literal|6
expr_stmt|;
name|wc
operator||=
literal|0x4000000
expr_stmt|;
case|case
literal|5
case|:
name|r
index|[
literal|4
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|=
name|wc
operator|>>
literal|6
expr_stmt|;
name|wc
operator||=
literal|0x200000
expr_stmt|;
case|case
literal|4
case|:
name|r
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|=
name|wc
operator|>>
literal|6
expr_stmt|;
name|wc
operator||=
literal|0x10000
expr_stmt|;
case|case
literal|3
case|:
name|r
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|=
name|wc
operator|>>
literal|6
expr_stmt|;
name|wc
operator||=
literal|0x800
expr_stmt|;
case|case
literal|2
case|:
name|r
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|=
name|wc
operator|>>
literal|6
expr_stmt|;
name|wc
operator||=
literal|0xc0
expr_stmt|;
case|case
literal|1
case|:
name|r
index|[
literal|0
index|]
operator|=
name|wc
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Luckily, the encoding's name is platform independent.  */
end_comment

begin_define
define|#
directive|define
name|UTF8_NAME
value|"UTF-8"
end_define

begin_comment
comment|/* Converts the Unicode character CODE to its multibyte representation    in the current locale and calls SUCCESS on the resulting byte    sequence.  If an error occurs, invoke FAILURE instead,    passing it CODE with errno set appropriately.    Assumes that the locale doesn't change between two calls.    Return whatever the SUCCESS or FAILURE returns.  */
end_comment

begin_decl_stmt
name|int
name|unicode_to_mb
argument_list|(
name|unsigned
name|int
name|code
argument_list|,
name|int
argument_list|(
argument|*success
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|buf
operator|,
name|size_t
name|buflen
operator|,
name|void
operator|*
name|callback_arg
operator|)
argument_list|)
argument_list|,
name|int
argument_list|(
argument|*failure
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|code
operator|,
name|void
operator|*
name|callback_arg
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|callback_arg
argument_list|)
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
specifier|static
name|int
name|is_utf8
decl_stmt|;
if|#
directive|if
name|HAVE_ICONV
specifier|static
name|iconv_t
name|utf8_to_local
decl_stmt|;
endif|#
directive|endif
name|char
name|inbuf
index|[
literal|6
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
specifier|const
name|char
modifier|*
name|charset
decl_stmt|;
if|#
directive|if
name|USE_INCLUDED_LIBINTL
specifier|extern
specifier|const
name|char
modifier|*
name|locale_charset
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
name|charset
operator|=
name|locale_charset
argument_list|()
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_LANGINFO_CODESET
name|charset
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
else|#
directive|else
name|charset
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|is_utf8
operator|=
operator|!
name|strcmp
argument_list|(
name|charset
argument_list|,
name|UTF8_NAME
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_ICONV
if|if
condition|(
operator|!
name|is_utf8
condition|)
block|{
name|utf8_to_local
operator|=
name|iconv_open
argument_list|(
name|charset
argument_list|,
name|UTF8_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_to_local
operator|==
call|(
name|iconv_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* For an unknown encoding, assume ASCII.  */
name|utf8_to_local
operator|=
name|iconv_open
argument_list|(
literal|"ASCII"
argument_list|,
name|UTF8_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_to_local
operator|==
call|(
name|iconv_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
name|failure
argument_list|(
name|code
argument_list|,
name|callback_arg
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Convert the character to UTF-8.  */
name|count
operator|=
name|utf8_wctomb
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|inbuf
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EILSEQ
expr_stmt|;
return|return
name|failure
argument_list|(
name|code
argument_list|,
name|callback_arg
argument_list|)
return|;
block|}
if|if
condition|(
name|is_utf8
condition|)
block|{
return|return
name|success
argument_list|(
name|inbuf
argument_list|,
name|count
argument_list|,
name|callback_arg
argument_list|)
return|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_ICONV
name|char
name|outbuf
index|[
literal|25
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|inptr
decl_stmt|;
name|size_t
name|inbytesleft
decl_stmt|;
name|char
modifier|*
name|outptr
decl_stmt|;
name|size_t
name|outbytesleft
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|inptr
operator|=
name|inbuf
expr_stmt|;
name|inbytesleft
operator|=
name|count
expr_stmt|;
name|outptr
operator|=
name|outbuf
expr_stmt|;
name|outbytesleft
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
comment|/* Convert the character from UTF-8 to the locale's charset.  */
name|res
operator|=
name|iconv
argument_list|(
name|utf8_to_local
argument_list|,
operator|(
name|ICONV_CONST
name|char
operator|*
operator|*
operator|)
operator|&
name|inptr
argument_list|,
operator|&
name|inbytesleft
argument_list|,
operator|&
name|outptr
argument_list|,
operator|&
name|outbytesleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbytesleft
operator|>
literal|0
operator|||
name|res
operator|==
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
comment|/* Irix iconv() inserts a NUL byte if it cannot convert. */
if|#
directive|if
operator|!
name|defined
name|_LIBICONV_VERSION
operator|&&
operator|(
name|defined
name|sgi
operator|||
name|defined
name|__sgi
operator|)
operator|||
operator|(
name|res
operator|>
literal|0
operator|&&
name|code
operator|!=
literal|0
operator|&&
name|outptr
operator|-
name|outbuf
operator|==
literal|1
operator|&&
operator|*
name|outbuf
operator|==
literal|'\0'
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|res
operator|!=
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|errno
operator|=
name|EILSEQ
expr_stmt|;
return|return
name|failure
argument_list|(
name|code
argument_list|,
name|callback_arg
argument_list|)
return|;
block|}
comment|/* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */
if|#
directive|if
name|defined
name|_LIBICONV_VERSION
expr|\
operator|||
operator|!
operator|(
operator|(
name|__GLIBC__
operator|-
literal|0
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|-
literal|0
operator|<=
literal|1
operator|)
operator|||
name|defined
name|__sun
operator|)
comment|/* Get back to the initial shift state.  */
name|res
operator|=
name|iconv
argument_list|(
name|utf8_to_local
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|outptr
argument_list|,
operator|&
name|outbytesleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return
name|failure
argument_list|(
name|code
argument_list|,
name|callback_arg
argument_list|)
return|;
endif|#
directive|endif
return|return
name|success
argument_list|(
name|outbuf
argument_list|,
name|outptr
operator|-
name|outbuf
argument_list|,
name|callback_arg
argument_list|)
return|;
else|#
directive|else
name|errno
operator|=
name|ENOTSUP
expr_stmt|;
return|return
name|failure
argument_list|(
name|code
argument_list|,
name|callback_arg
argument_list|)
return|;
endif|#
directive|endif
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Simple success callback that outputs the converted string.    The STREAM is passed as callback_arg.  */
end_comment

begin_function
name|int
name|print_unicode_success
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|callback_arg
decl_stmt|;
return|return
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|buflen
argument_list|,
name|stream
argument_list|)
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simple failure callback that prints an ASCII representation, using    the same notation as C99 strings.  */
end_comment

begin_function
name|int
name|print_unicode_failure
parameter_list|(
name|unsigned
name|int
name|code
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|callback_arg
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|code
operator|<
literal|0x10000
condition|?
literal|"\\u%04X"
else|:
literal|"\\U%08X"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Outputs the Unicode character CODE to the output stream STREAM.    Returns zero if successful, -1 (setting errno) otherwise.    Assumes that the locale doesn't change between two calls.  */
end_comment

begin_function
name|int
name|print_unicode_char
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|int
name|code
parameter_list|)
block|{
return|return
name|unicode_to_mb
argument_list|(
name|code
argument_list|,
name|print_unicode_success
argument_list|,
name|print_unicode_failure
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_function

end_unit

