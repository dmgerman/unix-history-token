begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert a `struct tm' to a time_t value.    Copyright (C) 1993, 94, 95, 96, 97, 98, 99 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Paul Eggert (eggert@twinsun.com).     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Define this to have a standalone program to test this implementation of    mktime.  */
end_comment

begin_comment
comment|/* #define DEBUG 1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|HAVE_LIMITS_H
value|1
end_define

begin_define
define|#
directive|define
name|STDC_HEADERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Assume that leap seconds are possible, unless told otherwise.    If the host has a `zic' command with a `-L leapsecondfilename' option,    then it supports leap seconds; otherwise it probably doesn't.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LEAP_SECONDS_POSSIBLE
end_ifndef

begin_define
define|#
directive|define
name|LEAP_SECONDS_POSSIBLE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Some systems define `time_t' here.  */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make it work even if the system's libc has its own mktime routine.  */
end_comment

begin_define
define|#
directive|define
name|mktime
value|my_mktime
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__P
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__GNUC__
operator|||
operator|(
name|defined
name|__STDC__
operator|&&
name|__STDC__
operator|)
end_if

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|args
parameter_list|)
value|args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|args
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not __P.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The extra casts work around common compiler bugs.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_SIGNED
parameter_list|(
name|t
parameter_list|)
value|(! ((t) 0< (t) -1))
end_define

begin_comment
comment|/* The outer cast is needed to work around a bug in Cray C 5.0.3.0.    It is necessary at least when t == time_t.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_MINIMUM
parameter_list|(
name|t
parameter_list|)
value|((t) (TYPE_SIGNED (t) \ 			      ? ~ (t) 0<< (sizeof (t) * CHAR_BIT - 1) : (t) 0))
end_define

begin_define
define|#
directive|define
name|TYPE_MAXIMUM
parameter_list|(
name|t
parameter_list|)
value|((t) (~ (t) 0 - TYPE_MINIMUM (t)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MIN
end_ifndef

begin_define
define|#
directive|define
name|INT_MIN
value|TYPE_MINIMUM (int)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MAX
end_ifndef

begin_define
define|#
directive|define
name|INT_MAX
value|TYPE_MAXIMUM (int)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TIME_T_MIN
end_ifndef

begin_define
define|#
directive|define
name|TIME_T_MIN
value|TYPE_MINIMUM (time_t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TIME_T_MAX
end_ifndef

begin_define
define|#
directive|define
name|TIME_T_MAX
value|TYPE_MAXIMUM (time_t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_define
define|#
directive|define
name|EPOCH_YEAR
value|1970
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__isleap
end_ifndef

begin_comment
comment|/* Nonzero if YEAR is a leap year (every 4 years,    except every 100th isn't, and every 400th is).  */
end_comment

begin_define
define|#
directive|define
name|__isleap
parameter_list|(
name|year
parameter_list|)
define|\
value|((year) % 4 == 0&& ((year) % 100 != 0 || (year) % 400 == 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How many days come before each month (0-12).  */
end_comment

begin_decl_stmt
specifier|const
name|unsigned
name|short
name|int
name|__mon_yday
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/* Normal years.  */
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
comment|/* Leap years.  */
block|{
literal|0
block|,
literal|31
block|,
literal|60
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|my_mktime_localtime_r
value|__localtime_r
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If we're a mktime substitute in a GNU program, then prefer    localtime to localtime_r, since many localtime_r implementations    are buggy.  */
end_comment

begin_function
specifier|static
name|struct
name|tm
modifier|*
name|my_mktime_localtime_r
parameter_list|(
specifier|const
name|time_t
modifier|*
name|t
parameter_list|,
name|struct
name|tm
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|l
init|=
name|localtime
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
operator|*
name|tp
operator|=
operator|*
name|l
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! _LIBC */
end_comment

begin_comment
comment|/* Yield the difference between (YEAR-YDAY HOUR:MIN:SEC) and (*TP),    measured in seconds, ignoring leap seconds.    YEAR uses the same numbering as TM->tm_year.    All values are in range, except possibly YEAR.    If TP is null, return a nonzero value.    If overflow occurs, yield the low order bits of the correct answer.  */
end_comment

begin_function
specifier|static
name|time_t
name|ydhms_tm_diff
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|yday
parameter_list|,
name|int
name|hour
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|sec
parameter_list|,
specifier|const
name|struct
name|tm
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tp
condition|)
return|return
literal|1
return|;
else|else
block|{
comment|/* Compute intervening leap days correctly even if year is negative. 	 Take care to avoid int overflow.  time_t overflow is OK, since 	 only the low order bits of the correct time_t answer are needed. 	 Don't convert to time_t until after all divisions are done, since 	 time_t might be unsigned.  */
name|int
name|a4
init|=
operator|(
name|year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|b4
init|=
operator|(
name|tp
operator|->
name|tm_year
operator|>>
literal|2
operator|)
operator|+
operator|(
name|TM_YEAR_BASE
operator|>>
literal|2
operator|)
operator|-
operator|!
operator|(
name|tp
operator|->
name|tm_year
operator|&
literal|3
operator|)
decl_stmt|;
name|int
name|a100
init|=
name|a4
operator|/
literal|25
operator|-
operator|(
name|a4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|b100
init|=
name|b4
operator|/
literal|25
operator|-
operator|(
name|b4
operator|%
literal|25
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|a400
init|=
name|a100
operator|>>
literal|2
decl_stmt|;
name|int
name|b400
init|=
name|b100
operator|>>
literal|2
decl_stmt|;
name|int
name|intervening_leap_days
init|=
operator|(
name|a4
operator|-
name|b4
operator|)
operator|-
operator|(
name|a100
operator|-
name|b100
operator|)
operator|+
operator|(
name|a400
operator|-
name|b400
operator|)
decl_stmt|;
name|time_t
name|years
init|=
name|year
operator|-
operator|(
name|time_t
operator|)
name|tp
operator|->
name|tm_year
decl_stmt|;
name|time_t
name|days
init|=
operator|(
literal|365
operator|*
name|years
operator|+
name|intervening_leap_days
operator|+
operator|(
name|yday
operator|-
name|tp
operator|->
name|tm_yday
operator|)
operator|)
decl_stmt|;
return|return
operator|(
literal|60
operator|*
operator|(
literal|60
operator|*
operator|(
literal|24
operator|*
name|days
operator|+
operator|(
name|hour
operator|-
name|tp
operator|->
name|tm_hour
operator|)
operator|)
operator|+
operator|(
name|min
operator|-
name|tp
operator|->
name|tm_min
operator|)
operator|)
operator|+
operator|(
name|sec
operator|-
name|tp
operator|->
name|tm_sec
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Use CONVERT to convert *T to a broken down time in *TP.    If *T is out of range for conversion, adjust it so that    it is the nearest in-range value and then convert that.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tm
modifier|*
name|ranged_convert
argument_list|(
expr|struct
name|tm
operator|*
call|(
modifier|*
name|convert
call|)
argument_list|(
specifier|const
name|time_t
operator|*
argument_list|,
expr|struct
name|tm
operator|*
argument_list|)
argument_list|,
name|time_t
operator|*
name|t
argument_list|,
expr|struct
name|tm
operator|*
name|tp
argument_list|)
block|{
name|struct
name|tm
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
call|(
modifier|*
name|convert
call|)
argument_list|(
name|t
argument_list|,
name|tp
argument_list|)
operator|)
operator|&&
operator|*
name|t
condition|)
block|{
name|time_t
name|bad
init|=
operator|*
name|t
decl_stmt|;
name|time_t
name|ok
init|=
literal|0
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* BAD is a known unconvertible time_t, and OK is a known good one. 	 Use binary search to narrow the range between BAD and OK until 	 they differ by 1.  */
while|while
condition|(
name|bad
operator|!=
name|ok
operator|+
operator|(
name|bad
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
condition|)
block|{
name|time_t
name|mid
init|=
operator|*
name|t
operator|=
operator|(
name|bad
operator|<
literal|0
condition|?
name|bad
operator|+
operator|(
operator|(
name|ok
operator|-
name|bad
operator|)
operator|>>
literal|1
operator|)
else|:
name|ok
operator|+
operator|(
operator|(
name|bad
operator|-
name|ok
operator|)
operator|>>
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
call|(
modifier|*
name|convert
call|)
argument_list|(
name|t
argument_list|,
name|tp
argument_list|)
operator|)
condition|)
block|{
name|tm
operator|=
operator|*
name|r
expr_stmt|;
name|ok
operator|=
name|mid
expr_stmt|;
block|}
else|else
name|bad
operator|=
name|mid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
operator|&&
name|ok
condition|)
block|{
comment|/* The last conversion attempt failed; 	     revert to the most recent successful attempt.  */
operator|*
name|t
operator|=
name|ok
expr_stmt|;
operator|*
name|tp
operator|=
name|tm
expr_stmt|;
name|r
operator|=
name|tp
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert *TP to a time_t value, inverting    the monotonic and mostly-unit-linear conversion function CONVERT.    Use *OFFSET to keep track of a guess at the offset of the result,    compared to what the result would be for UTC without leap seconds.    If *OFFSET's guess is correct, only one CONVERT call is needed.  */
end_comment

begin_decl_stmt
name|time_t
name|__mktime_internal
argument_list|(
expr|struct
name|tm
operator|*
name|tp
argument_list|,
expr|struct
name|tm
operator|*
call|(
modifier|*
name|convert
call|)
argument_list|(
specifier|const
name|time_t
operator|*
argument_list|,
expr|struct
name|tm
operator|*
argument_list|)
argument_list|,
name|time_t
operator|*
name|offset
argument_list|)
block|{
name|time_t
name|t
decl_stmt|,
name|dt
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* The maximum number of probes (calls to CONVERT) should be enough      to handle any combinations of time zone rule changes, solar time,      leap seconds, and oscillations around a spring-forward gap.      POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */
name|int
name|remaining_probes
init|=
literal|6
decl_stmt|;
comment|/* Time requested.  Copy it in case CONVERT modifies *TP; this can      occur if TP is localtime's returned value and CONVERT is localtime.  */
name|int
name|sec
init|=
name|tp
operator|->
name|tm_sec
decl_stmt|;
name|int
name|min
init|=
name|tp
operator|->
name|tm_min
decl_stmt|;
name|int
name|hour
init|=
name|tp
operator|->
name|tm_hour
decl_stmt|;
name|int
name|mday
init|=
name|tp
operator|->
name|tm_mday
decl_stmt|;
name|int
name|mon
init|=
name|tp
operator|->
name|tm_mon
decl_stmt|;
name|int
name|year_requested
init|=
name|tp
operator|->
name|tm_year
decl_stmt|;
name|int
name|isdst
init|=
name|tp
operator|->
name|tm_isdst
decl_stmt|;
comment|/* Ensure that mon is in range, and set year accordingly.  */
name|int
name|mon_remainder
init|=
name|mon
operator|%
literal|12
decl_stmt|;
name|int
name|negative_mon_remainder
init|=
name|mon_remainder
operator|<
literal|0
decl_stmt|;
name|int
name|mon_years
init|=
name|mon
operator|/
literal|12
operator|-
name|negative_mon_remainder
decl_stmt|;
name|int
name|year
init|=
name|year_requested
operator|+
name|mon_years
decl_stmt|;
comment|/* The other values need not be in range:      the remaining code handles minor overflows correctly,      assuming int and time_t arithmetic wraps around.      Major overflows are caught at the end.  */
comment|/* Calculate day of year from year, month, and day of month.      The result need not be in range.  */
name|int
name|yday
init|=
operator|(
operator|(
name|__mon_yday
index|[
name|__isleap
argument_list|(
name|year
operator|+
name|TM_YEAR_BASE
argument_list|)
index|]
index|[
name|mon_remainder
operator|+
literal|12
operator|*
name|negative_mon_remainder
index|]
operator|)
operator|+
name|mday
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|sec_requested
init|=
name|sec
decl_stmt|;
if|#
directive|if
name|LEAP_SECONDS_POSSIBLE
comment|/* Handle out-of-range seconds specially,      since ydhms_tm_diff assumes every minute has 60 seconds.  */
if|if
condition|(
name|sec
operator|<
literal|0
condition|)
name|sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|59
operator|<
name|sec
condition|)
name|sec
operator|=
literal|59
expr_stmt|;
endif|#
directive|endif
comment|/* Invert CONVERT by probing.  First assume the same offset as last time.      Then repeatedly use the error to improve the guess.  */
name|tm
operator|.
name|tm_year
operator|=
name|EPOCH_YEAR
operator|-
name|TM_YEAR_BASE
expr_stmt|;
name|tm
operator|.
name|tm_yday
operator|=
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
name|t0
operator|=
name|ydhms_tm_diff
argument_list|(
name|year
argument_list|,
name|yday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|t1
operator|=
name|t2
operator|=
name|t0
operator|+
operator|*
name|offset
init|;
operator|(
name|dt
operator|=
name|ydhms_tm_diff
argument_list|(
name|year
argument_list|,
name|yday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|,
name|ranged_convert
argument_list|(
name|convert
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|tm
argument_list|)
argument_list|)
operator|)
condition|;
name|t1
operator|=
name|t2
operator|,
name|t2
operator|=
name|t
operator|,
name|t
operator|+=
name|dt
control|)
if|if
condition|(
name|t
operator|==
name|t1
operator|&&
name|t
operator|!=
name|t2
operator|&&
operator|(
name|isdst
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_isdst
operator|<
literal|0
operator|||
operator|(
name|isdst
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|tm
operator|.
name|tm_isdst
operator|!=
literal|0
operator|)
operator|)
condition|)
comment|/* We can't possibly find a match, as we are oscillating 	 between two values.  The requested time probably falls 	 within a spring-forward gap of size DT.  Follow the common 	 practice in this case, which is to return a time that is DT 	 away from the requested time, preferring a time whose 	 tm_isdst differs from the requested value.  In practice, 	 this is more useful than returning -1.  */
break|break;
elseif|else
if|if
condition|(
operator|--
name|remaining_probes
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we have a match, check whether tm.tm_isdst has the requested      value, if any.  */
if|if
condition|(
name|dt
operator|==
literal|0
operator|&&
name|isdst
operator|!=
name|tm
operator|.
name|tm_isdst
operator|&&
literal|0
operator|<=
name|isdst
operator|&&
literal|0
operator|<=
name|tm
operator|.
name|tm_isdst
condition|)
block|{
comment|/* tm.tm_isdst has the wrong value.  Look for a neighboring 	 time with the right value, and use its UTC offset. 	 Heuristic: probe the previous three calendar quarters (approximately), 	 looking for the desired isdst.  This isn't perfect, 	 but it's good enough in practice.  */
name|int
name|quarter
init|=
literal|7889238
decl_stmt|;
comment|/* seconds per average 1/4 Gregorian year */
name|int
name|i
decl_stmt|;
comment|/* If we're too close to the time_t limit, look in future quarters.  */
if|if
condition|(
name|t
operator|<
name|TIME_T_MIN
operator|+
literal|3
operator|*
name|quarter
condition|)
name|quarter
operator|=
operator|-
name|quarter
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|time_t
name|ot
init|=
name|t
operator|-
name|i
operator|*
name|quarter
decl_stmt|;
name|struct
name|tm
name|otm
decl_stmt|;
name|ranged_convert
argument_list|(
name|convert
argument_list|,
operator|&
name|ot
argument_list|,
operator|&
name|otm
argument_list|)
expr_stmt|;
if|if
condition|(
name|otm
operator|.
name|tm_isdst
operator|==
name|isdst
condition|)
block|{
comment|/* We found the desired tm_isdst. 		 Extrapolate back to the desired time.  */
name|t
operator|=
name|ot
operator|+
name|ydhms_tm_diff
argument_list|(
name|year
argument_list|,
name|yday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|,
operator|&
name|otm
argument_list|)
expr_stmt|;
name|ranged_convert
argument_list|(
name|convert
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|offset
operator|=
name|t
operator|-
name|t0
expr_stmt|;
if|#
directive|if
name|LEAP_SECONDS_POSSIBLE
if|if
condition|(
name|sec_requested
operator|!=
name|tm
operator|.
name|tm_sec
condition|)
block|{
comment|/* Adjust time to reflect the tm_sec requested, not the normalized value. 	 Also, repair any damage from a false match due to a leap second.  */
name|t
operator|+=
name|sec_requested
operator|-
name|sec
operator|+
operator|(
name|sec
operator|==
literal|0
operator|&&
name|tm
operator|.
name|tm_sec
operator|==
literal|60
operator|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|convert
call|)
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tm
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TIME_T_MAX
operator|/
name|INT_MAX
operator|/
literal|366
operator|/
literal|24
operator|/
literal|60
operator|/
literal|60
operator|<
literal|3
condition|)
block|{
comment|/* time_t isn't large enough to rule out overflows in ydhms_tm_diff, 	 so check for major overflows.  A gross check suffices, 	 since if t has overflowed, it is off by a multiple of 	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of 	 the difference that is bounded by a small value.  */
name|double
name|dyear
init|=
operator|(
name|double
operator|)
name|year_requested
operator|+
name|mon_years
operator|-
name|tm
operator|.
name|tm_year
decl_stmt|;
name|double
name|dday
init|=
literal|366
operator|*
name|dyear
operator|+
name|mday
decl_stmt|;
name|double
name|dsec
init|=
literal|60
operator|*
operator|(
literal|60
operator|*
operator|(
literal|24
operator|*
name|dday
operator|+
name|hour
operator|)
operator|+
name|min
operator|)
operator|+
name|sec_requested
decl_stmt|;
comment|/* On Irix4.0.5 cc, dividing TIME_T_MIN by 3 does not produce 	 correct results, ie., it erroneously gives a positive value 	 of 715827882.  Setting a variable first then doing math on it 	 seems to work.  (ghazi@caip.rutgers.edu) */
specifier|const
name|time_t
name|time_t_max
init|=
name|TIME_T_MAX
decl_stmt|;
specifier|const
name|time_t
name|time_t_min
init|=
name|TIME_T_MIN
decl_stmt|;
if|if
condition|(
name|time_t_max
operator|/
literal|3
operator|-
name|time_t_min
operator|/
literal|3
operator|<
operator|(
name|dsec
operator|<
literal|0
condition|?
operator|-
name|dsec
else|:
name|dsec
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|tp
operator|=
name|tm
expr_stmt|;
return|return
name|t
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|localtime_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert *TP to a time_t value.  */
end_comment

begin_function
name|time_t
name|mktime
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_LIBC
comment|/* POSIX.1 8.1.1 requires that whenever mktime() is called, the      time zone names contained in the external variable `tzname' shall      be set as if the tzset() function had been called.  */
name|__tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|__mktime_internal
argument_list|(
name|tp
argument_list|,
name|my_mktime_localtime_r
argument_list|,
operator|&
name|localtime_offset
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|mktime
argument_list|,
argument|timelocal
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|int
name|not_equal_tm
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|tm
modifier|*
name|a
decl_stmt|;
name|struct
name|tm
modifier|*
name|b
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|a
operator|->
name|tm_sec
operator|^
name|b
operator|->
name|tm_sec
operator|)
operator||
operator|(
name|a
operator|->
name|tm_min
operator|^
name|b
operator|->
name|tm_min
operator|)
operator||
operator|(
name|a
operator|->
name|tm_hour
operator|^
name|b
operator|->
name|tm_hour
operator|)
operator||
operator|(
name|a
operator|->
name|tm_mday
operator|^
name|b
operator|->
name|tm_mday
operator|)
operator||
operator|(
name|a
operator|->
name|tm_mon
operator|^
name|b
operator|->
name|tm_mon
operator|)
operator||
operator|(
name|a
operator|->
name|tm_year
operator|^
name|b
operator|->
name|tm_year
operator|)
operator||
operator|(
name|a
operator|->
name|tm_mday
operator|^
name|b
operator|->
name|tm_mday
operator|)
operator||
operator|(
name|a
operator|->
name|tm_yday
operator|^
name|b
operator|->
name|tm_yday
operator|)
operator||
operator|(
name|a
operator|->
name|tm_isdst
operator|^
name|b
operator|->
name|tm_isdst
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_tm
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|tp
condition|)
name|printf
argument_list|(
literal|"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d"
argument_list|,
name|tp
operator|->
name|tm_year
operator|+
name|TM_YEAR_BASE
argument_list|,
name|tp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|,
name|tp
operator|->
name|tm_sec
argument_list|,
name|tp
operator|->
name|tm_yday
argument_list|,
name|tp
operator|->
name|tm_wday
argument_list|,
name|tp
operator|->
name|tm_isdst
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_result
parameter_list|(
name|tk
parameter_list|,
name|tmk
parameter_list|,
name|tl
parameter_list|,
name|lt
parameter_list|)
name|time_t
name|tk
decl_stmt|;
name|struct
name|tm
name|tmk
decl_stmt|;
name|time_t
name|tl
decl_stmt|;
name|struct
name|tm
modifier|*
name|lt
decl_stmt|;
block|{
if|if
condition|(
name|tk
operator|!=
name|tl
operator|||
operator|!
name|lt
operator|||
name|not_equal_tm
argument_list|(
operator|&
name|tmk
argument_list|,
name|lt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"mktime ("
argument_list|)
expr_stmt|;
name|print_tm
argument_list|(
operator|&
name|tmk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\nyields ("
argument_list|)
expr_stmt|;
name|print_tm
argument_list|(
name|lt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") == %ld, should be %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|tl
argument_list|,
operator|(
name|long
operator|)
name|tk
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
name|tmk
decl_stmt|,
name|tml
decl_stmt|;
name|struct
name|tm
modifier|*
name|lt
decl_stmt|;
name|time_t
name|tk
decl_stmt|,
name|tl
decl_stmt|;
name|char
name|trailer
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|3
operator|||
name|argc
operator|==
literal|4
operator|)
operator|&&
operator|(
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"%d-%d-%d%c"
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_mon
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
operator|&
name|trailer
argument_list|)
operator|==
literal|3
operator|)
operator|&&
operator|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d:%d:%d%c"
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|,
operator|&
name|trailer
argument_list|)
operator|==
literal|3
operator|)
condition|)
block|{
name|tm
operator|.
name|tm_year
operator|-=
name|TM_YEAR_BASE
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
name|argc
operator|==
literal|3
condition|?
operator|-
literal|1
else|:
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|tmk
operator|=
name|tm
expr_stmt|;
name|tl
operator|=
name|mktime
argument_list|(
operator|&
name|tmk
argument_list|)
expr_stmt|;
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
condition|)
block|{
name|tml
operator|=
operator|*
name|lt
expr_stmt|;
name|lt
operator|=
operator|&
name|tml
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"mktime returns %ld == "
argument_list|,
operator|(
name|long
operator|)
name|tl
argument_list|)
expr_stmt|;
name|print_tm
argument_list|(
operator|&
name|tmk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|check_result
argument_list|(
name|tl
argument_list|,
name|tmk
argument_list|,
name|tl
argument_list|,
name|lt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|4
operator|||
operator|(
name|argc
operator|==
literal|5
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|time_t
name|from
init|=
name|atol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|time_t
name|by
init|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|time_t
name|to
init|=
name|atol
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
for|for
control|(
name|tl
operator|=
name|from
init|;
name|tl
operator|<=
name|to
condition|;
name|tl
operator|+=
name|by
control|)
block|{
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
condition|)
block|{
name|tmk
operator|=
name|tml
operator|=
operator|*
name|lt
expr_stmt|;
name|tk
operator|=
name|mktime
argument_list|(
operator|&
name|tmk
argument_list|)
expr_stmt|;
name|status
operator||=
name|check_result
argument_list|(
name|tk
argument_list|,
name|tmk
argument_list|,
name|tl
argument_list|,
name|tml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"localtime (%ld) yields 0\n"
argument_list|,
operator|(
name|long
operator|)
name|tl
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|tl
operator|=
name|from
init|;
name|tl
operator|<=
name|to
condition|;
name|tl
operator|+=
name|by
control|)
block|{
comment|/* Null benchmark.  */
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
condition|)
block|{
name|tmk
operator|=
name|tml
operator|=
operator|*
name|lt
expr_stmt|;
name|tk
operator|=
name|tl
expr_stmt|;
name|status
operator||=
name|check_result
argument_list|(
name|tk
argument_list|,
name|tmk
argument_list|,
name|tl
argument_list|,
name|tml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"localtime (%ld) yields 0\n"
argument_list|,
operator|(
name|long
operator|)
name|tl
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|printf
argument_list|(
literal|"Usage:\ \t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\n\ \t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\n\ \t%s FROM BY TO - # Do not test those values (for benchmark).\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Local Variables: compile-command: "gcc -DDEBUG -DHAVE_LIMITS_H -DSTDC_HEADERS -Wall -W -O -g mktime.c -o mktime" End: */
end_comment

end_unit

