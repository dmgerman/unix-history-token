begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: res_findzonecut.c,v 1.14.2.4 2004/06/10 17:59:43 dhankins Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1999-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  */
end_comment

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc-dhcp/list.h>
end_include

begin_include
include|#
directive|include
file|"minires/minires.h"
end_include

begin_include
include|#
directive|include
file|"arpa/nameser.h"
end_include

begin_comment
comment|/* Data structures. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rr_a
block|{
name|ISC_LINK
argument_list|(
argument|struct rr_a
argument_list|)
name|link
expr_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
block|}
name|rr_a
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rr_a
argument_list|)
name|rrset_a
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rr_ns
block|{
name|ISC_LINK
argument_list|(
argument|struct rr_ns
argument_list|)
name|link
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|rrset_a
name|addrs
decl_stmt|;
block|}
name|rr_ns
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rr_ns
argument_list|)
name|rrset_ns
expr_stmt|;
end_typedef

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|int
name|satisfy
parameter_list|(
name|res_state
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|rrset_ns
modifier|*
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_addrs
parameter_list|(
name|res_state
parameter_list|,
name|rr_ns
modifier|*
parameter_list|,
name|struct
name|in_addr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ns_rcode
name|get_soa
parameter_list|(
name|res_state
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|ns_class
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|rrset_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|get_ns
parameter_list|(
name|res_state
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|ns_class
parameter_list|,
name|rrset_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|get_glue
parameter_list|(
name|res_state
parameter_list|,
name|ns_class
parameter_list|,
name|rrset_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|save_ns
parameter_list|(
name|res_state
parameter_list|,
name|ns_msg
modifier|*
parameter_list|,
name|ns_sect
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|ns_class
parameter_list|,
name|rrset_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|save_a
parameter_list|(
name|res_state
parameter_list|,
name|ns_msg
modifier|*
parameter_list|,
name|ns_sect
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|ns_class
parameter_list|,
name|rrset_a
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_nsrrset
parameter_list|(
name|rrset_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_nsrr
parameter_list|(
name|rrset_ns
modifier|*
parameter_list|,
name|rr_ns
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rr_ns
modifier|*
name|find_ns
parameter_list|(
name|rrset_ns
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|do_query
parameter_list|(
name|res_state
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|ns_class
parameter_list|,
name|ns_type
parameter_list|,
name|double
modifier|*
parameter_list|,
name|ns_msg
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Public. */
end_comment

begin_comment
comment|/*  * int  * res_findzonecut(res, dname, class, zname, zsize, addrs, naddrs)  *	find enclosing zone for a<dname,class>, and some server addresses  * parameters:  *	res - resolver context to work within (is modified)  *	dname - domain name whose enclosing zone is desired  *	class - class of dname (and its enclosing zone)  *	zname - found zone name  *	zsize - allocated size of zname  *	addrs - found server addresses  *	naddrs - max number of addrs  * return values:  *< 0 - an error occurred (check errno)  *	= 0 - zname is now valid, but addrs[] wasn't changed  *> 0 - zname is now valid, and return value is number of addrs[] found  * notes:  *	this function calls res_nsend() which means it depends on correctly  *	functioning recursive nameservers (usually defined in /etc/resolv.conf  *	or its local equivilent).  *  *	we start by asking for an SOA<dname,class>.  if we get one as an  *	answer, that just means<dname,class> is a zone top, which is fine.  *	more than likely we'll be told to go pound sand, in the form of a  *	negative answer.  *  *	note that we are not prepared to deal with referrals since that would  *	only come from authority servers and our correctly functioning local  *	recursive server would have followed the referral and got us something  *	more definite.  *  *	if the authority section contains an SOA, this SOA should also be the  *	closest enclosing zone, since any intermediary zone cuts would've been  *	returned as referrals and dealt with by our correctly functioning local  *	recursive name server.  but an SOA in the authority section should NOT  *	match our dname (since that would have been returned in the answer  *	section).  an authority section SOA has to be "above" our dname.  *  *	we cannot fail to find an SOA in this way.  ultimately we'll return  *	a zname indicating the root zone if that's the closest enclosing zone.  *	however, since authority section SOA's were once optional, it's  *	possible that we'll have to go hunting for the enclosing SOA by  *	ripping labels off the front of our dname -- this is known as "doing  *	it the hard way."  *  *	ultimately we want some server addresses, which are ideally the ones  *	pertaining to the SOA.MNAME, but only if there is a matching NS RR.  *	so the second phase (after we find an SOA) is to go looking for the  *	NS RRset for that SOA's zone.  *  *	no answer section processed by this code is allowed to contain CNAME  *	or DNAME RR's.  for the SOA query this means we strip a label and  *	keep going.  for the NS and A queries this means we just give up.  */
end_comment

begin_function
name|isc_result_t
name|res_findzonecut
parameter_list|(
name|res_state
name|statp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|,
name|size_t
name|zsize
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addrs
parameter_list|,
name|int
name|naddrs
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|void
modifier|*
name|zcookie
parameter_list|)
block|{
name|char
name|mname
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|u_long
name|save_pfcode
decl_stmt|;
name|rrset_ns
name|nsrrs
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"START dname='%s' class=%s, zsize=%ld, naddrs=%d"
operator|,
name|dname
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|,
operator|(
name|long
operator|)
name|zsize
operator|,
name|naddrs
operator|)
argument_list|)
expr_stmt|;
name|save_pfcode
operator|=
name|statp
operator|->
name|pfcode
expr_stmt|;
name|statp
operator|->
name|pfcode
operator||=
name|RES_PRF_HEAD2
operator||
name|RES_PRF_HEAD1
operator||
name|RES_PRF_HEADX
operator||
name|RES_PRF_QUES
operator||
name|RES_PRF_ANS
operator||
name|RES_PRF_AUTH
operator||
name|RES_PRF_ADD
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|nsrrs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"look for a predefined zone statement"
operator|)
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|find_cached_zone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|zname
argument_list|,
name|zsize
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|,
operator|&
name|n
argument_list|,
name|zcookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|DPRINTF
argument_list|(
operator|(
literal|"get the soa, and see if it has enough glue"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcode
operator|=
name|get_soa
argument_list|(
name|statp
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|zname
argument_list|,
name|zsize
argument_list|,
name|mname
argument_list|,
sizeof|sizeof
name|mname
argument_list|,
operator|&
name|nsrrs
argument_list|)
operator|)
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|(
operator|(
name|opts
operator|&
name|RES_EXHAUSTIVE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|n
operator|=
name|satisfy
argument_list|(
name|statp
argument_list|,
name|mname
argument_list|,
operator|&
name|nsrrs
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
name|DPRINTF
argument_list|(
operator|(
literal|"get the ns rrset and see if it has enough glue"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcode
operator|=
name|get_ns
argument_list|(
name|statp
argument_list|,
name|zname
argument_list|,
name|class
argument_list|,
operator|&
name|nsrrs
argument_list|)
operator|)
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|(
operator|(
name|opts
operator|&
name|RES_EXHAUSTIVE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|n
operator|=
name|satisfy
argument_list|(
name|statp
argument_list|,
name|mname
argument_list|,
operator|&
name|nsrrs
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
name|DPRINTF
argument_list|(
operator|(
literal|"get the missing glue and see if it's finally enough"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcode
operator|=
name|get_glue
argument_list|(
name|statp
argument_list|,
name|class
argument_list|,
operator|&
name|nsrrs
argument_list|)
operator|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|n
operator|=
name|satisfy
argument_list|(
name|statp
argument_list|,
name|mname
argument_list|,
operator|&
name|nsrrs
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|)
expr_stmt|;
comment|/* If we found the zone, cache it. */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|cache_found_zone
argument_list|(
name|class
argument_list|,
name|zname
argument_list|,
name|addrs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|done
label|:
name|DPRINTF
argument_list|(
operator|(
literal|"FINISH n=%d (%s)"
operator|,
name|n
operator|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"OK"
operator|)
argument_list|)
expr_stmt|;
name|free_nsrrset
argument_list|(
operator|&
name|nsrrs
argument_list|)
expr_stmt|;
name|statp
operator|->
name|pfcode
operator|=
name|save_pfcode
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|n
expr_stmt|;
return|return
name|rcode
return|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|int
name|satisfy
parameter_list|(
name|res_state
name|statp
parameter_list|,
specifier|const
name|char
modifier|*
name|mname
parameter_list|,
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addrs
parameter_list|,
name|int
name|naddrs
parameter_list|)
block|{
name|rr_ns
modifier|*
name|nsrr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|x
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|nsrr
operator|=
name|find_ns
argument_list|(
name|nsrrsp
argument_list|,
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrr
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|add_addrs
argument_list|(
name|statp
argument_list|,
name|nsrr
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|)
expr_stmt|;
name|addrs
operator|+=
name|x
expr_stmt|;
name|naddrs
operator|-=
name|x
expr_stmt|;
name|n
operator|+=
name|x
expr_stmt|;
block|}
for|for
control|(
name|nsrr
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsrrsp
argument_list|)
init|;
name|nsrr
operator|!=
name|NULL
operator|&&
name|naddrs
operator|>
literal|0
condition|;
name|nsrr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsrr
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|nsrr
operator|->
name|name
argument_list|,
name|mname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|x
operator|=
name|add_addrs
argument_list|(
name|statp
argument_list|,
name|nsrr
argument_list|,
name|addrs
argument_list|,
name|naddrs
argument_list|)
expr_stmt|;
name|addrs
operator|+=
name|x
expr_stmt|;
name|naddrs
operator|-=
name|x
expr_stmt|;
name|n
operator|+=
name|x
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"satisfy(%s): %d"
operator|,
name|mname
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_addrs
parameter_list|(
name|res_state
name|statp
parameter_list|,
name|rr_ns
modifier|*
name|nsrr
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addrs
parameter_list|,
name|int
name|naddrs
parameter_list|)
block|{
name|rr_a
modifier|*
name|arr
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|arr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|)
init|;
name|arr
operator|!=
name|NULL
condition|;
name|arr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|arr
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|naddrs
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|addrs
operator|++
operator|=
name|arr
operator|->
name|addr
expr_stmt|;
name|naddrs
operator|--
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"add_addrs: %d"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ns_rcode
name|get_soa
parameter_list|(
name|res_state
name|statp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|,
name|size_t
name|zsize
parameter_list|,
name|char
modifier|*
name|mname
parameter_list|,
name|size_t
name|msize
parameter_list|,
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|)
block|{
name|char
name|tname
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|double
name|resp
index|[
name|NS_PACKETSZ
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|;
name|ns_sect
name|sect
decl_stmt|;
name|ns_msg
name|msg
decl_stmt|;
name|u_int
name|rcode
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
comment|/* 	 * Find closest enclosing SOA, even if it's for the root zone. 	 */
comment|/* First canonicalize dname (exactly one unescaped trailing "."). */
name|status
operator|=
name|ns_makecanon
argument_list|(
name|dname
argument_list|,
name|tname
argument_list|,
sizeof|sizeof
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|dname
operator|=
name|tname
expr_stmt|;
comment|/* Now grovel the subdomains, hunting for an SOA answer or auth. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Leading or inter-label '.' are skipped here. */
while|while
condition|(
operator|*
name|dname
operator|==
literal|'.'
condition|)
name|dname
operator|++
expr_stmt|;
comment|/* Is there an SOA? */
name|rcode
operator|=
name|do_query
argument_list|(
name|statp
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|ns_t_soa
argument_list|,
name|resp
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: do_query('%s', %s) failed (%d)"
operator|,
name|dname
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: CNAME or DNAME found"
operator|)
argument_list|)
expr_stmt|;
name|sect
operator|=
name|ns_s_max
operator|,
name|n
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ancount
operator|=
name|ns_msg_count
argument_list|(
name|msg
argument_list|,
name|ns_s_an
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ns_msg_count
argument_list|(
name|msg
argument_list|,
name|ns_s_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancount
operator|>
literal|0
operator|&&
name|rcode
operator|==
name|ISC_R_SUCCESS
condition|)
name|sect
operator|=
name|ns_s_an
operator|,
name|n
operator|=
name|ancount
expr_stmt|;
elseif|else
if|if
condition|(
name|nscount
operator|>
literal|0
condition|)
name|sect
operator|=
name|ns_s_ns
operator|,
name|n
operator|=
name|nscount
expr_stmt|;
else|else
name|sect
operator|=
name|ns_s_max
operator|,
name|n
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|rdata
decl_stmt|;
name|int
name|rdlen
decl_stmt|;
name|ns_rr
name|rr
decl_stmt|;
name|rcode
operator|=
name|ns_parserr
argument_list|(
operator|&
name|msg
argument_list|,
name|sect
argument_list|,
name|i
argument_list|,
operator|&
name|rr
argument_list|)
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: ns_parserr(%s, %d) failed"
operator|,
name|p_section
argument_list|(
name|sect
argument_list|,
name|ns_o_query
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
if|if
condition|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|==
name|ns_t_cname
operator|||
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|==
name|ns_t_dname
condition|)
break|break;
if|if
condition|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|!=
name|ns_t_soa
operator|||
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
operator|!=
name|class
condition|)
continue|continue;
name|t
operator|=
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
name|ns_s_an
case|:
if|if
condition|(
name|ns_samedomain
argument_list|(
name|dname
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: %s'%s', '%s') == 0"
operator|,
literal|"ns_samedomain("
operator|,
name|dname
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOTZONE
return|;
block|}
break|break;
case|case
name|ns_s_ns
case|:
if|if
condition|(
name|ns_samename
argument_list|(
name|dname
argument_list|,
name|t
argument_list|)
operator|==
literal|1
operator|||
name|ns_samedomain
argument_list|(
name|dname
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: %smain('%s', '%s')"
operator|,
literal|"ns_samename() || !ns_samedo"
operator|,
name|dname
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOTZONE
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
literal|1
operator|>
name|zsize
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: zname(%d) too small (%d)"
operator|,
name|zsize
operator|,
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOSPACE
return|;
block|}
name|strcpy
argument_list|(
name|zname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|rdata
operator|=
name|ns_rr_rdata
argument_list|(
name|rr
argument_list|)
expr_stmt|;
name|rdlen
operator|=
name|ns_rr_rdlen
argument_list|(
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_name_uncompress
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|resp
argument_list|,
name|ns_msg_end
argument_list|(
name|msg
argument_list|)
argument_list|,
name|rdata
argument_list|,
name|mname
argument_list|,
name|msize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: %s failed"
operator|,
literal|"ns_name_uncompress"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|rcode
operator|=
name|save_ns
argument_list|(
name|statp
argument_list|,
operator|&
name|msg
argument_list|,
name|ns_s_ns
argument_list|,
name|zname
argument_list|,
name|class
argument_list|,
name|nsrrsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: save_ns failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
comment|/* If we're out of labels, then not even "." has an SOA! */
if|if
condition|(
operator|*
name|dname
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Find label-terminating "."; top of loop will skip it. */
while|while
condition|(
operator|*
name|dname
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
name|dname
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|*
operator|++
name|dname
operator|==
literal|'\0'
condition|)
block|{
return|return
name|ISC_R_NOSPACE
return|;
block|}
name|dname
operator|++
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"get_soa: out of labels"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_DESTADDRREQ
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|get_ns
parameter_list|(
name|res_state
name|statp
parameter_list|,
specifier|const
name|char
modifier|*
name|zname
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|)
block|{
name|double
name|resp
index|[
name|NS_PACKETSZ
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
name|ns_msg
name|msg
decl_stmt|;
name|int
name|n
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
comment|/* Go and get the NS RRs for this zone. */
name|rcode
operator|=
name|do_query
argument_list|(
name|statp
argument_list|,
name|zname
argument_list|,
name|class
argument_list|,
name|ns_t_ns
argument_list|,
name|resp
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_ns: do_query('zname', %s) failed (%d)"
operator|,
name|zname
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|,
name|rcode
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
comment|/* Remember the NS RRs and associated A RRs that came back. */
name|rcode
operator|=
name|save_ns
argument_list|(
name|statp
argument_list|,
operator|&
name|msg
argument_list|,
name|ns_s_an
argument_list|,
name|zname
argument_list|,
name|class
argument_list|,
name|nsrrsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_ns save_ns('%s', %s) failed"
operator|,
name|zname
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|get_glue
parameter_list|(
name|res_state
name|statp
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|)
block|{
name|rr_ns
modifier|*
name|nsrr
decl_stmt|,
modifier|*
name|nsrr_n
decl_stmt|;
comment|/* Go and get the A RRs for each empty NS RR on our list. */
for|for
control|(
name|nsrr
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsrrsp
argument_list|)
init|;
name|nsrr
operator|!=
name|NULL
condition|;
name|nsrr
operator|=
name|nsrr_n
control|)
block|{
name|double
name|resp
index|[
name|NS_PACKETSZ
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
name|ns_msg
name|msg
decl_stmt|;
name|int
name|n
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
name|nsrr_n
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsrr
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|)
condition|)
block|{
name|rcode
operator|=
name|do_query
argument_list|(
name|statp
argument_list|,
name|nsrr
operator|->
name|name
argument_list|,
name|class
argument_list|,
name|ns_t_a
argument_list|,
name|resp
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_glue: do_query('%s', %s') failed"
operator|,
name|nsrr
operator|->
name|name
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_glue: do_query('%s', %s') CNAME or DNAME found"
operator|,
name|nsrr
operator|->
name|name
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|rcode
operator|=
name|save_a
argument_list|(
name|statp
argument_list|,
operator|&
name|msg
argument_list|,
name|ns_s_an
argument_list|,
name|nsrr
operator|->
name|name
argument_list|,
name|class
argument_list|,
operator|&
name|nsrr
operator|->
name|addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_glue: save_r('%s', %s) failed"
operator|,
name|nsrr
operator|->
name|name
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
comment|/* If it's still empty, it's just chaff. */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"get_glue: removing empty '%s' NS"
operator|,
name|nsrr
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free_nsrr
argument_list|(
name|nsrrsp
argument_list|,
name|nsrr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|save_ns
parameter_list|(
name|res_state
name|statp
parameter_list|,
name|ns_msg
modifier|*
name|msg
parameter_list|,
name|ns_sect
name|sect
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ns_msg_count
argument_list|(
operator|*
name|msg
argument_list|,
name|sect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|tname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|rdata
decl_stmt|;
name|rr_ns
modifier|*
name|nsrr
decl_stmt|;
name|ns_rr
name|rr
decl_stmt|;
name|int
name|rdlen
decl_stmt|;
name|rcode
operator|=
name|ns_parserr
argument_list|(
name|msg
argument_list|,
name|sect
argument_list|,
name|i
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_ns: ns_parserr(%s, %d) failed"
operator|,
name|p_section
argument_list|(
name|sect
argument_list|,
name|ns_o_query
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
if|if
condition|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|!=
name|ns_t_ns
operator|||
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
operator|!=
name|class
operator|||
name|ns_samename
argument_list|(
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
argument_list|,
name|owner
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|nsrr
operator|=
name|find_ns
argument_list|(
name|nsrrsp
argument_list|,
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrr
operator|==
name|NULL
condition|)
block|{
name|nsrr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|nsrr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrr
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_ns: malloc failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|rdata
operator|=
name|ns_rr_rdata
argument_list|(
name|rr
argument_list|)
expr_stmt|;
name|rdlen
operator|=
name|ns_rr_rdlen
argument_list|(
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_name_uncompress
argument_list|(
name|ns_msg_base
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|ns_msg_end
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|rdata
argument_list|,
name|tname
argument_list|,
sizeof|sizeof
name|tname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_ns: ns_name_uncompress failed"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nsrr
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|nsrr
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrr
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_ns: strdup failed"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nsrr
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|nsrrsp
argument_list|,
name|nsrr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|rcode
operator|=
name|save_a
argument_list|(
name|statp
argument_list|,
name|msg
argument_list|,
name|ns_s_ar
argument_list|,
name|nsrr
operator|->
name|name
argument_list|,
name|class
argument_list|,
operator|&
name|nsrr
operator|->
name|addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_ns: save_r('%s', %s) failed"
operator|,
name|nsrr
operator|->
name|name
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|save_a
parameter_list|(
name|res_state
name|statp
parameter_list|,
name|ns_msg
modifier|*
name|msg
parameter_list|,
name|ns_sect
name|sect
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|rrset_a
modifier|*
name|arrsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ns_msg_count
argument_list|(
operator|*
name|msg
argument_list|,
name|sect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ns_rr
name|rr
decl_stmt|;
name|rr_a
modifier|*
name|arr
decl_stmt|;
name|rcode
operator|=
name|ns_parserr
argument_list|(
name|msg
argument_list|,
name|sect
argument_list|,
name|i
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_a: ns_parserr(%s, %d) failed"
operator|,
name|p_section
argument_list|(
name|sect
argument_list|,
name|ns_o_query
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
if|if
condition|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|!=
name|ns_t_a
operator|||
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
operator|!=
name|class
operator|||
name|ns_samename
argument_list|(
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
argument_list|,
name|owner
argument_list|)
operator|!=
literal|1
operator|||
name|ns_rr_rdlen
argument_list|(
name|rr
argument_list|)
operator|!=
name|NS_INADDRSZ
condition|)
continue|continue;
name|arr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arr
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"save_a: malloc failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|arr
operator|->
name|addr
argument_list|,
name|ns_rr_rdata
argument_list|(
name|rr
argument_list|)
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|arrsp
argument_list|,
name|arr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_nsrrset
parameter_list|(
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|)
block|{
name|rr_ns
modifier|*
name|nsrr
decl_stmt|;
while|while
condition|(
operator|(
name|nsrr
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsrrsp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free_nsrr
argument_list|(
name|nsrrsp
argument_list|,
name|nsrr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_nsrr
parameter_list|(
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|,
name|rr_ns
modifier|*
name|nsrr
parameter_list|)
block|{
name|rr_a
modifier|*
name|arr
decl_stmt|;
while|while
condition|(
operator|(
name|arr
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|nsrr
operator|->
name|addrs
argument_list|,
name|arr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsrr
operator|->
name|name
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|nsrrsp
argument_list|,
name|nsrr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nsrr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rr_ns
modifier|*
name|find_ns
parameter_list|(
name|rrset_ns
modifier|*
name|nsrrsp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|)
block|{
name|rr_ns
modifier|*
name|nsrr
decl_stmt|;
for|for
control|(
name|nsrr
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|nsrrsp
argument_list|)
init|;
name|nsrr
operator|!=
name|NULL
condition|;
name|nsrr
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nsrr
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|nsrr
operator|->
name|name
argument_list|,
name|dname
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|nsrr
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|do_query
parameter_list|(
name|res_state
name|statp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|ns_type
name|qtype
parameter_list|,
name|double
modifier|*
name|resp
parameter_list|,
name|ns_msg
modifier|*
name|msg
parameter_list|,
name|int
modifier|*
name|alias_count
parameter_list|)
block|{
name|double
name|req
index|[
name|NS_PACKETSZ
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|res_nmkquery
argument_list|(
name|statp
argument_list|,
name|ns_o_query
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|req
argument_list|,
name|NS_PACKETSZ
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"do_query: res_nmkquery failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|res_nsend
argument_list|(
name|statp
argument_list|,
name|req
argument_list|,
name|n
argument_list|,
name|resp
argument_list|,
name|NS_PACKETSZ
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"do_query: res_nsend failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"do_query: res_nsend returned 0"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
if|if
condition|(
name|ns_initparse
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|resp
argument_list|,
name|n
argument_list|,
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"do_query: ns_initparse failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOSPACE
return|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ns_msg_count
argument_list|(
operator|*
name|msg
argument_list|,
name|ns_s_an
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ns_rr
name|rr
decl_stmt|;
name|status
operator|=
name|ns_parserr
argument_list|(
name|msg
argument_list|,
name|ns_s_an
argument_list|,
name|i
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"do_query: ns_parserr failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|n
operator|+=
operator|(
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
operator|==
name|class
operator|&&
operator|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|==
name|ns_t_cname
operator|||
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
operator|==
name|ns_t_dname
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|alias_count
condition|)
operator|*
name|alias_count
operator|=
name|n
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

end_unit

