begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* trace.c     Subroutines that support tracing of OMAPI wire transactions and    provide a mechanism for programs using OMAPI to trace their own    transactions... */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon, as part of a project for Nominum, Inc.   To learn more  * about the Internet Software Consortium, see http://www.isc.org/.  To  * learn more about Nominum, Inc., see ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
end_if

begin_function_decl
name|void
function_decl|(
modifier|*
name|trace_set_time_hook
function_decl|)
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|tracing_stopped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|traceoutfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|traceindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|trace_type_t
modifier|*
modifier|*
name|trace_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trace_type_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trace_type_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|trace_type_t
modifier|*
name|new_trace_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|traceinfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tracefile_header_t
name|tracefile_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trace_playback_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|trace_type_t
name|trace_time_marker
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|omapi_array_t
modifier|*
name|trace_listeners
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|omapi_array_t
modifier|*
name|omapi_connections
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|trace_free_all
parameter_list|()
block|{
name|trace_type_t
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tp
operator|=
name|new_trace_types
expr_stmt|;
while|while
condition|(
name|tp
condition|)
block|{
name|new_trace_types
operator|=
name|tp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|name
condition|)
block|{
name|dfree
argument_list|(
name|tp
operator|->
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|dfree
argument_list|(
name|tp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|new_trace_types
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trace_type_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trace_types
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|trace_types
index|[
name|i
index|]
operator|->
name|name
condition|)
name|dfree
argument_list|(
name|trace_types
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|trace_types
index|[
name|i
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
name|dfree
argument_list|(
name|trace_types
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|trace_types
operator|=
operator|(
name|trace_type_t
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|trace_type_count
operator|=
name|trace_type_max
operator|=
literal|0
expr_stmt|;
name|omapi_array_free
argument_list|(
operator|&
name|trace_listeners
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_array_free
argument_list|(
operator|&
name|omapi_connections
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|isc_result_t
name|trace_type_record
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|trace_playback
parameter_list|()
block|{
return|return
name|trace_playback_flag
return|;
block|}
end_function

begin_function
name|int
name|trace_record
parameter_list|()
block|{
if|if
condition|(
name|traceoutfile
operator|&&
operator|!
name|tracing_stopped
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|isc_result_t
name|trace_init
parameter_list|(
name|void
function_decl|(
modifier|*
name|set_time
function_decl|)
parameter_list|(
name|u_int32_t
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|trace_type_t
modifier|*
name|root_type
decl_stmt|;
specifier|static
name|int
name|root_setup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|root_setup
condition|)
return|return
name|ISC_R_SUCCESS
return|;
name|trace_set_time_hook
operator|=
name|set_time
expr_stmt|;
name|root_type
operator|=
name|trace_type_register
argument_list|(
literal|"trace-index-mapping"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_index_map_input
argument_list|,
name|trace_index_stop_tracing
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_type
condition|)
return|return
name|ISC_R_UNEXPECTED
return|;
if|if
condition|(
name|new_trace_types
operator|==
name|root_type
condition|)
name|new_trace_types
operator|=
name|new_trace_types
operator|->
name|next
expr_stmt|;
name|root_type
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|trace_type_stash
argument_list|(
name|root_type
argument_list|)
expr_stmt|;
name|root_setup
operator|=
literal|1
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|trace_begin
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|tracefile_header_t
name|tfh
decl_stmt|;
name|int
name|status
decl_stmt|;
name|trace_type_t
modifier|*
name|tptr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|traceoutfile
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_begin called twice"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
block|}
name|traceoutfile
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceoutfile
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_begin: %s: %m"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|traceoutfile
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tfh
operator|.
name|magic
operator|=
name|htonl
argument_list|(
name|TRACEFILE_MAGIC
argument_list|)
expr_stmt|;
name|tfh
operator|.
name|version
operator|=
name|htonl
argument_list|(
name|TRACEFILE_VERSION
argument_list|)
expr_stmt|;
name|tfh
operator|.
name|hlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
name|tracefile_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|tfh
operator|.
name|phlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
name|tracepacket_t
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|write
argument_list|(
name|traceoutfile
argument_list|,
operator|&
name|tfh
argument_list|,
sizeof|sizeof
name|tfh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_begin write failed: %m"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
sizeof|sizeof
name|tfh
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_begin: short write (%d:%ld)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|status
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
name|tfh
argument_list|)
argument_list|)
expr_stmt|;
name|trace_stop
argument_list|()
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
comment|/* Stash all the types that have already been set up. */
if|if
condition|(
name|new_trace_types
condition|)
block|{
name|next
operator|=
name|new_trace_types
expr_stmt|;
name|new_trace_types
operator|=
operator|(
name|trace_type_t
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|tptr
operator|=
name|next
init|;
name|tptr
condition|;
name|tptr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tptr
operator|->
name|index
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
operator|(
name|trace_type_record
argument_list|(
name|tptr
argument_list|,
name|strlen
argument_list|(
name|tptr
operator|->
name|name
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|trace_write_packet
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
name|unsigned
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|trace_iov_t
name|iov
decl_stmt|;
name|iov
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|len
operator|=
name|length
expr_stmt|;
return|return
name|trace_write_packet_iov
argument_list|(
name|ttype
argument_list|,
literal|1
argument_list|,
operator|&
name|iov
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|trace_write_packet_iov
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
name|int
name|count
parameter_list|,
name|trace_iov_t
modifier|*
name|iov
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|tracepacket_t
name|tmp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Really shouldn't get called here, but it may be hard to turn off 	   tracing midstream if the trace file write fails or something. */
if|if
condition|(
name|tracing_stopped
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ttype
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet with null trace type"
argument_list|,
name|file
condition|?
name|file
else|:
literal|"<unknown file>"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
block|}
if|if
condition|(
operator|!
name|traceoutfile
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet with no tracefile."
argument_list|,
name|file
condition|?
name|file
else|:
literal|"<unknown file>"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
block|}
comment|/* Compute the total length of the iov. */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|iov
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
comment|/* We have to swap out the data, because it may be read back on a 	   machine of different endianness. */
name|tmp
operator|.
name|type_index
operator|=
name|htonl
argument_list|(
name|ttype
operator|->
name|index
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|when
operator|=
name|htonl
argument_list|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|tmp
operator|.
name|length
operator|=
name|htonl
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|status
operator|=
name|write
argument_list|(
name|traceoutfile
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet write failed: %m"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
sizeof|sizeof
name|tmp
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet: short write (%d:%ld)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|status
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|trace_stop
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|write
argument_list|(
name|traceoutfile
argument_list|,
name|iov
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|iov
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): %s write failed: %m"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
literal|"trace_write_packet"
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|iov
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): %s: short write (%d:%d)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
literal|"trace_write_packet"
argument_list|,
name|status
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|trace_stop
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Write padding on the end of the packet to align the next 	   packet to an 8-byte boundary.   This is in case we decide to 	   use mmap in some clever way later on. */
if|if
condition|(
name|length
operator|%
literal|8
condition|)
block|{
specifier|static
name|char
name|zero
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|unsigned
name|padl
init|=
literal|8
operator|-
operator|(
name|length
operator|%
literal|8
operator|)
decl_stmt|;
name|status
operator|=
name|write
argument_list|(
name|traceoutfile
argument_list|,
name|zero
argument_list|,
name|padl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet write failed: %m"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|padl
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): trace_write_packet: short write (%d:%d)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|status
argument_list|,
name|padl
argument_list|)
expr_stmt|;
name|trace_stop
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|trace_type_stash
parameter_list|(
name|trace_type_t
modifier|*
name|tptr
parameter_list|)
block|{
name|trace_type_t
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|trace_type_max
operator|<=
name|tptr
operator|->
name|index
condition|)
block|{
name|delta
operator|=
name|tptr
operator|->
name|index
operator|-
name|trace_type_max
operator|+
literal|10
expr_stmt|;
name|vec
operator|=
name|dmalloc
argument_list|(
operator|(
operator|(
name|trace_type_max
operator|+
name|delta
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|trace_type_t
operator|*
argument_list|)
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|vec
index|[
name|trace_type_max
index|]
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|trace_type_t
operator|*
argument_list|)
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|trace_type_max
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|trace_types
condition|)
block|{
name|memcpy
argument_list|(
name|vec
argument_list|,
name|trace_types
argument_list|,
name|trace_type_count
operator|*
sizeof|sizeof
argument_list|(
name|trace_type_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|trace_types
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|trace_types
operator|=
name|vec
expr_stmt|;
block|}
name|trace_types
index|[
name|tptr
operator|->
name|index
index|]
operator|=
name|tptr
expr_stmt|;
if|if
condition|(
name|tptr
operator|->
name|index
operator|>=
name|trace_type_count
condition|)
name|trace_type_count
operator|=
name|tptr
operator|->
name|index
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|trace_type_t
modifier|*
name|trace_type_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|baggage
parameter_list|,
name|void
function_decl|(
modifier|*
name|have_packet
function_decl|)
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|stop_tracing
function_decl|)
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|trace_type_t
modifier|*
name|ttmp
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|unsigned
name|slen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|ttmp
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ttmp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttmp
condition|)
return|return
name|ttmp
return|;
name|ttmp
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|ttmp
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|slen
operator|+
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttmp
operator|->
name|name
condition|)
block|{
name|dfree
argument_list|(
name|ttmp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|trace_type_t
operator|*
operator|)
literal|0
return|;
block|}
name|strcpy
argument_list|(
name|ttmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ttmp
operator|->
name|have_packet
operator|=
name|have_packet
expr_stmt|;
name|ttmp
operator|->
name|stop_tracing
operator|=
name|stop_tracing
expr_stmt|;
if|if
condition|(
name|traceoutfile
condition|)
block|{
name|status
operator|=
name|trace_type_record
argument_list|(
name|ttmp
argument_list|,
name|slen
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dfree
argument_list|(
name|ttmp
operator|->
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|ttmp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|trace_type_t
operator|*
operator|)
literal|0
return|;
block|}
block|}
else|else
block|{
name|ttmp
operator|->
name|next
operator|=
name|new_trace_types
expr_stmt|;
name|new_trace_types
operator|=
name|ttmp
expr_stmt|;
block|}
return|return
name|ttmp
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|trace_type_record
parameter_list|(
name|trace_type_t
modifier|*
name|ttmp
parameter_list|,
name|unsigned
name|slen
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|trace_index_mapping_t
modifier|*
name|tim
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|tim
operator|=
name|dmalloc
argument_list|(
name|slen
operator|+
name|TRACE_INDEX_MAPPING_SIZE
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tim
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|ttmp
operator|->
name|index
operator|=
operator|++
name|traceindex
expr_stmt|;
name|trace_type_stash
argument_list|(
name|ttmp
argument_list|)
expr_stmt|;
name|tim
operator|->
name|index
operator|=
name|htonl
argument_list|(
name|ttmp
operator|->
name|index
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tim
operator|->
name|name
argument_list|,
name|ttmp
operator|->
name|name
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|status
operator|=
name|trace_write_packet
argument_list|(
name|trace_types
index|[
literal|0
index|]
argument_list|,
name|slen
operator|+
name|TRACE_INDEX_MAPPING_SIZE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tim
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|tim
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Stop all registered trace types from trying to trace. */
end_comment

begin_function
name|void
name|trace_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trace_type_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|trace_types
index|[
name|i
index|]
operator|->
name|stop_tracing
condition|)
operator|(
operator|*
operator|(
name|trace_types
index|[
name|i
index|]
operator|->
name|stop_tracing
operator|)
operator|)
operator|(
name|trace_types
index|[
name|i
index|]
operator|)
expr_stmt|;
name|tracing_stopped
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|trace_index_map_input
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|trace_index_mapping_t
modifier|*
name|tmap
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|trace_type_t
modifier|*
name|tptr
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|TRACE_INDEX_MAPPING_SIZE
condition|)
block|{
name|log_error
argument_list|(
literal|"short trace index mapping"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmap
operator|=
operator|(
name|trace_index_mapping_t
operator|*
operator|)
name|buf
expr_stmt|;
name|prev
operator|=
operator|&
name|new_trace_types
expr_stmt|;
for|for
control|(
name|tptr
operator|=
name|new_trace_types
init|;
name|tptr
condition|;
name|tptr
operator|=
name|tptr
operator|->
name|next
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|tptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|length
operator|-
name|TRACE_INDEX_MAPPING_SIZE
operator|&&
operator|!
name|memcmp
argument_list|(
name|tptr
operator|->
name|name
argument_list|,
name|tmap
operator|->
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|tptr
operator|->
name|index
operator|=
name|ntohl
argument_list|(
name|tmap
operator|->
name|index
argument_list|)
expr_stmt|;
name|trace_type_stash
argument_list|(
name|tptr
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|tptr
operator|->
name|next
expr_stmt|;
return|return;
block|}
name|prev
operator|=
operator|&
name|tptr
operator|->
name|next
expr_stmt|;
block|}
name|log_error
argument_list|(
literal|"No registered trace type for type name %.*s"
argument_list|,
operator|(
name|int
operator|)
name|length
operator|-
name|TRACE_INDEX_MAPPING_SIZE
argument_list|,
name|tmap
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|trace_index_stop_tracing
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|trace_replay_init
parameter_list|(
name|void
parameter_list|)
block|{
name|trace_playback_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|trace_file_replay
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|tracepacket_t
modifier|*
name|tpkt
init|=
operator|(
name|tracepacket_t
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|unsigned
name|buflen
decl_stmt|;
name|unsigned
name|bufmax
init|=
literal|0
decl_stmt|;
name|trace_type_t
modifier|*
name|ttype
init|=
operator|(
name|trace_type_t
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|traceinfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traceinfile
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't open tracefile %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|traceinfile
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|fread
argument_list|(
operator|&
name|tracefile_header
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|tracefile_header
argument_list|,
name|traceinfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
sizeof|sizeof
name|tracefile_header
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|traceinfile
argument_list|)
condition|)
name|log_error
argument_list|(
literal|"Error reading trace file header: %m"
argument_list|)
expr_stmt|;
else|else
name|log_error
argument_list|(
literal|"Short read on trace file header: %d %ld."
argument_list|,
name|status
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
name|tracefile_header
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tracefile_header
operator|.
name|magic
operator|=
name|ntohl
argument_list|(
name|tracefile_header
operator|.
name|magic
argument_list|)
expr_stmt|;
name|tracefile_header
operator|.
name|version
operator|=
name|ntohl
argument_list|(
name|tracefile_header
operator|.
name|version
argument_list|)
expr_stmt|;
name|tracefile_header
operator|.
name|hlen
operator|=
name|ntohl
argument_list|(
name|tracefile_header
operator|.
name|hlen
argument_list|)
expr_stmt|;
name|tracefile_header
operator|.
name|phlen
operator|=
name|ntohl
argument_list|(
name|tracefile_header
operator|.
name|phlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracefile_header
operator|.
name|magic
operator|!=
name|TRACEFILE_MAGIC
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: not a dhcp trace file."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tracefile_header
operator|.
name|version
operator|>
name|TRACEFILE_VERSION
condition|)
block|{
name|log_error
argument_list|(
literal|"tracefile version %ld> current %ld."
argument_list|,
operator|(
name|long
name|int
operator|)
name|tracefile_header
operator|.
name|version
argument_list|,
operator|(
name|long
name|int
operator|)
name|TRACEFILE_VERSION
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tracefile_header
operator|.
name|phlen
operator|<
sizeof|sizeof
expr|*
name|tpkt
condition|)
block|{
name|log_error
argument_list|(
literal|"tracefile packet size too small - %ld< %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
operator|(
name|long
name|int
operator|)
sizeof|sizeof
expr|*
name|tpkt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|len
operator|=
operator|(
sizeof|sizeof
name|tracefile_header
operator|)
operator|-
name|tracefile_header
operator|.
name|hlen
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"tracefile header size too small - %ld< %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|tracefile_header
operator|.
name|hlen
argument_list|,
operator|(
name|long
name|int
operator|)
sizeof|sizeof
name|tracefile_header
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|fseek
argument_list|(
name|traceinfile
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"can't seek past header: %m"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|tpkt
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tpkt
condition|)
block|{
name|log_error
argument_list|(
literal|"can't allocate trace packet header."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
operator|(
name|result
operator|=
name|trace_get_next_packet
argument_list|(
operator|&
name|ttype
argument_list|,
name|tpkt
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|bufmax
argument_list|)
operator|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
call|(
modifier|*
name|ttype
operator|->
name|have_packet
call|)
argument_list|(
name|ttype
argument_list|,
name|tpkt
operator|->
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ttype
operator|=
operator|(
name|trace_type_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|out
label|:
name|fclose
argument_list|(
name|traceinfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|dfree
argument_list|(
name|buf
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpkt
condition|)
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the next packet from the file.   If ttp points to a nonzero pointer    to a trace type structure, check the next packet to see if it's of the    expected type, and back off if not. */
end_comment

begin_function
name|isc_result_t
name|trace_get_next_packet
parameter_list|(
name|trace_type_t
modifier|*
modifier|*
name|ttp
parameter_list|,
name|tracepacket_t
modifier|*
name|tpkt
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|unsigned
modifier|*
name|buflen
parameter_list|,
name|unsigned
modifier|*
name|bufmax
parameter_list|)
block|{
name|trace_type_t
modifier|*
name|ttype
decl_stmt|;
name|unsigned
name|paylen
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fpos_t
name|curpos
decl_stmt|;
name|status
operator|=
name|fgetpos
argument_list|(
name|traceinfile
argument_list|,
operator|&
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't save tracefile position: %m"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fread
argument_list|(
name|tpkt
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
name|traceinfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
name|tracefile_header
operator|.
name|phlen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|traceinfile
argument_list|)
condition|)
name|log_error
argument_list|(
literal|"Error reading trace packet header: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|ISC_R_EOF
return|;
else|else
name|log_error
argument_list|(
literal|"Short read on trace packet header: "
literal|"%ld %ld."
argument_list|,
operator|(
name|long
name|int
operator|)
name|status
argument_list|,
operator|(
name|long
name|int
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
comment|/* Swap the packet. */
name|tpkt
operator|->
name|type_index
operator|=
name|ntohl
argument_list|(
name|tpkt
operator|->
name|type_index
argument_list|)
expr_stmt|;
name|tpkt
operator|->
name|length
operator|=
name|ntohl
argument_list|(
name|tpkt
operator|->
name|length
argument_list|)
expr_stmt|;
name|tpkt
operator|->
name|when
operator|=
name|ntohl
argument_list|(
name|tpkt
operator|->
name|when
argument_list|)
expr_stmt|;
comment|/* See if there's a handler for this packet type. */
if|if
condition|(
name|tpkt
operator|->
name|type_index
operator|<
name|trace_type_count
operator|&&
name|trace_types
index|[
name|tpkt
operator|->
name|type_index
index|]
condition|)
name|ttype
operator|=
name|trace_types
index|[
name|tpkt
operator|->
name|type_index
index|]
expr_stmt|;
else|else
block|{
name|log_error
argument_list|(
literal|"Trace packet with unknown index %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|tpkt
operator|->
name|type_index
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
comment|/* If we were just hunting for the time marker, we've found it, 	   so back up to the beginning of the packet and return its 	   type. */
if|if
condition|(
name|ttp
operator|&&
operator|*
name|ttp
operator|==
operator|&
name|trace_time_marker
condition|)
block|{
operator|*
name|ttp
operator|=
name|ttype
expr_stmt|;
name|status
operator|=
name|fsetpos
argument_list|(
name|traceinfile
argument_list|,
operator|&
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"fsetpos in tracefile failed: %m"
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
return|return
name|ISC_R_EXISTS
return|;
block|}
comment|/* If we were supposed to get a particular kind of packet, 	   check to see that we got the right kind. */
if|if
condition|(
name|ttp
operator|&&
operator|*
name|ttp
operator|&&
name|ttype
operator|!=
operator|*
name|ttp
condition|)
block|{
name|log_error
argument_list|(
literal|"Read packet type %s when expecting %s"
argument_list|,
name|ttype
operator|->
name|name
argument_list|,
operator|(
operator|*
name|ttp
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|fsetpos
argument_list|(
name|traceinfile
argument_list|,
operator|&
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"fsetpos in tracefile failed: %m"
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
return|return
name|ISC_R_UNEXPECTEDTOKEN
return|;
block|}
name|paylen
operator|=
name|tpkt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|paylen
operator|%
literal|8
condition|)
name|paylen
operator|+=
literal|8
operator|-
operator|(
name|tpkt
operator|->
name|length
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|paylen
operator|>
operator|(
operator|*
name|bufmax
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf
operator|)
condition|)
name|dfree
argument_list|(
operator|(
operator|*
name|buf
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bufmax
operator|)
operator|=
operator|(
operator|(
name|paylen
operator|+
literal|1023
operator|)
operator|&
operator|~
literal|1023U
operator|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|=
name|dmalloc
argument_list|(
operator|(
operator|*
name|bufmax
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|buf
operator|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't allocate input buffer sized %d"
argument_list|,
operator|(
operator|*
name|bufmax
operator|)
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
block|}
name|status
operator|=
name|fread
argument_list|(
operator|(
operator|*
name|buf
operator|)
argument_list|,
literal|1
argument_list|,
name|paylen
argument_list|,
name|traceinfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
name|paylen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|traceinfile
argument_list|)
condition|)
name|log_error
argument_list|(
literal|"Error reading trace payload: %m"
argument_list|)
expr_stmt|;
else|else
name|log_error
argument_list|(
literal|"Short read on trace payload: %d %d."
argument_list|,
name|status
argument_list|,
name|paylen
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
comment|/* Store the actual length of the payload. */
operator|*
name|buflen
operator|=
name|tpkt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|trace_set_time_hook
condition|)
call|(
modifier|*
name|trace_set_time_hook
call|)
argument_list|(
name|tpkt
operator|->
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttp
condition|)
operator|*
name|ttp
operator|=
name|ttype
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|trace_get_packet
parameter_list|(
name|trace_type_t
modifier|*
modifier|*
name|ttp
parameter_list|,
name|unsigned
modifier|*
name|buflen
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|tracepacket_t
modifier|*
name|tpkt
decl_stmt|;
name|unsigned
name|bufmax
init|=
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
operator|*
name|buf
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|tpkt
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tpkt
condition|)
block|{
name|log_error
argument_list|(
literal|"can't allocate trace packet header."
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|status
operator|=
name|trace_get_next_packet
argument_list|(
name|ttp
argument_list|,
name|tpkt
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
operator|&
name|bufmax
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|time_t
name|trace_snoop_time
parameter_list|(
name|trace_type_t
modifier|*
modifier|*
name|ptp
parameter_list|)
block|{
name|tracepacket_t
modifier|*
name|tpkt
decl_stmt|;
name|unsigned
name|bufmax
init|=
literal|0
decl_stmt|;
name|unsigned
name|buflen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|time_t
name|result
decl_stmt|;
name|trace_type_t
modifier|*
name|ttp
decl_stmt|;
if|if
condition|(
operator|!
name|ptp
condition|)
name|ptp
operator|=
operator|&
name|ttp
expr_stmt|;
name|tpkt
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tpkt
condition|)
block|{
name|log_error
argument_list|(
literal|"can't allocate trace packet header."
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
operator|*
name|ptp
operator|=
operator|&
name|trace_time_marker
expr_stmt|;
name|trace_get_next_packet
argument_list|(
name|ptp
argument_list|,
name|tpkt
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|bufmax
argument_list|)
expr_stmt|;
name|result
operator|=
name|tpkt
operator|->
name|when
expr_stmt|;
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Get a packet from the trace input file that contains a file with the    specified name.   We don't hunt for the packet - it should be the next    packet in the tracefile.   If it's not, or something else bad happens,    return an error code. */
end_comment

begin_function
name|isc_result_t
name|trace_get_file
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
modifier|*
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|fpos_t
name|curpos
decl_stmt|;
name|unsigned
name|max
init|=
literal|0
decl_stmt|;
name|tracepacket_t
modifier|*
name|tpkt
decl_stmt|;
name|int
name|status
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* Disallow some obvious bogosities. */
if|if
condition|(
operator|!
name|buf
operator|||
operator|!
name|len
operator|||
operator|*
name|buf
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* Save file position in case of filename mismatch. */
name|status
operator|=
name|fgetpos
argument_list|(
name|traceinfile
argument_list|,
operator|&
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't save tracefile position: %m"
argument_list|)
expr_stmt|;
name|tpkt
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|tracefile_header
operator|.
name|phlen
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tpkt
condition|)
block|{
name|log_error
argument_list|(
literal|"can't allocate trace packet header."
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|result
operator|=
name|trace_get_next_packet
argument_list|(
operator|&
name|ttype
argument_list|,
name|tpkt
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
condition|)
name|dfree
argument_list|(
operator|*
name|buf
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Make sure the filename is right. */
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
operator|*
name|buf
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Read file %s when expecting %s"
argument_list|,
operator|*
name|buf
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|status
operator|=
name|fsetpos
argument_list|(
name|traceinfile
argument_list|,
operator|&
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"fsetpos in tracefile failed: %m"
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
operator|*
name|buf
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_PROTOCOLERROR
return|;
block|}
return|return
name|ISC_R_UNEXPECTEDTOKEN
return|;
block|}
name|dfree
argument_list|(
name|tpkt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRACING */
end_comment

end_unit

