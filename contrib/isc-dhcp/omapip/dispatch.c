begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dispatch.c     I/O dispatcher. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999-2000 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_decl_stmt
specifier|static
name|omapi_io_object_t
name|omapi_io_states
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cur_time
decl_stmt|;
end_decl_stmt

begin_macro
name|OMAPI_OBJECT_ALLOC
argument_list|(
argument|omapi_io
argument_list|,
argument|omapi_io_object_t
argument_list|,
argument|omapi_type_io_object
argument_list|)
end_macro

begin_macro
name|OMAPI_OBJECT_ALLOC
argument_list|(
argument|omapi_waiter
argument_list|,
argument|omapi_waiter_object_t
argument_list|,
argument|omapi_type_waiter
argument_list|)
end_macro

begin_comment
comment|/* Register an I/O handle so that we can do asynchronous I/O on it. */
end_comment

begin_function
name|isc_result_t
name|omapi_register_io_object
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|int
function_decl|(
modifier|*
name|readfd
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|writefd
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|)
parameter_list|,
name|isc_result_t
function_decl|(
modifier|*
name|reader
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|)
parameter_list|,
name|isc_result_t
function_decl|(
modifier|*
name|writer
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|)
parameter_list|,
name|isc_result_t
function_decl|(
modifier|*
name|reaper
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_io_object_t
modifier|*
name|obj
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* omapi_io_states is a static object.   If its reference count 	   is zero, this is the first I/O handle to be registered, so 	   we need to initialize it.   Because there is no inner or outer 	   pointer on this object, and we're setting its refcnt to 1, it 	   will never be freed. */
if|if
condition|(
operator|!
name|omapi_io_states
operator|.
name|refcnt
condition|)
block|{
name|omapi_io_states
operator|.
name|refcnt
operator|=
literal|1
expr_stmt|;
name|omapi_io_states
operator|.
name|type
operator|=
name|omapi_type_io_object
expr_stmt|;
block|}
name|obj
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|omapi_io_allocate
argument_list|(
operator|&
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|omapi_object_reference
argument_list|(
operator|&
name|obj
operator|->
name|inner
argument_list|,
name|h
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|omapi_object_reference
argument_list|(
operator|&
name|h
operator|->
name|outer
argument_list|,
operator|(
name|omapi_object_t
operator|*
operator|)
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* Find the last I/O state, if there are any. */
for|for
control|(
name|p
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|p
operator|&&
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|p
operator|->
name|next
argument_list|,
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
else|else
name|omapi_io_reference
argument_list|(
operator|&
name|omapi_io_states
operator|.
name|next
argument_list|,
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|obj
operator|->
name|readfd
operator|=
name|readfd
expr_stmt|;
name|obj
operator|->
name|writefd
operator|=
name|writefd
expr_stmt|;
name|obj
operator|->
name|reader
operator|=
name|reader
expr_stmt|;
name|obj
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
name|obj
operator|->
name|reaper
operator|=
name|reaper
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_unregister_io_object
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|)
block|{
name|omapi_io_object_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|obj
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|ph
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|outer
operator|||
name|h
operator|->
name|outer
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|obj
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
name|h
operator|->
name|outer
expr_stmt|;
name|ph
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
expr_stmt|;
name|omapi_io_reference
argument_list|(
operator|&
name|ph
argument_list|,
name|obj
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* remove from the list of I/O states */
name|last
operator|=
operator|&
name|omapi_io_states
expr_stmt|;
for|for
control|(
name|p
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|obj
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_reference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|p
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|next
condition|)
name|omapi_io_dereference
argument_list|(
operator|&
name|obj
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|outer
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|outer
operator|->
name|inner
operator|==
operator|(
name|omapi_object_t
operator|*
operator|)
name|obj
condition|)
name|omapi_object_dereference
argument_list|(
operator|&
name|obj
operator|->
name|outer
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_object_dereference
argument_list|(
operator|&
name|obj
operator|->
name|outer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|omapi_object_dereference
argument_list|(
operator|&
name|obj
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_object_dereference
argument_list|(
operator|&
name|h
operator|->
name|outer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_dereference
argument_list|(
operator|&
name|ph
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_dispatch
parameter_list|(
name|struct
name|timeval
modifier|*
name|t
parameter_list|)
block|{
return|return
name|omapi_wait_for_completion
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
operator|&
name|omapi_io_states
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_wait_for_completion
parameter_list|(
name|omapi_object_t
modifier|*
name|object
parameter_list|,
name|struct
name|timeval
modifier|*
name|t
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_waiter_object_t
modifier|*
name|waiter
decl_stmt|;
name|omapi_object_t
modifier|*
name|inner
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|omapi_waiter_allocate
argument_list|(
operator|&
name|waiter
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Paste the waiter object onto the inner object we're 		   waiting on. */
for|for
control|(
name|inner
operator|=
name|object
init|;
name|inner
operator|->
name|inner
condition|;
name|inner
operator|=
name|inner
operator|->
name|inner
control|)
empty_stmt|;
name|status
operator|=
name|omapi_object_reference
argument_list|(
operator|&
name|waiter
operator|->
name|outer
argument_list|,
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|omapi_waiter_dereference
argument_list|(
operator|&
name|waiter
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|omapi_object_reference
argument_list|(
operator|&
name|inner
operator|->
name|inner
argument_list|,
operator|(
name|omapi_object_t
operator|*
operator|)
name|waiter
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|omapi_waiter_dereference
argument_list|(
operator|&
name|waiter
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
else|else
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
literal|0
expr_stmt|;
do|do
block|{
name|status
operator|=
name|omapi_one_dispatch
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
name|waiter
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
do|while
condition|(
operator|!
name|waiter
operator|||
operator|!
name|waiter
operator|->
name|ready
condition|)
do|;
if|if
condition|(
name|waiter
operator|->
name|outer
condition|)
block|{
if|if
condition|(
name|waiter
operator|->
name|outer
operator|->
name|inner
condition|)
block|{
name|omapi_object_dereference
argument_list|(
operator|&
name|waiter
operator|->
name|outer
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiter
operator|->
name|inner
condition|)
name|omapi_object_reference
argument_list|(
operator|&
name|waiter
operator|->
name|outer
operator|->
name|inner
argument_list|,
name|waiter
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|omapi_object_dereference
argument_list|(
operator|&
name|waiter
operator|->
name|outer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waiter
operator|->
name|inner
condition|)
name|omapi_object_dereference
argument_list|(
operator|&
name|waiter
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|status
operator|=
name|waiter
operator|->
name|waitstatus
expr_stmt|;
name|omapi_waiter_dereference
argument_list|(
operator|&
name|waiter
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_one_dispatch
parameter_list|(
name|omapi_object_t
modifier|*
name|wo
parameter_list|,
name|struct
name|timeval
modifier|*
name|t
parameter_list|)
block|{
name|fd_set
name|r
decl_stmt|,
name|w
decl_stmt|,
name|x
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|to
decl_stmt|;
name|omapi_io_object_t
modifier|*
name|io
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|omapi_waiter_object_t
modifier|*
name|waiter
decl_stmt|;
name|omapi_object_t
modifier|*
name|tmp
init|=
operator|(
name|omapi_object_t
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|wo
operator|||
name|wo
operator|->
name|type
operator|!=
name|omapi_type_waiter
condition|)
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
name|wo
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* First, see if the timeout has expired, and if so return. */
if|if
condition|(
name|t
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>
name|t
operator|->
name|tv_sec
operator|||
operator|(
name|now
operator|.
name|tv_sec
operator|==
name|t
operator|->
name|tv_sec
operator|&&
name|now
operator|.
name|tv_usec
operator|>=
name|t
operator|->
name|tv_usec
operator|)
condition|)
return|return
name|ISC_R_TIMEDOUT
return|;
comment|/* We didn't time out, so figure out how long until 		   we do. */
name|to
operator|.
name|tv_sec
operator|=
name|t
operator|->
name|tv_sec
operator|-
name|now
operator|.
name|tv_sec
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
name|t
operator|->
name|tv_usec
operator|-
name|now
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|to
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|to
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|to
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
comment|/* It is possible for the timeout to get set larger than 		   the largest time select() is willing to accept. 		   Restricting the timeout to a maximum of one day should 		   work around this.  -DPN.  (Ref: Bug #416) */
if|if
condition|(
name|to
operator|.
name|tv_sec
operator|>
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
condition|)
name|to
operator|.
name|tv_sec
operator|=
literal|60
operator|*
literal|60
operator|*
literal|24
expr_stmt|;
block|}
comment|/* If the object we're waiting on has reached completion, 	   return now. */
if|if
condition|(
name|waiter
operator|&&
name|waiter
operator|->
name|ready
condition|)
return|return
name|ISC_R_SUCCESS
return|;
name|again
label|:
comment|/* If we have no I/O state, we can't proceed. */
if|if
condition|(
operator|!
operator|(
name|io
operator|=
name|omapi_io_states
operator|.
name|next
operator|)
condition|)
return|return
name|ISC_R_NOMORE
return|;
comment|/* Set up the read and write masks. */
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|io
condition|;
name|io
operator|=
name|io
operator|->
name|next
control|)
block|{
comment|/* Check for a read socket.   If we shouldn't be 		   trying to read for this I/O object, either there 		   won't be a readfd function, or it'll return -1. */
if|if
condition|(
name|io
operator|->
name|readfd
operator|&&
name|io
operator|->
name|inner
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|readfd
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|desc
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|>
name|max
condition|)
name|max
operator|=
name|desc
expr_stmt|;
block|}
comment|/* Same deal for write fdets. */
if|if
condition|(
name|io
operator|->
name|writefd
operator|&&
name|io
operator|->
name|inner
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|writefd
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|desc
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|>
name|max
condition|)
name|max
operator|=
name|desc
expr_stmt|;
block|}
block|}
comment|/* Wait for a packet or a timeout... XXX */
if|#
directive|if
literal|0
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
define|#
directive|define
name|fds_bits
value|__fds_bits
endif|#
directive|endif
block|log_error ("dispatch: %d %lx %lx", max, 		   (unsigned long)r.fds_bits [0], 		   (unsigned long)w.fds_bits [0]);
endif|#
directive|endif
name|count
operator|=
name|select
argument_list|(
name|max
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|x
argument_list|,
name|t
operator|?
operator|&
name|to
operator|:
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the current time... */
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
comment|/* We probably have a bad file descriptor.   Figure out which one. 	   When we find it, call the reaper function on it, which will 	   maybe make it go away, and then try again. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|struct
name|timeval
name|t0
decl_stmt|;
name|omapi_io_object_t
modifier|*
name|prev
init|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
decl_stmt|;
name|io
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|omapi_io_states
operator|.
name|next
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|io
argument_list|,
name|omapi_io_states
operator|.
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
while|while
condition|(
name|io
condition|)
block|{
name|omapi_object_t
modifier|*
name|obj
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|t0
operator|.
name|tv_sec
operator|=
name|t0
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|readfd
operator|&&
name|io
operator|->
name|inner
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|readfd
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|desc
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|log_error ("read check: %d %lx %lx", max, 				       (unsigned long)r.fds_bits [0], 				       (unsigned long)w.fds_bits [0]);
endif|#
directive|endif
name|count
operator|=
name|select
argument_list|(
name|desc
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|t0
argument_list|)
expr_stmt|;
name|bogon
label|:
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"Bad descriptor %d."
argument_list|,
name|desc
argument_list|)
expr_stmt|;
for|for
control|(
name|obj
operator|=
operator|(
name|omapi_object_t
operator|*
operator|)
name|io
init|;
name|obj
operator|->
name|outer
condition|;
name|obj
operator|=
name|obj
operator|->
name|outer
control|)
empty_stmt|;
for|for
control|(
init|;
name|obj
condition|;
name|obj
operator|=
name|obj
operator|->
name|inner
control|)
block|{
name|omapi_value_t
modifier|*
name|ov
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|ov
operator|=
operator|(
name|omapi_value_t
operator|*
operator|)
literal|0
expr_stmt|;
name|omapi_get_value_str
argument_list|(
name|obj
argument_list|,
operator|(
name|omapi_object_t
operator|*
operator|)
literal|0
argument_list|,
literal|"name"
argument_list|,
operator|&
name|ov
argument_list|)
expr_stmt|;
if|if
condition|(
name|ov
operator|&&
name|ov
operator|->
name|value
operator|&&
operator|(
name|ov
operator|->
name|value
operator|->
name|type
operator|==
name|omapi_datatype_string
operator|)
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|ov
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
expr_stmt|;
name|len
operator|=
name|ov
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|""
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|log_error
argument_list|(
literal|"Object %lx %s%s%.*s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|obj
argument_list|,
name|obj
operator|->
name|type
operator|->
name|name
argument_list|,
name|len
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|len
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|omapi_value_dereference
argument_list|(
operator|&
name|ov
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|reaper
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|prev
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|next
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|prev
operator|->
name|next
argument_list|,
name|io
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|omapi_io_states
operator|.
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|next
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|omapi_io_states
operator|.
name|next
argument_list|,
name|io
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|omapi_io_dereference
argument_list|(
operator|&
name|io
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|t0
operator|.
name|tv_sec
operator|=
name|t0
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* Same deal for write fdets. */
if|if
condition|(
name|io
operator|->
name|writefd
operator|&&
name|io
operator|->
name|inner
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|writefd
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|desc
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|count
operator|=
name|select
argument_list|(
name|desc
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|t0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|bogon
goto|;
block|}
if|if
condition|(
name|prev
condition|)
name|omapi_io_dereference
argument_list|(
operator|&
name|prev
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_reference
argument_list|(
operator|&
name|prev
argument_list|,
name|io
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_dereference
argument_list|(
operator|&
name|io
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|next
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|io
argument_list|,
name|prev
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|omapi_io_dereference
argument_list|(
operator|&
name|prev
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|io
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|io
condition|;
name|io
operator|=
name|io
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|io
operator|->
name|inner
condition|)
continue|continue;
name|omapi_object_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|io
operator|->
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Check for a read descriptor, and if there is one, 		   see if we got input on that socket. */
if|if
condition|(
name|io
operator|->
name|readfd
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|readfd
operator|)
operator|)
operator|(
name|tmp
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|desc
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|status
operator|=
operator|(
operator|(
operator|*
operator|(
name|io
operator|->
name|reader
operator|)
operator|)
operator|(
name|tmp
operator|)
operator|)
expr_stmt|;
comment|/* XXX what to do with status? */
block|}
comment|/* Same deal for write descriptors. */
if|if
condition|(
name|io
operator|->
name|writefd
operator|&&
operator|(
name|desc
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|writefd
operator|)
operator|)
operator|(
name|tmp
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|desc
argument_list|,
operator|&
name|w
argument_list|)
condition|)
name|status
operator|=
operator|(
operator|(
operator|*
operator|(
name|io
operator|->
name|writer
operator|)
operator|)
operator|(
name|tmp
operator|)
operator|)
expr_stmt|;
comment|/* XXX what to do with status? */
block|}
name|omapi_object_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Now check for I/O handles that are no longer valid, 	   and remove them from the list. */
name|prev
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|io
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|io
condition|;
name|io
operator|=
name|io
operator|->
name|next
control|)
block|{
if|if
condition|(
name|io
operator|->
name|reaper
condition|)
block|{
if|if
condition|(
name|io
operator|->
name|inner
condition|)
name|status
operator|=
operator|(
operator|*
operator|(
name|io
operator|->
name|reaper
operator|)
operator|)
operator|(
name|io
operator|->
name|inner
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
operator|->
name|inner
operator|||
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|omapi_io_object_t
modifier|*
name|tmp
init|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Save a reference to the next 				   pointer, if there is one. */
if|if
condition|(
name|io
operator|->
name|next
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|io
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|prev
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|prev
operator|->
name|next
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|omapi_io_states
operator|.
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|omapi_io_reference
argument_list|(
operator|&
name|omapi_io_states
operator|.
name|next
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
else|else
name|omapi_signal_in
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
operator|&
name|omapi_io_states
argument_list|,
literal|"ready"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
condition|)
name|omapi_io_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|io
expr_stmt|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_set_value
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_data_string_t
modifier|*
name|name
parameter_list|,
name|omapi_typed_data_t
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|set_value
condition|)
return|return
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|set_value
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|id
operator|,
name|name
operator|,
name|value
operator|)
return|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_get_value
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_data_string_t
modifier|*
name|name
parameter_list|,
name|omapi_value_t
modifier|*
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|get_value
condition|)
return|return
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|get_value
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|id
operator|,
name|name
operator|,
name|value
operator|)
return|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_destroy
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|omapi_io_object_t
modifier|*
name|obj
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|obj
operator|=
operator|(
name|omapi_io_object_t
operator|*
operator|)
name|h
expr_stmt|;
comment|/* remove from the list of I/O states */
for|for
control|(
name|p
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|obj
condition|)
block|{
name|omapi_io_dereference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_reference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|p
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_io_dereference
argument_list|(
operator|&
name|p
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|p
expr_stmt|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_signal_handler
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|signal_handler
condition|)
return|return
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|signal_handler
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|name
operator|,
name|ap
operator|)
return|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_stuff_values
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_object_t
modifier|*
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|->
name|type
operator|!=
name|omapi_type_io_object
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|i
operator|->
name|inner
operator|&&
name|i
operator|->
name|inner
operator|->
name|type
operator|->
name|stuff_values
condition|)
return|return
operator|(
operator|*
operator|(
name|i
operator|->
name|inner
operator|->
name|type
operator|->
name|stuff_values
operator|)
operator|)
operator|(
name|c
operator|,
name|id
operator|,
name|i
operator|->
name|inner
operator|)
return|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_waiter_signal_handler
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|omapi_waiter_object_t
modifier|*
name|waiter
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|omapi_type_waiter
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ready"
argument_list|)
condition|)
block|{
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
name|h
expr_stmt|;
name|waiter
operator|->
name|ready
operator|=
literal|1
expr_stmt|;
name|waiter
operator|->
name|waitstatus
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"status"
argument_list|)
condition|)
block|{
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
name|h
expr_stmt|;
name|waiter
operator|->
name|ready
operator|=
literal|1
expr_stmt|;
name|waiter
operator|->
name|waitstatus
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|isc_result_t
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"disconnect"
argument_list|)
condition|)
block|{
name|waiter
operator|=
operator|(
name|omapi_waiter_object_t
operator|*
operator|)
name|h
expr_stmt|;
name|waiter
operator|->
name|ready
operator|=
literal|1
expr_stmt|;
name|waiter
operator|->
name|waitstatus
operator|=
name|ISC_R_CONNRESET
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|signal_handler
condition|)
return|return
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|signal_handler
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|name
operator|,
name|ap
operator|)
return|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_io_state_foreach
parameter_list|(
name|isc_result_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|omapi_io_object_t
modifier|*
name|io
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
for|for
control|(
name|io
operator|=
name|omapi_io_states
operator|.
name|next
init|;
name|io
condition|;
name|io
operator|=
name|io
operator|->
name|next
control|)
block|{
if|if
condition|(
name|io
operator|->
name|inner
condition|)
block|{
name|status
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|io
operator|->
name|inner
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

end_unit

