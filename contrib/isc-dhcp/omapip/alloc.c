begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* alloc.c     Functions supporting memory allocation for the object management    protocol... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999-2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
end_if

begin_decl_stmt
name|struct
name|dmalloc_preamble
modifier|*
name|dmalloc_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dmalloc_outstanding
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dmalloc_longterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dmalloc_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dmalloc_cutoff_generation
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
end_if

begin_decl_stmt
name|struct
name|rc_history_entry
name|rc_history
index|[
name|RC_HISTORY_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rc_history_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rc_history_count
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|print_rc_hist_entry
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|VOIDPTR
name|dmalloc
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|foo
init|=
name|malloc
argument_list|(
name|size
operator|+
name|DMDSIZE
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VOIDPTR
modifier|*
name|bar
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|foo
condition|)
return|return
operator|(
name|VOIDPTR
operator|)
literal|0
return|;
name|bar
operator|=
call|(
name|VOIDPTR
call|)
argument_list|(
name|foo
operator|+
name|DMDOFFSET
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bar
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
name|dp
operator|=
operator|(
expr|struct
name|dmalloc_preamble
operator|*
operator|)
name|foo
expr_stmt|;
name|dp
operator|->
name|prev
operator|=
name|dmalloc_list
expr_stmt|;
if|if
condition|(
name|dmalloc_list
condition|)
name|dmalloc_list
operator|->
name|next
operator|=
name|dp
expr_stmt|;
name|dmalloc_list
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|next
operator|=
operator|(
expr|struct
name|dmalloc_preamble
operator|*
operator|)
literal|0
expr_stmt|;
name|dp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dp
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|dp
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|dp
operator|->
name|generation
operator|=
name|dmalloc_generation
operator|++
expr_stmt|;
name|dmalloc_outstanding
operator|+=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMLFSIZE
condition|;
name|i
operator|++
control|)
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
operator|=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DMDOFFSET
init|;
name|i
operator|<
name|DMDSIZE
condition|;
name|i
operator|++
control|)
name|foo
index|[
name|i
operator|+
name|size
index|]
operator|=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|foo
index|[
name|i
operator|+
name|size
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL_EXHAUSTIVELY
argument_list|)
comment|/* Check _every_ entry in the pool!   Very expensive. */
for|for
control|(
name|dp
operator|=
name|dmalloc_list
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|prev
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMLFSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|foo
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DMDOFFSET
init|;
name|i
operator|<
name|DMDSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|foo
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|foo
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_REFCNT_DMALLOC_FREE
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
name|foo
operator|+
name|DMDOFFSET
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|RC_MALLOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bar
return|;
block|}
end_function

begin_function
name|void
name|dfree
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|VOIDPTR
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"dfree %s(%d): free on null pointer."
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
block|{
name|unsigned
name|char
modifier|*
name|bar
init|=
name|ptr
decl_stmt|;
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bar
operator|-=
name|DMDOFFSET
expr_stmt|;
name|cur
operator|=
operator|(
expr|struct
name|dmalloc_preamble
operator|*
operator|)
name|bar
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dmalloc_list
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|prev
control|)
if|if
condition|(
name|dp
operator|==
name|cur
condition|)
break|break;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): freeing unknown memory: %lx"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cur
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|prev
condition|)
name|dp
operator|->
name|prev
operator|->
name|next
operator|=
name|dp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|next
condition|)
name|dp
operator|->
name|next
operator|->
name|prev
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|dmalloc_list
condition|)
name|dmalloc_list
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|generation
operator|>=
name|dmalloc_cutoff_generation
condition|)
name|dmalloc_outstanding
operator|-=
name|dp
operator|->
name|size
expr_stmt|;
else|else
name|dmalloc_longterm
operator|-=
name|dp
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMLFSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|DMDOFFSET
init|;
name|i
operator|<
name|DMDSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bar
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|bar
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ptr
operator|=
name|bar
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_REFCNT_DMALLOC_FREE
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
operator|+
name|DMDOFFSET
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|RC_MALLOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
end_if

begin_comment
comment|/* For allocation functions that keep their own free lists, we want to    account for the reuse of the memory. */
end_comment

begin_function
name|void
name|dmalloc_reuse
parameter_list|(
name|foo
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|justref
parameter_list|)
name|VOIDPTR
name|foo
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|justref
decl_stmt|;
block|{
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|;
comment|/* Get the pointer to the dmalloc header. */
name|dp
operator|=
name|foo
expr_stmt|;
name|dp
operator|--
expr_stmt|;
comment|/* If we just allocated this and are now referencing it, this 	   function would almost be a no-op, except that it would 	   increment the generation count needlessly.  So just return 	   in this case. */
if|if
condition|(
name|dp
operator|->
name|generation
operator|==
name|dmalloc_generation
condition|)
return|return;
comment|/* If this is longterm data, and we just made reference to it, 	   don't put it on the short-term list or change its name - 	   we don't need to know about this. */
if|if
condition|(
name|dp
operator|->
name|generation
operator|<
name|dmalloc_cutoff_generation
operator|&&
name|justref
condition|)
return|return;
comment|/* Take it out of the place in the allocated list where it was. */
if|if
condition|(
name|dp
operator|->
name|prev
condition|)
name|dp
operator|->
name|prev
operator|->
name|next
operator|=
name|dp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|next
condition|)
name|dp
operator|->
name|next
operator|->
name|prev
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|dmalloc_list
condition|)
name|dmalloc_list
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
comment|/* Account for its removal. */
if|if
condition|(
name|dp
operator|->
name|generation
operator|>=
name|dmalloc_cutoff_generation
condition|)
name|dmalloc_outstanding
operator|-=
name|dp
operator|->
name|size
expr_stmt|;
else|else
name|dmalloc_longterm
operator|-=
name|dp
operator|->
name|size
expr_stmt|;
comment|/* Now put it at the head of the list. */
name|dp
operator|->
name|prev
operator|=
name|dmalloc_list
expr_stmt|;
if|if
condition|(
name|dmalloc_list
condition|)
name|dmalloc_list
operator|->
name|next
operator|=
name|dp
expr_stmt|;
name|dmalloc_list
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|next
operator|=
operator|(
expr|struct
name|dmalloc_preamble
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Change the reference location information. */
name|dp
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|dp
operator|->
name|line
operator|=
name|line
expr_stmt|;
comment|/* Increment the generation. */
name|dp
operator|->
name|generation
operator|=
name|dmalloc_generation
operator|++
expr_stmt|;
comment|/* Account for it. */
name|dmalloc_outstanding
operator|+=
name|dp
operator|->
name|size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmalloc_dump_outstanding
parameter_list|()
block|{
specifier|static
name|unsigned
name|long
name|dmalloc_cutoff_point
decl_stmt|;
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|foo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dmalloc_cutoff_point
condition|)
name|dmalloc_cutoff_point
operator|=
name|dmalloc_cutoff_generation
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dmalloc_list
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|generation
operator|<=
name|dmalloc_cutoff_point
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMLFSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|dp
operator|->
name|low_fence
index|[
name|i
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|foo
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DMDOFFSET
init|;
name|i
operator|<
name|DMDSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|foo
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
operator|!=
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|&
name|foo
index|[
name|i
operator|+
name|dp
operator|->
name|size
index|]
argument_list|)
operator|)
operator|%
literal|143
operator|)
operator|+
literal|113
condition|)
block|{
name|log_error
argument_list|(
literal|"malloc fence modified: %s(%d)"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
comment|/* Don't count data that's actually on a free list                    somewhere. */
if|if
condition|(
name|dp
operator|->
name|file
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|inhistory
init|=
literal|0
decl_stmt|,
name|noted
init|=
literal|0
decl_stmt|;
comment|/* If we have the info, see if this is actually 			   new garbage. */
if|if
condition|(
name|rc_history_count
operator|<
name|RC_HISTORY_MAX
condition|)
block|{
name|count
operator|=
name|rc_history_count
expr_stmt|;
block|}
else|else
name|count
operator|=
name|RC_HISTORY_MAX
expr_stmt|;
name|i
operator|=
name|rc_history_index
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|RC_HISTORY_MAX
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rc_history
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|dp
operator|+
literal|1
condition|)
block|{
name|inhistory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|noted
condition|)
block|{
name|log_info
argument_list|(
literal|"  %s(%d): %d"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
name|noted
operator|=
literal|1
expr_stmt|;
block|}
name|print_rc_hist_entry
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc_history
index|[
name|i
index|]
operator|.
name|refcnt
condition|)
break|break;
block|}
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|RC_HISTORY_MAX
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|--
condition|)
do|;
if|if
condition|(
operator|!
name|inhistory
condition|)
endif|#
directive|endif
name|log_info
argument_list|(
literal|"  %s(%d): %d"
argument_list|,
name|dp
operator|->
name|file
argument_list|,
name|dp
operator|->
name|line
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|dmalloc_list
condition|)
name|dmalloc_cutoff_point
operator|=
name|dmalloc_list
operator|->
name|generation
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_MEMORY_LEAKAGE || DEBUG_MALLOC_POOL */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
end_if

begin_function
specifier|static
name|void
name|print_rc_hist_entry
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|log_info
argument_list|(
literal|"   referenced by %s(%d)[%lx]: addr = %lx  refcnt = %x"
argument_list|,
name|rc_history
index|[
name|i
index|]
operator|.
name|file
argument_list|,
name|rc_history
index|[
name|i
index|]
operator|.
name|line
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rc_history
index|[
name|i
index|]
operator|.
name|reference
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rc_history
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|rc_history
index|[
name|i
index|]
operator|.
name|refcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_rc_history
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|rc_history_index
expr_stmt|;
if|if
condition|(
operator|!
name|rc_history
index|[
name|i
index|]
operator|.
name|file
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rc_history_count
operator|<
name|RC_HISTORY_MAX
condition|)
block|{
name|i
operator|-=
name|rc_history_count
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|RC_HISTORY_MAX
expr_stmt|;
block|}
name|rc_history_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rc_history
index|[
name|i
index|]
operator|.
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|addr
operator|||
name|addr
operator|==
name|rc_history
index|[
name|i
index|]
operator|.
name|addr
condition|)
name|print_rc_hist_entry
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|RC_HISTORY_MAX
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rc_history_index
condition|)
break|break;
block|}
block|}
end_function

begin_function
name|void
name|rc_history_next
parameter_list|(
name|int
name|d
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|RC_HISTORY_COMPRESSION
argument_list|)
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ap
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
comment|/* If we are decreasing the reference count, try to find the 	   entry where the reference was made and eliminate it; then 	   we can also eliminate this reference. */
if|if
condition|(
name|d
condition|)
block|{
name|m
operator|=
name|rc_history_index
operator|-
literal|1000
expr_stmt|;
if|if
condition|(
name|m
operator|<
operator|-
literal|1
condition|)
name|m
operator|=
operator|-
literal|1
expr_stmt|;
name|ap
operator|=
name|rc_history
index|[
name|rc_history_index
index|]
operator|.
name|addr
expr_stmt|;
name|rp
operator|=
name|rc_history
index|[
name|rc_history_index
index|]
operator|.
name|reference
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rc_history_index
operator|-
literal|1
init|;
name|i
operator|>
name|m
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|rc_history
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|ap
condition|)
block|{
if|if
condition|(
name|rc_history
index|[
name|i
index|]
operator|.
name|reference
operator|==
name|rp
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|10
condition|)
block|{
for|for
control|(
name|n
operator|=
name|i
init|;
name|n
operator|<=
name|rc_history_index
condition|;
name|n
operator|++
control|)
name|print_rc_hist_entry
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
literal|11
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|&
name|rc_history
index|[
name|i
index|]
argument_list|,
operator|&
name|rc_history
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|rc_history_index
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rc_history_entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|rc_history_count
expr_stmt|;
operator|--
name|rc_history_index
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|rc_history_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rc_history
index|[
name|j
index|]
operator|.
name|addr
operator|==
name|ap
condition|)
operator|--
name|rc_history
index|[
name|j
index|]
operator|.
name|refcnt
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|10
condition|)
block|{
for|for
control|(
name|n
operator|=
name|i
init|;
name|n
operator|<=
name|rc_history_index
condition|;
name|n
operator|++
control|)
name|print_rc_hist_entry
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
literal|11
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|++
name|rc_history_index
operator|==
name|RC_HISTORY_MAX
condition|)
name|rc_history_index
operator|=
literal|0
expr_stmt|;
operator|++
name|rc_history_count
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
end_if

begin_struct
struct|struct
name|caller
block|{
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dmalloc_find_entry
parameter_list|(
name|struct
name|dmalloc_preamble
modifier|*
name|dp
parameter_list|,
name|struct
name|caller
modifier|*
name|array
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|middle
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|middle
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|middle
operator|==
name|min
condition|)
return|return
name|middle
return|;
if|if
condition|(
name|array
index|[
name|middle
index|]
operator|.
name|dp
operator|->
name|file
operator|==
name|dp
operator|->
name|file
condition|)
block|{
if|if
condition|(
name|array
index|[
name|middle
index|]
operator|.
name|dp
operator|->
name|line
operator|==
name|dp
operator|->
name|line
condition|)
return|return
name|middle
return|;
elseif|else
if|if
condition|(
name|array
index|[
name|middle
index|]
operator|.
name|dp
operator|->
name|line
operator|<
name|dp
operator|->
name|line
condition|)
return|return
name|dmalloc_find_entry
argument_list|(
name|dp
argument_list|,
name|array
argument_list|,
name|middle
argument_list|,
name|max
argument_list|)
return|;
else|else
return|return
name|dmalloc_find_entry
argument_list|(
name|dp
argument_list|,
name|array
argument_list|,
literal|0
argument_list|,
name|middle
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|array
index|[
name|middle
index|]
operator|.
name|dp
operator|->
name|file
operator|<
name|dp
operator|->
name|file
condition|)
return|return
name|dmalloc_find_entry
argument_list|(
name|dp
argument_list|,
name|array
argument_list|,
name|middle
argument_list|,
name|max
argument_list|)
return|;
else|else
return|return
name|dmalloc_find_entry
argument_list|(
name|dp
argument_list|,
name|array
argument_list|,
literal|0
argument_list|,
name|middle
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|omapi_print_dmalloc_usage_by_caller
parameter_list|()
block|{
name|struct
name|dmalloc_preamble
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|foo
decl_stmt|;
name|int
name|ccur
decl_stmt|,
name|cmax
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|caller
name|cp
index|[
literal|1024
index|]
decl_stmt|;
name|cmax
operator|=
literal|1024
expr_stmt|;
name|ccur
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dmalloc_list
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|prev
control|)
block|{
name|i
operator|=
name|dmalloc_find_entry
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
name|ccur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|ccur
operator|||
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|file
operator|!=
name|dp
operator|->
name|file
operator|||
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|line
operator|!=
name|dp
operator|->
name|line
operator|)
operator|&&
name|ccur
operator|==
name|cmax
condition|)
block|{
name|log_error
argument_list|(
literal|"no space for memory usage summary."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
name|ccur
condition|)
block|{
name|cp
index|[
name|ccur
operator|++
index|]
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|cp
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|file
operator|<
name|dp
operator|->
name|file
operator|||
operator|(
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|file
operator|==
name|dp
operator|->
name|file
operator|&&
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|line
operator|<
name|dp
operator|->
name|line
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|ccur
condition|)
name|memmove
argument_list|(
name|cp
operator|+
name|i
operator|+
literal|2
argument_list|,
name|cp
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
name|ccur
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
expr|*
name|cp
argument_list|)
expr_stmt|;
name|cp
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|cp
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|ccur
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|file
operator|!=
name|dp
operator|->
name|file
operator|||
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|line
operator|!=
name|dp
operator|->
name|line
condition|)
block|{
name|memmove
argument_list|(
name|cp
operator|+
name|i
operator|+
literal|1
argument_list|,
name|cp
operator|+
name|i
argument_list|,
operator|(
name|ccur
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
expr|*
name|cp
argument_list|)
expr_stmt|;
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|cp
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|ccur
operator|++
expr_stmt|;
block|}
else|else
name|cp
index|[
name|i
index|]
operator|.
name|count
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("%d\t%s:%d\n", i, dp -> file, dp -> line); 		dump_rc_history (dp + 1);
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccur
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d\t%s:%d\t%d\n"
argument_list|,
name|i
argument_list|,
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|file
argument_list|,
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|->
name|line
argument_list|,
name|cp
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|dump_rc_history
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|dp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_MEMORY_LEAKAGE || DEBUG_MALLOC_POOL */
end_comment

begin_function
name|isc_result_t
name|omapi_object_allocate
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|o
parameter_list|,
name|omapi_object_type_t
modifier|*
name|type
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|size_t
name|tsize
decl_stmt|;
name|omapi_object_t
modifier|*
name|foo
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|type
operator|->
name|allocator
condition|)
block|{
name|foo
operator|=
operator|(
name|omapi_object_t
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|type
operator|->
name|allocator
call|)
argument_list|(
operator|&
name|foo
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|type
operator|->
name|size
expr_stmt|;
block|}
else|else
name|status
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_NOMEMORY
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|sizer
condition|)
name|tsize
operator|=
call|(
modifier|*
name|type
operator|->
name|sizer
call|)
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|tsize
operator|=
name|type
operator|->
name|size
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|tsize
operator|<
sizeof|sizeof
argument_list|(
name|omapi_object_t
argument_list|)
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|foo
operator|=
name|dmalloc
argument_list|(
name|tsize
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foo
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|status
operator|=
name|omapi_object_initialize
argument_list|(
name|foo
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|tsize
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|freer
condition|)
call|(
modifier|*
name|type
operator|->
name|freer
call|)
argument_list|(
name|foo
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|dfree
argument_list|(
name|foo
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
name|omapi_object_reference
argument_list|(
name|o
argument_list|,
name|foo
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_object_initialize
parameter_list|(
name|omapi_object_t
modifier|*
name|o
parameter_list|,
name|omapi_object_type_t
modifier|*
name|type
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|psize
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|o
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|initialize
condition|)
call|(
modifier|*
name|type
operator|->
name|initialize
call|)
argument_list|(
name|o
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_object_reference
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|h
operator|->
name|type
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_object_dereference
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|outer_reference
init|=
literal|0
decl_stmt|;
name|int
name|inner_reference
init|=
literal|0
decl_stmt|;
name|int
name|handle_reference
init|=
literal|0
decl_stmt|;
name|int
name|extra_references
decl_stmt|;
name|omapi_object_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with refcnt of zero!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
comment|/* See if this object's inner object refers to it, but don't 	   count this as a reference if we're being asked to free the 	   reference from the inner object. */
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|inner
operator|&&
operator|(
operator|*
name|h
operator|)
operator|->
name|inner
operator|->
name|outer
operator|&&
name|h
operator|!=
operator|&
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|inner
operator|->
name|outer
operator|)
condition|)
name|inner_reference
operator|=
literal|1
expr_stmt|;
comment|/* Ditto for the outer object. */
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|outer
operator|&&
operator|(
operator|*
name|h
operator|)
operator|->
name|outer
operator|->
name|inner
operator|&&
name|h
operator|!=
operator|&
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|outer
operator|->
name|inner
operator|)
condition|)
name|outer_reference
operator|=
literal|1
expr_stmt|;
comment|/* Ditto for the outer object.  The code below assumes that 	   the only reason we'd get a dereference from the handle 	   table is if this function does it - otherwise we'd have to 	   traverse the handle table to find the address where the 	   reference is stored and compare against that, and we don't 	   want to do that if we can avoid it. */
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|handle
condition|)
name|handle_reference
operator|=
literal|1
expr_stmt|;
comment|/* If we are getting rid of the last reference other than 	   references to inner and outer objects, or from the handle 	   table, then we must examine all the objects in either 	   direction to see if they hold any non-inner, non-outer, 	   non-handle-table references.  If not, we need to free the 	   entire chain of objects. */
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|==
name|inner_reference
operator|+
name|outer_reference
operator|+
name|handle_reference
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|inner_reference
operator|||
name|outer_reference
operator|||
name|handle_reference
condition|)
block|{
comment|/* XXX we could check for a reference from the                            handle table here. */
name|extra_references
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|*
name|h
operator|)
operator|->
name|inner
init|;
name|p
operator|&&
operator|!
name|extra_references
condition|;
name|p
operator|=
name|p
operator|->
name|inner
control|)
block|{
name|extra_references
operator|+=
name|p
operator|->
name|refcnt
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|inner
operator|&&
name|p
operator|->
name|inner
operator|->
name|outer
operator|==
name|p
condition|)
operator|--
name|extra_references
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outer
condition|)
operator|--
name|extra_references
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|handle
condition|)
operator|--
name|extra_references
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
operator|(
operator|*
name|h
operator|)
operator|->
name|outer
init|;
name|p
operator|&&
operator|!
name|extra_references
condition|;
name|p
operator|=
name|p
operator|->
name|outer
control|)
block|{
name|extra_references
operator|+=
name|p
operator|->
name|refcnt
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outer
operator|&&
name|p
operator|->
name|outer
operator|->
name|inner
operator|==
name|p
condition|)
operator|--
name|extra_references
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|inner
condition|)
operator|--
name|extra_references
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|handle
condition|)
operator|--
name|extra_references
expr_stmt|;
block|}
block|}
else|else
name|extra_references
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|extra_references
condition|)
block|{
name|hp
operator|=
operator|*
name|h
expr_stmt|;
operator|*
name|h
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|inner_reference
condition|)
name|omapi_object_dereference
argument_list|(
operator|&
name|hp
operator|->
name|inner
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_reference
condition|)
name|omapi_object_dereference
argument_list|(
operator|&
name|hp
operator|->
name|outer
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/*			if (!hp -> type -> freer) */
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
name|hp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|hp
operator|->
name|type
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|->
name|destroy
condition|)
operator|(
operator|*
operator|(
name|hp
operator|->
name|type
operator|->
name|destroy
operator|)
operator|)
operator|(
name|hp
operator|,
name|file
operator|,
name|line
operator|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|->
name|freer
condition|)
operator|(
name|hp
operator|->
name|type
operator|->
name|freer
argument_list|(
name|hp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
operator|)
expr_stmt|;
else|else
name|dfree
argument_list|(
name|hp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|--
expr_stmt|;
comment|/*			if (!(*h) -> type -> freer) */
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|type
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|--
expr_stmt|;
comment|/*		if (!(*h) -> type -> freer) */
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|type
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_buffer_new
parameter_list|(
name|omapi_buffer_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|omapi_buffer_t
modifier|*
name|t
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|t
operator|=
operator|(
name|omapi_buffer_t
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|t
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
name|status
operator|=
name|omapi_buffer_reference
argument_list|(
name|h
argument_list|,
name|t
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dfree
argument_list|(
name|t
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
operator|*
name|h
operator|)
operator|->
name|head
operator|=
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|h
operator|)
operator|->
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_buffer_reference
parameter_list|(
name|omapi_buffer_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_buffer_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_buffer_dereference
parameter_list|(
name|omapi_buffer_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with refcnt of zero!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|--
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|dfree
argument_list|(
operator|*
name|h
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_typed_data_new
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|omapi_typed_data_t
modifier|*
modifier|*
name|t
parameter_list|,
name|omapi_datatype_t
name|type
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|l
decl_stmt|;
name|omapi_typed_data_t
modifier|*
name|new
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|val
decl_stmt|;
name|int
name|intval
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|omapi_object_t
modifier|*
name|obj
decl_stmt|;
name|va_start
argument_list|(
name|l
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|omapi_datatype_int
case|:
name|len
operator|=
name|OMAPI_TYPED_DATA_INT_LEN
expr_stmt|;
name|intval
operator|=
name|va_arg
argument_list|(
name|l
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|omapi_datatype_string
case|:
name|s
operator|=
name|va_arg
argument_list|(
name|l
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|val
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|OMAPI_TYPED_DATA_NOBUFFER_LEN
operator|+
name|val
expr_stmt|;
break|break;
case|case
name|omapi_datatype_data
case|:
name|val
operator|=
name|va_arg
argument_list|(
name|l
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|len
operator|=
name|OMAPI_TYPED_DATA_NOBUFFER_LEN
operator|+
name|val
expr_stmt|;
break|break;
case|case
name|omapi_datatype_object
case|:
name|len
operator|=
name|OMAPI_TYPED_DATA_OBJECT_LEN
expr_stmt|;
name|obj
operator|=
name|va_arg
argument_list|(
name|l
argument_list|,
name|omapi_object_t
operator|*
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ISC_R_INVALIDARG
return|;
block|}
name|new
operator|=
name|dmalloc
argument_list|(
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|omapi_datatype_int
case|:
name|new
operator|->
name|u
operator|.
name|integer
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|omapi_datatype_string
case|:
name|memcpy
argument_list|(
name|new
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|omapi_datatype_data
case|:
name|new
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|omapi_datatype_object
case|:
name|status
operator|=
name|omapi_object_reference
argument_list|(
operator|&
name|new
operator|->
name|u
operator|.
name|object
argument_list|,
name|obj
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dfree
argument_list|(
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
break|break;
block|}
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
name|omapi_typed_data_reference
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_typed_data_reference
parameter_list|(
name|omapi_typed_data_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_typed_data_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_typed_data_dereference
parameter_list|(
name|omapi_typed_data_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with refcnt of zero!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|--
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|type
condition|)
block|{
case|case
name|omapi_datatype_int
case|:
case|case
name|omapi_datatype_string
case|:
case|case
name|omapi_datatype_data
case|:
default|default:
break|break;
case|case
name|omapi_datatype_object
case|:
name|omapi_object_dereference
argument_list|(
operator|&
operator|(
operator|*
name|h
operator|)
operator|->
name|u
operator|.
name|object
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
name|dfree
argument_list|(
operator|*
name|h
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_data_string_new
parameter_list|(
name|omapi_data_string_t
modifier|*
modifier|*
name|d
parameter_list|,
name|unsigned
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|omapi_data_string_t
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|dmalloc
argument_list|(
name|OMAPI_DATA_STRING_EMPTY_SIZE
operator|+
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|OMAPI_DATA_STRING_EMPTY_SIZE
argument_list|)
expr_stmt|;
name|new
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
name|omapi_data_string_reference
argument_list|(
name|d
argument_list|,
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_data_string_reference
parameter_list|(
name|omapi_data_string_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_data_string_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_data_string_dereference
parameter_list|(
name|omapi_data_string_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with refcnt of zero!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|--
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
name|dfree
argument_list|(
operator|*
name|h
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_value_new
parameter_list|(
name|omapi_value_t
modifier|*
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|omapi_value_t
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
return|return
name|omapi_value_reference
argument_list|(
name|d
argument_list|,
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_value_reference
parameter_list|(
name|omapi_value_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_value_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_value_dereference
parameter_list|(
name|omapi_value_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with refcnt of zero!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|--
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|name
condition|)
name|omapi_data_string_dereference
argument_list|(
operator|&
operator|(
operator|*
name|h
operator|)
operator|->
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|value
condition|)
name|omapi_typed_data_dereference
argument_list|(
operator|&
operator|(
operator|*
name|h
operator|)
operator|->
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
operator|*
name|h
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_addr_list_new
parameter_list|(
name|omapi_addr_list_t
modifier|*
modifier|*
name|d
parameter_list|,
name|unsigned
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|omapi_addr_list_t
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|dmalloc
argument_list|(
operator|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|omapi_addr_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|omapi_addr_list_t
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|omapi_addr_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|omapi_addr_list_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|new
operator|->
name|addresses
operator|=
operator|(
name|omapi_addr_t
operator|*
operator|)
operator|(
name|new
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|omapi_addr_list_reference
argument_list|(
name|d
argument_list|,
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_addr_list_reference
parameter_list|(
name|omapi_addr_list_t
modifier|*
modifier|*
name|r
parameter_list|,
name|omapi_addr_list_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|r
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|*
name|r
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): reference store into non-null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|*
name|r
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|refcnt
operator|++
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|r
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|refcnt
argument_list|,
literal|0
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_addr_list_dereference
parameter_list|(
name|omapi_addr_list_t
modifier|*
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
operator|*
name|h
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of null pointer!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|log_error
argument_list|(
literal|"%s(%d): dereference of pointer with zero refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
endif|#
directive|endif
block|}
operator|--
operator|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|h
argument_list|,
operator|*
name|h
argument_list|,
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|h
operator|)
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
name|dfree
argument_list|(
operator|*
name|h
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

end_unit

