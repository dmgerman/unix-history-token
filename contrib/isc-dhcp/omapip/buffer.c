begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* buffer.c     Buffer access functions for the object management protocol... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999-2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|trace_connection_input_input
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_connection_input_stop
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_connection_output_input
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_connection_output_stop
parameter_list|(
name|trace_type_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|trace_type_t
modifier|*
name|trace_connection_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|trace_type_t
modifier|*
name|trace_connection_output
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|isc_result_t
name|omapi_connection_reader_trace
parameter_list|(
name|omapi_object_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|omapi_array_t
modifier|*
name|omapi_connections
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|omapi_buffer_trace_setup
parameter_list|()
block|{
name|trace_connection_input
operator|=
name|trace_type_register
argument_list|(
literal|"connection-input"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_connection_input_input
argument_list|,
name|trace_connection_input_stop
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|trace_connection_output
operator|=
name|trace_type_register
argument_list|(
literal|"connection-output"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_connection_output_input
argument_list|,
name|trace_connection_output_stop
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trace_connection_input_input
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|left
decl_stmt|,
name|taken
decl_stmt|,
name|cc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int32_t
name|connect_index
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|omapi_connection_object_t
modifier|*
name|c
init|=
operator|(
name|omapi_connection_object_t
operator|*
operator|)
literal|0
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|connect_index
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|connect_index
argument_list|)
expr_stmt|;
name|connect_index
operator|=
name|ntohl
argument_list|(
name|connect_index
argument_list|)
expr_stmt|;
name|omapi_array_foreach_begin
argument_list|(
argument|omapi_connections
argument_list|,
argument|omapi_connection_object_t
argument_list|,
argument|lp
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|index
operator|==
name|ntohl
argument_list|(
name|connect_index
argument_list|)
condition|)
block|{
name|omapi_connection_reference
argument_list|(
operator|&
name|c
argument_list|,
name|lp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_connection_dereference
argument_list|(
operator|&
name|lp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|omapi_array_foreach_end
argument_list|(
name|omapi_connections
argument_list|,
name|omapi_connection_object_t
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|log_error
argument_list|(
literal|"trace connection input: no connection index %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|connect_index
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|buf
operator|+
sizeof|sizeof
name|connect_index
expr_stmt|;
name|left
operator|=
name|length
operator|-
sizeof|sizeof
name|connect_index
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|taken
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|omapi_connection_reader_trace
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
name|c
argument_list|,
name|left
argument_list|,
name|s
argument_list|,
operator|&
name|taken
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|log_error
argument_list|(
literal|"trace connection input: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|taken
condition|)
block|{
if|if
condition|(
name|cc
operator|>
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"trace connection_input: %s"
argument_list|,
literal|"input is not being consumed."
argument_list|)
expr_stmt|;
break|break;
block|}
name|cc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cc
operator|=
literal|0
expr_stmt|;
name|left
operator|-=
name|taken
expr_stmt|;
block|}
block|}
name|omapi_connection_dereference
argument_list|(
operator|&
name|c
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trace_connection_input_stop
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|trace_connection_output_input
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
comment|/* We *could* check to see if the output is correct, but for now 	   we aren't going to do that. */
block|}
end_function

begin_function
specifier|static
name|void
name|trace_connection_output_stop
parameter_list|(
name|trace_type_t
modifier|*
name|ttype
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make sure that at least len bytes are in the input buffer, and if not,    read enough bytes to make up the difference. */
end_comment

begin_function
name|isc_result_t
name|omapi_connection_reader
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
return|return
name|omapi_connection_reader_trace
argument_list|(
name|h
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|omapi_connection_reader_trace
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|unsigned
name|stuff_len
parameter_list|,
name|char
modifier|*
name|stuff_buf
parameter_list|,
name|unsigned
modifier|*
name|stuff_taken
parameter_list|)
block|{
endif|#
directive|endif
name|omapi_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|unsigned
name|read_len
decl_stmt|;
name|int
name|read_status
decl_stmt|;
name|omapi_connection_object_t
modifier|*
name|c
decl_stmt|;
name|unsigned
name|bytes_to_read
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|type
operator|!=
name|omapi_type_connection
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|c
operator|=
operator|(
name|omapi_connection_object_t
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Make sure c -> bytes_needed is valid. */
if|if
condition|(
name|c
operator|->
name|bytes_needed
operator|<
literal|0
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* See if there are enough bytes. */
if|if
condition|(
name|c
operator|->
name|in_bytes
operator|>=
name|OMAPI_BUF_SIZE
operator|-
literal|1
operator|&&
name|c
operator|->
name|in_bytes
operator|>
name|c
operator|->
name|bytes_needed
condition|)
return|return
name|ISC_R_SUCCESS
return|;
if|if
condition|(
name|c
operator|->
name|inbufs
condition|)
block|{
for|for
control|(
name|buffer
operator|=
name|c
operator|->
name|inbufs
init|;
name|buffer
operator|->
name|next
condition|;
name|buffer
operator|=
name|buffer
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|BUFFER_BYTES_FREE
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|status
operator|=
name|omapi_buffer_new
argument_list|(
operator|&
name|buffer
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|omapi_buffer_new
argument_list|(
operator|&
name|c
operator|->
name|inbufs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|buffer
operator|=
name|c
operator|->
name|inbufs
expr_stmt|;
block|}
name|bytes_to_read
operator|=
name|BUFFER_BYTES_FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes_to_read
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|tail
operator|>
name|buffer
operator|->
name|head
condition|)
name|read_len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
operator|->
name|buf
argument_list|)
operator|-
name|buffer
operator|->
name|tail
expr_stmt|;
else|else
name|read_len
operator|=
name|buffer
operator|->
name|head
operator|-
name|buffer
operator|->
name|tail
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
if|if
condition|(
name|trace_playback
argument_list|()
condition|)
block|{
if|if
condition|(
name|stuff_len
condition|)
block|{
if|if
condition|(
name|read_len
operator|>
name|stuff_len
condition|)
name|read_len
operator|=
name|stuff_len
expr_stmt|;
if|if
condition|(
name|stuff_taken
condition|)
operator|*
name|stuff_taken
operator|+=
name|read_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buffer
operator|->
name|buf
index|[
name|buffer
operator|->
name|tail
index|]
argument_list|,
name|stuff_buf
argument_list|,
name|read_len
argument_list|)
expr_stmt|;
name|stuff_len
operator|-=
name|read_len
expr_stmt|;
name|stuff_buf
operator|+=
name|read_len
expr_stmt|;
name|read_status
operator|=
name|read_len
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|read_status
operator|=
name|read
argument_list|(
name|c
operator|->
name|socket
argument_list|,
operator|&
name|buffer
operator|->
name|buf
index|[
name|buffer
operator|->
name|tail
index|]
argument_list|,
name|read_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_status
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
break|break;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
return|return
name|ISC_R_IOERROR
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
condition|)
block|{
name|omapi_disconnect
argument_list|(
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SHUTTINGDOWN
return|;
block|}
else|else
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
comment|/* If we got a zero-length read, as opposed to EWOULDBLOCK, 		   the remote end closed the connection. */
if|if
condition|(
name|read_status
operator|==
literal|0
condition|)
block|{
name|omapi_disconnect
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SHUTTINGDOWN
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
if|if
condition|(
name|trace_record
argument_list|()
condition|)
block|{
name|trace_iov_t
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|int32_t
name|connect_index
decl_stmt|;
name|connect_index
operator|=
name|htonl
argument_list|(
name|c
operator|->
name|index
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|connect_index
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|len
operator|=
sizeof|sizeof
name|connect_index
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|buf
operator|=
operator|&
name|buffer
operator|->
name|buf
index|[
name|buffer
operator|->
name|tail
index|]
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|len
operator|=
name|read_status
expr_stmt|;
name|status
operator|=
operator|(
name|trace_write_packet_iov
argument_list|(
name|trace_connection_input
argument_list|,
literal|2
argument_list|,
name|iov
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|trace_stop
argument_list|()
expr_stmt|;
name|log_error
argument_list|(
literal|"trace connection input: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|buffer
operator|->
name|tail
operator|+=
name|read_status
expr_stmt|;
name|c
operator|->
name|in_bytes
operator|+=
name|read_status
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|tail
operator|==
sizeof|sizeof
name|buffer
operator|->
name|buf
condition|)
name|buffer
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_status
operator|<
name|read_len
condition|)
break|break;
name|bytes_to_read
operator|-=
name|read_status
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|bytes_needed
operator|<=
name|c
operator|->
name|in_bytes
condition|)
block|{
name|omapi_signal
argument_list|(
name|h
argument_list|,
literal|"ready"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Put some bytes into the output buffer for a connection. */
end_comment

begin_function
name|isc_result_t
name|omapi_connection_copyin
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|bufp
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|omapi_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|int
name|bytes_copied
init|=
literal|0
decl_stmt|;
name|unsigned
name|copy_len
decl_stmt|;
name|int
name|sig_flags
init|=
name|SIG_MODE_UPDATE
decl_stmt|;
name|omapi_connection_object_t
modifier|*
name|c
decl_stmt|;
comment|/* Make sure len is valid. */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|type
operator|!=
name|omapi_type_connection
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|c
operator|=
operator|(
name|omapi_connection_object_t
operator|*
operator|)
name|h
expr_stmt|;
comment|/* If the connection is closed, return an error if the caller 	   tries to copy in. */
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|omapi_connection_disconnecting
operator|||
name|c
operator|->
name|state
operator|==
name|omapi_connection_closed
condition|)
return|return
name|ISC_R_NOTCONNECTED
return|;
if|if
condition|(
name|c
operator|->
name|outbufs
condition|)
block|{
for|for
control|(
name|buffer
operator|=
name|c
operator|->
name|outbufs
init|;
name|buffer
operator|->
name|next
condition|;
name|buffer
operator|=
name|buffer
operator|->
name|next
control|)
empty_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|omapi_buffer_new
argument_list|(
operator|&
name|c
operator|->
name|outbufs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|buffer
operator|=
name|c
operator|->
name|outbufs
expr_stmt|;
block|}
while|while
condition|(
name|bytes_copied
operator|<
name|len
condition|)
block|{
comment|/* If there is no space available in this buffer,                    allocate a new one. */
if|if
condition|(
operator|!
name|BUFFER_BYTES_FREE
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|status
operator|=
operator|(
name|omapi_buffer_new
argument_list|(
operator|&
name|buffer
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|->
name|tail
operator|>
name|buffer
operator|->
name|head
condition|)
name|copy_len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
operator|->
name|buf
argument_list|)
operator|-
name|buffer
operator|->
name|tail
expr_stmt|;
else|else
name|copy_len
operator|=
name|buffer
operator|->
name|head
operator|-
name|buffer
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|copy_len
operator|>
operator|(
name|len
operator|-
name|bytes_copied
operator|)
condition|)
name|copy_len
operator|=
name|len
operator|-
name|bytes_copied
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|out_key
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|out_context
condition|)
name|sig_flags
operator||=
name|SIG_MODE_INIT
expr_stmt|;
name|status
operator|=
name|omapi_connection_sign_data
argument_list|(
name|sig_flags
argument_list|,
name|c
operator|->
name|out_key
argument_list|,
operator|&
name|c
operator|->
name|out_context
argument_list|,
operator|&
name|bufp
index|[
name|bytes_copied
index|]
argument_list|,
name|copy_len
argument_list|,
operator|(
name|omapi_typed_data_t
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|buffer
operator|->
name|buf
index|[
name|buffer
operator|->
name|tail
index|]
argument_list|,
operator|&
name|bufp
index|[
name|bytes_copied
index|]
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|tail
operator|+=
name|copy_len
expr_stmt|;
name|c
operator|->
name|out_bytes
operator|+=
name|copy_len
expr_stmt|;
name|bytes_copied
operator|+=
name|copy_len
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|tail
operator|==
sizeof|sizeof
name|buffer
operator|->
name|buf
condition|)
name|buffer
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Copy some bytes from the input buffer, and advance the input buffer    pointer beyond the bytes copied out. */
end_comment

begin_function
name|isc_result_t
name|omapi_connection_copyout
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|unsigned
name|bytes_remaining
decl_stmt|;
name|unsigned
name|bytes_this_copy
decl_stmt|;
name|unsigned
name|first_byte
decl_stmt|;
name|omapi_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|sig_flags
init|=
name|SIG_MODE_UPDATE
decl_stmt|;
name|omapi_connection_object_t
modifier|*
name|c
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|type
operator|!=
name|omapi_type_connection
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|c
operator|=
operator|(
name|omapi_connection_object_t
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|c
operator|->
name|in_bytes
condition|)
return|return
name|ISC_R_NOMORE
return|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|bytes_remaining
operator|=
name|size
expr_stmt|;
name|buffer
operator|=
name|c
operator|->
name|inbufs
expr_stmt|;
while|while
condition|(
name|bytes_remaining
condition|)
block|{
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|ISC_R_UNEXPECTED
return|;
if|if
condition|(
name|BYTES_IN_BUFFER
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|head
operator|==
operator|(
sizeof|sizeof
name|buffer
operator|->
name|buf
operator|)
operator|-
literal|1
condition|)
name|first_byte
operator|=
literal|0
expr_stmt|;
else|else
name|first_byte
operator|=
name|buffer
operator|->
name|head
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|first_byte
operator|>
name|buffer
operator|->
name|tail
condition|)
block|{
name|bytes_this_copy
operator|=
operator|(
sizeof|sizeof
name|buffer
operator|->
name|buf
operator|-
name|first_byte
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytes_this_copy
operator|=
name|buffer
operator|->
name|tail
operator|-
name|first_byte
expr_stmt|;
block|}
if|if
condition|(
name|bytes_this_copy
operator|>
name|bytes_remaining
condition|)
name|bytes_this_copy
operator|=
name|bytes_remaining
expr_stmt|;
if|if
condition|(
name|bufp
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|in_key
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|in_context
condition|)
name|sig_flags
operator||=
name|SIG_MODE_INIT
expr_stmt|;
name|status
operator|=
name|omapi_connection_sign_data
argument_list|(
name|sig_flags
argument_list|,
name|c
operator|->
name|in_key
argument_list|,
operator|&
name|c
operator|->
name|in_context
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|buffer
operator|->
name|buf
index|[
name|first_byte
index|]
argument_list|,
name|bytes_this_copy
argument_list|,
operator|(
name|omapi_typed_data_t
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
name|memcpy
argument_list|(
name|bufp
argument_list|,
operator|&
name|buffer
operator|->
name|buf
index|[
name|first_byte
index|]
argument_list|,
name|bytes_this_copy
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|bytes_this_copy
expr_stmt|;
block|}
name|bytes_remaining
operator|-=
name|bytes_this_copy
expr_stmt|;
name|buffer
operator|->
name|head
operator|=
name|first_byte
operator|+
name|bytes_this_copy
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|in_bytes
operator|-=
name|bytes_this_copy
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BYTES_IN_BUFFER
argument_list|(
name|buffer
argument_list|)
condition|)
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
comment|/* Get rid of any input buffers that we emptied. */
name|buffer
operator|=
operator|(
name|omapi_buffer_t
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|inbufs
operator|&&
operator|!
name|BYTES_IN_BUFFER
argument_list|(
name|c
operator|->
name|inbufs
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|inbufs
operator|->
name|next
condition|)
block|{
name|omapi_buffer_reference
argument_list|(
operator|&
name|buffer
argument_list|,
name|c
operator|->
name|inbufs
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_buffer_dereference
argument_list|(
operator|&
name|c
operator|->
name|inbufs
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|omapi_buffer_dereference
argument_list|(
operator|&
name|c
operator|->
name|inbufs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|omapi_buffer_reference
argument_list|(
operator|&
name|c
operator|->
name|inbufs
argument_list|,
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_buffer_dereference
argument_list|(
operator|&
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_writer
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|)
block|{
name|unsigned
name|bytes_this_write
decl_stmt|;
name|int
name|bytes_written
decl_stmt|;
name|unsigned
name|first_byte
decl_stmt|;
name|omapi_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
decl_stmt|;
name|omapi_connection_object_t
modifier|*
name|c
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|type
operator|!=
name|omapi_type_connection
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|c
operator|=
operator|(
name|omapi_connection_object_t
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Already flushed... */
if|if
condition|(
operator|!
name|c
operator|->
name|out_bytes
condition|)
return|return
name|ISC_R_SUCCESS
return|;
name|buffer
operator|=
name|c
operator|->
name|outbufs
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|out_bytes
condition|)
block|{
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|ISC_R_UNEXPECTED
return|;
if|if
condition|(
name|BYTES_IN_BUFFER
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|buffer
operator|->
name|head
operator|==
operator|(
sizeof|sizeof
name|buffer
operator|->
name|buf
operator|)
operator|-
literal|1
condition|)
name|first_byte
operator|=
literal|0
expr_stmt|;
else|else
name|first_byte
operator|=
name|buffer
operator|->
name|head
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|first_byte
operator|>
name|buffer
operator|->
name|tail
condition|)
block|{
name|bytes_this_write
operator|=
operator|(
sizeof|sizeof
name|buffer
operator|->
name|buf
operator|-
name|first_byte
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bytes_this_write
operator|=
name|buffer
operator|->
name|tail
operator|-
name|first_byte
expr_stmt|;
block|}
name|bytes_written
operator|=
name|write
argument_list|(
name|c
operator|->
name|socket
argument_list|,
operator|&
name|buffer
operator|->
name|buf
index|[
name|first_byte
index|]
argument_list|,
name|bytes_this_write
argument_list|)
expr_stmt|;
comment|/* If the write failed with EWOULDBLOCK or we wrote 			   zero bytes, a further write would block, so we have 			   flushed as much as we can for now.   Other errors 			   are really errors. */
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
return|return
name|ISC_R_SUCCESS
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
return|return
name|ISC_R_NOCONN
return|;
ifdef|#
directive|ifdef
name|EDQUOT
elseif|else
if|if
condition|(
name|errno
operator|==
name|EFBIG
operator|||
name|errno
operator|==
name|EDQUOT
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|errno
operator|==
name|EFBIG
condition|)
endif|#
directive|endif
return|return
name|ISC_R_NORESOURCES
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
return|return
name|ISC_R_NOSPACE
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
return|return
name|ISC_R_IOERROR
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ECONNRESET
condition|)
return|return
name|ISC_R_SHUTTINGDOWN
return|;
else|else
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
if|if
condition|(
name|bytes_written
operator|==
literal|0
condition|)
return|return
name|ISC_R_SUCCESS
return|;
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
if|if
condition|(
name|trace_record
argument_list|()
condition|)
block|{
name|trace_iov_t
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|int32_t
name|connect_index
decl_stmt|;
name|connect_index
operator|=
name|htonl
argument_list|(
name|c
operator|->
name|index
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|connect_index
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|len
operator|=
sizeof|sizeof
name|connect_index
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|buf
operator|=
operator|&
name|buffer
operator|->
name|buf
index|[
name|buffer
operator|->
name|tail
index|]
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|len
operator|=
name|bytes_written
expr_stmt|;
name|status
operator|=
operator|(
name|trace_write_packet_iov
argument_list|(
name|trace_connection_input
argument_list|,
literal|2
argument_list|,
name|iov
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|trace_stop
argument_list|()
expr_stmt|;
name|log_error
argument_list|(
literal|"trace %s output: %s"
argument_list|,
literal|"connection"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|buffer
operator|->
name|head
operator|=
name|first_byte
operator|+
name|bytes_written
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|out_bytes
operator|-=
name|bytes_written
expr_stmt|;
comment|/* If we didn't finish out the write, we filled the 			   O.S. output buffer and a further write would block, 			   so stop trying to flush now. */
if|if
condition|(
name|bytes_written
operator|!=
name|bytes_this_write
condition|)
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
name|BYTES_IN_BUFFER
argument_list|(
name|buffer
argument_list|)
condition|)
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
comment|/* Get rid of any output buffers we emptied. */
name|buffer
operator|=
operator|(
name|omapi_buffer_t
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|outbufs
operator|&&
operator|!
name|BYTES_IN_BUFFER
argument_list|(
name|c
operator|->
name|outbufs
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|outbufs
operator|->
name|next
condition|)
block|{
name|omapi_buffer_reference
argument_list|(
operator|&
name|buffer
argument_list|,
name|c
operator|->
name|outbufs
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_buffer_dereference
argument_list|(
operator|&
name|c
operator|->
name|outbufs
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|omapi_buffer_dereference
argument_list|(
operator|&
name|c
operator|->
name|outbufs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|omapi_buffer_reference
argument_list|(
operator|&
name|c
operator|->
name|outbufs
argument_list|,
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|omapi_buffer_dereference
argument_list|(
operator|&
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_get_uint32
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|u_int32_t
modifier|*
name|result
parameter_list|)
block|{
name|u_int32_t
name|inbuf
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|omapi_connection_copyout
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|inbuf
argument_list|,
name|c
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
operator|*
name|result
operator|=
name|ntohl
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_put_uint32
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|u_int32_t
name|inbuf
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|inbuf
operator|=
name|htonl
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|omapi_connection_copyin
argument_list|(
name|c
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|inbuf
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_get_uint16
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|u_int16_t
modifier|*
name|result
parameter_list|)
block|{
name|u_int16_t
name|inbuf
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|omapi_connection_copyout
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|inbuf
argument_list|,
name|c
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
operator|*
name|result
operator|=
name|ntohs
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_put_uint16
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|u_int16_t
name|inbuf
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|inbuf
operator|=
name|htons
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|omapi_connection_copyin
argument_list|(
name|c
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|inbuf
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_write_typed_data
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|omapi_typed_data_t
modifier|*
name|data
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_handle_t
name|handle
decl_stmt|;
comment|/* Null data is valid. */
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
return|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|omapi_datatype_int
case|:
name|status
operator|=
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|data
operator|->
name|u
operator|.
name|integer
argument_list|)
operator|)
argument_list|)
return|;
case|case
name|omapi_datatype_string
case|:
case|case
name|omapi_datatype_data
case|:
name|status
operator|=
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
condition|)
return|return
name|omapi_connection_copyin
argument_list|(
name|c
argument_list|,
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
argument_list|)
return|;
return|return
name|ISC_R_SUCCESS
return|;
case|case
name|omapi_datatype_object
case|:
if|if
condition|(
name|data
operator|->
name|u
operator|.
name|object
condition|)
block|{
name|status
operator|=
name|omapi_object_handle
argument_list|(
operator|&
name|handle
argument_list|,
name|data
operator|->
name|u
operator|.
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
else|else
name|handle
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
sizeof|sizeof
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
name|handle
argument_list|)
return|;
block|}
return|return
name|ISC_R_INVALIDARG
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_put_name
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|status
operator|=
name|omapi_connection_put_uint16
argument_list|(
name|c
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|omapi_connection_copyin
argument_list|(
name|c
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_put_string
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|len
condition|)
return|return
name|omapi_connection_copyin
argument_list|(
name|c
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
argument_list|,
name|len
argument_list|)
return|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_connection_put_handle
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|omapi_object_t
modifier|*
name|h
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_handle_t
name|handle
decl_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|status
operator|=
name|omapi_object_handle
argument_list|(
operator|&
name|handle
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
else|else
name|handle
operator|=
literal|0
expr_stmt|;
comment|/* The null handle. */
name|status
operator|=
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
sizeof|sizeof
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|omapi_connection_put_uint32
argument_list|(
name|c
argument_list|,
name|handle
argument_list|)
return|;
block|}
end_function

end_unit

