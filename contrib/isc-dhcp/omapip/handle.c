begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* handle.c     Functions for maintaining handles on objects. */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1999-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software has been written for Internet Systems Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about Internet Systems Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_comment
comment|/* The handle table is a hierarchical tree designed for quick mapping    of handle identifiers to objects.  Objects contain their own handle    identifiers if they have them, so the reverse mapping is also    quick.  The hierarchy is made up of table objects, each of which    has 120 entries, a flag indicating whether the table is a leaf    table or an indirect table, the handle of the first object covered    by the table and the first object after that that's *not* covered    by the table, a count of how many objects of either type are    currently stored in the table, and an array of 120 entries pointing    either to objects or tables.     When we go to add an object to the table, we look to see if the    next object handle to be assigned is covered by the outermost    table.  If it is, we find the place within that table where the    next handle should go, and if necessary create additional nodes in    the tree to contain the new handle.  The pointer to the object is    then stored in the correct position.        Theoretically, we could have some code here to free up handle    tables as they go out of use, but by and large handle tables won't    go out of use, so this is being skipped for now.  It shouldn't be    too hard to implement in the future if there's a different    application. */
end_comment

begin_decl_stmt
name|omapi_handle_table_t
modifier|*
name|omapi_handle_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|omapi_handle_t
name|omapi_next_handle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next handle to be assigned. */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|omapi_handle_lookup_in
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
parameter_list|,
name|omapi_handle_t
parameter_list|,
name|omapi_handle_table_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|omapi_object_handle_in_table
parameter_list|(
name|omapi_handle_t
parameter_list|,
name|omapi_handle_table_t
modifier|*
parameter_list|,
name|omapi_object_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|omapi_handle_table_enclose
parameter_list|(
name|omapi_handle_table_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|isc_result_t
name|omapi_object_handle
parameter_list|(
name|omapi_handle_t
modifier|*
name|h
parameter_list|,
name|omapi_object_t
modifier|*
name|o
parameter_list|)
block|{
name|int
name|tabix
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|handle
condition|)
block|{
operator|*
name|h
operator|=
name|o
operator|->
name|handle
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
name|omapi_handle_table
condition|)
block|{
name|omapi_handle_table
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|omapi_handle_table
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|omapi_handle_table
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|omapi_handle_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|omapi_handle_table
argument_list|)
expr_stmt|;
name|omapi_handle_table
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|omapi_handle_table
operator|->
name|limit
operator|=
name|OMAPI_HANDLE_TABLE_SIZE
expr_stmt|;
name|omapi_handle_table
operator|->
name|leafp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this handle doesn't fit in the outer table, we need to 	   make a new outer table.  This is a while loop in case for 	   some reason we decide to do disjoint handle allocation, 	   where the next level of indirection still isn't big enough 	   to enclose the next handle ID. */
while|while
condition|(
name|omapi_next_handle
operator|>=
name|omapi_handle_table
operator|->
name|limit
condition|)
block|{
name|omapi_handle_table_t
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|limit
operator|=
operator|(
name|omapi_handle_table
operator|->
name|limit
operator|*
name|OMAPI_HANDLE_TABLE_SIZE
operator|)
expr_stmt|;
name|new
operator|->
name|leafp
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|children
index|[
literal|0
index|]
operator|.
name|table
operator|=
name|omapi_handle_table
expr_stmt|;
name|omapi_handle_table
operator|=
name|new
expr_stmt|;
block|}
comment|/* Try to cram this handle into the existing table. */
name|status
operator|=
name|omapi_object_handle_in_table
argument_list|(
name|omapi_next_handle
argument_list|,
name|omapi_handle_table
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* If it worked, return the next handle and increment it. */
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|h
operator|=
name|omapi_next_handle
expr_stmt|;
name|omapi_next_handle
operator|++
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
name|status
operator|!=
name|ISC_R_NOSPACE
condition|)
return|return
name|status
return|;
name|status
operator|=
name|omapi_handle_table_enclose
argument_list|(
operator|&
name|omapi_handle_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|status
operator|=
name|omapi_object_handle_in_table
argument_list|(
name|omapi_next_handle
argument_list|,
name|omapi_handle_table
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
operator|*
name|h
operator|=
name|omapi_next_handle
expr_stmt|;
name|omapi_next_handle
operator|++
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|omapi_object_handle_in_table
parameter_list|(
name|omapi_handle_t
name|h
parameter_list|,
name|omapi_handle_table_t
modifier|*
name|table
parameter_list|,
name|omapi_object_t
modifier|*
name|o
parameter_list|)
block|{
name|omapi_handle_table_t
modifier|*
name|inner
decl_stmt|;
name|omapi_handle_t
name|scale
decl_stmt|,
name|index
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|first
operator|>
name|h
operator|||
name|table
operator|->
name|limit
operator|<=
name|h
condition|)
return|return
name|ISC_R_NOSPACE
return|;
comment|/* If this is a leaf table, just stash the object in the 	   appropriate place. */
if|if
condition|(
name|table
operator|->
name|leafp
condition|)
block|{
name|status
operator|=
operator|(
name|omapi_object_reference
argument_list|(
operator|&
name|table
operator|->
name|children
index|[
name|h
operator|-
name|table
operator|->
name|first
index|]
operator|.
name|object
argument_list|,
name|o
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|o
operator|->
name|handle
operator|=
name|h
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
comment|/* Scale is the number of handles represented by each child of this 	   table.   For a leaf table, scale would be 1.   For a first level 	   of indirection, 120.   For a second, 120 * 120.   Et cetera. */
name|scale
operator|=
operator|(
name|table
operator|->
name|limit
operator|-
name|table
operator|->
name|first
operator|)
operator|/
name|OMAPI_HANDLE_TABLE_SIZE
expr_stmt|;
comment|/* So the next most direct table from this one that contains the 	   handle must be the subtable of this table whose index into this 	   table's array of children is the handle divided by the scale. */
name|index
operator|=
operator|(
name|h
operator|-
name|table
operator|->
name|first
operator|)
operator|/
name|scale
expr_stmt|;
name|inner
operator|=
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
expr_stmt|;
comment|/* If there is no more direct table than this one in the slot 	   we came up with, make one. */
if|if
condition|(
operator|!
name|inner
condition|)
block|{
name|inner
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|inner
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inner
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|inner
argument_list|)
expr_stmt|;
name|inner
operator|->
name|first
operator|=
name|index
operator|*
name|scale
operator|+
name|table
operator|->
name|first
expr_stmt|;
name|inner
operator|->
name|limit
operator|=
name|inner
operator|->
name|first
operator|+
name|scale
expr_stmt|;
if|if
condition|(
name|scale
operator|==
name|OMAPI_HANDLE_TABLE_SIZE
condition|)
name|inner
operator|->
name|leafp
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
operator|=
name|inner
expr_stmt|;
block|}
name|status
operator|=
name|omapi_object_handle_in_table
argument_list|(
name|h
argument_list|,
name|inner
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|status
operator|=
operator|(
name|omapi_handle_table_enclose
argument_list|(
operator|&
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
return|return
name|omapi_object_handle_in_table
argument_list|(
name|h
argument_list|,
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
argument_list|,
name|o
argument_list|)
return|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|omapi_handle_table_enclose
parameter_list|(
name|omapi_handle_table_t
modifier|*
modifier|*
name|table
parameter_list|)
block|{
name|omapi_handle_table_t
modifier|*
name|inner
init|=
operator|*
name|table
decl_stmt|;
name|omapi_handle_table_t
modifier|*
name|new
decl_stmt|;
name|int
name|index
decl_stmt|,
name|base
decl_stmt|,
name|scale
decl_stmt|;
comment|/* The scale of the table we're enclosing is going to be the 	   difference between its "first" and "limit" members.  So the 	   scale of the table enclosing it is going to be that multiplied 	   by the table size. */
name|scale
operator|=
operator|(
name|inner
operator|->
name|first
operator|-
name|inner
operator|->
name|limit
operator|)
operator|*
name|OMAPI_HANDLE_TABLE_SIZE
expr_stmt|;
comment|/* The range that the enclosing table covers is going to be 	   the result of subtracting the remainder of dividing the 	   enclosed table's first entry number by the enclosing 	   table's scale.  If handle IDs are being allocated 	   sequentially, the enclosing table's "first" value will be 	   the same as the enclosed table's "first" value. */
name|base
operator|=
name|inner
operator|->
name|first
operator|-
name|inner
operator|->
name|first
operator|%
name|scale
expr_stmt|;
comment|/* The index into the enclosing table at which the enclosed table 	   will be stored is going to be the difference between the "first" 	   value of the enclosing table and the enclosed table - zero, if 	   we are allocating sequentially. */
name|index
operator|=
operator|(
name|base
operator|-
name|inner
operator|->
name|first
operator|)
operator|/
name|OMAPI_HANDLE_TABLE_SIZE
expr_stmt|;
name|new
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|first
operator|=
name|base
expr_stmt|;
name|new
operator|->
name|limit
operator|=
name|base
operator|+
name|scale
expr_stmt|;
if|if
condition|(
name|scale
operator|==
name|OMAPI_HANDLE_TABLE_SIZE
condition|)
name|new
operator|->
name|leafp
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
operator|=
name|inner
expr_stmt|;
operator|*
name|table
operator|=
name|new
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_handle_lookup
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|o
parameter_list|,
name|omapi_handle_t
name|h
parameter_list|)
block|{
return|return
name|omapi_handle_lookup_in
argument_list|(
name|o
argument_list|,
name|h
argument_list|,
name|omapi_handle_table
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|omapi_handle_lookup_in
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|o
parameter_list|,
name|omapi_handle_t
name|h
parameter_list|,
name|omapi_handle_table_t
modifier|*
name|table
parameter_list|)
block|{
name|omapi_handle_table_t
modifier|*
name|inner
decl_stmt|;
name|omapi_handle_t
name|scale
decl_stmt|,
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|table
operator|||
name|table
operator|->
name|first
operator|>
name|h
operator|||
name|table
operator|->
name|limit
operator|<=
name|h
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
comment|/* If this is a leaf table, just grab the object. */
if|if
condition|(
name|table
operator|->
name|leafp
condition|)
block|{
comment|/* Not there? */
if|if
condition|(
operator|!
name|table
operator|->
name|children
index|[
name|h
operator|-
name|table
operator|->
name|first
index|]
operator|.
name|object
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
return|return
name|omapi_object_reference
argument_list|(
name|o
argument_list|,
name|table
operator|->
name|children
index|[
name|h
operator|-
name|table
operator|->
name|first
index|]
operator|.
name|object
argument_list|,
name|MDL
argument_list|)
return|;
block|}
comment|/* Scale is the number of handles represented by each child of this 	   table.   For a leaf table, scale would be 1.   For a first level 	   of indirection, 120.   For a second, 120 * 120.   Et cetera. */
name|scale
operator|=
operator|(
name|table
operator|->
name|limit
operator|-
name|table
operator|->
name|first
operator|)
operator|/
name|OMAPI_HANDLE_TABLE_SIZE
expr_stmt|;
comment|/* So the next most direct table from this one that contains the 	   handle must be the subtable of this table whose index into this 	   table's array of children is the handle divided by the scale. */
name|index
operator|=
operator|(
name|h
operator|-
name|table
operator|->
name|first
operator|)
operator|/
name|scale
expr_stmt|;
name|inner
operator|=
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
expr_stmt|;
return|return
name|omapi_handle_lookup_in
argument_list|(
name|o
argument_list|,
name|h
argument_list|,
name|table
operator|->
name|children
index|[
name|index
index|]
operator|.
name|table
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For looking up objects based on handles that have been sent on the wire. */
end_comment

begin_function
name|isc_result_t
name|omapi_handle_td_lookup
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|obj
parameter_list|,
name|omapi_typed_data_t
modifier|*
name|handle
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_handle_t
name|h
decl_stmt|;
if|if
condition|(
name|handle
operator|->
name|type
operator|==
name|omapi_datatype_int
condition|)
name|h
operator|=
name|handle
operator|->
name|u
operator|.
name|integer
expr_stmt|;
elseif|else
if|if
condition|(
name|handle
operator|->
name|type
operator|==
name|omapi_datatype_data
operator|&&
name|handle
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|==
sizeof|sizeof
name|h
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|h
argument_list|,
name|handle
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
sizeof|sizeof
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|ntohl
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|ISC_R_INVALIDARG
return|;
return|return
name|omapi_handle_lookup
argument_list|(
name|obj
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function

end_unit

