begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* listener.c     Subroutines that support the omapi extensible array type. */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 2001-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software has been written for Internet Systems Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about Internet Systems Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_comment
comment|/* Allocate a new extensible array. */
end_comment

begin_function
name|isc_result_t
name|omapi_array_allocate
parameter_list|(
name|omapi_array_t
modifier|*
modifier|*
name|array
parameter_list|,
name|omapi_array_ref_t
name|ref
parameter_list|,
name|omapi_array_deref_t
name|deref
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_array_t
modifier|*
name|aptr
decl_stmt|;
if|if
condition|(
operator|!
name|array
operator|||
operator|*
name|array
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|aptr
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|omapi_array_t
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aptr
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
operator|*
name|array
operator|=
name|aptr
expr_stmt|;
name|aptr
operator|->
name|ref
operator|=
name|ref
expr_stmt|;
name|aptr
operator|->
name|deref
operator|=
name|deref
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_array_free
parameter_list|(
name|omapi_array_t
modifier|*
modifier|*
name|array
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|omapi_array_t
modifier|*
name|aptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|array
operator|||
operator|!
operator|*
name|array
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|aptr
operator|=
operator|*
name|array
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aptr
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|aptr
operator|->
name|data
index|[
name|i
index|]
operator|&&
name|aptr
operator|->
name|deref
condition|)
call|(
modifier|*
name|aptr
operator|->
name|deref
call|)
argument_list|(
operator|&
name|aptr
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|aptr
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|aptr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|array
operator|=
operator|(
name|omapi_array_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Extend the size of the array by one entry (we may allocate more than that)    and store the specified value in the new array element. */
end_comment

begin_function
name|isc_result_t
name|omapi_array_extend
parameter_list|(
name|omapi_array_t
modifier|*
name|array
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|int
name|new
init|=
name|array
operator|->
name|count
decl_stmt|;
name|status
operator|=
name|omapi_array_set
argument_list|(
name|array
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|&&
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
operator|*
name|index
operator|=
name|new
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Set a value in the specified array, extending it if necessary. */
end_comment

begin_function
name|isc_result_t
name|omapi_array_set
parameter_list|(
name|omapi_array_t
modifier|*
name|array
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|newbuf
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|array
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* If the proposed index is larger than the current available 	   space in the array, make more space in the array. */
if|if
condition|(
name|array
operator|->
name|max
operator|<=
name|index
condition|)
block|{
name|delta
operator|=
name|index
operator|-
name|array
operator|->
name|max
operator|+
literal|10
expr_stmt|;
name|newbuf
operator|=
name|dmalloc
argument_list|(
operator|(
name|array
operator|->
name|max
operator|+
name|delta
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newbuf
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
comment|/* Zero the new elements. */
name|memset
argument_list|(
operator|&
name|newbuf
index|[
name|array
operator|->
name|max
index|]
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|array
operator|->
name|max
operator|+=
name|delta
expr_stmt|;
comment|/* Copy the old array data into the new buffer. */
if|if
condition|(
name|array
operator|->
name|data
condition|)
block|{
name|memcpy
argument_list|(
name|newbuf
argument_list|,
name|array
operator|->
name|data
argument_list|,
name|array
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|array
operator|->
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|array
operator|->
name|data
operator|=
name|newbuf
expr_stmt|;
block|}
else|else
block|{
comment|/* If there's already data there, and this is an array 		   of references, dereference what's there. */
if|if
condition|(
name|array
operator|->
name|data
index|[
name|index
index|]
condition|)
block|{
name|status
operator|=
operator|(
call|(
modifier|*
name|array
operator|->
name|deref
call|)
argument_list|(
operator|&
name|array
operator|->
name|data
index|[
name|index
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
block|}
comment|/* Store the pointer using the referencer function.  We have 	   either just memset this to zero or dereferenced what was 	   there previously, so there is no need to do anything if the 	   pointer we have been asked to store is null. */
if|if
condition|(
name|ptr
condition|)
block|{
name|status
operator|=
call|(
modifier|*
name|array
operator|->
name|ref
call|)
argument_list|(
operator|&
name|array
operator|->
name|data
index|[
name|index
index|]
argument_list|,
name|ptr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|index
operator|>=
name|array
operator|->
name|count
condition|)
name|array
operator|->
name|count
operator|=
name|index
operator|+
literal|1
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|omapi_array_lookup
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|omapi_array_t
modifier|*
name|array
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|array
operator|||
operator|!
name|ptr
operator|||
operator|*
name|ptr
operator|||
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|array
operator|->
name|count
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
name|array
operator|->
name|data
index|[
name|index
index|]
condition|)
return|return
call|(
modifier|*
name|array
operator|->
name|ref
call|)
argument_list|(
name|ptr
argument_list|,
name|array
operator|->
name|data
index|[
name|index
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_expr_stmt
name|OMAPI_ARRAY_TYPE_DECL
argument_list|(
name|omapi_object
argument_list|,
name|omapi_object_t
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

