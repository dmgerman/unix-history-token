begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* clparse.c     Parser for dhclient config and lease files... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996-2002 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: clparse.c,v 1.62.2.3 2002/11/17 02:25:43 dhankins Exp $ Copyright (c) 1996-2002 The Internet Software Consortium.  All rights reserved.\n"
literal|"$FreeBSD$\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
specifier|static
name|TIME
name|parsed_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|client_config
name|top_level_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|client_script_name
index|[]
init|=
name|_PATH_DHCLIENT_SCRIPT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|default_requested_options
index|[]
init|=
block|{
name|DHO_SUBNET_MASK
block|,
name|DHO_BROADCAST_ADDRESS
block|,
name|DHO_TIME_OFFSET
block|,
name|DHO_ROUTERS
block|,
name|DHO_DOMAIN_NAME
block|,
name|DHO_DOMAIN_NAME_SERVERS
block|,
name|DHO_HOST_NAME
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client-conf-file :== client-declarations END_OF_FILE    client-declarations :==<nil> 			 | client-declaration 			 | client-declarations client-declaration */
end_comment

begin_function
name|isc_result_t
name|read_client_conf
parameter_list|()
block|{
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
name|struct
name|client_state
modifier|*
name|state
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
comment|/* Set up the initial dhcp option universe. */
name|initialize_common_option_spaces
argument_list|()
expr_stmt|;
comment|/* Initialize the top level client configuration. */
name|memset
argument_list|(
operator|&
name|top_level_config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|top_level_config
argument_list|)
expr_stmt|;
comment|/* Set some defaults... */
name|top_level_config
operator|.
name|timeout
operator|=
literal|60
expr_stmt|;
name|top_level_config
operator|.
name|select_interval
operator|=
literal|0
expr_stmt|;
name|top_level_config
operator|.
name|reboot_timeout
operator|=
literal|10
expr_stmt|;
name|top_level_config
operator|.
name|retry_interval
operator|=
literal|300
expr_stmt|;
name|top_level_config
operator|.
name|backoff_cutoff
operator|=
literal|15
expr_stmt|;
name|top_level_config
operator|.
name|initial_interval
operator|=
literal|3
expr_stmt|;
name|top_level_config
operator|.
name|bootp_policy
operator|=
name|P_ACCEPT
expr_stmt|;
name|top_level_config
operator|.
name|script_name
operator|=
name|path_dhclient_script
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
operator|=
name|default_requested_options
expr_stmt|;
name|top_level_config
operator|.
name|omapi_port
operator|=
operator|-
literal|1
expr_stmt|;
name|top_level_config
operator|.
name|do_forward_update
operator|=
literal|1
expr_stmt|;
name|group_allocate
argument_list|(
operator|&
name|top_level_config
operator|.
name|on_receipt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top_level_config
operator|.
name|on_receipt
condition|)
name|log_fatal
argument_list|(
literal|"no memory for top-level on_receipt group"
argument_list|)
expr_stmt|;
name|group_allocate
argument_list|(
operator|&
name|top_level_config
operator|.
name|on_transmission
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top_level_config
operator|.
name|on_transmission
condition|)
name|log_fatal
argument_list|(
literal|"no memory for top-level on_transmission group"
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_client_conf_file
argument_list|(
name|path_dhclient_conf
argument_list|,
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|top_level_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
empty_stmt|;
ifdef|#
directive|ifdef
name|LATER
comment|/* Set up the standard name service updater routine. */
name|parse
operator|=
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|new_parse
argument_list|(
operator|&
name|parse
argument_list|,
operator|-
literal|1
argument_list|,
name|default_client_config
argument_list|,
operator|(
sizeof|sizeof
name|default_client_config
operator|)
operator|-
literal|1
argument_list|,
literal|"default client configuration"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"can't begin default client config!"
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|top_level_config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|end_parse
argument_list|(
operator|&
name|parse
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set up state and config structures for clients that don't 	   have per-interface configuration statements. */
name|config
operator|=
operator|(
expr|struct
name|client_config
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
block|{
name|ip
operator|->
name|client
operator|=
operator|(
expr|struct
name|client_state
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_state
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|log_fatal
argument_list|(
literal|"no memory for client state."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interface
operator|=
name|ip
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
block|{
if|if
condition|(
operator|!
name|config
condition|)
block|{
name|config
operator|=
operator|(
expr|struct
name|client_config
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
name|log_fatal
argument_list|(
literal|"no memory for client config."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|config
argument_list|,
operator|&
name|top_level_config
argument_list|,
sizeof|sizeof
name|top_level_config
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|client
operator|->
name|config
operator|=
name|config
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|read_client_conf_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_config
modifier|*
name|client
parameter_list|)
block|{
name|int
name|file
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|uerr2isc
argument_list|(
name|errno
argument_list|)
return|;
name|cfile
operator|=
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
expr_stmt|;
name|new_parse
argument_list|(
operator|&
name|cfile
argument_list|,
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|path_dhclient_conf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
name|ip
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|cfile
operator|->
name|warnings_occurred
condition|?
name|ISC_R_BADPARSE
else|:
name|ISC_R_SUCCESS
operator|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|end_parse
argument_list|(
operator|&
name|cfile
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* lease-file :== client-lease-statements END_OF_FILE    client-lease-statements :==<nil> 		     | client-lease-statements LEASE client-lease-statement */
end_comment

begin_function
name|void
name|read_client_leases
parameter_list|()
block|{
name|int
name|file
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
comment|/* Open the lease file.   If we can't open it, just return - 	   we can safely trust the server to remember our state. */
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|path_dhclient_db
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|cfile
operator|=
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
expr_stmt|;
name|new_parse
argument_list|(
operator|&
name|cfile
argument_list|,
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|path_dhclient_db
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|LEASE
condition|)
block|{
name|log_error
argument_list|(
literal|"Corrupt lease file - possible data loss!"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|end_parse
argument_list|(
operator|&
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* client-declaration :==  	SEND option-decl | 	DEFAULT option-decl | 	SUPERSEDE option-decl | 	PREPEND option-decl | 	APPEND option-decl | 	hardware-declaration | 	REQUEST option-list | 	REQUIRE option-list | 	TIMEOUT number | 	RETRY number | 	REBOOT number | 	SELECT_TIMEOUT number | 	SCRIPT string | 	VENDOR_SPACE string | 	interface-declaration | 	LEASE client-lease-statement | 	ALIAS client-lease-statement | 	KEY key-definition */
end_comment

begin_function
name|void
name|parse_client_statement
parameter_list|(
name|cfile
parameter_list|,
name|ip
parameter_list|,
name|config
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|stmt
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|enum
name|statement_op
name|op
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|data_string
name|key_id
decl_stmt|;
name|enum
name|policy
name|policy
decl_stmt|;
name|int
name|known
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
switch|switch
condition|(
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|INCLUDE
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"filename string expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|read_client_conf_file
argument_list|(
name|val
argument_list|,
name|ip
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s: bad parse."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|KEY
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
comment|/* This may seem arbitrary, but there's a reason for 			   doing it: the authentication key database is not 			   scoped.  If we allow the user to declare a key other 			   than in the outer scope, the user is very likely to 			   believe that the key will only be used in that 			   scope.  If the user only wants the key to be used on 			   one interface, because it's known that the other 			   interface may be connected to an insecure net and 			   the secret key is considered sensitive, we don't 			   want to lull them into believing they've gotten 			   their way.   This is a bit contrived, but people 			   tend not to be entirely rational about security. */
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"key definition not allowed here."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|parse_key
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
comment|/* REQUIRE can either start a policy statement or a 		   comma-seperated list of names of required options. */
case|case
name|REQUIRE
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|AUTHENTICATION
condition|)
block|{
name|policy
operator|=
name|P_REQUIRE
expr_stmt|;
goto|goto
name|do_policy
goto|;
block|}
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|required_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGNORE
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|policy
operator|=
name|P_IGNORE
expr_stmt|;
goto|goto
name|do_policy
goto|;
case|case
name|ACCEPT
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|policy
operator|=
name|P_ACCEPT
expr_stmt|;
goto|goto
name|do_policy
goto|;
case|case
name|PREFER
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|policy
operator|=
name|P_PREFER
expr_stmt|;
goto|goto
name|do_policy
goto|;
case|case
name|DONT
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|policy
operator|=
name|P_DONT
expr_stmt|;
goto|goto
name|do_policy
goto|;
name|do_policy
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|AUTHENTICATION
condition|)
block|{
if|if
condition|(
name|policy
operator|!=
name|P_PREFER
operator|&&
name|policy
operator|!=
name|P_REQUIRE
operator|&&
name|policy
operator|!=
name|P_DONT
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid authentication policy."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|config
operator|->
name|auth_policy
operator|=
name|policy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|TOKEN_BOOTP
condition|)
block|{
if|if
condition|(
name|policy
operator|!=
name|P_PREFER
operator|&&
name|policy
operator|!=
name|P_IGNORE
operator|&&
name|policy
operator|!=
name|P_ACCEPT
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid bootp policy."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|config
operator|->
name|bootp_policy
operator|=
name|policy
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a policy type."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|OPTION
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|SPACE
condition|)
block|{
if|if
condition|(
name|ip
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"option space definitions %s"
argument_list|,
literal|" may not be scoped."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|parse_option_space_decl
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
return|return;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CODE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting \"code\" keyword."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|free_option
argument_list|(
name|option
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ip
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"option definitions may only appear in %s"
argument_list|,
literal|"the outermost scope."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|free_option
argument_list|(
name|option
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|parse_option_code_definition
argument_list|(
name|cfile
argument_list|,
name|option
argument_list|)
condition|)
name|free_option
argument_list|(
name|option
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEDIA
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|media
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|HARDWARE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|parse_hardware_param
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip
operator|->
name|hw_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"hardware address parameter %s"
argument_list|,
literal|"not allowed here."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REQUEST
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|requested_options
operator|==
name|default_requested_options
condition|)
name|config
operator|->
name|requested_options
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
literal|0
expr_stmt|;
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|requested_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|TIMEOUT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|RETRY
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|retry_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT_TIMEOUT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|select_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|OMAPI
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|PORT
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unexpected omapi subtype: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid port number: `%s'"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
operator|||
name|tmp
operator|>
literal|65535
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid omapi port %d."
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|config
operator|!=
operator|&
name|top_level_config
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"omapi port only works at top level."
argument_list|)
expr_stmt|;
else|else
name|config
operator|->
name|omapi_port
operator|=
name|tmp
expr_stmt|;
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|DO_FORWARD_UPDATE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"on"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
condition|)
name|config
operator|->
name|do_forward_update
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"false"
argument_list|)
condition|)
name|config
operator|->
name|do_forward_update
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting boolean value."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBOOT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|reboot_timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|BACKOFF_CUTOFF
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|backoff_cutoff
argument_list|)
expr_stmt|;
return|return;
case|case
name|INITIAL_INTERVAL
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|initial_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCRIPT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_string
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|script_name
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|VENDOR
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|OPTION
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting 'vendor option space'"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SPACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting 'vendor option space'"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting an identifier."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|config
operator|->
name|vendor_space_name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|->
name|vendor_space_name
condition|)
name|log_fatal
argument_list|(
literal|"no memory for vendor option space name."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|config
operator|->
name|vendor_space_name
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|universe_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|universes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|config
operator|->
name|vendor_space_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|universe_count
condition|)
block|{
name|log_error
argument_list|(
literal|"vendor option space %s not found."
argument_list|,
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
block|}
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTERFACE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"nested interface declaration."
argument_list|)
expr_stmt|;
name|parse_interface_declaration
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|PSEUDO
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|log_fatal
argument_list|(
literal|"no memory for pseudo interface name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|parse_interface_declaration
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEASE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ALIAS
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|REJECT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_reject_statement
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return;
default|default:
name|lose
operator|=
literal|0
expr_stmt|;
name|stmt
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_executable_statement
argument_list|(
operator|&
name|stmt
argument_list|,
name|cfile
argument_list|,
operator|&
name|lose
argument_list|,
name|context_any
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a statement."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|executable_statement
modifier|*
modifier|*
name|eptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|;
if|if
condition|(
name|stmt
operator|&&
operator|(
name|stmt
operator|->
name|op
operator|==
name|send_option_statement
operator|||
operator|(
name|stmt
operator|->
name|op
operator|==
name|on_statement
operator|&&
operator|(
name|stmt
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_TRANSMISSION
operator|)
operator|)
operator|)
condition|)
block|{
name|eptr
operator|=
operator|&
name|config
operator|->
name|on_transmission
operator|->
name|statements
expr_stmt|;
if|if
condition|(
name|stmt
operator|->
name|op
operator|==
name|on_statement
condition|)
block|{
name|sptr
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
name|executable_statement_reference
argument_list|(
operator|&
name|sptr
argument_list|,
name|stmt
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
operator|&
name|stmt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|executable_statement_reference
argument_list|(
operator|&
name|stmt
argument_list|,
name|sptr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
operator|&
name|sptr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|eptr
operator|=
operator|&
name|config
operator|->
name|on_receipt
operator|->
name|statements
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
block|{
for|for
control|(
init|;
operator|*
name|eptr
condition|;
name|eptr
operator|=
operator|&
operator|(
operator|*
name|eptr
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|executable_statement_reference
argument_list|(
name|eptr
argument_list|,
name|stmt
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* option-list :== option_name |    		   option_list COMMA option_name */
end_comment

begin_function
name|void
name|parse_option_list
parameter_list|(
name|cfile
parameter_list|,
name|list
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|u_int32_t
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|ix
decl_stmt|,
name|i
decl_stmt|;
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|pair
name|p
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|,
name|q
decl_stmt|,
name|r
decl_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|SEMI
condition|)
break|break;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s: expected option name."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|256
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s: expected option name."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_pair
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate pair for option code."
argument_list|)
expr_stmt|;
name|r
operator|->
name|car
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|i
expr_stmt|;
name|r
operator|->
name|cdr
operator|=
operator|(
name|pair
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|q
operator|->
name|cdr
operator|=
name|r
expr_stmt|;
else|else
name|p
operator|=
name|r
expr_stmt|;
name|q
operator|=
name|r
expr_stmt|;
operator|++
name|ix
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX we can't free the list here, because we may have copied 	   XXX it from an outer config state. */
operator|*
name|list
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|ix
condition|)
block|{
operator|*
name|list
operator|=
name|dmalloc
argument_list|(
operator|(
name|ix
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
operator|*
name|list
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|list
condition|)
name|log_error
argument_list|(
literal|"no memory for option list."
argument_list|)
expr_stmt|;
else|else
block|{
name|ix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|cdr
control|)
operator|(
operator|*
name|list
operator|)
index|[
name|ix
operator|++
index|]
operator|=
operator|(
name|u_int32_t
operator|)
operator|(
name|long
operator|)
name|q
operator|->
name|car
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
name|ix
index|]
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|cdr
expr_stmt|;
name|free_pair
argument_list|(
name|p
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* interface-declaration :==    	INTERFACE string LBRACE client-declarations RBRACE */
end_comment

begin_function
name|void
name|parse_interface_declaration
parameter_list|(
name|cfile
parameter_list|,
name|outer_config
parameter_list|,
name|name
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_config
modifier|*
name|outer_config
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|,
modifier|*
modifier|*
name|cp
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|interface_or_dummy
argument_list|(
operator|&
name|ip
argument_list|,
name|val
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate interface %s."
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* If we were given a name, this is a pseudo-interface. */
if|if
condition|(
name|name
condition|)
block|{
name|make_client_state
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|client
operator|->
name|interface
operator|=
name|ip
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|ip
operator|->
name|client
init|;
operator|*
name|cp
condition|;
name|cp
operator|=
operator|&
operator|(
operator|(
operator|*
name|cp
operator|)
operator|->
name|next
operator|)
control|)
empty_stmt|;
operator|*
name|cp
operator|=
name|client
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
block|{
name|make_client_state
argument_list|(
operator|&
name|ip
operator|->
name|client
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interface
operator|=
name|ip
expr_stmt|;
block|}
name|client
operator|=
name|ip
operator|->
name|client
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|client
operator|->
name|config
condition|)
name|make_client_config
argument_list|(
name|client
argument_list|,
name|outer_config
argument_list|)
expr_stmt|;
name|ip
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_AUTOMATIC
expr_stmt|;
name|interfaces_requested
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unterminated interface declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
name|ip
argument_list|,
name|client
operator|->
name|config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|interface_or_dummy
parameter_list|(
name|struct
name|interface_info
modifier|*
modifier|*
name|pi
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|i
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
comment|/* Find the interface (if any) that matches the name. */
for|for
control|(
name|i
operator|=
name|interfaces
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|ip
argument_list|,
name|i
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If it's not a real interface, see if it's on the dummy list. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|ip
argument_list|,
name|i
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we didn't find an interface, make a dummy interface as 	   a placeholder. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't record interface %s: %s"
argument_list|,
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|ip
operator|->
name|next
argument_list|,
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
condition|)
name|status
operator|=
name|interface_reference
argument_list|(
name|pi
argument_list|,
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|make_client_state
parameter_list|(
name|state
parameter_list|)
name|struct
name|client_state
modifier|*
modifier|*
name|state
decl_stmt|;
block|{
operator|*
name|state
operator|=
operator|(
operator|(
expr|struct
name|client_state
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|state
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|state
condition|)
name|log_fatal
argument_list|(
literal|"no memory for client state\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_client_config
parameter_list|(
name|client
parameter_list|,
name|config
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|client
operator|->
name|config
operator|=
operator|(
operator|(
operator|(
expr|struct
name|client_config
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|,
name|MDL
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|config
condition|)
name|log_fatal
argument_list|(
literal|"no memory for client config\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|client
operator|->
name|config
argument_list|,
name|config
argument_list|,
sizeof|sizeof
expr|*
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clone_group
argument_list|(
operator|&
name|client
operator|->
name|config
operator|->
name|on_receipt
argument_list|,
name|config
operator|->
name|on_receipt
argument_list|,
name|MDL
argument_list|)
operator|||
operator|!
name|clone_group
argument_list|(
operator|&
name|client
operator|->
name|config
operator|->
name|on_transmission
argument_list|,
name|config
operator|->
name|on_transmission
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for client state groups."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* client-lease-statement :== 	RBRACE client-lease-declarations LBRACE  	client-lease-declarations :==<nil> | 		client-lease-declaration | 		client-lease-declarations client-lease-declaration */
end_comment

begin_function
name|void
name|parse_client_lease_statement
parameter_list|(
name|cfile
parameter_list|,
name|is_static
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|is_static
decl_stmt|;
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
init|=
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|lease
operator|=
operator|(
operator|(
expr|struct
name|client_lease
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
name|log_fatal
argument_list|(
literal|"no memory for lease.\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|->
name|is_static
operator|=
name|is_static
expr_stmt|;
if|if
condition|(
operator|!
name|option_state_allocate
argument_list|(
operator|&
name|lease
operator|->
name|options
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for lease options.\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unterminated lease declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_lease_declaration
argument_list|(
name|cfile
argument_list|,
name|lease
argument_list|,
operator|&
name|ip
argument_list|,
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* If the lease declaration didn't include an interface 	   declaration that we recognized, it's of no use to us. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|destroy_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure there's a client state structure... */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
block|{
name|make_client_state
argument_list|(
operator|&
name|ip
operator|->
name|client
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interface
operator|=
name|ip
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|client
condition|)
name|client
operator|=
name|ip
operator|->
name|client
expr_stmt|;
comment|/* If this is an alias lease, it doesn't need to be sorted in. */
if|if
condition|(
name|is_static
operator|==
literal|2
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|alias
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* The new lease may supersede a lease that's not the 	   active lease but is still on the lease list, so scan the 	   lease list looking for a lease with the same address, and 	   if we find it, toss it. */
name|pl
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lp
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|pl
condition|)
name|pl
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
else|else
name|client
operator|->
name|leases
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|destroy_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is a preloaded lease, just put it on the list of recorded 	   leases - don't make it the active lease. */
if|if
condition|(
name|is_static
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|client
operator|->
name|leases
expr_stmt|;
name|client
operator|->
name|leases
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* The last lease in the lease file on a particular interface is 	   the active lease for that interface.    Of course, we don't know 	   what the last lease in the file is until we've parsed the whole 	   file, so at this point, we assume that the lease we just parsed 	   is the active lease for its interface.   If there's already 	   an active lease for the interface, and this lease is for the same 	   ip address, then we just toss the old active lease and replace 	   it with this one.   If this lease is for a different address, 	   then if the old active lease has expired, we dump it; if not, 	   we put it on the list of leases for this interface which are 	   still valid but no longer active. */
if|if
condition|(
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|active
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|destroy_client_lease
argument_list|(
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
name|destroy_client_lease
argument_list|(
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
else|else
block|{
name|client
operator|->
name|active
operator|->
name|next
operator|=
name|client
operator|->
name|leases
expr_stmt|;
name|client
operator|->
name|leases
operator|=
name|client
operator|->
name|active
expr_stmt|;
block|}
block|}
name|client
operator|->
name|active
operator|=
name|lease
expr_stmt|;
comment|/* phew. */
block|}
end_function

begin_comment
comment|/* client-lease-declaration :== 	BOOTP | 	INTERFACE string | 	FIXED_ADDR ip_address | 	FILENAME string | 	SERVER_NAME string | 	OPTION option-decl | 	RENEW time-decl | 	REBIND time-decl | 	EXPIRE time-decl | 	KEY id */
end_comment

begin_function
name|void
name|parse_client_lease_declaration
parameter_list|(
name|cfile
parameter_list|,
name|lease
parameter_list|,
name|ipp
parameter_list|,
name|clientp
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|interface_info
modifier|*
modifier|*
name|ipp
decl_stmt|;
name|struct
name|client_state
modifier|*
modifier|*
name|clientp
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
init|=
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|data_string
name|key_id
decl_stmt|;
switch|switch
condition|(
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|KEY
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|&&
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting key name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|omapi_auth_key_lookup_name
argument_list|(
operator|&
name|lease
operator|->
name|key
argument_list|,
name|val
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown key %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOKEN_BOOTP
case|:
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|INTERFACE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|interface_or_dummy
argument_list|(
name|ipp
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|*
name|ipp
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"state name precedes interface."
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
if|if
condition|(
name|client
operator|->
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|client
operator|->
name|name
argument_list|,
name|val
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|client
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"lease specified for unknown pseudo."
argument_list|)
expr_stmt|;
operator|*
name|clientp
operator|=
name|client
expr_stmt|;
break|break;
case|case
name|FIXED_ADDR
case|:
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|address
argument_list|)
condition|)
return|return;
break|break;
case|case
name|MEDIUM
case|:
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|medium
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|FILENAME
case|:
name|parse_string
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|filename
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERVER_NAME
case|:
name|parse_string
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|server_name
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|RENEW
case|:
name|lease
operator|->
name|renewal
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBIND
case|:
name|lease
operator|->
name|rebind
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPIRE
case|:
name|lease
operator|->
name|expiry
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPTION
case|:
name|oc
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|parse_option_decl
argument_list|(
operator|&
name|oc
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
name|save_option
argument_list|(
name|oc
operator|->
name|option
operator|->
name|universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting lease declaration."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_string_list
parameter_list|(
name|cfile
parameter_list|,
name|lp
parameter_list|,
name|multiple
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|string_list
modifier|*
modifier|*
name|lp
decl_stmt|;
name|int
name|multiple
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|string_list
modifier|*
name|cur
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Find the last medium in the media list. */
if|if
condition|(
operator|*
name|lp
condition|)
block|{
for|for
control|(
name|cur
operator|=
operator|*
name|lp
init|;
name|cur
operator|->
name|next
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
empty_stmt|;
block|}
else|else
block|{
name|cur
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
block|}
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting media options."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|log_fatal
argument_list|(
literal|"no memory for string list entry."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|string
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Store this medium at the end of the media list. */
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|tmp
expr_stmt|;
name|cur
operator|=
name|tmp
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|multiple
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_reject_statement
parameter_list|(
name|cfile
parameter_list|,
name|config
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|iaddr
name|addr
decl_stmt|;
name|struct
name|iaddrlist
modifier|*
name|list
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting IP address."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
operator|(
expr|struct
name|iaddrlist
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iaddrlist
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|log_fatal
argument_list|(
literal|"no memory for reject list!"
argument_list|)
expr_stmt|;
name|list
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|config
operator|->
name|reject_list
expr_stmt|;
name|config
operator|->
name|reject_list
operator|=
name|list
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* allow-deny-keyword :== BOOTP    			| BOOTING 			| DYNAMIC_BOOTP 			| UNKNOWN_CLIENTS */
end_comment

begin_function
name|int
name|parse_allow_deny
parameter_list|(
name|oc
parameter_list|,
name|cfile
parameter_list|,
name|flag
parameter_list|)
name|struct
name|option_cache
modifier|*
modifier|*
name|oc
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|unsigned
name|char
name|rf
init|=
name|flag
decl_stmt|;
name|struct
name|expression
modifier|*
name|data
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"allow/deny/ignore not permitted here."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

