begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* clparse.c     Parser for dhclient config and lease files... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: clparse.c,v 1.13.2.5 2000/07/20 05:06:40 mellon Exp $ Copyright (c) 1997 The Internet Software Consortium.  All rights reserved.\n"
literal|"$FreeBSD$\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"dhctoken.h"
end_include

begin_decl_stmt
name|struct
name|client_config
name|top_level_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|client_script_name
index|[]
init|=
literal|"/sbin/dhclient-script"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client-conf-file :== client-declarations EOF    client-declarations :==<nil> 			 | client-declaration 			 | client-declarations client-declaration */
end_comment

begin_function
name|int
name|read_client_conf
parameter_list|()
block|{
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|new_parse
argument_list|(
name|path_dhclient_conf
argument_list|)
expr_stmt|;
comment|/* Set up the initial dhcp option universe. */
name|initialize_universes
argument_list|()
expr_stmt|;
comment|/* Initialize the top level client configuration. */
name|memset
argument_list|(
operator|&
name|top_level_config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|top_level_config
argument_list|)
expr_stmt|;
comment|/* Set some defaults... */
name|top_level_config
operator|.
name|timeout
operator|=
literal|60
expr_stmt|;
name|top_level_config
operator|.
name|select_interval
operator|=
literal|0
expr_stmt|;
name|top_level_config
operator|.
name|reboot_timeout
operator|=
literal|10
expr_stmt|;
name|top_level_config
operator|.
name|retry_interval
operator|=
literal|300
expr_stmt|;
name|top_level_config
operator|.
name|backoff_cutoff
operator|=
literal|15
expr_stmt|;
name|top_level_config
operator|.
name|initial_interval
operator|=
literal|3
expr_stmt|;
name|top_level_config
operator|.
name|bootp_policy
operator|=
name|ACCEPT
expr_stmt|;
name|top_level_config
operator|.
name|script_name
operator|=
name|client_script_name
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_SUBNET_MASK
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_BROADCAST_ADDRESS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_TIME_OFFSET
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_ROUTERS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_DOMAIN_NAME
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_DOMAIN_NAME_SERVERS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_HOST_NAME
expr_stmt|;
if|if
condition|(
operator|(
name|cfile
operator|=
name|fopen
argument_list|(
name|path_dhclient_conf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|top_level_config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Clear the peek buffer */
name|fclose
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
comment|/* Set up state and config structures for clients that don't 	   have per-interface configuration declarations. */
name|config
operator|=
operator|(
expr|struct
name|client_config
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
block|{
name|ip
operator|->
name|client
operator|=
operator|(
expr|struct
name|client_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|error
argument_list|(
literal|"no memory for client state."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
block|{
if|if
condition|(
operator|!
name|config
condition|)
block|{
name|config
operator|=
operator|(
expr|struct
name|client_config
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
name|error
argument_list|(
literal|"no memory for client config."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|config
argument_list|,
operator|&
name|top_level_config
argument_list|,
sizeof|sizeof
name|top_level_config
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|client
operator|->
name|config
operator|=
name|config
expr_stmt|;
block|}
block|}
return|return
operator|!
name|warnings_occurred
return|;
block|}
end_function

begin_comment
comment|/* lease-file :== client-lease-statements EOF    client-lease-statements :==<nil> 		     | client-lease-statements LEASE client-lease-statement */
end_comment

begin_function
name|void
name|read_client_leases
parameter_list|()
block|{
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|new_parse
argument_list|(
name|path_dhclient_db
argument_list|)
expr_stmt|;
comment|/* Open the lease file.   If we can't open it, just return - 	   we can safely trust the server to remember our state. */
if|if
condition|(
operator|(
name|cfile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|LEASE
condition|)
block|{
name|warn
argument_list|(
literal|"Corrupt lease file - possible data loss!"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/* client-declaration :==  	SEND option-decl | 	DEFAULT option-decl | 	SUPERSEDE option-decl | 	PREPEND option-decl | 	APPEND option-decl | 	hardware-declaration | 	REQUEST option-list | 	REQUIRE option-list | 	TIMEOUT number | 	RETRY number | 	REBOOT number | 	SELECT_TIMEOUT number | 	SCRIPT string | 	interface-declaration | 	LEASE client-lease-statement | 	ALIAS client-lease-statement */
end_comment

begin_function
name|void
name|parse_client_statement
parameter_list|(
name|cfile
parameter_list|,
name|ip
parameter_list|,
name|config
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
switch|switch
condition|(
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|SEND
case|:
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|send_options
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEFAULT
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_DEFAULT
expr_stmt|;
return|return;
case|case
name|SUPERSEDE
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_SUPERSEDE
expr_stmt|;
return|return;
case|case
name|APPEND
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_APPEND
expr_stmt|;
return|return;
case|case
name|PREPEND
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_PREPEND
expr_stmt|;
return|return;
case|case
name|MEDIA
case|:
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|media
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|HARDWARE
case|:
if|if
condition|(
name|ip
condition|)
block|{
name|parse_hardware_param
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip
operator|->
name|hw_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
literal|"hardware address parameter %s"
argument_list|,
literal|"not allowed here."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REQUEST
case|:
name|config
operator|->
name|requested_option_count
operator|=
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
name|config
operator|->
name|requested_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|REQUIRE
case|:
name|memset
argument_list|(
name|config
operator|->
name|required_options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|config
operator|->
name|required_options
argument_list|)
expr_stmt|;
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
name|config
operator|->
name|required_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|TIMEOUT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|RETRY
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|retry_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT_TIMEOUT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|select_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBOOT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|reboot_timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|BACKOFF_CUTOFF
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|backoff_cutoff
argument_list|)
expr_stmt|;
return|return;
case|case
name|INITIAL_INTERVAL
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|initial_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCRIPT
case|:
name|config
operator|->
name|script_name
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTERFACE
case|:
if|if
condition|(
name|ip
condition|)
name|parse_warn
argument_list|(
literal|"nested interface declaration."
argument_list|)
expr_stmt|;
name|parse_interface_declaration
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEASE
case|:
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ALIAS
case|:
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|REJECT
case|:
name|parse_reject_statement
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return;
default|default:
name|parse_warn
argument_list|(
literal|"expecting a statement."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|parse_X
parameter_list|(
name|cfile
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|u_int8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NUMBER
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting hexadecimal constant."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|convert_num
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
name|val
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|++
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
literal|"hexadecimal constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COLON
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COLON
condition|)
do|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
literal|"string constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
literal|"expecting string or hexadecimal data"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* option-list :== option_name |    		   option_list COMMA option_name */
end_comment

begin_function
name|int
name|parse_option_list
parameter_list|(
name|cfile
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|u_int8_t
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|ix
decl_stmt|,
name|i
decl_stmt|;
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected option name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|256
condition|)
block|{
name|parse_warn
argument_list|(
literal|"%s: expected option name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|list
index|[
name|ix
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ix
operator|==
literal|256
condition|)
block|{
name|parse_warn
argument_list|(
literal|"%s: too many options."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ix
return|;
block|}
end_function

begin_comment
comment|/* interface-declaration :==    	INTERFACE string LBRACE client-declarations RBRACE */
end_comment

begin_function
name|void
name|parse_interface_declaration
parameter_list|(
name|cfile
parameter_list|,
name|outer_config
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_config
modifier|*
name|outer_config
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|interface_or_dummy
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|make_client_state
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
name|make_client_config
argument_list|(
name|ip
argument_list|,
name|outer_config
argument_list|)
expr_stmt|;
name|ip
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_AUTOMATIC
expr_stmt|;
name|interfaces_requested
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unterminated interface declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|interface_info
modifier|*
name|interface_or_dummy
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
comment|/* Find the interface (if any) that matches the name. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
comment|/* If it's not a real interface, see if it's on the dummy list. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* If we didn't find an interface, make a dummy interface as 	   a placeholder. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|ip
operator|=
operator|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ip
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
name|error
argument_list|(
literal|"Insufficient memory to record interface %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ip
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ip
operator|->
name|next
operator|=
name|dummy_interfaces
expr_stmt|;
name|dummy_interfaces
operator|=
name|ip
expr_stmt|;
block|}
return|return
name|ip
return|;
block|}
end_function

begin_function
name|void
name|make_client_state
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
name|ip
operator|->
name|client
operator|=
operator|(
operator|(
expr|struct
name|client_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|error
argument_list|(
literal|"no memory for state on %s\n"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_client_config
parameter_list|(
name|ip
parameter_list|,
name|config
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|ip
operator|->
name|client
operator|->
name|config
operator|=
operator|(
operator|(
expr|struct
name|client_config
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
name|error
argument_list|(
literal|"no memory for config for %s\n"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
operator|->
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|config
argument_list|,
name|config
argument_list|,
sizeof|sizeof
expr|*
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* client-lease-statement :== 	RBRACE client-lease-declarations LBRACE  	client-lease-declarations :==<nil> | 		client-lease-declaration | 		client-lease-declarations client-lease-declaration */
end_comment

begin_function
name|void
name|parse_client_lease_statement
parameter_list|(
name|cfile
parameter_list|,
name|is_static
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|int
name|is_static
decl_stmt|;
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|lease
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
name|error
argument_list|(
literal|"no memory for lease.\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|->
name|is_static
operator|=
name|is_static
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unterminated lease declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_lease_declaration
argument_list|(
name|cfile
argument_list|,
name|lease
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* If the lease declaration didn't include an interface 	   declaration that we recognized, it's of no use to us. */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure there's a client state structure... */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|make_client_state
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* If this is an alias lease, it doesn't need to be sorted in. */
if|if
condition|(
name|is_static
operator|==
literal|2
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|alias
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* The new lease may supersede a lease that's not the 	   active lease but is still on the lease list, so scan the 	   lease list looking for a lease with the same address, and 	   if we find it, toss it. */
name|pl
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lp
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|pl
condition|)
name|pl
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|free_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is a preloaded lease, just put it on the list of recorded 	   leases - don't make it the active lease. */
if|if
condition|(
name|is_static
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* The last lease in the lease file on a particular interface is 	   the active lease for that interface.    Of course, we don't know 	   what the last lease in the file is until we've parsed the whole 	   file, so at this point, we assume that the lease we just parsed 	   is the active lease for its interface.   If there's already 	   an active lease for the interface, and this lease is for the same 	   ip address, then we just toss the old active lease and replace 	   it with this one.   If this lease is for a different address, 	   then if the old active lease has expired, we dump it; if not, 	   we put it on the list of leases for this interface which are 	   still valid but no longer active. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|lease
expr_stmt|;
comment|/* phew. */
block|}
end_function

begin_comment
comment|/* client-lease-declaration :== 	BOOTP | 	INTERFACE string | 	FIXED_ADDR ip_address | 	FILENAME string | 	SERVER_NAME string | 	OPTION option-decl | 	RENEW time-decl | 	REBIND time-decl | 	EXPIRE time-decl */
end_comment

begin_function
name|void
name|parse_client_lease_declaration
parameter_list|(
name|cfile
parameter_list|,
name|lease
parameter_list|,
name|ipp
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|interface_info
modifier|*
modifier|*
name|ipp
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|BOOTP
case|:
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|INTERFACE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|interface_or_dummy
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
break|break;
case|case
name|FIXED_ADDR
case|:
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|address
argument_list|)
condition|)
return|return;
break|break;
case|case
name|MEDIUM
case|:
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|medium
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|FILENAME
case|:
name|lease
operator|->
name|filename
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERVER_NAME
case|:
name|lease
operator|->
name|server_name
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|RENEW
case|:
name|lease
operator|->
name|renewal
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBIND
case|:
name|lease
operator|->
name|rebind
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPIRE
case|:
name|lease
operator|->
name|expiry
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPTION
case|:
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
name|lease
operator|->
name|options
argument_list|)
expr_stmt|;
return|return;
default|default:
name|parse_warn
argument_list|(
literal|"expecting lease declaration."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|option
modifier|*
name|parse_option_decl
parameter_list|(
name|cfile
parameter_list|,
name|options
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|option_data
modifier|*
name|options
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|u_int8_t
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u_int8_t
name|hunkbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|hunkix
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|vendor
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|iaddr
name|ip_addr
decl_stmt|;
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nul_term
init|=
literal|0
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier after option keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|vendor
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vendor
condition|)
name|error
argument_list|(
literal|"no memory for vendor information."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vendor
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DOT
condition|)
block|{
comment|/* Go ahead and take the DOT token... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* The next token should be an identifier... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier after '.'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Look up the option name hash table for the specified 		   vendor. */
name|universe
operator|=
operator|(
operator|(
expr|struct
name|universe
operator|*
operator|)
name|hash_lookup
argument_list|(
operator|&
name|universe_hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|vendor
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* If it's not there, we can't parse the rest of the 		   declaration. */
if|if
condition|(
operator|!
name|universe
condition|)
block|{
name|parse_warn
argument_list|(
literal|"no vendor named %s."
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Use the default hash table, which contains all the 		   standard dhcp option names. */
name|val
operator|=
name|vendor
expr_stmt|;
name|universe
operator|=
operator|&
name|dhcp_universe
expr_stmt|;
block|}
comment|/* Look up the actual option info... */
name|option
operator|=
operator|(
expr|struct
name|option
operator|*
operator|)
name|hash_lookup
argument_list|(
name|universe
operator|->
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we didn't get an option structure, it's an undefined option. */
if|if
condition|(
operator|!
name|option
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|vendor
condition|)
name|parse_warn
argument_list|(
literal|"no option named %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|parse_warn
argument_list|(
literal|"no option named %s for vendor %s"
argument_list|,
name|val
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Free the initial identifier token. */
name|free
argument_list|(
name|vendor
argument_list|)
expr_stmt|;
comment|/* Parse the option data... */
do|do
block|{
for|for
control|(
name|fmt
operator|=
name|option
operator|->
name|format
init|;
operator|*
name|fmt
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'A'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'X'
case|:
name|len
operator|=
name|parse_X
argument_list|(
name|cfile
argument_list|,
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
sizeof|sizeof
name|hunkbuf
operator|-
name|hunkix
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Text string... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting string."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunkix
operator|+
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|hunkbuf
condition|)
block|{
name|parse_warn
argument_list|(
literal|"option data buffer %s"
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nul_term
operator|=
literal|1
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* IP address. */
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip_addr
argument_list|)
condition|)
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
name|len
operator|=
name|ip_addr
operator|.
name|len
expr_stmt|;
name|dp
operator|=
name|ip_addr
operator|.
name|iabuf
expr_stmt|;
name|alloc
label|:
if|if
condition|(
name|hunkix
operator|+
name|len
operator|>
sizeof|sizeof
name|hunkbuf
condition|)
block|{
name|parse_warn
argument_list|(
literal|"option data buffer %s"
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Unsigned 32-bit integer... */
case|case
literal|'l'
case|:
comment|/* Signed 32-bit integer... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|need_number
label|:
name|parse_warn
argument_list|(
literal|"expecting number."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'s'
case|:
comment|/* Signed 16-bit integer. */
case|case
literal|'S'
case|:
comment|/* Unsigned 16-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'b'
case|:
comment|/* Signed 8-bit integer. */
case|case
literal|'B'
case|:
comment|/* Unsigned 8-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'f'
case|:
comment|/* Boolean flag. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|bad_flag
label|:
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"on"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
literal|"expecting boolean."
argument_list|)
expr_stmt|;
goto|goto
name|bad_flag
goto|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
default|default:
name|warn
argument_list|(
literal|"Bad format %c in parse_option_param."
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|fmt
operator|==
literal|'A'
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|hunkix
operator|+
name|nul_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
condition|)
name|error
argument_list|(
literal|"out of memory allocating option data."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
argument_list|,
name|hunkbuf
argument_list|,
name|hunkix
operator|+
name|nul_term
argument_list|)
expr_stmt|;
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|len
operator|=
name|hunkix
expr_stmt|;
return|return
name|option
return|;
block|}
end_function

begin_function
name|void
name|parse_string_list
parameter_list|(
name|cfile
parameter_list|,
name|lp
parameter_list|,
name|multiple
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|string_list
modifier|*
modifier|*
name|lp
decl_stmt|;
name|int
name|multiple
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|string_list
modifier|*
name|cur
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Find the last medium in the media list. */
if|if
condition|(
operator|*
name|lp
condition|)
block|{
for|for
control|(
name|cur
operator|=
operator|*
name|lp
init|;
name|cur
operator|->
name|next
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
empty_stmt|;
block|}
else|else
block|{
name|cur
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
block|}
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"Expecting media options."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|error
argument_list|(
literal|"no memory for string list entry."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|string
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Store this medium at the end of the media list. */
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|tmp
expr_stmt|;
name|cur
operator|=
name|tmp
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|multiple
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_reject_statement
parameter_list|(
name|cfile
parameter_list|,
name|config
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|iaddr
name|addr
decl_stmt|;
name|struct
name|iaddrlist
modifier|*
name|list
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting IP address."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
operator|(
expr|struct
name|iaddrlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iaddrlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|error
argument_list|(
literal|"no memory for reject list!"
argument_list|)
expr_stmt|;
name|list
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|config
operator|->
name|reject_list
expr_stmt|;
name|config
operator|->
name|reject_list
operator|=
name|list
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

