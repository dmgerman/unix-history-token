begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dhclient.c     DHCP Client. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998, 1999  * The Internet Software Consortium.    All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  *  * This client was substantially modified and enhanced by Elliot Poger  * for use on Linux while he was working on the MosquitoNet project at  * Stanford.  *  * The current version owes much to Elliot's Linux enhancements, but  * was substantially reorganized and partially rewritten by Ted Lemon  * so as to use the same networking framework that the Internet Software  * Consortium DHCP server uses.   Much system-specific configuration code  * was moved into a shell script so that as support for more operating  * systems is added, it will not be necessary to port and maintain  * system-specific configuration code to these operating systems - instead,  * the shell script can invoke the native tools to accomplish the same  * purpose.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ocopyright
index|[]
init|=
literal|"$Id: dhclient.c,v 1.44.2.47 2000/09/06 20:59:09 mellon Exp $ Copyright (c) 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium.  All rights reserved.\n"
literal|"$FreeBSD$\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
name|TIME
name|cur_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TIME
name|default_lease_time
init|=
literal|43200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12 hours... */
end_comment

begin_decl_stmt
name|TIME
name|max_lease_time
init|=
literal|86400
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 hours... */
end_comment

begin_decl_stmt
name|struct
name|tree_cache
modifier|*
name|global_options
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_conf
init|=
name|_PATH_DHCLIENT_CONF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_db
init|=
name|_PATH_DHCLIENT_DB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_pid
init|=
name|_PATH_DHCLIENT_PID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interfaces_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|log_perror
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iaddr
name|iaddr_broadcast
init|=
block|{
literal|4
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iaddr
name|iaddr_any
init|=
block|{
literal|4
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|inaddr_any
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|sockaddr_broadcast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ASSERT_STATE() does nothing now; it used to be    assert (state_is == state_shouldbe). */
end_comment

begin_define
define|#
directive|define
name|ASSERT_STATE
parameter_list|(
name|state_is
parameter_list|,
name|state_shouldbe
parameter_list|)
value|{}
end_define

begin_decl_stmt
name|u_int16_t
name|local_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|remote_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|log_priority
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_daemon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|save_scripts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onetry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"Copyright 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|arr
index|[]
init|=
literal|"All rights reserved."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|message
index|[]
init|=
literal|"Internet Software Consortium DHCP Client"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|contrib
index|[]
init|=
literal|"Please contribute if you find this software useful."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|url
index|[]
init|=
literal|"For info, please visit http://www.isc.org/dhcp-contrib.html"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|servent
modifier|*
name|ent
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|int
name|seed
decl_stmt|;
name|int
name|quiet
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
comment|/* Initially, log errors to stderr as well as to syslogd. */
ifdef|#
directive|ifdef
name|SYSLOG_4_2
name|openlog
argument_list|(
name|s
argument_list|,
name|LOG_NDELAY
argument_list|)
expr_stmt|;
name|log_priority
operator|=
name|DHCPD_LOG_FACILITY
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
name|s
argument_list|,
name|LOG_NDELAY
argument_list|,
name|DHCPD_LOG_FACILITY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSLOG_4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-p"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|local_port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"binding to user-specified port %d"
argument_list|,
name|ntohs
argument_list|(
name|local_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|no_daemon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-D"
argument_list|)
condition|)
block|{
name|save_scripts
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-cf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|path_dhclient_conf
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|path_dhclient_pid
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|path_dhclient_db
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-q"
argument_list|)
condition|)
block|{
name|quiet
operator|=
literal|1
expr_stmt|;
name|quiet_interface_discovery
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-1"
argument_list|)
condition|)
block|{
name|onetry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|usage
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|interface_info
modifier|*
name|tmp
init|=
operator|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|,
literal|"specified_interface"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|error
argument_list|(
literal|"Insufficient memory to %s %s"
argument_list|,
literal|"record interface"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|tmp
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|interfaces
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|INTERFACE_REQUESTED
expr_stmt|;
name|interfaces_requested
operator|=
literal|1
expr_stmt|;
name|interfaces
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|note
argument_list|(
literal|"%s %s"
argument_list|,
name|message
argument_list|,
name|DHCP_VERSION
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|contrib
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* Default to the DHCP/BOOTP port. */
if|if
condition|(
operator|!
name|local_port
condition|)
block|{
name|ent
operator|=
name|getservbyname
argument_list|(
literal|"dhcpc"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ent
condition|)
name|local_port
operator|=
name|htons
argument_list|(
literal|68
argument_list|)
expr_stmt|;
else|else
name|local_port
operator|=
name|ent
operator|->
name|s_port
expr_stmt|;
ifndef|#
directive|ifndef
name|__CYGWIN32__
name|endservent
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|remote_port
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|local_port
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* Get the current time... */
name|GET_TIME
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_port
operator|=
name|remote_port
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|sockaddr_broadcast
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|sockaddr_broadcast
expr_stmt|;
endif|#
directive|endif
name|inaddr_any
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* Discover all the network interfaces. */
name|discover_interfaces
argument_list|(
name|DISCOVER_UNCONFIGURED
argument_list|)
expr_stmt|;
comment|/* Parse the dhclient.conf file. */
name|read_client_conf
argument_list|()
expr_stmt|;
comment|/* Parse the lease database. */
name|read_client_leases
argument_list|()
expr_stmt|;
comment|/* Rewrite the lease database... */
name|rewrite_client_leases
argument_list|()
expr_stmt|;
comment|/* If no broadcast interfaces were discovered, call the script 	   and tell it so. */
if|if
condition|(
operator|!
name|interfaces
condition|)
block|{
name|script_init
argument_list|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
argument_list|,
literal|"NBI"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|"No broadcast interfaces found - exiting."
argument_list|)
expr_stmt|;
comment|/* Nothing more to do. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Call the script with the list of interfaces. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
comment|/* If interfaces were specified, don't configure 			   interfaces that weren't specified! */
if|if
condition|(
name|interfaces_requested
operator|&&
operator|(
operator|(
name|ip
operator|->
name|flags
operator|&
operator|(
name|INTERFACE_REQUESTED
operator||
name|INTERFACE_AUTOMATIC
operator|)
operator|)
operator|!=
name|INTERFACE_REQUESTED
operator|)
condition|)
continue|continue;
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"PREINIT"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point, all the interfaces that the script thinks 	   are relevant should be running, so now we once again call 	   discover_interfaces(), and this time ask it to actually set 	   up the interfaces. */
name|discover_interfaces
argument_list|(
name|interfaces_requested
condition|?
name|DISCOVER_REQUESTED
else|:
name|DISCOVER_RUNNING
argument_list|)
expr_stmt|;
comment|/* Make up a seed for the random number generator from current 	   time plus the sum of the last four bytes of each 	   interface's hardware address interpreted as an integer. 	   Not much entropy, but we're booting, so we're not likely to 	   find anything better. */
name|seed
operator|=
literal|0
expr_stmt|;
comment|/* Unfortunately, what's on the stack isn't random. :') */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|int
name|junk
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|junk
argument_list|,
operator|&
name|ip
operator|->
name|hw_address
operator|.
name|haddr
index|[
name|ip
operator|->
name|hw_address
operator|.
name|hlen
operator|-
sizeof|sizeof
name|seed
index|]
argument_list|,
sizeof|sizeof
name|seed
argument_list|)
expr_stmt|;
name|seed
operator|+=
name|junk
expr_stmt|;
block|}
name|srandom
argument_list|(
name|seed
operator|+
name|cur_time
argument_list|)
expr_stmt|;
comment|/* Start a configuration state machine for each interface. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_reboot
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the bootp packet handler... */
name|bootp_packet_handler
operator|=
name|do_packet
expr_stmt|;
comment|/* Start dispatching packets and timeouts... */
name|dispatch
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|appname
parameter_list|)
name|char
modifier|*
name|appname
decl_stmt|;
block|{
name|note
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|contrib
argument_list|)
expr_stmt|;
name|note
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Usage: %s [-D] [-d] [-p<port>] [-cf conf-file]"
argument_list|,
name|appname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"       [-lf lease-file] [-pf pidfile] [-q] [-1] [interface]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cleanup
parameter_list|()
block|{
comment|/* Make sure the pidfile is gone. */
name|unlink
argument_list|(
name|path_dhclient_pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Individual States:  *   * Each routine is called from the dhclient_state_machine() in one of  * these conditions:  * -> entering INIT state  * -> recvpacket_flag == 0: timeout in this state  * -> otherwise: received a packet in this state  *  * Return conditions as handled by dhclient_state_machine():  * Returns 1, sendpacket_flag = 1: send packet, reset timer.  * Returns 1, sendpacket_flag = 0: just reset the timer (wait for a milestone).  * Returns 0: finish the nap which was interrupted for no good reason.  *  * Several per-interface variables are used to keep track of the process:  *   active_lease: the lease that is being used on the interface  *                 (null pointer if not configured yet).  *   offered_leases: leases corresponding to DHCPOFFER messages that have  *		     been sent to us by DHCP servers.  *   acked_leases: leases corresponding to DHCPACK messages that have been  *		   sent to us by DHCP servers.  *   sendpacket: DHCP packet we're trying to send.  *   destination: IP address to send sendpacket to  * In addition, there are several relevant per-lease variables.  *   T1_expiry, T2_expiry, lease_expiry: lease milestones  * In the active lease, these control the process of renewing the lease;  * In leases on the acked_leases list, this simply determines when we  * can no longer legitimately use the lease.  */
end_comment

begin_function
name|void
name|state_reboot
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
comment|/* If we don't remember an active lease, go straight to INIT. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
operator|||
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|is_bootp
condition|)
block|{
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are in the rebooting state. */
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REBOOTING
expr_stmt|;
comment|/* make_request doesn't initialize xid because it normally comes 	   from the DHCPDISCOVER, but we haven't sent a DHCPDISCOVER, 	   so pick an xid now. */
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* Make a DHCPREQUEST packet, and set appropriate per-interface 	   flags. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Zap the medium list... */
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send out the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when a lease has completely expired and we've been unable to    renew it. */
end_comment

begin_function
name|void
name|state_init
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_INIT
argument_list|)
expr_stmt|;
comment|/* Make a DHCPDISCOVER packet, and set appropriate per-interface 	   flags. */
name|make_discover
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_SELECTING
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Add an immediate timeout to cause the first DHCPDISCOVER packet 	   to go out. */
name|send_discover
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_selecting is called when one or more DHCPOFFER packets have been    received and a configurable period of time has passed. */
end_comment

begin_function
name|void
name|state_selecting
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|picked
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_SELECTING
argument_list|)
expr_stmt|;
comment|/* Cancel state_selecting and send_discover timeouts, since either 	   one could have got us here. */
name|cancel_timeout
argument_list|(
name|state_selecting
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* We have received one or more DHCPOFFER packets.   Currently, 	   the only criterion by which we judge leases is whether or 	   not we get a response when we arp for them. */
name|picked
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lp
condition|;
name|lp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
comment|/* Check to see if we got an ARPREPLY for the address 		   in this particular lease. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"ARPCHECK"
argument_list|,
name|lp
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"check_"
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* If the ARPCHECK code detects another 			   machine using the offered address, it exits 			   nonzero.  We need to send a DHCPDECLINE and 			   toss the lease. */
if|if
condition|(
name|script_go
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|make_decline
argument_list|(
name|ip
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|send_decline
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
name|picked
operator|=
name|lp
expr_stmt|;
name|picked
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|freeit
label|:
name|free_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* If we just tossed all the leases we were offered, go back 	   to square one. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was a BOOTREPLY, we can just take the address right now. */
if|if
condition|(
operator|!
name|picked
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|new
operator|=
name|picked
expr_stmt|;
comment|/* Make up some lease expiry times 		   XXX these should be configurable. */
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|cur_time
operator|+
literal|12000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
operator|+
literal|8000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
operator|+
literal|10000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
comment|/* Bind to the address we received. */
name|bind_lease
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go to the REQUESTING state. */
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Make a DHCPREQUEST packet from the lease we picked. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|picked
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
comment|/* Toss the lease we picked - we'll get it back in a DHCPACK. */
name|free_client_lease
argument_list|(
name|picked
argument_list|)
expr_stmt|;
comment|/* Add an immediate timeout to send the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_requesting is called when we receive a DHCPACK message after    having sent out one or more DHCPREQUEST packets. */
end_comment

begin_function
name|void
name|dhcpack
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|debug
argument_list|(
literal|"DHCPACK in wrong transaction."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|debug
argument_list|(
literal|"DHCPACK in wrong state."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|note
argument_list|(
literal|"DHCPACK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|note
argument_list|(
literal|"packet_to_lease failed."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|client
operator|->
name|new
operator|=
name|lease
expr_stmt|;
comment|/* Stop resending DHCPREQUEST. */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* Figure out the lease time. */
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_LEASE_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* A number that looks negative here is really just very large, 	   because the lease expiry offset is unsigned. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
literal|0
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
comment|/* Take the server-provided renewal time if there is one; 	   otherwise figure it out according to the spec. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_RENEWAL_TIME
index|]
operator|.
name|len
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_RENEWAL_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|/
literal|2
expr_stmt|;
comment|/* Same deal with the rebind time. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_REBINDING_TIME
index|]
operator|.
name|len
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_REBINDING_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|/
literal|2
operator|+
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|/
literal|4
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|+=
name|cur_time
expr_stmt|;
comment|/* Lease lengths can never be negative. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|TIME_MAX
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|TIME_MAX
expr_stmt|;
name|bind_lease
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bind_lease
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
comment|/* Remember the medium. */
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Write out the new lease. */
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
name|ip
argument_list|,
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|?
literal|"BOUND"
else|:
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_RENEWING
condition|?
literal|"RENEW"
else|:
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
condition|?
literal|"REBOOT"
else|:
literal|"REBIND"
operator|)
operator|)
operator|)
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"old_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"new_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Replace the old active lease with the new one. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|ip
operator|->
name|client
operator|->
name|new
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Set up a timeout to start the renewal process. */
name|add_timeout
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
argument_list|,
name|state_bound
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|"bound to %s -- renewal in %d seconds."
argument_list|,
name|piaddr
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_bound is called when we've successfully bound to a particular    lease, but the renewal time on that lease has expired.   We are    expected to unicast a DHCPREQUEST to the server that gave us our    original lease. */
end_comment

begin_function
name|void
name|state_bound
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_BOUND
argument_list|)
expr_stmt|;
comment|/* T1 has expired. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|options
index|[
name|DHO_DHCP_SERVER_IDENTIFIER
index|]
operator|.
name|len
operator|==
literal|4
condition|)
block|{
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|options
index|[
name|DHO_DHCP_SERVER_IDENTIFIER
index|]
operator|.
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_RENEWING
expr_stmt|;
comment|/* Send the first packet immediately. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|commit_leases
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|write_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|db_startup
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|bootp
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|packet
operator|->
name|raw
operator|->
name|op
operator|!=
name|BOOTREPLY
condition|)
return|return;
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|note
argument_list|(
literal|"BOOTREPLY from %s rejected."
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dhcpoffer
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcp
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
name|void
argument_list|(
argument|*handler
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|packet
operator|->
name|packet_type
condition|)
block|{
case|case
name|DHCPOFFER
case|:
name|handler
operator|=
name|dhcpoffer
expr_stmt|;
name|type
operator|=
literal|"DHCPOFFER"
expr_stmt|;
break|break;
case|case
name|DHCPNAK
case|:
name|handler
operator|=
name|dhcpnak
expr_stmt|;
name|type
operator|=
literal|"DHCPNACK"
expr_stmt|;
break|break;
case|case
name|DHCPACK
case|:
name|handler
operator|=
name|dhcpack
expr_stmt|;
name|type
operator|=
literal|"DHCPACK"
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|note
argument_list|(
literal|"%s from %s rejected."
argument_list|,
name|type
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
call|(
modifier|*
name|handler
call|)
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcpoffer
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|arp_timeout_needed
decl_stmt|,
name|stop_selecting
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|?
literal|"DHCPOFFER"
else|:
literal|"BOOTREPLY"
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|packet
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_SELECTING
operator|||
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|debug
argument_list|(
literal|"%s in wrong transaction."
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|note
argument_list|(
literal|"%s from %s"
argument_list|,
name|name
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this lease doesn't supply the minimum required parameters, 	   blow it off. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packet
operator|->
name|options
index|[
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
index|]
operator|.
name|len
condition|)
block|{
name|note
argument_list|(
literal|"%s isn't satisfactory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we've already seen this lease, don't record it again. */
for|for
control|(
name|lease
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lease
condition|;
name|lease
operator|=
name|lease
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|yiaddr
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"%s already seen."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|note
argument_list|(
literal|"packet_to_lease failed."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this lease was acquired through a BOOTREPLY, record that 	   fact. */
if|if
condition|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|)
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
comment|/* Record the medium under which this lease was offered. */
name|lease
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Send out an ARP Request for the offered IP address. */
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"ARPSEND"
argument_list|,
name|lease
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"check_"
argument_list|,
name|lease
argument_list|)
expr_stmt|;
comment|/* If the script can't send an ARP request without waiting,  	   we'll be waiting when we do the ARPCHECK, so don't wait now. */
if|if
condition|(
name|script_go
argument_list|(
name|ip
argument_list|)
condition|)
name|arp_timeout_needed
operator|=
literal|0
expr_stmt|;
else|else
name|arp_timeout_needed
operator|=
literal|2
expr_stmt|;
comment|/* Figure out when we're supposed to stop selecting. */
name|stop_selecting
operator|=
operator|(
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|select_interval
operator|)
expr_stmt|;
comment|/* If this is the lease we asked for, put it at the head of the 	   list, and don't mess with the arp request timeout. */
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
argument_list|)
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
block|}
else|else
block|{
comment|/* If we already have an offer, and arping for this 		   offer would take us past the selection timeout, 		   then don't extend the timeout - just hope for the 		   best. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|&&
operator|(
name|cur_time
operator|+
name|arp_timeout_needed
operator|)
operator|>
name|stop_selecting
condition|)
name|arp_timeout_needed
operator|=
literal|0
expr_stmt|;
comment|/* Put the lease at the end of the list. */
name|lease
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|offered_leases
condition|)
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
else|else
block|{
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
name|lp
operator|->
name|next
operator|=
name|lease
expr_stmt|;
block|}
block|}
comment|/* If we're supposed to stop selecting before we've had time 	   to wait for the ARPREPLY, add some delay to wait for 	   the ARPREPLY. */
if|if
condition|(
name|stop_selecting
operator|-
name|cur_time
operator|<
name|arp_timeout_needed
condition|)
name|stop_selecting
operator|=
name|cur_time
operator|+
name|arp_timeout_needed
expr_stmt|;
comment|/* If the selecting interval has expired, go immediately to 	   state_selecting().  Otherwise, time out into 	   state_selecting at the select interval. */
if|if
condition|(
name|stop_selecting
operator|<=
literal|0
condition|)
name|state_selecting
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
block|{
name|add_timeout
argument_list|(
name|stop_selecting
argument_list|,
name|state_selecting
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a client_lease structure and initialize it from the parameters    in the specified packet. */
end_comment

begin_function
name|struct
name|client_lease
modifier|*
name|packet_to_lease
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lease
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|warn
argument_list|(
literal|"dhcpoffer: no memory to record lease.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|lease
argument_list|)
expr_stmt|;
comment|/* Copy the lease options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|warn
argument_list|(
literal|"dhcpoffer: no memory for option %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|=
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
index|[
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|lease
operator|->
name|address
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* If the server name was filled out, copy it. */
if|if
condition|(
operator|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|len
operator|||
operator|!
operator|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|2
operator|)
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
literal|0
index|]
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Don't count on the NUL terminator. */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|64
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|!
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
name|len
index|]
condition|)
break|break;
name|lease
operator|->
name|server_name
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|server_name
condition|)
block|{
name|warn
argument_list|(
literal|"dhcpoffer: no memory for filename.\n"
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|server_name
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|server_name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Ditto for the filename. */
if|if
condition|(
operator|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|len
operator|||
operator|!
operator|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|file
index|[
literal|0
index|]
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Don't count on the NUL terminator. */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|64
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|!
name|packet
operator|->
name|raw
operator|->
name|file
index|[
name|len
index|]
condition|)
break|break;
name|lease
operator|->
name|filename
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|filename
condition|)
block|{
name|warn
argument_list|(
literal|"dhcpoffer: no memory for filename.\n"
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|lease
return|;
block|}
end_function

begin_function
name|void
name|dhcpnak
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|debug
argument_list|(
literal|"DHCPNAK in wrong transaction."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|debug
argument_list|(
literal|"DHCPNAK in wrong state."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|note
argument_list|(
literal|"DHCPNAK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
name|note
argument_list|(
literal|"DHCPNAK with no active lease.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Stop sending DHCPREQUEST packets... */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send out a DHCPDISCOVER packet, and set a timeout to send out another    one after the right interval has expired.  If we don't get an offer by    the time we reach the panic interval, call the panic function. */
end_comment

begin_function
name|void
name|send_discover
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|int
name|increase
init|=
literal|1
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|ip
operator|->
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're past the panic timeout, call the script and tell it 	   we haven't found anything for this interface yet. */
if|if
condition|(
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
block|{
name|state_panic
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're selecting media, try the whole list before doing 	   the exponential backoff, but if we've already received an 	   offer, stop looping, because we obviously have it right. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|media
condition|)
block|{
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|again
label|:
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|medium
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
operator|->
name|next
expr_stmt|;
name|increase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|medium
condition|)
block|{
if|if
condition|(
name|fail
condition|)
name|error
argument_list|(
literal|"No valid media types for %s!"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|media
expr_stmt|;
name|increase
operator|=
literal|1
expr_stmt|;
block|}
name|note
argument_list|(
literal|"Trying medium \"%s\" %d"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|medium
operator|->
name|string
argument_list|,
name|increase
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"MEDIUM"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|script_go
argument_list|(
name|ip
argument_list|)
condition|)
block|{
goto|goto
name|again
goto|;
block|}
block|}
comment|/* If we're supposed to increase the interval, do so.  If it's 	   currently zero (i.e., we haven't sent any packets yet), set 	   it to one; otherwise, add to it a random number between 	   zero and two times itself.  On average, this means that it 	   will double with every transmission. */
if|if
condition|(
name|increase
condition|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|interval
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* If the backoff would take us to the panic timeout, just use that 	   as the interval. */
if|if
condition|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
operator|)
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|secs
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
expr_stmt|;
name|note
argument_list|(
literal|"DHCPDISCOVER on %s to %s port %d interval %ld"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|,
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|,
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_panic gets called if we haven't received any offers in a preset    amount of time.   When this happens, we try to use existing leases that    haven't yet expired, and failing that, we call the client script and    hope it can do something. */
end_comment

begin_function
name|void
name|state_panic
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|loop
init|=
name|ip
operator|->
name|client
operator|->
name|active
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
name|note
argument_list|(
literal|"No DHCPOFFERS received."
argument_list|)
expr_stmt|;
comment|/* We may not have an active lease, but we may have some 	   predefined leases that we can try. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
operator|&&
name|ip
operator|->
name|client
operator|->
name|leases
condition|)
goto|goto
name|activate_next
goto|;
comment|/* Run through the list of leases and see if one can be used. */
while|while
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|>
name|cur_time
condition|)
block|{
name|note
argument_list|(
literal|"Trying recorded lease %s"
argument_list|,
name|piaddr
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the client script with the existing 			   parameters. */
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"TIMEOUT"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"new_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
comment|/* If the old lease is still good and doesn't 			   yet need renewal, go into BOUND state and 			   timeout at the renewal time. */
if|if
condition|(
operator|!
name|script_go
argument_list|(
name|ip
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_time
operator|<
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|note
argument_list|(
literal|"bound: renewal in %d seconds."
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
operator|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
operator|)
argument_list|,
name|state_bound
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|note
argument_list|(
literal|"bound: immediate renewal."
argument_list|)
expr_stmt|;
name|state_bound
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are no other leases, give up. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|leases
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
block|}
name|activate_next
label|:
comment|/* Otherwise, put the active lease at the end of the 		   lease list, and try another lease.. */
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
name|lp
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
block|{
name|lp
operator|->
name|next
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
operator|->
name|next
expr_stmt|;
comment|/* If we already tried this lease, we've exhausted the 		   set of leases, so we might as well give up for 		   now. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|==
name|loop
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|loop
condition|)
name|loop
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
block|}
comment|/* No leases were available, or what was available didn't work, so 	   tell the shell script that we failed to allocate an address, 	   and try again later. */
if|if
condition|(
name|onetry
condition|)
block|{
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|"Unable to obtain a lease on first try - exiting.\n"
argument_list|)
expr_stmt|;
block|}
name|note
argument_list|(
literal|"No working leases in persistent database - sleeping.\n"
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"FAIL"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|retry_interval
argument_list|,
name|state_init
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_request
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|struct
name|sockaddr_in
name|destination
decl_stmt|;
name|struct
name|in_addr
name|from
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|ip
operator|->
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're in the INIT-REBOOT or REQUESTING state and we're 	   past the reboot timeout, go to INIT and see if we can 	   DISCOVER an address... */
comment|/* XXX In the INIT-REBOOT state, if we don't get an ACK, it 	   means either that we're on a network with no DHCP server, 	   or that our server is down.  In the latter case, assuming 	   that there is a backup DHCP server, DHCPDISCOVER will get 	   us a new address, but we could also have successfully 	   reused our old address.  In the former case, we're hosed 	   anyway.  This is not a win-prone situation. */
if|if
condition|(
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|)
operator|&&
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|reboot_timeout
condition|)
block|{
name|cancel
label|:
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're in the reboot state, make sure the media is set up 	   correctly. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|&&
operator|!
name|ip
operator|->
name|client
operator|->
name|medium
operator|&&
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
condition|)
block|{
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"MEDIUM"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
comment|/* If the medium we chose won't fly, go to INIT state. */
if|if
condition|(
name|script_go
argument_list|(
name|ip
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
comment|/* Record the medium. */
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
expr_stmt|;
block|}
comment|/* If the lease has expired, relinquish the address and go back 	   to the INIT state. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
block|{
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"EXPIRE"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"old_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Now do a preinit on the interface so that we can 		   discover a new address. */
name|script_init
argument_list|(
name|ip
argument_list|,
literal|"PREINIT"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do the exponential backoff... */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|interval
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
comment|/* If the backoff would take us to the expiry time, just set the 	   timeout to the expiry time. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* If the lease T2 time has elapsed, or if we're not yet bound, 	   broadcast the DHCPREQUEST rather than unicasting. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|cur_time
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|rebind
condition|)
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|destination
operator|.
name|sin_port
operator|=
name|remote_port
expr_stmt|;
name|destination
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|destination
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|destination
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
condition|)
name|memcpy
argument_list|(
operator|&
name|from
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|from
argument_list|)
expr_stmt|;
else|else
name|from
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|ip
operator|->
name|client
operator|->
name|secs
expr_stmt|;
else|else
block|{
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
block|}
name|note
argument_list|(
literal|"DHCPREQUEST on %s to %s port %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|destination
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|destination
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_BROADCAST
operator|&&
name|fallback_interface
condition|)
name|result
operator|=
name|send_packet
argument_list|(
name|fallback_interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|,
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_decline
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|note
argument_list|(
literal|"DHCPDECLINE on %s to %s port %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_release
parameter_list|(
name|ipp
parameter_list|)
name|void
modifier|*
name|ipp
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|note
argument_list|(
literal|"DHCPRELEASE on %s to %s port %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_discover
parameter_list|(
name|ip
parameter_list|,
name|lease
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|discover
init|=
name|DHCPDISCOVER
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|option_elements
index|[
literal|256
index|]
decl_stmt|;
name|memset
argument_list|(
name|option_elements
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|option_elements
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|options
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPDISCOVER */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|discover
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
name|discover
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
name|discover
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Request the options we want */
name|i
operator|=
name|DHO_DHCP_PARAMETER_REQUEST_LIST
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_options
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* If we had an address, try to get it again. */
if|if
condition|(
name|lease
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|=
name|lease
operator|->
name|address
expr_stmt|;
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Send any options requested in the config file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|options
index|[
name|i
index|]
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* filled in by send_discover. */
if|if
condition|(
name|can_receive_unicast_unconfigured
argument_list|(
name|ip
argument_list|)
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
name|htons
argument_list|(
name|BOOTP_BROADCAST
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|sendpkt
argument_list|)
expr_stmt|;
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|sendpkt
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_request
parameter_list|(
name|ip
parameter_list|,
name|lease
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|request
init|=
name|DHCPREQUEST
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|option_elements
index|[
literal|256
index|]
decl_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|options
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPREQUEST */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Request the options we want */
name|i
operator|=
name|DHO_DHCP_PARAMETER_REQUEST_LIST
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_options
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* If we are requesting an address that hasn't yet been assigned 	   to us, use the DHCP Requested Address option. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
block|{
comment|/* Send back the server identifier... */
name|i
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|=
name|lease
operator|->
name|address
expr_stmt|;
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Send any options requested in the config file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|options
index|[
name|i
index|]
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
comment|/* If we own the address we're requesting, put it in ciaddr; 	   otherwise set ciaddr to zero. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_BOUND
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_RENEWING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBINDING
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_receive_unicast_unconfigured
argument_list|(
name|ip
argument_list|)
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
name|htons
argument_list|(
name|BOOTP_BROADCAST
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|sendpkt
argument_list|)
expr_stmt|;
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|sendpkt
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_decline
parameter_list|(
name|ip
parameter_list|,
name|lease
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|decline
init|=
name|DHCPDECLINE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|message_type_tree
decl_stmt|;
name|struct
name|tree_cache
name|requested_address_tree
decl_stmt|;
name|struct
name|tree_cache
name|server_id_tree
decl_stmt|;
name|struct
name|tree_cache
name|client_id_tree
decl_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|options
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPDECLINE */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|message_type_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|decline
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
name|decline
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
name|decline
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send back the server identifier... */
name|i
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|server_id_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send back the address we're declining. */
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|requested_address_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send the uid if the user supplied one. */
name|i
operator|=
name|DHO_DHCP_CLIENT_IDENTIFIER
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|client_id_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* ciaddr must always be zero. */
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|sendpkt
argument_list|)
expr_stmt|;
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|sendpkt
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_release
parameter_list|(
name|ip
parameter_list|,
name|lease
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|request
init|=
name|DHCPRELEASE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|message_type_tree
decl_stmt|;
name|struct
name|tree_cache
name|server_id_tree
decl_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|options
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPRELEASE */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|message_type_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send back the server identifier... */
name|i
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|server_id_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|sendpkt
argument_list|)
expr_stmt|;
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|free_client_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|free
argument_list|(
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|free
argument_list|(
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
name|free
argument_list|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
name|leaseFile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rewrite_client_leases
parameter_list|()
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|leaseFile
condition|)
name|fclose
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
name|error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
comment|/* Write out all the leases attached to configured interfaces that 	   we know about. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write out any leases that are attached to interfaces that aren't 	   currently configured. */
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_client_lease
parameter_list|(
name|ip
parameter_list|,
name|lease
parameter_list|,
name|rewrite
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|int
name|rewrite
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
specifier|static
name|int
name|leases_written
decl_stmt|;
if|if
condition|(
operator|!
name|rewrite
condition|)
block|{
if|if
condition|(
name|leases_written
operator|++
operator|>
literal|20
condition|)
block|{
name|rewrite_client_leases
argument_list|()
expr_stmt|;
name|leases_written
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the lease came from the config file, we don't need to stash 	   a copy in the lease database. */
if|if
condition|(
name|lease
operator|->
name|is_static
condition|)
return|return;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
comment|/* XXX */
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
name|error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"lease {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|is_bootp
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  bootp;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  interface \"%s\";\n"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  fixed-address %s;\n"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  filename \"%s\";\n"
argument_list|,
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  server-name \"%s\";\n"
argument_list|,
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|medium
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  medium \"%s\";\n"
argument_list|,
name|lease
operator|->
name|medium
operator|->
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  option %s %s;\n"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pretty_print_option
argument_list|(
name|i
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note: the following is not a Y2K bug - it's a Y1.9K bug.   Until 	   somebody invents a time machine, I think we can safely disregard 	   it. */
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|renewal
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  renew %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|rebind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  rebind %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|expiry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  expire %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Variables holding name of script and file pointer for writing to    script.   Needless to say, this is not reentrant - only one script    can be invoked at a time. */
end_comment

begin_decl_stmt
name|char
name|scriptName
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|scriptFile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|script_init
parameter_list|(
name|ip
parameter_list|,
name|reason
parameter_list|,
name|medium
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
name|struct
name|string_list
modifier|*
name|medium
decl_stmt|;
block|{
name|struct
name|string_list
modifier|*
name|sl
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
for|for
control|(
name|sl
operator|=
name|ip
operator|->
name|client
operator|->
name|env
init|;
name|sl
condition|;
name|sl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sl
argument_list|,
literal|"script_init"
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|client
operator|->
name|env
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|envc
operator|=
literal|0
expr_stmt|;
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"interface"
argument_list|,
literal|"%s"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|medium
condition|)
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"medium"
argument_list|,
literal|"%s"
argument_list|,
name|medium
operator|->
name|string
argument_list|)
expr_stmt|;
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"reason"
argument_list|,
literal|"%s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|script_write_params
parameter_list|(
name|ip
parameter_list|,
name|prefix
parameter_list|,
name|lease
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|dbuf
index|[
literal|1500
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"ip_address"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the benefit of Linux (and operating systems which may 	   have similar needs), compute the network address based on 	   the supplied ip address and netmask, if provided.  Also 	   compute the broadcast address (the host address all ones 	   broadcast address, not the host address all zeroes 	   broadcast address). */
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
operator|&&
operator|(
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
operator|<
sizeof|sizeof
name|lease
operator|->
name|address
operator|.
name|iabuf
operator|)
condition|)
block|{
name|struct
name|iaddr
name|netmask
decl_stmt|,
name|subnet
decl_stmt|,
name|broadcast
decl_stmt|;
name|memcpy
argument_list|(
name|netmask
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|netmask
operator|.
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
expr_stmt|;
name|subnet
operator|=
name|subnet_number
argument_list|(
name|lease
operator|->
name|address
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
operator|.
name|len
condition|)
block|{
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"network_number"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|subnet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|options
index|[
name|DHO_BROADCAST_ADDRESS
index|]
operator|.
name|len
condition|)
block|{
name|broadcast
operator|=
name|broadcast_addr
argument_list|(
name|subnet
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|broadcast
operator|.
name|len
condition|)
block|{
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"broadcast_address"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|broadcast
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"filename"
argument_list|,
literal|"%s"
argument_list|,
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"server_name"
argument_list|,
literal|"%s"
argument_list|,
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
switch|switch
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|default_actions
index|[
name|i
index|]
condition|)
block|{
case|case
name|ACTION_DEFAULT
case|:
name|dp
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|ACTION_SUPERSEDE
case|:
name|supersede
label|:
name|dp
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|ACTION_PREPEND
case|:
name|len
operator|=
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
name|dbuf
condition|)
block|{
name|warn
argument_list|(
literal|"no space to %s %s"
argument_list|,
literal|"prepend option"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|supersede
goto|;
block|}
name|dp
operator|=
name|dbuf
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_APPEND
case|:
name|len
operator|=
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
name|dbuf
condition|)
block|{
name|warn
argument_list|(
literal|"no space to %s %s"
argument_list|,
literal|"append option"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|supersede
goto|;
block|}
name|dp
operator|=
name|dbuf
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|dp
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|dhcp_option_ev_name
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|dhcp_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|pretty_print_option
argument_list|(
name|i
argument_list|,
name|dp
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|client_envadd
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"expiry"
argument_list|,
literal|"%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lease
operator|->
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|script_go
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|scriptName
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|char
modifier|*
name|epp
index|[
literal|3
index|]
decl_stmt|;
name|char
name|reason
index|[]
init|=
literal|"REASON=NBI"
decl_stmt|;
specifier|static
name|char
name|client_path
index|[]
init|=
name|CLIENT_PATH
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|wpid
decl_stmt|,
name|wstatus
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|scriptName
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|script_name
expr_stmt|;
name|envp
operator|=
name|dmalloc
argument_list|(
operator|(
name|ip
operator|->
name|client
operator|->
name|envc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|"script_go"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|envp
condition|)
block|{
name|error
argument_list|(
literal|"No memory for client script environment."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|ip
operator|->
name|client
operator|->
name|env
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|sp
operator|->
name|string
expr_stmt|;
block|}
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|client_path
expr_stmt|;
name|envp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|scriptName
operator|=
name|top_level_config
operator|.
name|script_name
expr_stmt|;
name|epp
index|[
literal|0
index|]
operator|=
name|reason
expr_stmt|;
name|epp
index|[
literal|1
index|]
operator|=
name|client_path
expr_stmt|;
name|epp
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|envp
operator|=
name|epp
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
name|scriptName
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
condition|)
block|{
do|do
block|{
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wpid
operator|!=
name|pid
operator|&&
name|wpid
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|wpid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"wait: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|execve
argument_list|(
name|scriptName
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"execve (%s, ...): %m"
argument_list|,
name|scriptName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|ip
operator|->
name|client
operator|->
name|env
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sp
argument_list|,
literal|"script_go"
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|client
operator|->
name|env
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|envc
operator|=
literal|0
expr_stmt|;
name|dfree
argument_list|(
name|envp
argument_list|,
literal|"script_go"
argument_list|)
expr_stmt|;
block|}
return|return
name|wstatus
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
name|void
name|client_envadd
parameter_list|(
name|struct
name|client_state
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|spbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|val
decl_stmt|;
name|va_list
name|list
decl_stmt|;
name|va_start
argument_list|(
name|list
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|spbuf
argument_list|,
sizeof|sizeof
name|spbuf
argument_list|,
name|fmt
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|val
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
comment|/* = */
operator|+
name|len
operator|+
sizeof|sizeof
expr|*
name|val
argument_list|,
literal|"client_envadd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return;
name|s
operator|=
name|val
operator|->
name|string
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|spbuf
condition|)
block|{
name|va_start
argument_list|(
name|list
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|fmt
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|s
argument_list|,
name|spbuf
argument_list|)
expr_stmt|;
name|val
operator|->
name|next
operator|=
name|client
operator|->
name|env
expr_stmt|;
name|client
operator|->
name|env
operator|=
name|val
expr_stmt|;
name|client
operator|->
name|envc
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dhcp_option_ev_name
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|option
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|option
operator|->
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|buflen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|option
operator|->
name|name
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
else|else
name|buf
index|[
name|i
index|]
operator|=
name|option
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|go_daemon
parameter_list|()
block|{
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* Don't become a daemon if the user requested otherwise. */
if|if
condition|(
name|no_daemon
condition|)
block|{
name|write_client_pid_file
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Only do it once. */
if|if
condition|(
name|state
condition|)
return|return;
name|state
operator|=
literal|1
expr_stmt|;
comment|/* Stop logging to stderr... */
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* Become a daemon... */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't fork daemon: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pid
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Become session leader and get pid... */
name|pid
operator|=
name|setsid
argument_list|()
expr_stmt|;
comment|/* Close standard I/O descriptors. */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|write_client_pid_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_client_pid_file
parameter_list|()
block|{
name|FILE
modifier|*
name|pf
decl_stmt|;
name|int
name|pfdesc
decl_stmt|;
name|pfdesc
operator|=
name|open
argument_list|(
name|path_dhclient_pid
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfdesc
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't create %s: %m"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
return|return;
block|}
name|pf
operator|=
name|fdopen
argument_list|(
name|pfdesc
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
condition|)
name|warn
argument_list|(
literal|"Can't fdopen %s: %m"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pf
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

