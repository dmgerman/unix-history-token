begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dhclient.c     DHCP Client. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995-2002 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This code is based on the original client state machine that was  * written by Elliot Poger.  The code has been extensively hacked on  * by Ted Lemon since then, so any mistakes you find are probably his  * fault and not Elliot's.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ocopyright
index|[]
init|=
literal|"$Id: dhclient.c,v 1.129.2.9 2002/02/20 07:16:31 mellon Exp $ Copyright (c) 1995-2001 Internet Software Consortium.  All rights reserved.\n"
literal|"$FreeBSD$\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
name|TIME
name|cur_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TIME
name|default_lease_time
init|=
literal|43200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12 hours... */
end_comment

begin_decl_stmt
name|TIME
name|max_lease_time
init|=
literal|86400
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 hours... */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|path_dhclient_conf
init|=
name|_PATH_DHCLIENT_CONF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|path_dhclient_db
init|=
name|_PATH_DHCLIENT_DB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|path_dhclient_pid
init|=
name|_PATH_DHCLIENT_PID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|path_dhclient_script_array
index|[]
init|=
name|_PATH_DHCLIENT_SCRIPT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_script
init|=
name|path_dhclient_script_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dhcp_max_agent_option_packet_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interfaces_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iaddr
name|iaddr_broadcast
init|=
block|{
literal|4
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iaddr
name|iaddr_any
init|=
block|{
literal|4
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|inaddr_any
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|sockaddr_broadcast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|giaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ASSERT_STATE() does nothing now; it used to be    assert (state_is == state_shouldbe). */
end_comment

begin_define
define|#
directive|define
name|ASSERT_STATE
parameter_list|(
name|state_is
parameter_list|,
name|state_shouldbe
parameter_list|)
value|{}
end_define

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"Copyright 1995-2001 Internet Software Consortium."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|arr
index|[]
init|=
literal|"All rights reserved."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|message
index|[]
init|=
literal|"Internet Software Consortium DHCP Client"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|url
index|[]
init|=
literal|"For info, please visit http://www.isc.org/products/DHCP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|local_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|remote_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_daemon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|save_scripts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|client_env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|client_env_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onetry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nowait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|do_release
parameter_list|(
name|struct
name|client_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|servent
modifier|*
name|ent
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|unsigned
name|seed
decl_stmt|;
name|char
modifier|*
name|server
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|relay
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|int
name|release_mode
init|=
literal|0
decl_stmt|;
name|omapi_object_t
modifier|*
name|listener
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|persist
init|=
literal|0
decl_stmt|;
name|int
name|omapi_port
decl_stmt|;
name|int
name|no_dhclient_conf
init|=
literal|0
decl_stmt|;
name|int
name|no_dhclient_db
init|=
literal|0
decl_stmt|;
name|int
name|no_dhclient_pid
init|=
literal|0
decl_stmt|;
name|int
name|no_dhclient_script
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Make sure we have stdin, stdout and stderr. */
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* No sense logging to /dev/null. */
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSLOG_4_2
name|openlog
argument_list|(
literal|"dhclient"
argument_list|,
name|LOG_NDELAY
argument_list|)
expr_stmt|;
name|log_priority
operator|=
name|LOG_DAEMON
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"dhclient"
argument_list|,
name|LOG_NDELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSLOG_4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up the OMAPI. */
name|status
operator|=
name|omapi_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't initialize OMAPI: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the OMAPI wrappers for various server database internal 	   objects. */
name|dhcp_common_objects_setup
argument_list|()
expr_stmt|;
name|dhcp_interface_discovery_hook
operator|=
name|dhclient_interface_discovery_hook
expr_stmt|;
name|dhcp_interface_shutdown_hook
operator|=
name|dhclient_interface_shutdown_hook
expr_stmt|;
name|dhcp_interface_startup_hook
operator|=
name|dhclient_interface_startup_hook
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-r"
argument_list|)
condition|)
block|{
name|release_mode
operator|=
literal|1
expr_stmt|;
name|no_daemon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-p"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|local_port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|log_debug
argument_list|(
literal|"binding to user-specified port %d"
argument_list|,
name|ntohs
argument_list|(
name|local_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|no_daemon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|path_dhclient_pid
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|no_dhclient_pid
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-cf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|path_dhclient_conf
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|no_dhclient_conf
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|path_dhclient_db
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|no_dhclient_db
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-sf"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|path_dhclient_script
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|no_dhclient_script
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-1"
argument_list|)
condition|)
block|{
name|onetry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-q"
argument_list|)
condition|)
block|{
name|quiet
operator|=
literal|1
expr_stmt|;
name|quiet_interface_discovery
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|server
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-g"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|relay
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
comment|/* do not start up any interfaces */
name|interfaces_requested
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-w"
argument_list|)
condition|)
block|{
comment|/* do not exit if there are no broadcast interfaces. */
name|persist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-e"
argument_list|)
condition|)
block|{
name|struct
name|string_list
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
sizeof|sizeof
expr|*
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|log_fatal
argument_list|(
literal|"No memory for %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|string
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|client_env
expr_stmt|;
name|client_env
operator|=
name|tmp
expr_stmt|;
name|client_env_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--version"
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"isc-dhclient-%s"
argument_list|,
name|DHCP_VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nw"
argument_list|)
condition|)
block|{
name|nowait
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|interface_info
modifier|*
name|tmp
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
decl_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't record interface %s:%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|>
sizeof|sizeof
name|tmp
operator|->
name|name
condition|)
name|log_fatal
argument_list|(
literal|"%s: interface name too long (max %ld)"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|tmp
operator|->
name|next
argument_list|,
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|INTERFACE_REQUESTED
expr_stmt|;
name|interfaces_requested
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|no_dhclient_conf
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"PATH_DHCLIENT_CONF"
argument_list|)
operator|)
condition|)
block|{
name|path_dhclient_conf
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_dhclient_db
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"PATH_DHCLIENT_DB"
argument_list|)
operator|)
condition|)
block|{
name|path_dhclient_db
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_dhclient_pid
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"PATH_DHCLIENT_PID"
argument_list|)
operator|)
condition|)
block|{
name|path_dhclient_pid
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_dhclient_script
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"PATH_DHCLIENT_SCRIPT"
argument_list|)
operator|)
condition|)
block|{
name|path_dhclient_script
operator|=
name|s
expr_stmt|;
block|}
comment|/* first kill of any currently running client */
if|if
condition|(
name|release_mode
condition|)
block|{
comment|/* XXX inelegant hack to prove concept */
name|char
name|command
index|[
literal|1024
index|]
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SNPRINTF
argument_list|)
name|snprintf
argument_list|(
name|command
argument_list|,
literal|1024
argument_list|,
literal|"kill `cat %s`"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"kill `cat %s`"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|log_info
argument_list|(
literal|"%s %s"
argument_list|,
name|message
argument_list|,
name|DHCP_VERSION
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* If we're given a relay agent address to insert, for testing 	   purposes, figure out what it is. */
if|if
condition|(
name|relay
condition|)
block|{
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|relay
argument_list|,
operator|&
name|giaddr
argument_list|)
condition|)
block|{
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|relay
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|giaddr
argument_list|,
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|giaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_fatal
argument_list|(
literal|"%s: no such host"
argument_list|,
name|relay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Default to the DHCP/BOOTP port. */
if|if
condition|(
operator|!
name|local_port
condition|)
block|{
if|if
condition|(
name|relay
operator|&&
name|giaddr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
condition|)
block|{
name|local_port
operator|=
name|htons
argument_list|(
literal|67
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|=
name|getservbyname
argument_list|(
literal|"dhcpc"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ent
condition|)
name|local_port
operator|=
name|htons
argument_list|(
literal|68
argument_list|)
expr_stmt|;
else|else
name|local_port
operator|=
name|ent
operator|->
name|s_port
expr_stmt|;
ifndef|#
directive|ifndef
name|__CYGWIN32__
name|endservent
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If we're faking a relay agent, and we're not using loopback, 	   use the server port, not the client port. */
if|if
condition|(
name|relay
operator|&&
name|giaddr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
condition|)
block|{
name|local_port
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|local_port
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remote_port
operator|=
name|local_port
expr_stmt|;
block|}
else|else
name|remote_port
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|local_port
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* Get the current time... */
name|GET_TIME
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_port
operator|=
name|remote_port
expr_stmt|;
if|if
condition|(
name|server
condition|)
block|{
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|server
argument_list|,
operator|&
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|,
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|sockaddr_broadcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
block|}
block|}
else|else
block|{
name|sockaddr_broadcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
block|}
name|inaddr_any
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* Discover all the network interfaces. */
name|discover_interfaces
argument_list|(
name|DISCOVER_UNCONFIGURED
argument_list|)
expr_stmt|;
comment|/* Parse the dhclient.conf file. */
name|read_client_conf
argument_list|()
expr_stmt|;
comment|/* Parse the lease database. */
name|read_client_leases
argument_list|()
expr_stmt|;
comment|/* Rewrite the lease database... */
name|rewrite_client_leases
argument_list|()
expr_stmt|;
comment|/* XXX */
comment|/* 	config_counter(&snd_counter,&rcv_counter); */
comment|/* If no broadcast interfaces were discovered, call the script 	   and tell it so. */
if|if
condition|(
operator|!
name|interfaces
condition|)
block|{
comment|/* Call dhclient-script with the NBI flag, in case somebody 		   cares. */
name|script_init
argument_list|(
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
argument_list|,
literal|"NBI"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* If we haven't been asked to persist, waiting for new 		   interfaces, then just exit. */
if|if
condition|(
operator|!
name|persist
condition|)
block|{
comment|/* Nothing more to do. */
name|log_info
argument_list|(
literal|"No broadcast interfaces found - exiting."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|release_mode
condition|)
block|{
comment|/* Call the script with the list of interfaces. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
comment|/* If interfaces were specified, don't configure 			   interfaces that weren't specified! */
if|if
condition|(
name|interfaces_requested
operator|&&
operator|(
operator|(
name|ip
operator|->
name|flags
operator|&
operator|(
name|INTERFACE_REQUESTED
operator||
name|INTERFACE_AUTOMATIC
operator|)
operator|)
operator|!=
name|INTERFACE_REQUESTED
operator|)
condition|)
continue|continue;
name|script_init
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|"PREINIT"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
operator|->
name|client
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point, all the interfaces that the script thinks 	   are relevant should be running, so now we once again call 	   discover_interfaces(), and this time ask it to actually set 	   up the interfaces. */
name|discover_interfaces
argument_list|(
name|interfaces_requested
condition|?
name|DISCOVER_REQUESTED
else|:
name|DISCOVER_RUNNING
argument_list|)
expr_stmt|;
comment|/* Make up a seed for the random number generator from current 	   time plus the sum of the last four bytes of each 	   interface's hardware address interpreted as an integer. 	   Not much entropy, but we're booting, so we're not likely to 	   find anything better. */
name|seed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|int
name|junk
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|junk
argument_list|,
operator|&
name|ip
operator|->
name|hw_address
operator|.
name|hbuf
index|[
name|ip
operator|->
name|hw_address
operator|.
name|hlen
operator|-
sizeof|sizeof
name|seed
index|]
argument_list|,
sizeof|sizeof
name|seed
argument_list|)
expr_stmt|;
name|seed
operator|+=
name|junk
expr_stmt|;
block|}
name|srandom
argument_list|(
name|seed
operator|+
name|cur_time
argument_list|)
expr_stmt|;
comment|/* Start a configuration state machine for each interface. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|ip
operator|->
name|flags
operator||=
name|INTERFACE_RUNNING
expr_stmt|;
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
if|if
condition|(
name|release_mode
condition|)
name|do_release
argument_list|(
name|client
argument_list|)
expr_stmt|;
else|else
block|{
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
comment|/* Set up a timeout to start the initialization 				   process. */
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|random
argument_list|()
operator|%
literal|5
argument_list|,
name|state_reboot
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|release_mode
condition|)
return|return
literal|0
return|;
comment|/* Start up a listener for the object management API protocol. */
if|if
condition|(
name|top_level_config
operator|.
name|omapi_port
operator|!=
operator|-
literal|1
condition|)
block|{
name|listener
operator|=
operator|(
name|omapi_object_t
operator|*
operator|)
literal|0
expr_stmt|;
name|result
operator|=
name|omapi_generic_new
argument_list|(
operator|&
name|listener
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate new generic object: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|omapi_protocol_listen
argument_list|(
name|listener
argument_list|,
operator|(
name|unsigned
operator|)
name|top_level_config
operator|.
name|omapi_port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't start OMAPI protocol: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the bootp packet handler... */
name|bootp_packet_handler
operator|=
name|do_packet
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_MALLOC_POOL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE_ON_EXIT
argument_list|)
name|dmalloc_cutoff_generation
operator|=
name|dmalloc_generation
expr_stmt|;
name|dmalloc_longterm
operator|=
name|dmalloc_outstanding
expr_stmt|;
name|dmalloc_outstanding
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* If we're not supposed to wait before getting the address, 	   don't. */
if|if
condition|(
name|nowait
condition|)
name|go_daemon
argument_list|()
expr_stmt|;
comment|/* If we're not going to daemonize, write the pid file 	   now. */
if|if
condition|(
name|no_daemon
operator|||
name|nowait
condition|)
name|write_client_pid_file
argument_list|()
expr_stmt|;
comment|/* Start dispatching packets and timeouts... */
name|dispatch
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|log_info
argument_list|(
literal|"%s %s"
argument_list|,
name|message
argument_list|,
name|DHCP_VERSION
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|arr
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"Usage: dhclient [-1Ddqr] [-nw] [-p<port>] %s"
argument_list|,
literal|"[-s server]"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"                [-cf config-file] [-lf lease-file]%s"
argument_list|,
literal|"[-pf pid-file] [-e VAR=val]"
argument_list|)
expr_stmt|;
name|log_fatal
argument_list|(
literal|"                [-sf script-file] [interface]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|find_class
parameter_list|(
name|struct
name|class
modifier|*
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|check_collection
parameter_list|(
name|packet
parameter_list|,
name|lease
parameter_list|,
name|collection
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|collection
modifier|*
name|collection
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|classify
parameter_list|(
name|packet
parameter_list|,
name|class
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|class
modifier|*
name|class
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|unbill_class
parameter_list|(
name|lease
parameter_list|,
name|class
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|class
modifier|*
name|class
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|find_subnet
parameter_list|(
name|struct
name|subnet
modifier|*
modifier|*
name|sp
parameter_list|,
name|struct
name|iaddr
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Individual States:  *   * Each routine is called from the dhclient_state_machine() in one of  * these conditions:  * -> entering INIT state  * -> recvpacket_flag == 0: timeout in this state  * -> otherwise: received a packet in this state  *  * Return conditions as handled by dhclient_state_machine():  * Returns 1, sendpacket_flag = 1: send packet, reset timer.  * Returns 1, sendpacket_flag = 0: just reset the timer (wait for a milestone).  * Returns 0: finish the nap which was interrupted for no good reason.  *  * Several per-interface variables are used to keep track of the process:  *   active_lease: the lease that is being used on the interface  *                 (null pointer if not configured yet).  *   offered_leases: leases corresponding to DHCPOFFER messages that have  *		     been sent to us by DHCP servers.  *   acked_leases: leases corresponding to DHCPACK messages that have been  *		   sent to us by DHCP servers.  *   sendpacket: DHCP packet we're trying to send.  *   destination: IP address to send sendpacket to  * In addition, there are several relevant per-lease variables.  *   T1_expiry, T2_expiry, lease_expiry: lease milestones  * In the active lease, these control the process of renewing the lease;  * In leases on the acked_leases list, this simply determines when we  * can no longer legitimately use the lease.  */
end_comment

begin_function
name|void
name|state_reboot
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
comment|/* If we don't remember an active lease, go straight to INIT. */
if|if
condition|(
operator|!
name|client
operator|->
name|active
operator|||
name|client
operator|->
name|active
operator|->
name|is_bootp
operator|||
name|client
operator|->
name|active
operator|->
name|expiry
operator|<=
name|cur_time
condition|)
block|{
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are in the rebooting state. */
name|client
operator|->
name|state
operator|=
name|S_REBOOTING
expr_stmt|;
comment|/* make_request doesn't initialize xid because it normally comes 	   from the DHCPDISCOVER, but we haven't sent a DHCPDISCOVER, 	   so pick an xid now. */
name|client
operator|->
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* Make a DHCPREQUEST packet, and set appropriate per-interface 	   flags. */
name|make_request
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Zap the medium list... */
name|client
operator|->
name|medium
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send out the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when a lease has completely expired and we've been unable to    renew it. */
end_comment

begin_function
name|void
name|state_init
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_INIT
argument_list|)
expr_stmt|;
comment|/* Make a DHCPDISCOVER packet, and set appropriate per-interface 	   flags. */
name|make_discover
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|client
operator|->
name|xid
operator|=
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_SELECTING
expr_stmt|;
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Add an immediate timeout to cause the first DHCPDISCOVER packet 	   to go out. */
name|send_discover
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_selecting is called when one or more DHCPOFFER packets have been    received and a configurable period of time has passed. */
end_comment

begin_function
name|void
name|state_selecting
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|picked
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_SELECTING
argument_list|)
expr_stmt|;
comment|/* Cancel state_selecting and send_discover timeouts, since either 	   one could have got us here. */
name|cancel_timeout
argument_list|(
name|state_selecting
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* We have received one or more DHCPOFFER packets.   Currently, 	   the only criterion by which we judge leases is whether or 	   not we get a response when we arp for them. */
name|picked
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|offered_leases
init|;
name|lp
condition|;
name|lp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
comment|/* Check to see if we got an ARPREPLY for the address 		   in this particular lease. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|picked
operator|=
name|lp
expr_stmt|;
name|picked
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|freeit
label|:
name|destroy_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
name|client
operator|->
name|offered_leases
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* If we just tossed all the leases we were offered, go back 	   to square one. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was a BOOTREPLY, we can just take the address right now. */
if|if
condition|(
name|picked
operator|->
name|is_bootp
condition|)
block|{
name|client
operator|->
name|new
operator|=
name|picked
expr_stmt|;
comment|/* Make up some lease expiry times 		   XXX these should be configurable. */
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|cur_time
operator|+
literal|12000
expr_stmt|;
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
operator|+
literal|8000
expr_stmt|;
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
operator|+
literal|10000
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
comment|/* Bind to the address we received. */
name|bind_lease
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go to the REQUESTING state. */
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Make a DHCPREQUEST packet from the lease we picked. */
name|make_request
argument_list|(
name|client
argument_list|,
name|picked
argument_list|)
expr_stmt|;
name|client
operator|->
name|xid
operator|=
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
comment|/* Toss the lease we picked - we'll get it back in a DHCPACK. */
name|destroy_client_lease
argument_list|(
name|picked
argument_list|)
expr_stmt|;
comment|/* Add an immediate timeout to send the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_requesting is called when we receive a DHCPACK message after    having sent out one or more DHCPREQUEST packets. */
end_comment

begin_function
name|void
name|dhcpack
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
if|if
condition|(
name|client
operator|->
name|xid
operator|==
name|packet
operator|->
name|raw
operator|->
name|xid
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|client
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
operator|&
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_debug
argument_list|(
literal|"DHCPACK in wrong transaction."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_debug
argument_list|(
literal|"DHCPACK in wrong state."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|log_info
argument_list|(
literal|"DHCPACK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|log_info
argument_list|(
literal|"packet_to_lease failed."
argument_list|)
expr_stmt|;
return|return;
block|}
name|client
operator|->
name|new
operator|=
name|lease
expr_stmt|;
comment|/* Stop resending DHCPREQUEST. */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* Figure out the lease time. */
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
name|DHO_DHCP_LEASE_TIME
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|.
name|len
operator|>
literal|3
condition|)
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|getULong
argument_list|(
name|ds
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|new
operator|->
name|expiry
condition|)
block|{
name|log_error
argument_list|(
literal|"no expiry time on offered lease."
argument_list|)
expr_stmt|;
comment|/* XXX this is going to be bad - if this _does_ 		   XXX happen, we should probably dynamically  		   XXX disqualify the DHCP server that gave us the 		   XXX bad packet from future selections and 		   XXX then go back into the init state. */
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* A number that looks negative here is really just very large, 	   because the lease expiry offset is unsigned. */
if|if
condition|(
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
literal|0
condition|)
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
comment|/* Take the server-provided renewal time if there is one. */
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
name|DHO_DHCP_RENEWAL_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|.
name|len
operator|>
literal|3
condition|)
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|getULong
argument_list|(
name|ds
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
literal|0
expr_stmt|;
comment|/* If it wasn't specified by the server, calculate it. */
if|if
condition|(
operator|!
name|client
operator|->
name|new
operator|->
name|renewal
condition|)
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|client
operator|->
name|new
operator|->
name|expiry
operator|/
literal|2
expr_stmt|;
comment|/* Now introduce some randomness to the renewal time: */
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
operator|(
operator|(
operator|(
name|client
operator|->
name|new
operator|->
name|renewal
operator|+
literal|3
operator|)
operator|*
literal|3
operator|/
literal|4
operator|)
operator|+
operator|(
name|random
argument_list|()
operator|%
comment|/* XXX NUMS */
operator|(
operator|(
name|client
operator|->
name|new
operator|->
name|renewal
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Same deal with the rebind time. */
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
name|DHO_DHCP_REBINDING_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|client
operator|->
name|new
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|.
name|len
operator|>
literal|3
condition|)
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|getULong
argument_list|(
name|ds
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|new
operator|->
name|rebind
condition|)
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
operator|(
name|client
operator|->
name|new
operator|->
name|expiry
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* XXX NUMS */
comment|/* Make sure our randomness didn't run the renewal time past the 	   rebind time. */
if|if
condition|(
name|client
operator|->
name|new
operator|->
name|renewal
operator|>
name|client
operator|->
name|new
operator|->
name|rebind
condition|)
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
operator|(
name|client
operator|->
name|new
operator|->
name|rebind
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|client
operator|->
name|new
operator|->
name|expiry
operator|+=
name|cur_time
expr_stmt|;
comment|/* Lease lengths can never be negative. */
if|if
condition|(
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|new
operator|->
name|renewal
operator|<
name|cur_time
condition|)
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|TIME_MAX
expr_stmt|;
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|new
operator|->
name|rebind
operator|<
name|cur_time
condition|)
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|TIME_MAX
expr_stmt|;
name|bind_lease
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bind_lease
parameter_list|(
name|client
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|client
operator|->
name|interface
decl_stmt|;
comment|/* Remember the medium. */
name|client
operator|->
name|new
operator|->
name|medium
operator|=
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
name|client
argument_list|,
operator|(
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|?
literal|"BOUND"
else|:
operator|(
name|client
operator|->
name|state
operator|==
name|S_RENEWING
condition|?
literal|"RENEW"
else|:
operator|(
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
condition|?
literal|"REBOOT"
else|:
literal|"REBIND"
operator|)
operator|)
operator|)
argument_list|,
name|client
operator|->
name|new
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|active
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"old_"
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"new_"
argument_list|,
name|client
operator|->
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
comment|/* If the BOUND/RENEW code detects another machine using the 	   offered address, it exits nonzero.  We need to send a 	   DHCPDECLINE and toss the lease. */
if|if
condition|(
name|script_go
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|make_decline
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|new
argument_list|)
expr_stmt|;
name|send_decline
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|destroy_client_lease
argument_list|(
name|client
operator|->
name|new
argument_list|)
expr_stmt|;
name|client
operator|->
name|new
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write out the new lease. */
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|new
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Replace the old active lease with the new one. */
if|if
condition|(
name|client
operator|->
name|active
condition|)
name|destroy_client_lease
argument_list|(
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|client
operator|->
name|active
operator|=
name|client
operator|->
name|new
expr_stmt|;
name|client
operator|->
name|new
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Set up a timeout to start the renewal process. */
name|add_timeout
argument_list|(
name|client
operator|->
name|active
operator|->
name|renewal
argument_list|,
name|state_bound
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"bound to %s -- renewal in %ld seconds."
argument_list|,
name|piaddr
argument_list|(
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|config
operator|->
name|do_forward_update
condition|)
block|{
name|client
operator|->
name|dns_update_timeout
operator|=
literal|1
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
literal|1
argument_list|,
name|client_dns_update_timeout
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* state_bound is called when we've successfully bound to a particular    lease, but the renewal time on that lease has expired.   We are    expected to unicast a DHCPREQUEST to the server that gave us our    original lease. */
end_comment

begin_function
name|void
name|state_bound
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_BOUND
argument_list|)
expr_stmt|;
comment|/* T1 has expired. */
name|make_request
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|client
operator|->
name|xid
operator|=
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|active
operator|->
name|options
argument_list|,
name|DHO_DHCP_SERVER_IDENTIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|active
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|.
name|len
operator|>
literal|3
condition|)
block|{
name|memcpy
argument_list|(
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
name|ds
operator|.
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|client
operator|->
name|destination
operator|.
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
block|}
else|else
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_RENEWING
expr_stmt|;
comment|/* Send the first packet immediately. */
name|send_request
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_stop is called when we've been told to shut down.   We unconfigure    the interfaces, and then stop operating until told otherwise. */
end_comment

begin_function
name|void
name|state_stop
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Cancel all timeouts. */
name|cancel_timeout
argument_list|(
name|state_selecting
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|state_bound
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* If we have an address, unconfigure it. */
if|if
condition|(
name|client
operator|->
name|active
condition|)
block|{
name|script_init
argument_list|(
name|client
argument_list|,
literal|"STOP"
argument_list|,
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"old_"
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|commit_leases
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|write_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|write_host
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_decl
modifier|*
name|host
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|db_startup
parameter_list|(
name|testp
parameter_list|)
name|int
name|testp
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|bootp
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|packet
operator|->
name|raw
operator|->
name|op
operator|!=
name|BOOTREPLY
condition|)
return|return;
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"BOOTREPLY from %s rejected."
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dhcpoffer
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcp
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
name|void
argument_list|(
argument|*handler
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|packet
operator|->
name|packet_type
condition|)
block|{
case|case
name|DHCPOFFER
case|:
name|handler
operator|=
name|dhcpoffer
expr_stmt|;
name|type
operator|=
literal|"DHCPOFFER"
expr_stmt|;
break|break;
case|case
name|DHCPNAK
case|:
name|handler
operator|=
name|dhcpnak
expr_stmt|;
name|type
operator|=
literal|"DHCPNACK"
expr_stmt|;
break|break;
case|case
name|DHCPACK
case|:
name|handler
operator|=
name|dhcpack
expr_stmt|;
name|type
operator|=
literal|"DHCPACK"
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"%s from %s rejected."
argument_list|,
name|type
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
call|(
modifier|*
name|handler
call|)
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcpoffer
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|stop_selecting
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|packet
operator|->
name|packet_type
condition|?
literal|"DHCPOFFER"
else|:
literal|"BOOTREPLY"
decl_stmt|;
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|char
name|obuf
index|[
literal|1024
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_packet
argument_list|(
name|packet
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find a client state that matches the xid... */
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
if|if
condition|(
name|client
operator|->
name|xid
operator|==
name|packet
operator|->
name|raw
operator|->
name|xid
condition|)
break|break;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
operator|!
name|client
operator|||
name|client
operator|->
name|state
operator|!=
name|S_SELECTING
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
operator|&
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_debug
argument_list|(
literal|"%s in wrong transaction."
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%s from %s"
argument_list|,
name|name
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this lease doesn't supply the minimum required parameters, 	   blow it off. */
if|if
condition|(
name|client
operator|->
name|config
operator|->
name|required_options
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|log_info
argument_list|(
literal|"%s: no %s option."
argument_list|,
name|obuf
argument_list|,
operator|(
name|dhcp_universe
operator|.
name|options
index|[
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
index|]
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If we've already seen this lease, don't record it again. */
for|for
control|(
name|lease
operator|=
name|client
operator|->
name|offered_leases
init|;
name|lease
condition|;
name|lease
operator|=
name|lease
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|yiaddr
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
name|log_debug
argument_list|(
literal|"%s: already seen."
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|log_info
argument_list|(
literal|"%s: packet_to_lease failed."
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this lease was acquired through a BOOTREPLY, record that 	   fact. */
if|if
condition|(
operator|!
name|packet
operator|->
name|options_valid
operator|||
operator|!
name|packet
operator|->
name|packet_type
condition|)
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
comment|/* Record the medium under which this lease was offered. */
name|lease
operator|->
name|medium
operator|=
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Figure out when we're supposed to stop selecting. */
name|stop_selecting
operator|=
operator|(
name|client
operator|->
name|first_sending
operator|+
name|client
operator|->
name|config
operator|->
name|select_interval
operator|)
expr_stmt|;
comment|/* If this is the lease we asked for, put it at the head of the 	   list, and don't mess with the arp request timeout. */
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
name|client
operator|->
name|requested_address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|client
operator|->
name|requested_address
operator|.
name|iabuf
argument_list|,
name|client
operator|->
name|requested_address
operator|.
name|len
argument_list|)
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|client
operator|->
name|offered_leases
expr_stmt|;
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
block|}
else|else
block|{
comment|/* Put the lease at the end of the list. */
name|lease
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|offered_leases
condition|)
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
else|else
block|{
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|offered_leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
name|lp
operator|->
name|next
operator|=
name|lease
expr_stmt|;
block|}
block|}
comment|/* If the selecting interval has expired, go immediately to 	   state_selecting().  Otherwise, time out into 	   state_selecting at the select interval. */
if|if
condition|(
name|stop_selecting
operator|<=
literal|0
condition|)
name|state_selecting
argument_list|(
name|client
argument_list|)
expr_stmt|;
else|else
block|{
name|add_timeout
argument_list|(
name|stop_selecting
argument_list|,
name|state_selecting
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"%s"
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a client_lease structure and initialize it from the parameters    in the specified packet. */
end_comment

begin_function
name|struct
name|client_lease
modifier|*
name|packet_to_lease
parameter_list|(
name|packet
parameter_list|,
name|client
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|data_string
name|data
decl_stmt|;
name|lease
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
name|new_client_lease
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|log_error
argument_list|(
literal|"packet_to_lease: no memory to record lease.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|lease
argument_list|)
expr_stmt|;
comment|/* Copy the lease options. */
name|option_state_reference
argument_list|(
operator|&
name|lease
operator|->
name|options
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|lease
operator|->
name|address
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|config
operator|->
name|vendor_space_name
condition|)
block|{
name|i
operator|=
name|DHO_VENDOR_ENCAPSULATED_OPTIONS
expr_stmt|;
comment|/* See if there was a vendor encapsulation option. */
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|client
operator|->
name|config
operator|->
name|vendor_space_name
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|len
condition|)
block|{
name|parse_encapsulated_suboptions
argument_list|(
name|packet
operator|->
name|options
argument_list|,
operator|&
name|dhcp_options
index|[
name|i
index|]
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|,
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Figure out the overload flag. */
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_DHCP_OPTION_OVERLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|len
operator|>
literal|0
condition|)
name|i
operator|=
name|data
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If the server name was filled out, copy it. */
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|2
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* Don't count on the NUL terminator. */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|64
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|!
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
name|len
index|]
condition|)
break|break;
name|lease
operator|->
name|server_name
operator|=
name|dmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|server_name
condition|)
block|{
name|log_error
argument_list|(
literal|"dhcpoffer: no memory for filename.\n"
argument_list|)
expr_stmt|;
name|destroy_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|server_name
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|server_name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Ditto for the filename. */
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|file
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* Don't count on the NUL terminator. */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|64
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|!
name|packet
operator|->
name|raw
operator|->
name|file
index|[
name|len
index|]
condition|)
break|break;
name|lease
operator|->
name|filename
operator|=
name|dmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|filename
condition|)
block|{
name|log_error
argument_list|(
literal|"dhcpoffer: no memory for filename.\n"
argument_list|)
expr_stmt|;
name|destroy_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|execute_statements_in_scope
argument_list|(
operator|(
expr|struct
name|binding_value
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|client
operator|->
name|config
operator|->
name|on_receipt
argument_list|,
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|lease
return|;
block|}
end_function

begin_function
name|void
name|dhcpnak
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
comment|/* Find a client state that matches the xid... */
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
if|if
condition|(
name|client
operator|->
name|xid
operator|==
name|packet
operator|->
name|raw
operator|->
name|xid
condition|)
break|break;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
operator|!
name|client
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
operator|&
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_debug
argument_list|(
literal|"DHCPNAK in wrong transaction."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_debug
argument_list|(
literal|"DHCPNAK in wrong state."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|log_info
argument_list|(
literal|"DHCPNAK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|active
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|log_info
argument_list|(
literal|"DHCPNAK with no active lease.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|destroy_client_lease
argument_list|(
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|client
operator|->
name|active
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Stop sending DHCPREQUEST packets... */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send out a DHCPDISCOVER packet, and set a timeout to send out another    one after the right interval has expired.  If we don't get an offer by    the time we reach the panic interval, call the panic function. */
end_comment

begin_function
name|void
name|send_discover
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|int
name|increase
init|=
literal|1
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're past the panic timeout, call the script and tell it 	   we haven't found anything for this interface yet. */
if|if
condition|(
name|interval
operator|>
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
block|{
name|state_panic
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're selecting media, try the whole list before doing 	   the exponential backoff, but if we've already received an 	   offer, stop looping, because we obviously have it right. */
if|if
condition|(
operator|!
name|client
operator|->
name|offered_leases
operator|&&
name|client
operator|->
name|config
operator|->
name|media
condition|)
block|{
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|again
label|:
if|if
condition|(
name|client
operator|->
name|medium
condition|)
block|{
name|client
operator|->
name|medium
operator|=
name|client
operator|->
name|medium
operator|->
name|next
expr_stmt|;
name|increase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|client
operator|->
name|medium
condition|)
block|{
if|if
condition|(
name|fail
condition|)
name|log_fatal
argument_list|(
literal|"No valid media types for %s!"
argument_list|,
name|client
operator|->
name|interface
operator|->
name|name
argument_list|)
expr_stmt|;
name|client
operator|->
name|medium
operator|=
name|client
operator|->
name|config
operator|->
name|media
expr_stmt|;
name|increase
operator|=
literal|1
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"Trying medium \"%s\" %d"
argument_list|,
name|client
operator|->
name|medium
operator|->
name|string
argument_list|,
name|increase
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
name|client
argument_list|,
literal|"MEDIUM"
argument_list|,
name|client
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|script_go
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* If we're supposed to increase the interval, do so.  If it's 	   currently zero (i.e., we haven't sent any packets yet), set 	   it to one; otherwise, add to it a random number between 	   zero and two times itself.  On average, this means that it 	   will double with every transmission. */
if|if
condition|(
name|increase
condition|)
block|{
if|if
condition|(
operator|!
name|client
operator|->
name|interval
condition|)
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
name|client
operator|->
name|interval
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|client
operator|->
name|interval
operator|>
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|client
operator|->
name|interval
condition|)
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* If the backoff would take us to the panic timeout, just use that 	   as the interval. */
if|if
condition|(
name|cur_time
operator|+
name|client
operator|->
name|interval
operator|>
name|client
operator|->
name|first_sending
operator|+
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
name|client
operator|->
name|interval
operator|=
operator|(
name|client
operator|->
name|first_sending
operator|+
name|client
operator|->
name|config
operator|->
name|timeout
operator|)
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
name|client
operator|->
name|secs
operator|=
name|client
operator|->
name|packet
operator|.
name|secs
expr_stmt|;
name|log_info
argument_list|(
literal|"DHCPDISCOVER on %s to %s port %d interval %ld"
argument_list|,
name|client
operator|->
name|name
condition|?
name|client
operator|->
name|name
else|:
name|client
operator|->
name|interface
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|client
operator|->
name|interval
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|client
operator|->
name|interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|client
operator|->
name|interval
argument_list|,
name|send_discover
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_panic gets called if we haven't received any offers in a preset    amount of time.   When this happens, we try to use existing leases that    haven't yet expired, and failing that, we call the client script and    hope it can do something. */
end_comment

begin_function
name|void
name|state_panic
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|loop
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
name|loop
operator|=
name|lp
operator|=
name|client
operator|->
name|active
expr_stmt|;
name|log_info
argument_list|(
literal|"No DHCPOFFERS received."
argument_list|)
expr_stmt|;
comment|/* We may not have an active lease, but we may have some 	   predefined leases that we can try. */
if|if
condition|(
operator|!
name|client
operator|->
name|active
operator|&&
name|client
operator|->
name|leases
condition|)
goto|goto
name|activate_next
goto|;
comment|/* Run through the list of leases and see if one can be used. */
while|while
condition|(
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|active
operator|->
name|expiry
operator|>
name|cur_time
condition|)
block|{
name|log_info
argument_list|(
literal|"Trying recorded lease %s"
argument_list|,
name|piaddr
argument_list|(
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the client script with the existing 			   parameters. */
name|script_init
argument_list|(
name|client
argument_list|,
literal|"TIMEOUT"
argument_list|,
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"new_"
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
comment|/* If the old lease is still good and doesn't 			   yet need renewal, go into BOUND state and 			   timeout at the renewal time. */
if|if
condition|(
operator|!
name|script_go
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_time
operator|<
name|client
operator|->
name|active
operator|->
name|renewal
condition|)
block|{
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|log_info
argument_list|(
literal|"bound: renewal in %ld %s."
argument_list|,
call|(
name|long
call|)
argument_list|(
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
argument_list|,
literal|"seconds"
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|client
operator|->
name|active
operator|->
name|renewal
argument_list|,
name|state_bound
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|log_info
argument_list|(
literal|"bound: immediate renewal."
argument_list|)
expr_stmt|;
name|state_bound
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are no other leases, give up. */
if|if
condition|(
operator|!
name|client
operator|->
name|leases
condition|)
block|{
name|client
operator|->
name|leases
operator|=
name|client
operator|->
name|active
expr_stmt|;
name|client
operator|->
name|active
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
block|}
name|activate_next
label|:
comment|/* Otherwise, put the active lease at the end of the 		   lease list, and try another lease.. */
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
name|lp
operator|->
name|next
operator|=
name|client
operator|->
name|active
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
block|{
name|lp
operator|->
name|next
operator|->
name|next
operator|=
operator|(
expr|struct
name|client_lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|client
operator|->
name|active
operator|=
name|client
operator|->
name|leases
expr_stmt|;
name|client
operator|->
name|leases
operator|=
name|client
operator|->
name|leases
operator|->
name|next
expr_stmt|;
comment|/* If we already tried this lease, we've exhausted the 		   set of leases, so we might as well give up for 		   now. */
if|if
condition|(
name|client
operator|->
name|active
operator|==
name|loop
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|loop
condition|)
name|loop
operator|=
name|client
operator|->
name|active
expr_stmt|;
block|}
comment|/* No leases were available, or what was available didn't work, so 	   tell the shell script that we failed to allocate an address, 	   and try again later. */
if|if
condition|(
name|onetry
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|log_info
argument_list|(
literal|"Unable to obtain a lease on first try.%s"
argument_list|,
literal|"  Exiting."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"No working leases in persistent database - sleeping."
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
name|client
argument_list|,
literal|"FAIL"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
operator|(
operator|(
name|client
operator|->
name|config
operator|->
name|retry_interval
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
operator|(
name|random
argument_list|()
operator|%
name|client
operator|->
name|config
operator|->
name|retry_interval
operator|)
operator|)
argument_list|,
name|state_init
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_request
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|struct
name|sockaddr_in
name|destination
decl_stmt|;
name|struct
name|in_addr
name|from
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're in the INIT-REBOOT or REQUESTING state and we're 	   past the reboot timeout, go to INIT and see if we can 	   DISCOVER an address... */
comment|/* XXX In the INIT-REBOOT state, if we don't get an ACK, it 	   means either that we're on a network with no DHCP server, 	   or that our server is down.  In the latter case, assuming 	   that there is a backup DHCP server, DHCPDISCOVER will get 	   us a new address, but we could also have successfully 	   reused our old address.  In the former case, we're hosed 	   anyway.  This is not a win-prone situation. */
if|if
condition|(
operator|(
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|)
operator|&&
name|interval
operator|>
name|client
operator|->
name|config
operator|->
name|reboot_timeout
condition|)
block|{
name|cancel
label|:
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're in the reboot state, make sure the media is set up 	   correctly. */
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|&&
operator|!
name|client
operator|->
name|medium
operator|&&
name|client
operator|->
name|active
operator|->
name|medium
condition|)
block|{
name|script_init
argument_list|(
name|client
argument_list|,
literal|"MEDIUM"
argument_list|,
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
comment|/* If the medium we chose won't fly, go to INIT state. */
if|if
condition|(
name|script_go
argument_list|(
name|client
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
comment|/* Record the medium. */
name|client
operator|->
name|medium
operator|=
name|client
operator|->
name|active
operator|->
name|medium
expr_stmt|;
block|}
comment|/* If the lease has expired, relinquish the address and go back 	   to the INIT state. */
if|if
condition|(
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|>
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
block|{
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
name|client
argument_list|,
literal|"EXPIRE"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"old_"
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* Now do a preinit on the interface so that we can 		   discover a new address. */
name|script_init
argument_list|(
name|client
argument_list|,
literal|"PREINIT"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do the exponential backoff... */
if|if
condition|(
operator|!
name|client
operator|->
name|interval
condition|)
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
block|{
name|client
operator|->
name|interval
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|client
operator|->
name|interval
operator|>
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
comment|/* If the backoff would take us to the expiry time, just set the 	   timeout to the expiry time. */
if|if
condition|(
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|+
name|client
operator|->
name|interval
operator|>
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|active
operator|->
name|expiry
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* If the lease T2 time has elapsed, or if we're not yet bound, 	   broadcast the DHCPREQUEST rather than unicasting. */
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|cur_time
operator|>
name|client
operator|->
name|active
operator|->
name|rebind
condition|)
name|destination
operator|.
name|sin_addr
operator|=
name|sockaddr_broadcast
operator|.
name|sin_addr
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|destination
operator|.
name|sin_port
operator|=
name|remote_port
expr_stmt|;
name|destination
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|destination
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|destination
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_RENEWING
operator|||
name|client
operator|->
name|state
operator|==
name|S_REBINDING
condition|)
name|memcpy
argument_list|(
operator|&
name|from
argument_list|,
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|from
argument_list|)
expr_stmt|;
else|else
name|from
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|client
operator|->
name|secs
expr_stmt|;
else|else
block|{
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"DHCPREQUEST on %s to %s port %d"
argument_list|,
name|client
operator|->
name|name
condition|?
name|client
operator|->
name|name
else|:
name|client
operator|->
name|interface
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|destination
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|destination
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_BROADCAST
operator|&&
name|fallback_interface
condition|)
name|result
operator|=
name|send_packet
argument_list|(
name|fallback_interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|client
operator|->
name|interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|client
operator|->
name|interval
argument_list|,
name|send_request
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_decline
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|log_info
argument_list|(
literal|"DHCPDECLINE on %s to %s port %d"
argument_list|,
name|client
operator|->
name|name
condition|?
name|client
operator|->
name|name
else|:
name|client
operator|->
name|interface
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|client
operator|->
name|interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_release
parameter_list|(
name|cpp
parameter_list|)
name|void
modifier|*
name|cpp
decl_stmt|;
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cpp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|sockaddr_in
name|destination
decl_stmt|;
name|struct
name|in_addr
name|from
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|from
argument_list|,
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|from
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|destination
operator|.
name|sin_port
operator|=
name|remote_port
expr_stmt|;
name|destination
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|destination
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|destination
expr_stmt|;
endif|#
directive|endif
comment|/* Set the lease to end now, so that we don't accidentally 	   reuse it if we restart before the old expiry time. */
name|client
operator|->
name|active
operator|->
name|expiry
operator|=
name|client
operator|->
name|active
operator|->
name|renewal
operator|=
name|client
operator|->
name|active
operator|->
name|rebind
operator|=
name|cur_time
expr_stmt|;
if|if
condition|(
operator|!
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't release lease: lease write failed."
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_info
argument_list|(
literal|"DHCPRELEASE on %s to %s port %d"
argument_list|,
name|client
operator|->
name|name
condition|?
name|client
operator|->
name|name
else|:
name|client
operator|->
name|interface
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|destination
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|destination
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallback_interface
condition|)
name|result
operator|=
name|send_packet
argument_list|(
name|fallback_interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Send out a packet. */
name|result
operator|=
name|send_packet
argument_list|(
name|client
operator|->
name|interface
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
operator|(
expr|struct
name|hardware
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_client_options
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|,
name|type
parameter_list|,
name|sid
parameter_list|,
name|rip
parameter_list|,
name|prl
parameter_list|,
name|op
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|u_int8_t
modifier|*
name|type
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|sid
decl_stmt|;
name|struct
name|iaddr
modifier|*
name|rip
decl_stmt|;
name|u_int32_t
modifier|*
name|prl
decl_stmt|;
name|struct
name|option_state
modifier|*
modifier|*
name|op
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* If there are any leftover options, get rid of them. */
if|if
condition|(
operator|*
name|op
condition|)
name|option_state_dereference
argument_list|(
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Allocate space for options. */
name|option_state_allocate
argument_list|(
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Send the server identifier if provided. */
if|if
condition|(
name|sid
condition|)
name|save_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
operator|*
name|op
argument_list|,
name|sid
argument_list|)
expr_stmt|;
name|oc
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send the requested address if provided. */
if|if
condition|(
name|rip
condition|)
block|{
name|client
operator|->
name|requested_address
operator|=
operator|*
name|rip
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|make_const_option_cache
argument_list|(
operator|&
name|oc
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|rip
operator|->
name|iabuf
argument_list|,
name|rip
operator|->
name|len
argument_list|,
operator|&
name|dhcp_options
index|[
name|DHO_DHCP_REQUESTED_ADDRESS
index|]
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_error
argument_list|(
literal|"can't make requested address cache."
argument_list|)
expr_stmt|;
else|else
block|{
name|save_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
operator|*
name|op
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|client
operator|->
name|requested_address
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|make_const_option_cache
argument_list|(
operator|&
name|oc
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
operator|&
name|dhcp_options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_error
argument_list|(
literal|"can't make message type."
argument_list|)
expr_stmt|;
else|else
block|{
name|save_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
operator|*
name|op
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prl
condition|)
block|{
comment|/* Figure out how many parameters were requested. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|prl
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|i
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_error
argument_list|(
literal|"can't make parameter list buffer."
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|prl
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|data
index|[
name|i
index|]
operator|=
name|prl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|make_const_option_cache
argument_list|(
operator|&
name|oc
argument_list|,
operator|&
name|bp
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
literal|0
argument_list|,
name|i
argument_list|,
operator|&
name|dhcp_options
index|[
name|DHO_DHCP_PARAMETER_REQUEST_LIST
index|]
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_error
argument_list|(
literal|"can't make option cache"
argument_list|)
expr_stmt|;
else|else
block|{
name|save_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
operator|*
name|op
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Run statements that need to be run on transmission. */
if|if
condition|(
name|client
operator|->
name|config
operator|->
name|on_transmission
condition|)
name|execute_statements_in_scope
argument_list|(
operator|(
expr|struct
name|binding_value
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
name|lease
condition|?
name|lease
operator|->
name|options
else|:
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
operator|)
argument_list|,
operator|*
name|op
argument_list|,
operator|&
name|global_scope
argument_list|,
name|client
operator|->
name|config
operator|->
name|on_transmission
argument_list|,
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_discover
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|discover
init|=
name|DHCPDISCOVER
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
init|=
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|make_client_options
argument_list|(
name|client
argument_list|,
name|lease
argument_list|,
operator|&
name|discover
argument_list|,
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
argument_list|,
name|lease
condition|?
operator|&
name|lease
operator|->
name|address
else|:
operator|(
expr|struct
name|iaddr
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|config
operator|->
name|requested_options
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
comment|/* Set up the option buffer... */
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|data_string
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* filled in by send_discover. */
if|if
condition|(
name|can_receive_unicast_unconfigured
argument_list|(
name|client
operator|->
name|interface
argument_list|)
condition|)
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
name|htons
argument_list|(
name|BOOTP_BROADCAST
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|client
operator|->
name|packet
operator|.
name|ciaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|client
operator|->
name|packet
operator|.
name|yiaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|client
operator|->
name|packet
operator|.
name|siaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|=
name|giaddr
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
operator|&
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_request
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|request
init|=
name|DHCPREQUEST
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|digest
decl_stmt|;
name|unsigned
name|char
modifier|*
name|old_digest_loc
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_DHCP_SERVER_IDENTIFIER
argument_list|)
expr_stmt|;
else|else
name|oc
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
name|make_client_options
argument_list|(
name|client
argument_list|,
name|lease
argument_list|,
operator|&
name|request
argument_list|,
name|oc
argument_list|,
operator|(
operator|(
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|)
condition|?
operator|&
name|lease
operator|->
name|address
else|:
operator|(
expr|struct
name|iaddr
operator|*
operator|)
literal|0
operator|)
argument_list|,
name|client
operator|->
name|config
operator|->
name|requested_options
argument_list|,
operator|&
name|client
operator|->
name|sent_options
argument_list|)
expr_stmt|;
comment|/* Set up the option buffer... */
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
operator|&
name|global_scope
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|data_string
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|client
operator|->
name|xid
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
comment|/* If we own the address we're requesting, put it in ciaddr; 	   otherwise set ciaddr to zero. */
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|S_BOUND
operator|||
name|client
operator|->
name|state
operator|==
name|S_RENEWING
operator|||
name|client
operator|->
name|state
operator|==
name|S_REBINDING
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_receive_unicast_unconfigured
argument_list|(
name|client
operator|->
name|interface
argument_list|)
condition|)
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
name|htons
argument_list|(
name|BOOTP_BROADCAST
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|state
operator|!=
name|S_BOUND
operator|&&
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
condition|)
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|=
name|giaddr
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
operator|&
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_decline
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|decline
init|=
name|DHCPDECLINE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
init|=
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
decl_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_DHCP_SERVER_IDENTIFIER
argument_list|)
expr_stmt|;
name|make_client_options
argument_list|(
name|client
argument_list|,
name|lease
argument_list|,
operator|&
name|decline
argument_list|,
name|oc
argument_list|,
operator|&
name|lease
operator|->
name|address
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
comment|/* Set up the option buffer... */
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|data_string
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|option_state_dereference
argument_list|(
operator|&
name|options
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|client
operator|->
name|xid
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
if|if
condition|(
name|can_receive_unicast_unconfigured
argument_list|(
name|client
operator|->
name|interface
argument_list|)
condition|)
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
name|htons
argument_list|(
name|BOOTP_BROADCAST
argument_list|)
expr_stmt|;
comment|/* ciaddr must always be zero. */
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|=
name|giaddr
expr_stmt|;
name|memcpy
argument_list|(
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
operator|&
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|make_release
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|unsigned
name|char
name|request
init|=
name|DHCPRELEASE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
init|=
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_DHCP_SERVER_IDENTIFIER
argument_list|)
expr_stmt|;
name|make_client_options
argument_list|(
name|client
argument_list|,
name|lease
argument_list|,
operator|&
name|request
argument_list|,
name|oc
argument_list|,
operator|(
expr|struct
name|iaddr
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
comment|/* Set up the option buffer... */
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|client
operator|->
name|packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|data_string
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|config
operator|->
name|vendor_space_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|option_state_dereference
argument_list|(
operator|&
name|options
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|=
name|giaddr
expr_stmt|;
name|memcpy
argument_list|(
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
operator|&
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PACKET
name|dump_raw
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|client
operator|->
name|packet
argument_list|,
name|client
operator|->
name|packet_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|destroy_client_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|dfree
argument_list|(
name|lease
operator|->
name|server_name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|dfree
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|option_state_dereference
argument_list|(
operator|&
name|lease
operator|->
name|options
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
name|leaseFile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rewrite_client_leases
parameter_list|()
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|leaseFile
condition|)
name|fclose
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
name|log_error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write out all the leases attached to configured interfaces that 	   we know about. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|lp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|active
condition|)
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out any leases that are attached to interfaces that aren't 	   currently configured. */
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
for|for
control|(
name|lp
operator|=
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|lp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|active
condition|)
name|write_client_lease
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_lease_option
parameter_list|(
name|struct
name|option_cache
modifier|*
name|oc
parameter_list|,
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|!=
operator|&
name|dhcp_universe
condition|)
block|{
name|name
operator|=
name|u
operator|->
name|name
expr_stmt|;
name|dot
operator|=
literal|"."
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|dot
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  option %s%s%s %s;\n"
argument_list|,
name|name
argument_list|,
name|dot
argument_list|,
name|oc
operator|->
name|option
operator|->
name|name
argument_list|,
name|pretty_print_option
argument_list|(
name|oc
operator|->
name|option
argument_list|,
name|ds
operator|.
name|data
argument_list|,
name|ds
operator|.
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|write_client_lease
parameter_list|(
name|client
parameter_list|,
name|lease
parameter_list|,
name|rewrite
parameter_list|,
name|makesure
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|int
name|rewrite
decl_stmt|;
name|int
name|makesure
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
specifier|static
name|int
name|leases_written
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|pair
modifier|*
name|hash
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|rewrite
condition|)
block|{
if|if
condition|(
name|leases_written
operator|++
operator|>
literal|20
condition|)
block|{
name|rewrite_client_leases
argument_list|()
expr_stmt|;
name|leases_written
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the lease came from the config file, we don't need to stash 	   a copy in the lease database. */
if|if
condition|(
name|lease
operator|->
name|is_static
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
comment|/* XXX */
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
name|log_error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"lease {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|is_bootp
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  bootp;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  interface \"%s\";\n"
argument_list|,
name|client
operator|->
name|interface
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  name \"%s\";\n"
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  fixed-address %s;\n"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
block|{
name|s
operator|=
name|quotify_string
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  filename \"%s\";\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|dfree
argument_list|(
name|s
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|errors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
block|{
name|s
operator|=
name|quotify_string
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  server-name \"%s\";\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|dfree
argument_list|(
name|s
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|errors
expr_stmt|;
block|}
if|if
condition|(
name|lease
operator|->
name|medium
condition|)
block|{
name|s
operator|=
name|quotify_string
argument_list|(
name|lease
operator|->
name|medium
operator|->
name|string
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  medium \"%s\";\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|++
name|errors
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|dfree
argument_list|(
name|s
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|errors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lease
operator|->
name|options
operator|->
name|universe_count
condition|;
name|i
operator|++
control|)
block|{
name|option_space_foreach
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|universes
index|[
name|i
index|]
argument_list|,
name|client
argument_list|,
name|write_lease_option
argument_list|)
expr_stmt|;
block|}
comment|/* Note: the following is not a Y2K bug - it's a Y1.9K bug.   Until 	   somebody invents a time machine, I think we can safely disregard 	   it. */
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|renewal
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  renew %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|rebind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  rebind %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|expiry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  expire %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errors
operator|&&
name|makesure
condition|)
block|{
if|if
condition|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|leaseFile
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_info
argument_list|(
literal|"write_client_lease: %m"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|errors
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Variables holding name of script and file pointer for writing to    script.   Needless to say, this is not reentrant - only one script    can be invoked at a time. */
end_comment

begin_decl_stmt
name|char
name|scriptName
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|scriptFile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|script_init
parameter_list|(
name|client
parameter_list|,
name|reason
parameter_list|,
name|medium
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
name|struct
name|string_list
modifier|*
name|medium
decl_stmt|;
block|{
name|struct
name|string_list
modifier|*
name|sl
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|client
condition|)
block|{
for|for
control|(
name|sl
operator|=
name|client
operator|->
name|env
init|;
name|sl
condition|;
name|sl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sl
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|env
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
name|client
operator|->
name|envc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|interface
condition|)
block|{
name|client_envadd
argument_list|(
name|client
argument_list|,
literal|""
argument_list|,
literal|"interface"
argument_list|,
literal|"%s"
argument_list|,
name|client
operator|->
name|interface
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|name
condition|)
name|client_envadd
argument_list|(
name|client
argument_list|,
literal|""
argument_list|,
literal|"client"
argument_list|,
literal|"%s"
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|medium
condition|)
name|client_envadd
argument_list|(
name|client
argument_list|,
literal|""
argument_list|,
literal|"medium"
argument_list|,
literal|"%s"
argument_list|,
name|medium
operator|->
name|string
argument_list|)
expr_stmt|;
name|client_envadd
argument_list|(
name|client
argument_list|,
literal|""
argument_list|,
literal|"reason"
argument_list|,
literal|"%s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|client_envadd
argument_list|(
name|client
argument_list|,
literal|""
argument_list|,
literal|"pid"
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|envadd_state
block|{
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|client_option_envadd
parameter_list|(
name|struct
name|option_cache
modifier|*
name|oc
parameter_list|,
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|envadd_state
modifier|*
name|es
init|=
name|stuff
decl_stmt|;
name|struct
name|data_string
name|data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluate_option_cache
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|len
condition|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|dhcp_option_ev_name
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|oc
operator|->
name|option
argument_list|)
condition|)
block|{
name|client_envadd
argument_list|(
name|es
operator|->
name|client
argument_list|,
name|es
operator|->
name|prefix
argument_list|,
name|name
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|pretty_print_option
argument_list|(
name|oc
operator|->
name|option
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|script_write_params
parameter_list|(
name|client
parameter_list|,
name|prefix
parameter_list|,
name|lease
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|data_string
name|data
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|pair
modifier|*
name|hash
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|envadd_state
name|es
decl_stmt|;
name|es
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|es
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"ip_address"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the benefit of Linux (and operating systems which may 	   have similar needs), compute the network address based on 	   the supplied ip address and netmask, if provided.  Also 	   compute the broadcast address (the host address all ones 	   broadcast address, not the host address all zeroes 	   broadcast address). */
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_SUBNET_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|data
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|len
operator|>
literal|3
condition|)
block|{
name|struct
name|iaddr
name|netmask
decl_stmt|,
name|subnet
decl_stmt|,
name|broadcast
decl_stmt|;
name|memcpy
argument_list|(
name|netmask
operator|.
name|iabuf
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|netmask
operator|.
name|len
operator|=
name|data
operator|.
name|len
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|subnet
operator|=
name|subnet_number
argument_list|(
name|lease
operator|->
name|address
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
operator|.
name|len
condition|)
block|{
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"network_number"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|subnet
argument_list|)
argument_list|)
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|lease
operator|->
name|options
argument_list|,
name|DHO_BROADCAST_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oc
operator|||
operator|!
operator|(
name|evaluate_option_cache
argument_list|(
operator|&
name|data
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
block|{
name|broadcast
operator|=
name|broadcast_addr
argument_list|(
name|subnet
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|broadcast
operator|.
name|len
condition|)
block|{
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"broadcast_address"
argument_list|,
literal|"%s"
argument_list|,
name|piaddr
argument_list|(
name|broadcast
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"filename"
argument_list|,
literal|"%s"
argument_list|,
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"server_name"
argument_list|,
literal|"%s"
argument_list|,
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lease
operator|->
name|options
operator|->
name|universe_count
condition|;
name|i
operator|++
control|)
block|{
name|option_space_foreach
argument_list|(
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|lease
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|universes
index|[
name|i
index|]
argument_list|,
operator|&
name|es
argument_list|,
name|client_option_envadd
argument_list|)
expr_stmt|;
block|}
name|client_envadd
argument_list|(
name|client
argument_list|,
name|prefix
argument_list|,
literal|"expiry"
argument_list|,
literal|"%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|lease
operator|->
name|expiry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|script_go
parameter_list|(
name|client
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|scriptName
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|char
modifier|*
name|epp
index|[
literal|3
index|]
decl_stmt|;
name|char
name|reason
index|[]
init|=
literal|"REASON=NBI"
decl_stmt|;
specifier|static
name|char
name|client_path
index|[]
init|=
name|CLIENT_PATH
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|wpid
decl_stmt|,
name|wstatus
decl_stmt|;
if|if
condition|(
name|client
condition|)
name|scriptName
operator|=
name|client
operator|->
name|config
operator|->
name|script_name
expr_stmt|;
else|else
name|scriptName
operator|=
name|top_level_config
operator|.
name|script_name
expr_stmt|;
name|envp
operator|=
name|dmalloc
argument_list|(
operator|(
operator|(
name|client
condition|?
name|client
operator|->
name|envc
else|:
literal|2
operator|)
operator|+
name|client_env_count
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|envp
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for client script environment."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Copy out the environment specified on the command line, 	   if any. */
for|for
control|(
name|sp
operator|=
name|client_env
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|sp
operator|->
name|string
expr_stmt|;
block|}
comment|/* Copy out the environment specified by dhclient. */
if|if
condition|(
name|client
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|client
operator|->
name|env
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|sp
operator|->
name|string
expr_stmt|;
block|}
block|}
else|else
block|{
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|reason
expr_stmt|;
block|}
comment|/* Set $PATH. */
name|envp
index|[
name|i
operator|++
index|]
operator|=
name|client_path
expr_stmt|;
name|envp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|scriptName
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
condition|)
block|{
do|do
block|{
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wpid
operator|!=
name|pid
operator|&&
name|wpid
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|wpid
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"wait: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|i
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|i
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|i
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|STDERR_FILENO
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|execve
argument_list|(
name|scriptName
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"execve (%s, ...): %m"
argument_list|,
name|scriptName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|client
operator|->
name|env
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|env
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
name|client
operator|->
name|envc
operator|=
literal|0
expr_stmt|;
block|}
name|dfree
argument_list|(
name|envp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|GET_TIME
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
return|return
operator|(
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
else|:
operator|-
name|WTERMSIG
argument_list|(
name|wstatus
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|client_envadd
parameter_list|(
name|struct
name|client_state
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|spbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|val
decl_stmt|;
name|va_list
name|list
decl_stmt|;
name|va_start
argument_list|(
name|list
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|spbuf
argument_list|,
sizeof|sizeof
name|spbuf
argument_list|,
name|fmt
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|val
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
comment|/* = */
operator|+
name|len
operator|+
sizeof|sizeof
expr|*
name|val
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return;
name|s
operator|=
name|val
operator|->
name|string
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|spbuf
condition|)
block|{
name|va_start
argument_list|(
name|list
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|fmt
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|s
argument_list|,
name|spbuf
argument_list|)
expr_stmt|;
name|val
operator|->
name|next
operator|=
name|client
operator|->
name|env
expr_stmt|;
name|client
operator|->
name|env
operator|=
name|val
expr_stmt|;
name|client
operator|->
name|envc
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dhcp_option_ev_name
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|option
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|universe
operator|!=
operator|&
name|dhcp_universe
condition|)
block|{
name|s
operator|=
name|option
operator|->
name|universe
operator|->
name|name
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|option
operator|->
name|name
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|buflen
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|buf
index|[
name|j
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
else|else
name|buf
index|[
name|j
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|s
operator|=
name|option
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|buflen
condition|)
return|return
literal|0
return|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
literal|2
condition|)
do|;
name|buf
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|go_daemon
parameter_list|()
block|{
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't become a daemon if the user requested otherwise. */
if|if
condition|(
name|no_daemon
condition|)
block|{
name|write_client_pid_file
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Only do it once. */
if|if
condition|(
name|state
condition|)
return|return;
name|state
operator|=
literal|1
expr_stmt|;
comment|/* Stop logging to stderr... */
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* Become a daemon... */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|log_fatal
argument_list|(
literal|"Can't fork daemon: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pid
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Become session leader and get pid... */
name|pid
operator|=
name|setsid
argument_list|()
expr_stmt|;
comment|/* Close standard I/O descriptors. */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reopen them on /dev/null. */
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|log_perror
operator|=
literal|0
expr_stmt|;
comment|/* No sense logging to /dev/null. */
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|write_client_pid_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_client_pid_file
parameter_list|()
block|{
name|FILE
modifier|*
name|pf
decl_stmt|;
name|int
name|pfdesc
decl_stmt|;
name|pfdesc
operator|=
name|open
argument_list|(
name|path_dhclient_pid
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfdesc
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't create %s: %m"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
return|return;
block|}
name|pf
operator|=
name|fdopen
argument_list|(
name|pfdesc
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
condition|)
name|log_error
argument_list|(
literal|"Can't fdopen %s: %m"
argument_list|,
name|path_dhclient_pid
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pf
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|client_location_changed
parameter_list|()
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|client
operator|->
name|state
condition|)
block|{
case|case
name|S_SELECTING
case|:
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_BOUND
case|:
name|cancel_timeout
argument_list|(
name|state_bound
argument_list|,
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_REBOOTING
case|:
case|case
name|S_REQUESTING
case|:
case|case
name|S_RENEWING
case|:
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_INIT
case|:
case|case
name|S_REBINDING
case|:
case|case
name|S_STOPPED
case|:
break|break;
block|}
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_reboot
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|do_release
parameter_list|(
name|client
parameter_list|)
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
block|{
name|struct
name|data_string
name|ds
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
comment|/* Pick a random xid. */
name|client
operator|->
name|xid
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* is there even a lease to release? */
if|if
condition|(
name|client
operator|->
name|active
condition|)
block|{
comment|/* Make a DHCPRELEASE packet, and set appropriate per-interface 		   flags. */
name|make_release
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|active
operator|->
name|options
argument_list|,
name|DHO_DHCP_SERVER_IDENTIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
name|client
operator|->
name|active
operator|->
name|options
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|.
name|len
operator|>
literal|3
condition|)
block|{
name|memcpy
argument_list|(
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
name|ds
operator|.
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|client
operator|->
name|destination
operator|.
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
block|}
else|else
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|client
operator|->
name|interval
operator|=
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Zap the medium list... */
name|client
operator|->
name|medium
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Send out the first and only DHCPRELEASE packet. */
name|send_release
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* Do the client script RELEASE operation. */
name|script_init
argument_list|(
name|client
argument_list|,
literal|"RELEASE"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
name|client
argument_list|,
literal|"old_"
argument_list|,
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
comment|/* Cancel any timeouts. */
name|cancel_timeout
argument_list|(
name|state_bound
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|state_init
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|state_reboot
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|S_STOPPED
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dhclient_interface_shutdown_hook
parameter_list|(
name|struct
name|interface_info
modifier|*
name|interface
parameter_list|)
block|{
name|do_release
argument_list|(
name|interface
operator|->
name|client
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|dhclient_interface_discovery_hook
parameter_list|(
name|struct
name|interface_info
modifier|*
name|tmp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|last
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
comment|/* See if we can find the client from dummy_interfaces */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Remove from dummy_interfaces */
if|if
condition|(
name|last
condition|)
block|{
name|ip
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
name|interface_reference
argument_list|(
operator|&
name|ip
argument_list|,
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|next
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ip
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
name|interface_reference
argument_list|(
operator|&
name|ip
argument_list|,
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|next
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy "client" to tmp */
if|if
condition|(
name|ip
operator|->
name|client
condition|)
block|{
name|tmp
operator|->
name|client
operator|=
name|ip
operator|->
name|client
expr_stmt|;
name|tmp
operator|->
name|client
operator|->
name|interface
operator|=
name|tmp
expr_stmt|;
block|}
name|interface_dereference
argument_list|(
operator|&
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|ip
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhclient_interface_startup_hook
parameter_list|(
name|struct
name|interface_info
modifier|*
name|interface
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
comment|/* This code needs some rethinking.   It doesn't test against 	   a signal name, and it just kind of bulls into doing something 	   that may or may not be appropriate. */
if|if
condition|(
name|interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|interface
operator|->
name|next
argument_list|,
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|interface
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|discover_interfaces
argument_list|(
name|DISCOVER_UNCONFIGURED
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
comment|/* If interfaces were specified, don't configure 		   interfaces that weren't specified! */
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|INTERFACE_RUNNING
operator|||
operator|(
name|ip
operator|->
name|flags
operator|&
operator|(
name|INTERFACE_REQUESTED
operator||
name|INTERFACE_AUTOMATIC
operator|)
operator|)
operator|!=
name|INTERFACE_REQUESTED
condition|)
continue|continue;
name|script_init
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|"PREINIT"
argument_list|,
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|(
name|ip
operator|->
name|client
argument_list|)
expr_stmt|;
block|}
name|discover_interfaces
argument_list|(
name|interfaces_requested
condition|?
name|DISCOVER_REQUESTED
else|:
name|DISCOVER_RUNNING
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|INTERFACE_RUNNING
condition|)
continue|continue;
name|ip
operator|->
name|flags
operator||=
name|INTERFACE_RUNNING
expr_stmt|;
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
comment|/* Set up a timeout to start the initialization 			   process. */
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|random
argument_list|()
operator|%
literal|5
argument_list|,
name|state_reboot
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* The client should never receive a relay agent information option,    so if it does, log it and discard it. */
end_comment

begin_function
name|int
name|parse_agent_information_option
parameter_list|(
name|packet
parameter_list|,
name|len
parameter_list|,
name|data
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The client never sends relay agent information options. */
end_comment

begin_function
name|unsigned
name|cons_agent_information_options
parameter_list|(
name|cfg_options
parameter_list|,
name|outpacket
parameter_list|,
name|agentix
parameter_list|,
name|length
parameter_list|)
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|outpacket
decl_stmt|;
name|unsigned
name|agentix
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
block|{
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shutdown_exit
parameter_list|(
name|void
modifier|*
name|foo
parameter_list|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_set_control_state
parameter_list|(
name|control_object_state_t
name|oldstate
parameter_list|,
name|control_object_state_t
name|newstate
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
comment|/* Do the right thing for each interface. */
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
for|for
control|(
name|client
operator|=
name|ip
operator|->
name|client
init|;
name|client
condition|;
name|client
operator|=
name|client
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|server_startup
case|:
return|return
name|ISC_R_SUCCESS
return|;
case|case
name|server_running
case|:
return|return
name|ISC_R_SUCCESS
return|;
case|case
name|server_shutdown
case|:
if|if
condition|(
name|client
operator|->
name|active
operator|&&
name|client
operator|->
name|active
operator|->
name|expiry
operator|>
name|cur_time
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|config
operator|->
name|do_forward_update
condition|)
name|client_dns_update
argument_list|(
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_release
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|server_hibernate
case|:
name|state_stop
argument_list|(
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|server_awaken
case|:
name|state_reboot
argument_list|(
name|client
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newstate
operator|==
name|server_shutdown
condition|)
name|add_timeout
argument_list|(
name|cur_time
operator|+
literal|1
argument_list|,
name|shutdown_exit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Called after a timeout if the DNS update failed on the previous try.    Retries the update, and if it times out, schedules a retry after    ten times as long of a wait. */
end_comment

begin_function
name|void
name|client_dns_update_timeout
parameter_list|(
name|void
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|client_state
modifier|*
name|client
init|=
name|cp
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|active
condition|)
block|{
name|status
operator|=
name|client_dns_update
argument_list|(
name|client
argument_list|,
literal|1
argument_list|,
operator|(
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_TIMEDOUT
condition|)
block|{
name|client
operator|->
name|dns_update_timeout
operator|*=
literal|10
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|client
operator|->
name|dns_update_timeout
argument_list|,
name|client_dns_update_timeout
argument_list|,
name|client
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See if we should do a DNS update, and if so, do it. */
end_comment

begin_function
name|isc_result_t
name|client_dns_update
parameter_list|(
name|struct
name|client_state
modifier|*
name|client
parameter_list|,
name|int
name|addp
parameter_list|,
name|int
name|ttl
parameter_list|)
block|{
name|struct
name|data_string
name|ddns_fqdn
decl_stmt|,
name|ddns_fwd_name
decl_stmt|,
name|ddns_dhcid
decl_stmt|,
name|client_identifier
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|int
name|ignorep
decl_stmt|;
name|int
name|result
decl_stmt|;
name|isc_result_t
name|rcode
decl_stmt|;
comment|/* If we didn't send an FQDN option, we certainly aren't going to 	   be doing an update. */
if|if
condition|(
operator|!
name|client
operator|->
name|sent_options
condition|)
return|return
name|ISC_R_SUCCESS
return|;
comment|/* If we don't have a lease, we can't do an update. */
if|if
condition|(
operator|!
name|client
operator|->
name|active
condition|)
return|return
name|ISC_R_SUCCESS
return|;
comment|/* If we set the no client update flag, don't do the update. */
if|if
condition|(
operator|(
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
name|FQDN_NO_CLIENT_UPDATE
argument_list|)
operator|)
operator|&&
name|evaluate_boolean_option_cache
argument_list|(
operator|&
name|ignorep
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
name|ISC_R_SUCCESS
return|;
comment|/* If we set the "server, please update" flag, or didn't set it 	   to false, don't do the update. */
if|if
condition|(
operator|!
operator|(
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
name|FQDN_SERVER_UPDATE
argument_list|)
operator|)
operator|||
name|evaluate_boolean_option_cache
argument_list|(
operator|&
name|ignorep
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
name|ISC_R_SUCCESS
return|;
comment|/* If no FQDN option was supplied, don't do the update. */
name|memset
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ddns_fwd_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
name|FQDN_FQDN
argument_list|)
operator|)
operator|||
operator|!
name|evaluate_option_cache
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
name|ISC_R_SUCCESS
return|;
comment|/* Make a dhcid string out of either the client identifier, 	   if we are sending one, or the interface's MAC address, 	   otherwise. */
name|memset
argument_list|(
operator|&
name|ddns_dhcid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ddns_dhcid
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client_identifier
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|client_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
name|DHO_DHCP_CLIENT_IDENTIFIER
argument_list|)
operator|)
operator|&&
name|evaluate_option_cache
argument_list|(
operator|&
name|client_identifier
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|sent_options
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|result
operator|=
name|get_dhcid
argument_list|(
operator|&
name|ddns_dhcid
argument_list|,
name|DHO_DHCP_CLIENT_IDENTIFIER
argument_list|,
name|client_identifier
operator|.
name|data
argument_list|,
name|client_identifier
operator|.
name|len
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|client_identifier
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|get_dhcid
argument_list|(
operator|&
name|ddns_dhcid
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
argument_list|,
name|client
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|data_string_forget
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
comment|/* Start the resolver, if necessary. */
if|if
condition|(
operator|!
name|resolver_inited
condition|)
block|{
name|minires_ninit
argument_list|(
operator|&
name|resolver_state
argument_list|)
expr_stmt|;
name|resolver_inited
operator|=
literal|1
expr_stmt|;
name|resolver_state
operator|.
name|retrans
operator|=
literal|1
expr_stmt|;
name|resolver_state
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Perform updates. 	 */
if|if
condition|(
name|ddns_fwd_name
operator|.
name|len
operator|&&
name|ddns_dhcid
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|addp
condition|)
name|rcode
operator|=
name|ddns_update_a
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
name|client
operator|->
name|active
operator|->
name|address
argument_list|,
operator|&
name|ddns_dhcid
argument_list|,
name|ttl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rcode
operator|=
name|ddns_remove_a
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
name|client
operator|->
name|active
operator|->
name|address
argument_list|,
operator|&
name|ddns_dhcid
argument_list|)
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|ddns_fwd_name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ddns_dhcid
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
end_function

end_unit

