begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /proj/cvs/isc/DHCP/dst/dst_api.c,v 1.1 2001/02/22 07:22:08 mellon Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Portions Copyright (c) 1995-1998 by Trusted Information Systems, Inc.  *  * Permission to use, copy modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND TRUSTED INFORMATION SYSTEMS  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL  * TRUSTED INFORMATION SYSTEMS BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  * WITH THE USE OR PERFORMANCE OF THE SOFTWARE.  */
end_comment

begin_comment
comment|/*  * This file contains the interface between the DST API and the crypto API.  * This is the only file that needs to be changed if the crypto system is  * changed.  Exported functions are:  * void dst_init()	 Initialize the toolkit  * int  dst_check_algorithm()   Function to determines if alg is suppored.  * int  dst_compare_keys()      Function to compare two keys for equality.  * int  dst_sign_data()         Incremental signing routine.  * int  dst_verify_data()       Incremental verify routine.  * int  dst_generate_key()      Function to generate new KEY  * DST_KEY *dst_read_key()      Function to retrieve private/public KEY.  * void dst_write_key()         Function to write out a key.  * DST_KEY *dst_dnskey_to_key() Function to convert DNS KEY RR to a DST  *				KEY structure.  * int dst_key_to_dnskey() 	Function to return a public key in DNS   *				format binary  * DST_KEY *dst_buffer_to_key() Converst a data in buffer to KEY  * int *dst_key_to_buffer()	Writes out DST_KEY key matterial in buffer  * void dst_free_key()       	Releases all memory referenced by key structure  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"minires/minires.h"
end_include

begin_include
include|#
directive|include
file|"arpa/nameser.h"
end_include

begin_include
include|#
directive|include
file|"dst_internal.h"
end_include

begin_comment
comment|/* static variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dst_func
modifier|*
name|dst_t_func
index|[
name|DST_MAX_ALGS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|key_file_fmt_str
init|=
literal|"Private-key-format: v%s\nAlgorithm: %d (%s)\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dst_path
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal I/O functions */
end_comment

begin_function_decl
specifier|static
name|DST_KEY
modifier|*
name|dst_s_read_public_key
parameter_list|(
specifier|const
name|char
modifier|*
name|in_name
parameter_list|,
specifier|const
name|unsigned
name|in_id
parameter_list|,
name|int
name|in_alg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dst_s_read_private_key_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|DST_KEY
modifier|*
name|pk_key
parameter_list|,
name|unsigned
name|in_id
parameter_list|,
name|int
name|in_alg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dst_s_write_public_key
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dst_s_write_private_key
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* internal function to set up data structure */
end_comment

begin_function_decl
specifier|static
name|DST_KEY
modifier|*
name|dst_s_get_key_struct
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|,
specifier|const
name|u_int32_t
name|flags
parameter_list|,
specifier|const
name|int
name|protocol
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  dst_init  *	This function initializes the Digital Signature Toolkit.  *	Right now, it just checks the DSTKEYPATH environment variable.  *  Parameters  *	none  *  Returns  *	none  */
end_comment

begin_function
name|void
name|dst_init
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|done_init
operator|!=
literal|0
condition|)
return|return;
name|done_init
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|getenv
argument_list|(
literal|"DSTKEYPATH"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PATH_MAX
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"%s is longer than %d characters, ignoring\n"
operator|,
name|s
operator|,
name|PATH_MAX
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"%s is not a valid directory\n"
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|dp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|int
name|l
decl_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|dp
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dp
index|[
name|l
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|dst_path
operator|=
name|dp
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|dst_t_func
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_t_func
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first one is selected */
if|#
directive|if
literal|0
block|dst_bsafe_init(); 	dst_rsaref_init();
endif|#
directive|endif
name|dst_hmac_md5_init
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|dst_eay_dss_init(); 	dst_cylink_init();
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  dst_check_algorithm  *	This function determines if the crypto system for the specified  *	algorithm is present.  *  Parameters  *	alg     1       KEY_RSA  *		3       KEY_DSA  *	      157     KEY_HMAC_MD5  *		      future algorithms TBD and registered with IANA.  *  Returns  *	1 - The algorithm is available.  *	0 - The algorithm is not available.  */
end_comment

begin_function
name|int
name|dst_check_algorithm
parameter_list|(
specifier|const
name|int
name|alg
parameter_list|)
block|{
return|return
operator|(
name|dst_t_func
index|[
name|alg
index|]
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * dst_s_get_key_struct   *	This function allocates key structure and fills in some of the   *	fields of the structure.   * Parameters:   *	name:     the name of the key   *	alg:      the algorithm number   *	flags:    the dns flags of the key  *	protocol: the dns protocol of the key  *	bits:     the size of the key  * Returns:  *       NULL if error  *       valid pointer otherwise  */
end_comment

begin_function
specifier|static
name|DST_KEY
modifier|*
name|dst_s_get_key_struct
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|,
specifier|const
name|u_int32_t
name|flags
parameter_list|,
specifier|const
name|int
name|protocol
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|)
block|{
name|DST_KEY
modifier|*
name|new_key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dst_check_algorithm
argument_list|(
name|alg
argument_list|)
condition|)
comment|/* make sure alg is available */
name|new_key
operator|=
operator|(
name|DST_KEY
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|new_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
argument_list|)
expr_stmt|;
name|new_key
operator|->
name|dk_key_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new_key
operator|->
name|dk_alg
operator|=
name|alg
expr_stmt|;
name|new_key
operator|->
name|dk_flags
operator|=
name|flags
expr_stmt|;
name|new_key
operator|->
name|dk_proto
operator|=
name|protocol
expr_stmt|;
name|new_key
operator|->
name|dk_KEY_struct
operator|=
name|NULL
expr_stmt|;
name|new_key
operator|->
name|dk_key_size
operator|=
name|bits
expr_stmt|;
name|new_key
operator|->
name|dk_func
operator|=
name|dst_t_func
index|[
name|alg
index|]
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_compare_keys  *	Compares two keys for equality.  *  Parameters  *	key1, key2      Two keys to be compared.  *  Returns  *	0	       The keys are equal.  *	non-zero	The keys are not equal.  */
end_comment

begin_function
name|int
name|dst_compare_keys
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key1
parameter_list|,
specifier|const
name|DST_KEY
modifier|*
name|key2
parameter_list|)
block|{
if|if
condition|(
name|key1
operator|==
name|key2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|key1
operator|==
name|NULL
operator|||
name|key2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|4
operator|)
return|;
if|if
condition|(
name|key1
operator|->
name|dk_alg
operator|!=
name|key2
operator|->
name|dk_alg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|key1
operator|->
name|dk_key_size
operator|!=
name|key2
operator|->
name|dk_key_size
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|key1
operator|->
name|dk_id
operator|!=
name|key2
operator|->
name|dk_id
condition|)
return|return
operator|(
literal|3
operator|)
return|;
return|return
operator|(
name|key1
operator|->
name|dk_func
operator|->
name|compare
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_sign_data  *	An incremental signing function.  Data is signed in steps.  *	First the context must be initialized (SIG_MODE_INIT).  *	Then data is hashed (SIG_MODE_UPDATE).  Finally the signature  *	itself is created (SIG_MODE_FINAL).  This function can be called  *	once with INIT, UPDATE and FINAL modes all set, or it can be   *	called separately with a different mode set for each step.  The  *	UPDATE step can be repeated.  * Parameters  *	mode    A bit mask used to specify operation(s) to be performed.  *		  SIG_MODE_INIT	   1   Initialize digest  *		  SIG_MODE_UPDATE	 2   Add data to digest  *		  SIG_MODE_FINAL	  4   Generate signature  *					      from signature  *		  SIG_MODE_ALL (SIG_MODE_INIT,SIG_MODE_UPDATE,SIG_MODE_FINAL  *	data    Data to be signed.  *	len     The length in bytes of data to be signed.  *	in_key  Contains a private key to sign with.  *		  KEY structures should be handled (created, converted,  *		  compared, stored, freed) by the DST.  *	signature  *	      The location to which the signature will be written.  *	sig_len Length of the signature field in bytes.  * Return  *	 0      Successfull INIT or Update operation  *>0      success FINAL (sign) operation  *<0      failure  */
end_comment

begin_function
name|int
name|dst_sign_data
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|,
name|DST_KEY
modifier|*
name|in_key
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
specifier|const
name|unsigned
name|len
parameter_list|,
name|u_char
modifier|*
name|signature
parameter_list|,
specifier|const
name|unsigned
name|sig_len
parameter_list|)
block|{
name|DUMP
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|len
argument_list|,
literal|"dst_sign_data()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|SIG_MODE_FINAL
operator|&&
operator|(
name|in_key
operator|->
name|dk_KEY_struct
operator|==
name|NULL
operator|||
name|signature
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|MISSING_KEY_OR_SIGNATURE
operator|)
return|;
if|if
condition|(
name|in_key
operator|->
name|dk_func
operator|&&
name|in_key
operator|->
name|dk_func
operator|->
name|sign
condition|)
return|return
operator|(
name|in_key
operator|->
name|dk_func
operator|->
name|sign
argument_list|(
name|mode
argument_list|,
name|in_key
argument_list|,
name|context
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|)
operator|)
return|;
return|return
operator|(
name|UNKNOWN_KEYALG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_verify_data  *	An incremental verify function.  Data is verified in steps.  *	First the context must be initialized (SIG_MODE_INIT).  *	Then data is hashed (SIG_MODE_UPDATE).  Finally the signature  *	is verified (SIG_MODE_FINAL).  This function can be called  *	once with INIT, UPDATE and FINAL modes all set, or it can be  *	called separately with a different mode set for each step.  The  *	UPDATE step can be repeated.  *  Parameters  *	mode	Operations to perform this time.  *		      SIG_MODE_INIT       1   Initialize digest  *		      SIG_MODE_UPDATE     2   add data to digest  *		      SIG_MODE_FINAL      4   verify signature  *		      SIG_MODE_ALL  *			  (SIG_MODE_INIT,SIG_MODE_UPDATE,SIG_MODE_FINAL)  *	data	Data to pass through the hash function.  *	len	 Length of the data in bytes.  *	in_key      Key for verification.  *	signature   Location of signature.  *	sig_len     Length of the signature in bytes.  *  Returns  *	0	   Verify success  *	Non-Zero    Verify Failure  */
end_comment

begin_function
name|int
name|dst_verify_data
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|,
name|DST_KEY
modifier|*
name|in_key
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
specifier|const
name|unsigned
name|len
parameter_list|,
specifier|const
name|u_char
modifier|*
name|signature
parameter_list|,
specifier|const
name|unsigned
name|sig_len
parameter_list|)
block|{
name|DUMP
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|len
argument_list|,
literal|"dst_verify_data()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|SIG_MODE_FINAL
operator|&&
operator|(
name|in_key
operator|->
name|dk_KEY_struct
operator|==
name|NULL
operator|||
name|signature
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|MISSING_KEY_OR_SIGNATURE
operator|)
return|;
if|if
condition|(
name|in_key
operator|->
name|dk_func
operator|==
name|NULL
operator|||
name|in_key
operator|->
name|dk_func
operator|->
name|verify
operator|==
name|NULL
condition|)
return|return
operator|(
name|UNSUPPORTED_KEYALG
operator|)
return|;
return|return
operator|(
name|in_key
operator|->
name|dk_func
operator|->
name|verify
argument_list|(
name|mode
argument_list|,
name|in_key
argument_list|,
name|context
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|signature
argument_list|,
name|sig_len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_read_private_key  *	Access a private key.  First the list of private keys that have  *	already been read in is searched, then the key accessed on disk.  *	If the private key can be found, it is returned.  If the key cannot  *	be found, a null pointer is returned.  The options specify required  *	key characteristics.  If the private key requested does not have  *	these characteristics, it will not be read.  *  Parameters  *	in_keyname  The private key name.  *	in_id	    The id of the private key.  *	options     DST_FORCE_READ  Read from disk - don't use a previously  *				      read key.  *		  DST_CAN_SIGN    The key must be useable for signing.  *		  DST_NO_AUTHEN   The key must be useable for authentication.  *		  DST_STANDARD    Return any key   *  Returns  *	NULL	If there is no key found in the current directory or  *		      this key has not been loaded before.  *	!NULL       Success - KEY structure returned.  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|dst_read_key
parameter_list|(
specifier|const
name|char
modifier|*
name|in_keyname
parameter_list|,
specifier|const
name|unsigned
name|in_id
parameter_list|,
specifier|const
name|int
name|in_alg
parameter_list|,
specifier|const
name|int
name|type
parameter_list|)
block|{
name|char
name|keyname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|DST_KEY
modifier|*
name|dg_key
init|=
name|NULL
decl_stmt|,
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|in_alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_private_key(): Algorithm %d not suppored\n"
operator|,
name|in_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|&&
operator|(
name|DST_PUBLIC
operator||
name|DST_PRIVATE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|in_keyname
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_private_key(): Null key name passed in\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|strcpy
argument_list|(
name|keyname
argument_list|,
name|in_keyname
argument_list|)
expr_stmt|;
comment|/* before I read in the public key, check if it is allowed to sign */
if|if
condition|(
operator|(
name|pubkey
operator|=
name|dst_s_read_public_key
argument_list|(
name|keyname
argument_list|,
name|in_id
argument_list|,
name|in_alg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|DST_PUBLIC
condition|)
return|return
name|pubkey
return|;
if|if
condition|(
operator|!
operator|(
name|dg_key
operator|=
name|dst_s_get_key_struct
argument_list|(
name|keyname
argument_list|,
name|pubkey
operator|->
name|dk_alg
argument_list|,
name|pubkey
operator|->
name|dk_flags
argument_list|,
name|pubkey
operator|->
name|dk_proto
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|dg_key
operator|)
return|;
comment|/* Fill in private key and some fields in the general key structure */
if|if
condition|(
name|dst_s_read_private_key_file
argument_list|(
name|keyname
argument_list|,
name|dg_key
argument_list|,
name|pubkey
operator|->
name|dk_id
argument_list|,
name|pubkey
operator|->
name|dk_alg
argument_list|)
operator|==
literal|0
condition|)
name|dg_key
operator|=
name|dst_free_key
argument_list|(
name|dg_key
argument_list|)
expr_stmt|;
name|pubkey
operator|=
name|dst_free_key
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|dg_key
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dst_write_key
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|,
specifier|const
name|int
name|type
parameter_list|)
block|{
name|int
name|pub
init|=
literal|0
decl_stmt|,
name|priv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|key
operator|->
name|dk_alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_key(): Algorithm %d not suppored\n"
operator|,
name|key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNSUPPORTED_KEYALG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|DST_PRIVATE
operator||
name|DST_PUBLIC
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|&
name|DST_PUBLIC
condition|)
if|if
condition|(
operator|(
name|pub
operator|=
name|dst_s_write_public_key
argument_list|(
name|key
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pub
operator|)
return|;
if|if
condition|(
name|type
operator|&
name|DST_PRIVATE
condition|)
if|if
condition|(
operator|(
name|priv
operator|=
name|dst_s_write_private_key
argument_list|(
name|key
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|priv
operator|)
return|;
return|return
operator|(
name|priv
operator|+
name|pub
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_write_private_key  *	Write a private key to disk.  The filename will be of the form:  *	K<key->dk_name>+<key->dk_alg>+<key->dk_id>.<private key suffix>.  *	If there is already a file with this name, an error is returned.  *  *  Parameters  *	key     A DST managed key structure that contains  *	      all information needed about a key.  *  Return  *>= 0    Correct behavior.  Returns length of encoded key value  *		  written to disk.  *<  0    error.  */
end_comment

begin_function
specifier|static
name|int
name|dst_s_write_private_key
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|)
block|{
name|u_char
name|encoded_block
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|;
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* First encode the key into the portable key format */
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|key
operator|->
name|dk_KEY_struct
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* null key has no private key */
if|if
condition|(
name|key
operator|->
name|dk_func
operator|==
name|NULL
operator|||
name|key
operator|->
name|dk_func
operator|->
name|to_file_fmt
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_private_key(): Unsupported operation %d\n"
operator|,
name|key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|=
name|key
operator|->
name|dk_func
operator|->
name|to_file_fmt
argument_list|(
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|encoded_block
argument_list|,
sizeof|sizeof
argument_list|(
name|encoded_block
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_private_key(): Failed encoding private RSA bsafe key %d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
comment|/* Now I can create the file I want to use */
name|dst_s_build_filename
argument_list|(
name|file
argument_list|,
name|key
operator|->
name|dk_key_name
argument_list|,
name|key
operator|->
name|dk_id
argument_list|,
name|key
operator|->
name|dk_alg
argument_list|,
name|PRIVATE_KEY
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Do not overwrite an existing file */
if|if
condition|(
operator|(
name|fp
operator|=
name|dst_s_fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|,
literal|0600
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|nn
decl_stmt|;
if|if
condition|(
operator|(
name|nn
operator|=
name|fwrite
argument_list|(
name|encoded_block
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|len
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_private_key(): Write failure on %s %d != %d errno=%d\n"
operator|,
name|file
operator|,
name|out_len
operator|,
name|nn
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_private_key(): Can not create file %s\n"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|6
operator|)
return|;
block|}
name|memset
argument_list|(
name|encoded_block
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *  *  dst_read_public_key  *	Read a public key from disk and store in a DST key structure.  *  Parameters  *	in_name	 K<in_name><in_id>.<public key suffix> is the  *		      filename of the key file to be read.  *  Returns  *	NULL	    If the key does not exist or no name is supplied.  *	NON-NULL	Initalized key structure if the key exists.  */
end_comment

begin_function
specifier|static
name|DST_KEY
modifier|*
name|dst_s_read_public_key
parameter_list|(
specifier|const
name|char
modifier|*
name|in_name
parameter_list|,
specifier|const
name|unsigned
name|in_id
parameter_list|,
name|int
name|in_alg
parameter_list|)
block|{
name|unsigned
name|flags
decl_stmt|,
name|len
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|alg
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|name
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|enckey
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|,
modifier|*
name|notspace
decl_stmt|;
name|u_char
name|deckey
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|in_name
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_public_key(): No key name given\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dst_s_build_filename
argument_list|(
name|name
argument_list|,
name|in_name
argument_list|,
name|in_id
argument_list|,
name|in_alg
argument_list|,
name|PUBLIC_KEY
argument_list|,
name|PATH_MAX
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_public_key(): Cannot make filename from %s, %d, and %s\n"
operator|,
name|in_name
operator|,
name|in_id
operator|,
name|PUBLIC_KEY
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Open the file and read it's formatted contents up to key 	 * File format: 	 *    domain.name [ttl] [IN] KEY<flags><protocol><algorithm><key> 	 * flags, proto, alg stored as decimal (or hex numbers FIXME). 	 * (FIXME: handle parentheses for line continuation.) 	 */
if|if
condition|(
operator|(
name|fp
operator|=
name|dst_s_fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_public_key(): Public Key not found %s\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Skip domain name, which ends at first blank */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* Skip blank to get to next field */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* Skip optional TTL -- if initial digit, skip whole word. */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
comment|/* Skip optional "IN" */
if|if
condition|(
name|c
operator|==
literal|'I'
operator|||
name|c
operator|==
literal|'i'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
comment|/* Locate and skip "KEY" */
if|if
condition|(
name|c
operator|!=
literal|'K'
operator|&&
name|c
operator|!=
literal|'k'
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"\"KEY\" doesn't appear in file: %s"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* return the charcter to the input field */
comment|/* Handle hex!! FIXME.  */
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|alg
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_public_key(): Can not read flag/proto/alg field from %s\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* read in the key string */
name|fgets
argument_list|(
name|enckey
argument_list|,
sizeof|sizeof
argument_list|(
name|enckey
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* If we aren't at end-of-file, something is wrong.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"Key too long in file: %s"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|enckey
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* discard \n */
name|enckey
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove leading spaces */
for|for
control|(
name|notspace
operator|=
operator|(
name|char
operator|*
operator|)
name|enckey
init|;
name|isspace
argument_list|(
operator|*
name|notspace
argument_list|)
condition|;
name|len
operator|--
control|)
name|notspace
operator|++
expr_stmt|;
name|dlen
operator|=
name|b64_pton
argument_list|(
name|notspace
argument_list|,
name|deckey
argument_list|,
sizeof|sizeof
argument_list|(
name|deckey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|<
literal|0
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_public_key: bad return from b64_pton = %d"
operator|,
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* store key and info in a key structure that is returned */
comment|/*	return dst_store_public_key(in_name, alg, proto, 666, flags, deckey, 				    dlen);*/
return|return
name|dst_buffer_to_key
argument_list|(
name|in_name
argument_list|,
name|alg
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|,
name|deckey
argument_list|,
operator|(
name|unsigned
operator|)
name|dlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_write_public_key  *	Write a key to disk in DNS format.  *  Parameters  *	key     Pointer to a DST key structure.  *  Returns  *	0       Failure  *	1       Success  */
end_comment

begin_function
specifier|static
name|int
name|dst_s_write_public_key
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|u_char
name|out_key
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|;
name|char
name|enc_key
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|out_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|out_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_public_key(): No key specified \n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|=
name|dst_key_to_dnskey
argument_list|(
name|key
argument_list|,
name|out_key
argument_list|,
sizeof|sizeof
argument_list|(
name|out_key
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make the filename */
if|if
condition|(
name|dst_s_build_filename
argument_list|(
name|filename
argument_list|,
name|key
operator|->
name|dk_key_name
argument_list|,
name|key
operator|->
name|dk_id
argument_list|,
name|key
operator|->
name|dk_alg
argument_list|,
name|PUBLIC_KEY
argument_list|,
name|PATH_MAX
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_write_public_key(): Cannot make filename from %s, %d, and %s\n"
operator|,
name|key
operator|->
name|dk_key_name
operator|,
name|key
operator|->
name|dk_id
operator|,
name|PUBLIC_KEY
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* create public key file */
if|if
condition|(
operator|(
name|fp
operator|=
name|dst_s_fopen
argument_list|(
name|filename
argument_list|,
literal|"w+"
argument_list|,
literal|0644
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"DST_write_public_key: open of file:%s failed (errno=%d)\n"
operator|,
name|filename
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*write out key first base64 the key data */
if|if
condition|(
name|key
operator|->
name|dk_flags
operator|&
name|DST_EXTEND_FLAG
condition|)
name|b64_ntop
argument_list|(
operator|&
name|out_key
index|[
literal|6
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|-
literal|6
argument_list|)
argument_list|,
name|enc_key
argument_list|,
sizeof|sizeof
argument_list|(
name|enc_key
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b64_ntop
argument_list|(
operator|&
name|out_key
index|[
literal|4
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|-
literal|4
argument_list|)
argument_list|,
name|enc_key
argument_list|,
sizeof|sizeof
argument_list|(
name|enc_key
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s IN KEY %d %d %d %s\n"
argument_list|,
name|key
operator|->
name|dk_key_name
argument_list|,
name|key
operator|->
name|dk_flags
argument_list|,
name|key
operator|->
name|dk_proto
argument_list|,
name|key
operator|->
name|dk_alg
argument_list|,
name|enc_key
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_dnskey_to_public_key  *	This function converts the contents of a DNS KEY RR into a DST  *	key structure.  *  Paramters  *	len	 Length of the RDATA of the KEY RR RDATA  *	rdata	 A pointer to the the KEY RR RDATA.  *	in_name     Key name to be stored in key structure.  *  Returns  *	NULL	    Failure  *	NON-NULL	Success.  Pointer to key structure.  *			Caller's responsibility to free() it.  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|dst_dnskey_to_key
parameter_list|(
specifier|const
name|char
modifier|*
name|in_name
parameter_list|,
specifier|const
name|u_char
modifier|*
name|rdata
parameter_list|,
specifier|const
name|unsigned
name|len
parameter_list|)
block|{
name|DST_KEY
modifier|*
name|key_st
decl_stmt|;
name|int
name|alg
decl_stmt|;
name|int
name|start
init|=
name|DST_KEY_START
decl_stmt|;
if|if
condition|(
name|rdata
operator|==
name|NULL
operator|||
name|len
operator|<=
name|DST_KEY_ALG
condition|)
comment|/* no data */
return|return
operator|(
name|NULL
operator|)
return|;
name|alg
operator|=
operator|(
name|u_int8_t
operator|)
name|rdata
index|[
name|DST_KEY_ALG
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_dnskey_to_key(): Algorithm %d not suppored\n"
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|key_st
operator|=
name|dst_s_get_key_struct
argument_list|(
name|in_name
argument_list|,
name|alg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|in_name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|key_st
operator|->
name|dk_flags
operator|=
name|dst_s_get_int16
argument_list|(
name|rdata
argument_list|)
expr_stmt|;
name|key_st
operator|->
name|dk_proto
operator|=
operator|(
name|u_int16_t
operator|)
name|rdata
index|[
name|DST_KEY_PROT
index|]
expr_stmt|;
if|if
condition|(
name|key_st
operator|->
name|dk_flags
operator|&
name|DST_EXTEND_FLAG
condition|)
block|{
name|u_int32_t
name|ext_flags
decl_stmt|;
name|ext_flags
operator|=
operator|(
name|u_int32_t
operator|)
name|dst_s_get_int16
argument_list|(
operator|&
name|rdata
index|[
name|DST_EXT_FLAG
index|]
argument_list|)
expr_stmt|;
name|key_st
operator|->
name|dk_flags
operator|=
name|key_st
operator|->
name|dk_flags
operator||
operator|(
name|ext_flags
operator|<<
literal|16
operator|)
expr_stmt|;
name|start
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 	 * now point to the begining of the data representing the encoding 	 * of the key 	 */
if|if
condition|(
name|key_st
operator|->
name|dk_func
operator|&&
name|key_st
operator|->
name|dk_func
operator|->
name|from_dns_key
condition|)
block|{
if|if
condition|(
name|key_st
operator|->
name|dk_func
operator|->
name|from_dns_key
argument_list|(
name|key_st
argument_list|,
operator|&
name|rdata
index|[
name|start
index|]
argument_list|,
name|len
operator|-
name|start
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
name|key_st
operator|)
return|;
block|}
else|else
name|EREPORT
argument_list|(
operator|(
literal|"dst_dnskey_to_public_key(): unsuppored alg %d\n"
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|key_st
argument_list|)
expr_stmt|;
return|return
operator|(
name|key_st
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_public_key_to_dnskey  *	Function to encode a public key into DNS KEY wire format   *  Parameters  *	key	     Key structure to encode.  *	out_storage     Location to write the encoded key to.  *	out_len	 Size of the output array.  *  Returns  *<0      Failure  *>=0     Number of bytes written to out_storage  */
end_comment

begin_function
name|int
name|dst_key_to_dnskey
parameter_list|(
specifier|const
name|DST_KEY
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
name|out_storage
parameter_list|,
specifier|const
name|unsigned
name|out_len
parameter_list|)
block|{
name|u_int16_t
name|val
decl_stmt|;
name|int
name|loc
init|=
literal|0
decl_stmt|;
name|int
name|enc_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|key
operator|->
name|dk_alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_key_to_dnskey(): Algorithm %d not suppored\n"
operator|,
name|key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNSUPPORTED_KEYALG
operator|)
return|;
block|}
name|memset
argument_list|(
name|out_storage
argument_list|,
literal|0
argument_list|,
name|out_len
argument_list|)
expr_stmt|;
name|val
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|key
operator|->
name|dk_flags
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|out_storage
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|out_storage
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|loc
operator|+=
literal|2
expr_stmt|;
name|out_storage
index|[
name|loc
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|key
operator|->
name|dk_proto
expr_stmt|;
name|out_storage
index|[
name|loc
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|key
operator|->
name|dk_alg
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|dk_flags
operator|>
literal|0xffff
condition|)
block|{
comment|/* Extended flags */
name|val
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|key
operator|->
name|dk_flags
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|out_storage
index|[
name|loc
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|out_storage
index|[
name|loc
operator|+
literal|1
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|loc
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|dk_KEY_struct
operator|==
name|NULL
condition|)
return|return
operator|(
name|loc
operator|)
return|;
if|if
condition|(
name|key
operator|->
name|dk_func
operator|&&
name|key
operator|->
name|dk_func
operator|->
name|to_dns_key
condition|)
block|{
name|enc_len
operator|=
name|key
operator|->
name|dk_func
operator|->
name|to_dns_key
argument_list|(
name|key
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|out_storage
index|[
name|loc
index|]
argument_list|,
name|out_len
operator|-
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc_len
operator|>
literal|0
condition|)
return|return
operator|(
name|enc_len
operator|+
name|loc
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|EREPORT
argument_list|(
operator|(
literal|"dst_key_to_dnskey(): Unsupported ALG %d\n"
operator|,
name|key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_buffer_to_key  *	Function to encode a string of raw data into a DST key  *  Parameters  *	alg		The algorithm (HMAC only)  *	key		A pointer to the data  *	keylen		The length of the data  *  Returns  *	NULL	    an error occurred  *	NON-NULL	the DST key  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|dst_buffer_to_key
parameter_list|(
specifier|const
name|char
modifier|*
name|key_name
parameter_list|,
comment|/* name of the key */
specifier|const
name|int
name|alg
parameter_list|,
comment|/* algorithm */
specifier|const
name|unsigned
name|flags
parameter_list|,
comment|/* dns flags */
specifier|const
name|int
name|protocol
parameter_list|,
comment|/* dns protocol */
specifier|const
name|u_char
modifier|*
name|key_buf
parameter_list|,
comment|/* key in dns wire fmt */
specifier|const
name|unsigned
name|key_len
parameter_list|)
comment|/* size of key */
block|{
name|DST_KEY
modifier|*
name|dkey
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_buffer_to_key(): Algorithm %d not suppored\n"
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dkey
operator|=
name|dst_s_get_key_struct
argument_list|(
name|key_name
argument_list|,
name|alg
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|dkey
operator|->
name|dk_func
operator|!=
name|NULL
operator|&&
name|dkey
operator|->
name|dk_func
operator|->
name|from_dns_key
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dkey
operator|->
name|dk_func
operator|->
name|from_dns_key
argument_list|(
name|dkey
argument_list|,
name|key_buf
argument_list|,
name|key_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_buffer_to_key(): dst_buffer_to_hmac failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_free_key
argument_list|(
name|dkey
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dkey
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dst_key_to_buffer
parameter_list|(
name|DST_KEY
modifier|*
name|key
parameter_list|,
name|u_char
modifier|*
name|out_buff
parameter_list|,
name|unsigned
name|buf_len
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* this function will extrac the secret of HMAC into a buffer */
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|key
operator|->
name|dk_func
operator|!=
name|NULL
operator|&&
name|key
operator|->
name|dk_func
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|key
operator|->
name|dk_func
operator|->
name|to_dns_key
argument_list|(
name|key
argument_list|,
name|out_buff
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|len
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_s_read_private_key_file  *     Function reads in private key from a file.  *     Fills out the KEY structure.  * Parameters  *     name    Name of the key to be read.  *     pk_key  Structure that the key is returned in.  *     in_id   Key identifier (tag)  * Return  *     1 if everthing works  *     0 if there is any problem  */
end_comment

begin_function
specifier|static
name|int
name|dst_s_read_private_key_file
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|DST_KEY
modifier|*
name|pk_key
parameter_list|,
name|unsigned
name|in_id
parameter_list|,
name|int
name|in_alg
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|,
name|alg
decl_stmt|,
name|len
decl_stmt|,
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|file_major
decl_stmt|,
name|file_minor
decl_stmt|;
name|int
name|id
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|u_char
name|in_buff
index|[
name|RAW_KEY_SIZE
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|pk_key
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_private_key_file(): No key name given\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Make the filename */
if|if
condition|(
name|dst_s_build_filename
argument_list|(
name|filename
argument_list|,
name|name
argument_list|,
name|in_id
argument_list|,
name|in_alg
argument_list|,
name|PRIVATE_KEY
argument_list|,
name|PATH_MAX
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_read_private_key(): Cannot make filename from %s, %d, and %s\n"
operator|,
name|name
operator|,
name|in_id
operator|,
name|PRIVATE_KEY
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* first check if we can find the key file */
if|if
condition|(
operator|(
name|fp
operator|=
name|dst_s_fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file: Could not open file %s in directory %s\n"
operator|,
name|filename
operator|,
name|dst_path
index|[
literal|0
index|]
condition|?
name|dst_path
else|:
operator|(
name|char
operator|*
operator|)
name|getcwd
argument_list|(
name|NULL
argument_list|,
name|PATH_MAX
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* now read the header info from the file */
if|if
condition|(
operator|(
name|cnt
operator|=
name|fread
argument_list|(
name|in_buff
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|in_buff
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|)
operator|<
literal|5
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file: error reading file %s (empty file)\n"
operator|,
name|filename
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* decrypt key */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|in_buff
argument_list|,
literal|"Private-key-format: v"
argument_list|,
literal|20
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|len
operator|=
name|cnt
expr_stmt|;
name|p
operator|=
name|in_buff
expr_stmt|;
if|if
condition|(
operator|!
name|dst_s_verify_str
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
literal|"Private-key-format: v"
argument_list|)
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file(): Not a Key file/Decrypt failed %s\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* read in file format */
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%d.%d"
argument_list|,
operator|&
name|file_major
argument_list|,
operator|&
name|file_minor
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|KEY_FILE_FORMAT
argument_list|,
literal|"%d.%d"
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_major
operator|<
literal|1
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file(): Unknown keyfile %d.%d version for %s\n"
operator|,
name|file_major
operator|,
name|file_minor
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|file_major
operator|>
name|major
operator|||
name|file_minor
operator|>
name|minor
condition|)
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file(): Keyfile %s version higher than mine %d.%d MAY FAIL\n"
operator|,
name|name
operator|,
name|file_major
operator|,
name|file_minor
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip to end of line */
if|if
condition|(
operator|!
name|dst_s_verify_str
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
literal|"Algorithm: "
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|alg
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip to end of line */
if|if
condition|(
name|pk_key
operator|->
name|dk_key_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|pk_key
operator|->
name|dk_key_name
argument_list|,
name|name
argument_list|)
condition|)
name|SAFE_FREE2
argument_list|(
name|pk_key
operator|->
name|dk_key_name
argument_list|,
name|strlen
argument_list|(
name|pk_key
operator|->
name|dk_key_name
argument_list|)
argument_list|)
expr_stmt|;
name|pk_key
operator|->
name|dk_key_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* allocate and fill in key structure */
if|if
condition|(
name|pk_key
operator|->
name|dk_func
operator|==
name|NULL
operator|||
name|pk_key
operator|->
name|dk_func
operator|->
name|from_file_fmt
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|id
operator|=
name|pk_key
operator|->
name|dk_func
operator|->
name|from_file_fmt
argument_list|(
name|pk_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|&
name|in_buff
index|[
name|len
index|]
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Make sure the actual key tag matches the input tag used in the filename 	 */
if|if
condition|(
name|id
operator|!=
name|in_id
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_read_private_key_file(): actual tag of key read %d != input tag used to build filename %d.\n"
operator|,
name|id
operator|,
name|in_id
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pk_key
operator|->
name|dk_id
operator|=
operator|(
name|u_int16_t
operator|)
name|id
expr_stmt|;
name|pk_key
operator|->
name|dk_alg
operator|=
name|alg
expr_stmt|;
name|memset
argument_list|(
name|in_buff
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
name|memset
argument_list|(
name|in_buff
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_generate_key  *	Generate and store a public/private keypair.  *	Keys will be stored in formatted files.  *  Parameters  *	name    Name of the new key.  Used to create key files  *		  K<name>+<alg>+<id>.public and K<name>+<alg>+<id>.private.  *	bits    Size of the new key in bits.  *	exp     What exponent to use:  *		  0	   use exponent 3  *		  non-zero    use Fermant4  *	flags   The default value of the DNS Key flags.  *		  The DNS Key RR Flag field is defined in RFC 2065,  *		  section 3.3.  The field has 16 bits.  *	protocol  *	      Default value of the DNS Key protocol field.  *		  The DNS Key protocol field is defined in RFC 2065,  *		  section 3.4.  The field has 8 bits.  *	alg     What algorithm to use.  Currently defined:  *		  KEY_RSA       1  *		  KEY_DSA       3  *		  KEY_HMAC    157  *	out_id The key tag is returned.  *  *  Return  *	NULL		Failure  *	non-NULL 	the generated key pair  *			Caller frees the result, and its dk_name pointer.  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|dst_generate_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|,
specifier|const
name|int
name|exp
parameter_list|,
specifier|const
name|unsigned
name|flags
parameter_list|,
specifier|const
name|int
name|protocol
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|)
block|{
name|DST_KEY
modifier|*
name|new_key
init|=
name|NULL
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|dst_check_algorithm
argument_list|(
name|alg
argument_list|)
condition|)
block|{
comment|/* make sure alg is available */
name|EREPORT
argument_list|(
operator|(
literal|"dst_generate_key(): Algorithm %d not suppored\n"
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|=
name|dst_s_get_key_struct
argument_list|(
name|name
argument_list|,
name|alg
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
comment|/* null key we are done */
return|return
operator|(
name|new_key
operator|)
return|;
if|if
condition|(
name|new_key
operator|->
name|dk_func
operator|==
name|NULL
operator|||
name|new_key
operator|->
name|dk_func
operator|->
name|generate
operator|==
name|NULL
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_generate_key_pair():Unsupported algorithm %d\n"
operator|,
name|alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_free_key
argument_list|(
name|new_key
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|new_key
operator|->
name|dk_func
operator|->
name|generate
argument_list|(
name|new_key
argument_list|,
name|exp
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_generate_key_pair(): Key generation failure %s %d %d %d\n"
operator|,
name|new_key
operator|->
name|dk_key_name
operator|,
name|new_key
operator|->
name|dk_alg
operator|,
name|new_key
operator|->
name|dk_key_size
operator|,
name|exp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_free_key
argument_list|(
name|new_key
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  dst_free_key  *	Release all data structures pointed to by a key structure.  *  Parameters  *	f_key   Key structure to be freed.  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|dst_free_key
parameter_list|(
name|DST_KEY
modifier|*
name|f_key
parameter_list|)
block|{
if|if
condition|(
name|f_key
operator|==
name|NULL
condition|)
return|return
operator|(
name|f_key
operator|)
return|;
if|if
condition|(
name|f_key
operator|->
name|dk_func
operator|&&
name|f_key
operator|->
name|dk_func
operator|->
name|destroy
condition|)
name|f_key
operator|->
name|dk_KEY_struct
operator|=
name|f_key
operator|->
name|dk_func
operator|->
name|destroy
argument_list|(
name|f_key
operator|->
name|dk_KEY_struct
argument_list|)
expr_stmt|;
else|else
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_free_key(): Unknown key alg %d\n"
operator|,
name|f_key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f_key
operator|->
name|dk_KEY_struct
argument_list|)
expr_stmt|;
comment|/* SHOULD NOT happen */
block|}
if|if
condition|(
name|f_key
operator|->
name|dk_KEY_struct
condition|)
block|{
name|free
argument_list|(
name|f_key
operator|->
name|dk_KEY_struct
argument_list|)
expr_stmt|;
name|f_key
operator|->
name|dk_KEY_struct
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|f_key
operator|->
name|dk_key_name
condition|)
name|SAFE_FREE
argument_list|(
name|f_key
operator|->
name|dk_key_name
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|f_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dst_sig_size  *	Return the maximim size of signature from the key specified in bytes  * Parameters  *      key   * Returns  *     bytes  */
end_comment

begin_function
name|int
name|dst_sig_size
parameter_list|(
name|DST_KEY
modifier|*
name|key
parameter_list|)
block|{
switch|switch
condition|(
name|key
operator|->
name|dk_alg
condition|)
block|{
case|case
name|KEY_HMAC_MD5
case|:
return|return
operator|(
literal|16
operator|)
return|;
case|case
name|KEY_HMAC_SHA1
case|:
return|return
operator|(
literal|20
operator|)
return|;
case|case
name|KEY_RSA
case|:
return|return
operator|(
name|key
operator|->
name|dk_key_size
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
case|case
name|KEY_DSA
case|:
return|return
operator|(
literal|40
operator|)
return|;
default|default:
name|EREPORT
argument_list|(
operator|(
literal|"dst_sig_size(): Unknown key alg %d\n"
operator|,
name|key
operator|->
name|dk_alg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * dst_random   *  function that multiplexes number of random number generators  * Parameters    *   mode: select the random number generator  *   wanted is how many bytes of random data are requested   *   outran is a buffer of size at least wanted for the output data  *  * Returns  *    number of bytes written to outran  */
end_comment

begin_function
name|int
name|dst_random
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|,
name|unsigned
name|wanted
parameter_list|,
name|u_char
modifier|*
name|outran
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|buff
init|=
name|NULL
decl_stmt|,
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wanted
operator|<=
literal|0
operator|||
name|outran
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DST_RAND_SEMI
case|:
name|bp
operator|=
name|buff
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
name|wanted
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wanted
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|,
name|bp
operator|++
control|)
block|{
operator|*
name|bp
operator|=
name|dst_s_quick_random
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|outran
argument_list|,
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
name|wanted
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|wanted
operator|)
return|;
case|case
name|DST_RAND_STD
case|:
return|return
operator|(
name|dst_s_semi_random
argument_list|(
name|outran
argument_list|,
name|wanted
argument_list|)
operator|)
return|;
case|case
name|DST_RAND_KEY
case|:
return|return
operator|(
name|dst_s_random
argument_list|(
name|outran
argument_list|,
name|wanted
argument_list|)
operator|)
return|;
case|case
name|DST_RAND_DSS
case|:
default|default:
comment|/* need error case here XXX OG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

