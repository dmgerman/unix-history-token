begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /proj/cvs/isc/DHCP/dst/prandom.c,v 1.1 2001/02/22 07:22:09 mellon Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Portions Copyright (c) 1995-1998 by Trusted Information Systems, Inc.  *  * Permission to use, copy modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND TRUSTED INFORMATION SYSTEMS  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL  * TRUSTED INFORMATION SYSTEMS BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  * WITH THE USE OR PERFORMANCE OF THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|NEED_PRAND_CONF
end_define

begin_include
include|#
directive|include
file|"minires/minires.h"
end_include

begin_include
include|#
directive|include
file|"dst_internal.h"
end_include

begin_include
include|#
directive|include
file|"arpa/nameser.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DST_NUM_HASHES
end_ifndef

begin_define
define|#
directive|define
name|DST_NUM_HASHES
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DST_NUMBER_OF_COUNTERS
end_ifndef

begin_define
define|#
directive|define
name|DST_NUMBER_OF_COUNTERS
value|5
end_define

begin_comment
comment|/* 32 * 5 == 160 == SHA(1)> MD5 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * the constant below is a prime number to make fixed data structues like   * stat and time wrap over blocks. This adds certain uncertanty to what is   * in each digested block.   * The prime number 2879 has the special property that when   * divided by 2,4 and 6 the result is also a prime numbers  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DST_RANDOM_BLOCK_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DST_RANDOM_BLOCK_SIZE
value|2879
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * This constant dictatates how many bits we shift to the right before using a   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DST_SHIFT
end_ifndef

begin_define
define|#
directive|define
name|DST_SHIFT
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * An initalizer that is as bad as any other with half the bits set   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DST_RANDOM_PATTERN
end_ifndef

begin_define
define|#
directive|define
name|DST_RANDOM_PATTERN
value|0x8765CA93
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * things must have changed in the last 3600 seconds to be used   */
end_comment

begin_define
define|#
directive|define
name|MAX_OLD
value|3600
end_define

begin_comment
comment|/*    *  these two data structure are used to process input data into digests,   *  *  The first structure is containts a pointer to a DST HMAC key   *  the variables accompanying are used for   *	step : select every step byte from input data for the hash  *	block: number of data elements going into each hash  *	digested: number of data elements digested so far  *	curr: offset into the next input data for the first byte.   */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hash
block|{
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
name|int
name|digested
decl_stmt|,
name|block
decl_stmt|,
name|step
decl_stmt|,
name|curr
decl_stmt|;
block|}
name|prand_hash
typedef|;
end_typedef

begin_comment
comment|/*  *  This data structure controlls number of hashes and keeps track of   *  overall progress in generating correct number of bytes of output.  *	output  : array to store the output data in  *	needed  : how many bytes of output are needed  *	filled  : number of bytes in output so far.   *	bytes   : total number of bytes processed by this structure  *	file_digest : the HMAC key used to digest files.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|work
block|{
name|unsigned
name|needed
decl_stmt|,
name|filled
decl_stmt|,
name|bytes
decl_stmt|;
name|u_char
modifier|*
name|output
decl_stmt|;
name|prand_hash
modifier|*
name|hash
index|[
name|DST_NUM_HASHES
index|]
decl_stmt|;
name|DST_KEY
modifier|*
name|file_digest
decl_stmt|;
block|}
name|dst_work
typedef|;
end_typedef

begin_comment
comment|/*   * forward function declarations   */
end_comment

begin_function_decl
specifier|static
name|int
name|get_dev_random
parameter_list|(
name|u_char
modifier|*
name|output
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_time
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_ls
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unix_cmd
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|digest_file
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|force_hash
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|,
name|prand_hash
modifier|*
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_hash
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|,
name|prand_hash
modifier|*
name|hash
parameter_list|,
specifier|const
name|u_char
modifier|*
name|input
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_digest
parameter_list|(
name|dst_work
modifier|*
name|tmp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|input
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|prand_hash
modifier|*
name|get_hmac_key
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|own_random
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * variables used in the quick random number generator   */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|ran_val
init|=
name|DST_RANDOM_PATTERN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ran_cnt
init|=
operator|(
name|DST_RANDOM_PATTERN
operator|>>
literal|10
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * setting the quick_random generator to particular values or if both   * input parameters are 0 then set it to initial vlaues  */
end_comment

begin_function
name|void
name|dst_s_quick_random_set
parameter_list|(
name|u_int32_t
name|val
parameter_list|,
name|u_int32_t
name|cnt
parameter_list|)
block|{
name|ran_val
operator|=
operator|(
name|val
operator|==
literal|0
operator|)
condition|?
name|DST_RANDOM_PATTERN
else|:
name|val
expr_stmt|;
name|ran_cnt
operator|=
operator|(
name|cnt
operator|==
literal|0
operator|)
condition|?
operator|(
name|DST_RANDOM_PATTERN
operator|>>
literal|10
operator|)
else|:
name|cnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * this is a quick and random number generator that seems to generate quite   * good distribution of data   */
end_comment

begin_function
name|u_int32_t
name|dst_s_quick_random
parameter_list|(
name|int
name|inc
parameter_list|)
block|{
name|ran_val
operator|=
operator|(
operator|(
name|ran_val
operator|>>
literal|13
operator|)
operator|^
operator|(
name|ran_val
operator|<<
literal|19
operator|)
operator|)
operator|^
operator|(
operator|(
name|ran_val
operator|>>
literal|7
operator|)
operator|^
operator|(
name|ran_val
operator|<<
literal|25
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
comment|/* only increasing values accepted */
name|ran_cnt
operator|+=
name|inc
expr_stmt|;
name|ran_val
operator|+=
name|ran_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|ran_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * get_dev_random: Function to read /dev/random reliably  * this function returns how many bytes where read from the device.  * port_after.h should set the control variable HAVE_DEV_RANDOM   */
end_comment

begin_function
specifier|static
name|int
name|get_dev_random
parameter_list|(
name|u_char
modifier|*
name|output
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_DEV_RANDOM
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|stat
argument_list|(
literal|"/dev/random"
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|S_ISCHR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|output
argument_list|,
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Portable way of getting the time values if gettimeofday is missing   * then compile with -DMISSING_GETTIMEOFDAY  time() is POSIX compliant but  * gettimeofday() is not.  * Time of day is predictable, we are looking for the randomness that comes   * the last few bits in the microseconds in the timer are hard to predict when   * this is invoked at the end of other operations  */
end_comment

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|mtime
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|do_time
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|tmp
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timezone
argument_list|)
index|]
decl_stmt|;
name|struct
name|timezone
modifier|*
name|zone
decl_stmt|;
name|zone
operator|=
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|tmp
expr_stmt|;
name|mtime
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|timezone
argument_list|)
operator|)
expr_stmt|;
name|gettimeofday
argument_list|(
name|mtime
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|cnt
operator|=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|my_digest
argument_list|(
name|work
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this function simulates the ls command, but it uses stat which gives more  * information and is harder to guess   * Each call to this function will visit the next directory on the list of   * directories, in a circular manner.   * return value is the number of bytes added to the temp buffer  *  * do_ls() does not visit subdirectories  * if attacker has access to machine it can guess most of the values seen  * thus it is important to only visit directories that are freqently updated  * Attacker that has access to the network can see network traffic   * when NFS mounted directories are accessed and know exactly the data used  * but may not know exactly in what order data is used.   * Returns the number of bytes that where returned in stat structures  */
end_comment

begin_function
specifier|static
name|int
name|do_ls
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
block|{
struct|struct
name|dir_info
block|{
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|time_t
name|atime
decl_stmt|,
name|mtime
decl_stmt|,
name|ctime
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|dir_info
name|dir_info
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
decl_stmt|;
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|long
name|d_round
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|tb_i
init|=
literal|0
decl_stmt|,
name|out
init|=
literal|0
decl_stmt|;
name|unsigned
name|dir_len
decl_stmt|;
name|char
name|file_name
index|[
literal|1024
index|]
decl_stmt|;
name|u_char
name|tmp_buff
index|[
literal|1024
index|]
decl_stmt|;
name|DIR
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
comment|/* if at the end of the list start over */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dirs
index|[
name|i
operator|++
index|]
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
comment|/* directory does not exist */
return|return
operator|(
literal|0
operator|)
return|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_round
operator|==
literal|0
condition|)
name|d_round
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|MAX_OLD
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
comment|/* if starting a new round cut what we accept */
name|d_round
operator|+=
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|d_round
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|st_atime
operator|<
name|d_round
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EREPORT
argument_list|(
operator|(
literal|"do_ls i %d filled %4d in_temp %4d\n"
operator|,
name|i
operator|-
literal|1
operator|,
name|work
operator|->
name|filled
operator|,
name|work
operator|->
name|in_temp
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buff
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tb_i
operator|+=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|dirs
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* open it for read */
return|return
operator|(
literal|0
operator|)
return|;
name|strcpy
argument_list|(
name|file_name
argument_list|,
name|dirs
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|dir_len
operator|=
name|strlen
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|file_name
index|[
name|dir_len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
decl_stmt|;
name|out
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|my_digest
argument_list|(
name|work
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|entry
operator|->
name|d_name
argument_list|,
name|len
argument_list|)
condition|)
break|break;
name|memcpy
argument_list|(
operator|&
name|file_name
index|[
name|dir_len
index|]
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|file_name
index|[
name|dir_len
operator|+
name|len
index|]
operator|=
literal|0x0
expr_stmt|;
comment|/* for all entries in dir get the stats */
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
comment|/* count successfull stat calls */
comment|/* copy non static fields */
name|dir_info
operator|.
name|uid
operator|+=
name|buf
operator|.
name|st_uid
expr_stmt|;
name|dir_info
operator|.
name|gid
operator|+=
name|buf
operator|.
name|st_gid
expr_stmt|;
name|dir_info
operator|.
name|size
operator|+=
name|buf
operator|.
name|st_size
expr_stmt|;
name|dir_info
operator|.
name|atime
operator|+=
name|buf
operator|.
name|st_atime
expr_stmt|;
name|dir_info
operator|.
name|mtime
operator|+=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|dir_info
operator|.
name|ctime
operator|+=
name|buf
operator|.
name|st_ctime
expr_stmt|;
name|out
operator|+=
sizeof|sizeof
argument_list|(
name|dir_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_digest
argument_list|(
name|work
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|dir_info
argument_list|,
sizeof|sizeof
argument_list|(
name|dir_info
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* done */
name|out
operator|+=
name|do_time
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* add a time stamp */
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * unix_cmd()   * this function executes the a command from the cmds[] list of unix commands   * configured in the prand_conf.h file  * return value is the number of bytes added to the randomness temp buffer  *   * it returns the number of bytes that where read in  * if more data is needed at the end time is added to the data.  * This function maintains a state to selects the next command to run  * returns the number of bytes read in from the command   */
end_comment

begin_function
specifier|static
name|int
name|unix_cmd
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
block|{
specifier|static
name|int
name|cmd_index
init|=
literal|0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|FILE
modifier|*
name|pipe
decl_stmt|;
name|u_char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
if|if
condition|(
name|cmds
index|[
name|cmd_index
index|]
operator|==
name|NULL
condition|)
name|cmd_index
operator|=
literal|0
expr_stmt|;
name|EREPORT
argument_list|(
operator|(
literal|"unix_cmd() i %d filled %4d in_temp %4d\n"
operator|,
name|cmd_index
operator|,
name|work
operator|->
name|filled
operator|,
name|work
operator|->
name|in_temp
operator|)
argument_list|)
expr_stmt|;
name|pipe
operator|=
name|popen
argument_list|(
name|cmds
index|[
name|cmd_index
operator|++
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* execute the command */
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|pipe
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cnt
operator|+=
name|n
expr_stmt|;
comment|/* process the output */
if|if
condition|(
name|my_digest
argument_list|(
name|work
argument_list|,
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
condition|)
break|break;
comment|/* this adds some randomness to the output */
name|cnt
operator|+=
name|do_time
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|pipe
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|NULL
expr_stmt|;
comment|/* drain the pipe */
name|pclose
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
comment|/* read how many bytes where read in */
block|}
end_function

begin_comment
comment|/*   * digest_file() This function will read a file and run hash over it  * input is a file name   */
end_comment

begin_function
specifier|static
name|int
name|digest_file
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
block|{
specifier|static
name|int
name|f_cnt
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|long
name|f_round
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|no
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|f_round
operator|==
literal|0
operator|||
name|files
index|[
name|f_cnt
index|]
operator|==
name|NULL
operator|||
name|work
operator|->
name|file_digest
operator|==
name|NULL
condition|)
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
condition|)
comment|/* only do this if needed */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|f_round
operator|==
literal|0
condition|)
comment|/* first time called set to one hour ago */
name|f_round
operator|=
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|MAX_OLD
operator|)
expr_stmt|;
name|name
operator|=
name|files
index|[
name|f_cnt
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|files
index|[
name|f_cnt
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* end of list of files */
if|if
condition|(
name|f_cnt
operator|<=
literal|1
condition|)
comment|/* list is too short */
return|return
operator|(
literal|0
operator|)
return|;
name|f_cnt
operator|=
literal|0
expr_stmt|;
comment|/* start again on list */
name|f_round
operator|+=
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|f_round
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* set new cutoff */
name|work
operator|->
name|file_digest
operator|=
name|dst_free_key
argument_list|(
name|work
operator|->
name|file_digest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|file_digest
operator|==
name|NULL
condition|)
block|{
name|work
operator|->
name|file_digest
operator|=
name|dst_buffer_to_key
argument_list|(
literal|""
argument_list|,
name|KEY_HMAC_MD5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|file_digest
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|||
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no such file or not allowed to read it */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"/proc/"
argument_list|,
literal|6
argument_list|)
operator|&&
name|st
operator|.
name|st_mtime
operator|<
name|f_round
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* file has not changed recently enough */
if|if
condition|(
name|dst_sign_data
argument_list|(
name|SIG_MODE_INIT
argument_list|,
name|work
operator|->
name|file_digest
argument_list|,
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|work
operator|->
name|file_digest
operator|=
name|dst_free_key
argument_list|(
name|work
operator|->
name|file_digest
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|no
operator|=
literal|0
init|;
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|;
name|no
operator|+=
name|i
control|)
name|dst_sign_data
argument_list|(
name|SIG_MODE_UPDATE
argument_list|,
name|work
operator|->
name|file_digest
argument_list|,
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|no
operator|>=
literal|64
condition|)
block|{
name|i
operator|=
name|dst_sign_data
argument_list|(
name|SIG_MODE_FINAL
argument_list|,
name|work
operator|->
name|file_digest
argument_list|,
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|work
operator|->
name|output
index|[
name|work
operator|->
name|filled
index|]
argument_list|,
name|DST_HASH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|work
operator|->
name|filled
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|my_digest
argument_list|(
name|work
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|my_digest
argument_list|(
name|work
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|no
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * function to perform the FINAL and INIT operation on a hash if allowed  */
end_comment

begin_function
specifier|static
name|void
name|force_hash
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|,
name|prand_hash
modifier|*
name|hash
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/*  	 * if more than half a block then add data to output  	 * otherwise adde the digest to the next hash  	 */
if|if
condition|(
operator|(
name|hash
operator|->
name|digested
operator|*
literal|2
operator|)
operator|>
name|hash
operator|->
name|block
condition|)
block|{
name|i
operator|=
name|dst_sign_data
argument_list|(
name|SIG_MODE_FINAL
argument_list|,
name|hash
operator|->
name|key
argument_list|,
operator|&
name|hash
operator|->
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|work
operator|->
name|output
index|[
name|work
operator|->
name|filled
index|]
argument_list|,
name|DST_HASH_SIZE
argument_list|)
expr_stmt|;
name|hash
operator|->
name|digested
operator|=
literal|0
expr_stmt|;
name|dst_sign_data
argument_list|(
name|SIG_MODE_INIT
argument_list|,
name|hash
operator|->
name|key
argument_list|,
operator|&
name|hash
operator|->
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|work
operator|->
name|filled
operator|+=
name|i
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*   * This function takes the input data does the selection of data specified  * by the hash control block.  * The step varialbe in the work sturcture determines which 1/step bytes  * are used,   *  */
end_comment

begin_function
specifier|static
name|int
name|do_hash
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|,
name|prand_hash
modifier|*
name|hash
parameter_list|,
specifier|const
name|u_char
modifier|*
name|input
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|tmp
init|=
name|input
decl_stmt|;
name|u_char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|abuf
init|=
operator|(
name|u_char
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|needed
decl_stmt|,
name|avail
decl_stmt|,
name|dig
decl_stmt|,
name|cnt
init|=
name|size
decl_stmt|;
name|unsigned
name|tmp_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
operator|||
name|input
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|hash
operator|->
name|step
operator|>
literal|1
condition|)
block|{
comment|/* if using subset of input data */
name|tmp_size
operator|=
name|size
operator|/
name|hash
operator|->
name|step
operator|+
literal|2
expr_stmt|;
name|abuf
operator|=
name|tp
operator|=
name|malloc
argument_list|(
name|tmp_size
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tp
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
name|hash
operator|->
name|curr
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|hash
operator|->
name|step
operator|,
name|cnt
operator|++
control|)
operator|*
operator|(
name|tp
operator|++
operator|)
operator|=
name|input
index|[
name|i
index|]
expr_stmt|;
comment|/* calcutate the starting point in the next input set */
name|hash
operator|->
name|curr
operator|=
operator|(
name|hash
operator|->
name|step
operator|-
operator|(
name|i
operator|-
name|size
operator|)
operator|)
operator|%
name|hash
operator|->
name|step
expr_stmt|;
block|}
comment|/* digest the data in block sizes */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cnt
condition|;
name|n
operator|+=
name|needed
control|)
block|{
name|avail
operator|=
operator|(
name|cnt
operator|-
name|n
operator|)
expr_stmt|;
name|needed
operator|=
name|hash
operator|->
name|block
operator|-
name|hash
operator|->
name|digested
expr_stmt|;
name|dig
operator|=
operator|(
name|avail
operator|<
name|needed
operator|)
condition|?
name|avail
else|:
name|needed
expr_stmt|;
name|dst_sign_data
argument_list|(
name|SIG_MODE_UPDATE
argument_list|,
name|hash
operator|->
name|key
argument_list|,
operator|&
name|hash
operator|->
name|ctx
argument_list|,
operator|&
name|tmp
index|[
name|n
index|]
argument_list|,
name|dig
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hash
operator|->
name|digested
operator|+=
name|dig
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|digested
operator|>=
name|hash
operator|->
name|block
condition|)
name|force_hash
argument_list|(
name|work
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|needed
operator|<
name|work
operator|->
name|filled
condition|)
block|{
if|if
condition|(
name|abuf
condition|)
name|SAFE_FREE2
argument_list|(
name|abuf
argument_list|,
name|tmp_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tmp_size
operator|>
literal|0
condition|)
name|SAFE_FREE2
argument_list|(
name|abuf
argument_list|,
name|tmp_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data from INPUT for length SIZE into the work-block TMP.  * If we fill the work-block, digest it; then,  * if work-block needs more data, keep filling with the rest of the input.  */
end_comment

begin_function
specifier|static
name|int
name|my_digest
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|,
specifier|const
name|u_char
modifier|*
name|input
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|full
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|counter
decl_stmt|;
name|counter
operator|+=
name|size
expr_stmt|;
comment|/* first do each one of the hashes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DST_NUM_HASHES
operator|&&
name|full
operator|==
literal|0
condition|;
name|i
operator|++
control|)
name|full
operator|=
name|do_hash
argument_list|(
name|work
argument_list|,
name|work
operator|->
name|hash
index|[
name|i
index|]
argument_list|,
name|input
argument_list|,
name|size
argument_list|)
operator|+
name|do_hash
argument_list|(
name|work
argument_list|,
name|work
operator|->
name|hash
index|[
name|i
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|counter
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   * if enough data has be generated do final operation on all hashes   *  that have enough date for that   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|full
operator|&&
operator|(
name|i
operator|<
name|DST_NUM_HASHES
operator|)
condition|;
name|i
operator|++
control|)
name|force_hash
argument_list|(
name|work
argument_list|,
name|work
operator|->
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|full
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this function gets some semi random data and sets that as an HMAC key  * If we get a valid key this function returns that key initalized  * otherwise it returns NULL;  */
end_comment

begin_function
specifier|static
name|prand_hash
modifier|*
name|get_hmac_key
parameter_list|(
name|int
name|step
parameter_list|,
name|int
name|block
parameter_list|)
block|{
name|u_char
modifier|*
name|buff
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|size
init|=
literal|70
decl_stmt|;
name|DST_KEY
modifier|*
name|new_key
init|=
name|NULL
decl_stmt|;
name|prand_hash
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
comment|/* use key that is larger than  digest algorithms (64) for key size */
name|buff
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* do not memset the allocated memory to get random bytes there */
comment|/* time of day is somewhat random  expecialy in the last bytes */
name|gettimeofday
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
expr_stmt|;
comment|/* get some semi random stuff in here stir it with micro seconds */
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
name|dst_s_quick_random
argument_list|(
operator|(
name|int
operator|)
name|buff
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* get the pid of this process and its parent */
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
operator|(
name|int
operator|)
name|getpid
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
operator|(
name|int
operator|)
name|getppid
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* get the user ID */
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
operator|(
name|int
operator|)
name|getuid
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|GET_HOST_ID_MISSING
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
operator|(
name|int
operator|)
name|gethostid
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get some more random data */
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|temp
operator|=
name|dst_s_quick_random
argument_list|(
operator|(
name|int
operator|)
name|buff
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buff
index|[
name|n
index|]
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* covert this into a HMAC key */
name|new_key
operator|=
name|dst_buffer_to_key
argument_list|(
literal|""
argument_list|,
name|KEY_HMAC_MD5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* get the control structure */
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|prand_hash
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new
operator|->
name|digested
operator|=
name|new
operator|->
name|curr
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|step
operator|=
name|step
expr_stmt|;
name|new
operator|->
name|block
operator|=
name|block
expr_stmt|;
name|new
operator|->
name|key
operator|=
name|new_key
expr_stmt|;
if|if
condition|(
name|dst_sign_data
argument_list|(
name|SIG_MODE_INIT
argument_list|,
name|new_key
argument_list|,
operator|&
name|new
operator|->
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * own_random()   * This function goes out and from various sources tries to generate enough  * semi random data that a hash function can generate a random data.   * This function will iterate between the two main random source sources,   *  information from programs and directores in random order.   * This function return the number of bytes added to the random output buffer.   */
end_comment

begin_function
specifier|static
name|unsigned
name|own_random
parameter_list|(
name|dst_work
modifier|*
name|work
parameter_list|)
block|{
name|int
name|dir
init|=
literal|0
decl_stmt|,
name|b
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|n
decl_stmt|,
name|cmd
init|=
literal|0
decl_stmt|,
name|dig
init|=
literal|0
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
comment|/*   * now get the initial seed to put into the quick random function from   * the address of the work structure   */
name|bytes
operator|=
operator|(
name|int
operator|)
name|getpid
argument_list|()
expr_stmt|;
comment|/*  * proceed while needed   */
while|while
condition|(
name|work
operator|->
name|filled
operator|<
name|work
operator|->
name|needed
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"own_random r %08x b %6d t %6d f %6d\n"
operator|,
name|ran_val
operator|,
name|bytes
operator|,
name|work
operator|->
name|in_temp
operator|,
name|work
operator|->
name|filled
operator|)
argument_list|)
expr_stmt|;
comment|/* pick a random number in the range of 0..7 based on that random number  * perform some operations that yield random data  */
name|start
operator|=
name|work
operator|->
name|filled
expr_stmt|;
name|n
operator|=
operator|(
name|dst_s_quick_random
argument_list|(
name|bytes
argument_list|)
operator|>>
name|DST_SHIFT
operator|)
operator|&
literal|0x07
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|3
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cmds
argument_list|)
operator|>
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmds
argument_list|)
condition|)
block|{
name|b
operator|=
name|unix_cmd
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|cmd
operator|+=
name|b
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
case|case
literal|7
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|dirs
argument_list|)
operator|>
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirs
argument_list|)
condition|)
block|{
name|b
operator|=
name|do_ls
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|dir
operator|+=
name|b
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
comment|/* retry getting data from /dev/random */
name|b
operator|=
name|get_dev_random
argument_list|(
operator|&
name|work
operator|->
name|output
index|[
name|work
operator|->
name|filled
index|]
argument_list|,
name|work
operator|->
name|needed
operator|-
name|work
operator|->
name|filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|>
literal|0
condition|)
name|work
operator|->
name|filled
operator|+=
name|b
expr_stmt|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|files
argument_list|)
operator|>
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|files
argument_list|)
condition|)
block|{
name|b
operator|=
name|digest_file
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|dig
operator|+=
name|b
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
default|default:
comment|/* to make sure we make some progress */
name|work
operator|->
name|output
index|[
name|work
operator|->
name|filled
operator|++
index|]
operator|=
literal|0xff
operator|&
name|dst_s_quick_random
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|b
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|b
operator|>
literal|0
condition|)
name|bytes
operator|+=
name|b
expr_stmt|;
block|}
return|return
operator|(
name|work
operator|->
name|filled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * dst_s_random() This function will return the requested number of bytes   * of randomness to the caller it will use the best available sources of   * randomness.  * The current order is to use /dev/random, precalculated randomness, and   * finaly use some system calls and programs to generate semi random data that   * is then digested to generate randomness.   * This function is thread safe as each thread uses its own context, but  * concurrent treads will affect each other as they update shared state   * information.  * It is strongly recommended that this function be called requesting a size   * that is not a multiple of the output of the hash function used.   *   * If /dev/random is not available this function is not suitable to generate   * large ammounts of data, rather it is suitable to seed a pseudo-random   * generator   * Returns the number of bytes put in the output buffer   */
end_comment

begin_function
name|int
name|dst_s_random
parameter_list|(
name|u_char
modifier|*
name|output
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
specifier|static
name|u_char
name|old_unused
index|[
name|DST_HASH_SIZE
operator|*
name|DST_NUM_HASHES
index|]
decl_stmt|;
specifier|static
name|unsigned
name|unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|output
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|size
operator|>=
literal|2048
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*  	 * Read from /dev/random  	 */
name|n
operator|=
name|get_dev_random
argument_list|(
name|output
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/*  	 *  If old data is available and needed use it  	 */
if|if
condition|(
name|n
operator|<
name|size
operator|&&
name|unused
operator|>
literal|0
condition|)
block|{
name|unsigned
name|need
init|=
name|size
operator|-
name|n
decl_stmt|;
if|if
condition|(
name|unused
operator|<=
name|need
condition|)
block|{
name|memcpy
argument_list|(
name|output
argument_list|,
name|old_unused
argument_list|,
name|unused
argument_list|)
expr_stmt|;
name|n
operator|+=
name|unused
expr_stmt|;
name|unused
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|output
argument_list|,
name|old_unused
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|n
operator|+=
name|need
expr_stmt|;
name|unused
operator|-=
name|need
expr_stmt|;
name|memcpy
argument_list|(
name|old_unused
argument_list|,
operator|&
name|old_unused
index|[
name|need
index|]
argument_list|,
name|unused
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we need more use the simulated randomness here. 	 */
if|if
condition|(
name|n
operator|<
name|size
condition|)
block|{
name|dst_work
modifier|*
name|my_work
init|=
operator|(
name|dst_work
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dst_work
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|my_work
operator|==
name|NULL
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|my_work
operator|->
name|needed
operator|=
name|size
operator|-
name|n
expr_stmt|;
name|my_work
operator|->
name|filled
operator|=
literal|0
expr_stmt|;
name|my_work
operator|->
name|output
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|my_work
operator|->
name|needed
operator|+
name|DST_HASH_SIZE
operator|*
name|DST_NUM_HASHES
argument_list|)
expr_stmt|;
name|my_work
operator|->
name|file_digest
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|my_work
operator|->
name|output
operator|==
name|NULL
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|memset
argument_list|(
name|my_work
operator|->
name|output
argument_list|,
literal|0x0
argument_list|,
name|my_work
operator|->
name|needed
argument_list|)
expr_stmt|;
comment|/* allocate upto 4 different HMAC hash functions out of order */
if|#
directive|if
name|DST_NUM_HASHES
operator|>=
literal|3
name|my_work
operator|->
name|hash
index|[
literal|2
index|]
operator|=
name|get_hmac_key
argument_list|(
literal|3
argument_list|,
name|DST_RANDOM_BLOCK_SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DST_NUM_HASHES
operator|>=
literal|2
name|my_work
operator|->
name|hash
index|[
literal|1
index|]
operator|=
name|get_hmac_key
argument_list|(
literal|7
argument_list|,
name|DST_RANDOM_BLOCK_SIZE
operator|/
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DST_NUM_HASHES
operator|>=
literal|4
name|my_work
operator|->
name|hash
index|[
literal|3
index|]
operator|=
name|get_hmac_key
argument_list|(
literal|5
argument_list|,
name|DST_RANDOM_BLOCK_SIZE
operator|/
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_work
operator|->
name|hash
index|[
literal|0
index|]
operator|=
name|get_hmac_key
argument_list|(
literal|1
argument_list|,
name|DST_RANDOM_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_work
operator|->
name|hash
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* if failure bail out */
return|return
operator|(
name|n
operator|)
return|;
name|s
operator|=
name|own_random
argument_list|(
name|my_work
argument_list|)
expr_stmt|;
comment|/* if more generated than needed store it for future use */
if|if
condition|(
name|s
operator|>=
name|my_work
operator|->
name|needed
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_random(): More than needed %d>= %d\n"
operator|,
name|s
operator|,
name|my_work
operator|->
name|needed
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|output
index|[
name|n
index|]
argument_list|,
name|my_work
operator|->
name|output
argument_list|,
name|my_work
operator|->
name|needed
argument_list|)
expr_stmt|;
name|n
operator|+=
name|my_work
operator|->
name|needed
expr_stmt|;
comment|/* saving unused data for next time */
name|unused
operator|=
name|s
operator|-
name|my_work
operator|->
name|needed
expr_stmt|;
name|memcpy
argument_list|(
name|old_unused
argument_list|,
operator|&
name|my_work
operator|->
name|output
index|[
name|my_work
operator|->
name|needed
index|]
argument_list|,
name|unused
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXXX This should not happen */
name|EREPORT
argument_list|(
operator|(
literal|"Not enough %d>= %d\n"
operator|,
name|s
operator|,
name|my_work
operator|->
name|needed
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|output
index|[
name|n
index|]
argument_list|,
name|my_work
operator|->
name|output
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|n
operator|+=
name|my_work
operator|->
name|needed
expr_stmt|;
block|}
comment|/* delete the allocated work area */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DST_NUM_HASHES
condition|;
name|i
operator|++
control|)
block|{
name|dst_free_key
argument_list|(
name|my_work
operator|->
name|hash
index|[
name|i
index|]
operator|->
name|key
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|my_work
operator|->
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|SAFE_FREE
argument_list|(
name|my_work
operator|->
name|output
argument_list|)
expr_stmt|;
name|SAFE_FREE
argument_list|(
name|my_work
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A random number generator that is fast and strong   * this random number generator is based on HASHing data,  * the input to the digest function is a collection of<NUMBER_OF_COUNTERS>  * counters that is incremented between digest operations  * each increment operation amortizes to 2 bits changed in that value  * for 5 counters thus the input will amortize to have 10 bits changed   * The counters are initaly set using the strong random function above  * the HMAC key is selected by the same methold as the HMAC keys for the   * strong random function.   * Each set of counters is used for 2^25 operations   *   * returns the number of bytes written to the output buffer   * or       negative number in case of error   */
end_comment

begin_function
name|int
name|dst_s_semi_random
parameter_list|(
name|u_char
modifier|*
name|output
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
specifier|static
name|u_int32_t
name|counter
index|[
name|DST_NUMBER_OF_COUNTERS
index|]
decl_stmt|;
specifier|static
name|u_char
name|semi_old
index|[
name|DST_HASH_SIZE
index|]
decl_stmt|;
specifier|static
name|int
name|semi_loc
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|hb_size
init|=
literal|0
decl_stmt|;
specifier|static
name|DST_KEY
modifier|*
name|my_key
init|=
name|NULL
decl_stmt|;
name|prand_hash
modifier|*
name|hash
decl_stmt|;
name|unsigned
name|out
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
operator|||
name|size
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* check if we need a new key */
if|if
condition|(
name|my_key
operator|==
name|NULL
operator|||
name|cnt
operator|>
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
block|{
comment|/* get HMAC KEY */
if|if
condition|(
name|my_key
condition|)
name|my_key
operator|->
name|dk_func
operator|->
name|destroy
argument_list|(
name|my_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|=
name|get_hmac_key
argument_list|(
literal|1
argument_list|,
name|DST_RANDOM_BLOCK_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|my_key
operator|=
name|hash
operator|->
name|key
expr_stmt|;
comment|/* check if the key works stir the new key using some old random data */
name|hb_size
operator|=
name|dst_sign_data
argument_list|(
name|SIG_MODE_ALL
argument_list|,
name|my_key
argument_list|,
name|NULL
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|counter
argument_list|)
argument_list|,
name|semi_old
argument_list|,
sizeof|sizeof
argument_list|(
name|semi_old
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hb_size
operator|<=
literal|0
condition|)
block|{
name|EREPORT
argument_list|(
operator|(
literal|"dst_s_semi_random() Sign of alg %d failed %d\n"
operator|,
name|my_key
operator|->
name|dk_alg
operator|,
name|hb_size
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* new set the counters to random values */
name|dst_s_random
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|counter
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if old data around use it first */
if|if
condition|(
name|semi_loc
operator|<
name|hb_size
condition|)
block|{
if|if
condition|(
name|size
operator|<=
name|hb_size
operator|-
name|semi_loc
condition|)
block|{
comment|/* need less */
name|memcpy
argument_list|(
name|output
argument_list|,
operator|&
name|semi_old
index|[
name|semi_loc
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|semi_loc
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
comment|/* DONE */
block|}
else|else
block|{
name|out
operator|=
name|hb_size
operator|-
name|semi_loc
expr_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
operator|&
name|semi_old
index|[
name|semi_loc
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|semi_loc
operator|+=
name|out
expr_stmt|;
block|}
block|}
comment|/* generate more randome stuff */
while|while
condition|(
name|out
operator|<
name|size
condition|)
block|{
comment|/*  		 * modify at least one bit by incrementing at least one counter 		 * based on the last bit of the last counter updated update 		 * the next one. 		 * minimaly this  operation will modify at least 1 bit,  		 * amortized 2 bits 		 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|DST_NUMBER_OF_COUNTERS
condition|;
name|n
operator|++
control|)
name|i
operator|=
operator|(
name|int
operator|)
name|counter
index|[
name|n
index|]
operator|++
expr_stmt|;
name|i
operator|=
name|dst_sign_data
argument_list|(
name|SIG_MODE_ALL
argument_list|,
name|my_key
argument_list|,
name|NULL
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|counter
argument_list|,
name|hb_size
argument_list|,
name|semi_old
argument_list|,
sizeof|sizeof
argument_list|(
name|semi_old
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|hb_size
condition|)
name|EREPORT
argument_list|(
operator|(
literal|"HMAC SIGNATURE FAILURE %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|-
name|out
operator|<
name|i
condition|)
comment|/* Not all data is needed */
name|semi_loc
operator|=
name|i
operator|=
name|size
operator|-
name|out
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|output
index|[
name|out
index|]
argument_list|,
name|semi_old
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
operator|+=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

end_unit

