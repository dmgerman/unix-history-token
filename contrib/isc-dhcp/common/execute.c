begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* execute.c     Support for executable statements. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1998-2002 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: execute.c,v 1.44.2.9 2002/11/17 02:26:58 dhankins Exp $ Copyright (c) 1998-2002 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_function
name|int
name|execute_statements
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|out_options
parameter_list|,
name|scope
parameter_list|,
name|statements
parameter_list|)
name|struct
name|binding_value
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|out_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|statements
decl_stmt|;
block|{
name|struct
name|executable_statement
modifier|*
name|r
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|num
decl_stmt|;
name|struct
name|binding_scope
modifier|*
name|outer
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|struct
name|binding_scope
modifier|*
name|ns
decl_stmt|;
if|if
condition|(
operator|!
name|statements
condition|)
return|return
literal|1
return|;
name|r
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
name|next
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
name|e
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
name|executable_statement_reference
argument_list|(
operator|&
name|r
argument_list|,
name|statements
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|&&
operator|!
operator|(
name|result
operator|&&
operator|*
name|result
operator|)
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|next
condition|)
name|executable_statement_reference
argument_list|(
operator|&
name|next
argument_list|,
name|r
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|op
condition|)
block|{
case|case
name|statements_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: statements"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|execute_statements
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|statements
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: statements returns %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|status
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|on_statement
case|:
if|if
condition|(
name|lease
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_EXPIRY
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: on expiry"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lease
operator|->
name|on_expiry
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
name|lease
operator|->
name|on_expiry
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
condition|)
name|executable_statement_reference
argument_list|(
operator|&
name|lease
operator|->
name|on_expiry
argument_list|,
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_RELEASE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: on release"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lease
operator|->
name|on_release
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
name|lease
operator|->
name|on_release
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
condition|)
name|executable_statement_reference
argument_list|(
operator|&
name|lease
operator|->
name|on_release
argument_list|,
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_COMMIT
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: on commit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lease
operator|->
name|on_commit
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
name|lease
operator|->
name|on_commit
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
condition|)
name|executable_statement_reference
argument_list|(
operator|&
name|lease
operator|->
name|on_commit
argument_list|,
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|switch_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: switch"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
operator|(
name|find_matching_case
argument_list|(
operator|&
name|e
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|,
name|r
operator|->
name|data
operator|.
name|s_switch
operator|.
name|statements
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: switch: case %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|execute_statements
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|e
argument_list|)
operator|)
condition|)
block|{
name|executable_statement_dereference
argument_list|(
operator|&
name|e
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|executable_statement_dereference
argument_list|(
operator|&
name|e
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* These have no effect when executed. */
case|case
name|case_statement
case|:
case|case
name|default_statement
case|:
break|break;
case|case
name|if_statement
case|:
name|status
operator|=
operator|(
name|evaluate_boolean_expression
argument_list|(
operator|&
name|rc
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: if %s"
argument_list|,
operator|(
name|status
condition|?
operator|(
name|rc
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX Treat NULL as false */
if|if
condition|(
operator|!
name|status
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|execute_statements
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|rc
condition|?
name|r
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
else|:
name|r
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|eval_statement
case|:
name|status
operator|=
name|evaluate_expression
argument_list|(
operator|(
expr|struct
name|binding_value
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|eval
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: evaluate: %s"
argument_list|,
operator|(
name|status
condition|?
literal|"succeeded"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|return_statement
case|:
name|status
operator|=
name|evaluate_expression
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|retval
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: return: %s"
argument_list|,
operator|(
name|status
condition|?
literal|"succeeded"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|add_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: add %s"
argument_list|,
operator|(
name|r
operator|->
name|data
operator|.
name|add
operator|->
name|name
condition|?
name|r
operator|->
name|data
operator|.
name|add
operator|->
name|name
else|:
literal|"<unnamed class>"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|classify
argument_list|(
name|packet
argument_list|,
name|r
operator|->
name|data
operator|.
name|add
argument_list|)
expr_stmt|;
break|break;
case|case
name|break_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: break"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|supersede_option_statement
case|:
case|case
name|send_option_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: %s option %s.%s"
argument_list|,
operator|(
name|r
operator|->
name|op
operator|==
name|supersede_option_statement
condition|?
literal|"supersede"
else|:
literal|"send"
operator|)
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|option_statement
goto|;
endif|#
directive|endif
case|case
name|default_option_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: default option %s.%s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|option_statement
goto|;
endif|#
directive|endif
case|case
name|append_option_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: append option %s.%s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|option_statement
goto|;
endif|#
directive|endif
case|case
name|prepend_option_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: prepend option %s.%s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
name|option_statement
label|:
endif|#
directive|endif
name|set_option
argument_list|(
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
argument_list|,
name|out_options
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
argument_list|,
name|r
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|set_statement
case|:
case|case
name|define_statement
case|:
if|if
condition|(
operator|!
name|scope
condition|)
block|{
name|log_error
argument_list|(
literal|"set %s: no scope"
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|scope
condition|)
block|{
if|if
condition|(
operator|!
name|binding_scope_allocate
argument_list|(
name|scope
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"set %s: can't allocate scope"
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: set %s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|binding
condition|)
block|{
name|binding
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
name|memset
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|binding
argument_list|)
expr_stmt|;
name|binding
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|name
condition|)
block|{
name|strcpy
argument_list|(
name|binding
operator|->
name|name
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
name|binding
operator|->
name|next
operator|=
operator|(
operator|*
name|scope
operator|)
operator|->
name|bindings
expr_stmt|;
operator|(
operator|*
name|scope
operator|)
operator|->
name|bindings
operator|=
name|binding
expr_stmt|;
block|}
else|else
block|{
name|badalloc
label|:
name|dfree
argument_list|(
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|binding
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|binding
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|set_statement
condition|)
block|{
name|status
operator|=
operator|(
name|evaluate_expression
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|binding_value_allocate
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
block|{
name|dfree
argument_list|(
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|binding
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|binding
operator|->
name|value
condition|)
block|{
name|binding
operator|->
name|value
operator|->
name|type
operator|=
name|binding_function
expr_stmt|;
operator|(
name|fundef_reference
argument_list|(
operator|&
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|fundef
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|expr
operator|->
name|data
operator|.
name|func
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: set %s%s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|,
operator|(
name|binding
operator|&&
name|status
condition|?
literal|""
else|:
literal|" (failed)"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|unset_statement
case|:
if|if
condition|(
operator|!
name|scope
operator|||
operator|!
operator|*
name|scope
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|unset
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: unset %s: %s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|unset
argument_list|,
operator|(
name|status
condition|?
literal|"found"
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|let_statement
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: let %s"
argument_list|,
name|r
operator|->
name|data
operator|.
name|let
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ns
operator|=
operator|(
expr|struct
name|binding_scope
operator|*
operator|)
literal|0
expr_stmt|;
name|binding_scope_allocate
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|e
operator|=
name|r
expr_stmt|;
name|next_let
label|:
if|if
condition|(
name|ns
condition|)
block|{
name|binding
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
condition|)
block|{
name|blb
label|:
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|binding
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|name
operator|+
literal|1
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|name
condition|)
name|strcpy
argument_list|(
name|binding
operator|->
name|name
argument_list|,
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|dfree
argument_list|(
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|binding
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
expr_stmt|;
goto|goto
name|blb
goto|;
block|}
block|}
block|}
if|if
condition|(
name|ns
operator|&&
name|binding
condition|)
block|{
name|status
operator|=
operator|(
name|evaluate_expression
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|e
operator|->
name|data
operator|.
name|set
operator|.
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
name|binding
operator|->
name|next
operator|=
name|ns
operator|->
name|bindings
expr_stmt|;
name|ns
operator|->
name|bindings
operator|=
name|binding
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: let %s%s"
argument_list|,
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|name
argument_list|,
operator|(
name|binding
operator|&&
name|status
condition|?
literal|""
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|statements
condition|)
block|{ 			}
elseif|else
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|statements
operator|->
name|op
operator|==
name|let_statement
condition|)
block|{
name|e
operator|=
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|statements
expr_stmt|;
goto|goto
name|next_let
goto|;
block|}
elseif|else
if|if
condition|(
name|ns
condition|)
block|{
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
name|binding_scope_reference
argument_list|(
operator|&
name|ns
operator|->
name|outer
argument_list|,
operator|*
name|scope
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|execute_statements
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
operator|&
name|ns
argument_list|,
name|e
operator|->
name|data
operator|.
name|let
operator|.
name|statements
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns
condition|)
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_statement
case|:
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|r
operator|->
name|data
operator|.
name|log
operator|.
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"exec: log"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|data
operator|.
name|log
operator|.
name|priority
condition|)
block|{
case|case
name|log_priority_fatal
case|:
name|log_fatal
argument_list|(
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ds
operator|.
name|len
argument_list|,
name|ds
operator|.
name|buffer
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_error
case|:
name|log_error
argument_list|(
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ds
operator|.
name|len
argument_list|,
name|ds
operator|.
name|buffer
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_debug
case|:
name|log_debug
argument_list|(
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ds
operator|.
name|len
argument_list|,
name|ds
operator|.
name|buffer
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_info
case|:
name|log_info
argument_list|(
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ds
operator|.
name|len
argument_list|,
name|ds
operator|.
name|buffer
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|log_error
argument_list|(
literal|"bogus statement type %d"
argument_list|,
name|r
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
name|executable_statement_dereference
argument_list|(
operator|&
name|r
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|executable_statement_reference
argument_list|(
operator|&
name|r
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
operator|&
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Execute all the statements in a particular scope, and all statements in    scopes outer from that scope, but if a particular limiting scope is    reached, do not execute statements in that scope or in scopes outer    from it.   More specific scopes need to take precedence over less    specific scopes, so we recursively traverse the scope list, executing    the most outer scope first. */
end_comment

begin_function
name|void
name|execute_statements_in_scope
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|out_options
parameter_list|,
name|scope
parameter_list|,
name|group
parameter_list|,
name|limiting_group
parameter_list|)
name|struct
name|binding_value
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|out_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|struct
name|group
modifier|*
name|limiting_group
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|limit
decl_stmt|;
comment|/* If we've recursed as far as we can, return. */
if|if
condition|(
operator|!
name|group
condition|)
return|return;
comment|/* As soon as we get to a scope that is outer than the limiting 	   scope, we are done.   This is so that if somebody does something 	   like this, it does the expected thing:  	        domain-name "fugue.com"; 		shared-network FOO { 			host bar { 				domain-name "othello.fugue.com"; 				fixed-address 10.20.30.40; 			} 			subnet 10.20.30.0 netmask 255.255.255.0 { 				domain-name "manhattan.fugue.com"; 			} 		}  	   The problem with the above arrangement is that the host's 	   group nesting will be host -> shared-network -> top-level, 	   and the limiting scope when we evaluate the host's scope 	   will be the subnet -> shared-network -> top-level, so we need 	   to know when we evaluate the host's scope to stop before we 	   evaluate the shared-networks scope, because it's outer than 	   the limiting scope, which means we've already evaluated it. */
for|for
control|(
name|limit
operator|=
name|limiting_group
init|;
name|limit
condition|;
name|limit
operator|=
name|limit
operator|->
name|next
control|)
block|{
if|if
condition|(
name|group
operator|==
name|limit
condition|)
return|return;
block|}
if|if
condition|(
name|group
operator|->
name|next
condition|)
name|execute_statements_in_scope
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|group
operator|->
name|next
argument_list|,
name|limiting_group
argument_list|)
expr_stmt|;
name|execute_statements
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|group
operator|->
name|statements
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dereference or free any subexpressions of a statement being freed. */
end_comment

begin_function
name|int
name|executable_statement_dereference
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|executable_statement
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
operator|*
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): null pointer"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
operator|--
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|,
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|op
condition|)
block|{
case|case
name|statements_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|statements
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|statements
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|on_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|statements
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|switch_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|statements
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|case_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|c_case
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|if_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|eval_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|eval
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|eval
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|return_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|eval
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|eval
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|set_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|name
condition|)
name|dfree
argument_list|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|unset_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|unset
condition|)
name|dfree
argument_list|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|unset
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|supersede_option_statement
case|:
case|case
name|send_option_statement
case|:
case|case
name|default_option_statement
case|:
case|case
name|append_option_statement
case|:
case|case
name|prepend_option_statement
case|:
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|option
condition|)
name|option_cache_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|option
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Nothing to do. */
break|break;
block|}
name|dfree
argument_list|(
operator|(
operator|*
name|ptr
operator|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|write_statements
parameter_list|(
name|file
parameter_list|,
name|statements
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|statements
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|struct
name|executable_statement
modifier|*
name|r
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|int
name|col
decl_stmt|;
if|if
condition|(
operator|!
name|statements
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|statements
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|r
operator|->
name|op
condition|)
block|{
case|case
name|statements_statement
case|:
name|write_statements
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|statements
argument_list|,
name|indent
argument_list|)
expr_stmt|;
break|break;
case|case
name|on_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"on "
argument_list|)
expr_stmt|;
name|s
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_EXPIRY
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sexpiry"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" or "
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_COMMIT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%scommit"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"or"
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator|&
name|ON_RELEASE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%srelease"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"or"
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" {"
argument_list|)
expr_stmt|;
name|write_statements
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|switch_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"switch ("
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|7
argument_list|,
name|indent
operator|+
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|7
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|write_statements
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|s_switch
operator|.
name|statements
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|case_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"case "
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|5
argument_list|,
name|indent
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|5
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
break|break;
case|case
name|default_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"default: "
argument_list|)
expr_stmt|;
break|break;
case|case
name|if_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"if "
argument_list|)
expr_stmt|;
name|x
operator|=
name|r
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|else_if
label|:
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|write_statements
argument_list|(
name|file
argument_list|,
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
operator|&&
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
operator|->
name|op
operator|==
name|if_statement
operator|&&
operator|!
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
operator|->
name|next
condition|)
block|{
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"} elsif "
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|6
argument_list|,
name|indent
operator|+
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|else_if
goto|;
block|}
if|if
condition|(
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
condition|)
block|{
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"} else {"
argument_list|)
expr_stmt|;
name|write_statements
argument_list|(
name|file
argument_list|,
name|x
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|eval_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"eval "
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|eval
argument_list|,
name|indent
operator|+
literal|5
argument_list|,
name|indent
operator|+
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
break|break;
case|case
name|return_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"return;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|add_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"add \"%s\""
argument_list|,
name|r
operator|->
name|data
operator|.
name|add
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|break_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"break;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|supersede_option_statement
case|:
case|case
name|send_option_statement
case|:
name|s
operator|=
literal|"supersede"
expr_stmt|;
goto|goto
name|option_statement
goto|;
case|case
name|default_option_statement
case|:
name|s
operator|=
literal|"default"
expr_stmt|;
goto|goto
name|option_statement
goto|;
case|case
name|append_option_statement
case|:
name|s
operator|=
literal|"append"
expr_stmt|;
goto|goto
name|option_statement
goto|;
case|case
name|prepend_option_statement
case|:
name|s
operator|=
literal|"prepend"
expr_stmt|;
name|option_statement
label|:
comment|/* Note: the reason we don't try to pretty print 			   the option here is that the format of the option 			   may change in dhcpd.conf, and then when this 			   statement was read back, it would cause a syntax 			   error. */
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|==
operator|&
name|dhcp_universe
condition|)
block|{
name|t
operator|=
literal|""
expr_stmt|;
name|dot
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|universe
operator|->
name|name
operator|)
expr_stmt|;
name|dot
operator|=
literal|"."
expr_stmt|;
block|}
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %s%s%s = "
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
name|dot
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
name|col
operator|=
operator|(
name|indent
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
name|strlen
argument_list|(
name|dot
argument_list|)
operator|+
name|strlen
argument_list|(
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|option
operator|->
name|name
argument_list|)
operator|+
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|expression
condition|)
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|expression
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|token_indent_data_string
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|8
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
operator|&
name|r
operator|->
name|data
operator|.
name|option
operator|->
name|data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|set_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"set "
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|" "
argument_list|,
literal|" "
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
name|indent
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
break|break;
case|case
name|unset_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"unset "
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|6
argument_list|,
name|indent
operator|+
literal|6
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|r
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|6
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_statement
case|:
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"log "
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|data
operator|.
name|log
operator|.
name|priority
condition|)
block|{
case|case
name|log_priority_fatal
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"fatal,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_error
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"error,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_debug
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"debug,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_priority_info
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"info,"
argument_list|)
expr_stmt|;
break|break;
block|}
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|r
operator|->
name|data
operator|.
name|log
operator|.
name|expr
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|");"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_fatal
argument_list|(
literal|"bogus statement type %d\n"
argument_list|,
name|r
operator|->
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Find a case statement in the sequence of executable statements that    matches the expression, and if found, return the following statement.    If no case statement matches, try to find a default statement and    return that (the default statement can precede all the case statements).    Otherwise, return the null statement. */
end_comment

begin_function
name|int
name|find_matching_case
parameter_list|(
name|struct
name|executable_statement
modifier|*
modifier|*
name|ep
parameter_list|,
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|out_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|struct
name|executable_statement
modifier|*
name|stmt
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|sub
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|foo
decl_stmt|;
if|if
condition|(
name|is_data_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|struct
name|executable_statement
modifier|*
name|e
decl_stmt|;
name|struct
name|data_string
name|cd
decl_stmt|,
name|ds
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cd
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
for|for
control|(
name|s
operator|=
name|stmt
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|op
operator|==
name|case_statement
condition|)
block|{
name|sub
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|cd
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|s
operator|->
name|data
operator|.
name|c_case
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
name|cd
operator|.
name|len
operator|==
name|ds
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|cd
operator|.
name|data
argument_list|,
name|ds
operator|.
name|data
argument_list|,
name|cd
operator|.
name|len
argument_list|)
condition|)
block|{
name|data_string_forget
argument_list|(
operator|&
name|cd
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|executable_statement_reference
argument_list|(
name|ep
argument_list|,
name|s
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|cd
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|long
name|n
decl_stmt|,
name|c
decl_stmt|;
name|status
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|n
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
for|for
control|(
name|s
operator|=
name|stmt
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|op
operator|==
name|case_statement
condition|)
block|{
name|sub
operator|=
operator|(
name|evaluate_numeric_expression
argument_list|(
operator|&
name|c
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|out_options
argument_list|,
name|scope
argument_list|,
name|s
operator|->
name|data
operator|.
name|c_case
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
name|n
operator|==
name|c
condition|)
block|{
name|executable_statement_reference
argument_list|(
name|ep
argument_list|,
name|s
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* If we didn't find a matching case statement, look for a default 	   statement and return the statement following it. */
for|for
control|(
name|s
operator|=
name|stmt
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|op
operator|==
name|default_statement
condition|)
break|break;
if|if
condition|(
name|s
condition|)
block|{
name|executable_statement_reference
argument_list|(
name|ep
argument_list|,
name|s
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|executable_statement_foreach
parameter_list|(
name|struct
name|executable_statement
modifier|*
name|stmt
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|executable_statement
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|void
modifier|*
name|vp
parameter_list|,
name|int
name|condp
parameter_list|)
block|{
name|struct
name|executable_statement
modifier|*
name|foo
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
for|for
control|(
name|foo
operator|=
name|stmt
init|;
name|foo
condition|;
name|foo
operator|=
name|foo
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|callback
call|)
argument_list|(
name|foo
argument_list|,
name|vp
argument_list|,
name|condp
argument_list|)
operator|!=
literal|0
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|foo
operator|->
name|op
condition|)
block|{
case|case
name|null_statement
case|:
break|break;
case|case
name|if_statement
case|:
if|if
condition|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|add_statement
case|:
break|break;
case|case
name|eval_statement
case|:
break|break;
case|case
name|break_statement
case|:
break|break;
case|case
name|default_option_statement
case|:
break|break;
case|case
name|supersede_option_statement
case|:
break|break;
case|case
name|append_option_statement
case|:
break|break;
case|case
name|prepend_option_statement
case|:
break|break;
case|case
name|send_option_statement
case|:
break|break;
case|case
name|statements_statement
case|:
if|if
condition|(
operator|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|statements
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
name|condp
argument_list|)
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|on_statement
case|:
if|if
condition|(
operator|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|switch_statement
case|:
if|if
condition|(
operator|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|s_switch
operator|.
name|statements
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|case_statement
case|:
break|break;
case|case
name|default_statement
case|:
break|break;
case|case
name|set_statement
case|:
break|break;
case|case
name|unset_statement
case|:
break|break;
case|case
name|let_statement
case|:
if|if
condition|(
operator|(
name|executable_statement_foreach
argument_list|(
name|foo
operator|->
name|data
operator|.
name|let
operator|.
name|statements
argument_list|,
name|callback
argument_list|,
name|vp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|define_statement
case|:
break|break;
case|case
name|log_statement
case|:
case|case
name|return_statement
case|:
break|break;
block|}
block|}
return|return
name|ok
return|;
block|}
end_function

end_unit

