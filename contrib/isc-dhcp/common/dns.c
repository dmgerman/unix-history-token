begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dns.c     Domain Name Service subroutines. */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: dns.c,v 1.35.2.10 2001/10/26 21:26:39 mellon Exp $ Copyright (c) 2001 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"arpa/nameser.h"
end_include

begin_include
include|#
directive|include
file|"dst/md5.h"
end_include

begin_comment
comment|/* This file is kind of a crutch for the BIND 8 nsupdate code, which has  * itself been cruelly hacked from its original state.   What this code  * does is twofold: first, it maintains a database of zone cuts that can  * be used to figure out which server should be contacted to update any  * given domain name.   Secondly, it maintains a set of named TSIG keys,  * and associates those keys with zones.   When an update is requested for  * a particular zone, the key associated with that zone is used for the  * update.  *  * The way this works is that you define the domain name to which an  * SOA corresponds, and the addresses of some primaries for that domain name:  *  *	zone FOO.COM {  *	  primary 10.0.17.1;  *	  secondary 10.0.22.1, 10.0.23.1;  *	  key "FOO.COM Key";  * 	}  *  * If an update is requested for GAZANGA.TOPANGA.FOO.COM, then the name  * server looks in its database for a zone record for "GAZANGA.TOPANGA.FOO.COM",  * doesn't find it, looks for one for "TOPANGA.FOO.COM", doesn't find *that*,  * looks for "FOO.COM", finds it. So it  * attempts the update to the primary for FOO.COM.   If that times out, it  * tries the secondaries.   You can list multiple primaries if you have some  * kind of magic name server that supports that.   You shouldn't list  * secondaries that don't know how to forward updates (e.g., BIND 8 doesn't  * support update forwarding, AFAIK).   If no TSIG key is listed, the update  * is attempted without TSIG.  *  * The DHCP server tries to find an existing zone for any given name by  * trying to look up a local zone structure for each domain containing  * that name, all the way up to '.'.   If it finds one cached, it tries  * to use that one to do the update.   That's why it tries to update  * "FOO.COM" above, even though theoretically it should try GAZANGA...  * and TOPANGA... first.  *  * If the update fails with a predefined or cached zone (we'll get to  * those in a second), then it tries to find a more specific zone.   This  * is done by looking first for an SOA for GAZANGA.TOPANGA.FOO.COM.   Then  * an SOA for TOPANGA.FOO.COM is sought.   If during this search a predefined  * or cached zone is found, the update fails - there's something wrong  * somewhere.  *  * If a more specific zone _is_ found, that zone is cached for the length of  * its TTL in the same database as that described above.   TSIG updates are  * never done for cached zones - if you want TSIG updates you _must_  * write a zone definition linking the key to the zone.   In cases where you  * know for sure what the key is but do not want to hardcode the IP addresses  * of the primary or secondaries, a zone declaration can be made that doesn't  * include any primary or secondary declarations.   When the DHCP server  * encounters this while hunting up a matching zone for a name, it looks up  * the SOA, fills in the IP addresses, and uses that record for the update.  * If the SOA lookup returns NXRRSET, a warning is printed and the zone is  * discarded, TSIG key and all.   The search for the zone then continues as if  * the zone record hadn't been found.   Zones without IP addresses don't  * match when initially hunting for a predefined or cached zone to update.  *  * When an update is attempted and no predefined or cached zone is found  * that matches any enclosing domain of the domain being updated, the DHCP  * server goes through the same process that is done when the update to a  * predefined or cached zone fails - starting with the most specific domain  * name (GAZANGA.TOPANGA.FOO.COM) and moving to the least specific (the root),  * it tries to look up an SOA record.   When it finds one, it creates a cached  * zone and attempts an update, and gives up if the update fails.  *  * TSIG keys are defined like this:  *  *	key "FOO.COM Key" {  *		algorithm HMAC-MD5.SIG-ALG.REG.INT;  *		secret<Base64>;  *	}  *  *<Base64> is a number expressed in base64 that represents the key.  * It's also permissible to use a quoted string here - this will be  * translated as the ASCII bytes making up the string, and will not  * include any NUL termination.  The key name can be any text string,  * and the key type must be one of the key types defined in the draft  * or by the IANA.  Currently only the HMAC-MD5... key type is  * supported.  */
end_comment

begin_decl_stmt
name|dns_zone_hash_t
modifier|*
name|dns_zone_hash
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
end_if

begin_function
name|isc_result_t
name|find_tsig_key
parameter_list|(
name|ns_tsig_key
modifier|*
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|zname
parameter_list|,
name|struct
name|dns_zone
modifier|*
name|zone
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|ns_tsig_key
modifier|*
name|tkey
decl_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
if|if
condition|(
operator|!
name|zone
operator|->
name|key
condition|)
block|{
return|return
name|ISC_R_KEY_UNKNOWN
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|zone
operator|->
name|key
operator|->
name|name
operator|||
name|strlen
argument_list|(
name|zone
operator|->
name|key
operator|->
name|name
argument_list|)
operator|>
name|NS_MAXDNAME
operator|)
operator|||
operator|(
operator|!
name|zone
operator|->
name|key
operator|->
name|algorithm
operator|||
name|strlen
argument_list|(
name|zone
operator|->
name|key
operator|->
name|algorithm
argument_list|)
operator|>
name|NS_MAXDNAME
operator|)
operator|||
operator|(
operator|!
name|zone
operator|->
name|key
operator|)
operator|||
operator|(
operator|!
name|zone
operator|->
name|key
operator|->
name|key
operator|)
operator|||
operator|(
name|zone
operator|->
name|key
operator|->
name|key
operator|->
name|len
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|ISC_R_INVALIDKEY
return|;
block|}
name|tkey
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tkey
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tkey
condition|)
block|{
name|nomem
label|:
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|memset
argument_list|(
name|tkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|tkey
argument_list|)
expr_stmt|;
name|tkey
operator|->
name|data
operator|=
name|dmalloc
argument_list|(
name|zone
operator|->
name|key
operator|->
name|key
operator|->
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tkey
operator|->
name|data
condition|)
block|{
name|dfree
argument_list|(
name|tkey
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|strcpy
argument_list|(
name|tkey
operator|->
name|name
argument_list|,
name|zone
operator|->
name|key
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tkey
operator|->
name|alg
argument_list|,
name|zone
operator|->
name|key
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tkey
operator|->
name|data
argument_list|,
name|zone
operator|->
name|key
operator|->
name|key
operator|->
name|value
argument_list|,
name|zone
operator|->
name|key
operator|->
name|key
operator|->
name|len
argument_list|)
expr_stmt|;
name|tkey
operator|->
name|len
operator|=
name|zone
operator|->
name|key
operator|->
name|key
operator|->
name|len
expr_stmt|;
operator|*
name|key
operator|=
name|tkey
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|tkey_free
parameter_list|(
name|ns_tsig_key
modifier|*
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|key
operator|)
operator|->
name|data
condition|)
name|dfree
argument_list|(
operator|(
operator|*
name|key
operator|)
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
operator|(
operator|*
name|key
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|key
operator|=
operator|(
name|ns_tsig_key
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|enter_dns_zone
parameter_list|(
name|struct
name|dns_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|dns_zone
modifier|*
name|tz
init|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|dns_zone_hash
condition|)
block|{
name|dns_zone_hash_lookup
argument_list|(
operator|&
name|tz
argument_list|,
name|dns_zone_hash
argument_list|,
name|zone
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tz
operator|==
name|zone
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|tz
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
if|if
condition|(
name|tz
condition|)
block|{
name|dns_zone_hash_delete
argument_list|(
name|dns_zone_hash
argument_list|,
name|zone
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dns_zone_dereference
argument_list|(
operator|&
name|tz
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dns_zone_new_hash
argument_list|(
operator|&
name|dns_zone_hash
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
block|}
name|dns_zone_hash_add
argument_list|(
name|dns_zone_hash
argument_list|,
name|zone
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_zone_lookup
parameter_list|(
name|struct
name|dns_zone
modifier|*
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|dns_zone
modifier|*
name|tz
init|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|tname
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|dns_zone_hash
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|tname
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|2
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tname
condition|)
return|return
name|ISC_R_NOMEMORY
return|;
empty_stmt|;
name|strcpy
argument_list|(
name|tname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tname
index|[
name|len
index|]
operator|=
literal|'.'
expr_stmt|;
name|tname
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|tname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dns_zone_hash_lookup
argument_list|(
name|zone
argument_list|,
name|dns_zone_hash
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
condition|)
name|status
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
else|else
name|status
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|tname
condition|)
name|dfree
argument_list|(
name|tname
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|dns_zone_dereference
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|dns_zone
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dns_zone
modifier|*
name|dns_zone
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
operator|*
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): null pointer"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|dns_zone
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
expr_stmt|;
operator|--
name|dns_zone
operator|->
name|refcnt
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
name|dns_zone
argument_list|,
name|dns_zone
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zone
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dns_zone
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
name|dns_zone
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|dns_zone
operator|->
name|name
condition|)
name|dfree
argument_list|(
name|dns_zone
operator|->
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zone
operator|->
name|key
condition|)
name|omapi_auth_key_dereference
argument_list|(
operator|&
name|dns_zone
operator|->
name|key
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zone
operator|->
name|primary
condition|)
name|option_cache_dereference
argument_list|(
operator|&
name|dns_zone
operator|->
name|primary
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zone
operator|->
name|secondary
condition|)
name|option_cache_dereference
argument_list|(
operator|&
name|dns_zone
operator|->
name|secondary
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|dns_zone
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
end_if

begin_function
name|isc_result_t
name|find_cached_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|ns_class
name|class
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|,
name|size_t
name|zsize
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addrs
parameter_list|,
name|int
name|naddrs
parameter_list|,
name|int
modifier|*
name|naddrout
parameter_list|,
name|struct
name|dns_zone
modifier|*
modifier|*
name|zcookie
parameter_list|)
block|{
name|isc_result_t
name|status
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
name|struct
name|dns_zone
modifier|*
name|zone
init|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|data_string
name|nsaddrs
decl_stmt|;
name|int
name|ix
decl_stmt|;
comment|/* The absence of the zcookie pointer indicates that we 	   succeeded previously, but the update itself failed, meaning 	   that we shouldn't use the cached zone. */
if|if
condition|(
operator|!
name|zcookie
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
comment|/* We can't look up a null zone. */
if|if
condition|(
operator|!
name|dname
operator|||
operator|!
operator|*
name|dname
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* For each subzone, try to find a cached zone. */
for|for
control|(
name|np
operator|=
name|dname
init|;
name|np
condition|;
name|np
operator|=
name|strchr
argument_list|(
name|np
argument_list|,
literal|'.'
argument_list|)
control|)
block|{
name|np
operator|++
expr_stmt|;
name|status
operator|=
name|dns_zone_lookup
argument_list|(
operator|&
name|zone
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Make sure the zone is valid. */
if|if
condition|(
name|zone
operator|->
name|timeout
operator|&&
name|zone
operator|->
name|timeout
operator|<
name|cur_time
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_CANCELED
return|;
block|}
comment|/* Make sure the zone name will fit. */
if|if
condition|(
name|strlen
argument_list|(
name|zone
operator|->
name|name
argument_list|)
operator|>
name|zsize
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOSPACE
return|;
block|}
name|strcpy
argument_list|(
name|zname
argument_list|,
name|zone
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|nsaddrs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nsaddrs
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|primary
condition|)
block|{
if|if
condition|(
name|evaluate_option_cache
argument_list|(
operator|&
name|nsaddrs
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|zone
operator|->
name|primary
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|int
name|ip
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ix
operator|<
name|naddrs
condition|)
block|{
if|if
condition|(
name|ip
operator|+
literal|4
operator|>
name|nsaddrs
operator|.
name|len
condition|)
break|break;
name|memcpy
argument_list|(
operator|&
name|addrs
index|[
name|ix
index|]
argument_list|,
operator|&
name|nsaddrs
operator|.
name|data
index|[
name|ip
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|nsaddrs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zone
operator|->
name|secondary
condition|)
block|{
if|if
condition|(
name|evaluate_option_cache
argument_list|(
operator|&
name|nsaddrs
argument_list|,
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|global_scope
argument_list|,
name|zone
operator|->
name|secondary
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|int
name|ip
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ix
operator|<
name|naddrs
condition|)
block|{
if|if
condition|(
name|ip
operator|+
literal|4
operator|>
name|nsaddrs
operator|.
name|len
condition|)
break|break;
name|memcpy
argument_list|(
operator|&
name|addrs
index|[
name|ix
index|]
argument_list|,
operator|&
name|nsaddrs
operator|.
name|data
index|[
name|ip
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|nsaddrs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* It's not an error for zcookie to have a value here - actually, 	   it's quite likely, because res_nupdate cycles through all the 	   names in the update looking for their zones. */
if|if
condition|(
operator|!
operator|*
name|zcookie
condition|)
name|dns_zone_reference
argument_list|(
name|zcookie
argument_list|,
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|naddrout
condition|)
operator|*
name|naddrout
operator|=
name|ix
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|forget_zone
parameter_list|(
name|struct
name|dns_zone
modifier|*
modifier|*
name|zone
parameter_list|)
block|{
name|dns_zone_dereference
argument_list|(
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|repudiate_zone
parameter_list|(
name|struct
name|dns_zone
modifier|*
modifier|*
name|zone
parameter_list|)
block|{
comment|/* XXX Currently we're not differentiating between a cached 	   XXX zone and a zone that's been repudiated, which means 	   XXX that if we reap cached zones, we blow away repudiated 	   XXX zones.   This isn't a big problem since we're not yet 	   XXX caching zones... :'} */
operator|(
operator|*
name|zone
operator|)
operator|->
name|timeout
operator|=
name|cur_time
operator|-
literal|1
expr_stmt|;
name|dns_zone_dereference
argument_list|(
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cache_found_zone
parameter_list|(
name|ns_class
name|class
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addrs
parameter_list|,
name|int
name|naddrs
parameter_list|)
block|{
name|isc_result_t
name|status
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|struct
name|dns_zone
modifier|*
name|zone
init|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|data_string
name|nsaddrs
decl_stmt|;
name|int
name|ix
init|=
name|strlen
argument_list|(
name|zname
argument_list|)
decl_stmt|;
if|if
condition|(
name|zname
index|[
name|ix
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
comment|/* See if there's already such a zone. */
if|if
condition|(
name|dns_zone_lookup
argument_list|(
operator|&
name|zone
argument_list|,
name|zname
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* If it's not a dynamic zone, leave it alone. */
if|if
condition|(
operator|!
name|zone
operator|->
name|timeout
condition|)
return|return;
comment|/* Address may have changed, so just blow it away. */
if|if
condition|(
name|zone
operator|->
name|primary
condition|)
name|option_cache_dereference
argument_list|(
operator|&
name|zone
operator|->
name|primary
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|secondary
condition|)
name|option_cache_dereference
argument_list|(
operator|&
name|zone
operator|->
name|secondary
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dns_zone_allocate
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|zone
operator|->
name|name
condition|)
block|{
name|zone
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|zname
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|ix
operator|!=
literal|0
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|name
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|zone
operator|->
name|name
argument_list|,
name|zname
argument_list|)
expr_stmt|;
comment|/* Add a trailing '.' if it was missing. */
if|if
condition|(
name|ix
condition|)
block|{
name|zone
operator|->
name|name
index|[
name|ix
index|]
operator|=
literal|'.'
expr_stmt|;
name|zone
operator|->
name|name
index|[
name|ix
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* XXX Need to get the lower-level code to push the actual zone 	   XXX TTL up to us. */
name|zone
operator|->
name|timeout
operator|=
name|cur_time
operator|+
literal|1800
expr_stmt|;
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
operator|&
name|zone
operator|->
name|primary
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|zone
operator|->
name|primary
operator|->
name|data
operator|.
name|buffer
argument_list|,
name|naddrs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|zone
operator|->
name|primary
operator|->
name|data
operator|.
name|buffer
operator|->
name|data
argument_list|,
name|addrs
argument_list|,
name|naddrs
operator|*
sizeof|sizeof
expr|*
name|addrs
argument_list|)
expr_stmt|;
name|zone
operator|->
name|primary
operator|->
name|data
operator|.
name|data
operator|=
operator|&
name|zone
operator|->
name|primary
operator|->
name|data
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|zone
operator|->
name|primary
operator|->
name|data
operator|.
name|len
operator|=
name|naddrs
operator|*
sizeof|sizeof
expr|*
name|addrs
expr_stmt|;
name|enter_dns_zone
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have to use TXT records for now. */
end_comment

begin_define
define|#
directive|define
name|T_DHCID
value|T_TXT
end_define

begin_function
name|int
name|get_dhcid
parameter_list|(
name|struct
name|data_string
modifier|*
name|id
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|MD5_CTX
name|md5
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Types can only be 0..(2^16)-1. */
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>
literal|65535
condition|)
return|return
literal|0
return|;
comment|/* Hexadecimal MD5 digest plus two byte type and NUL. */
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|id
operator|->
name|buffer
argument_list|,
operator|(
name|MD5_DIGEST_LENGTH
operator|*
literal|2
operator|)
operator|+
literal|3
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|id
operator|->
name|data
operator|=
name|id
operator|->
name|buffer
operator|->
name|data
expr_stmt|;
comment|/* 	 * DHCP clients and servers should use the following forms of client 	 * identification, starting with the most preferable, and finishing 	 * with the least preferable.  If the client does not send any of these 	 * forms of identification, the DHCP/DDNS interaction is not defined by 	 * this specification.  The most preferable form of identification is 	 * the Globally Unique Identifier Option [TBD].  Next is the DHCP 	 * Client Identifier option.  Last is the client's link-layer address, 	 * as conveyed in its DHCPREQUEST message.  Implementors should note 	 * that the link-layer address cannot be used if there are no 	 * significant bytes in the chaddr field of the DHCP client's request, 	 * because this does not constitute a unique identifier. 	 *   -- "Interaction between DHCP and DNS" 	 *<draft-ietf-dhc-dhcp-dns-12.txt> 	 *      M. Stapp, Y. Rekhter 	 */
comment|/* Put the type in the first two bytes. */
name|id
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|type
operator|>>
literal|4
index|]
expr_stmt|;
name|id
operator|->
name|buffer
operator|->
name|data
index|[
literal|1
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|type
operator|%
literal|15
index|]
expr_stmt|;
comment|/* Mash together an MD5 hash of the identifier. */
name|MD5_Init
argument_list|(
operator|&
name|md5
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md5
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MD5_Final
argument_list|(
name|buf
argument_list|,
operator|&
name|md5
argument_list|)
expr_stmt|;
comment|/* Convert into ASCII. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MD5_DIGEST_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|->
name|buffer
operator|->
name|data
index|[
name|i
operator|*
literal|2
operator|+
literal|2
index|]
operator|=
literal|"0123456789abcdef"
index|[
operator|(
name|buf
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|id
operator|->
name|buffer
operator|->
name|data
index|[
name|i
operator|*
literal|2
operator|+
literal|3
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|buf
index|[
name|i
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
name|id
operator|->
name|len
operator|=
name|MD5_DIGEST_LENGTH
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|id
operator|->
name|buffer
operator|->
name|data
index|[
name|id
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Now for the DDNS update code that is shared between client and    server... */
end_comment

begin_function
name|isc_result_t
name|ddns_update_a
parameter_list|(
name|struct
name|data_string
modifier|*
name|ddns_fwd_name
parameter_list|,
name|struct
name|iaddr
name|ddns_addr
parameter_list|,
name|struct
name|data_string
modifier|*
name|ddns_dhcid
parameter_list|,
name|unsigned
name|long
name|ttl
parameter_list|,
name|int
name|rrsetp
parameter_list|)
block|{
name|ns_updque
name|updqueue
decl_stmt|;
name|ns_updrec
modifier|*
name|updrec
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|ddns_address
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|ddns_addr
operator|.
name|len
operator|!=
literal|4
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
ifndef|#
directive|ifndef
name|NO_SNPRINTF
name|snprintf
argument_list|(
name|ddns_address
argument_list|,
literal|16
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|0
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|1
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|2
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ddns_address
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|0
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|1
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|2
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * When a DHCP client or server intends to update an A RR, it first 	 * prepares a DNS UPDATE query which includes as a prerequisite the 	 * assertion that the name does not exist.  The update section of the 	 * query attempts to add the new name and its IP address mapping (an A 	 * RR), and the DHCID RR with its unique client-identity. 	 *   -- "Interaction between DHCP and DNS" 	 */
name|ISC_LIST_INIT
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
comment|/* 	 * A RR does not exist. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_PREREQ
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|rrsetp
condition|?
name|NXRRSET
else|:
name|NXDOMAIN
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Add A RR. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ddns_address
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|strlen
argument_list|(
name|ddns_address
argument_list|)
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|ADD
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Add DHCID RR. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_DHCID
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
name|ddns_dhcid
operator|->
name|data
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|ddns_dhcid
operator|->
name|len
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|ADD
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to perform the update. 	 */
name|result
operator|=
name|minires_nupdate
argument_list|(
operator|&
name|resolver_state
argument_list|,
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
argument_list|)
expr_stmt|;
name|print_dns_status
argument_list|(
operator|(
name|int
operator|)
name|result
argument_list|,
operator|&
name|updqueue
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|updqueue
argument_list|)
condition|)
block|{
name|updrec
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|minires_freeupdrec
argument_list|(
name|updrec
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this update operation succeeds, the updater can conclude that it 	 * has added a new name whose only RRs are the A and DHCID RR records. 	 * The A RR update is now complete (and a client updater is finished, 	 * while a server might proceed to perform a PTR RR update). 	 *   -- "Interaction between DHCP and DNS" 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
name|result
return|;
comment|/* 	 * If the first update operation fails with YXDOMAIN, the updater can 	 * conclude that the intended name is in use.  The updater then 	 * attempts to confirm that the DNS name is not being used by some 	 * other host. The updater prepares a second UPDATE query in which the 	 * prerequisite is that the desired name has attached to it a DHCID RR 	 * whose contents match the client identity.  The update section of 	 * this query deletes the existing A records on the name, and adds the 	 * A record that matches the DHCP binding and the DHCID RR with the 	 * client identity. 	 *   -- "Interaction between DHCP and DNS" 	 */
if|if
condition|(
name|result
operator|!=
operator|(
name|rrsetp
condition|?
name|ISC_R_YXRRSET
else|:
name|ISC_R_YXDOMAIN
operator|)
condition|)
return|return
name|result
return|;
comment|/* 	 * DHCID RR exists, and matches client identity. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_PREREQ
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_DHCID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
name|ddns_dhcid
operator|->
name|data
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|ddns_dhcid
operator|->
name|len
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Delete A RRset. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|DELETE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Add A RR. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ddns_address
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|strlen
argument_list|(
name|ddns_address
argument_list|)
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|ADD
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to perform the update. 	 */
name|result
operator|=
name|minires_nupdate
argument_list|(
operator|&
name|resolver_state
argument_list|,
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
argument_list|)
expr_stmt|;
name|print_dns_status
argument_list|(
operator|(
name|int
operator|)
name|result
argument_list|,
operator|&
name|updqueue
argument_list|)
expr_stmt|;
comment|/* 	 * If this query succeeds, the updater can conclude that the current 	 * client was the last client associated with the domain name, and that 	 * the name now contains the updated A RR. The A RR update is now 	 * complete (and a client updater is finished, while a server would 	 * then proceed to perform a PTR RR update). 	 *   -- "Interaction between DHCP and DNS" 	 */
comment|/* 	 * If the second query fails with NXRRSET, the updater must conclude 	 * that the client's desired name is in use by another host.  At this 	 * juncture, the updater can decide (based on some administrative 	 * configuration outside of the scope of this document) whether to let 	 * the existing owner of the name keep that name, and to (possibly) 	 * perform some name disambiguation operation on behalf of the current 	 * client, or to replace the RRs on the name with RRs that represent 	 * the current client. If the configured policy allows replacement of 	 * existing records, the updater submits a query that deletes the 	 * existing A RR and the existing DHCID RR, adding A and DHCID RRs that 	 * represent the IP address and client-identity of the new client. 	 *   -- "Interaction between DHCP and DNS" 	 */
name|error
label|:
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|updqueue
argument_list|)
condition|)
block|{
name|updrec
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|minires_freeupdrec
argument_list|(
name|updrec
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ddns_remove_a
parameter_list|(
name|struct
name|data_string
modifier|*
name|ddns_fwd_name
parameter_list|,
name|struct
name|iaddr
name|ddns_addr
parameter_list|,
name|struct
name|data_string
modifier|*
name|ddns_dhcid
parameter_list|)
block|{
name|ns_updque
name|updqueue
decl_stmt|;
name|ns_updrec
modifier|*
name|updrec
decl_stmt|;
name|isc_result_t
name|result
init|=
name|SERVFAIL
decl_stmt|;
name|char
name|ddns_address
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|ddns_addr
operator|.
name|len
operator|!=
literal|4
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
ifndef|#
directive|ifndef
name|NO_SNPRINTF
name|snprintf
argument_list|(
name|ddns_address
argument_list|,
literal|16
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|0
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|1
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|2
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ddns_address
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|0
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|1
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|2
index|]
argument_list|,
name|ddns_addr
operator|.
name|iabuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The entity chosen to handle the A record for this client (either the 	 * client or the server) SHOULD delete the A record that was added when 	 * the lease was made to the client. 	 * 	 * In order to perform this delete, the updater prepares an UPDATE 	 * query which contains two prerequisites.  The first prerequisite 	 * asserts that the DHCID RR exists whose data is the client identity 	 * described in Section 4.3. The second prerequisite asserts that the 	 * data in the A RR contains the IP address of the lease that has 	 * expired or been released. 	 *   -- "Interaction between DHCP and DNS" 	 */
name|ISC_LIST_INIT
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
comment|/* 	 * DHCID RR exists, and matches client identity. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_PREREQ
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_DHCID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
name|ddns_dhcid
operator|->
name|data
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|ddns_dhcid
operator|->
name|len
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * A RR matches the expiring lease. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_PREREQ
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ddns_address
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|strlen
argument_list|(
name|ddns_address
argument_list|)
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Delete appropriate A RR. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ddns_address
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|strlen
argument_list|(
name|ddns_address
argument_list|)
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|DELETE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to perform the update. 	 */
name|result
operator|=
name|minires_nupdate
argument_list|(
operator|&
name|resolver_state
argument_list|,
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
argument_list|)
expr_stmt|;
name|print_dns_status
argument_list|(
operator|(
name|int
operator|)
name|result
argument_list|,
operator|&
name|updqueue
argument_list|)
expr_stmt|;
comment|/* 	 * If the query fails, the updater MUST NOT delete the DNS name.  It 	 * may be that the host whose lease on the server has expired has moved 	 * to another network and obtained a lease from a different server, 	 * which has caused the client's A RR to be replaced. It may also be 	 * that some other client has been configured with a name that matches 	 * the name of the DHCP client, and the policy was that the last client 	 * to specify the name would get the name.  In this case, the DHCID RR 	 * will no longer match the updater's notion of the client-identity of 	 * the host pointed to by the DNS name. 	 *   -- "Interaction between DHCP and DNS" 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* If the rrset isn't there, we didn't need to do the 		   delete, which is success. */
if|if
condition|(
name|result
operator|==
name|ISC_R_NXRRSET
operator|||
name|result
operator|==
name|ISC_R_NXDOMAIN
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|updqueue
argument_list|)
condition|)
block|{
name|updrec
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|minires_freeupdrec
argument_list|(
name|updrec
argument_list|)
expr_stmt|;
block|}
comment|/* If the deletion of the A succeeded, and there are no A records 	   left for this domain, then we can blow away the DHCID record 	   as well.   We can't blow away the DHCID record above because 	   it's possible that more than one A has been added to this 	   domain name. */
name|ISC_LIST_INIT
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
comment|/* 	 * A RR does not exist. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_PREREQ
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
literal|0
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|NXRRSET
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Delete appropriate DHCID RR. 	 */
name|updrec
operator|=
name|minires_mkupdrec
argument_list|(
name|S_UPDATE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddns_fwd_name
operator|->
name|data
argument_list|,
name|C_IN
argument_list|,
name|T_DHCID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updrec
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|updrec
operator|->
name|r_data
operator|=
name|ddns_dhcid
operator|->
name|data
expr_stmt|;
name|updrec
operator|->
name|r_size
operator|=
name|ddns_dhcid
operator|->
name|len
expr_stmt|;
name|updrec
operator|->
name|r_opcode
operator|=
name|DELETE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to perform the update. 	 */
name|result
operator|=
name|minires_nupdate
argument_list|(
operator|&
name|resolver_state
argument_list|,
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
argument_list|)
expr_stmt|;
name|print_dns_status
argument_list|(
operator|(
name|int
operator|)
name|result
argument_list|,
operator|&
name|updqueue
argument_list|)
expr_stmt|;
comment|/* Fall through. */
name|error
label|:
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|updqueue
argument_list|)
condition|)
block|{
name|updrec
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|updqueue
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|updqueue
argument_list|,
name|updrec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|minires_freeupdrec
argument_list|(
name|updrec
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSUPDATE */
end_comment

begin_macro
name|HASH_FUNCTIONS
argument_list|(
argument|dns_zone
argument_list|,
argument|const char *
argument_list|,
argument|struct dns_zone
argument_list|,
argument|dns_zone_hash_t
argument_list|,
argument|dns_zone_reference
argument_list|,
argument|dns_zone_dereference
argument_list|)
end_macro

end_unit

