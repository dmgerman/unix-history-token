begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* memory.c     Memory-resident database... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: memory.c,v 1.35.2.4 1999/05/27 17:47:43 mellon Exp $ Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|subnet
modifier|*
name|subnets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|shared_network
modifier|*
name|shared_networks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|host_hw_addr_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|host_uid_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|lease_uid_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|lease_ip_addr_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|lease_hw_addr_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lease
modifier|*
name|dangling_leases
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|vendor_class_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_table
modifier|*
name|user_class_hash
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|enter_host
parameter_list|(
name|hd
parameter_list|)
name|struct
name|host_decl
modifier|*
name|hd
decl_stmt|;
block|{
name|struct
name|host_decl
modifier|*
name|hp
init|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|host_decl
modifier|*
name|np
init|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
literal|0
decl_stmt|;
name|hd
operator|->
name|n_ipaddr
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|interface
operator|.
name|hlen
condition|)
block|{
if|if
condition|(
operator|!
name|host_hw_addr_hash
condition|)
name|host_hw_addr_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
else|else
name|hp
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
name|hash_lookup
argument_list|(
name|host_hw_addr_hash
argument_list|,
name|hd
operator|->
name|interface
operator|.
name|haddr
argument_list|,
name|hd
operator|->
name|interface
operator|.
name|hlen
argument_list|)
expr_stmt|;
comment|/* If there isn't already a host decl matching this 		   address, add it to the hash table. */
if|if
condition|(
operator|!
name|hp
condition|)
name|add_hash
argument_list|(
name|host_hw_addr_hash
argument_list|,
name|hd
operator|->
name|interface
operator|.
name|haddr
argument_list|,
name|hd
operator|->
name|interface
operator|.
name|hlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hd
argument_list|)
expr_stmt|;
block|}
comment|/* If there was already a host declaration for this hardware 	   address, add this one to the end of the list. */
if|if
condition|(
name|hp
condition|)
block|{
for|for
control|(
name|np
operator|=
name|hp
init|;
name|np
operator|->
name|n_ipaddr
condition|;
name|np
operator|=
name|np
operator|->
name|n_ipaddr
control|)
empty_stmt|;
name|np
operator|->
name|n_ipaddr
operator|=
name|hd
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|tree_evaluate
argument_list|(
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
argument_list|)
condition|)
return|return;
comment|/* If there's no uid hash, make one; otherwise, see if 		   there's already an entry in the hash for this host. */
if|if
condition|(
operator|!
name|host_uid_hash
condition|)
block|{
name|host_uid_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
name|hash_lookup
argument_list|(
name|host_uid_hash
argument_list|,
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|value
argument_list|,
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* If there's already a host declaration for this 		   client identifier, add this one to the end of the 		   list.  Otherwise, add it to the hash table. */
if|if
condition|(
name|hp
condition|)
block|{
comment|/* Don't link it in twice... */
if|if
condition|(
operator|!
name|np
condition|)
block|{
for|for
control|(
name|np
operator|=
name|hp
init|;
name|np
operator|->
name|n_ipaddr
condition|;
name|np
operator|=
name|np
operator|->
name|n_ipaddr
control|)
empty_stmt|;
name|np
operator|->
name|n_ipaddr
operator|=
name|hd
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_hash
argument_list|(
name|host_uid_hash
argument_list|,
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|value
argument_list|,
name|hd
operator|->
name|group
operator|->
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|host_decl
modifier|*
name|find_hosts_by_haddr
parameter_list|(
name|htype
parameter_list|,
name|haddr
parameter_list|,
name|hlen
parameter_list|)
name|int
name|htype
decl_stmt|;
name|unsigned
name|char
modifier|*
name|haddr
decl_stmt|;
name|int
name|hlen
decl_stmt|;
block|{
name|struct
name|host_decl
modifier|*
name|foo
decl_stmt|;
name|foo
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
name|hash_lookup
argument_list|(
name|host_hw_addr_hash
argument_list|,
name|haddr
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_function
name|struct
name|host_decl
modifier|*
name|find_hosts_by_uid
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|host_decl
modifier|*
name|foo
decl_stmt|;
name|foo
operator|=
operator|(
expr|struct
name|host_decl
operator|*
operator|)
name|hash_lookup
argument_list|(
name|host_uid_hash
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_comment
comment|/* More than one host_decl can be returned by find_hosts_by_haddr or    find_hosts_by_uid, and each host_decl can have multiple addresses.    Loop through the list of hosts, and then for each host, through the    list of addresses, looking for an address that's in the same shared    network as the one specified.    Store the matching address through    the addr pointer, update the host pointer to point at the host_decl    that matched, and return the subnet that matched. */
end_comment

begin_function
name|struct
name|subnet
modifier|*
name|find_host_for_network
parameter_list|(
name|host
parameter_list|,
name|addr
parameter_list|,
name|share
parameter_list|)
name|struct
name|host_decl
modifier|*
modifier|*
name|host
decl_stmt|;
name|struct
name|iaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|share
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
name|struct
name|iaddr
name|ip_address
decl_stmt|;
name|struct
name|host_decl
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|host
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|n_ipaddr
control|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|fixed_addr
operator|||
operator|!
name|tree_evaluate
argument_list|(
name|hp
operator|->
name|fixed_addr
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hp
operator|->
name|fixed_addr
operator|->
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ip_address
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|ip_address
operator|.
name|iabuf
argument_list|,
name|hp
operator|->
name|fixed_addr
operator|->
name|value
operator|+
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|subnet
operator|=
name|find_grouped_subnet
argument_list|(
name|share
argument_list|,
name|ip_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
condition|)
block|{
operator|*
name|addr
operator|=
name|ip_address
expr_stmt|;
operator|*
name|host
operator|=
name|hp
expr_stmt|;
return|return
name|subnet
return|;
block|}
block|}
block|}
return|return
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|void
name|new_address_range
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|subnet
parameter_list|,
name|dynamic
parameter_list|)
name|struct
name|iaddr
name|low
decl_stmt|,
name|high
decl_stmt|;
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
name|int
name|dynamic
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|address_range
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|plp
decl_stmt|;
name|struct
name|iaddr
name|net
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|i
decl_stmt|;
name|char
name|lowbuf
index|[
literal|16
index|]
decl_stmt|,
name|highbuf
index|[
literal|16
index|]
decl_stmt|,
name|netbuf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|share
init|=
name|subnet
operator|->
name|shared_network
decl_stmt|;
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|struct
name|in_addr
name|ia
decl_stmt|;
comment|/* All subnets should have attached shared network structures. */
if|if
condition|(
operator|!
name|share
condition|)
block|{
name|strcpy
argument_list|(
name|netbuf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|net
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No shared network for network %s (%s)"
argument_list|,
name|netbuf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the hash table if it hasn't been done yet. */
if|if
condition|(
operator|!
name|lease_uid_hash
condition|)
name|lease_uid_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lease_ip_addr_hash
condition|)
name|lease_ip_addr_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lease_hw_addr_hash
condition|)
name|lease_hw_addr_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
comment|/* Make sure that high and low addresses are in same subnet. */
name|net
operator|=
name|subnet_number
argument_list|(
name|low
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_eq
argument_list|(
name|net
argument_list|,
name|subnet_number
argument_list|(
name|high
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|lowbuf
argument_list|,
name|piaddr
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|highbuf
argument_list|,
name|piaddr
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|netbuf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Address range %s to %s, netmask %s spans %s!"
argument_list|,
name|lowbuf
argument_list|,
name|highbuf
argument_list|,
name|netbuf
argument_list|,
literal|"multiple subnets"
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that the addresses are on the correct subnet. */
if|if
condition|(
operator|!
name|addr_eq
argument_list|(
name|net
argument_list|,
name|subnet
operator|->
name|net
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|lowbuf
argument_list|,
name|piaddr
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|highbuf
argument_list|,
name|piaddr
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|netbuf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Address range %s to %s not on net %s/%s!"
argument_list|,
name|lowbuf
argument_list|,
name|highbuf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|net
argument_list|)
argument_list|,
name|netbuf
argument_list|)
expr_stmt|;
block|}
comment|/* Get the high and low host addresses... */
name|max
operator|=
name|host_addr
argument_list|(
name|high
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
name|min
operator|=
name|host_addr
argument_list|(
name|low
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
comment|/* Allow range to be specified high-to-low as well as low-to-high. */
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|host_addr
argument_list|(
name|high
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
block|}
comment|/* Get a lease structure for each address in the range. */
name|address_range
operator|=
name|new_leases
argument_list|(
name|max
operator|-
name|min
operator|+
literal|1
argument_list|,
literal|"new_address_range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|address_range
condition|)
block|{
name|strcpy
argument_list|(
name|lowbuf
argument_list|,
name|piaddr
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|highbuf
argument_list|,
name|piaddr
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No memory for address range %s-%s."
argument_list|,
name|lowbuf
argument_list|,
name|highbuf
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|address_range
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|address_range
operator|)
operator|*
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill in the last lease if it hasn't been already... */
if|if
condition|(
operator|!
name|share
operator|->
name|last_lease
condition|)
block|{
name|share
operator|->
name|last_lease
operator|=
operator|&
name|address_range
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Fill out the lease structures with some minimal information. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
operator|-
name|min
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|address_range
index|[
name|i
index|]
operator|.
name|ip_addr
operator|=
name|ip_addr
argument_list|(
name|subnet
operator|->
name|net
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|,
name|i
operator|+
name|min
argument_list|)
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|starts
operator|=
name|address_range
index|[
name|i
index|]
operator|.
name|timestamp
operator|=
name|MIN_TIME
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|ends
operator|=
name|MIN_TIME
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|subnet
operator|=
name|subnet
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|shared_network
operator|=
name|share
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|dynamic
condition|?
name|DYNAMIC_BOOTP_OK
else|:
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ia
argument_list|,
name|address_range
index|[
name|i
index|]
operator|.
name|ip_addr
operator|.
name|iabuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
operator|->
name|group
operator|->
name|get_lease_hostnames
condition|)
block|{
name|h
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ia
argument_list|,
sizeof|sizeof
name|ia
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
name|warn
argument_list|(
literal|"No hostname for %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|address_range
index|[
name|i
index|]
operator|.
name|hostname
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|h
operator|->
name|h_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|address_range
index|[
name|i
index|]
operator|.
name|hostname
condition|)
name|error
argument_list|(
literal|"no memory for hostname %s."
argument_list|,
name|h
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|address_range
index|[
name|i
index|]
operator|.
name|hostname
argument_list|,
name|h
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Link this entry into the list. */
name|address_range
index|[
name|i
index|]
operator|.
name|next
operator|=
name|share
operator|->
name|leases
expr_stmt|;
name|address_range
index|[
name|i
index|]
operator|.
name|prev
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
name|share
operator|->
name|leases
operator|=
operator|&
name|address_range
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|address_range
index|[
name|i
index|]
operator|.
name|next
condition|)
name|address_range
index|[
name|i
index|]
operator|.
name|next
operator|->
name|prev
operator|=
name|share
operator|->
name|leases
expr_stmt|;
name|add_hash
argument_list|(
name|lease_ip_addr_hash
argument_list|,
name|address_range
index|[
name|i
index|]
operator|.
name|ip_addr
operator|.
name|iabuf
argument_list|,
name|address_range
index|[
name|i
index|]
operator|.
name|ip_addr
operator|.
name|len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|address_range
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Find out if any dangling leases are in range... */
name|plp
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|dangling_leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|struct
name|iaddr
name|lnet
decl_stmt|;
name|int
name|lhost
decl_stmt|;
name|lnet
operator|=
name|subnet_number
argument_list|(
name|lp
operator|->
name|ip_addr
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
name|lhost
operator|=
name|host_addr
argument_list|(
name|lp
operator|->
name|ip_addr
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
expr_stmt|;
comment|/* If it's in range, fill in the real lease structure with 		   the dangling lease's values, and remove the lease from 		   the list of dangling leases. */
if|if
condition|(
name|addr_eq
argument_list|(
name|lnet
argument_list|,
name|subnet
operator|->
name|net
argument_list|)
operator|&&
name|lhost
operator|>=
name|i
operator|&&
name|lhost
operator|<=
name|max
condition|)
block|{
if|if
condition|(
name|plp
condition|)
block|{
name|plp
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|dangling_leases
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
name|lp
operator|->
name|next
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
name|address_range
index|[
name|lhost
operator|-
name|i
index|]
operator|.
name|hostname
operator|=
name|lp
operator|->
name|hostname
expr_stmt|;
name|address_range
index|[
name|lhost
operator|-
name|i
index|]
operator|.
name|client_hostname
operator|=
name|lp
operator|->
name|client_hostname
expr_stmt|;
name|supersede_lease
argument_list|(
operator|&
name|address_range
index|[
name|lhost
operator|-
name|i
index|]
argument_list|,
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_lease
argument_list|(
name|lp
argument_list|,
literal|"new_address_range"
argument_list|)
expr_stmt|;
block|}
else|else
name|plp
operator|=
name|lp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|subnet
modifier|*
name|find_subnet
parameter_list|(
name|addr
parameter_list|)
name|struct
name|iaddr
name|addr
decl_stmt|;
block|{
name|struct
name|subnet
modifier|*
name|rv
decl_stmt|;
for|for
control|(
name|rv
operator|=
name|subnets
init|;
name|rv
condition|;
name|rv
operator|=
name|rv
operator|->
name|next_subnet
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|subnet_number
argument_list|(
name|addr
argument_list|,
name|rv
operator|->
name|netmask
argument_list|)
argument_list|,
name|rv
operator|->
name|net
argument_list|)
condition|)
return|return
name|rv
return|;
block|}
return|return
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|subnet
modifier|*
name|find_grouped_subnet
parameter_list|(
name|share
parameter_list|,
name|addr
parameter_list|)
name|struct
name|shared_network
modifier|*
name|share
decl_stmt|;
name|struct
name|iaddr
name|addr
decl_stmt|;
block|{
name|struct
name|subnet
modifier|*
name|rv
decl_stmt|;
for|for
control|(
name|rv
operator|=
name|share
operator|->
name|subnets
init|;
name|rv
condition|;
name|rv
operator|=
name|rv
operator|->
name|next_sibling
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|subnet_number
argument_list|(
name|addr
argument_list|,
name|rv
operator|->
name|netmask
argument_list|)
argument_list|,
name|rv
operator|->
name|net
argument_list|)
condition|)
return|return
name|rv
return|;
block|}
return|return
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|int
name|subnet_inner_than
parameter_list|(
name|subnet
parameter_list|,
name|scan
parameter_list|,
name|warnp
parameter_list|)
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|,
decl|*
name|scan
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|warnp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|subnet_number
argument_list|(
name|subnet
operator|->
name|net
argument_list|,
name|scan
operator|->
name|netmask
argument_list|)
argument_list|,
name|scan
operator|->
name|net
argument_list|)
operator|||
name|addr_eq
argument_list|(
name|subnet_number
argument_list|(
name|scan
operator|->
name|net
argument_list|,
name|subnet
operator|->
name|netmask
argument_list|)
argument_list|,
name|subnet
operator|->
name|net
argument_list|)
condition|)
block|{
name|char
name|n1buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|subnet
operator|->
name|netmask
operator|.
name|iabuf
index|[
literal|3
operator|-
operator|(
name|i
operator|>>
literal|3
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|scan
operator|->
name|netmask
operator|.
name|iabuf
index|[
literal|3
operator|-
operator|(
name|j
operator|>>
literal|3
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|&
literal|7
operator|)
operator|)
condition|)
break|break;
name|strcpy
argument_list|(
name|n1buf
argument_list|,
name|piaddr
argument_list|(
name|subnet
operator|->
name|net
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnp
condition|)
name|warn
argument_list|(
literal|"%ssubnet %s/%d conflicts with subnet %s/%d"
argument_list|,
literal|"Warning: "
argument_list|,
name|n1buf
argument_list|,
literal|32
operator|-
name|i
argument_list|,
name|piaddr
argument_list|(
name|scan
operator|->
name|net
argument_list|)
argument_list|,
literal|32
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|j
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Enter a new subnet into the subnet list. */
end_comment

begin_function
name|void
name|enter_subnet
parameter_list|(
name|subnet
parameter_list|)
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
block|{
name|struct
name|subnet
modifier|*
name|scan
decl_stmt|,
modifier|*
name|prev
init|=
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Check for duplicates... */
for|for
control|(
name|scan
operator|=
name|subnets
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next_subnet
control|)
block|{
comment|/* When we find a conflict, make sure that the 		   subnet with the narrowest subnet mask comes 		   first. */
if|if
condition|(
name|subnet_inner_than
argument_list|(
name|subnet
argument_list|,
name|scan
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|next_subnet
operator|=
name|subnet
expr_stmt|;
block|}
else|else
name|subnets
operator|=
name|subnet
expr_stmt|;
name|subnet
operator|->
name|next_subnet
operator|=
name|scan
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|scan
expr_stmt|;
block|}
comment|/* XXX use the BSD radix tree code instead of a linked list. */
name|subnet
operator|->
name|next_subnet
operator|=
name|subnets
expr_stmt|;
name|subnets
operator|=
name|subnet
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a new shared network into the shared network list. */
end_comment

begin_function
name|void
name|enter_shared_network
parameter_list|(
name|share
parameter_list|)
name|struct
name|shared_network
modifier|*
name|share
decl_stmt|;
block|{
comment|/* XXX Sort the nets into a balanced tree to make searching quicker. */
name|share
operator|->
name|next
operator|=
name|shared_networks
expr_stmt|;
name|shared_networks
operator|=
name|share
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a lease into the system.   This is called by the parser each    time it reads in a new lease.   If the subnet for that lease has    already been read in (usually the case), just update that lease;    otherwise, allocate temporary storage for the lease and keep it around    until we're done reading in the config file. */
end_comment

begin_function
name|void
name|enter_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|comp
init|=
name|find_lease_by_ip_addr
argument_list|(
name|lease
operator|->
name|ip_addr
argument_list|)
decl_stmt|;
comment|/* If we don't have a place for this lease yet, save it for 	   later. */
if|if
condition|(
operator|!
name|comp
condition|)
block|{
name|comp
operator|=
name|new_lease
argument_list|(
literal|"enter_lease"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp
condition|)
block|{
name|error
argument_list|(
literal|"No memory for lease %s\n"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|ip_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|comp
operator|=
operator|*
name|lease
expr_stmt|;
name|comp
operator|->
name|next
operator|=
name|dangling_leases
expr_stmt|;
name|comp
operator|->
name|prev
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
name|dangling_leases
operator|=
name|comp
expr_stmt|;
block|}
else|else
block|{
comment|/* Record the hostname information in the lease. */
name|comp
operator|->
name|hostname
operator|=
name|lease
operator|->
name|hostname
expr_stmt|;
name|comp
operator|->
name|client_hostname
operator|=
name|lease
operator|->
name|client_hostname
expr_stmt|;
name|supersede_lease
argument_list|(
name|comp
argument_list|,
name|lease
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replace the data in an existing lease with the data in a new lease;    adjust hash tables to suit, and insertion sort the lease into the    list of leases by expiry time so that we can always find the oldest    lease. */
end_comment

begin_function
name|int
name|supersede_lease
parameter_list|(
name|comp
parameter_list|,
name|lease
parameter_list|,
name|commit
parameter_list|)
name|struct
name|lease
modifier|*
name|comp
decl_stmt|,
decl|*
name|lease
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|commit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|enter_uid
init|=
literal|0
decl_stmt|;
name|int
name|enter_hwaddr
init|=
literal|0
decl_stmt|;
name|struct
name|lease
modifier|*
name|lp
decl_stmt|;
comment|/* Static leases are not currently kept in the database... */
if|if
condition|(
name|lease
operator|->
name|flags
operator|&
name|STATIC_LEASE
condition|)
return|return
literal|1
return|;
comment|/* If the existing lease hasn't expired and has a different 	   unique identifier or, if it doesn't have a unique 	   identifier, a different hardware address, then the two 	   leases are in conflict.  If the existing lease has a uid 	   and the new one doesn't, but they both have the same 	   hardware address, and dynamic bootp is allowed on this 	   lease, then we allow that, in case a dynamic BOOTP lease is 	   requested *after* a DHCP lease has been assigned. */
if|if
condition|(
operator|!
operator|(
name|lease
operator|->
name|flags
operator|&
name|ABANDONED_LEASE
operator|)
operator|&&
name|comp
operator|->
name|ends
operator|>
name|cur_time
operator|&&
operator|(
operator|(
operator|(
name|comp
operator|->
name|uid
operator|&&
name|lease
operator|->
name|uid
operator|)
operator|&&
operator|(
name|comp
operator|->
name|uid_len
operator|!=
name|lease
operator|->
name|uid_len
operator|||
name|memcmp
argument_list|(
name|comp
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid
argument_list|,
name|comp
operator|->
name|uid_len
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|comp
operator|->
name|uid
operator|&&
operator|(
operator|(
name|comp
operator|->
name|hardware_addr
operator|.
name|htype
operator|!=
name|lease
operator|->
name|hardware_addr
operator|.
name|htype
operator|)
operator|||
operator|(
name|comp
operator|->
name|hardware_addr
operator|.
name|hlen
operator|!=
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
operator|)
operator|||
name|memcmp
argument_list|(
name|comp
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|comp
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Lease conflict at %s"
argument_list|,
name|piaddr
argument_list|(
name|comp
operator|->
name|ip_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If there's a Unique ID, dissociate it from the hash 		   table and free it if necessary. */
if|if
condition|(
name|comp
operator|->
name|uid
condition|)
block|{
name|uid_hash_delete
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|enter_uid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|uid
operator|!=
operator|&
name|comp
operator|->
name|uid_buf
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|comp
operator|->
name|uid
argument_list|)
expr_stmt|;
name|comp
operator|->
name|uid_max
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|uid_len
operator|=
literal|0
expr_stmt|;
block|}
name|comp
operator|->
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|enter_uid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|hardware_addr
operator|.
name|htype
operator|&&
operator|(
operator|(
name|comp
operator|->
name|hardware_addr
operator|.
name|hlen
operator|!=
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
operator|)
operator|||
operator|(
name|comp
operator|->
name|hardware_addr
operator|.
name|htype
operator|!=
name|lease
operator|->
name|hardware_addr
operator|.
name|htype
operator|)
operator|||
name|memcmp
argument_list|(
name|comp
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|comp
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|)
operator|)
condition|)
block|{
name|hw_hash_delete
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|enter_hwaddr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|comp
operator|->
name|hardware_addr
operator|.
name|htype
condition|)
name|enter_hwaddr
operator|=
literal|1
expr_stmt|;
comment|/* Copy the data files, but not the linkages. */
name|comp
operator|->
name|starts
operator|=
name|lease
operator|->
name|starts
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|uid
condition|)
block|{
if|if
condition|(
name|lease
operator|->
name|uid_len
operator|<
sizeof|sizeof
argument_list|(
name|lease
operator|->
name|uid_buf
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|comp
operator|->
name|uid_buf
argument_list|,
name|lease
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid_len
argument_list|)
expr_stmt|;
name|comp
operator|->
name|uid
operator|=
operator|&
name|comp
operator|->
name|uid_buf
index|[
literal|0
index|]
expr_stmt|;
name|comp
operator|->
name|uid_max
operator|=
sizeof|sizeof
name|comp
operator|->
name|uid_buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lease
operator|->
name|uid
operator|!=
operator|&
name|lease
operator|->
name|uid_buf
index|[
literal|0
index|]
condition|)
block|{
name|comp
operator|->
name|uid
operator|=
name|lease
operator|->
name|uid
expr_stmt|;
name|comp
operator|->
name|uid_max
operator|=
name|lease
operator|->
name|uid_max
expr_stmt|;
name|lease
operator|->
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|lease
operator|->
name|uid_max
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"corrupt lease uid."
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
else|else
block|{
name|comp
operator|->
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|comp
operator|->
name|uid_max
operator|=
literal|0
expr_stmt|;
block|}
name|comp
operator|->
name|uid_len
operator|=
name|lease
operator|->
name|uid_len
expr_stmt|;
name|comp
operator|->
name|host
operator|=
name|lease
operator|->
name|host
expr_stmt|;
name|comp
operator|->
name|hardware_addr
operator|=
name|lease
operator|->
name|hardware_addr
expr_stmt|;
name|comp
operator|->
name|flags
operator|=
operator|(
operator|(
name|lease
operator|->
name|flags
operator|&
operator|~
name|PERSISTENT_FLAGS
operator|)
operator||
operator|(
name|comp
operator|->
name|flags
operator|&
operator|~
name|EPHEMERAL_FLAGS
operator|)
operator|)
expr_stmt|;
comment|/* Record the lease in the uid hash if necessary. */
if|if
condition|(
name|enter_uid
operator|&&
name|lease
operator|->
name|uid
condition|)
block|{
name|uid_hash_add
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
comment|/* Record it in the hardware address hash if necessary. */
if|if
condition|(
name|enter_hwaddr
operator|&&
name|lease
operator|->
name|hardware_addr
operator|.
name|htype
condition|)
block|{
name|hw_hash_add
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the lease from its current place in the  		   timeout sequence. */
if|if
condition|(
name|comp
operator|->
name|prev
condition|)
block|{
name|comp
operator|->
name|prev
operator|->
name|next
operator|=
name|comp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|->
name|shared_network
operator|->
name|leases
operator|=
name|comp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|->
name|next
condition|)
block|{
name|comp
operator|->
name|next
operator|->
name|prev
operator|=
name|comp
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|->
name|shared_network
operator|->
name|last_lease
operator|==
name|comp
condition|)
block|{
name|comp
operator|->
name|shared_network
operator|->
name|last_lease
operator|=
name|comp
operator|->
name|prev
expr_stmt|;
block|}
comment|/* Find the last insertion point... */
if|if
condition|(
name|comp
operator|==
name|comp
operator|->
name|shared_network
operator|->
name|insertion_point
operator|||
operator|!
name|comp
operator|->
name|shared_network
operator|->
name|insertion_point
condition|)
block|{
name|lp
operator|=
name|comp
operator|->
name|shared_network
operator|->
name|leases
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|comp
operator|->
name|shared_network
operator|->
name|insertion_point
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lp
condition|)
block|{
comment|/* Nothing on the list yet?    Just make comp the 			   head of the list. */
name|comp
operator|->
name|shared_network
operator|->
name|leases
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|shared_network
operator|->
name|last_lease
operator|=
name|comp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|ends
operator|>
name|lease
operator|->
name|ends
condition|)
block|{
comment|/* Skip down the list until we run out of list 			   or find a place for comp. */
while|while
condition|(
name|lp
operator|->
name|next
operator|&&
name|lp
operator|->
name|ends
operator|>
name|lease
operator|->
name|ends
condition|)
block|{
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|->
name|ends
operator|>
name|lease
operator|->
name|ends
condition|)
block|{
comment|/* If we ran out of list, put comp 				   at the end. */
name|lp
operator|->
name|next
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|prev
operator|=
name|lp
expr_stmt|;
name|comp
operator|->
name|next
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
name|comp
operator|->
name|shared_network
operator|->
name|last_lease
operator|=
name|comp
expr_stmt|;
block|}
else|else
block|{
comment|/* If we didn't, put it between lp and 				   the previous item on the list. */
if|if
condition|(
operator|(
name|comp
operator|->
name|prev
operator|=
name|lp
operator|->
name|prev
operator|)
condition|)
name|comp
operator|->
name|prev
operator|->
name|next
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|next
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|prev
operator|=
name|comp
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Skip up the list until we run out of list 			   or find a place for comp. */
while|while
condition|(
name|lp
operator|->
name|prev
operator|&&
name|lp
operator|->
name|ends
operator|<
name|lease
operator|->
name|ends
condition|)
block|{
name|lp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|->
name|ends
operator|<
name|lease
operator|->
name|ends
condition|)
block|{
comment|/* If we ran out of list, put comp 				   at the beginning. */
name|lp
operator|->
name|prev
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|next
operator|=
name|lp
expr_stmt|;
name|comp
operator|->
name|prev
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
name|comp
operator|->
name|shared_network
operator|->
name|leases
operator|=
name|comp
expr_stmt|;
block|}
else|else
block|{
comment|/* If we didn't, put it between lp and 				   the next item on the list. */
if|if
condition|(
operator|(
name|comp
operator|->
name|next
operator|=
name|lp
operator|->
name|next
operator|)
condition|)
name|comp
operator|->
name|next
operator|->
name|prev
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|prev
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|comp
expr_stmt|;
block|}
block|}
name|comp
operator|->
name|shared_network
operator|->
name|insertion_point
operator|=
name|comp
expr_stmt|;
name|comp
operator|->
name|ends
operator|=
name|lease
operator|->
name|ends
expr_stmt|;
block|}
comment|/* Return zero if we didn't commit the lease to permanent storage; 	   nonzero if we did. */
return|return
name|commit
operator|&&
name|write_lease
argument_list|(
name|comp
argument_list|)
operator|&&
name|commit_leases
argument_list|()
return|;
block|}
end_block

begin_comment
comment|/* Release the specified lease and re-hash it as appropriate. */
end_comment

begin_function
name|void
name|release_lease
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
name|lt
decl_stmt|;
name|lt
operator|=
operator|*
name|lease
expr_stmt|;
if|if
condition|(
name|lt
operator|.
name|ends
operator|>
name|cur_time
condition|)
block|{
name|lt
operator|.
name|ends
operator|=
name|cur_time
expr_stmt|;
name|supersede_lease
argument_list|(
name|lease
argument_list|,
operator|&
name|lt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Abandon the specified lease (set its timeout to infinity and its    particulars to zero, and re-hash it as appropriate. */
end_comment

begin_function
name|void
name|abandon_lease
parameter_list|(
name|lease
parameter_list|,
name|message
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|struct
name|lease
name|lt
decl_stmt|;
name|lease
operator|->
name|flags
operator||=
name|ABANDONED_LEASE
expr_stmt|;
name|lt
operator|=
operator|*
name|lease
expr_stmt|;
name|lt
operator|.
name|ends
operator|=
name|cur_time
expr_stmt|;
name|warn
argument_list|(
literal|"Abandoning IP address %s: %s"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|ip_addr
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|lt
operator|.
name|hardware_addr
operator|.
name|htype
operator|=
literal|0
expr_stmt|;
name|lt
operator|.
name|hardware_addr
operator|.
name|hlen
operator|=
literal|0
expr_stmt|;
name|lt
operator|.
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|lt
operator|.
name|uid_len
operator|=
literal|0
expr_stmt|;
name|supersede_lease
argument_list|(
name|lease
argument_list|,
operator|&
name|lt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate the lease associated with a given IP address... */
end_comment

begin_function
name|struct
name|lease
modifier|*
name|find_lease_by_ip_addr
parameter_list|(
name|addr
parameter_list|)
name|struct
name|iaddr
name|addr
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|lease
init|=
operator|(
expr|struct
name|lease
operator|*
operator|)
name|hash_lookup
argument_list|(
name|lease_ip_addr_hash
argument_list|,
name|addr
operator|.
name|iabuf
argument_list|,
name|addr
operator|.
name|len
argument_list|)
decl_stmt|;
return|return
name|lease
return|;
block|}
end_function

begin_function
name|struct
name|lease
modifier|*
name|find_lease_by_uid
parameter_list|(
name|uid
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|uid
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|lease
init|=
operator|(
expr|struct
name|lease
operator|*
operator|)
name|hash_lookup
argument_list|(
name|lease_uid_hash
argument_list|,
name|uid
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
name|lease
return|;
block|}
end_function

begin_function
name|struct
name|lease
modifier|*
name|find_lease_by_hw_addr
parameter_list|(
name|hwaddr
parameter_list|,
name|hwlen
parameter_list|)
name|unsigned
name|char
modifier|*
name|hwaddr
decl_stmt|;
name|int
name|hwlen
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|lease
init|=
operator|(
expr|struct
name|lease
operator|*
operator|)
name|hash_lookup
argument_list|(
name|lease_hw_addr_hash
argument_list|,
name|hwaddr
argument_list|,
name|hwlen
argument_list|)
decl_stmt|;
return|return
name|lease
return|;
block|}
end_function

begin_comment
comment|/* Add the specified lease to the uid hash. */
end_comment

begin_function
name|void
name|uid_hash_add
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|head
init|=
name|find_lease_by_uid
argument_list|(
name|lease
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid_len
argument_list|)
decl_stmt|;
name|struct
name|lease
modifier|*
name|scan
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|lease
operator|->
name|n_uid
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If it's not in the hash, just add it. */
if|if
condition|(
operator|!
name|head
condition|)
name|add_hash
argument_list|(
name|lease_uid_hash
argument_list|,
name|lease
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lease
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Otherwise, attach it to the end of the list. */
for|for
control|(
name|scan
operator|=
name|head
init|;
name|scan
operator|->
name|n_uid
condition|;
name|scan
operator|=
name|scan
operator|->
name|n_uid
control|)
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scan
operator|==
name|lease
condition|)
name|abort
argument_list|()
endif|#
directive|endif
expr_stmt|;
name|scan
operator|->
name|n_uid
operator|=
name|lease
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the specified lease from the uid hash. */
end_comment

begin_function
name|void
name|uid_hash_delete
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|head
init|=
name|find_lease_by_uid
argument_list|(
name|lease
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid_len
argument_list|)
decl_stmt|;
name|struct
name|lease
modifier|*
name|scan
decl_stmt|;
comment|/* If it's not in the hash, we have no work to do. */
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|lease
operator|->
name|n_uid
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If the lease we're freeing is at the head of the list, 	   remove the hash table entry and add a new one with the 	   next lease on the list (if there is one). */
if|if
condition|(
name|head
operator|==
name|lease
condition|)
block|{
name|delete_hash_entry
argument_list|(
name|lease_uid_hash
argument_list|,
name|lease
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|uid_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|n_uid
condition|)
name|add_hash
argument_list|(
name|lease_uid_hash
argument_list|,
name|lease
operator|->
name|n_uid
operator|->
name|uid
argument_list|,
name|lease
operator|->
name|n_uid
operator|->
name|uid_len
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|lease
operator|->
name|n_uid
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, look for the lease in the list of leases 		   attached to the hash table entry, and remove it if 		   we find it. */
for|for
control|(
name|scan
operator|=
name|head
init|;
name|scan
operator|->
name|n_uid
condition|;
name|scan
operator|=
name|scan
operator|->
name|n_uid
control|)
block|{
if|if
condition|(
name|scan
operator|->
name|n_uid
operator|==
name|lease
condition|)
block|{
name|scan
operator|->
name|n_uid
operator|=
name|scan
operator|->
name|n_uid
operator|->
name|n_uid
expr_stmt|;
break|break;
block|}
block|}
block|}
name|lease
operator|->
name|n_uid
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the specified lease to the hardware address hash. */
end_comment

begin_function
name|void
name|hw_hash_add
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|head
init|=
name|find_lease_by_hw_addr
argument_list|(
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|)
decl_stmt|;
name|struct
name|lease
modifier|*
name|scan
decl_stmt|;
comment|/* If it's not in the hash, just add it. */
if|if
condition|(
operator|!
name|head
condition|)
name|add_hash
argument_list|(
name|lease_hw_addr_hash
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|lease
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Otherwise, attach it to the end of the list. */
for|for
control|(
name|scan
operator|=
name|head
init|;
name|scan
operator|->
name|n_hw
condition|;
name|scan
operator|=
name|scan
operator|->
name|n_hw
control|)
empty_stmt|;
name|scan
operator|->
name|n_hw
operator|=
name|lease
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the specified lease from the hardware address hash. */
end_comment

begin_function
name|void
name|hw_hash_delete
parameter_list|(
name|lease
parameter_list|)
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
block|{
name|struct
name|lease
modifier|*
name|head
init|=
name|find_lease_by_hw_addr
argument_list|(
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|)
decl_stmt|;
name|struct
name|lease
modifier|*
name|scan
decl_stmt|;
comment|/* If it's not in the hash, we have no work to do. */
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|lease
operator|->
name|n_hw
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If the lease we're freeing is at the head of the list, 	   remove the hash table entry and add a new one with the 	   next lease on the list (if there is one). */
if|if
condition|(
name|head
operator|==
name|lease
condition|)
block|{
name|delete_hash_entry
argument_list|(
name|lease_hw_addr_hash
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|n_hw
condition|)
name|add_hash
argument_list|(
name|lease_hw_addr_hash
argument_list|,
name|lease
operator|->
name|n_hw
operator|->
name|hardware_addr
operator|.
name|haddr
argument_list|,
name|lease
operator|->
name|n_hw
operator|->
name|hardware_addr
operator|.
name|hlen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|lease
operator|->
name|n_hw
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, look for the lease in the list of leases 		   attached to the hash table entry, and remove it if 		   we find it. */
for|for
control|(
name|scan
operator|=
name|head
init|;
name|scan
operator|->
name|n_hw
condition|;
name|scan
operator|=
name|scan
operator|->
name|n_hw
control|)
block|{
if|if
condition|(
name|scan
operator|->
name|n_hw
operator|==
name|lease
condition|)
block|{
name|scan
operator|->
name|n_hw
operator|=
name|scan
operator|->
name|n_hw
operator|->
name|n_hw
expr_stmt|;
break|break;
block|}
block|}
block|}
name|lease
operator|->
name|n_hw
operator|=
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|class
modifier|*
name|add_class
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|class
modifier|*
name|class
init|=
name|new_class
argument_list|(
literal|"add_class"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tname
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vendor_class_hash
condition|)
name|vendor_class_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|user_class_hash
condition|)
name|user_class_hash
operator|=
name|new_hash
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tname
operator|||
operator|!
name|class
operator|||
operator|!
name|vendor_class_hash
operator|||
operator|!
name|user_class_hash
condition|)
return|return
operator|(
expr|struct
name|class
operator|*
operator|)
literal|0
return|;
name|memset
argument_list|(
name|class
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|class
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|class
operator|->
name|name
operator|=
name|tname
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|add_hash
argument_list|(
name|user_class_hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tname
argument_list|,
name|strlen
argument_list|(
name|tname
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|class
argument_list|)
expr_stmt|;
else|else
name|add_hash
argument_list|(
name|vendor_class_hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tname
argument_list|,
name|strlen
argument_list|(
name|tname
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|class
argument_list|)
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_function
name|struct
name|class
modifier|*
name|find_class
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|)
name|int
name|type
decl_stmt|;
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|class
modifier|*
name|class
init|=
operator|(
expr|struct
name|class
operator|*
operator|)
name|hash_lookup
argument_list|(
name|type
condition|?
name|user_class_hash
else|:
name|vendor_class_hash
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_function
name|struct
name|group
modifier|*
name|clone_group
parameter_list|(
name|group
parameter_list|,
name|caller
parameter_list|)
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|caller
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|g
init|=
name|new_group
argument_list|(
name|caller
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
name|error
argument_list|(
literal|"%s: can't allocate new group"
argument_list|,
name|caller
argument_list|)
expr_stmt|;
operator|*
name|g
operator|=
operator|*
name|group
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Write all interesting leases to permanent storage. */
end_comment

begin_function
name|void
name|write_leases
parameter_list|()
block|{
name|struct
name|lease
modifier|*
name|l
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|shared_networks
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
for|for
control|(
name|l
operator|=
name|s
operator|->
name|leases
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|hardware_addr
operator|.
name|hlen
operator|||
name|l
operator|->
name|uid_len
operator|||
operator|(
name|l
operator|->
name|flags
operator|&
name|ABANDONED_LEASE
operator|)
condition|)
if|if
condition|(
operator|!
name|write_lease
argument_list|(
name|l
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't rewrite lease database"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|commit_leases
argument_list|()
condition|)
name|error
argument_list|(
literal|"Can't commit leases to new database: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_subnets
parameter_list|()
block|{
name|struct
name|lease
modifier|*
name|l
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|s
decl_stmt|;
name|struct
name|subnet
modifier|*
name|n
decl_stmt|;
name|note
argument_list|(
literal|"Subnets:"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|subnets
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next_subnet
control|)
block|{
name|debug
argument_list|(
literal|"  Subnet %s"
argument_list|,
name|piaddr
argument_list|(
name|n
operator|->
name|net
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"     netmask %s"
argument_list|,
name|piaddr
argument_list|(
name|n
operator|->
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|note
argument_list|(
literal|"Shared networks:"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|shared_networks
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|note
argument_list|(
literal|"  %s"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|s
operator|->
name|leases
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|print_lease
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|last_lease
condition|)
block|{
name|debug
argument_list|(
literal|"    Last Lease:"
argument_list|)
expr_stmt|;
name|print_lease
argument_list|(
name|s
operator|->
name|last_lease
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

