begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* memory.c     Memory-resident database... */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1995-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software has been written for Internet Systems Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about Internet Systems Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: memory.c,v 1.66.2.5 2004/06/10 17:59:19 dhankins Exp $ Copyright (c) 2004 Internet Systems Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
name|struct
name|group
modifier|*
name|root_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|group_hash_t
modifier|*
name|group_name_hash
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|group_write_hook
function_decl|)
parameter_list|(
name|struct
name|group_object
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|isc_result_t
name|delete_group
parameter_list|(
name|struct
name|group_object
modifier|*
name|group
parameter_list|,
name|int
name|writep
parameter_list|)
block|{
name|struct
name|group_object
modifier|*
name|d
decl_stmt|;
comment|/* The group should exist and be hashed - if not, it's invalid. */
if|if
condition|(
name|group_name_hash
condition|)
block|{
name|d
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
name|group_hash_lookup
argument_list|(
operator|&
name|d
argument_list|,
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* Also not okay to delete a group that's not the one in 	   the hash table. */
if|if
condition|(
name|d
operator|!=
name|group
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* If it's dynamic, and we're deleting it, we can just blow away the 	   hash table entry. */
if|if
condition|(
operator|(
name|group
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DYNAMIC
operator|)
operator|&&
operator|!
operator|(
name|group
operator|->
name|flags
operator|&
name|GROUP_OBJECT_STATIC
operator|)
condition|)
block|{
name|group_hash_delete
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|group
operator|->
name|flags
operator||=
name|GROUP_OBJECT_DELETED
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|group
condition|)
name|group_dereference
argument_list|(
operator|&
name|group
operator|->
name|group
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Store the group declaration in the lease file. */
if|if
condition|(
name|writep
operator|&&
name|group_write_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|group_write_hook
call|)
argument_list|(
name|group
argument_list|)
condition|)
return|return
name|ISC_R_IOERROR
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|supersede_group
parameter_list|(
name|struct
name|group_object
modifier|*
name|group
parameter_list|,
name|int
name|writep
parameter_list|)
block|{
name|struct
name|group_object
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
comment|/* Register the group in the group name hash table, 	   so we can look it up later. */
if|if
condition|(
name|group_name_hash
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
name|group_hash_lookup
argument_list|(
operator|&
name|t
argument_list|,
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|!=
name|group
condition|)
block|{
comment|/* If this isn't a dynamic entry, then we need to flag 			   the replacement as not dynamic either - otherwise, 			   if the dynamic entry is deleted later, the static 			   entry will come back next time the server is stopped 			   and restarted. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DYNAMIC
operator|)
condition|)
name|group
operator|->
name|flags
operator||=
name|GROUP_OBJECT_STATIC
expr_stmt|;
comment|/* Delete the old object if it hasn't already been 			   deleted.  If it has already been deleted, get rid of 			   the hash table entry.  This is a legitimate 			   situation - a deleted static object needs to be kept 			   around so we remember it's deleted. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DELETED
operator|)
condition|)
name|delete_group
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|group_hash_delete
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|group_object_dereference
argument_list|(
operator|&
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|group_new_hash
argument_list|(
operator|&
name|group_name_hash
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Add the group to the group name hash if it's not 	   already there, and also thread it into the list of 	   dynamic groups if appropriate. */
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|group_hash_add
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|group
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Store the group declaration in the lease file. */
if|if
condition|(
name|writep
operator|&&
name|group_write_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|group_write_hook
call|)
argument_list|(
name|group
argument_list|)
condition|)
return|return
name|ISC_R_IOERROR
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|clone_group
parameter_list|(
name|struct
name|group
modifier|*
modifier|*
name|gp
parameter_list|,
name|struct
name|group
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|struct
name|group
modifier|*
name|g
init|=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Normally gp should contain the null pointer, but for convenience 	   it's permissible to clone a group into itself. */
if|if
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|group
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|group_allocate
argument_list|(
operator|&
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|group
operator|==
operator|*
name|gp
condition|)
operator|*
name|gp
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
expr_stmt|;
name|group_reference
argument_list|(
name|gp
argument_list|,
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|g
operator|->
name|authoritative
operator|=
name|group
operator|->
name|authoritative
expr_stmt|;
name|group_reference
argument_list|(
operator|&
name|g
operator|->
name|next
argument_list|,
name|group
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|group_dereference
argument_list|(
operator|&
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

