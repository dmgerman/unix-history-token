begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* memory.c     Memory-resident database... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995-2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: memory.c,v 1.66.2.3 2001/10/17 03:25:10 mellon Exp $ Copyright (c) 1995-2000 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
name|struct
name|group
modifier|*
name|root_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|group_hash_t
modifier|*
name|group_name_hash
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|group_write_hook
function_decl|)
parameter_list|(
name|struct
name|group_object
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|isc_result_t
name|delete_group
parameter_list|(
name|struct
name|group_object
modifier|*
name|group
parameter_list|,
name|int
name|writep
parameter_list|)
block|{
name|struct
name|group_object
modifier|*
name|d
decl_stmt|;
comment|/* The group should exist and be hashed - if not, it's invalid. */
if|if
condition|(
name|group_name_hash
condition|)
block|{
name|d
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
name|group_hash_lookup
argument_list|(
operator|&
name|d
argument_list|,
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|ISC_R_INVALIDARG
return|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* Also not okay to delete a group that's not the one in 	   the hash table. */
if|if
condition|(
name|d
operator|!=
name|group
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
comment|/* If it's dynamic, and we're deleting it, we can just blow away the 	   hash table entry. */
if|if
condition|(
operator|(
name|group
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DYNAMIC
operator|)
operator|&&
operator|!
operator|(
name|group
operator|->
name|flags
operator|&
name|GROUP_OBJECT_STATIC
operator|)
condition|)
block|{
name|group_hash_delete
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|group
operator|->
name|flags
operator||=
name|GROUP_OBJECT_DELETED
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|group
condition|)
name|group_dereference
argument_list|(
operator|&
name|group
operator|->
name|group
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Store the group declaration in the lease file. */
if|if
condition|(
name|writep
operator|&&
name|group_write_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|group_write_hook
call|)
argument_list|(
name|group
argument_list|)
condition|)
return|return
name|ISC_R_IOERROR
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|supersede_group
parameter_list|(
name|struct
name|group_object
modifier|*
name|group
parameter_list|,
name|int
name|writep
parameter_list|)
block|{
name|struct
name|group_object
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
comment|/* Register the group in the group name hash table, 	   so we can look it up later. */
if|if
condition|(
name|group_name_hash
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
name|group_hash_lookup
argument_list|(
operator|&
name|t
argument_list|,
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|!=
name|group
condition|)
block|{
comment|/* If this isn't a dynamic entry, then we need to flag 			   the replacement as not dynamic either - otherwise, 			   if the dynamic entry is deleted later, the static 			   entry will come back next time the server is stopped 			   and restarted. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DYNAMIC
operator|)
condition|)
name|group
operator|->
name|flags
operator||=
name|GROUP_OBJECT_STATIC
expr_stmt|;
comment|/* Delete the old object if it hasn't already been 			   deleted.  If it has already been deleted, get rid of 			   the hash table entry.  This is a legitimate 			   situation - a deleted static object needs to be kept 			   around so we remember it's deleted. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|GROUP_OBJECT_DELETED
operator|)
condition|)
name|delete_group
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|group_hash_delete
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|group_object_dereference
argument_list|(
operator|&
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|group_new_hash
argument_list|(
operator|&
name|group_name_hash
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|group_object
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Add the group to the group name hash if it's not 	   already there, and also thread it into the list of 	   dynamic groups if appropriate. */
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|group_hash_add
argument_list|(
name|group_name_hash
argument_list|,
name|group
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|group
operator|->
name|name
argument_list|)
argument_list|,
name|group
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Store the group declaration in the lease file. */
if|if
condition|(
name|writep
operator|&&
name|group_write_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|group_write_hook
call|)
argument_list|(
name|group
argument_list|)
condition|)
return|return
name|ISC_R_IOERROR
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|clone_group
parameter_list|(
name|struct
name|group
modifier|*
modifier|*
name|gp
parameter_list|,
name|struct
name|group
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|struct
name|group
modifier|*
name|g
init|=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Normally gp should contain the null pointer, but for convenience 	   it's permissible to clone a group into itself. */
if|if
condition|(
operator|*
name|gp
operator|&&
operator|*
name|gp
operator|!=
name|group
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|group_allocate
argument_list|(
operator|&
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|group
operator|==
operator|*
name|gp
condition|)
operator|*
name|gp
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
expr_stmt|;
name|group_reference
argument_list|(
name|gp
argument_list|,
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|g
operator|->
name|authoritative
operator|=
name|group
operator|->
name|authoritative
expr_stmt|;
name|group_reference
argument_list|(
operator|&
name|g
operator|->
name|next
argument_list|,
name|group
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|group_dereference
argument_list|(
operator|&
name|g
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

