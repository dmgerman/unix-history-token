begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* parse.c     Common parser code for dhcpd and dhclient. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995-2001 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: parse.c,v 1.104.2.8 2002/01/10 19:37:51 mellon Exp $ Copyright (c) 1995-2001 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_comment
comment|/* Enumerations can be specified in option formats, and are used for    parsing, so we define the routines that manage them here. */
end_comment

begin_decl_stmt
name|struct
name|enumeration
modifier|*
name|enumerations
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_enumeration
parameter_list|(
name|struct
name|enumeration
modifier|*
name|enumeration
parameter_list|)
block|{
name|enumeration
operator|->
name|next
operator|=
name|enumerations
expr_stmt|;
name|enumerations
operator|=
name|enumeration
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|enumeration
modifier|*
name|find_enumeration
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|enumeration
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|enumerations
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|strlen
argument_list|(
name|e
operator|->
name|name
argument_list|)
operator|==
name|length
operator|&&
operator|!
name|memcmp
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|length
argument_list|)
condition|)
return|return
name|e
return|;
return|return
operator|(
expr|struct
name|enumeration
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|enumeration_value
modifier|*
name|find_enumeration_value
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|enumeration
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|e
operator|=
name|find_enumeration
argument_list|(
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|e
operator|->
name|values
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
name|e
operator|->
name|values
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
operator|&
name|e
operator|->
name|values
index|[
name|i
index|]
return|;
block|}
block|}
return|return
operator|(
expr|struct
name|enumeration_value
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip to the semicolon ending the current statement.   If we encounter    braces, the matching closing brace terminates the statement.   If we    encounter a right brace but haven't encountered a left brace, return    leaving the brace in the token buffer for the caller.   If we see a    semicolon and haven't seen a left brace, return.   This lets us skip    over:     	statement; 	statement foo bar { } 	statement foo bar { statement { } } 	statement}   	...et cetera. */
end_comment

begin_function
name|void
name|skip_to_semi
parameter_list|(
name|cfile
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|skip_to_rbrace
parameter_list|(
name|cfile
parameter_list|,
name|brace_count
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|brace_count
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_TOKEN
argument_list|)
name|log_error
argument_list|(
literal|"skip_to_rbrace: %d\n"
argument_list|,
name|brace_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace_count
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|brace_count
condition|)
return|return;
block|}
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|LBRACE
condition|)
block|{
name|brace_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|SEMI
operator|&&
operator|!
name|brace_count
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|EOL
condition|)
block|{
comment|/* EOL only happens when parsing /etc/resolv.conf, 			   and we treat it like a semicolon because the 			   resolv.conf file is line-oriented. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|END_OF_FILE
condition|)
do|;
block|}
end_function

begin_function
name|int
name|parse_semi
parameter_list|(
name|cfile
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* string-parameter :== STRING SEMI */
end_comment

begin_function
name|int
name|parse_string
parameter_list|(
name|cfile
parameter_list|,
name|sptr
parameter_list|,
name|lptr
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
modifier|*
name|sptr
decl_stmt|;
name|unsigned
modifier|*
name|lptr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a string"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|log_fatal
argument_list|(
literal|"no memory for string %s."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
name|dfree
argument_list|(
name|s
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sptr
condition|)
operator|*
name|sptr
operator|=
name|s
expr_stmt|;
else|else
name|dfree
argument_list|(
name|s
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lptr
condition|)
operator|*
name|lptr
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * hostname :== IDENTIFIER  *		| IDENTIFIER DOT  *		| hostname DOT IDENTIFIER  */
end_comment

begin_function
name|char
modifier|*
name|parse_host_name
parameter_list|(
name|cfile
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|pair
name|c
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
name|int
name|ltid
init|=
literal|0
decl_stmt|;
comment|/* Read a dotted hostname... */
do|do
block|{
comment|/* Read a token, which should be an identifier. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
operator|&&
name|token
operator|!=
name|NUMBER
condition|)
break|break;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Store this identifier... */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate temp space for hostname."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|c
operator|=
name|cons
argument_list|(
operator|(
name|caddr_t
operator|)
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Look for a dot; if it's there, keep going, otherwise 		   we're done. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DOT
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|ltid
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ltid
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|DOT
condition|)
do|;
comment|/* Should be at least one token. */
if|if
condition|(
operator|!
name|len
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* Assemble the hostname together into a string. */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
operator|+
name|ltid
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate space for hostname."
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|+
name|len
operator|+
name|ltid
expr_stmt|;
operator|*
operator|--
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ltid
condition|)
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
name|pair
name|cdr
init|=
name|c
operator|->
name|cdr
decl_stmt|;
name|unsigned
name|l
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|)
decl_stmt|;
name|t
operator|-=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Free up temp space. */
name|dfree
argument_list|(
name|c
operator|->
name|car
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|c
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|c
operator|=
name|cdr
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|s
condition|)
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ip-addr-or-hostname :== ip-address | hostname    ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER        Parse an ip address or a hostname.   If uniform is zero, put in    an expr_substring node to limit hostnames that evaluate to more    than one IP address. */
end_comment

begin_function
name|int
name|parse_ip_addr_or_hostname
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|uniform
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|uniform
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|unsigned
name|char
name|addr
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|len
init|=
sizeof|sizeof
name|addr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|expression
modifier|*
name|x
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|name
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|make_host_lookup
argument_list|(
name|expr
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|uniform
condition|)
block|{
if|if
condition|(
operator|!
name|make_limit
argument_list|(
operator|&
name|x
argument_list|,
operator|*
name|expr
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|0
return|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|expr
operator|=
name|x
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|NUMBER
condition|)
block|{
if|if
condition|(
operator|!
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
name|addr
argument_list|,
operator|&
name|len
argument_list|,
name|DOT
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|make_const_data
argument_list|(
name|expr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|token
operator|!=
name|RBRACE
operator|&&
name|token
operator|!=
name|LBRACE
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s (%d): expecting IP address or hostname"
argument_list|,
name|val
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER  */
end_comment

begin_function
name|int
name|parse_ip_addr
parameter_list|(
name|cfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|iaddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|addr
operator|->
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
name|addr
operator|->
name|iabuf
argument_list|,
operator|&
name|addr
operator|->
name|len
argument_list|,
name|DOT
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * hardware-parameter :== HARDWARE hardware-type colon-seperated-hex-list SEMI  * hardware-type :== ETHERNET | TOKEN_RING  */
end_comment

begin_function
name|void
name|parse_hardware_param
parameter_list|(
name|cfile
parameter_list|,
name|hardware
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hardware
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|unsigned
name|hlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|ETHERNET
case|:
name|hardware
operator|->
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_ETHER
expr_stmt|;
break|break;
case|case
name|TOKEN_RING
case|:
name|hardware
operator|->
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_IEEE802
expr_stmt|;
break|break;
case|case
name|FDDI
case|:
name|hardware
operator|->
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_FDDI
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|val
argument_list|,
literal|"unknown-"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|hardware
operator|->
name|hbuf
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
operator|&
name|val
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a network hardware type"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Parse the hardware address information.   Technically, 	   it would make a lot of sense to restrict the length of the 	   data we'll accept here to the length of a particular hardware 	   address type.   Unfortunately, there are some broken clients 	   out there that put bogus data in the chaddr buffer, and we accept 	   that data in the lease file rather than simply failing on such 	   clients.   Yuck. */
name|hlen
operator|=
literal|0
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|SEMI
condition|)
block|{
name|hardware
operator|->
name|hlen
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|t
operator|=
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|hlen
argument_list|,
name|COLON
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|hardware
operator|->
name|hlen
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hlen
operator|+
literal|1
operator|>
sizeof|sizeof
name|hardware
operator|->
name|hbuf
condition|)
block|{
name|dfree
argument_list|(
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"hardware address too long"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hardware
operator|->
name|hlen
operator|=
name|hlen
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|hardware
operator|->
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|t
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
literal|1
operator|<
sizeof|sizeof
name|hardware
operator|->
name|hbuf
condition|)
name|memset
argument_list|(
operator|&
name|hardware
operator|->
name|hbuf
index|[
name|hlen
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|hardware
operator|->
name|hbuf
operator|)
operator|-
name|hlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* lease-time :== NUMBER SEMI */
end_comment

begin_function
name|void
name|parse_lease_time
parameter_list|(
name|cfile
parameter_list|,
name|timep
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|TIME
modifier|*
name|timep
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting numeric lease time"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|convert_num
argument_list|(
name|cfile
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|timep
argument_list|,
name|val
argument_list|,
literal|10
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Unswap the number - convert_num returns stuff in NBO. */
operator|*
name|timep
operator|=
name|ntohl
argument_list|(
operator|*
name|timep
argument_list|)
expr_stmt|;
comment|/* XXX */
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* No BNF for numeric aggregates - that's defined by the caller.  What    this function does is to parse a sequence of numbers seperated by    the token specified in seperator.  If max is zero, any number of    numbers will be parsed; otherwise, exactly max numbers are    expected.  Base and size tell us how to internalize the numbers    once they've been tokenized. */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|parse_numeric_aggregate
parameter_list|(
name|cfile
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|,
name|seperator
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
modifier|*
name|max
decl_stmt|;
name|int
name|seperator
decl_stmt|;
name|int
name|base
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|pair
name|c
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bufp
operator|&&
operator|*
name|max
condition|)
block|{
name|bufp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
operator|*
name|max
operator|*
name|size
operator|/
literal|8
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|log_fatal
argument_list|(
literal|"no space for numeric aggregate"
argument_list|)
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|bufp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|count
condition|)
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|seperator
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|max
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|RBRACE
operator|&&
name|token
operator|!=
name|LBRACE
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"too few numbers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allow NUMBER_OR_NAME if base is 16. */
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
operator|(
name|base
operator|!=
literal|16
operator|||
name|token
operator|!=
name|NUMBER_OR_NAME
operator|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric value."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* If we can, convert the number now; otherwise, build 		   a linked list of all the numbers. */
if|if
condition|(
name|s
condition|)
block|{
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|+=
name|size
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|log_fatal
argument_list|(
literal|"no temp space for number."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|c
operator|=
name|cons
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|count
operator|!=
operator|*
name|max
condition|)
do|;
comment|/* If we had to cons up a list, convert it now. */
if|if
condition|(
name|c
condition|)
block|{
name|bufp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|count
operator|*
name|size
operator|/
literal|8
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|log_fatal
argument_list|(
literal|"no space for numeric aggregate."
argument_list|)
expr_stmt|;
name|s
operator|=
name|bufp
operator|+
name|count
operator|-
name|size
operator|/
literal|8
expr_stmt|;
operator|*
name|max
operator|=
name|count
expr_stmt|;
block|}
while|while
condition|(
name|c
condition|)
block|{
name|pair
name|cdr
init|=
name|c
operator|->
name|cdr
decl_stmt|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|-=
name|size
operator|/
literal|8
expr_stmt|;
comment|/* Free up temp space. */
name|dfree
argument_list|(
name|c
operator|->
name|car
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|c
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|c
operator|=
name|cdr
expr_stmt|;
block|}
return|return
name|bufp
return|;
block|}
end_function

begin_function
name|void
name|convert_num
parameter_list|(
name|cfile
parameter_list|,
name|buf
parameter_list|,
name|str
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|val
init|=
literal|0
decl_stmt|;
name|int
name|tval
decl_stmt|;
name|int
name|max
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* If base wasn't specified, figure it out from the data. */
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|ptr
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
block|}
do|do
block|{
name|tval
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
comment|/* XXX assumes ASCII... */
if|if
condition|(
name|tval
operator|>=
literal|'a'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'A'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'0'
condition|)
name|tval
operator|-=
literal|'0'
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Bogus number: %s."
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tval
operator|>=
name|base
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Bogus number %s: digit %d not in base %d"
argument_list|,
name|str
argument_list|,
name|tval
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|val
operator|*
name|base
operator|+
name|tval
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ptr
condition|)
do|;
if|if
condition|(
name|negative
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s%lo exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s%lx exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s%lu exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|negative
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putShort
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putLong
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Unexpected integer size: %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|(
name|u_int8_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putUShort
argument_list|(
name|buf
argument_list|,
operator|(
name|u_int16_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putULong
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Unexpected integer size: %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER   *		NUMBER COLON NUMBER COLON NUMBER SEMI |  *          NUMBER NUMBER SLASH NUMBER SLASH NUMBER   *		NUMBER COLON NUMBER COLON NUMBER NUMBER SEMI |  *	    NEVER  *  * Dates are stored in GMT or with a timezone offset; first number is day  * of week; next is year/month/day; next is hours:minutes:seconds on a  * 24-hour clock, followed by the timezone offset in seconds, which is  * optional.  */
end_comment

begin_function
name|TIME
name|parse_date
parameter_list|(
name|cfile
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|guess
decl_stmt|;
name|int
name|tzoff
decl_stmt|,
name|wday
decl_stmt|,
name|year
decl_stmt|,
name|mon
decl_stmt|,
name|mday
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|static
name|int
name|months
index|[
literal|11
index|]
init|=
block|{
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|}
decl_stmt|;
comment|/* Day of week, or "never"... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NEVER
condition|)
block|{
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|MAX_TIME
return|;
block|}
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric day of week expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|wday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Year... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric year expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Note: the following is not a Y2K bug - it's a Y1.9K bug.   Until 	   somebody invents a time machine, I think we can safely disregard 	   it.   This actually works around a stupid Y2K bug that was present 	   in a very early beta release of dhcpd. */
name|year
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|>
literal|1900
condition|)
name|year
operator|-=
literal|1900
expr_stmt|;
comment|/* Slash seperating year from month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expected slash seperating year from month."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|mon
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Slash seperating month from day... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expected slash seperating month from day."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric day of month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|mday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Hour... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric hour expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|hour
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon seperating hour from minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expected colon seperating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|min
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon seperating minute from second... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expected colon seperating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|sec
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NUMBER
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|tzoff
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|tzoff
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the date ends in a semicolon... */
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Guess the time value... */
name|guess
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
literal|365
operator|*
operator|(
name|year
operator|-
literal|70
operator|)
operator|+
comment|/* Days in years since '70 */
operator|(
name|year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|+
comment|/* Leap days since '70 */
operator|(
name|mon
comment|/* Days in months this year */
condition|?
name|months
index|[
name|mon
operator|-
literal|1
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|mon
operator|>
literal|1
operator|&&
comment|/* Leap day this year */
operator|!
operator|(
operator|(
name|year
operator|-
literal|72
operator|)
operator|&
literal|3
operator|)
operator|)
operator|+
name|mday
operator|-
literal|1
operator|)
operator|*
literal|24
operator|)
operator|+
comment|/* Day of month */
name|hour
operator|)
operator|*
literal|60
operator|)
operator|+
name|min
operator|)
operator|*
literal|60
operator|)
operator|+
name|sec
operator|+
name|tzoff
expr_stmt|;
comment|/* This guess could be wrong because of leap seconds or other 	   weirdness we don't know about that the system does.   For 	   now, we're just going to accept the guess, but at some point 	   it might be nice to do a successive approximation here to 	   get an exact value.   Even if the error is small, if the 	   server is restarted frequently (and thus the lease database 	   is reread), the error could accumulate into something 	   significant. */
return|return
name|guess
return|;
block|}
end_function

begin_comment
comment|/*  * option-name :== IDENTIFIER |  		   IDENTIFIER . IDENTIFIER  */
end_comment

begin_function
name|struct
name|option
modifier|*
name|parse_option_name
parameter_list|(
name|cfile
parameter_list|,
name|allocate
parameter_list|,
name|known
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|allocate
decl_stmt|;
name|int
modifier|*
name|known
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|char
modifier|*
name|uname
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier after option keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
name|uname
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uname
condition|)
name|log_fatal
argument_list|(
literal|"no memory for uname information."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|uname
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DOT
condition|)
block|{
comment|/* Go ahead and take the DOT token... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* The next token should be an identifier... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier after '.'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Look up the option name hash table for the specified 		   uname. */
name|universe
operator|=
operator|(
expr|struct
name|universe
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|universe_hash_lookup
argument_list|(
operator|&
name|universe
argument_list|,
name|universe_hash
argument_list|,
name|uname
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"no option space named %s."
argument_list|,
name|uname
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Use the default hash table, which contains all the 		   standard dhcp option names. */
name|val
operator|=
name|uname
expr_stmt|;
name|universe
operator|=
operator|&
name|dhcp_universe
expr_stmt|;
block|}
comment|/* Look up the actual option info... */
name|option
operator|=
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
expr_stmt|;
name|option_hash_lookup
argument_list|(
operator|&
name|option
argument_list|,
name|universe
operator|->
name|hash
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* If we didn't get an option structure, it's an undefined option. */
if|if
condition|(
name|option
condition|)
block|{
if|if
condition|(
name|known
condition|)
operator|*
name|known
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If we've been told to allocate, that means that this 		   (might) be an option code definition, so we'll create 		   an option structure just in case. */
if|if
condition|(
name|allocate
condition|)
block|{
name|option
operator|=
name|new_option
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|uname
condition|)
name|option
operator|->
name|name
operator|=
name|val
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|dfree
argument_list|(
name|uname
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|s
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|log_fatal
argument_list|(
literal|"no memory for option %s.%s"
argument_list|,
name|universe
operator|->
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|option
operator|->
name|name
operator|=
name|s
expr_stmt|;
block|}
name|option
operator|->
name|universe
operator|=
name|universe
expr_stmt|;
name|option
operator|->
name|code
operator|=
literal|0
expr_stmt|;
return|return
name|option
return|;
block|}
if|if
condition|(
name|val
operator|==
name|uname
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"no option named %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"no option named %s in space %s"
argument_list|,
name|val
argument_list|,
name|uname
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Free the initial identifier token. */
name|dfree
argument_list|(
name|uname
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|option
return|;
block|}
end_function

begin_comment
comment|/* IDENTIFIER SEMI */
end_comment

begin_function
name|void
name|parse_option_space_decl
parameter_list|(
name|cfile
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|universe
modifier|*
modifier|*
name|ua
decl_stmt|,
modifier|*
name|nu
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Discard the SPACE token, 						     which was checked by the 						     caller. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|nu
operator|=
name|new_universe
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nu
condition|)
name|log_fatal
argument_list|(
literal|"No memory for new option space."
argument_list|)
expr_stmt|;
comment|/* Set up the server option universe... */
name|s
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|log_fatal
argument_list|(
literal|"No memory for new option space name."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|nu
operator|->
name|name
operator|=
name|s
expr_stmt|;
name|nu
operator|->
name|lookup_func
operator|=
name|lookup_hashed_option
expr_stmt|;
name|nu
operator|->
name|option_state_dereference
operator|=
name|hashed_option_state_dereference
expr_stmt|;
name|nu
operator|->
name|foreach
operator|=
name|hashed_option_space_foreach
expr_stmt|;
name|nu
operator|->
name|save_func
operator|=
name|save_hashed_option
expr_stmt|;
name|nu
operator|->
name|delete_func
operator|=
name|delete_hashed_option
expr_stmt|;
name|nu
operator|->
name|encapsulate
operator|=
name|hashed_option_space_encapsulate
expr_stmt|;
name|nu
operator|->
name|decode
operator|=
name|parse_option_buffer
expr_stmt|;
name|nu
operator|->
name|length_size
operator|=
literal|1
expr_stmt|;
name|nu
operator|->
name|tag_size
operator|=
literal|1
expr_stmt|;
name|nu
operator|->
name|store_tag
operator|=
name|putUChar
expr_stmt|;
name|nu
operator|->
name|store_length
operator|=
name|putUChar
expr_stmt|;
name|nu
operator|->
name|index
operator|=
name|universe_count
operator|++
expr_stmt|;
if|if
condition|(
name|nu
operator|->
name|index
operator|>=
name|universe_max
condition|)
block|{
name|ua
operator|=
name|dmalloc
argument_list|(
name|universe_max
operator|*
literal|2
operator|*
sizeof|sizeof
expr|*
name|ua
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ua
condition|)
name|log_fatal
argument_list|(
literal|"No memory to expand option space array."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ua
argument_list|,
name|universes
argument_list|,
name|universe_max
operator|*
sizeof|sizeof
expr|*
name|ua
argument_list|)
expr_stmt|;
name|universe_max
operator|*=
literal|2
expr_stmt|;
name|dfree
argument_list|(
name|universes
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|universes
operator|=
name|ua
expr_stmt|;
block|}
name|universes
index|[
name|nu
operator|->
name|index
index|]
operator|=
name|nu
expr_stmt|;
name|option_new_hash
argument_list|(
operator|&
name|nu
operator|->
name|hash
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nu
operator|->
name|hash
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate %s option hash table."
argument_list|,
name|nu
operator|->
name|name
argument_list|)
expr_stmt|;
name|universe_hash_add
argument_list|(
name|universe_hash
argument_list|,
name|nu
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|nu
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is faked up to look good right now.   Ideally, this should do a    recursive parse and allow arbitrary data structure definitions, but for    now it just allows you to specify a single type, an array of single types,    a sequence of types, or an array of sequences of types.     ocd :== NUMBER EQUALS ocsd SEMI     ocsd :== ocsd_type | 	    ocsd_type_sequence | 	    ARRAY OF ocsd_simple_type_sequence     ocsd_type_sequence :== LBRACE ocsd_types RBRACE     ocsd_simple_type_sequence :== LBRACE ocsd_simple_types RBRACE     ocsd_types :== ocsd_type | 		  ocsd_types ocsd_type     ocsd_type :== ocsd_simple_type | 		 ARRAY OF ocsd_simple_type     ocsd_simple_types :== ocsd_simple_type | 			 ocsd_simple_types ocsd_simple_type     ocsd_simple_type :== BOOLEAN | 			INTEGER NUMBER | 			SIGNED INTEGER NUMBER | 			UNSIGNED INTEGER NUMBER | 			IP-ADDRESS | 			TEXT | 			STRING | 			ENCAPSULATE identifier */
end_comment

begin_function
name|int
name|parse_option_code_definition
parameter_list|(
name|cfile
parameter_list|,
name|option
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|unsigned
name|arrayp
init|=
literal|0
decl_stmt|;
name|int
name|recordp
init|=
literal|0
decl_stmt|;
name|int
name|no_more_in_record
init|=
literal|0
decl_stmt|;
name|char
name|tokbuf
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|tokix
init|=
literal|0
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|is_signed
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|has_encapsulation
init|=
literal|0
decl_stmt|;
comment|/* Parse the option code. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting option code number."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|option
operator|->
name|code
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|EQUAL
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting \"=\""
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See if this is an array. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|ARRAY
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|OF
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting \"of\"."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arrayp
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
name|LBRACE
condition|)
block|{
name|recordp
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
comment|/* At this point we're expecting a data type. */
name|next_type
label|:
if|if
condition|(
name|has_encapsulation
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"encapsulate must always be the last item."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|ARRAY
case|:
if|if
condition|(
name|arrayp
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"no nested arrays."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|OF
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting \"of\"."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arrayp
operator|=
name|recordp
operator|+
literal|1
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|recordp
operator|)
operator|&&
operator|(
name|token
operator|==
name|LBRACE
operator|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"only uniform array inside record."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
goto|goto
name|next_type
goto|;
case|case
name|BOOLEAN
case|:
name|type
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
name|INTEGER
case|:
name|is_signed
operator|=
literal|1
expr_stmt|;
name|parse_integer
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting number."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|atoi
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|type
operator|=
name|is_signed
condition|?
literal|'b'
else|:
literal|'B'
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|type
operator|=
name|is_signed
condition|?
literal|'s'
else|:
literal|'S'
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|type
operator|=
name|is_signed
condition|?
literal|'l'
else|:
literal|'L'
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s bit precision is not supported."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SIGNED
case|:
name|is_signed
operator|=
literal|1
expr_stmt|;
name|parse_signed
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|INTEGER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting \"integer\" keyword."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
goto|goto
name|parse_integer
goto|;
case|case
name|UNSIGNED
case|:
name|is_signed
operator|=
literal|0
expr_stmt|;
goto|goto
name|parse_signed
goto|;
case|case
name|IP_ADDRESS
case|:
name|type
operator|=
literal|'I'
expr_stmt|;
break|break;
case|case
name|DOMAIN_NAME
case|:
name|type
operator|=
literal|'d'
expr_stmt|;
goto|goto
name|no_arrays
goto|;
case|case
name|TEXT
case|:
name|type
operator|=
literal|'t'
expr_stmt|;
name|no_arrays
label|:
if|if
condition|(
name|arrayp
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"arrays of text strings not %s"
argument_list|,
literal|"yet supported."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|no_more_in_record
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRING_TOKEN
case|:
name|type
operator|=
literal|'X'
expr_stmt|;
goto|goto
name|no_arrays
goto|;
case|case
name|ENCAPSULATE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting option space identifier"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
name|tokix
operator|+
literal|2
operator|>
sizeof|sizeof
argument_list|(
name|tokbuf
argument_list|)
condition|)
goto|goto
name|toobig
goto|;
name|tokbuf
index|[
name|tokix
operator|++
index|]
operator|=
literal|'E'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|tokbuf
index|[
name|tokix
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|tokix
operator|+=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'.'
expr_stmt|;
name|has_encapsulation
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown data type %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tokix
operator|==
sizeof|sizeof
name|tokbuf
condition|)
block|{
name|toobig
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"too many types in record."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
name|recordp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tokbuf
index|[
name|tokix
operator|++
index|]
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|arrayp
operator|>
name|recordp
condition|)
block|{
if|if
condition|(
name|tokix
operator|==
sizeof|sizeof
name|tokbuf
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"too many types in record."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arrayp
operator|=
literal|0
expr_stmt|;
name|tokbuf
index|[
name|tokix
operator|++
index|]
operator|=
literal|'a'
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
if|if
condition|(
name|no_more_in_record
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s must be at end of record."
argument_list|,
name|type
operator|==
literal|'t'
condition|?
literal|"text"
else|:
literal|"string"
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
goto|goto
name|next_type
goto|;
block|}
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right brace."
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|recordp
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|has_encapsulation
operator|&&
name|arrayp
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Arrays of encapsulations don't make sense."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|has_encapsulation
operator|&&
name|tokbuf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|has_encapsulation
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|dmalloc
argument_list|(
name|tokix
operator|+
operator|(
name|arrayp
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|has_encapsulation
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|log_fatal
argument_list|(
literal|"no memory for option format."
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_encapsulation
condition|)
name|s
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|+
name|has_encapsulation
argument_list|,
name|tokbuf
argument_list|,
name|tokix
argument_list|)
expr_stmt|;
name|tokix
operator|+=
name|has_encapsulation
expr_stmt|;
if|if
condition|(
name|arrayp
condition|)
name|s
index|[
name|tokix
operator|++
index|]
operator|=
operator|(
name|arrayp
operator|>
name|recordp
operator|)
condition|?
literal|'a'
else|:
literal|'A'
expr_stmt|;
name|s
index|[
name|tokix
index|]
operator|=
literal|0
expr_stmt|;
name|option
operator|->
name|format
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|universe
operator|->
name|options
index|[
name|option
operator|->
name|code
index|]
condition|)
block|{
comment|/* XXX Free the option, but we can't do that now because they 		   XXX may start out static. */
block|}
name|option
operator|->
name|universe
operator|->
name|options
index|[
name|option
operator|->
name|code
index|]
operator|=
name|option
expr_stmt|;
name|option_hash_add
argument_list|(
name|option
operator|->
name|universe
operator|->
name|hash
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|option
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|option
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * base64 :== NUMBER_OR_STRING  */
end_comment

begin_function
name|int
name|parse_base64
parameter_list|(
name|data
parameter_list|,
name|cfile
parameter_list|)
name|struct
name|data_string
modifier|*
name|data
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|acc
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|char
name|from64
index|[]
init|=
block|{
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|/*  \"#$%&' */
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|62
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|63
block|,
comment|/* ()*+,-./ */
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
comment|/* 01234567 */
literal|60
block|,
literal|61
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|/* 89:;<=>? */
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
comment|/* @ABCDEFG */
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* HIJKLMNO */
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
comment|/* PQRSTUVW */
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
comment|/* XYZ[\]^_ */
literal|64
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
comment|/* 'abcdefg */
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* hijklmno */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
comment|/* pqrstuvw */
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
comment|/* xyz{|}~  */
name|struct
name|string_list
modifier|*
name|bufs
init|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|last
init|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|cc
init|=
literal|0
decl_stmt|;
name|int
name|terminated
init|=
literal|0
decl_stmt|;
comment|/* It's possible for a + or a / to cause a base64 quantity to be 	   tokenized into more than one token, so we have to parse them all 	   in before decoding. */
do|do
block|{
name|unsigned
name|l
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|l
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|t
operator|=
name|dmalloc
argument_list|(
name|l
operator|+
sizeof|sizeof
expr|*
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|log_fatal
argument_list|(
literal|"no memory for base64 buffer."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
operator|->
name|string
argument_list|,
name|val
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cc
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|t
expr_stmt|;
else|else
name|bufs
operator|=
name|t
expr_stmt|;
name|last
operator|=
name|t
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NAME
operator|||
name|token
operator|==
name|EQUAL
operator|||
name|token
operator|==
name|NUMBER
operator|||
name|token
operator|==
name|PLUS
operator|||
name|token
operator|==
name|SLASH
operator|||
name|token
operator|==
name|STRING
condition|)
do|;
name|data
operator|->
name|len
operator|=
name|cc
expr_stmt|;
name|data
operator|->
name|len
operator|=
operator|(
name|data
operator|->
name|len
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|data
operator|->
name|buffer
argument_list|,
name|data
operator|->
name|len
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"can't allocate buffer for base64 data."
argument_list|)
expr_stmt|;
name|data
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|j
operator|=
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|bufs
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
operator|->
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|foo
init|=
name|t
operator|->
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|terminated
operator|&&
name|foo
operator|!=
literal|'='
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"stuff after base64 '=' terminator: %s."
argument_list|,
operator|&
name|t
operator|->
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|foo
operator|<
literal|' '
operator|||
name|foo
operator|>
literal|'z'
condition|)
block|{
name|bad64
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid base64 character %d."
argument_list|,
name|t
operator|->
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad
label|:
name|data_string_forget
argument_list|(
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|foo
operator|==
literal|'='
condition|)
name|terminated
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|foo
operator|=
name|from64
index|[
name|foo
operator|-
literal|' '
index|]
expr_stmt|;
if|if
condition|(
name|foo
operator|==
literal|64
condition|)
goto|goto
name|bad64
goto|;
name|acc
operator|=
operator|(
name|acc
operator|<<
literal|6
operator|)
operator|+
name|foo
expr_stmt|;
switch|switch
condition|(
name|k
operator|%
literal|4
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|data
operator|->
name|buffer
operator|->
name|data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|acc
operator|>>
literal|4
operator|)
expr_stmt|;
name|acc
operator|=
name|acc
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator|->
name|buffer
operator|->
name|data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|acc
operator|>>
literal|2
operator|)
expr_stmt|;
name|acc
operator|=
name|acc
operator|&
literal|0x03
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|data
operator|->
name|buffer
operator|->
name|data
index|[
name|j
operator|++
index|]
operator|=
name|acc
expr_stmt|;
name|acc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|k
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|%
literal|4
condition|)
block|{
if|if
condition|(
name|acc
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"partial base64 value left over: %d."
argument_list|,
name|acc
argument_list|)
expr_stmt|;
block|}
block|}
name|data
operator|->
name|len
operator|=
name|j
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|data
operator|->
name|buffer
operator|->
name|data
expr_stmt|;
name|out
label|:
for|for
control|(
name|t
operator|=
name|bufs
init|;
name|t
condition|;
name|t
operator|=
name|last
control|)
block|{
name|last
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|len
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * colon-seperated-hex-list :== NUMBER |  *				NUMBER COLON colon-seperated-hex-list  */
end_comment

begin_function
name|int
name|parse_cshl
parameter_list|(
name|data
parameter_list|,
name|cfile
parameter_list|)
name|struct
name|data_string
modifier|*
name|data
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
name|u_int8_t
name|ibuf
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|ilen
init|=
literal|0
decl_stmt|;
name|unsigned
name|tlen
init|=
literal|0
decl_stmt|;
name|struct
name|option_tag
modifier|*
name|sl
init|=
operator|(
expr|struct
name|option_tag
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|option_tag
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|last
init|=
operator|&
name|sl
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rvp
decl_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting hexadecimal number."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sl
condition|;
name|sl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sl
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ilen
operator|==
sizeof|sizeof
name|ibuf
condition|)
block|{
name|next
operator|=
operator|(
expr|struct
name|option_tag
operator|*
operator|)
name|dmalloc
argument_list|(
name|ilen
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|option_tag
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|log_fatal
argument_list|(
literal|"no memory for string list."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|next
operator|->
name|data
argument_list|,
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|next
expr_stmt|;
name|last
operator|=
operator|&
name|next
operator|->
name|next
expr_stmt|;
name|tlen
operator|+=
name|ilen
expr_stmt|;
name|ilen
operator|=
literal|0
expr_stmt|;
block|}
name|convert_num
argument_list|(
name|cfile
argument_list|,
operator|&
name|ibuf
index|[
name|ilen
operator|++
index|]
argument_list|,
name|val
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
break|break;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|data
operator|->
name|buffer
argument_list|,
name|tlen
operator|+
name|ilen
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory to store octet data."
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
operator|&
name|data
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|data
operator|->
name|len
operator|=
name|tlen
operator|+
name|ilen
expr_stmt|;
name|data
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
name|rvp
operator|=
operator|&
name|data
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|sl
condition|)
block|{
name|next
operator|=
name|sl
operator|->
name|next
expr_stmt|;
name|memcpy
argument_list|(
name|rvp
argument_list|,
name|sl
operator|->
name|data
argument_list|,
sizeof|sizeof
name|ibuf
argument_list|)
expr_stmt|;
name|rvp
operator|+=
sizeof|sizeof
name|ibuf
expr_stmt|;
name|dfree
argument_list|(
name|sl
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|sl
operator|=
name|next
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rvp
argument_list|,
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * executable-statements :== executable-statement executable-statements |  *			     executable-statement  *  * executable-statement :==  *	IF if-statement |  * 	ADD class-name SEMI |  *	BREAK SEMI |  *	OPTION option-parameter SEMI |  *	SUPERSEDE option-parameter SEMI |  *	PREPEND option-parameter SEMI |  *	APPEND option-parameter SEMI  */
end_comment

begin_function
name|int
name|parse_executable_statements
parameter_list|(
name|statements
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|,
name|case_context
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|statements
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
name|enum
name|expression_context
name|case_context
decl_stmt|;
block|{
name|struct
name|executable_statement
modifier|*
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|statements
expr_stmt|;
while|while
condition|(
name|parse_executable_statement
argument_list|(
name|next
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|case_context
argument_list|)
condition|)
name|next
operator|=
operator|&
operator|(
operator|(
operator|*
name|next
operator|)
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|parse_executable_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|,
name|case_context
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
name|enum
name|expression_context
name|case_context
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|executable_statement
name|base
decl_stmt|;
name|struct
name|class
modifier|*
name|cta
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|known
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|dns_zone
modifier|*
name|zone
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|IF
case|:
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return
name|parse_if_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
return|;
case|case
name|TOKEN_ADD
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting class name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cta
operator|=
operator|(
expr|struct
name|class
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|find_class
argument_list|(
operator|&
name|cta
argument_list|,
name|val
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"class %s: %s"
argument_list|,
name|val
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|add_statement
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|add
operator|=
name|cta
expr_stmt|;
break|break;
case|case
name|BREAK
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|break_statement
expr_stmt|;
break|break;
case|case
name|SEND
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|send_option_statement
argument_list|)
return|;
case|case
name|SUPERSEDE
case|:
case|case
name|OPTION
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|supersede_option_statement
argument_list|)
return|;
case|case
name|ALLOW
case|:
name|flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|pad
goto|;
case|case
name|DENY
case|:
name|flag
operator|=
literal|0
expr_stmt|;
goto|goto
name|pad
goto|;
case|case
name|IGNORE
case|:
name|flag
operator|=
literal|2
expr_stmt|;
name|pad
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_allow_deny
argument_list|(
operator|&
name|cache
argument_list|,
name|cfile
argument_list|,
name|flag
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|supersede_option_statement
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|option
operator|=
name|cache
expr_stmt|;
break|break;
case|case
name|DEFAULT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COLON
condition|)
goto|goto
name|switch_default
goto|;
name|known
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|default_option_statement
argument_list|)
return|;
case|case
name|PREPEND
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|prepend_option_statement
argument_list|)
return|;
case|case
name|APPEND
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|append_option_statement
argument_list|)
return|;
case|case
name|ON
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return
name|parse_on_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
return|;
case|case
name|SWITCH
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return
name|parse_switch_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
return|;
case|case
name|CASE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_context
operator|==
name|context_any
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"case statement in inappropriate scope."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parse_case_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|case_context
argument_list|)
return|;
name|switch_default
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_context
operator|==
name|context_any
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"switch default statement in %s"
argument_list|,
literal|"inappropriate scope."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for default statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|default_statement
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|DEFINE
case|:
case|case
name|TOKEN_SET
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DEFINE
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NAME
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s can't be a variable name"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|badset
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for set statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|flag
condition|?
name|define_statement
else|:
name|set_statement
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|name
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate variable name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|LPAREN
condition|)
block|{
name|struct
name|string_list
modifier|*
name|head
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|head
operator|=
name|cur
operator|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|RPAREN
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|NAME
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting argument name"
argument_list|)
expr_stmt|;
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new
operator|=
operator|(
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate string."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|string
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
name|cur
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|cur
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|cur
operator|=
name|new
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right paren."
argument_list|)
expr_stmt|;
name|badx
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace."
argument_list|)
expr_stmt|;
goto|goto
name|badx
goto|;
block|}
name|expr
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expression_allocate
argument_list|(
operator|&
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression."
argument_list|)
expr_stmt|;
name|expr
operator|->
name|op
operator|=
name|expr_function
expr_stmt|;
if|if
condition|(
operator|!
name|fundef_allocate
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|func
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate fundef."
argument_list|)
expr_stmt|;
name|expr
operator|->
name|data
operator|.
name|func
operator|->
name|args
operator|=
name|head
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_executable_statements
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|func
operator|->
name|statements
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|case_context
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|lose
condition|)
goto|goto
name|badx
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting rigt brace."
argument_list|)
expr_stmt|;
goto|goto
name|badx
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|token
operator|!=
name|EQUAL
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting '=' in %s statement."
argument_list|,
name|flag
condition|?
literal|"define"
else|:
literal|"set"
argument_list|)
expr_stmt|;
goto|goto
name|badset
goto|;
block|}
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|set
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_any
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting expression."
argument_list|)
expr_stmt|;
else|else
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
case|case
name|UNSET
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NAME
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s can't be a variable name"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|badunset
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for set statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|unset_statement
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|unset
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|unset
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate variable name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|unset
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|EVAL
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for eval statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|eval_statement
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|eval
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_data
argument_list|,
comment|/* XXX */
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting data expression."
argument_list|)
expr_stmt|;
else|else
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RETURN
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for return statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|return_statement
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|retval
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_data
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting data expression."
argument_list|)
expr_stmt|;
else|else
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|LOG
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for log statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|log_statement
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left parenthesis expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|FATAL
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|priority
operator|=
name|log_priority_fatal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|ERROR
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|priority
operator|=
name|log_priority_error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|TOKEN_DEBUG
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|priority
operator|=
name|log_priority_debug
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|INFO
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|priority
operator|=
name|log_priority_info
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|priority
operator|=
name|log_priority_debug
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"comma expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|log
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
block|{
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right parenthesis expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
comment|/* Not really a statement, but we parse it here anyway 		   because it's appropriate for all DHCP agents with 		   parsers. */
case|case
name|ZONE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|zone
operator|=
operator|(
expr|struct
name|dns_zone
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dns_zone_allocate
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new zone."
argument_list|)
expr_stmt|;
name|zone
operator|->
name|name
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|name
condition|)
block|{
name|badzone
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting hostname."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|zone
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|s
operator|=
name|dmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|2
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
goto|goto
name|badzone
goto|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|zone
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dfree
argument_list|(
name|zone
operator|->
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|zone
operator|->
name|name
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parse_zone
argument_list|(
name|zone
argument_list|,
name|cfile
argument_list|)
condition|)
goto|goto
name|badzone
goto|;
name|status
operator|=
name|enter_dns_zone
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"dns zone key %s: %s"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dns_zone_dereference
argument_list|(
operator|&
name|zone
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Also not really a statement, but same idea as above. */
case|case
name|KEY
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_key
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
default|default:
if|if
condition|(
name|config_universe
operator|&&
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|option
operator|=
operator|(
expr|struct
name|option
operator|*
operator|)
literal|0
expr_stmt|;
name|option_hash_lookup
argument_list|(
operator|&
name|option
argument_list|,
name|config_universe
operator|->
name|hash
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return
name|parse_option_statement
argument_list|(
name|result
argument_list|,
name|cfile
argument_list|,
literal|1
argument_list|,
name|option
argument_list|,
name|supersede_option_statement
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NAME
condition|)
block|{
comment|/* This is rather ugly.  Since function calls are 			   data expressions, fake up an eval statement. */
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for eval statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|eval_statement
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|eval
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_data
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting "
literal|"function call."
argument_list|)
expr_stmt|;
else|else
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
operator|*
name|lose
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* zone-statements :== zone-statement | 		       zone-statement zone-statements    zone-statement :== 	PRIMARY ip-addresses SEMI | 	SECONDARY ip-addresses SEMI | 	key-reference SEMI    ip-addresses :== ip-addr-or-hostname | 		  ip-addr-or-hostname COMMA ip-addresses    key-reference :== KEY STRING | 		    KEY identifier */
end_comment

begin_function
name|int
name|parse_zone
parameter_list|(
name|struct
name|dns_zone
modifier|*
name|zone
parameter_list|,
name|struct
name|parse
modifier|*
name|cfile
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|key_name
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|PRIMARY
case|:
if|if
condition|(
name|zone
operator|->
name|primary
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"more than one primary."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
operator|&
name|zone
operator|->
name|primary
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate primary option cache."
argument_list|)
expr_stmt|;
name|oc
operator|=
name|zone
operator|->
name|primary
expr_stmt|;
goto|goto
name|consemup
goto|;
case|case
name|SECONDARY
case|:
if|if
condition|(
name|zone
operator|->
name|secondary
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"more than one secondary."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
operator|&
name|zone
operator|->
name|secondary
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate secondary."
argument_list|)
expr_stmt|;
name|oc
operator|=
name|zone
operator|->
name|secondary
expr_stmt|;
name|consemup
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
do|do
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|parse_ip_addr_or_hostname
argument_list|(
operator|&
name|expr
argument_list|,
name|cfile
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting IP addr or hostname."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|oc
operator|->
name|expression
condition|)
block|{
name|struct
name|expression
modifier|*
name|old
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|expression_reference
argument_list|(
operator|&
name|old
argument_list|,
name|oc
operator|->
name|expression
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|oc
operator|->
name|expression
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_concat
argument_list|(
operator|&
name|oc
operator|->
name|expression
argument_list|,
name|old
argument_list|,
name|expr
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for concat."
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|old
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expression_reference
argument_list|(
operator|&
name|oc
operator|->
name|expression
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|KEY
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|key_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|key_name
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_name
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting key name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|=
name|key_name
expr_stmt|;
block|}
if|if
condition|(
name|omapi_auth_key_lookup_name
argument_list|(
operator|&
name|zone
operator|->
name|key
argument_list|,
name|val
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown key %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|dfree
argument_list|(
name|key_name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right brace."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* key-statements :== key-statement | 		      key-statement key-statements    key-statement :== 	ALGORITHM host-name SEMI | 	secret-definition SEMI    secret-definition :== SECRET base64val | 			 SECRET STRING */
end_comment

begin_function
name|int
name|parse_key
parameter_list|(
name|struct
name|parse
modifier|*
name|cfile
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|struct
name|auth_key
modifier|*
name|key
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|key
operator|=
operator|(
expr|struct
name|auth_key
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|omapi_auth_key_new
argument_list|(
operator|&
name|key
argument_list|,
name|MDL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"no memory for key"
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|key
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|name
condition|)
name|log_fatal
argument_list|(
literal|"no memory for key name."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|key
operator|->
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|name
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|name
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting key name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|ALGORITHM
case|:
if|if
condition|(
name|key
operator|->
name|algorithm
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"key %s: too many algorithms"
argument_list|,
name|key
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
name|key
operator|->
name|algorithm
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|->
name|algorithm
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting key algorithm name."
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
goto|goto
name|rbad
goto|;
comment|/* If the algorithm name isn't an FQDN, tack on 			   the .SIG-ALG.REG.NET. domain. */
name|s
operator|=
name|strrchr
argument_list|(
name|key
operator|->
name|algorithm
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
specifier|static
name|char
name|add
index|[]
init|=
literal|".SIG-ALG.REG.INT."
decl_stmt|;
name|s
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|key
operator|->
name|algorithm
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|add
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for key %s."
argument_list|,
literal|"algorithm"
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
name|strcpy
argument_list|(
name|s
argument_list|,
name|key
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|key
operator|->
name|algorithm
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|key
operator|->
name|algorithm
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
comment|/* If there is no trailing '.', hack one in. */
name|s
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|key
operator|->
name|algorithm
argument_list|)
operator|+
literal|2
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for key %s."
argument_list|,
name|key
operator|->
name|algorithm
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
name|strcpy
argument_list|(
name|s
argument_list|,
name|key
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|key
operator|->
name|algorithm
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|key
operator|->
name|algorithm
operator|=
name|s
expr_stmt|;
block|}
break|break;
case|case
name|SECRET
case|:
if|if
condition|(
name|key
operator|->
name|key
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"key %s: too many secrets"
argument_list|,
name|key
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_base64
argument_list|(
operator|&
name|ds
argument_list|,
name|cfile
argument_list|)
condition|)
goto|goto
name|rbad
goto|;
name|status
operator|=
name|omapi_data_string_new
argument_list|(
operator|&
name|key
operator|->
name|key
argument_list|,
name|ds
operator|.
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|rbad
goto|;
name|memcpy
argument_list|(
name|key
operator|->
name|key
operator|->
name|value
argument_list|,
name|ds
operator|.
name|buffer
operator|->
name|data
argument_list|,
name|ds
operator|.
name|len
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
goto|goto
name|rbad
goto|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right brace."
argument_list|)
expr_stmt|;
goto|goto
name|rbad
goto|;
block|}
comment|/* Allow the BIND 8 syntax, which has a semicolon after each 	   closing brace. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|SEMI
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Remember the key. */
name|status
operator|=
name|omapi_auth_key_enter
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"tsig key %s: %s"
argument_list|,
name|key
operator|->
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|omapi_auth_key_dereference
argument_list|(
operator|&
name|key
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|rbad
label|:
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bad
label|:
name|omapi_auth_key_dereference
argument_list|(
operator|&
name|key
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * on-statement :== event-types LBRACE executable-statements RBRACE  * event-types :== event-type OR event-types |  *		   event-type  * event-type :== EXPIRY | COMMIT | RELEASE  */
end_comment

begin_function
name|int
name|parse_on_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|on_statement
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|EXPIRY
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator||=
name|ON_EXPIRY
expr_stmt|;
break|break;
case|case
name|COMMIT
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator||=
name|ON_COMMIT
expr_stmt|;
break|break;
case|case
name|RELEASE
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator||=
name|ON_RELEASE
expr_stmt|;
break|break;
case|case
name|TRANSMISSION
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|evtypes
operator||=
name|ON_TRANSMISSION
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a lease event type"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|OR
condition|)
do|;
comment|/* Semicolon means no statements. */
if|if
condition|(
name|token
operator|==
name|SEMI
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left brace expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_executable_statements
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|on
operator|.
name|statements
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_any
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|lose
condition|)
block|{
comment|/* Try to even things up. */
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|END_OF_FILE
operator|&&
name|token
operator|!=
name|RBRACE
condition|)
do|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right brace expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * switch-statement :== LPAREN expr RPAREN LBRACE executable-statements RBRACE  *  */
end_comment

begin_function
name|int
name|parse_switch_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|switch_statement
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|pfui
label|:
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|gnorf
label|:
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_data_or_numeric
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting data or numeric expression."
argument_list|)
expr_stmt|;
goto|goto
name|pfui
goto|;
block|}
goto|goto
name|gnorf
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right paren expected."
argument_list|)
expr_stmt|;
goto|goto
name|pfui
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left brace expected."
argument_list|)
expr_stmt|;
goto|goto
name|pfui
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|parse_executable_statements
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|statements
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
operator|(
name|is_data_expression
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|s_switch
operator|.
name|expr
argument_list|)
condition|?
name|context_data
else|:
name|context_numeric
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|lose
condition|)
block|{
name|skip_to_rbrace
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right brace expected."
argument_list|)
expr_stmt|;
goto|goto
name|pfui
goto|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * case-statement :== CASE expr COLON  *  */
end_comment

begin_function
name|int
name|parse_case_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|,
name|case_context
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
name|enum
name|expression_context
name|case_context
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for new statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|case_statement
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|c_case
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|case_context
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting %s expression."
argument_list|,
operator|(
name|case_context
operator|==
name|context_data
condition|?
literal|"data"
else|:
literal|"numeric"
operator|)
argument_list|)
expr_stmt|;
block|}
name|pfui
label|:
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"colon expected."
argument_list|)
expr_stmt|;
goto|goto
name|pfui
goto|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * if-statement :== boolean-expression LBRACE executable-statements RBRACE  *						else-statement  *  * else-statement :==<null> |  *		      ELSE LBRACE executable-statements RBRACE |  *		      ELSE IF if-statement |  *		      ELSIF if-statement  */
end_comment

begin_function
name|int
name|parse_if_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|parenp
decl_stmt|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for if statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|if_statement
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|LPAREN
condition|)
block|{
name|parenp
operator|=
literal|1
expr_stmt|;
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
else|else
name|parenp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_boolean_expression
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"boolean expression expected."
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSION_PARSE
argument_list|)
name|print_expression
argument_list|(
literal|"if condition"
argument_list|,
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|parenp
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right paren."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left brace expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_executable_statements
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|tc
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_any
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|lose
condition|)
block|{
comment|/* Try to even things up. */
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|END_OF_FILE
operator|&&
name|token
operator|!=
name|RBRACE
condition|)
do|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right brace expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|ELSE
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|IF
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_if_statement
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting if statement"
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left brace or if expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_executable_statements
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_any
argument_list|)
operator|)
condition|)
block|{
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RBRACE
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right brace expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|ELSIF
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_if_statement
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting conditional."
argument_list|)
expr_stmt|;
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|ie
operator|.
name|fc
operator|=
operator|(
expr|struct
name|executable_statement
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * boolean_expression :== CHECK STRING |  *  			  NOT boolean-expression |  *			  data-expression EQUAL data-expression |  *			  data-expression BANG EQUAL data-expression |  *			  boolean-expression AND boolean-expression |  *			  boolean-expression OR boolean-expression  *			  EXISTS OPTION-NAME  */
end_comment

begin_function
name|int
name|parse_boolean_expression
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
comment|/* Parse an expression... */
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_boolean
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_boolean_expression
argument_list|(
operator|*
name|expr
argument_list|)
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_variable_reference
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_funcall
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting a boolean expression."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * data_expression :== SUBSTRING LPAREN data-expression COMMA  *					numeric-expression COMMA  *					numeric-expression RPAREN |  *		       CONCAT LPAREN data-expression COMMA  					data-expression RPAREN  *		       SUFFIX LPAREN data_expression COMMA  *		       		     numeric-expression RPAREN |  *		       OPTION option_name |  *		       HARDWARE |  *		       PACKET LPAREN numeric-expression COMMA  *				     numeric-expression RPAREN |  *		       STRING |  *		       colon_seperated_hex_list  */
end_comment

begin_function
name|int
name|parse_data_expression
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
comment|/* Parse an expression... */
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_data
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_data_expression
argument_list|(
operator|*
name|expr
argument_list|)
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_variable_reference
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_funcall
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting a data expression."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * numeric-expression :== EXTRACT_INT LPAREN data-expression  *					     COMMA number RPAREN |  *			  NUMBER  */
end_comment

begin_function
name|int
name|parse_numeric_expression
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
comment|/* Parse an expression... */
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_numeric
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_numeric_expression
argument_list|(
operator|*
name|expr
argument_list|)
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_variable_reference
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_funcall
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting a numeric expression."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * dns-expression :==  *	UPDATE LPAREN ns-class COMMA ns-type COMMA data-expression COMMA  *				data-expression COMMA numeric-expression RPAREN  *	DELETE LPAREN ns-class COMMA ns-type COMMA data-expression COMMA  *				data-expression RPAREN  *	EXISTS LPAREN ns-class COMMA ns-type COMMA data-expression COMMA  *				data-expression RPAREN  *	NOT EXISTS LPAREN ns-class COMMA ns-type COMMA data-expression COMMA  *				data-expression RPAREN  * ns-class :== IN | CHAOS | HS | NUMBER  * ns-type :== A | PTR | MX | TXT | NUMBER  */
end_comment

begin_function
name|int
name|parse_dns_expression
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
block|{
comment|/* Parse an expression... */
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_dns
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_dns_expression
argument_list|(
operator|*
name|expr
argument_list|)
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_variable_reference
operator|&&
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|!=
name|expr_funcall
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Expecting a dns update subexpression."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a subexpression that does not contain a binary operator. */
end_comment

begin_function
name|int
name|parse_non_binary
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|,
name|context
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
name|enum
name|expression_context
name|context
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|collection
modifier|*
name|col
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|expression
modifier|*
name|nexp
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|int
name|known
decl_stmt|;
name|enum
name|expr_op
name|opcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|stmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|u
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|,
name|code
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Check for unary operators... */
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CHECK
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"string expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|col
operator|=
name|collections
init|;
name|col
condition|;
name|col
operator|=
name|col
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|col
operator|->
name|name
argument_list|,
name|val
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|col
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown collection."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_check
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|check
operator|=
name|col
expr_stmt|;
break|break;
case|case
name|TOKEN_NOT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|context_dns
condition|)
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
goto|goto
name|not_exists
goto|;
block|}
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_not
expr_stmt|;
if|if
condition|(
operator|!
name|parse_non_binary
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|not
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_boolean
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expression expected"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|is_boolean_expression
argument_list|(
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|not
argument_list|)
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"boolean expression expected"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|LPAREN
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expression expected"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right paren expected"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|EXISTS
case|:
if|if
condition|(
name|context
operator|==
name|context_dns
condition|)
goto|goto
name|ns_exists
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_exists
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|STATIC
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_static
expr_stmt|;
break|break;
case|case
name|KNOWN
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_known
expr_stmt|;
break|break;
case|case
name|SUBSTRING
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_substring
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
name|nolparen
label|:
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
name|nodata
label|:
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting data expression."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
block|{
name|nocomma
label|:
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"comma expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
name|nonum
label|:
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric expression."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
block|}
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nonum
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|norparen
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SUFFIX
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_suffix
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|suffix
operator|.
name|expr
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nonum
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|CONCAT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_concat
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
name|concat_another
label|:
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
name|nexp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
name|nexp
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate at CONCAT2"
argument_list|)
expr_stmt|;
name|nexp
operator|->
name|op
operator|=
name|expr_concat
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
name|nexp
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|,
operator|*
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
name|expr
argument_list|,
name|nexp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|nexp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
goto|goto
name|concat_another
goto|;
block|}
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|BINARY_TO_ASCII
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_binary_to_ascii
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|b2a
operator|.
name|base
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|b2a
operator|.
name|width
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|b2a
operator|.
name|seperator
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|b2a
operator|.
name|buffer
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|REVERSE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_reverse
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
if|if
condition|(
operator|!
operator|(
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|reverse
operator|.
name|width
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|PICK
case|:
comment|/* pick (a, b, c) actually produces an internal representation 		   that looks like pick (a, pick (b, pick (c, nil))). */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|nexp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
name|nexp
argument_list|,
operator|*
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
do|do
block|{
name|nexp
operator|->
name|op
operator|=
name|expr_pick_first_value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
name|nexp
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|car
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
name|struct
name|expression
modifier|*
name|foo
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
name|foo
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expr"
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
name|nexp
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
argument_list|,
name|foo
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|nexp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
name|nexp
argument_list|,
name|foo
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|foo
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
name|expression_dereference
argument_list|(
operator|&
name|nexp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
comment|/* dns-update and dns-delete are present for historical 		   purposes, but are deprecated in favor of ns-update 		   in combination with update, delete, exists and not 		   exists. */
case|case
name|DNS_UPDATE
case|:
case|case
name|DNS_DELETE
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Please rebuild dhcpd with --with-nsupdate."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DNS_UPDATE
condition|)
name|opcode
operator|=
name|expr_ns_add
expr_stmt|;
else|else
name|opcode
operator|=
name|expr_ns_delete
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"parse_expression: expecting string."
argument_list|)
expr_stmt|;
name|badnsupdate
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"a"
argument_list|)
condition|)
name|u
operator|=
name|T_A
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"ptr"
argument_list|)
condition|)
name|u
operator|=
name|T_PTR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"mx"
argument_list|)
condition|)
name|u
operator|=
name|T_MX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"cname"
argument_list|)
condition|)
name|u
operator|=
name|T_CNAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"TXT"
argument_list|)
condition|)
name|u
operator|=
name|T_TXT
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unexpected rrtype: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|badnsupdate
goto|;
block|}
name|s
operator|=
operator|(
name|opcode
operator|==
name|expr_ns_add
condition|?
literal|"old-dns-update"
else|:
literal|"old-dns-delete"
operator|)
expr_stmt|;
name|cptr
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cptr
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate name for %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_funcall
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
operator|=
name|cptr
expr_stmt|;
comment|/* Fake up a function call. */
name|ep
operator|=
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|funcall
operator|.
name|arglist
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|ep
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ep
operator|)
operator|->
name|op
operator|=
name|expr_arg
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_int
argument_list|(
operator|&
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|u
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate rrtype value."
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
name|ep
operator|=
operator|&
operator|(
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|ep
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ep
operator|)
operator|->
name|op
operator|=
name|expr_arg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
name|ep
operator|=
operator|&
operator|(
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|ep
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ep
operator|)
operator|->
name|op
operator|=
name|expr_arg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
if|if
condition|(
name|opcode
operator|==
name|expr_ns_add
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
name|ep
operator|=
operator|&
operator|(
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|ep
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ep
operator|)
operator|->
name|op
operator|=
name|expr_arg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric expression."
argument_list|)
expr_stmt|;
goto|goto
name|badnsupdate
goto|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|NS_UPDATE
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Please rebuild dhcpd with --with-nsupdate."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|nexp
operator|=
operator|*
name|expr
expr_stmt|;
do|do
block|{
name|nexp
operator|->
name|op
operator|=
name|expr_dns_transaction
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse_dns_expression
argument_list|(
operator|&
name|nexp
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|car
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting dns expression."
argument_list|)
expr_stmt|;
name|badnstrans
label|:
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|expression_allocate
argument_list|(
operator|&
name|nexp
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
name|nexp
operator|=
name|nexp
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
expr_stmt|;
block|}
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
comment|/* NOT EXISTS is special cased above... */
name|not_exists
label|:
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|EXISTS
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting DNS prerequisite."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|opcode
operator|=
name|expr_ns_not_exists
expr_stmt|;
goto|goto
name|nsupdatecode
goto|;
case|case
name|TOKEN_ADD
case|:
name|opcode
operator|=
name|expr_ns_add
expr_stmt|;
goto|goto
name|nsupdatecode
goto|;
case|case
name|TOKEN_DELETE
case|:
name|opcode
operator|=
name|expr_ns_delete
expr_stmt|;
goto|goto
name|nsupdatecode
goto|;
name|ns_exists
label|:
name|opcode
operator|=
name|expr_ns_exists
expr_stmt|;
name|nsupdatecode
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Please rebuild dhcpd with --with-nsupdate."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|opcode
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
operator|&&
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier or number."
argument_list|)
expr_stmt|;
name|badnsop
label|:
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|token
operator|==
name|NUMBER
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"in"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
operator|=
name|C_IN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"chaos"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
operator|=
name|C_CHAOS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"hs"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
operator|=
name|C_HS
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unexpected rrclass: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|badnsop
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
operator|&&
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier or number."
argument_list|)
expr_stmt|;
goto|goto
name|badnsop
goto|;
block|}
if|if
condition|(
name|token
operator|==
name|NUMBER
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"a"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|T_A
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"ptr"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|T_PTR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"mx"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|T_MX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"cname"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|T_CNAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"TXT"
argument_list|)
condition|)
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
operator|=
name|T_TXT
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unexpected rrtype: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|badnsop
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
operator|(
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
goto|goto
name|nodata
goto|;
if|if
condition|(
name|opcode
operator|==
name|expr_ns_add
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
operator|(
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|ns_add
operator|.
name|ttl
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric expression."
argument_list|)
expr_stmt|;
goto|goto
name|badnsupdate
goto|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|OPTION
case|:
case|case
name|CONFIG_OPTION
case|:
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
operator|(
name|token
operator|==
name|OPTION
condition|?
name|expr_option
else|:
name|expr_config_option
operator|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|known
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|option
condition|)
block|{
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|HARDWARE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_hardware
expr_stmt|;
break|break;
case|case
name|LEASED_ADDRESS
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_leased_address
expr_stmt|;
break|break;
case|case
name|CLIENT_STATE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_client_state
expr_stmt|;
break|break;
case|case
name|FILENAME
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_filename
expr_stmt|;
break|break;
case|case
name|SERVER_NAME
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_sname
expr_stmt|;
break|break;
case|case
name|LEASE_TIME
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_lease_time
expr_stmt|;
break|break;
case|case
name|TOKEN_NULL
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_null
expr_stmt|;
break|break;
case|case
name|HOST_DECL_NAME
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_host_decl_name
expr_stmt|;
break|break;
case|case
name|UPDATED_DNS_RR
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting string."
argument_list|)
expr_stmt|;
name|bad_rrtype
label|:
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"a"
argument_list|)
condition|)
name|s
operator|=
literal|"ddns-fwd-name"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"ptr"
argument_list|)
condition|)
name|s
operator|=
literal|"ddns-rev-name"
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"invalid DNS rrtype: %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|bad_rrtype
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_variable_reference
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate variable name."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_packet
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|packet
operator|.
name|offset
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nonum
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
goto|goto
name|nocomma
goto|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|packet
operator|.
name|len
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
goto|goto
name|nonum
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
case|case
name|STRING
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
name|expr
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't make constant string expression."
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTRACT_INT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting data expression."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
block|}
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"comma expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"number expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|atoi
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_extract_int8
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_extract_int16
expr_stmt|;
break|break;
case|case
literal|32
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_extract_int32
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unsupported integer size %d"
argument_list|,
name|atoi
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|ENCODE_INT
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"left parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_numeric_expression
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|encode_int
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric expression."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COMMA
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"comma expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"number expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|atoi
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_encode_int8
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_encode_int16
expr_stmt|;
break|break;
case|case
literal|32
case|:
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_encode_int32
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unsupported integer size %d"
argument_list|,
name|atoi
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"right parenthesis expected."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|NUMBER
case|:
comment|/* If we're in a numeric context, this should just be a 		   number, by itself. */
if|if
condition|(
name|context
operator|==
name|context_numeric
operator|||
name|context
operator|==
name|context_data_or_numeric
condition|)
block|{
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_const_int
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|const_int
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NUMBER_OR_NAME
case|:
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_const_data
expr_stmt|;
if|if
condition|(
operator|!
name|parse_cshl
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|const_data
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|NS_FORMERR
case|:
name|known
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|ns_const
goto|;
name|ns_const
label|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_const_int
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|const_int
operator|=
name|known
expr_stmt|;
break|break;
case|case
name|NS_NOERROR
case|:
name|known
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_NOTAUTH
case|:
name|known
operator|=
name|ISC_R_NOTAUTH
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_NOTIMP
case|:
name|known
operator|=
name|ISC_R_NOTIMPLEMENTED
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_NOTZONE
case|:
name|known
operator|=
name|ISC_R_NOTZONE
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_NXDOMAIN
case|:
name|known
operator|=
name|ISC_R_NXDOMAIN
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_NXRRSET
case|:
name|known
operator|=
name|ISC_R_NXRRSET
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_REFUSED
case|:
name|known
operator|=
name|ISC_R_REFUSED
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_SERVFAIL
case|:
name|known
operator|=
name|ISC_R_SERVFAIL
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_YXDOMAIN
case|:
name|known
operator|=
name|ISC_R_YXDOMAIN
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|NS_YXRRSET
case|:
name|known
operator|=
name|ISC_R_YXRRSET
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|BOOTING
case|:
name|known
operator|=
name|S_INIT
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|REBOOT
case|:
name|known
operator|=
name|S_REBOOTING
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|SELECT
case|:
name|known
operator|=
name|S_SELECTING
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|REQUEST
case|:
name|known
operator|=
name|S_REQUESTING
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|BOUND
case|:
name|known
operator|=
name|S_BOUND
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|RENEW
case|:
name|known
operator|=
name|S_RENEWING
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|REBIND
case|:
name|known
operator|=
name|S_REBINDING
expr_stmt|;
goto|goto
name|ns_const
goto|;
case|case
name|DEFINED
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
goto|goto
name|nolparen
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NAME
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"%s can't be a variable name"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_variable_exists
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate variable name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
goto|goto
name|norparen
goto|;
break|break;
comment|/* Not a valid start to an expression... */
default|default:
if|if
condition|(
name|token
operator|!=
name|NAME
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
return|return
literal|0
return|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Save the name of the variable being referenced. */
name|cptr
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cptr
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate variable name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Simple variable reference, as far as we can tell. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LPAREN
condition|)
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_variable_reference
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|variable
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_funcall
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
operator|=
name|cptr
expr_stmt|;
comment|/* Now parse the argument list. */
name|ep
operator|=
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|funcall
operator|.
name|arglist
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|ep
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"can't allocate expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ep
operator|)
operator|->
name|op
operator|=
name|expr_arg
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context_any
argument_list|,
operator|(
expr|struct
name|expression
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|expr_none
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting expression."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
block|}
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ep
operator|=
operator|&
operator|(
operator|(
operator|*
name|ep
operator|)
operator|->
name|data
operator|.
name|arg
operator|.
name|next
operator|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|RPAREN
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Right parenthesis expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression. */
end_comment

begin_function
name|int
name|parse_expression
parameter_list|(
name|expr
parameter_list|,
name|cfile
parameter_list|,
name|lose
parameter_list|,
name|context
parameter_list|,
name|plhs
parameter_list|,
name|binop
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
modifier|*
name|lose
decl_stmt|;
name|enum
name|expression_context
name|context
decl_stmt|;
name|struct
name|expression
modifier|*
modifier|*
name|plhs
decl_stmt|;
name|enum
name|expr_op
name|binop
decl_stmt|;
block|{
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|expression
modifier|*
name|rhs
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|expression
modifier|*
name|lhs
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|enum
name|expr_op
name|next_op
decl_stmt|;
name|enum
name|expression_context
name|lhs_context
init|=
name|context_any
decl_stmt|,
name|rhs_context
init|=
name|context_any
decl_stmt|;
comment|/* Consume the left hand side we were passed. */
if|if
condition|(
name|plhs
condition|)
block|{
name|expression_reference
argument_list|(
operator|&
name|lhs
argument_list|,
operator|*
name|plhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|plhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|new_rhs
label|:
if|if
condition|(
operator|!
name|parse_non_binary
argument_list|(
operator|&
name|rhs
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|context
argument_list|)
condition|)
block|{
comment|/* If we already have a left-hand side, then it's not 		   okay for there not to be a right-hand side here, so 		   we need to flag it as an error. */
if|if
condition|(
name|lhs
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting right-hand side."
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
name|expression_dereference
argument_list|(
operator|&
name|lhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* At this point, rhs contains either an entire subexpression, 	   or at least a left-hand-side.   If we do not see a binary token 	   as the next token, we're done with the expression. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|BANG
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|EQUAL
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"! in boolean context without ="
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
condition|)
name|expression_dereference
argument_list|(
operator|&
name|lhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|next_op
operator|=
name|expr_not_equal
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQUAL
case|:
name|next_op
operator|=
name|expr_equal
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|next_op
operator|=
name|expr_and
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_boolean
condition|)
block|{
name|needbool
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting boolean expressions"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|rhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|OR
case|:
name|next_op
operator|=
name|expr_or
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_boolean
condition|)
goto|goto
name|needbool
goto|;
break|break;
case|case
name|PLUS
case|:
name|next_op
operator|=
name|expr_add
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
block|{
name|neednum
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting numeric expressions"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|rhs
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|MINUS
case|:
name|next_op
operator|=
name|expr_subtract
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|SLASH
case|:
name|next_op
operator|=
name|expr_divide
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|ASTERISK
case|:
name|next_op
operator|=
name|expr_multiply
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|PERCENT
case|:
name|next_op
operator|=
name|expr_remainder
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|AMPERSAND
case|:
name|next_op
operator|=
name|expr_binary_and
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|PIPE
case|:
name|next_op
operator|=
name|expr_binary_or
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
case|case
name|CARET
case|:
name|next_op
operator|=
name|expr_binary_xor
expr_stmt|;
name|context
operator|=
name|expression_context
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|context_numeric
condition|)
goto|goto
name|neednum
goto|;
break|break;
default|default:
name|next_op
operator|=
name|expr_none
expr_stmt|;
block|}
comment|/* If we have no lhs yet, we just parsed it. */
if|if
condition|(
operator|!
name|lhs
condition|)
block|{
comment|/* If there was no operator following what we just parsed, 		   then we're done - return it. */
if|if
condition|(
name|next_op
operator|==
name|expr_none
condition|)
block|{
operator|*
name|expr
operator|=
name|rhs
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lhs
operator|=
name|rhs
expr_stmt|;
name|rhs
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
name|binop
operator|=
name|next_op
expr_stmt|;
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
goto|goto
name|new_rhs
goto|;
block|}
comment|/* Now, if we didn't find a binary operator, we're done parsing 	   this subexpression, so combine it with the preceding binary 	   operator and return the result. */
if|if
condition|(
name|next_op
operator|==
name|expr_none
condition|)
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate expression!"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|binop
expr_stmt|;
comment|/* All the binary operators' data union members 		   are the same, so we'll cheat and use the member 		   for the equals operator. */
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
operator|=
name|lhs
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
operator|=
name|rhs
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Eat the operator token - we now know it was a binary operator... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* If the binary operator we saw previously has a lower precedence 	   than the next operator, then the rhs we just parsed for that 	   operator is actually the lhs of the operator with the higher 	   precedence - to get the real rhs, we need to recurse on the 	   new operator. */
if|if
condition|(
name|binop
operator|!=
name|expr_none
operator|&&
name|op_precedence
argument_list|(
name|binop
argument_list|,
name|next_op
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
name|rhs
expr_stmt|;
name|rhs
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_expression
argument_list|(
operator|&
name|rhs
argument_list|,
name|cfile
argument_list|,
name|lose
argument_list|,
name|op_context
argument_list|(
name|next_op
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
name|next_op
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a subexpression"
argument_list|)
expr_stmt|;
operator|*
name|lose
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|next_op
operator|=
name|expr_none
expr_stmt|;
block|}
comment|/* Now combine the LHS and the RHS using binop. */
name|tmp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"No memory for equal precedence combination."
argument_list|)
expr_stmt|;
comment|/* Store the LHS and RHS. */
name|tmp
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
operator|=
name|lhs
expr_stmt|;
name|tmp
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
operator|=
name|rhs
expr_stmt|;
name|tmp
operator|->
name|op
operator|=
name|binop
expr_stmt|;
name|lhs
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
name|rhs
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Recursions don't return until we have parsed the end of the 	   expression, so if we recursed earlier, we can now return what 	   we got. */
if|if
condition|(
name|next_op
operator|==
name|expr_none
condition|)
block|{
operator|*
name|expr
operator|=
name|lhs
expr_stmt|;
return|return
literal|1
return|;
block|}
name|binop
operator|=
name|next_op
expr_stmt|;
goto|goto
name|new_rhs
goto|;
block|}
end_function

begin_comment
comment|/* option-statement :== identifier DOT identifier<syntax> SEMI 		      | identifier<syntax> SEMI     Option syntax is handled specially through format strings, so it    would be painful to come up with BNF for it.   However, it always    starts as above and ends in a SEMI. */
end_comment

begin_function
name|int
name|parse_option_statement
parameter_list|(
name|result
parameter_list|,
name|cfile
parameter_list|,
name|lookups
parameter_list|,
name|option
parameter_list|,
name|op
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|int
name|lookups
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|enum
name|statement_op
name|op
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|NULL
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|expression
modifier|*
name|tmp
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|struct
name|executable_statement
modifier|*
name|stmt
decl_stmt|;
name|int
name|ftt
init|=
literal|1
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|SEMI
condition|)
block|{
comment|/* Eat the semicolon... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|token
operator|==
name|EQUAL
condition|)
block|{
comment|/* Eat the equals sign. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Parse a data expression and use its value for the data. */
if|if
condition|(
operator|!
name|parse_data_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|cfile
argument_list|,
operator|&
name|lose
argument_list|)
condition|)
block|{
comment|/* In this context, we must have an executable 			   statement, so if we found something else, it's 			   still an error. */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting a data expression."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* We got a valid expression, so use it. */
goto|goto
name|done
goto|;
block|}
comment|/* Parse the option data... */
do|do
block|{
comment|/* Set a flag if this is an array of a simple type (i.e., 		   not an array of pairs of IP addresses, or something 		   like that. */
name|int
name|uniform
init|=
name|option
operator|->
name|format
index|[
literal|1
index|]
operator|==
literal|'A'
decl_stmt|;
name|and_again
label|:
comment|/* Set fmt to start of format for 'A' and one char back 		   for 'a' */
if|if
condition|(
operator|(
name|fmt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fmt
operator|!=
name|option
operator|->
name|format
operator|)
operator|&&
operator|(
operator|*
name|fmt
operator|==
literal|'a'
operator|)
condition|)
name|fmt
operator|-=
literal|1
expr_stmt|;
else|else
name|fmt
operator|=
operator|(
operator|(
name|fmt
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'A'
operator|)
operator|)
condition|?
name|option
operator|->
name|format
else|:
name|fmt
expr_stmt|;
comment|/* 'a' means always uniform */
name|uniform
operator||=
operator|(
name|fmt
index|[
literal|1
index|]
operator|==
literal|'a'
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|fmt
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'A'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'a'
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'o'
condition|)
continue|continue;
name|tmp
operator|=
name|expr
expr_stmt|;
name|expr
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parse_option_token
argument_list|(
operator|&
name|expr
argument_list|,
name|cfile
argument_list|,
operator|&
name|fmt
argument_list|,
name|tmp
argument_list|,
name|uniform
argument_list|,
name|lookups
argument_list|)
condition|)
block|{
if|if
condition|(
name|fmt
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
if|if
condition|(
name|tmp
condition|)
name|expression_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|expr
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tmp
condition|)
name|expression_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'A'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'a'
operator|)
condition|)
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Comma means: continue with next element in array */
if|if
condition|(
name|token
operator|==
name|COMMA
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* no comma: end of array. 			   'A' or end of string means: leave the loop */
if|if
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'A'
operator|)
operator|||
operator|(
name|fmt
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
comment|/* 'a' means: go on with next char */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'a'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
goto|goto
name|and_again
goto|;
block|}
block|}
block|}
do|while
condition|(
operator|(
operator|*
name|fmt
operator|==
literal|'A'
operator|)
operator|||
operator|(
operator|*
name|fmt
operator|==
literal|'a'
operator|)
condition|)
do|;
name|done
label|:
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for option statement."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|expr
operator|&&
operator|!
name|option_cache
argument_list|(
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|option
argument_list|,
operator|(
expr|struct
name|data_string
operator|*
operator|)
literal|0
argument_list|,
name|expr
argument_list|,
name|option
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory for option cache"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|parse_option_token
parameter_list|(
name|rv
parameter_list|,
name|cfile
parameter_list|,
name|fmt
parameter_list|,
name|expr
parameter_list|,
name|uniform
parameter_list|,
name|lookups
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|rv
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|int
name|uniform
decl_stmt|;
name|int
name|lookups
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|enum
name|dhcp_token
name|token
decl_stmt|;
name|struct
name|expression
modifier|*
name|t
init|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ob
decl_stmt|;
name|struct
name|iaddr
name|addr
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|struct
name|enumeration_value
modifier|*
name|e
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|fmt
condition|)
block|{
case|case
literal|'U'
case|:
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"No memory for %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|g
operator|=
name|strchr
argument_list|(
operator|*
name|fmt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"malformed encapsulation format (bug!)"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|fmt
operator|=
name|g
expr_stmt|;
case|case
literal|'X'
case|:
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NUMBER
condition|)
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
name|t
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parse_cshl
argument_list|(
operator|&
name|t
operator|->
name|data
operator|.
name|const_data
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
name|expression_dereference
argument_list|(
operator|&
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|t
operator|->
name|op
operator|=
name|expr_const_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"No memory for \"%s\""
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting string %s."
argument_list|,
literal|"or hexadecimal data"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* Domain name... */
name|val
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"not a valid domain name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
goto|goto
name|make_string
goto|;
case|case
literal|'t'
case|:
comment|/* Text string... */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|&&
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting string."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|make_string
label|:
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"No memory for concatenation"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|f
operator|=
operator|(
operator|*
name|fmt
operator|)
operator|+
literal|1
expr_stmt|;
name|g
operator|=
name|strchr
argument_list|(
operator|*
name|fmt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"malformed %s (bug!)"
argument_list|,
literal|"enumeration format"
argument_list|)
expr_stmt|;
name|foo
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|fmt
operator|=
name|g
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"identifier expected"
argument_list|)
expr_stmt|;
goto|goto
name|foo
goto|;
block|}
name|e
operator|=
name|find_enumeration_value
argument_list|(
name|f
argument_list|,
operator|(
operator|*
name|fmt
operator|)
operator|-
name|f
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown value"
argument_list|)
expr_stmt|;
goto|goto
name|foo
goto|;
block|}
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|e
operator|->
name|value
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'I'
case|:
comment|/* IP address or hostname. */
if|if
condition|(
name|lookups
condition|)
block|{
if|if
condition|(
operator|!
name|parse_ip_addr_or_hostname
argument_list|(
operator|&
name|t
argument_list|,
name|cfile
argument_list|,
name|uniform
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|addr
operator|.
name|iabuf
argument_list|,
name|addr
operator|.
name|len
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* Lease interval. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|INFINITE
condition|)
goto|goto
name|check_number
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|putLong
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'L'
case|:
comment|/* Unsigned 32-bit integer... */
case|case
literal|'l'
case|:
comment|/* Signed 32-bit integer... */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|check_number
label|:
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|need_number
label|:
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting number."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
comment|/* Signed 16-bit integer. */
case|case
literal|'S'
case|:
comment|/* Unsigned 16-bit integer. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'b'
case|:
comment|/* Signed 8-bit integer. */
case|case
literal|'B'
case|:
comment|/* Unsigned 8-bit integer. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'f'
case|:
comment|/* Boolean flag. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|bad_flag
label|:
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"on"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"ignore"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|fmt
operator|)
index|[
literal|1
index|]
operator|!=
literal|'o'
condition|)
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting boolean."
argument_list|)
expr_stmt|;
goto|goto
name|bad_flag
goto|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|make_const_data
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"Bad format %c in parse_option_token."
argument_list|,
operator|*
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|expr
condition|)
block|{
if|if
condition|(
operator|!
name|make_concat
argument_list|(
name|rv
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|expression_reference
argument_list|(
name|rv
argument_list|,
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
operator|&
name|t
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|parse_option_decl
parameter_list|(
name|oc
parameter_list|,
name|cfile
parameter_list|)
name|struct
name|option_cache
modifier|*
modifier|*
name|oc
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|u_int8_t
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u_int8_t
name|hunkbuf
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|hunkix
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|iaddr
name|ip_addr
decl_stmt|;
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|int
name|nul_term
init|=
literal|0
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bp
decl_stmt|;
name|int
name|known
init|=
literal|0
decl_stmt|;
name|struct
name|enumeration_value
modifier|*
name|e
decl_stmt|;
name|option
operator|=
name|parse_option_name
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|,
operator|&
name|known
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
return|return
literal|0
return|;
comment|/* Parse the option data... */
do|do
block|{
comment|/* Set a flag if this is an array of a simple type (i.e., 		   not an array of pairs of IP addresses, or something 		   like that. */
name|int
name|uniform
init|=
name|option
operator|->
name|format
index|[
literal|1
index|]
operator|==
literal|'A'
decl_stmt|;
for|for
control|(
name|fmt
operator|=
name|option
operator|->
name|format
init|;
operator|*
name|fmt
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'A'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'E'
case|:
name|fmt
operator|=
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"malformed %s (bug!)"
argument_list|,
literal|"encapsulation format"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
literal|'X'
case|:
name|len
operator|=
name|parse_X
argument_list|(
name|cfile
argument_list|,
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
sizeof|sizeof
name|hunkbuf
operator|-
name|hunkix
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Text string... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting string."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hunkix
operator|+
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
name|hunkbuf
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"option data buffer %s"
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nul_term
operator|=
literal|1
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|f
operator|=
name|fmt
expr_stmt|;
name|fmt
operator|=
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"malformed %s (bug!)"
argument_list|,
literal|"enumeration format"
argument_list|)
expr_stmt|;
name|foo
label|:
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"identifier expected"
argument_list|)
expr_stmt|;
goto|goto
name|foo
goto|;
block|}
name|e
operator|=
name|find_enumeration_value
argument_list|(
name|f
argument_list|,
name|fmt
operator|-
name|f
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"unknown value"
argument_list|)
expr_stmt|;
goto|goto
name|foo
goto|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
operator|&
name|e
operator|->
name|value
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'I'
case|:
comment|/* IP address. */
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip_addr
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|ip_addr
operator|.
name|len
expr_stmt|;
name|dp
operator|=
name|ip_addr
operator|.
name|iabuf
expr_stmt|;
name|alloc
label|:
if|if
condition|(
name|hunkix
operator|+
name|len
operator|>
sizeof|sizeof
name|hunkbuf
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"option data buffer %s"
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Unsigned 32-bit integer... */
case|case
literal|'l'
case|:
comment|/* Signed 32-bit integer... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|need_number
label|:
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting number."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'s'
case|:
comment|/* Signed 16-bit integer. */
case|case
literal|'S'
case|:
comment|/* Unsigned 16-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'b'
case|:
comment|/* Signed 8-bit integer. */
case|case
literal|'B'
case|:
comment|/* Unsigned 8-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|cfile
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'f'
case|:
comment|/* Boolean flag. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|bad_flag
label|:
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"on"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting boolean."
argument_list|)
expr_stmt|;
goto|goto
name|bad_flag
goto|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
default|default:
name|log_error
argument_list|(
literal|"parse_option_param: Bad format %c"
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|fmt
operator|==
literal|'A'
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bp
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|hunkix
operator|+
name|nul_term
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"no memory to store option declaration."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|data
condition|)
name|log_fatal
argument_list|(
literal|"out of memory allocating option data."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|->
name|data
argument_list|,
name|hunkbuf
argument_list|,
name|hunkix
operator|+
name|nul_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_fatal
argument_list|(
literal|"out of memory allocating option cache."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|buffer
operator|=
name|bp
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|data
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|terminated
operator|=
name|nul_term
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|len
operator|=
name|hunkix
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|option
operator|=
name|option
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Consider merging parse_cshl into this. */
end_comment

begin_function
name|int
name|parse_X
parameter_list|(
name|cfile
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|)
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
name|u_int8_t
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|max
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|u_int8_t
modifier|*
name|s
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NUMBER
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting hexadecimal constant."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|convert_num
argument_list|(
name|cfile
argument_list|,
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
name|val
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|++
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"hexadecimal constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COLON
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COLON
condition|)
do|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"string constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"expecting string or hexadecimal data"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|parse_warn
parameter_list|(
name|struct
name|parse
modifier|*
name|cfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|list
decl_stmt|;
name|char
name|lexbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|mbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|fbuf
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|lix
decl_stmt|;
name|do_percentm
argument_list|(
name|mbuf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_SNPRINTF
name|snprintf
argument_list|(
name|fbuf
argument_list|,
sizeof|sizeof
name|fbuf
argument_list|,
literal|"%s line %d: %s"
argument_list|,
name|cfile
operator|->
name|tlname
argument_list|,
name|cfile
operator|->
name|lexline
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"%s line %d: %s"
argument_list|,
name|cfile
operator|->
name|tlname
argument_list|,
name|cfile
operator|->
name|lexline
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_start
argument_list|(
name|list
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|mbuf
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|,
name|fbuf
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|lix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cfile
operator|->
name|token_line
index|[
name|i
index|]
operator|&&
name|i
operator|<
operator|(
name|cfile
operator|->
name|lexchar
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lix
operator|<
operator|(
sizeof|sizeof
name|lexbuf
operator|)
operator|-
literal|1
condition|)
name|lexbuf
index|[
name|lix
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|cfile
operator|->
name|token_line
index|[
name|i
index|]
operator|==
literal|'\t'
condition|)
block|{
for|for
control|(
name|lix
init|;
name|lix
operator|<
operator|(
sizeof|sizeof
name|lexbuf
operator|)
operator|-
literal|1
operator|&&
operator|(
name|lix
operator|&
literal|7
operator|)
condition|;
name|lix
operator|++
control|)
name|lexbuf
index|[
name|lix
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|lexbuf
index|[
name|lix
index|]
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|log_priority
operator||
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|log_priority
operator||
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|cfile
operator|->
name|token_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
operator|->
name|lexchar
operator|<
literal|81
condition|)
name|syslog
argument_list|(
name|log_priority
operator||
name|LOG_ERR
argument_list|,
literal|"%s^"
argument_list|,
name|lexbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|log_perror
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
name|mbuf
argument_list|,
name|strlen
argument_list|(
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|cfile
operator|->
name|token_line
argument_list|,
name|strlen
argument_list|(
name|cfile
operator|->
name|token_line
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
operator|->
name|lexchar
operator|<
literal|81
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|lexbuf
argument_list|,
name|lix
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"^\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|cfile
operator|->
name|warnings_occurred
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

