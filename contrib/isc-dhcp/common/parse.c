begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* parse.c     Common parser code for dhcpd and dhclient. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: parse.c,v 1.2.2.4 1999/03/29 22:18:53 mellon Exp $ Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"dhctoken.h"
end_include

begin_comment
comment|/* Skip to the semicolon ending the current statement.   If we encounter    braces, the matching closing brace terminates the statement.   If we    encounter a right brace but haven't encountered a left brace, return    leaving the brace in the token buffer for the caller.   If we see a    semicolon and haven't seen a left brace, return.   This lets us skip    over:     	statement; 	statement foo bar { } 	statement foo bar { statement { } } 	statement}   	...et cetera. */
end_comment

begin_function
name|void
name|skip_to_semi
parameter_list|(
name|cfile
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|brace_count
init|=
literal|0
decl_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
block|{
if|if
condition|(
name|brace_count
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|brace_count
condition|)
return|return;
block|}
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|LBRACE
condition|)
block|{
name|brace_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|SEMI
operator|&&
operator|!
name|brace_count
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|EOL
condition|)
block|{
comment|/* EOL only happens when parsing /etc/resolv.conf, 			   and we treat it like a semicolon because the 			   resolv.conf file is line-oriented. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|EOF
condition|)
do|;
block|}
end_function

begin_function
name|int
name|parse_semi
parameter_list|(
name|cfile
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* string-parameter :== STRING SEMI */
end_comment

begin_function
name|char
modifier|*
name|parse_string
parameter_list|(
name|cfile
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"filename must be a string"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|error
argument_list|(
literal|"no memory for string %s."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* hostname :== identifier | hostname DOT identifier */
end_comment

begin_function
name|char
modifier|*
name|parse_host_name
parameter_list|(
name|cfile
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|pair
name|c
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
comment|/* Read a dotted hostname... */
do|do
block|{
comment|/* Read a token, which should be an identifier. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
operator|&&
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting an identifier in hostname"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Store this identifier... */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"can't allocate temp space for hostname."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|c
operator|=
name|cons
argument_list|(
operator|(
name|caddr_t
operator|)
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Look for a dot; if it's there, keep going, otherwise 		   we're done. */
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DOT
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|DOT
condition|)
do|;
comment|/* Assemble the hostname together into a string. */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"can't allocate space for hostname."
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
operator|+
name|len
expr_stmt|;
operator|*
operator|--
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
condition|)
block|{
name|pair
name|cdr
init|=
name|c
operator|->
name|cdr
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|)
decl_stmt|;
name|t
operator|-=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Free up temp space. */
name|free
argument_list|(
name|c
operator|->
name|car
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|cdr
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|s
condition|)
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|parse_ip_addr
parameter_list|(
name|cfile
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|iaddr
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
operator|->
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
name|addr
operator|->
name|iabuf
argument_list|,
operator|&
name|addr
operator|->
name|len
argument_list|,
name|DOT
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* hardware-parameter :== HARDWARE ETHERNET csns SEMI    csns :== NUMBER | csns COLON NUMBER */
end_comment

begin_function
name|void
name|parse_hardware_param
parameter_list|(
name|cfile
parameter_list|,
name|hardware
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hardware
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|ETHERNET
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_ETHER
expr_stmt|;
break|break;
case|case
name|TOKEN_RING
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_IEEE802
expr_stmt|;
break|break;
case|case
name|FDDI
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_FDDI
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
literal|"expecting a network hardware type"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse the hardware address information.   Technically, 	   it would make a lot of sense to restrict the length of the 	   data we'll accept here to the length of a particular hardware 	   address type.   Unfortunately, there are some broken clients 	   out there that put bogus data in the chaddr buffer, and we accept 	   that data in the lease file rather than simply failing on such 	   clients.   Yuck. */
name|hlen
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|hlen
argument_list|,
name|COLON
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
name|hardware
operator|->
name|haddr
condition|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
literal|"hardware address too long"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hardware
operator|->
name|hlen
operator|=
name|hlen
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|hardware
operator|->
name|haddr
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|,
name|hardware
operator|->
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
name|hardware
operator|->
name|haddr
condition|)
name|memset
argument_list|(
operator|&
name|hardware
operator|->
name|haddr
index|[
name|hlen
index|]
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
name|hardware
operator|->
name|haddr
operator|)
operator|-
name|hlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* lease-time :== NUMBER SEMI */
end_comment

begin_function
name|void
name|parse_lease_time
parameter_list|(
name|cfile
parameter_list|,
name|timep
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|TIME
modifier|*
name|timep
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"Expecting numeric lease time"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|convert_num
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|timep
argument_list|,
name|val
argument_list|,
literal|10
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Unswap the number - convert_num returns stuff in NBO. */
operator|*
name|timep
operator|=
name|ntohl
argument_list|(
operator|*
name|timep
argument_list|)
expr_stmt|;
comment|/* XXX */
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* No BNF for numeric aggregates - that's defined by the caller.  What    this function does is to parse a sequence of numbers seperated by    the token specified in seperator.  If max is zero, any number of    numbers will be parsed; otherwise, exactly max numbers are    expected.  Base and size tell us how to internalize the numbers    once they've been tokenized. */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|parse_numeric_aggregate
parameter_list|(
name|cfile
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|,
name|seperator
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|max
decl_stmt|;
name|int
name|seperator
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|pair
name|c
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bufp
operator|&&
operator|*
name|max
condition|)
block|{
name|bufp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|*
name|max
operator|*
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|error
argument_list|(
literal|"can't allocate space for numeric aggregate"
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|bufp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|count
condition|)
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|seperator
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|max
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|RBRACE
operator|&&
name|token
operator|!=
name|LBRACE
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
literal|"too few numbers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allow NUMBER_OR_NAME if base is 16. */
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
operator|(
name|base
operator|!=
literal|16
operator|||
name|token
operator|!=
name|NUMBER_OR_NAME
operator|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting numeric value."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* If we can, convert the number now; otherwise, build 		   a linked list of all the numbers. */
if|if
condition|(
name|s
condition|)
block|{
name|convert_num
argument_list|(
name|s
argument_list|,
name|val
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|+=
name|size
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|error
argument_list|(
literal|"no temp space for number."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|c
operator|=
name|cons
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|count
operator|!=
operator|*
name|max
condition|)
do|;
comment|/* If we had to cons up a list, convert it now. */
if|if
condition|(
name|c
condition|)
block|{
name|bufp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|error
argument_list|(
literal|"can't allocate space for numeric aggregate."
argument_list|)
expr_stmt|;
name|s
operator|=
name|bufp
operator|+
name|count
operator|-
name|size
operator|/
literal|8
expr_stmt|;
operator|*
name|max
operator|=
name|count
expr_stmt|;
block|}
while|while
condition|(
name|c
condition|)
block|{
name|pair
name|cdr
init|=
name|c
operator|->
name|cdr
decl_stmt|;
name|convert_num
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|car
operator|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|-=
name|size
operator|/
literal|8
expr_stmt|;
comment|/* Free up temp space. */
name|free
argument_list|(
name|c
operator|->
name|car
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|cdr
expr_stmt|;
block|}
return|return
name|bufp
return|;
block|}
end_function

begin_function
name|void
name|convert_num
parameter_list|(
name|buf
parameter_list|,
name|str
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|val
init|=
literal|0
decl_stmt|;
name|int
name|tval
decl_stmt|;
name|int
name|max
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* If base wasn't specified, figure it out from the data. */
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|ptr
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
block|}
else|else
block|{
name|base
operator|=
literal|10
expr_stmt|;
block|}
block|}
do|do
block|{
name|tval
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
comment|/* XXX assumes ASCII... */
if|if
condition|(
name|tval
operator|>=
literal|'a'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'A'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'0'
condition|)
name|tval
operator|-=
literal|'0'
expr_stmt|;
else|else
block|{
name|warn
argument_list|(
literal|"Bogus number: %s."
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tval
operator|>=
name|base
condition|)
block|{
name|warn
argument_list|(
literal|"Bogus number: %s: digit %d not in base %d\n"
argument_list|,
name|str
argument_list|,
name|tval
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|val
operator|*
name|base
operator|+
name|tval
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ptr
condition|)
do|;
if|if
condition|(
name|negative
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|warn
argument_list|(
literal|"value %s%o exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|warn
argument_list|(
literal|"value %s%x exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"value %s%u exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|negative
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putShort
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putLong
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"Unexpected integer size: %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|(
name|u_int8_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putUShort
argument_list|(
name|buf
argument_list|,
operator|(
name|u_int16_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putULong
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"Unexpected integer size: %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER     		NUMBER COLON NUMBER COLON NUMBER SEMI     Dates are always in GMT; first number is day of week; next is    year/month/day; next is hours:minutes:seconds on a 24-hour    clock. */
end_comment

begin_function
name|TIME
name|parse_date
parameter_list|(
name|cfile
parameter_list|)
name|FILE
modifier|*
name|cfile
decl_stmt|;
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|guess
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
specifier|static
name|int
name|months
index|[
literal|11
index|]
init|=
block|{
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|}
decl_stmt|;
comment|/* Day of week... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric day of week expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_wday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Year... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric year expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|>
literal|1900
condition|)
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* Slash seperating year from month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected slash seperating year from month."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_mon
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Slash seperating month from day... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected slash seperating month from day."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric day of month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Hour... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric hour expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon seperating hour from minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected colon seperating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon seperating minute from second... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected colon seperating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TIME
operator|)
literal|0
return|;
block|}
name|tm
operator|.
name|tm_sec
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* We assume that mktime does not use tm_yday. */
name|tm
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the date ends in a semicolon... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Guess the time value... */
name|guess
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
literal|365
operator|*
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|70
operator|)
operator|+
comment|/* Days in years since '70 */
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|+
comment|/* Leap days since '70 */
operator|(
name|tm
operator|.
name|tm_mon
comment|/* Days in months this year */
condition|?
name|months
index|[
name|tm
operator|.
name|tm_mon
operator|-
literal|1
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|tm
operator|.
name|tm_mon
operator|>
literal|1
operator|&&
comment|/* Leap day this year */
operator|!
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|72
operator|)
operator|&
literal|3
operator|)
operator|)
operator|+
name|tm
operator|.
name|tm_mday
operator|-
literal|1
operator|)
operator|*
literal|24
operator|)
operator|+
comment|/* Day of month */
name|tm
operator|.
name|tm_hour
operator|)
operator|*
literal|60
operator|)
operator|+
name|tm
operator|.
name|tm_min
operator|)
operator|*
literal|60
operator|)
operator|+
name|tm
operator|.
name|tm_sec
expr_stmt|;
comment|/* This guess could be wrong because of leap seconds or other 	   weirdness we don't know about that the system does.   For 	   now, we're just going to accept the guess, but at some point 	   it might be nice to do a successive approximation here to 	   get an exact value.   Even if the error is small, if the 	   server is restarted frequently (and thus the lease database 	   is reread), the error could accumulate into something 	   significant. */
return|return
name|guess
return|;
block|}
end_function

end_unit

