begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* resolv.c     Parser for /etc/resolv.conf file. */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1996-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software has been written for Internet Systems Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about Internet Systems Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: resolv.c,v 1.16.2.2 2004/06/10 17:59:20 dhankins Exp $ Copyright (c) 2004 Internet Systems Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
name|struct
name|name_server
modifier|*
name|name_servers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain_search_list
modifier|*
name|domains
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|path_resolv_conf
index|[]
init|=
name|_PATH_RESOLV_CONF
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|read_resolv_conf
parameter_list|(
name|parse_time
parameter_list|)
name|TIME
name|parse_time
decl_stmt|;
block|{
name|int
name|file
decl_stmt|;
name|struct
name|parse
modifier|*
name|cfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|int
name|declaration
init|=
literal|0
decl_stmt|;
name|struct
name|name_server
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sl
decl_stmt|,
modifier|*
name|ns
decl_stmt|;
name|struct
name|domain_search_list
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dl
decl_stmt|,
modifier|*
name|nd
decl_stmt|;
name|struct
name|iaddr
modifier|*
name|iaddr
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|path_resolv_conf
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't open %s: %m"
argument_list|,
name|path_resolv_conf
argument_list|)
expr_stmt|;
return|return;
block|}
name|cfile
operator|=
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
expr_stmt|;
name|new_parse
argument_list|(
operator|&
name|cfile
argument_list|,
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|path_resolv_conf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_FILE
condition|)
break|break;
elseif|else
if|if
condition|(
name|token
operator|==
name|EOL
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|token
operator|==
name|DOMAIN
operator|||
name|token
operator|==
name|SEARCH
condition|)
block|{
do|do
block|{
name|struct
name|domain_search_list
modifier|*
name|nd
decl_stmt|,
modifier|*
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|dn
decl_stmt|;
name|dn
operator|=
name|parse_host_name
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dn
condition|)
break|break;
name|dp
operator|=
operator|&
name|domains
expr_stmt|;
for|for
control|(
name|nd
operator|=
name|domains
init|;
name|nd
condition|;
name|nd
operator|=
name|nd
operator|->
name|next
control|)
block|{
name|dp
operator|=
operator|&
name|nd
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nd
operator|->
name|domain
argument_list|,
name|dn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|nd
condition|)
block|{
name|nd
operator|=
name|new_domain_search_list
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
name|log_fatal
argument_list|(
literal|"No memory for %s"
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|nd
operator|->
name|next
operator|=
operator|(
expr|struct
name|domain_search_list
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|dp
operator|=
name|nd
expr_stmt|;
name|nd
operator|->
name|domain
operator|=
name|dn
expr_stmt|;
name|dn
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|nd
operator|->
name|rcdate
operator|=
name|parse_time
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|EOL
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|EOL
condition|)
block|{
name|parse_warn
argument_list|(
name|cfile
argument_list|,
literal|"junk after domain declaration"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|NAMESERVER
condition|)
block|{
name|struct
name|name_server
modifier|*
name|ns
decl_stmt|,
modifier|*
modifier|*
name|sp
decl_stmt|;
name|struct
name|iaddr
name|iaddr
decl_stmt|;
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|iaddr
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|name_servers
expr_stmt|;
for|for
control|(
name|ns
operator|=
name|name_servers
init|;
name|ns
condition|;
name|ns
operator|=
name|ns
operator|->
name|next
control|)
block|{
name|sp
operator|=
operator|&
name|ns
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|ns
operator|->
name|addr
operator|.
name|sin_addr
argument_list|,
name|iaddr
operator|.
name|iabuf
argument_list|,
name|iaddr
operator|.
name|len
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|ns
condition|)
block|{
name|ns
operator|=
name|new_name_server
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
name|log_fatal
argument_list|(
literal|"No memory for nameserver %s"
argument_list|,
name|piaddr
argument_list|(
name|iaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|->
name|next
operator|=
operator|(
expr|struct
name|name_server
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|sp
operator|=
name|ns
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ns
operator|->
name|addr
operator|.
name|sin_addr
argument_list|,
name|iaddr
operator|.
name|iabuf
argument_list|,
name|iaddr
operator|.
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|ns
operator|->
name|addr
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|ns
operator|->
name|addr
expr_stmt|;
endif|#
directive|endif
name|ns
operator|->
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ns
operator|->
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ns
operator|->
name|addr
operator|.
name|sin_zero
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ns
operator|->
name|addr
operator|.
name|sin_zero
argument_list|)
expr_stmt|;
block|}
name|ns
operator|->
name|rcdate
operator|=
name|parse_time
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
else|else
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
comment|/* Ignore what we don't grok. */
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
literal|0
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Lose servers that are no longer in /etc/resolv.conf. */
name|sl
operator|=
operator|(
expr|struct
name|name_server
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|name_servers
init|;
name|sp
condition|;
name|sp
operator|=
name|ns
control|)
block|{
name|ns
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rcdate
operator|!=
name|parse_time
condition|)
block|{
if|if
condition|(
name|sl
condition|)
name|sl
operator|->
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
else|else
name|name_servers
operator|=
name|sp
operator|->
name|next
expr_stmt|;
comment|/* We can't actually free the name server structure, 			   because somebody might be hanging on to it.    If 			   your /etc/resolv.conf file changes a lot, this 			   could be a noticable memory leak. */
block|}
else|else
name|sl
operator|=
name|sp
expr_stmt|;
block|}
comment|/* Lose domains that are no longer in /etc/resolv.conf. */
name|dl
operator|=
operator|(
expr|struct
name|domain_search_list
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|domains
init|;
name|dp
condition|;
name|dp
operator|=
name|nd
control|)
block|{
name|nd
operator|=
name|dp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|rcdate
operator|!=
name|parse_time
condition|)
block|{
if|if
condition|(
name|dl
condition|)
name|dl
operator|->
name|next
operator|=
name|dp
operator|->
name|next
expr_stmt|;
else|else
name|domains
operator|=
name|dp
operator|->
name|next
expr_stmt|;
name|free_domain_search_list
argument_list|(
name|dp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
name|dl
operator|=
name|dp
expr_stmt|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|end_parse
argument_list|(
operator|&
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pick a name server from the /etc/resolv.conf file. */
end_comment

begin_function
name|struct
name|name_server
modifier|*
name|first_name_server
parameter_list|()
block|{
name|FILE
modifier|*
name|rc
decl_stmt|;
specifier|static
name|TIME
name|rcdate
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* Check /etc/resolv.conf and reload it if it's changed. */
if|if
condition|(
name|cur_time
operator|>
name|rcdate
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|path_resolv_conf
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't stat %s"
argument_list|,
name|path_resolv_conf
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|name_server
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|>
name|rcdate
condition|)
block|{
name|char
name|rcbuf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|rcdate
operator|=
name|cur_time
operator|+
literal|1
expr_stmt|;
name|read_resolv_conf
argument_list|(
name|rcdate
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|name_servers
return|;
block|}
end_function

end_unit

