begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dispatch.c     Network input dispatcher... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995-2002 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: discover.c,v 1.42.2.13 2002/11/17 02:26:57 dhankins Exp $ Copyright (c) 1995-2002 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_decl_stmt
name|struct
name|interface_info
modifier|*
name|interfaces
decl_stmt|,
modifier|*
name|dummy_interfaces
decl_stmt|,
modifier|*
name|fallback_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interfaces_invalidated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet_interface_discovery
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|local_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|remote_port
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|dhcp_interface_setup_hook
function_decl|)
parameter_list|(
name|struct
name|interface_info
modifier|*
parameter_list|,
name|struct
name|iaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|dhcp_interface_discovery_hook
function_decl|)
parameter_list|(
name|struct
name|interface_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
function_decl|(
modifier|*
name|dhcp_interface_startup_hook
function_decl|)
parameter_list|(
name|struct
name|interface_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|dhcp_interface_shutdown_hook
function_decl|)
parameter_list|(
name|struct
name|interface_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|in_addr
name|limited_broadcast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|local_address
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*bootp_packet_handler
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
expr|struct
name|interface_info
operator|*
operator|,
expr|struct
name|dhcp_packet
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|iaddr
operator|,
expr|struct
name|hardware
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|omapi_object_type_t
modifier|*
name|dhcp_type_interface
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
end_if

begin_decl_stmt
name|trace_type_t
modifier|*
name|interface_trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|trace_type_t
modifier|*
name|inpacket_trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|trace_type_t
modifier|*
name|outpacket_trace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|interface_info
modifier|*
modifier|*
name|interface_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interface_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interface_max
decl_stmt|;
end_decl_stmt

begin_macro
name|OMAPI_OBJECT_ALLOC
argument_list|(
argument|interface
argument_list|,
argument|struct interface_info
argument_list|,
argument|dhcp_type_interface
argument_list|)
end_macro

begin_function
name|isc_result_t
name|interface_setup
parameter_list|()
block|{
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|omapi_object_type_register
argument_list|(
operator|&
name|dhcp_type_interface
argument_list|,
literal|"interface"
argument_list|,
name|dhcp_interface_set_value
argument_list|,
name|dhcp_interface_get_value
argument_list|,
name|dhcp_interface_destroy
argument_list|,
name|dhcp_interface_signal_handler
argument_list|,
name|dhcp_interface_stuff_values
argument_list|,
name|dhcp_interface_lookup
argument_list|,
name|dhcp_interface_create
argument_list|,
name|dhcp_interface_remove
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface_info
argument_list|)
argument_list|,
name|interface_initialize
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't register interface object type: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
end_if

begin_function
name|void
name|interface_trace_setup
parameter_list|()
block|{
name|interface_trace
operator|=
name|trace_type_register
argument_list|(
literal|"interface"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_interface_input
argument_list|,
name|trace_interface_stop
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|inpacket_trace
operator|=
name|trace_type_register
argument_list|(
literal|"inpacket"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_inpacket_input
argument_list|,
name|trace_inpacket_stop
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|outpacket_trace
operator|=
name|trace_type_register
argument_list|(
literal|"outpacket"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|trace_outpacket_input
argument_list|,
name|trace_outpacket_stop
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|interface_initialize
parameter_list|(
name|omapi_object_t
modifier|*
name|ipo
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|ipo
decl_stmt|;
name|ip
operator|->
name|rfdesc
operator|=
name|ip
operator|->
name|wfdesc
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Use the SIOCGIFCONF ioctl to get a list of all the attached interfaces.    For each interface that's of type INET and not the loopback interface,    register that interface with the network I/O software, figure out what    subnet it's on, and add it to the list of interfaces. */
end_comment

begin_function
name|void
name|discover_interfaces
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|ifconf
name|ic
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|address_count
init|=
literal|0
decl_stmt|;
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|share
decl_stmt|;
name|struct
name|sockaddr_in
name|foo
decl_stmt|;
name|int
name|ir
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|tif
decl_stmt|;
ifdef|#
directive|ifdef
name|ALIAS_NAMES_PERMUTED
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
name|isc_result_t
name|status
decl_stmt|;
specifier|static
name|int
name|setup_fallback
init|=
literal|0
decl_stmt|;
name|int
name|wifcount
init|=
literal|0
decl_stmt|;
comment|/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on. */
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log_fatal
argument_list|(
literal|"Can't create addrlist socket"
argument_list|)
expr_stmt|;
comment|/* Get the interface configuration information... */
ifdef|#
directive|ifdef
name|SIOCGIFCONF_ZERO_PROBE
comment|/* linux will only tell us how long a buffer it wants if we give it 	 * a null buffer first. So, do a dry run to figure out the length. 	 *  	 * XXX this code is duplicated from below because trying to fold 	 * the logic into the if statement and goto resulted in excesssive 	 * obfuscation. The intent is that unless you run Linux you shouldn't 	 * have to deal with this. */
name|ic
operator|.
name|ifc_len
operator|=
literal|0
expr_stmt|;
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* otherwise, we just feed it a starting size, and it'll tell us if 	 * it needs more */
name|ic
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
endif|#
directive|endif
name|gifconf_again
label|:
name|i
operator|=
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|&
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|log_fatal
argument_list|(
literal|"ioctl: SIOCGIFCONF: %m"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOCGIFCONF_ZERO_PROBE
comment|/* Workaround for SIOCGIFCONF bug on some Linux versions. */
if|if
condition|(
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|==
literal|0
operator|&&
name|ic
operator|.
name|ifc_len
operator|==
literal|0
condition|)
block|{
name|ic
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
goto|goto
name|gifconf_again
goto|;
block|}
endif|#
directive|endif
comment|/* If the SIOCGIFCONF resulted in more data than would fit in 	   a buffer, allocate a bigger buffer. */
if|if
condition|(
operator|(
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|==
name|buf
ifdef|#
directive|ifdef
name|SIOCGIFCONF_ZERO_PROBE
operator|||
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|==
literal|0
endif|#
directive|endif
operator|)
operator|&&
name|ic
operator|.
name|ifc_len
operator|>
sizeof|sizeof
name|buf
condition|)
block|{
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
name|dmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|ic
operator|.
name|ifc_len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate SIOCGIFCONF buffer."
argument_list|)
expr_stmt|;
goto|goto
name|gifconf_again
goto|;
ifdef|#
directive|ifdef
name|SIOCGIFCONF_ZERO_PROBE
block|}
elseif|else
if|if
condition|(
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|==
literal|0
condition|)
block|{
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|ic
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
goto|goto
name|gifconf_again
goto|;
endif|#
directive|endif
block|}
comment|/* If we already have a list of interfaces, and we're running as 	   a DHCP server, the interfaces were requested. */
if|if
condition|(
name|interfaces
operator|&&
operator|(
name|state
operator|==
name|DISCOVER_SERVER
operator|||
name|state
operator|==
name|DISCOVER_RELAY
operator|||
name|state
operator|==
name|DISCOVER_REQUESTED
operator|)
condition|)
name|ir
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
name|ir
operator|=
name|INTERFACE_REQUESTED
operator||
name|INTERFACE_AUTOMATIC
expr_stmt|;
else|else
name|ir
operator|=
name|INTERFACE_REQUESTED
expr_stmt|;
comment|/* Cycle through the list of interfaces looking for IP addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|.
name|ifc_len
condition|;
control|)
block|{
name|struct
name|ifreq
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ic
operator|.
name|ifc_req
operator|+
name|i
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|i
operator|+=
operator|(
sizeof|sizeof
name|ifp
operator|->
name|ifr_name
operator|)
operator|+
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|+=
sizeof|sizeof
expr|*
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIAS_NAMES_PERMUTED
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|ifp
operator|->
name|ifr_name
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SKIP_DUMMY_INTERFACES
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ifp
operator|->
name|ifr_name
argument_list|,
literal|"dummy"
argument_list|,
literal|5
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* See if this is the sort of interface we want to 		   deal with. */
name|strcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log_fatal
argument_list|(
literal|"Can't get interface flags for %s: %m"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* See if we've seen an interface that matches this one. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
condition|)
break|break;
comment|/* Skip loopback, point-to-point and down interfaces, 		   except don't skip down interfaces if we're trying to 		   get a list of configurable interfaces. */
if|if
condition|(
operator|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
operator|||
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
operator|!
name|tmp
operator|)
operator|||
operator|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|&&
name|state
operator|!=
name|DISCOVER_UNCONFIGURED
operator|)
condition|)
continue|continue;
comment|/* If there isn't already an interface by this name, 		   allocate one. */
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|tmp
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Error allocating interface %s: %s"
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
name|interface_snorf
argument_list|(
name|tmp
argument_list|,
name|ir
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|interfaces
expr_stmt|;
comment|/* XXX */
block|}
if|if
condition|(
name|dhcp_interface_discovery_hook
condition|)
call|(
modifier|*
name|dhcp_interface_discovery_hook
call|)
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* If we have the capability, extract link information 		   and record it in a linked list. */
ifdef|#
directive|ifdef
name|HAVE_AF_LINK
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|foo
init|=
operator|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|&
name|ifp
operator|->
name|ifr_addr
operator|)
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIN_LEN
argument_list|)
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
name|foo
operator|->
name|sdl_alen
expr_stmt|;
else|#
directive|else
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
comment|/* XXX!!! */
endif|#
directive|endif
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_ETHER
expr_stmt|;
comment|/* XXX */
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|LLADDR
argument_list|(
name|foo
argument_list|)
argument_list|,
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|++
expr_stmt|;
comment|/* for type. */
block|}
elseif|else
endif|#
directive|endif
comment|/* AF_LINK */
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|iaddr
name|addr
decl_stmt|;
comment|/* Get a pointer to the address... */
name|memcpy
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|ifp
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
name|ifp
operator|->
name|ifr_addr
argument_list|)
expr_stmt|;
comment|/* We don't want the loopback interface. */
if|if
condition|(
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
operator|&&
operator|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_AUTOMATIC
operator|)
operator|&&
name|state
operator|==
name|DISCOVER_SERVER
operator|)
condition|)
continue|continue;
comment|/* If this is the first real IP address we've 			   found, keep a pointer to ifreq structure in 			   which we found it. */
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|unsigned
name|len
init|=
operator|(
operator|(
sizeof|sizeof
name|ifp
operator|->
name|ifr_name
operator|)
operator|+
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|)
decl_stmt|;
else|#
directive|else
name|unsigned
name|len
init|=
sizeof|sizeof
expr|*
name|ifp
decl_stmt|;
endif|#
directive|endif
name|tif
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
condition|)
name|log_fatal
argument_list|(
literal|"no space for ifp."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tif
argument_list|,
name|ifp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ifp
operator|=
name|tif
expr_stmt|;
name|tmp
operator|->
name|primary_address
operator|=
name|foo
operator|.
name|sin_addr
expr_stmt|;
block|}
comment|/* Grab the address... */
name|addr
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|addr
operator|.
name|iabuf
argument_list|,
operator|&
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhcp_interface_setup_hook
condition|)
call|(
modifier|*
name|dhcp_interface_setup_hook
call|)
argument_list|(
name|tmp
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we allocated a buffer, free it. */
if|if
condition|(
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|!=
name|buf
condition|)
name|dfree
argument_list|(
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LINUX_SLASHPROC_DISCOVERY
argument_list|)
comment|/* On Linux, interfaces that don't have IP addresses don't 	   show up in the SIOCGIFCONF syscall.  This only matters for 	   the DHCP client, of course - the relay agent and server 	   should only care about interfaces that are configured with 	   IP addresses anyway.  	   The PROCDEV_DEVICE (/proc/net/dev) is a kernel-supplied file 	   that, when read, prints a human readable network status.   We 	   extract the names of the network devices by skipping the first 	   two lines (which are header) and then parsing off everything 	   up to the colon in each subsequent line - these lines start 	   with the interface name, then a colon, then a bunch of 	   statistics. */
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
block|{
name|FILE
modifier|*
name|proc_dev
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|skip
init|=
literal|2
decl_stmt|;
name|proc_dev
operator|=
name|fopen
argument_list|(
name|PROCDEV_DEVICE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_dev
condition|)
name|log_fatal
argument_list|(
literal|"%s: %m"
argument_list|,
name|PROCDEV_DEVICE
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|proc_dev
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* Skip the first two blocks, which are header 			   lines. */
if|if
condition|(
name|skip
condition|)
block|{
operator|--
name|skip
expr_stmt|;
continue|continue;
block|}
name|sep
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
comment|/* See if we've seen an interface that matches 			   this one. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
comment|/* If we found one, nothing more to do.. */
if|if
condition|(
name|tmp
condition|)
continue|continue;
comment|/* Otherwise, allocate one. */
name|tmp
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't allocate interface %s: %s"
argument_list|,
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|ir
expr_stmt|;
name|strncpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|tmp
operator|->
name|next
argument_list|,
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|interfaces
expr_stmt|;
if|if
condition|(
name|dhcp_interface_discovery_hook
condition|)
call|(
modifier|*
name|dhcp_interface_discovery_hook
call|)
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|proc_dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now cycle through all the interfaces we found, looking for 	   hardware addresses. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIOCGIFHWADDR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_AF_LINK
argument_list|)
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|int
name|b
decl_stmt|,
name|sk
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
condition|)
block|{
comment|/* Make up an ifreq structure. */
name|tif
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
condition|)
name|log_fatal
argument_list|(
literal|"no space to remember ifp."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tif
operator|->
name|ifr_name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ifp
operator|=
name|tif
expr_stmt|;
block|}
comment|/* Read the hardware address from this interface. */
name|ifr
operator|=
operator|*
name|tmp
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|sa
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|.
name|ifr_hwaddr
expr_stmt|;
switch|switch
condition|(
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_TUNNEL
case|case
name|ARPHRD_TUNNEL
case|:
comment|/* ignore tunnel interfaces. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_ROSE
case|case
name|ARPHRD_ROSE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_LOOPBACK
case|case
name|ARPHRD_LOOPBACK
case|:
comment|/* ignore loopback interface */
break|break;
endif|#
directive|endif
case|case
name|ARPHRD_ETHER
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|7
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|ARPHRD_ETHER
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAVE_ARPHRD_IEEE802
define|#
directive|define
name|ARPHRD_IEEE802
value|HTYPE_IEEE802
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ARPHRD_IEEE802_TR
argument_list|)
case|case
name|ARPHRD_IEEE802_TR
case|:
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|7
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|ARPHRD_IEEE802
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAVE_ARPHRD_FDDI
define|#
directive|define
name|ARPHRD_FDDI
value|HTYPE_FDDI
endif|#
directive|endif
case|case
name|ARPHRD_FDDI
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|17
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_FDDI
expr_stmt|;
comment|/* XXX */
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_METRICOM
case|case
name|ARPHRD_METRICOM
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|7
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|ARPHRD_METRICOM
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_AX25
case|case
name|ARPHRD_AX25
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|7
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|ARPHRD_AX25
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_NETROM
case|case
name|ARPHRD_NETROM
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|7
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|ARPHRD_NETROM
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|log_error
argument_list|(
literal|"%s: unknown hardware address type %d"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|,
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* defined (HAVE_SIOCGIFHWADDR)&& !defined (HAVE_AF_LINK) */
comment|/* If we're just trying to get a list of interfaces that we might 	   be able to configure, we can quit now. */
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Weed out the interfaces that did not have IP addresses. */
name|tmp
operator|=
name|last
operator|=
name|next
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|interfaces
condition|)
name|interface_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|interface_dereference
argument_list|(
operator|&
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|next
argument_list|,
name|tmp
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* skip interfaces that are running already */
if|if
condition|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_RUNNING
condition|)
block|{
name|interface_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_AUTOMATIC
operator|)
operator|&&
name|state
operator|==
name|DISCOVER_REQUESTED
condition|)
name|tmp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|INTERFACE_AUTOMATIC
operator||
name|INTERFACE_REQUESTED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
operator|||
operator|!
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_REQUESTED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_REQUESTED
operator|)
operator|!=
name|ir
condition|)
name|log_fatal
argument_list|(
literal|"%s: not found"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
block|{
if|if
condition|(
name|interfaces
condition|)
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_dereference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|->
name|next
condition|)
name|interface_dereference
argument_list|(
operator|&
name|tmp
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Remember the interface in case we need to know 			   about it later. */
if|if
condition|(
name|dummy_interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|tmp
operator|->
name|next
argument_list|,
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
name|tmp
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|tmp
operator|->
name|ifp
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
name|tmp
operator|->
name|ifp
operator|->
name|ifr_addr
argument_list|)
expr_stmt|;
comment|/* We must have a subnet declaration for each interface. */
if|if
condition|(
operator|!
name|tmp
operator|->
name|shared_network
operator|&&
operator|(
name|state
operator|==
name|DISCOVER_SERVER
operator|)
condition|)
block|{
name|log_error
argument_list|(
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"No subnet declaration for %s (%s)."
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|foo
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|supports_multiple_interfaces
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"** Ignoring requests on %s.  %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
literal|"If this is not what"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"   you want, please write %s"
argument_list|,
literal|"a subnet declaration"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"   in your dhcpd.conf file %s"
argument_list|,
literal|"for the network segment"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"   to %s %s %s"
argument_list|,
literal|"which interface"
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
literal|"is attached. **"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"You must write a subnet %s"
argument_list|,
literal|" declaration for this"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"subnet.   You cannot prevent %s"
argument_list|,
literal|"the DHCP server"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
literal|"from listening on this subnet %s"
argument_list|,
literal|"because your"
argument_list|)
expr_stmt|;
name|log_fatal
argument_list|(
literal|"operating system does not %s."
argument_list|,
literal|"support this capability"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find subnets that don't have valid interface 		   addresses... */
for|for
control|(
name|subnet
operator|=
operator|(
name|tmp
operator|->
name|shared_network
condition|?
name|tmp
operator|->
name|shared_network
operator|->
name|subnets
else|:
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
operator|)
init|;
name|subnet
condition|;
name|subnet
operator|=
name|subnet
operator|->
name|next_sibling
control|)
block|{
if|if
condition|(
operator|!
name|subnet
operator|->
name|interface_address
operator|.
name|len
condition|)
block|{
comment|/* Set the interface address for this subnet 				   to the first address we found. */
name|subnet
operator|->
name|interface_address
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|subnet
operator|->
name|interface_address
operator|.
name|iabuf
argument_list|,
operator|&
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flag the index as not having been set, so that the 		   interface registerer can set it or not as it chooses. */
name|tmp
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Register the interface... */
name|if_register_receive
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|if_register_send
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|interface_stash
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|wifcount
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|tmp
operator|->
name|rfdesc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on %s: %m"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|rfdesc
operator|!=
name|tmp
operator|->
name|wfdesc
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|tmp
operator|->
name|wfdesc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on %s: %m"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|next
label|:
name|interface_dereference
argument_list|(
operator|&
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|tmp
argument_list|,
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* Now register all the remaining interfaces as protocols. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
comment|/* not if it's been registered before */
if|if
condition|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_RUNNING
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|rfdesc
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|status
operator|=
name|omapi_register_io_object
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
name|tmp
argument_list|,
name|if_readsocket
argument_list|,
literal|0
argument_list|,
name|got_one
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't register I/O handle for %s: %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|DISCOVER_SERVER
operator|&&
name|wifcount
operator|==
literal|0
condition|)
block|{
name|log_info
argument_list|(
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|log_fatal
argument_list|(
literal|"Not configured to listen on any interfaces!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|setup_fallback
condition|)
block|{
name|setup_fallback
operator|=
literal|1
expr_stmt|;
name|maybe_setup_fallback
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETFD
argument_list|)
if|if
condition|(
name|fallback_interface
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fallback_interface
operator|->
name|rfdesc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on fallback: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallback_interface
operator|->
name|rfdesc
operator|!=
name|fallback_interface
operator|->
name|wfdesc
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fallback_interface
operator|->
name|wfdesc
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"Can't set close-on-exec on fallback: %m"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|if_readsocket
parameter_list|(
name|h
parameter_list|)
name|omapi_object_t
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
operator|-
literal|1
return|;
name|ip
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
return|return
name|ip
operator|->
name|rfdesc
return|;
block|}
end_function

begin_function
name|int
name|setup_fallback
parameter_list|(
name|struct
name|interface_info
modifier|*
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|isc_result_t
name|status
decl_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|fallback_interface
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Error allocating fallback interface: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fallback_interface
operator|->
name|name
argument_list|,
literal|"fallback"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhcp_interface_setup_hook
condition|)
call|(
modifier|*
name|dhcp_interface_setup_hook
call|)
argument_list|(
name|fallback_interface
argument_list|,
operator|(
expr|struct
name|iaddr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|interface_reference
argument_list|(
name|fp
argument_list|,
name|fallback_interface
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fallback_interface
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|interface_stash
argument_list|(
name|fallback_interface
argument_list|)
expr_stmt|;
return|return
name|status
operator|==
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|reinitialize_interfaces
parameter_list|()
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|if_reinitialize_receive
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|if_reinitialize_send
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fallback_interface
condition|)
name|if_reinitialize_send
argument_list|(
name|fallback_interface
argument_list|)
expr_stmt|;
name|interfaces_invalidated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|got_one
parameter_list|(
name|h
parameter_list|)
name|omapi_object_t
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|hardware
name|hfrom
decl_stmt|;
name|struct
name|iaddr
name|ifrom
decl_stmt|;
name|int
name|result
decl_stmt|;
union|union
block|{
name|unsigned
name|char
name|packbuf
index|[
literal|4095
index|]
decl_stmt|;
comment|/* Packet input buffer. 					 	 Must be as large as largest 						 possible MTU. */
name|struct
name|dhcp_packet
name|packet
decl_stmt|;
block|}
name|u
union|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|ip
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|result
operator|=
name|receive_packet
argument_list|(
name|ip
argument_list|,
name|u
operator|.
name|packbuf
argument_list|,
sizeof|sizeof
name|u
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|hfrom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"receive_packet failed on %s: %m"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ISC_R_UNEXPECTED
return|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
name|ISC_R_UNEXPECTED
return|;
comment|/* If we didn't at least get the fixed portion of the BOOTP 	   packet, drop the packet.  We're allowing packets with no 	   sname or filename, because we're aware of at least one 	   client that sends such packets, but this definitely falls 	   into the category of being forgiving. */
if|if
condition|(
name|result
operator|<
name|DHCP_FIXED_NON_UDP
operator|-
name|DHCP_SNAME_LEN
operator|-
name|DHCP_FILE_LEN
condition|)
return|return
name|ISC_R_UNEXPECTED
return|;
if|if
condition|(
name|bootp_packet_handler
condition|)
block|{
name|ifrom
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|ifrom
operator|.
name|iabuf
argument_list|,
operator|&
name|from
operator|.
name|sin_addr
argument_list|,
name|ifrom
operator|.
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bootp_packet_handler
call|)
argument_list|(
name|ip
argument_list|,
operator|&
name|u
operator|.
name|packet
argument_list|,
operator|(
name|unsigned
operator|)
name|result
argument_list|,
name|from
operator|.
name|sin_port
argument_list|,
name|ifrom
argument_list|,
operator|&
name|hfrom
argument_list|)
expr_stmt|;
block|}
comment|/* If there is buffered data, read again.    This is for, e.g., 	   bpf, which may return two packets at once. */
if|if
condition|(
name|ip
operator|->
name|rbuf_offset
operator|!=
name|ip
operator|->
name|rbuf_len
condition|)
goto|goto
name|again
goto|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_set_value
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_data_string_t
modifier|*
name|name
parameter_list|,
name|omapi_typed_data_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|int
name|foo
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|interface
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|omapi_ds_strcmp
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|->
name|type
operator|==
name|omapi_datatype_data
operator|||
name|value
operator|->
name|type
operator|==
name|omapi_datatype_string
operator|)
operator|&&
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|<
sizeof|sizeof
name|interface
operator|->
name|name
condition|)
block|{
name|memcpy
argument_list|(
name|interface
operator|->
name|name
argument_list|,
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
argument_list|)
expr_stmt|;
name|interface
operator|->
name|name
index|[
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
name|ISC_R_INVALIDARG
return|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
comment|/* Try to find some inner object that can take the value. */
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|set_value
condition|)
block|{
name|status
operator|=
operator|(
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|set_value
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|id
operator|,
name|name
operator|,
name|value
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
operator|||
name|status
operator|==
name|ISC_R_UNCHANGED
condition|)
return|return
name|status
return|;
block|}
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_get_value
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_data_string_t
modifier|*
name|name
parameter_list|,
name|omapi_value_t
modifier|*
modifier|*
name|value
parameter_list|)
block|{
return|return
name|ISC_R_NOTIMPLEMENTED
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_destroy
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|interface
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|ifp
condition|)
block|{
name|dfree
argument_list|(
name|interface
operator|->
name|ifp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|interface
operator|->
name|ifp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|interface
operator|->
name|next
condition|)
name|interface_dereference
argument_list|(
operator|&
name|interface
operator|->
name|next
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|rbuf
condition|)
block|{
name|dfree
argument_list|(
name|interface
operator|->
name|rbuf
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|interface
operator|->
name|rbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|interface
operator|->
name|client
condition|)
name|interface
operator|->
name|client
operator|=
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|interface
operator|->
name|shared_network
condition|)
name|omapi_object_dereference
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|*
operator|)
operator|&
name|interface
operator|->
name|shared_network
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_signal_handler
parameter_list|(
name|omapi_object_t
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|,
modifier|*
name|interface
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|interface
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
comment|/* If it's an update signal, see if the interface is dead right 	   now, or isn't known at all, and if that's the case, revive it. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"update"
argument_list|)
condition|)
block|{
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
if|if
condition|(
name|ip
operator|==
name|interface
condition|)
break|break;
if|if
condition|(
name|ip
operator|&&
name|dhcp_interface_startup_hook
condition|)
return|return
call|(
modifier|*
name|dhcp_interface_startup_hook
call|)
argument_list|(
name|ip
argument_list|)
return|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
if|if
condition|(
name|ip
operator|==
name|interface
condition|)
break|break;
if|if
condition|(
operator|!
name|ip
operator|&&
name|dhcp_interface_startup_hook
condition|)
return|return
call|(
modifier|*
name|dhcp_interface_startup_hook
call|)
argument_list|(
name|ip
argument_list|)
return|;
block|}
comment|/* Try to find some inner object that can take the value. */
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|get_value
condition|)
block|{
name|status
operator|=
operator|(
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|signal_handler
operator|)
operator|)
operator|(
name|h
operator|->
name|inner
operator|,
name|name
operator|,
name|ap
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|ISC_R_NOTFOUND
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_stuff_values
parameter_list|(
name|omapi_object_t
modifier|*
name|c
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_object_t
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
return|return
name|ISC_R_INVALIDARG
return|;
name|interface
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Write out all the values. */
name|status
operator|=
name|omapi_connection_put_name
argument_list|(
name|c
argument_list|,
literal|"state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
if|if
condition|(
name|interface
operator|->
name|flags
operator|&&
name|INTERFACE_REQUESTED
condition|)
name|status
operator|=
name|omapi_connection_put_string
argument_list|(
name|c
argument_list|,
literal|"up"
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|omapi_connection_put_string
argument_list|(
name|c
argument_list|,
literal|"down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Write out the inner object, if any. */
if|if
condition|(
name|h
operator|->
name|inner
operator|&&
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|stuff_values
condition|)
block|{
name|status
operator|=
operator|(
operator|(
operator|*
operator|(
name|h
operator|->
name|inner
operator|->
name|type
operator|->
name|stuff_values
operator|)
operator|)
operator|(
name|c
operator|,
name|id
operator|,
name|h
operator|->
name|inner
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
block|}
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_lookup
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|ip
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|,
name|omapi_object_t
modifier|*
name|ref
parameter_list|)
block|{
name|omapi_value_t
modifier|*
name|tv
init|=
operator|(
name|omapi_value_t
operator|*
operator|)
literal|0
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|ISC_R_NOKEYS
return|;
comment|/* First see if we were sent a handle. */
name|status
operator|=
name|omapi_get_value_str
argument_list|(
name|ref
argument_list|,
name|id
argument_list|,
literal|"handle"
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|status
operator|=
name|omapi_handle_td_lookup
argument_list|(
name|ip
argument_list|,
name|tv
operator|->
name|value
argument_list|)
expr_stmt|;
name|omapi_value_dereference
argument_list|(
operator|&
name|tv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
comment|/* Don't return the object if the type is wrong. */
if|if
condition|(
operator|(
operator|*
name|ip
operator|)
operator|->
name|type
operator|!=
name|dhcp_type_interface
condition|)
block|{
name|omapi_object_dereference
argument_list|(
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_INVALIDARG
return|;
block|}
block|}
comment|/* Now look for an interface name. */
name|status
operator|=
name|omapi_get_value_str
argument_list|(
name|ref
argument_list|,
name|id
argument_list|,
literal|"name"
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
for|for
control|(
name|interface
operator|=
name|interfaces
init|;
name|interface
condition|;
name|interface
operator|=
name|interface
operator|->
name|next
control|)
block|{
name|s
operator|=
name|memchr
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|len
operator|=
name|s
operator|-
operator|&
name|interface
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
else|else
name|len
operator|=
name|IFNAMSIZ
expr_stmt|;
if|if
condition|(
operator|(
name|tv
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|interface
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tv
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
name|len
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|interface
condition|)
block|{
for|for
control|(
name|interface
operator|=
name|dummy_interfaces
init|;
name|interface
condition|;
name|interface
operator|=
name|interface
operator|->
name|next
control|)
block|{
name|s
operator|=
name|memchr
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|len
operator|=
name|s
operator|-
operator|&
name|interface
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
else|else
name|len
operator|=
name|IFNAMSIZ
expr_stmt|;
if|if
condition|(
operator|(
name|tv
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|len
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|interface
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tv
operator|->
name|value
operator|->
name|u
operator|.
name|buffer
operator|.
name|value
argument_list|,
name|len
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
name|omapi_value_dereference
argument_list|(
operator|&
name|tv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|&&
operator|*
name|ip
operator|!=
operator|(
name|omapi_object_t
operator|*
operator|)
name|interface
condition|)
block|{
name|omapi_object_dereference
argument_list|(
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_KEYCONFLICT
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|interface
condition|)
block|{
if|if
condition|(
operator|*
name|ip
condition|)
name|omapi_object_dereference
argument_list|(
name|ip
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|ISC_R_NOTFOUND
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|ip
condition|)
name|omapi_object_reference
argument_list|(
name|ip
argument_list|,
operator|(
name|omapi_object_t
operator|*
operator|)
name|interface
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* If we get to here without finding an interface, no valid key was 	   specified. */
if|if
condition|(
operator|!
operator|*
name|ip
condition|)
return|return
name|ISC_R_NOKEYS
return|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* actually just go discover the interface */
end_comment

begin_function
name|isc_result_t
name|dhcp_interface_create
parameter_list|(
name|omapi_object_t
modifier|*
modifier|*
name|lp
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|hp
decl_stmt|;
name|isc_result_t
name|status
decl_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|interface_allocate
argument_list|(
operator|&
name|hp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|status
return|;
name|hp
operator|->
name|flags
operator|=
name|INTERFACE_REQUESTED
expr_stmt|;
name|status
operator|=
name|interface_reference
argument_list|(
operator|(
expr|struct
name|interface_info
operator|*
operator|*
operator|)
name|lp
argument_list|,
name|hp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|hp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dhcp_interface_remove
parameter_list|(
name|omapi_object_t
modifier|*
name|lp
parameter_list|,
name|omapi_object_t
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|,
modifier|*
name|ip
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|interface
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|lp
expr_stmt|;
comment|/* remove from interfaces */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ip
operator|==
name|interface
condition|)
block|{
if|if
condition|(
name|last
condition|)
block|{
name|interface_dereference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|last
operator|->
name|next
argument_list|,
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|next
condition|)
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|next
condition|)
name|interface_dereference
argument_list|(
operator|&
name|ip
operator|->
name|next
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|ip
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip
condition|)
return|return
name|ISC_R_NOTFOUND
return|;
comment|/* add the interface to the dummy_interface list */
if|if
condition|(
name|dummy_interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|interface
operator|->
name|next
argument_list|,
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|dummy_interfaces
argument_list|,
name|interface
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* do a DHCPRELEASE */
if|if
condition|(
name|dhcp_interface_shutdown_hook
condition|)
call|(
modifier|*
name|dhcp_interface_shutdown_hook
call|)
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* remove the io object */
name|omapi_unregister_io_object
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
name|interface
argument_list|)
expr_stmt|;
name|if_deregister_send
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|if_deregister_receive
argument_list|(
name|interface
argument_list|)
expr_stmt|;
return|return
name|ISC_R_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|interface_stash
parameter_list|(
name|struct
name|interface_info
modifier|*
name|tptr
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
name|delta
decl_stmt|;
comment|/* If the registerer didn't assign an index, assign one now. */
if|if
condition|(
name|tptr
operator|->
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|tptr
operator|->
name|index
operator|=
name|interface_count
operator|++
expr_stmt|;
while|while
condition|(
name|tptr
operator|->
name|index
operator|<
name|interface_max
operator|&&
name|interface_vector
index|[
name|tptr
operator|->
name|index
index|]
condition|)
name|tptr
operator|->
name|index
operator|=
name|interface_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|interface_max
operator|<=
name|tptr
operator|->
name|index
condition|)
block|{
name|delta
operator|=
name|tptr
operator|->
name|index
operator|-
name|interface_max
operator|+
literal|10
expr_stmt|;
name|vec
operator|=
name|dmalloc
argument_list|(
operator|(
name|interface_max
operator|+
name|delta
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|interface_info
operator|*
argument_list|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|vec
index|[
name|interface_max
index|]
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|interface_info
operator|*
argument_list|)
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|interface_max
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|interface_vector
condition|)
block|{
name|memcpy
argument_list|(
name|vec
argument_list|,
name|interface_vector
argument_list|,
operator|(
name|interface_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|interface_info
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|interface_vector
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_vector
operator|=
name|vec
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|interface_vector
index|[
name|tptr
operator|->
name|index
index|]
argument_list|,
name|tptr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tptr
operator|->
name|index
operator|>=
name|interface_count
condition|)
name|interface_count
operator|=
name|tptr
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
name|trace_interface_register
argument_list|(
name|interface_trace
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|interface_snorf
parameter_list|(
name|struct
name|interface_info
modifier|*
name|tmp
parameter_list|,
name|int
name|ir
parameter_list|)
block|{
name|tmp
operator|->
name|circuit_id
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|tmp
operator|->
name|name
expr_stmt|;
name|tmp
operator|->
name|circuit_id_len
operator|=
name|strlen
argument_list|(
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|remote_id
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|remote_id_len
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|ir
expr_stmt|;
if|if
condition|(
name|interfaces
condition|)
block|{
name|interface_reference
argument_list|(
operator|&
name|tmp
operator|->
name|next
argument_list|,
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|interface_reference
argument_list|(
operator|&
name|interfaces
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

