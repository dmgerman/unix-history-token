begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tree.c     Routines for manipulating parse trees... */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1995-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software has been written for Internet Systems Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about Internet Systems Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: tree.c,v 1.101.2.9 2004/06/17 20:54:39 dhankins Exp $ Copyright (c) 2004 Internet Systems Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_decl_stmt
name|struct
name|binding_scope
modifier|*
name|global_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_host_lookup
name|PROTO
argument_list|(
operator|(
expr|struct
name|data_string
operator|*
operator|,
expr|struct
name|dns_host_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NSUPDATE
end_ifdef

begin_decl_stmt
name|struct
name|__res_state
name|resolver_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resolver_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|pair
name|cons
parameter_list|(
name|car
parameter_list|,
name|cdr
parameter_list|)
name|caddr_t
name|car
decl_stmt|;
name|pair
name|cdr
decl_stmt|;
block|{
name|pair
name|foo
init|=
operator|(
name|pair
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|foo
argument_list|,
name|MDL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foo
condition|)
name|log_fatal
argument_list|(
literal|"no memory for cons."
argument_list|)
expr_stmt|;
name|foo
operator|->
name|car
operator|=
name|car
expr_stmt|;
name|foo
operator|->
name|cdr
operator|=
name|cdr
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_function
name|int
name|make_const_option_cache
parameter_list|(
name|oc
parameter_list|,
name|buffer
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|,
name|option
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|option_cache
modifier|*
modifier|*
name|oc
decl_stmt|;
name|struct
name|buffer
modifier|*
modifier|*
name|buffer
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|bp
operator|=
operator|*
name|buffer
expr_stmt|;
operator|*
name|buffer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): can't allocate buffer."
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
name|oc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): can't allocate option cache."
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|buffer
operator|=
name|bp
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|data
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
operator|.
name|terminated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|memcpy
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|option
operator|=
name|option
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_host_lookup
parameter_list|(
name|expr
parameter_list|,
name|name
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for host lookup tree node."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_host_lookup
expr_stmt|;
if|if
condition|(
operator|!
name|enter_dns_host
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|host_lookup
operator|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|enter_dns_host
parameter_list|(
name|dh
parameter_list|,
name|name
parameter_list|)
name|struct
name|dns_host_entry
modifier|*
modifier|*
name|dh
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* XXX This should really keep a hash table of hostnames 	   XXX and just add a new reference to a hostname that 	   XXX already exists, if possible, rather than creating 	   XXX a new structure. */
if|if
condition|(
operator|!
name|dns_host_entry_allocate
argument_list|(
name|dh
argument_list|,
name|name
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't allocate space for new host."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_const_data
parameter_list|(
name|struct
name|expression
modifier|*
modifier|*
name|expr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|int
name|terminated
parameter_list|,
name|int
name|allocate
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|expression
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for make_const_data tree node."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nt
operator|=
operator|*
name|expr
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|allocate
condition|)
block|{
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|buffer
argument_list|,
name|len
operator|+
name|terminated
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't allocate const_data buffer"
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|data
operator|=
operator|&
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|buffer
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|len
operator|+
name|terminated
argument_list|)
expr_stmt|;
block|}
else|else
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|terminated
operator|=
name|terminated
expr_stmt|;
block|}
else|else
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|nt
operator|->
name|op
operator|=
name|expr_const_data
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|const_data
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_const_int
parameter_list|(
name|expr
parameter_list|,
name|val
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for make_const_int tree node."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_const_int
expr_stmt|;
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|const_int
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_concat
parameter_list|(
name|expr
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|expression
modifier|*
name|left
decl_stmt|,
decl|*
name|right
decl_stmt|;
end_function

begin_block
block|{
comment|/* If we're concatenating a null tree to a non-null tree, just 	   return the non-null tree; if both trees are null, return 	   a null tree. */
if|if
condition|(
operator|!
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|right
condition|)
return|return
literal|0
return|;
name|expression_reference
argument_list|(
name|expr
argument_list|,
name|right
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|right
condition|)
block|{
name|expression_reference
argument_list|(
name|expr
argument_list|,
name|left
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Otherwise, allocate a new node to concatenate the two. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for concatenation expression node."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_concat
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|,
name|left
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|,
name|right
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_function
name|int
name|make_encapsulation
parameter_list|(
name|expr
parameter_list|,
name|name
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|expr
decl_stmt|;
name|struct
name|data_string
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Allocate a new node to store the encapsulation. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for encapsulation expression node."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|expr
operator|)
operator|->
name|op
operator|=
name|expr_encapsulate
expr_stmt|;
name|data_string_copy
argument_list|(
operator|&
operator|(
operator|*
name|expr
operator|)
operator|->
name|data
operator|.
name|encapsulate
argument_list|,
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_substring
parameter_list|(
name|new
parameter_list|,
name|expr
parameter_list|,
name|offset
parameter_list|,
name|length
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|new
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|expression
modifier|*
name|offset
decl_stmt|;
name|struct
name|expression
modifier|*
name|length
decl_stmt|;
block|{
comment|/* Allocate an expression node to compute the substring. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|new
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for substring expression."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|new
operator|)
operator|->
name|op
operator|=
name|expr_substring
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|,
name|offset
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|,
name|length
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_limit
parameter_list|(
name|new
parameter_list|,
name|expr
parameter_list|,
name|limit
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|new
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|int
name|limit
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|rv
decl_stmt|;
comment|/* Allocate a node to enforce a limit on evaluation. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
name|new
argument_list|,
name|MDL
argument_list|)
condition|)
name|log_error
argument_list|(
literal|"no memory for limit expression"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|new
operator|)
operator|->
name|op
operator|=
name|expr_substring
expr_stmt|;
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Offset is a constant 0. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for limit offset expression"
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|new
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
operator|->
name|op
operator|=
name|expr_const_int
expr_stmt|;
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
operator|->
name|data
operator|.
name|const_int
operator|=
literal|0
expr_stmt|;
comment|/* Length is a constant: the specified limit. */
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for limit length expression"
argument_list|)
expr_stmt|;
name|expression_dereference
argument_list|(
name|new
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|len
operator|->
name|op
operator|=
name|expr_const_int
expr_stmt|;
operator|(
operator|*
name|new
operator|)
operator|->
name|data
operator|.
name|substring
operator|.
name|len
operator|->
name|data
operator|.
name|const_int
operator|=
name|limit
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|option_cache
parameter_list|(
name|struct
name|option_cache
modifier|*
modifier|*
name|oc
parameter_list|,
name|struct
name|data_string
modifier|*
name|dp
parameter_list|,
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|struct
name|option
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
name|oc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dp
condition|)
name|data_string_copy
argument_list|(
operator|&
operator|(
operator|*
name|oc
operator|)
operator|->
name|data
argument_list|,
name|dp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
name|expression_reference
argument_list|(
operator|&
operator|(
operator|*
name|oc
operator|)
operator|->
name|expression
argument_list|,
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
operator|*
name|oc
operator|)
operator|->
name|option
operator|=
name|option
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|make_let
parameter_list|(
name|result
parameter_list|,
name|name
parameter_list|)
name|struct
name|executable_statement
modifier|*
modifier|*
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|executable_statement_allocate
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|result
operator|)
operator|->
name|op
operator|=
name|let_statement
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|let
operator|.
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|let
operator|.
name|name
condition|)
block|{
name|executable_statement_dereference
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|strcpy
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|data
operator|.
name|let
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_host_lookup
parameter_list|(
name|result
parameter_list|,
name|dns
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|dns_host_entry
modifier|*
name|dns
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|new_len
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"time: now = %d  dns = %d  diff = %d"
argument_list|,
name|cur_time
argument_list|,
name|dns
operator|->
name|timeout
argument_list|,
name|cur_time
operator|-
name|dns
operator|->
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the record hasn't timed out, just copy the data and return. */
if|if
condition|(
name|cur_time
operator|<=
name|dns
operator|->
name|timeout
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"easy copy: %d %s"
argument_list|,
name|dns
operator|->
name|data
operator|.
name|len
argument_list|,
operator|(
name|dns
operator|->
name|data
operator|.
name|len
operator|>
literal|4
condition|?
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|dns
operator|->
name|data
operator|.
name|data
operator|)
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|dns
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"Looking up %s"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Otherwise, look it up... */
name|h
operator|=
name|gethostbyname
argument_list|(
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_H_ERRNO
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
endif|#
directive|endif
name|log_error
argument_list|(
literal|"%s: host unknown."
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_H_ERRNO
break|break;
case|case
name|TRY_AGAIN
case|:
name|log_error
argument_list|(
literal|"%s: temporary name server failure"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|log_error
argument_list|(
literal|"%s: name server failed"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
name|log_error
argument_list|(
literal|"%s: no A record associated with address"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_H_ERRNO */
comment|/* Okay to try again after a minute. */
name|dns
operator|->
name|timeout
operator|=
name|cur_time
operator|+
literal|60
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|dns
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"Lookup succeeded; first address is %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of addresses we got... */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|h
operator|->
name|h_addr_list
index|[
name|count
index|]
condition|;
name|count
operator|++
control|)
empty_stmt|;
comment|/* Dereference the old data, if any. */
name|data_string_forget
argument_list|(
operator|&
name|dns
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Do we need to allocate more memory? */
name|new_len
operator|=
name|count
operator|*
name|h
operator|->
name|h_length
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|dns
operator|->
name|data
operator|.
name|buffer
argument_list|,
name|new_len
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for %s."
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dns
operator|->
name|data
operator|.
name|data
operator|=
operator|&
name|dns
operator|->
name|data
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|dns
operator|->
name|data
operator|.
name|len
operator|=
name|new_len
expr_stmt|;
name|dns
operator|->
name|data
operator|.
name|terminated
operator|=
literal|0
expr_stmt|;
comment|/* Addresses are conveniently stored one to the buffer, so we 	   have to copy them out one at a time... :'( */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|dns
operator|->
name|data
operator|.
name|buffer
operator|->
name|data
index|[
name|h
operator|->
name|h_length
operator|*
name|i
index|]
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|h
operator|->
name|h_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"dns -> data: %x  h -> h_addr_list [0]: %x"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|dns
operator|->
name|buffer
operator|)
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX Set the timeout for an hour from now. 	   XXX This should really use the time on the DNS reply. */
name|dns
operator|->
name|timeout
operator|=
name|cur_time
operator|+
literal|3600
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|log_debug
argument_list|(
literal|"hard copy: %d %s"
argument_list|,
name|dns
operator|->
name|data
operator|.
name|len
argument_list|,
operator|(
name|dns
operator|->
name|data
operator|.
name|len
operator|>
literal|4
condition|?
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|dns
operator|->
name|data
operator|.
name|data
operator|)
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|dns
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|evaluate_expression
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|binding_value
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|binding_value
modifier|*
name|bv
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|expr_variable_reference
condition|)
block|{
if|if
condition|(
operator|!
name|scope
operator|||
operator|!
operator|*
name|scope
condition|)
return|return
literal|0
return|;
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|result
condition|)
name|binding_value_reference
argument_list|(
name|result
argument_list|,
name|binding
operator|->
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|expr_funcall
condition|)
block|{
name|struct
name|string_list
modifier|*
name|s
decl_stmt|;
name|struct
name|expression
modifier|*
name|arg
decl_stmt|;
name|struct
name|binding_scope
modifier|*
name|ns
decl_stmt|;
name|struct
name|binding
modifier|*
name|nb
decl_stmt|;
if|if
condition|(
operator|!
name|scope
operator|||
operator|!
operator|*
name|scope
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: no such function."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
operator|||
operator|!
name|binding
operator|->
name|value
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: no such function."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|type
operator|!=
name|binding_function
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: not a function."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Create a new binding scope in which to define 		   the arguments to the function. */
name|ns
operator|=
operator|(
expr|struct
name|binding_scope
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|binding_scope_allocate
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: can't allocate argument scope."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|arg
operator|=
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|arglist
expr_stmt|;
name|s
operator|=
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|fundef
operator|->
name|args
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
name|s
condition|)
block|{
name|nb
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nb
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nb
condition|)
block|{
name|blb
label|:
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|memset
argument_list|(
name|nb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nb
argument_list|)
expr_stmt|;
name|nb
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|->
name|name
condition|)
name|strcpy
argument_list|(
name|nb
operator|->
name|name
argument_list|,
name|s
operator|->
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|dfree
argument_list|(
name|nb
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|nb
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
expr_stmt|;
goto|goto
name|blb
goto|;
block|}
block|}
name|evaluate_expression
argument_list|(
operator|&
name|nb
operator|->
name|value
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|arg
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|nb
operator|->
name|next
operator|=
name|ns
operator|->
name|bindings
expr_stmt|;
name|ns
operator|->
name|bindings
operator|=
name|nb
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|data
operator|.
name|arg
operator|.
name|next
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|arg
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: too many arguments."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: too few arguments."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
name|binding_scope_reference
argument_list|(
operator|&
name|ns
operator|->
name|outer
argument_list|,
operator|*
name|scope
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|execute_statements
argument_list|(
operator|&
name|bv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
operator|&
name|ns
argument_list|,
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|fundef
operator|->
name|statements
argument_list|)
operator|)
expr_stmt|;
name|binding_scope_dereference
argument_list|(
operator|&
name|ns
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bv
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|is_boolean_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|binding_value_allocate
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|bv
operator|->
name|type
operator|=
name|binding_boolean
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bv
operator|->
name|value
operator|.
name|boolean
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_numeric_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|binding_value_allocate
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|bv
operator|->
name|type
operator|=
name|binding_numeric
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_numeric_expression
argument_list|(
operator|&
name|bv
operator|->
name|value
operator|.
name|intval
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_data_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|binding_value_allocate
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|bv
operator|->
name|type
operator|=
name|binding_data
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|bv
operator|->
name|value
operator|.
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_dns_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
if|if
condition|(
operator|!
name|binding_value_allocate
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|bv
operator|->
name|type
operator|=
name|binding_dns
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_dns_expression
argument_list|(
operator|&
name|bv
operator|->
name|value
operator|.
name|dns
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"%s: invalid expression type: %d"
argument_list|,
literal|"evaluate_expression"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|result
operator|&&
name|status
condition|)
name|binding_value_reference
argument_list|(
name|result
argument_list|,
name|bv
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|binding_value_dereference
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|binding_value_dereference
parameter_list|(
name|struct
name|binding_value
modifier|*
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|binding_value
modifier|*
name|bv
init|=
operator|*
name|v
decl_stmt|;
operator|*
name|v
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Decrement the reference count.   If it's nonzero, we're 	   done. */
operator|--
operator|(
name|bv
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|v
argument_list|,
name|bv
argument_list|,
name|bv
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|bv
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bv
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
name|bv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|bv
operator|->
name|type
condition|)
block|{
case|case
name|binding_boolean
case|:
case|case
name|binding_numeric
case|:
break|break;
case|case
name|binding_data
case|:
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|data
operator|.
name|buffer
condition|)
name|data_string_forget
argument_list|(
operator|&
name|bv
operator|->
name|value
operator|.
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|binding_dns
case|:
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|dns
condition|)
block|{
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|dns
operator|->
name|r_data
condition|)
block|{
name|dfree
argument_list|(
name|bv
operator|->
name|value
operator|.
name|dns
operator|->
name|r_data_ephem
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|bv
operator|->
name|value
operator|.
name|dns
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|bv
operator|->
name|value
operator|.
name|dns
operator|->
name|r_data_ephem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|minires_freeupdrec
argument_list|(
name|bv
operator|->
name|value
operator|.
name|dns
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|log_error
argument_list|(
literal|"%s(%d): invalid binding type: %d"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|bv
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dfree
argument_list|(
name|bv
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
end_if

begin_function
name|int
name|evaluate_dns_expression
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|)
name|ns_updrec
modifier|*
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
name|ns_updrec
modifier|*
name|foo
decl_stmt|;
name|unsigned
name|long
name|ttl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
name|struct
name|data_string
name|name
decl_stmt|,
name|data
decl_stmt|;
name|int
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
operator|*
name|result
condition|)
block|{
name|log_error
argument_list|(
literal|"evaluate_dns_expression called with non-null %s"
argument_list|,
literal|"result pointer"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
case|case
name|expr_ns_add
case|:
name|r0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ttl
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|ttl
argument_list|)
expr_stmt|;
goto|goto
name|nsfinish
goto|;
case|case
name|expr_ns_exists
case|:
name|ttl
operator|=
literal|1
expr_stmt|;
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_not_exists
case|:
name|r0
operator|=
literal|1
expr_stmt|;
name|nsfinish
label|:
name|memset
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
name|r1
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|name
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
condition|)
block|{
comment|/* The result of the evaluation may or may not 			   be NUL-terminated, but we need it 			   terminated for sure, so we have to allocate 			   a buffer and terminate it. */
name|tname
operator|=
name|dmalloc
argument_list|(
name|name
operator|.
name|len
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tname
condition|)
block|{
name|r2
operator|=
literal|0
expr_stmt|;
name|r1
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|tname
argument_list|,
name|name
operator|.
name|data
argument_list|,
name|name
operator|.
name|len
argument_list|)
expr_stmt|;
name|tname
index|[
name|name
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|r2
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|r2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r0
operator|&&
name|r1
operator|&&
operator|(
name|r2
operator|||
name|expr
operator|->
name|op
operator|!=
name|expr_ns_add
operator|)
condition|)
block|{
operator|*
name|result
operator|=
name|minires_mkupdrec
argument_list|(
operator|(
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_ns_add
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_delete
operator|)
condition|?
name|S_UPDATE
else|:
name|S_PREREQ
operator|)
argument_list|,
name|tname
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|result
condition|)
block|{
name|ngood
label|:
if|if
condition|(
name|r2
condition|)
block|{
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|data
operator|.
name|len
condition|)
block|{
comment|/* As a special case, if we get exactly 				   four bytes of data, it's an IP address 				   represented as a 32-bit quantity, which 				   is actually what we *should* be getting 				   here.   Because res_mkupdrec is currently 				   broken and expects a dotted quad, convert 				   it.   This should be fixed when the new 				   resolver is merged. */
if|if
condition|(
name|data
operator|.
name|len
operator|==
literal|4
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
operator|=
name|dmalloc
argument_list|(
literal|16
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
condition|)
goto|goto
name|dpngood
goto|;
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data
operator|=
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
expr_stmt|;
comment|/*%Audit% 16 bytes max. %2004.06.17,Safe%*/
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|data
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|data
operator|.
name|data
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|data
operator|.
name|data
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|data
operator|.
name|data
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|r_size
operator|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|r_size
operator|=
name|data
operator|.
name|len
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
operator|=
name|dmalloc
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
condition|)
block|{
name|dpngood
label|:
comment|/* double plus ungood. */
name|minires_freeupdrec
argument_list|(
operator|*
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|ngood
goto|;
block|}
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data
operator|=
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data_ephem
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|r_data
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|r_size
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|expr_ns_add
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|r_opcode
operator|=
name|ADD
expr_stmt|;
break|break;
case|case
name|expr_ns_delete
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|r_opcode
operator|=
name|DELETE
expr_stmt|;
break|break;
case|case
name|expr_ns_exists
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
break|break;
case|case
name|expr_ns_not_exists
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|r_opcode
operator|=
name|NXRRSET
expr_stmt|;
break|break;
comment|/* Can't happen, but satisfy gcc. */
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|r1
condition|)
block|{
name|data_string_forget
argument_list|(
operator|&
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|tname
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r2
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* One flaw in the thinking here: an IP address and an 		   ASCII string both look like data expressions, but 		   for A records, we want an ASCII string, not a 		   binary IP address.  Do I need to turn binary IP 		   addresses into a seperate type?  */
return|return
operator|(
name|r0
operator|&&
name|r1
operator|&&
operator|(
name|r2
operator|||
name|expr
operator|->
name|op
operator|!=
name|expr_ns_add
operator|)
operator|&&
operator|*
name|result
operator|)
return|;
else|#
directive|else
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
return|return
literal|0
return|;
endif|#
directive|endif
case|case
name|expr_funcall
case|:
name|log_error
argument_list|(
literal|"%s: dns values for functions not supported."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_variable_reference
case|:
name|log_error
argument_list|(
literal|"%s: dns values for variables not supported."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_check
case|:
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
case|case
name|expr_and
case|:
case|case
name|expr_or
case|:
case|case
name|expr_not
case|:
case|case
name|expr_match
case|:
case|case
name|expr_static
case|:
case|case
name|expr_known
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_variable_exists
case|:
name|log_error
argument_list|(
literal|"Boolean opcode in evaluate_dns_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_none
case|:
case|case
name|expr_substring
case|:
case|case
name|expr_suffix
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_const_data
case|:
case|case
name|expr_packet
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_reverse
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_pick_first_value
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_leased_address
case|:
case|case
name|expr_null
case|:
name|log_error
argument_list|(
literal|"Data opcode in evaluate_dns_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
name|log_error
argument_list|(
literal|"Numeric opcode in evaluate_dns_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_function
case|:
name|log_error
argument_list|(
literal|"Function opcode in evaluate_dns_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_arg
case|:
break|break;
block|}
name|log_error
argument_list|(
literal|"Bogus opcode in evaluate_dns_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (NSUPDATE) */
end_comment

begin_function
name|int
name|evaluate_boolean_expression
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|)
name|int
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|data_string
name|left
decl_stmt|,
name|right
decl_stmt|;
name|struct
name|data_string
name|rrtype
decl_stmt|,
name|rrname
decl_stmt|,
name|rrdata
decl_stmt|;
name|unsigned
name|long
name|ttl
decl_stmt|;
name|int
name|srrtype
decl_stmt|,
name|srrname
decl_stmt|,
name|srrdata
decl_stmt|,
name|sttl
decl_stmt|;
name|int
name|bleft
decl_stmt|,
name|bright
decl_stmt|;
name|int
name|sleft
decl_stmt|,
name|sright
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|struct
name|binding_value
modifier|*
name|bv
decl_stmt|,
modifier|*
name|obv
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|expr_check
case|:
operator|*
name|result
operator|=
name|check_collection
argument_list|(
name|packet
argument_list|,
name|lease
argument_list|,
name|expr
operator|->
name|data
operator|.
name|check
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: check (%s) returns %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|check
operator|->
name|name
argument_list|,
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
name|bv
operator|=
name|obv
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
name|sleft
operator|=
name|evaluate_expression
argument_list|(
operator|&
name|bv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_expression
argument_list|(
operator|&
name|obv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
if|if
condition|(
name|bv
operator|->
name|type
operator|!=
name|obv
operator|->
name|type
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|obv
operator|->
name|type
condition|)
block|{
case|case
name|binding_boolean
case|:
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|boolean
operator|==
name|obv
operator|->
name|value
operator|.
name|boolean
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
break|break;
case|case
name|binding_data
case|:
if|if
condition|(
operator|(
name|bv
operator|->
name|value
operator|.
name|data
operator|.
name|len
operator|==
name|obv
operator|->
name|value
operator|.
name|data
operator|.
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|bv
operator|->
name|value
operator|.
name|data
operator|.
name|data
argument_list|,
name|obv
operator|->
name|value
operator|.
name|data
operator|.
name|data
argument_list|,
name|obv
operator|->
name|value
operator|.
name|data
operator|.
name|len
argument_list|)
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
break|break;
case|case
name|binding_numeric
case|:
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|intval
operator|==
name|obv
operator|->
name|value
operator|.
name|intval
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
break|break;
case|case
name|binding_dns
case|:
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
comment|/* XXX This should be a comparison for equal 			       XXX values, not for identity. */
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|dns
operator|==
name|obv
operator|->
name|value
operator|.
name|dns
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
else|#
directive|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|binding_function
case|:
if|if
condition|(
name|bv
operator|->
name|value
operator|.
name|fundef
operator|==
name|obv
operator|->
name|value
operator|.
name|fundef
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
break|break;
default|default:
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|sleft
operator|&&
operator|!
name|sright
condition|)
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_equal
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: %sequal = %s"
argument_list|,
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
condition|?
literal|"not"
else|:
literal|""
argument_list|,
operator|(
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sright
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|obv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|expr_and
case|:
name|sleft
operator|=
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bleft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleft
operator|&&
name|bleft
condition|)
name|sright
operator|=
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sright
operator|=
name|bright
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: and (%s, %s) = %s"
argument_list|,
name|sleft
condition|?
operator|(
name|bleft
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|,
name|sright
condition|?
operator|(
name|bright
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|,
operator|(
operator|(
name|sleft
operator|&&
name|sright
operator|)
condition|?
operator|(
name|bleft
operator|&&
name|bright
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|bleft
operator|&&
name|bright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_or
case|:
name|bleft
operator|=
name|bright
operator|=
literal|0
expr_stmt|;
name|sleft
operator|=
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bleft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|or
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sleft
operator|||
operator|!
name|bleft
condition|)
name|sright
operator|=
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|or
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sright
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: or (%s, %s) = %s"
argument_list|,
name|sleft
condition|?
operator|(
name|bleft
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|,
name|sright
condition|?
operator|(
name|bright
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|,
operator|(
operator|(
name|sleft
operator|||
name|sright
operator|)
condition|?
operator|(
name|bleft
operator|||
name|bright
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|||
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|bleft
operator|||
name|bright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_not
case|:
name|sleft
operator|=
name|evaluate_boolean_expression
argument_list|(
operator|&
name|bleft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|not
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: not (%s) = %s"
argument_list|,
name|sleft
condition|?
operator|(
name|bleft
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|,
operator|(
operator|(
name|sleft
operator|&&
name|sright
operator|)
condition|?
operator|(
operator|!
name|bleft
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
condition|)
block|{
operator|*
name|result
operator|=
operator|!
name|bleft
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_exists
case|:
name|memset
argument_list|(
operator|&
name|left
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_options
operator|||
operator|!
name|get_option
argument_list|(
operator|&
name|left
argument_list|,
name|expr
operator|->
name|data
operator|.
name|exists
operator|->
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|in_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|exists
operator|->
name|code
argument_list|,
name|MDL
argument_list|)
condition|)
operator|*
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|result
operator|=
literal|1
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|left
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: exists %s.%s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|name
argument_list|,
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_known
case|:
if|if
condition|(
operator|!
name|packet
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: known = NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: known = %s"
argument_list|,
name|packet
operator|->
name|known
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|=
name|packet
operator|->
name|known
expr_stmt|;
return|return
literal|1
return|;
case|case
name|expr_static
case|:
if|if
condition|(
operator|!
name|lease
operator|||
operator|!
operator|(
name|lease
operator|->
name|flags
operator|&
name|STATIC_LEASE
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: static = false (%s %s %s %d)"
argument_list|,
name|lease
condition|?
literal|"y"
else|:
literal|"n"
argument_list|,
operator|(
name|lease
operator|&&
operator|(
name|lease
operator|->
name|flags
operator|&
name|STATIC_LEASE
operator|)
condition|?
literal|"y"
else|:
literal|"n"
operator|)
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|ip_addr
argument_list|)
argument_list|,
name|lease
condition|?
name|lease
operator|->
name|flags
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"bool: static = true"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|expr_variable_exists
case|:
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
block|{
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
condition|)
operator|*
name|result
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|result
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"boolean: %s? = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|,
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_variable_reference
case|:
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
block|{
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|type
operator|==
name|binding_boolean
condition|)
block|{
operator|*
name|result
operator|=
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|boolean
expr_stmt|;
name|sleft
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"binding type %d in %s."
argument_list|,
name|binding
operator|->
name|value
operator|->
name|type
argument_list|,
literal|"evaluate_boolean_expression"
argument_list|)
expr_stmt|;
name|sleft
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|sleft
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sleft
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"boolean: %s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|,
name|sleft
condition|?
operator|(
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sleft
return|;
case|case
name|expr_funcall
case|:
name|bv
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
name|sleft
operator|=
name|evaluate_expression
argument_list|(
operator|&
name|bv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleft
condition|)
block|{
if|if
condition|(
name|bv
operator|->
name|type
operator|!=
name|binding_boolean
condition|)
name|log_error
argument_list|(
literal|"%s() returned type %d in %s."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|bv
operator|->
name|type
argument_list|,
literal|"evaluate_boolean_expression"
argument_list|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|bv
operator|->
name|value
operator|.
name|boolean
expr_stmt|;
name|binding_value_dereference
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"boolean: %s() = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|sleft
condition|?
operator|(
operator|*
name|result
condition|?
literal|"true"
else|:
literal|"false"
operator|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|expr_none
case|:
case|case
name|expr_match
case|:
case|case
name|expr_substring
case|:
case|case
name|expr_suffix
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_const_data
case|:
case|case
name|expr_packet
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_reverse
case|:
case|case
name|expr_pick_first_value
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_leased_address
case|:
case|case
name|expr_null
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
name|log_error
argument_list|(
literal|"Data opcode in evaluate_boolean_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
name|log_error
argument_list|(
literal|"Numeric opcode in evaluate_boolean_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
name|log_error
argument_list|(
literal|"dns opcode in evaluate_boolean_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_function
case|:
name|log_error
argument_list|(
literal|"function definition in evaluate_boolean_expr"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_arg
case|:
break|break;
block|}
name|log_error
argument_list|(
literal|"Bogus opcode in evaluate_boolean_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evaluate_data_expression
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|data_string
name|data
decl_stmt|,
name|other
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|binding_value
modifier|*
name|bv
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
comment|/* Extract N bytes starting at byte M of a data string. */
case|case
name|expr_substring
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|s0
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Evaluate the offset and length. */
name|s1
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|offset
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|)
expr_stmt|;
name|s2
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
operator|&&
name|s2
condition|)
block|{
comment|/* If the offset is after end of the string, 			   return an empty string.  Otherwise, do the 			   adjustments and return what's left. */
if|if
condition|(
name|data
operator|.
name|len
operator|>
name|offset
condition|)
block|{
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|len
operator|>
name|len
condition|)
block|{
name|result
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|->
name|data
operator|+=
name|offset
expr_stmt|;
block|}
name|s3
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|s3
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: substring (%s, %s, %s) = %s"
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s1
condition|?
name|print_dec_1
argument_list|(
name|offset
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s2
condition|?
name|print_dec_2
argument_list|(
name|len
argument_list|)
else|:
literal|"NULL"
argument_list|,
operator|(
name|s3
condition|?
name|print_hex_2
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s0
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s3
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* Extract the last N bytes of a data string. */
case|case
name|expr_suffix
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|s0
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Evaluate the length. */
name|s1
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
condition|)
block|{
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* If we are returning the last N bytes of a 			   string whose length is<= N, just return 			   the string - otherwise, compute a new 			   starting address and decrease the 			   length. */
if|if
condition|(
name|data
operator|.
name|len
operator|>
name|len
condition|)
block|{
name|result
operator|->
name|data
operator|+=
name|data
operator|.
name|len
operator|-
name|len
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|len
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: suffix (%s, %s) = %s"
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s1
condition|?
name|print_dec_1
argument_list|(
name|len
argument_list|)
else|:
literal|"NULL"
argument_list|,
operator|(
operator|(
name|s0
operator|&&
name|s1
operator|)
condition|?
name|print_hex_2
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
operator|&&
name|s1
return|;
comment|/* Extract an option. */
case|case
name|expr_option
case|:
if|if
condition|(
name|in_options
condition|)
name|s0
operator|=
name|get_option
argument_list|(
name|result
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|in_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|code
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: option %s.%s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|name
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_config_option
case|:
if|if
condition|(
name|cfg_options
condition|)
name|s0
operator|=
name|get_option
argument_list|(
name|result
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|code
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: config-option %s.%s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
operator|->
name|name
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|name
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
comment|/* Combine the hardware type and address. */
case|case
name|expr_hardware
case|:
comment|/* On the client, hardware is our hardware. */
if|if
condition|(
name|client_state
condition|)
block|{
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|result
argument_list|)
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|client_state
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|client_state
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: hardware = %s"
argument_list|,
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* The server cares about the client's hardware address, 		   so only in the case where we are examining a packet can 		   we return anything. */
if|if
condition|(
operator|!
name|packet
operator|||
operator|!
name|packet
operator|->
name|raw
condition|)
block|{
name|log_error
argument_list|(
literal|"data: hardware: raw packet not available"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|>
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|chaddr
condition|)
block|{
name|log_error
argument_list|(
literal|"data: hardware: invalid hlen (%d)\n"
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|->
name|len
operator|=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|packet
operator|->
name|raw
operator|->
name|htype
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|1
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: hardware: no memory for buffer."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: hardware = %s"
argument_list|,
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
comment|/* Extract part of the raw packet. */
case|case
name|expr_packet
case|:
if|if
condition|(
operator|!
name|packet
operator|||
operator|!
name|packet
operator|->
name|raw
condition|)
block|{
name|log_error
argument_list|(
literal|"data: packet: raw packet not available"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|offset
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|offset
argument_list|)
expr_stmt|;
name|s1
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
operator|&&
name|offset
operator|<
name|packet
operator|->
name|packet_length
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|len
operator|>
name|packet
operator|->
name|packet_length
condition|)
name|result
operator|->
name|len
operator|=
name|packet
operator|->
name|packet_length
operator|-
name|offset
expr_stmt|;
else|else
name|result
operator|->
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|buffer
operator|->
name|data
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|packet
operator|->
name|raw
operator|)
operator|)
operator|+
name|offset
operator|)
argument_list|,
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: packet: no buffer memory."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s2
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|s2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: packet (%ld, %ld) = %s"
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|s2
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s2
return|;
comment|/* The encapsulation of all defined options in an 		   option space... */
case|case
name|expr_encapsulate
case|:
if|if
condition|(
name|cfg_options
condition|)
name|s0
operator|=
name|option_space_encapsulate
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
operator|&
name|expr
operator|->
name|data
operator|.
name|encapsulate
argument_list|)
expr_stmt|;
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: encapsulate (%s) = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|encapsulate
operator|.
name|data
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
comment|/* Some constant data... */
case|case
name|expr_const_data
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: const = %s"
argument_list|,
name|print_hex_1
argument_list|(
name|expr
operator|->
name|data
operator|.
name|const_data
operator|.
name|len
argument_list|,
name|expr
operator|->
name|data
operator|.
name|const_data
operator|.
name|data
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|expr
operator|->
name|data
operator|.
name|const_data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Hostname lookup... */
case|case
name|expr_host_lookup
case|:
name|s0
operator|=
name|do_host_lookup
argument_list|(
name|result
argument_list|,
name|expr
operator|->
name|data
operator|.
name|host_lookup
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: DNS lookup (%s) = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|host_lookup
operator|->
name|hostname
argument_list|,
operator|(
name|s0
condition|?
name|print_dotted_quads
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
comment|/* Concatenation... */
case|case
name|expr_concat
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|s0
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|other
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|other
argument_list|)
expr_stmt|;
name|s1
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|other
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
condition|)
block|{
name|result
operator|->
name|len
operator|=
name|data
operator|.
name|len
operator|+
name|other
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
operator|(
name|result
operator|->
name|len
operator|+
name|other
operator|.
name|terminated
operator|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: concat: no memory"
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|other
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|buffer
operator|->
name|data
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|data
operator|.
name|len
index|]
argument_list|,
name|other
operator|.
name|data
argument_list|,
name|other
operator|.
name|len
operator|+
name|other
operator|.
name|terminated
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s0
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
condition|)
name|data_string_forget
argument_list|(
operator|&
name|other
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: concat (%s, %s) = %s"
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|20
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s1
condition|?
name|print_hex_2
argument_list|(
name|other
operator|.
name|len
argument_list|,
name|other
operator|.
name|data
argument_list|,
literal|20
argument_list|)
else|:
literal|"NULL"
argument_list|,
operator|(
operator|(
name|s0
operator|&&
name|s1
operator|)
condition|?
name|print_hex_3
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
operator|&&
name|s1
return|;
case|case
name|expr_encode_int8
case|:
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|encode_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
condition|)
block|{
name|result
operator|->
name|len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: encode_int8: no memory"
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
block|}
block|}
else|else
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
operator|!
name|s0
condition|)
name|log_debug
argument_list|(
literal|"data: encode_int8 (NULL) = NULL"
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"data: encode_int8 (%ld) = %s"
argument_list|,
name|len
argument_list|,
name|print_hex_2
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_encode_int16
case|:
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|encode_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
condition|)
block|{
name|result
operator|->
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
literal|2
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: encode_int16: no memory"
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|putUShort
argument_list|(
name|result
operator|->
name|buffer
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
operator|!
name|s0
condition|)
name|log_debug
argument_list|(
literal|"data: encode_int16 (NULL) = NULL"
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"data: encode_int16 (%ld) = %s"
argument_list|,
name|len
argument_list|,
name|print_hex_2
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_encode_int32
case|:
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|encode_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
condition|)
block|{
name|result
operator|->
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
literal|4
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: encode_int32: no memory"
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|putULong
argument_list|(
name|result
operator|->
name|buffer
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|result
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
operator|!
name|s0
condition|)
name|log_debug
argument_list|(
literal|"data: encode_int32 (NULL) = NULL"
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"data: encode_int32 (%ld) = %s"
argument_list|,
name|len
argument_list|,
name|print_hex_2
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_binary_to_ascii
case|:
comment|/* Evaluate the base (offset) and width (len): */
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|offset
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|base
argument_list|)
expr_stmt|;
name|s1
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|width
argument_list|)
expr_stmt|;
comment|/* Evaluate the seperator string. */
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|s2
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|seperator
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Evaluate the data to be converted. */
name|memset
argument_list|(
operator|&
name|other
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|other
argument_list|)
expr_stmt|;
name|s3
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|other
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
operator|&&
name|s2
operator|&&
name|s3
condition|)
block|{
name|unsigned
name|buflen
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|8
operator|&&
name|len
operator|!=
literal|16
operator|&&
name|len
operator|!=
literal|32
condition|)
block|{
name|log_info
argument_list|(
literal|"binary_to_ascii: %s %ld!"
argument_list|,
literal|"invalid width"
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|b2a_out
goto|;
block|}
name|len
operator|/=
literal|8
expr_stmt|;
comment|/* The buffer must be a multiple of the number's 			   width. */
if|if
condition|(
name|other
operator|.
name|len
operator|%
name|len
condition|)
block|{
name|log_info
argument_list|(
literal|"binary-to-ascii: %s %d %s %ld!"
argument_list|,
literal|"length of buffer"
argument_list|,
name|other
operator|.
name|len
argument_list|,
literal|"not a multiple of width"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|b2a_out
goto|;
block|}
comment|/* Count the width of the output. */
name|buflen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|len
condition|;
name|i
operator|+=
name|len
control|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|data
index|[
name|i
index|]
operator|<
literal|8
condition|)
name|buflen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|other
operator|.
name|data
index|[
name|i
index|]
operator|<
literal|64
condition|)
name|buflen
operator|+=
literal|2
expr_stmt|;
else|else
name|buflen
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|10
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|data
index|[
name|i
index|]
operator|<
literal|10
condition|)
name|buflen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|other
operator|.
name|data
index|[
name|i
index|]
operator|<
literal|100
condition|)
name|buflen
operator|+=
literal|2
expr_stmt|;
else|else
name|buflen
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|data
index|[
name|i
index|]
operator|<
literal|16
condition|)
name|buflen
operator|++
expr_stmt|;
else|else
name|buflen
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|buflen
operator|+=
operator|(
name|converted_length
argument_list|(
operator|&
name|other
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|buflen
operator|+=
operator|(
name|converted_length
argument_list|(
operator|&
name|other
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|len
operator|!=
name|other
operator|.
name|len
condition|)
name|buflen
operator|+=
name|data
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|buflen
operator|+
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: binary-to-ascii: no memory"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|b2a_out
goto|;
block|}
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|buflen
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|len
condition|;
name|i
operator|+=
name|len
control|)
block|{
name|buflen
operator|+=
operator|(
name|binary_to_ascii
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|buflen
index|]
argument_list|,
operator|&
name|other
operator|.
name|data
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|len
operator|!=
name|other
operator|.
name|len
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|buflen
index|]
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|buflen
operator|+=
name|data
operator|.
name|len
expr_stmt|;
block|}
block|}
comment|/* NUL terminate. */
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|buflen
index|]
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
name|b2a_out
label|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: binary-to-ascii (%s, %s, %s, %s) = %s"
argument_list|,
name|s0
condition|?
name|print_dec_1
argument_list|(
name|offset
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s1
condition|?
name|print_dec_2
argument_list|(
name|len
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s2
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s3
condition|?
name|print_hex_2
argument_list|(
name|other
operator|.
name|len
argument_list|,
name|other
operator|.
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
argument_list|,
operator|(
name|status
condition|?
name|print_hex_3
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s2
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s3
condition|)
name|data_string_forget
argument_list|(
operator|&
name|other
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|expr_reverse
case|:
comment|/* Evaluate the width (len): */
name|s0
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|len
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|width
argument_list|)
expr_stmt|;
comment|/* Evaluate the data. */
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|s1
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
operator|&&
name|s1
condition|)
block|{
name|char
modifier|*
name|upper
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The buffer must be a multiple of the number's 			   width. */
if|if
condition|(
name|data
operator|.
name|len
operator|%
name|len
condition|)
block|{
name|log_info
argument_list|(
literal|"reverse: %s %d %s %ld!"
argument_list|,
literal|"length of buffer"
argument_list|,
name|data
operator|.
name|len
argument_list|,
literal|"not a multiple of width"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|reverse_out
goto|;
block|}
comment|/* XXX reverse in place?   I don't think we can. */
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|data
operator|.
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"data: reverse: no memory"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|reverse_out
goto|;
block|}
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|data
operator|.
name|len
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|len
condition|;
name|i
operator|+=
name|len
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|data
operator|.
name|data
index|[
name|data
operator|.
name|len
operator|-
name|i
operator|-
name|len
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
name|reverse_out
label|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: reverse (%s, %s) = %s"
argument_list|,
name|s0
condition|?
name|print_dec_1
argument_list|(
name|len
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|s1
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
argument_list|,
operator|(
name|status
condition|?
name|print_hex_3
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|30
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s0
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|expr_leased_address
case|:
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|log_error
argument_list|(
literal|"data: leased_address: not available"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|->
name|len
operator|=
name|lease
operator|->
name|ip_addr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|lease
operator|->
name|ip_addr
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|ip_addr
operator|.
name|len
argument_list|)
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: leased-address: no memory."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: leased-address = %s"
argument_list|,
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_pick_first_value
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|evaluate_data_expression
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|car
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: pick_first_value (%s, xxx)"
argument_list|,
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
operator|&&
operator|(
name|evaluate_data_expression
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
argument_list|,
name|MDL
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: pick_first_value (NULL, %s)"
argument_list|,
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: pick_first_value (NULL, NULL) = NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|expr_host_decl_name
case|:
if|if
condition|(
operator|!
name|lease
operator|||
operator|!
name|lease
operator|->
name|host
condition|)
block|{
name|log_error
argument_list|(
literal|"data: host_decl_name: not available"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|lease
operator|->
name|host
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
operator|+
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|lease
operator|->
name|host
operator|->
name|name
argument_list|)
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: host-decl-name: no memory."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: host-decl-name = %s"
argument_list|,
name|lease
operator|->
name|host
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_null
case|:
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: null = NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|expr_variable_reference
case|:
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
block|{
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|type
operator|==
name|binding_data
condition|)
block|{
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|s0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|type
operator|!=
name|binding_data
condition|)
block|{
name|log_error
argument_list|(
literal|"binding type %d in %s."
argument_list|,
name|binding
operator|->
name|value
operator|->
name|type
argument_list|,
literal|"evaluate_data_expression"
argument_list|)
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s0
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: %s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|50
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_funcall
case|:
name|bv
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
name|s0
operator|=
name|evaluate_expression
argument_list|(
operator|&
name|bv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s0
condition|)
block|{
if|if
condition|(
name|bv
operator|->
name|type
operator|!=
name|binding_data
condition|)
name|log_error
argument_list|(
literal|"%s() returned type %d in %s."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|bv
operator|->
name|type
argument_list|,
literal|"evaluate_data_expression"
argument_list|)
expr_stmt|;
else|else
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|bv
operator|->
name|value
operator|.
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|binding_value_dereference
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: %s = %s"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|s0
condition|?
name|print_hex_1
argument_list|(
name|result
operator|->
name|len
argument_list|,
name|result
operator|->
name|data
argument_list|,
literal|50
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Extract the filename. */
case|case
name|expr_filename
case|:
if|if
condition|(
name|packet
operator|&&
name|packet
operator|->
name|raw
operator|->
name|file
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|fn
init|=
name|memchr
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
name|fn
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|file
operator|+
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|file
operator|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|fn
operator|-
operator|&
operator|(
name|packet
operator|->
name|raw
operator|->
name|file
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
operator|+
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|result
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
name|s0
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: filename: no memory."
argument_list|)
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_info
argument_list|(
literal|"data: filename = \"%s\""
argument_list|,
name|s0
condition|?
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|result
operator|->
name|data
operator|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
comment|/* Extract the server name. */
case|case
name|expr_sname
case|:
if|if
condition|(
name|packet
operator|&&
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|fn
init|=
name|memchr
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
name|fn
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|sname
operator|+
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|sname
operator|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|fn
operator|-
operator|&
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|buffer_allocate
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|result
operator|->
name|len
operator|+
literal|1
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
block|{
name|result
operator|->
name|data
operator|=
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|result
operator|->
name|buffer
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|result
operator|->
name|buffer
operator|->
name|data
index|[
name|result
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|1
expr_stmt|;
name|s0
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"data: sname: no memory."
argument_list|)
expr_stmt|;
name|s0
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|s0
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_info
argument_list|(
literal|"data: sname = \"%s\""
argument_list|,
name|s0
condition|?
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|result
operator|->
name|data
operator|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s0
return|;
case|case
name|expr_check
case|:
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
case|case
name|expr_and
case|:
case|case
name|expr_or
case|:
case|case
name|expr_not
case|:
case|case
name|expr_match
case|:
case|case
name|expr_static
case|:
case|case
name|expr_known
case|:
case|case
name|expr_none
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_variable_exists
case|:
name|log_error
argument_list|(
literal|"Boolean opcode in evaluate_data_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
name|log_error
argument_list|(
literal|"Numeric opcode in evaluate_data_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
name|log_error
argument_list|(
literal|"dns update opcode in evaluate_data_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_function
case|:
name|log_error
argument_list|(
literal|"function definition in evaluate_data_expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_arg
case|:
break|break;
block|}
name|log_error
argument_list|(
literal|"Bogus opcode in evaluate_data_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evaluate_numeric_expression
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|)
name|unsigned
name|long
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|data_string
name|data
decl_stmt|;
name|int
name|status
decl_stmt|,
name|sleft
decl_stmt|,
name|sright
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
name|ns_updrec
modifier|*
name|nut
decl_stmt|;
name|ns_updque
name|uq
decl_stmt|;
endif|#
directive|endif
name|struct
name|expression
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|struct
name|binding_value
modifier|*
name|bv
decl_stmt|;
name|unsigned
name|long
name|ileft
decl_stmt|,
name|iright
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|expr_check
case|:
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
case|case
name|expr_and
case|:
case|case
name|expr_or
case|:
case|case
name|expr_not
case|:
case|case
name|expr_match
case|:
case|case
name|expr_static
case|:
case|case
name|expr_known
case|:
case|case
name|expr_none
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_variable_exists
case|:
name|log_error
argument_list|(
literal|"Boolean opcode in evaluate_numeric_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_substring
case|:
case|case
name|expr_suffix
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_const_data
case|:
case|case
name|expr_packet
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_reverse
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_pick_first_value
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_leased_address
case|:
case|case
name|expr_null
case|:
name|log_error
argument_list|(
literal|"Data opcode in evaluate_numeric_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_extract_int8
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|result
operator|=
name|data
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"num: extract_int8 (%s) = %s"
argument_list|,
name|status
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|status
condition|?
name|print_dec_1
argument_list|(
operator|*
name|result
argument_list|)
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
case|case
name|expr_extract_int16
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|2
condition|)
operator|*
name|result
operator|=
name|getUShort
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"num: extract_int16 (%s) = %ld"
argument_list|,
operator|(
operator|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|2
operator|)
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|2
operator|)
return|;
case|case
name|expr_extract_int32
case|:
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_data_expression
argument_list|(
operator|&
name|data
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|MDL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|4
condition|)
operator|*
name|result
operator|=
name|getULong
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"num: extract_int32 (%s) = %ld"
argument_list|,
operator|(
operator|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|4
operator|)
condition|?
name|print_hex_1
argument_list|(
name|data
operator|.
name|len
argument_list|,
name|data
operator|.
name|data
argument_list|,
literal|60
argument_list|)
else|:
literal|"NULL"
operator|)
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
name|data_string_forget
argument_list|(
operator|&
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|&&
name|data
operator|.
name|len
operator|>=
literal|4
operator|)
return|;
case|case
name|expr_const_int
case|:
operator|*
name|result
operator|=
name|expr
operator|->
name|data
operator|.
name|const_int
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"number: CONSTANT = %ld"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_lease_time
case|:
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|log_error
argument_list|(
literal|"data: leased_lease: not available"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lease
operator|->
name|ends
operator|<
name|cur_time
condition|)
block|{
name|log_error
argument_list|(
literal|"%s %lu when it is now %lu"
argument_list|,
literal|"data: lease_time: lease ends at"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lease
operator|->
name|ends
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|cur_time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|result
operator|=
name|lease
operator|->
name|ends
operator|-
name|cur_time
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"number: lease-time = (%lu - %lu) = %ld"
argument_list|,
name|lease
operator|->
name|ends
argument_list|,
name|cur_time
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|expr_dns_transaction
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSUPDATE
argument_list|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|resolver_inited
condition|)
block|{
name|minires_ninit
argument_list|(
operator|&
name|resolver_state
argument_list|)
expr_stmt|;
name|resolver_inited
operator|=
literal|1
expr_stmt|;
name|resolver_state
operator|.
name|retrans
operator|=
literal|1
expr_stmt|;
name|resolver_state
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|cur
operator|=
name|expr
expr_stmt|;
do|do
block|{
name|next
operator|=
name|cur
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
expr_stmt|;
name|nut
operator|=
literal|0
expr_stmt|;
name|status
operator|=
operator|(
name|evaluate_dns_expression
argument_list|(
operator|&
name|nut
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|cur
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|car
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
goto|goto
name|dns_bad
goto|;
name|ISC_LIST_APPEND
argument_list|(
name|uq
argument_list|,
name|nut
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
comment|/* Do the update and record the error code, if there was 		   an error; otherwise set it to NOERROR. */
operator|*
name|result
operator|=
name|minires_nupdate
argument_list|(
operator|&
name|resolver_state
argument_list|,
name|ISC_LIST_HEAD
argument_list|(
name|uq
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
name|print_dns_status
argument_list|(
operator|(
name|int
operator|)
operator|*
name|result
argument_list|,
operator|&
name|uq
argument_list|)
expr_stmt|;
name|dns_bad
label|:
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|uq
argument_list|)
condition|)
block|{
name|ns_updrec
modifier|*
name|tmp
init|=
name|ISC_LIST_HEAD
argument_list|(
name|uq
argument_list|)
decl_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|uq
argument_list|,
name|tmp
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|r_data_ephem
condition|)
block|{
name|dfree
argument_list|(
name|tmp
operator|->
name|r_data_ephem
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|r_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|tmp
operator|->
name|r_data_ephem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|minires_freeupdrec
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
endif|#
directive|endif
comment|/* NSUPDATE */
case|case
name|expr_variable_reference
case|:
if|if
condition|(
name|scope
operator|&&
operator|*
name|scope
condition|)
block|{
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|type
operator|==
name|binding_numeric
condition|)
block|{
operator|*
name|result
operator|=
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_error
argument_list|(
literal|"binding type %d in %s."
argument_list|,
name|binding
operator|->
name|value
operator|->
name|type
argument_list|,
literal|"evaluate_numeric_expression"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|status
condition|)
name|log_debug
argument_list|(
literal|"numeric: %s = %ld"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"numeric: %s = NULL"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|status
return|;
case|case
name|expr_funcall
case|:
name|bv
operator|=
operator|(
expr|struct
name|binding_value
operator|*
operator|)
literal|0
expr_stmt|;
name|status
operator|=
name|evaluate_expression
argument_list|(
operator|&
name|bv
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|bv
operator|->
name|type
operator|!=
name|binding_numeric
condition|)
name|log_error
argument_list|(
literal|"%s() returned type %d in %s."
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|bv
operator|->
name|type
argument_list|,
literal|"evaluate_numeric_expression"
argument_list|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|bv
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|binding_value_dereference
argument_list|(
operator|&
name|bv
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"data: %s = %ld"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|status
condition|?
operator|*
name|result
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|expr_add
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld + %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|+
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld + NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL + %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|+
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_subtract
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld - %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|-
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld - NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL - %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|-
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_multiply
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld * %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|*
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld * NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL * %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|*
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_divide
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
if|if
condition|(
name|iright
operator|!=
literal|0
condition|)
name|log_debug
argument_list|(
literal|"num: %ld / %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|/
name|iright
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: %ld / %ld = NULL"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld / NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL / %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
operator|&&
name|iright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|/
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_remainder
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
if|if
condition|(
name|iright
operator|!=
literal|0
condition|)
name|log_debug
argument_list|(
literal|"num: %ld %% %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|%
name|iright
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: %ld %% %ld = NULL"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld %% NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL %% %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
operator|&&
name|iright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|%
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_binary_and
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld | %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|&
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld& NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL& %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|&
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_binary_or
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld | %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator||
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld | NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL | %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator||
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_binary_xor
case|:
name|sleft
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|ileft
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sright
operator|=
name|evaluate_numeric_expression
argument_list|(
operator|&
name|iright
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
operator|->
name|data
operator|.
name|and
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
name|log_debug
argument_list|(
literal|"num: %ld ^ %ld = %ld"
argument_list|,
name|ileft
argument_list|,
name|iright
argument_list|,
name|ileft
operator|^
name|iright
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleft
condition|)
name|log_debug
argument_list|(
literal|"num: %ld ^ NULL = NULL"
argument_list|,
name|ileft
argument_list|)
expr_stmt|;
else|else
name|log_debug
argument_list|(
literal|"num: NULL ^ %ld = NULL"
argument_list|,
name|iright
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sleft
operator|&&
name|sright
condition|)
block|{
operator|*
name|result
operator|=
name|ileft
operator|^
name|iright
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_client_state
case|:
if|if
condition|(
name|client_state
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"num: client-state = %d"
argument_list|,
name|client_state
operator|->
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|=
name|client_state
operator|->
name|state
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_EXPRESSIONS
argument_list|)
name|log_debug
argument_list|(
literal|"num: client-state = NULL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
name|log_error
argument_list|(
literal|"dns opcode in evaluate_numeric_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_function
case|:
name|log_error
argument_list|(
literal|"function definition in evaluate_numeric_expr"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|expr_arg
case|:
break|break;
block|}
name|log_error
argument_list|(
literal|"evaluate_numeric_expression: bogus opcode %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return data hanging off of an option cache structure, or if there    isn't any, evaluate the expression hanging off of it and return the    result of that evaluation.   There should never be both an expression    and a valid data_string. */
end_comment

begin_function
name|int
name|evaluate_option_cache
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|oc
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|oc
operator|->
name|data
operator|.
name|len
condition|)
block|{
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|oc
operator|->
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|oc
operator|->
name|expression
condition|)
return|return
literal|0
return|;
return|return
name|evaluate_data_expression
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
operator|->
name|expression
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate an option cache and extract a boolean from the result,    returning the boolean.   Return false if there is no data. */
end_comment

begin_function
name|int
name|evaluate_boolean_option_cache
parameter_list|(
name|ignorep
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|oc
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|int
modifier|*
name|ignorep
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|data_string
name|ds
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* So that we can be called with option_lookup as an argument. */
if|if
condition|(
operator|!
name|oc
operator|||
operator|!
name|in_options
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ds
operator|.
name|len
condition|)
block|{
name|result
operator|=
name|ds
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|2
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
operator|*
name|ignorep
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|ignorep
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Evaluate a boolean expression and return the result of the evaluation,    or FALSE if it failed. */
end_comment

begin_function
name|int
name|evaluate_boolean_expression_result
parameter_list|(
name|ignorep
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|expr
parameter_list|)
name|int
modifier|*
name|ignorep
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
comment|/* So that we can be called with option_lookup as an argument. */
if|if
condition|(
operator|!
name|expr
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|evaluate_boolean_expression
argument_list|(
operator|&
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|result
operator|==
literal|2
condition|)
block|{
operator|*
name|ignorep
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|ignorep
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Dereference an expression node, and if the reference count goes to zero,    dereference any data it refers to, and then free it. */
end_comment

begin_function
name|void
name|expression_dereference
parameter_list|(
name|eptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|expression
modifier|*
modifier|*
name|eptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
operator|*
name|eptr
decl_stmt|;
comment|/* Zero the pointer. */
operator|*
name|eptr
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Decrement the reference count.   If it's nonzero, we're 	   done. */
operator|--
operator|(
name|expr
operator|->
name|refcnt
operator|)
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|eptr
argument_list|,
name|expr
argument_list|,
name|expr
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|expr
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
name|expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
comment|/* Dereference subexpressions. */
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
comment|/* All the binary operators can be handled the same way. */
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_and
case|:
case|case
name|expr_or
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_substring
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_suffix
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|expr
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|expr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_not
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|not
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|not
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_packet
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|offset
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|offset
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|len
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|len
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|extract_int
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|encode_int
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|encode_int
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_encapsulate
case|:
case|case
name|expr_const_data
case|:
name|data_string_forget
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|const_data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_host_lookup
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|host_lookup
condition|)
name|dns_host_entry_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|host_lookup
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_binary_to_ascii
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|base
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|base
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|width
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|width
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|seperator
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|seperator
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|buffer
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|buffer
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_pick_first_value
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|car
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|car
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_reverse
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|width
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|width
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_dns_transaction
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|car
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|car
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_ns_add
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|ttl
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|ttl
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|ns_delete
operator|.
name|rrname
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|ns_delete
operator|.
name|rrname
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|ns_delete
operator|.
name|rrdata
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|ns_delete
operator|.
name|rrdata
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_variable_reference
case|:
case|case
name|expr_variable_exists
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|variable
condition|)
name|dfree
argument_list|(
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_funcall
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
condition|)
name|dfree
argument_list|(
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|arglist
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|funcall
operator|.
name|arglist
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_arg
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|arg
operator|.
name|val
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|arg
operator|.
name|val
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|arg
operator|.
name|next
condition|)
name|expression_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|arg
operator|.
name|next
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_function
case|:
name|fundef_dereference
argument_list|(
operator|&
name|expr
operator|->
name|data
operator|.
name|func
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
comment|/* No subexpressions. */
case|case
name|expr_leased_address
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_check
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_known
case|:
case|case
name|expr_null
case|:
break|break;
default|default:
break|break;
block|}
name|free_expression
argument_list|(
name|expr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_dns_expression
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_ns_add
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_delete
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_exists
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_not_exists
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_boolean_expression
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_check
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_exists
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_variable_exists
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_equal
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_not_equal
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_and
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_or
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_not
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_known
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_static
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_data_expression
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_substring
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_suffix
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_option
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_hardware
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_const_data
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_packet
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_concat
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encapsulate
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int8
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int16
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int32
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_host_lookup
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_binary_to_ascii
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_filename
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_sname
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_reverse
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_pick_first_value
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_host_decl_name
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_leased_address
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_config_option
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_null
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_numeric_expression
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_extract_int8
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_extract_int16
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_extract_int32
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_const_int
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_lease_time
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_dns_transaction
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_add
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_subtract
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_multiply
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_divide
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_remainder
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_binary_and
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_binary_or
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_binary_xor
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_client_state
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_compound_expression
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
return|return
operator|(
name|expr
operator|->
name|op
operator|==
name|expr_ns_add
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_delete
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_exists
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_ns_not_exists
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_substring
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_suffix
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_option
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_concat
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int8
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int16
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_encode_int32
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_binary_to_ascii
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_reverse
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_pick_first_value
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_config_option
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_extract_int8
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_extract_int16
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_extract_int32
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_dns_transaction
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|op_val
name|PROTO
argument_list|(
operator|(
expr|enum
name|expr_op
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|op_val
parameter_list|(
name|op
parameter_list|)
name|enum
name|expr_op
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|expr_none
case|:
case|case
name|expr_match
case|:
case|case
name|expr_static
case|:
case|case
name|expr_check
case|:
case|case
name|expr_substring
case|:
case|case
name|expr_suffix
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_not
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_packet
case|:
case|case
name|expr_const_data
case|:
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_variable_exists
case|:
case|case
name|expr_known
case|:
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_reverse
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_pick_first_value
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_leased_address
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_null
case|:
case|case
name|expr_variable_reference
case|:
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
case|case
name|expr_arg
case|:
case|case
name|expr_funcall
case|:
case|case
name|expr_function
case|:
comment|/* XXXDPN: Need to assign sane precedences to these. */
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
return|return
literal|100
return|;
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
return|return
literal|3
return|;
case|case
name|expr_and
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
return|return
literal|1
return|;
case|case
name|expr_or
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
return|return
literal|2
return|;
block|}
return|return
literal|100
return|;
block|}
end_function

begin_function
name|int
name|op_precedence
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|expr_op
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|int
name|ov1
decl_stmt|,
name|ov2
decl_stmt|;
return|return
name|op_val
argument_list|(
name|op1
argument_list|)
operator|-
name|op_val
argument_list|(
name|op2
argument_list|)
return|;
block|}
end_function

begin_function
name|enum
name|expression_context
name|expression_context
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|)
block|{
if|if
condition|(
name|is_data_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|context_data
return|;
if|if
condition|(
name|is_numeric_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|context_numeric
return|;
if|if
condition|(
name|is_boolean_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|context_boolean
return|;
if|if
condition|(
name|is_dns_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|context_dns
return|;
return|return
name|context_any
return|;
block|}
end_function

begin_function
name|enum
name|expression_context
name|op_context
parameter_list|(
name|op
parameter_list|)
name|enum
name|expr_op
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* XXX Why aren't these specific? */
case|case
name|expr_none
case|:
case|case
name|expr_match
case|:
case|case
name|expr_static
case|:
case|case
name|expr_check
case|:
case|case
name|expr_substring
case|:
case|case
name|expr_suffix
case|:
case|case
name|expr_concat
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_not
case|:
case|case
name|expr_option
case|:
case|case
name|expr_hardware
case|:
case|case
name|expr_packet
case|:
case|case
name|expr_const_data
case|:
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_variable_exists
case|:
case|case
name|expr_known
case|:
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_reverse
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_pick_first_value
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_leased_address
case|:
case|case
name|expr_lease_time
case|:
case|case
name|expr_null
case|:
case|case
name|expr_variable_reference
case|:
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_arg
case|:
case|case
name|expr_funcall
case|:
case|case
name|expr_function
case|:
return|return
name|context_any
return|;
case|case
name|expr_equal
case|:
case|case
name|expr_not_equal
case|:
return|return
name|context_data
return|;
case|case
name|expr_and
case|:
return|return
name|context_boolean
return|;
case|case
name|expr_or
case|:
return|return
name|context_boolean
return|;
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
return|return
name|context_numeric
return|;
block|}
return|return
name|context_any
return|;
block|}
end_function

begin_function
name|int
name|write_expression
parameter_list|(
name|file
parameter_list|,
name|expr
parameter_list|,
name|col
parameter_list|,
name|indent
parameter_list|,
name|firstp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|int
name|firstp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|obuf
index|[
literal|65
index|]
decl_stmt|;
name|int
name|scol
decl_stmt|;
name|int
name|width
decl_stmt|;
comment|/* If this promises to be a fat expression, start a new line. */
if|if
condition|(
operator|!
name|firstp
operator|&&
name|is_compound_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|indent_spaces
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|col
operator|=
name|indent
expr_stmt|;
block|}
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|expr_none
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_check
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"check"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent_concat
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"\""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|check
operator|->
name|name
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_not_equal
case|:
name|s
operator|=
literal|"!="
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_equal
case|:
name|s
operator|=
literal|"="
expr_stmt|;
name|binary
label|:
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|0
index|]
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|" "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|equal
index|[
literal|1
index|]
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_substring
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"substring"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|expr
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|offset
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_suffix
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"suffix"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|expr
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_concat
case|:
name|e
operator|=
name|expr
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"concat"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|firstp
operator|=
literal|1
expr_stmt|;
name|concat_again
label|:
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
name|firstp
argument_list|)
expr_stmt|;
name|firstp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
condition|)
goto|goto
name|no_concat_cdr
goto|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
operator|->
name|op
operator|==
name|expr_concat
condition|)
block|{
name|e
operator|=
name|e
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|concat_again
goto|;
block|}
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|no_concat_cdr
label|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_host_lookup
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"gethostbyname"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent_concat
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"\""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|host_lookup
operator|->
name|hostname
argument_list|,
literal|"\""
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_add
case|:
name|s
operator|=
literal|"+"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_subtract
case|:
name|s
operator|=
literal|"-"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_multiply
case|:
name|s
operator|=
literal|"*"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_divide
case|:
name|s
operator|=
literal|"/"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_remainder
case|:
name|s
operator|=
literal|"%"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_binary_and
case|:
name|s
operator|=
literal|"&"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_binary_or
case|:
name|s
operator|=
literal|"|"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_binary_xor
case|:
name|s
operator|=
literal|"^"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_and
case|:
name|s
operator|=
literal|"and"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_or
case|:
name|s
operator|=
literal|"or"
expr_stmt|;
goto|goto
name|binary
goto|;
case|case
name|expr_not
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"not"
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|not
argument_list|,
name|col
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_option
case|:
name|s
operator|=
literal|"option"
expr_stmt|;
name|print_option_name
label|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
operator|!=
operator|&
name|dhcp_universe
condition|)
block|{
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
operator|(
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|universe
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|expr_hardware
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"hardware"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_packet
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"packet"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|offset
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|packet
operator|.
name|len
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_const_data
case|:
name|col
operator|=
name|token_indent_data_string
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
operator|&
name|expr
operator|->
name|data
operator|.
name|const_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_extract_int8
case|:
name|width
operator|=
literal|8
expr_stmt|;
name|extract_int
label|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"extract-int"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_extract_int16
case|:
name|width
operator|=
literal|16
expr_stmt|;
goto|goto
name|extract_int
goto|;
case|case
name|expr_extract_int32
case|:
name|width
operator|=
literal|32
expr_stmt|;
goto|goto
name|extract_int
goto|;
case|case
name|expr_encode_int8
case|:
name|width
operator|=
literal|8
expr_stmt|;
name|encode_int
label|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"encode-int"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|extract_int
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_encode_int16
case|:
name|width
operator|=
literal|16
expr_stmt|;
goto|goto
name|encode_int
goto|;
case|case
name|expr_encode_int32
case|:
name|width
operator|=
literal|32
expr_stmt|;
goto|goto
name|encode_int
goto|;
case|case
name|expr_const_int
case|:
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%lu"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|const_int
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_exists
case|:
name|s
operator|=
literal|"exists"
expr_stmt|;
goto|goto
name|print_option_name
goto|;
case|case
name|expr_encapsulate
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"encapsulate"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_indent_data_string
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
operator|&
name|expr
operator|->
name|data
operator|.
name|encapsulate
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_known
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"known"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_reverse
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"reverse"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|width
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_leased_address
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"leased-address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_client_state
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"client-state"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_binary_to_ascii
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"binary-to-ascii"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|base
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|width
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|seperator
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|b2a
operator|.
name|buffer
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_config_option
case|:
name|s
operator|=
literal|"config-option"
expr_stmt|;
goto|goto
name|print_option_name
goto|;
case|case
name|expr_host_decl_name
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"host-decl-name"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_pick_first_value
case|:
name|e
operator|=
name|expr
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"concat"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|firstp
operator|=
literal|1
expr_stmt|;
name|pick_again
label|:
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|car
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
name|firstp
argument_list|)
expr_stmt|;
name|firstp
operator|=
literal|0
expr_stmt|;
comment|/* We're being very lisp-like right now - instead of                    representing this expression as (first middle . last) we're                    representing it as (first middle last), which means that the                    tail cdr is always nil.  Apologies to non-wisp-lizards - may                    this obscure way of describing the problem motivate you to                    learn more about the one true computing language. */
if|if
condition|(
operator|!
name|e
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
condition|)
goto|goto
name|no_pick_cdr
goto|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
operator|->
name|op
operator|==
name|expr_pick_first_value
condition|)
block|{
name|e
operator|=
name|e
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
expr_stmt|;
goto|goto
name|pick_again
goto|;
block|}
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|data
operator|.
name|pick_first_value
operator|.
name|cdr
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|no_pick_cdr
label|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_lease_time
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"lease-time"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_dns_transaction
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"ns-update"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|expr
init|;
name|e
operator|&&
name|e
operator|->
name|op
operator|==
name|expr_dns_transaction
condition|;
name|e
operator|=
name|e
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
control|)
block|{
if|if
condition|(
operator|!
name|scol
condition|)
block|{
name|scol
operator|=
name|col
expr_stmt|;
name|firstp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|firstp
operator|=
literal|0
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|car
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
name|firstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|dns_transaction
operator|.
name|cdr
condition|)
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
condition|)
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_ns_add
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"update"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|scol
operator|=
name|col
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|ttl
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_ns_delete
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|finish_ns_small
label|:
name|scol
operator|=
name|col
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrclass
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%d"
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrtype
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrname
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|col
operator|=
name|write_expression
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|data
operator|.
name|ns_add
operator|.
name|rrdata
argument_list|,
name|col
argument_list|,
name|scol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_ns_exists
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"exists"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
goto|goto
name|finish_ns_small
goto|;
case|case
name|expr_ns_not_exists
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"not exists"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
goto|goto
name|finish_ns_small
goto|;
case|case
name|expr_static
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_null
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_variable_reference
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
break|break;
case|case
name|expr_variable_exists
case|:
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"defined"
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|expr
operator|->
name|data
operator|.
name|variable
argument_list|)
expr_stmt|;
name|col
operator|=
name|token_print_indent
argument_list|(
name|file
argument_list|,
name|col
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_fatal
argument_list|(
literal|"invalid expression type in print_expression: %d"
argument_list|,
name|expr
operator|->
name|op
argument_list|)
expr_stmt|;
block|}
return|return
name|col
return|;
block|}
end_function

begin_function
name|struct
name|binding
modifier|*
name|find_binding
parameter_list|(
name|struct
name|binding_scope
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|bp
decl_stmt|;
name|struct
name|binding_scope
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|scope
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|outer
control|)
block|{
for|for
control|(
name|bp
operator|=
name|s
operator|->
name|bindings
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|bp
operator|->
name|name
argument_list|)
condition|)
block|{
return|return
name|bp
return|;
block|}
block|}
block|}
return|return
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|int
name|free_bindings
parameter_list|(
name|struct
name|binding_scope
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|bp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|scope
operator|->
name|bindings
init|;
name|bp
condition|;
name|bp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|name
condition|)
name|dfree
argument_list|(
name|bp
operator|->
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|value
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|bp
operator|->
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|bp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|scope
operator|->
name|bindings
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|binding_scope_dereference
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|binding_scope
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|binding_scope
modifier|*
name|binding_scope
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
operator|*
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): null pointer"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|binding_scope
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|binding_scope
operator|*
operator|)
literal|0
expr_stmt|;
operator|--
name|binding_scope
operator|->
name|refcnt
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
name|binding_scope
argument_list|,
name|binding_scope
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding_scope
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|binding_scope
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
name|binding_scope
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|free_bindings
argument_list|(
name|binding_scope
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding_scope
operator|->
name|outer
condition|)
name|binding_scope_dereference
argument_list|(
operator|&
name|binding_scope
operator|->
name|outer
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|binding_scope
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|fundef_dereference
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|fundef
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|fundef
modifier|*
name|bp
init|=
operator|*
name|ptr
decl_stmt|;
name|struct
name|string_list
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): null pointer"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): null pointer"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|bp
operator|->
name|refcnt
operator|--
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bp
operator|->
name|refcnt
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|bp
operator|->
name|args
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|dfree
argument_list|(
name|sp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|statements
condition|)
name|executable_statement_dereference
argument_list|(
operator|&
name|bp
operator|->
name|statements
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|bp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|fundef
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
end_if

begin_comment
comment|/* Post 3.0 final. */
end_comment

begin_function
name|int
name|data_subexpression_length
parameter_list|(
name|int
modifier|*
name|rv
parameter_list|,
name|struct
name|expression
modifier|*
name|expr
parameter_list|)
block|{
name|int
name|crhs
decl_stmt|,
name|clhs
decl_stmt|,
name|llhs
decl_stmt|,
name|lrhs
decl_stmt|;
switch|switch
condition|(
name|expr
operator|->
name|op
condition|)
block|{
case|case
name|expr_substring
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
operator|&&
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
operator|->
name|op
operator|==
name|expr_const_int
condition|)
block|{
operator|(
operator|*
name|rv
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|data
operator|.
name|substring
operator|.
name|len
operator|->
name|data
operator|.
name|const_int
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_packet
case|:
case|case
name|expr_suffix
case|:
if|if
condition|(
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
operator|&&
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
operator|->
name|op
operator|==
name|expr_const_int
condition|)
block|{
operator|(
operator|*
name|rv
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|data
operator|.
name|suffix
operator|.
name|len
operator|->
name|data
operator|.
name|const_int
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|expr_concat
case|:
name|clhs
operator|=
name|data_subexpression_length
argument_list|(
operator|&
name|llhs
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crhs
operator|=
name|data_subexpression_length
argument_list|(
operator|&
name|lrhs
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crhs
operator|==
literal|0
operator|||
name|clhs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|rv
operator|=
name|llhs
operator|+
name|lrhs
expr_stmt|;
return|return
literal|1
return|;
break|break;
case|case
name|expr_hardware
case|:
return|return
literal|0
return|;
case|case
name|expr_const_data
case|:
operator|*
name|rv
operator|=
name|expr
operator|->
name|data
operator|.
name|const_data
operator|.
name|len
expr_stmt|;
return|return
literal|2
return|;
case|case
name|expr_reverse
case|:
return|return
name|data_subexpression_length
argument_list|(
name|rv
argument_list|,
name|expr
operator|->
name|data
operator|.
name|reverse
operator|.
name|buffer
argument_list|)
return|;
case|case
name|expr_leased_address
case|:
case|case
name|expr_lease_time
case|:
operator|*
name|rv
operator|=
literal|4
expr_stmt|;
return|return
literal|2
return|;
case|case
name|expr_pick_first_value
case|:
name|clhs
operator|=
name|data_subexpression_length
argument_list|(
operator|&
name|llhs
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crhs
operator|=
name|data_subexpression_length
argument_list|(
operator|&
name|lrhs
argument_list|,
name|expr
operator|->
name|data
operator|.
name|concat
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crhs
operator|==
literal|0
operator|||
name|clhs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|llhs
operator|>
name|lrhs
condition|)
operator|*
name|rv
operator|=
name|llhs
expr_stmt|;
else|else
operator|*
name|rv
operator|=
name|lrhs
expr_stmt|;
return|return
literal|1
return|;
case|case
name|expr_binary_to_ascii
case|:
case|case
name|expr_config_option
case|:
case|case
name|expr_host_decl_name
case|:
case|case
name|expr_encapsulate
case|:
case|case
name|expr_filename
case|:
case|case
name|expr_sname
case|:
case|case
name|expr_host_lookup
case|:
case|case
name|expr_option
case|:
case|case
name|expr_none
case|:
case|case
name|expr_match
case|:
case|case
name|expr_check
case|:
case|case
name|expr_equal
case|:
case|case
name|expr_and
case|:
case|case
name|expr_or
case|:
case|case
name|expr_not
case|:
case|case
name|expr_extract_int8
case|:
case|case
name|expr_extract_int16
case|:
case|case
name|expr_extract_int32
case|:
case|case
name|expr_encode_int8
case|:
case|case
name|expr_encode_int16
case|:
case|case
name|expr_encode_int32
case|:
case|case
name|expr_const_int
case|:
case|case
name|expr_exists
case|:
case|case
name|expr_known
case|:
case|case
name|expr_dns_transaction
case|:
case|case
name|expr_static
case|:
case|case
name|expr_ns_add
case|:
case|case
name|expr_ns_delete
case|:
case|case
name|expr_ns_exists
case|:
case|case
name|expr_ns_not_exists
case|:
case|case
name|expr_not_equal
case|:
case|case
name|expr_null
case|:
case|case
name|expr_variable_exists
case|:
case|case
name|expr_variable_reference
case|:
case|case
name|expr_arg
case|:
case|case
name|expr_funcall
case|:
case|case
name|expr_function
case|:
case|case
name|expr_add
case|:
case|case
name|expr_subtract
case|:
case|case
name|expr_multiply
case|:
case|case
name|expr_divide
case|:
case|case
name|expr_remainder
case|:
case|case
name|expr_binary_and
case|:
case|case
name|expr_binary_or
case|:
case|case
name|expr_binary_xor
case|:
case|case
name|expr_client_state
case|:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|expr_valid_for_context
parameter_list|(
name|struct
name|expression
modifier|*
name|expr
parameter_list|,
name|enum
name|expression_context
name|context
parameter_list|)
block|{
comment|/* We don't know at parse time what type of value a function may 	   return, so we can't flag an error on it. */
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|expr_funcall
operator|||
name|expr
operator|->
name|op
operator|==
name|expr_variable_reference
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|context_any
case|:
return|return
literal|1
return|;
case|case
name|context_boolean
case|:
if|if
condition|(
name|is_boolean_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|context_data
case|:
if|if
condition|(
name|is_data_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|context_numeric
case|:
if|if
condition|(
name|is_numeric_expression
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|context_dns
case|:
if|if
condition|(
name|is_dns_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|context_data_or_numeric
case|:
if|if
condition|(
name|is_numeric_expression
argument_list|(
name|expr
argument_list|)
operator|||
name|is_data_expression
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|context_function
case|:
if|if
condition|(
name|expr
operator|->
name|op
operator|==
name|expr_function
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_function
name|struct
name|binding
modifier|*
name|create_binding
parameter_list|(
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|scope
condition|)
block|{
if|if
condition|(
operator|!
name|binding_scope_allocate
argument_list|(
name|scope
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
return|;
block|}
name|binding
operator|=
name|find_binding
argument_list|(
operator|*
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
condition|)
block|{
name|binding
operator|=
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
condition|)
return|return
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
return|;
name|memset
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|binding
argument_list|)
expr_stmt|;
name|binding
operator|->
name|name
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
operator|->
name|name
condition|)
block|{
name|dfree
argument_list|(
name|binding
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|binding
operator|*
operator|)
literal|0
return|;
block|}
name|strcpy
argument_list|(
name|binding
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|binding
operator|->
name|next
operator|=
operator|(
operator|*
name|scope
operator|)
operator|->
name|bindings
expr_stmt|;
operator|(
operator|*
name|scope
operator|)
operator|->
name|bindings
operator|=
name|binding
expr_stmt|;
block|}
return|return
name|binding
return|;
block|}
end_function

begin_function
name|int
name|bind_ds_value
parameter_list|(
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|data_string
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|create_binding
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding_value_allocate
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
condition|)
return|return
literal|0
return|;
name|data_string_copy
argument_list|(
operator|&
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
argument_list|,
name|value
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|binding
operator|->
name|value
operator|->
name|type
operator|=
name|binding_data
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|find_bound_string
parameter_list|(
name|struct
name|data_string
modifier|*
name|value
parameter_list|,
name|struct
name|binding_scope
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|find_binding
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
operator|||
operator|!
name|binding
operator|->
name|value
operator|||
name|binding
operator|->
name|value
operator|->
name|type
operator|!=
name|binding_data
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
operator|.
name|terminated
condition|)
block|{
name|data_string_copy
argument_list|(
name|value
argument_list|,
operator|&
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer_allocate
argument_list|(
operator|&
name|value
operator|->
name|buffer
argument_list|,
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
operator|.
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|->
name|buffer
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|value
operator|->
name|buffer
operator|->
name|data
argument_list|,
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
operator|.
name|data
argument_list|,
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|value
operator|->
name|data
operator|=
name|value
operator|->
name|buffer
operator|->
name|data
expr_stmt|;
name|value
operator|->
name|len
operator|=
name|binding
operator|->
name|value
operator|->
name|value
operator|.
name|data
operator|.
name|len
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|unset
parameter_list|(
name|struct
name|binding_scope
modifier|*
name|scope
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|find_binding
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|binding_value_dereference
argument_list|(
operator|&
name|binding
operator|->
name|value
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* vim: set tabstop=8: */
end_comment

end_unit

