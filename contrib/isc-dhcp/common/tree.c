begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tree.c     Routines for manipulating parse trees... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: tree.c,v 1.10 1997/05/09 08:14:57 mellon Exp $ Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_decl_stmt
specifier|static
name|TIME
name|tree_evaluate_recurse
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TIME
name|do_host_lookup
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|dns_host_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_data_copy
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|pair
name|cons
parameter_list|(
name|car
parameter_list|,
name|cdr
parameter_list|)
name|caddr_t
name|car
decl_stmt|;
name|pair
name|cdr
decl_stmt|;
block|{
name|pair
name|foo
init|=
operator|(
name|pair
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|foo
argument_list|,
literal|"cons"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foo
condition|)
name|error
argument_list|(
literal|"no memory for cons."
argument_list|)
expr_stmt|;
name|foo
operator|->
name|car
operator|=
name|car
expr_stmt|;
name|foo
operator|->
name|cdr
operator|=
name|cdr
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_function
name|struct
name|tree_cache
modifier|*
name|tree_cache
parameter_list|(
name|tree
parameter_list|)
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
block|{
name|struct
name|tree_cache
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|new_tree_cache
argument_list|(
literal|"tree_cache"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tc
condition|)
return|return
literal|0
return|;
name|tc
operator|->
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|tc
operator|->
name|len
operator|=
name|tc
operator|->
name|buf_size
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
return|return
name|tc
return|;
block|}
end_function

begin_function
name|struct
name|tree
modifier|*
name|tree_host_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|tree
modifier|*
name|nt
decl_stmt|;
name|nt
operator|=
name|new_tree
argument_list|(
literal|"tree_host_lookup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nt
condition|)
name|error
argument_list|(
literal|"No memory for host lookup tree node."
argument_list|)
expr_stmt|;
name|nt
operator|->
name|op
operator|=
name|TREE_HOST_LOOKUP
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|host_lookup
operator|.
name|host
operator|=
name|enter_dns_host
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_function
name|struct
name|dns_host_entry
modifier|*
name|enter_dns_host
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|dns_host_entry
modifier|*
name|dh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dh
operator|=
operator|(
expr|struct
name|dns_host_entry
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dns_host_entry
argument_list|)
argument_list|,
literal|"enter_dns_host"
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|dh
operator|->
name|hostname
operator|=
name|dmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
literal|"enter_dns_host"
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Can't allocate space for new host."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dh
operator|->
name|hostname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dh
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|dh
operator|->
name|data_len
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|buf_len
operator|=
literal|0
expr_stmt|;
name|dh
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
return|return
name|dh
return|;
block|}
end_function

begin_function
name|struct
name|tree
modifier|*
name|tree_const
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|tree
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|nt
operator|=
name|new_tree
argument_list|(
literal|"tree_const"
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|nt
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
argument_list|,
literal|"tree_const"
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"No memory for constant data tree node."
argument_list|)
expr_stmt|;
name|nt
operator|->
name|op
operator|=
name|TREE_CONST
expr_stmt|;
name|memcpy
argument_list|(
name|nt
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
name|nt
return|;
block|}
end_function

begin_function
name|struct
name|tree
modifier|*
name|tree_concat
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|struct
name|tree
modifier|*
name|left
decl_stmt|,
decl|*
name|right
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|tree
modifier|*
name|nt
decl_stmt|;
comment|/* If we're concatenating a null tree to a non-null tree, just 	   return the non-null tree; if both trees are null, return 	   a null tree. */
if|if
condition|(
operator|!
name|left
condition|)
return|return
name|right
return|;
if|if
condition|(
operator|!
name|right
condition|)
return|return
name|left
return|;
comment|/* If both trees are constant, combine them. */
if|if
condition|(
name|left
operator|->
name|op
operator|==
name|TREE_CONST
operator|&&
name|right
operator|->
name|op
operator|==
name|TREE_CONST
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buf
init|=
name|dmalloc
argument_list|(
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
operator|+
name|right
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
argument_list|,
literal|"tree_concat"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|error
argument_list|(
literal|"No memory to concatenate constants."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
argument_list|,
name|right
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
name|right
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
literal|"tree_concat"
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
name|right
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
literal|"tree_concat"
argument_list|)
expr_stmt|;
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|left
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
operator|+=
name|right
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
expr_stmt|;
name|free_tree
argument_list|(
name|right
argument_list|,
literal|"tree_concat"
argument_list|)
expr_stmt|;
return|return
name|left
return|;
block|}
comment|/* Otherwise, allocate a new node to concatenate the two. */
if|if
condition|(
operator|!
operator|(
name|nt
operator|=
name|new_tree
argument_list|(
literal|"tree_concat"
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"No memory for data tree concatenation node."
argument_list|)
expr_stmt|;
name|nt
operator|->
name|op
operator|=
name|TREE_CONCAT
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|concat
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|nt
operator|->
name|data
operator|.
name|concat
operator|.
name|right
operator|=
name|right
expr_stmt|;
return|return
name|nt
return|;
block|}
end_block

begin_function
name|struct
name|tree
modifier|*
name|tree_limit
parameter_list|(
name|tree
parameter_list|,
name|limit
parameter_list|)
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|int
name|limit
decl_stmt|;
block|{
name|struct
name|tree
modifier|*
name|rv
decl_stmt|;
comment|/* If the tree we're limiting is constant, limit it now. */
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|TREE_CONST
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
operator|>
name|limit
condition|)
name|tree
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
operator|=
name|limit
expr_stmt|;
return|return
name|tree
return|;
block|}
comment|/* Otherwise, put in a node which enforces the limit on evaluation. */
name|rv
operator|=
name|new_tree
argument_list|(
literal|"tree_limit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return
operator|(
expr|struct
name|tree
operator|*
operator|)
literal|0
return|;
name|rv
operator|->
name|op
operator|=
name|TREE_LIMIT
expr_stmt|;
name|rv
operator|->
name|data
operator|.
name|limit
operator|.
name|tree
operator|=
name|tree
expr_stmt|;
name|rv
operator|->
name|data
operator|.
name|limit
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
name|tree_evaluate
parameter_list|(
name|tree_cache
parameter_list|)
name|struct
name|tree_cache
modifier|*
name|tree_cache
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|bp
init|=
name|tree_cache
operator|->
name|value
decl_stmt|;
name|int
name|bc
init|=
name|tree_cache
operator|->
name|buf_size
decl_stmt|;
name|int
name|bufix
init|=
literal|0
decl_stmt|;
comment|/* If there's no tree associated with this cache, it evaluates 	   to a constant and that was detected at startup. */
if|if
condition|(
operator|!
name|tree_cache
operator|->
name|tree
condition|)
return|return
literal|1
return|;
comment|/* Try to evaluate the tree without allocating more memory... */
name|tree_cache
operator|->
name|timeout
operator|=
name|tree_evaluate_recurse
argument_list|(
operator|&
name|bufix
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|bc
argument_list|,
name|tree_cache
operator|->
name|tree
argument_list|)
expr_stmt|;
comment|/* No additional allocation needed? */
if|if
condition|(
name|bufix
operator|<=
name|bc
condition|)
block|{
name|tree_cache
operator|->
name|len
operator|=
name|bufix
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If we can't allocate more memory, return with what we 	   have (maybe nothing). */
if|if
condition|(
operator|!
operator|(
name|bp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|bufix
argument_list|,
literal|"tree_evaluate"
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Record the change in conditions... */
name|bc
operator|=
name|bufix
expr_stmt|;
name|bufix
operator|=
literal|0
expr_stmt|;
comment|/* Note that the size of the result shouldn't change on the 	   second call to tree_evaluate_recurse, since we haven't 	   changed the ``current'' time. */
name|tree_evaluate_recurse
argument_list|(
operator|&
name|bufix
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|bc
argument_list|,
name|tree_cache
operator|->
name|tree
argument_list|)
expr_stmt|;
comment|/* Free the old buffer if needed, then store the new buffer 	   location and size and return. */
if|if
condition|(
name|tree_cache
operator|->
name|value
condition|)
name|dfree
argument_list|(
name|tree_cache
operator|->
name|value
argument_list|,
literal|"tree_evaluate"
argument_list|)
expr_stmt|;
name|tree_cache
operator|->
name|value
operator|=
name|bp
expr_stmt|;
name|tree_cache
operator|->
name|len
operator|=
name|bufix
expr_stmt|;
name|tree_cache
operator|->
name|buf_size
operator|=
name|bc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|TIME
name|tree_evaluate_recurse
parameter_list|(
name|bufix
parameter_list|,
name|bufp
parameter_list|,
name|bufcount
parameter_list|,
name|tree
parameter_list|)
name|int
modifier|*
name|bufix
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
modifier|*
name|bufcount
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
block|{
name|int
name|limit
decl_stmt|;
name|TIME
name|t1
decl_stmt|,
name|t2
decl_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
name|TREE_CONCAT
case|:
name|t1
operator|=
name|tree_evaluate_recurse
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|tree
operator|->
name|data
operator|.
name|concat
operator|.
name|left
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_evaluate_recurse
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|tree
operator|->
name|data
operator|.
name|concat
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|>
name|t2
condition|)
return|return
name|t2
return|;
return|return
name|t1
return|;
case|case
name|TREE_HOST_LOOKUP
case|:
return|return
name|do_host_lookup
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|tree
operator|->
name|data
operator|.
name|host_lookup
operator|.
name|host
argument_list|)
return|;
case|case
name|TREE_CONST
case|:
name|do_data_copy
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|tree
operator|->
name|data
operator|.
name|const_val
operator|.
name|data
argument_list|,
name|tree
operator|->
name|data
operator|.
name|const_val
operator|.
name|len
argument_list|)
expr_stmt|;
name|t1
operator|=
name|MAX_TIME
expr_stmt|;
return|return
name|t1
return|;
case|case
name|TREE_LIMIT
case|:
name|limit
operator|=
operator|*
name|bufix
operator|+
name|tree
operator|->
name|data
operator|.
name|limit
operator|.
name|limit
expr_stmt|;
name|t1
operator|=
name|tree_evaluate_recurse
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|tree
operator|->
name|data
operator|.
name|limit
operator|.
name|tree
argument_list|)
expr_stmt|;
operator|*
name|bufix
operator|=
name|limit
expr_stmt|;
return|return
name|t1
return|;
default|default:
name|warn
argument_list|(
literal|"Bad node id in tree: %d."
argument_list|)
expr_stmt|;
name|t1
operator|=
name|MAX_TIME
expr_stmt|;
return|return
name|t1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|TIME
name|do_host_lookup
parameter_list|(
name|bufix
parameter_list|,
name|bufp
parameter_list|,
name|bufcount
parameter_list|,
name|dns
parameter_list|)
name|int
modifier|*
name|bufix
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
modifier|*
name|bufcount
decl_stmt|;
name|struct
name|dns_host_entry
modifier|*
name|dns
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|new_len
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"time: now = %d  dns = %d %d  diff = %d"
argument_list|,
name|cur_time
argument_list|,
name|dns
operator|->
name|timeout
argument_list|,
name|cur_time
operator|-
name|dns
operator|->
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the record hasn't timed out, just copy the data and return. */
if|if
condition|(
name|cur_time
operator|<=
name|dns
operator|->
name|timeout
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"easy copy: %x %d %x"
argument_list|,
name|dns
operator|->
name|data
argument_list|,
name|dns
operator|->
name|data_len
argument_list|,
name|dns
operator|->
name|data
condition|?
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|dns
operator|->
name|data
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_data_copy
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|dns
operator|->
name|data
argument_list|,
name|dns
operator|->
name|data_len
argument_list|)
expr_stmt|;
return|return
name|dns
operator|->
name|timeout
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"Looking up %s"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Otherwise, look it up... */
name|h
operator|=
name|gethostbyname
argument_list|(
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_H_ERRNO
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
endif|#
directive|endif
name|warn
argument_list|(
literal|"%s: host unknown."
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_H_ERRNO
break|break;
case|case
name|TRY_AGAIN
case|:
name|warn
argument_list|(
literal|"%s: temporary name server failure"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|warn
argument_list|(
literal|"%s: name server failed"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
name|warn
argument_list|(
literal|"%s: no A record associated with address"
argument_list|,
name|dns
operator|->
name|hostname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !NO_H_ERRNO */
comment|/* Okay to try again after a minute. */
return|return
name|cur_time
operator|+
literal|60
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"Lookup succeeded; first address is %x"
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Count the number of addresses we got... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|h
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Do we need to allocate more memory? */
name|new_len
operator|=
name|i
operator|*
name|h
operator|->
name|h_length
expr_stmt|;
if|if
condition|(
name|dns
operator|->
name|buf_len
operator|<
name|i
condition|)
block|{
name|unsigned
name|char
modifier|*
name|buf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|new_len
argument_list|,
literal|"do_host_lookup"
argument_list|)
decl_stmt|;
comment|/* If we didn't get more memory, use what we have. */
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|new_len
operator|=
name|dns
operator|->
name|buf_len
expr_stmt|;
if|if
condition|(
operator|!
name|dns
operator|->
name|buf_len
condition|)
block|{
name|dns
operator|->
name|timeout
operator|=
name|cur_time
operator|+
literal|60
expr_stmt|;
return|return
name|dns
operator|->
name|timeout
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dns
operator|->
name|data
condition|)
name|dfree
argument_list|(
name|dns
operator|->
name|data
argument_list|,
literal|"do_host_lookup"
argument_list|)
expr_stmt|;
name|dns
operator|->
name|data
operator|=
name|buf
expr_stmt|;
name|dns
operator|->
name|buf_len
operator|=
name|new_len
expr_stmt|;
block|}
block|}
comment|/* Addresses are conveniently stored one to the buffer, so we 	   have to copy them out one at a time... :'( */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_len
operator|/
name|h
operator|->
name|h_length
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|dns
operator|->
name|data
operator|+
name|h
operator|->
name|h_length
operator|*
name|i
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|h
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"dns -> data: %x  h -> h_addr_list [0]: %x"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|dns
operator|->
name|data
operator|)
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dns
operator|->
name|data_len
operator|=
name|new_len
expr_stmt|;
comment|/* Set the timeout for an hour from now. 	   XXX This should really use the time on the DNS reply. */
name|dns
operator|->
name|timeout
operator|=
name|cur_time
operator|+
literal|3600
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_EVAL
name|debug
argument_list|(
literal|"hard copy: %x %d %x"
argument_list|,
name|dns
operator|->
name|data
argument_list|,
name|dns
operator|->
name|data_len
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|dns
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_data_copy
argument_list|(
name|bufix
argument_list|,
name|bufp
argument_list|,
name|bufcount
argument_list|,
name|dns
operator|->
name|data
argument_list|,
name|dns
operator|->
name|data_len
argument_list|)
expr_stmt|;
return|return
name|dns
operator|->
name|timeout
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_data_copy
parameter_list|(
name|bufix
parameter_list|,
name|bufp
parameter_list|,
name|bufcount
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|int
modifier|*
name|bufix
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
modifier|*
name|bufcount
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|space
init|=
operator|*
name|bufcount
operator|-
operator|*
name|bufix
decl_stmt|;
comment|/* If there's more space than we need, use only what we need. */
if|if
condition|(
name|space
operator|>
name|len
condition|)
name|space
operator|=
name|len
expr_stmt|;
comment|/* Copy as much data as will fit, then increment the buffer index 	   by the amount we actually had to copy, which could be more. */
if|if
condition|(
name|space
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
operator|*
name|bufp
operator|+
operator|*
name|bufix
argument_list|,
name|data
argument_list|,
name|space
argument_list|)
expr_stmt|;
operator|*
name|bufix
operator|+=
name|len
expr_stmt|;
block|}
end_function

end_unit

