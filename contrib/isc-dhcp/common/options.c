begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* options.c     DHCP options parsing and reassembly. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: options.c,v 1.26.2.11 2000/06/24 07:24:02 mellon Exp $ Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|DHCP_OPTION_DATA
end_define

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Parse all available options out of the specified packet. */
end_comment

begin_function
name|void
name|parse_options
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
comment|/* Initially, zero all option pointers. */
name|memset
argument_list|(
name|packet
operator|->
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
operator|->
name|options
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't see the magic cookie, there's nothing to parse. */
if|if
condition|(
name|memcmp
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|options
argument_list|,
name|DHCP_OPTIONS_COOKIE
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|packet
operator|->
name|options_valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Go through the options field, up to the end of the packet 	   or the End field. */
name|parse_option_buffer
argument_list|(
name|packet
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|options
index|[
literal|4
index|]
argument_list|,
name|packet
operator|->
name|packet_length
operator|-
name|DHCP_FIXED_NON_UDP
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* If we parsed a DHCP Option Overload option, parse more 	   options out of the buffer(s) containing them. */
if|if
condition|(
name|packet
operator|->
name|options_valid
operator|&&
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
condition|)
block|{
if|if
condition|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|parse_option_buffer
argument_list|(
name|packet
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|2
condition|)
name|parse_option_buffer
argument_list|(
name|packet
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse options out of the specified buffer, storing addresses of option    values in packet -> options and setting packet -> options_valid if no    errors are encountered. */
end_comment

begin_function
name|void
name|parse_option_buffer
parameter_list|(
name|packet
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|buffer
operator|+
name|length
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|code
decl_stmt|;
for|for
control|(
name|s
operator|=
name|buffer
init|;
operator|*
name|s
operator|!=
name|DHO_END
operator|&&
name|s
operator|<
name|end
condition|;
control|)
block|{
name|code
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
comment|/* Pad options don't have a length - just skip them. */
if|if
condition|(
name|code
operator|==
name|DHO_PAD
condition|)
block|{
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
comment|/* All other fields (except end, see above) have a 		   one-byte length. */
name|len
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the length is outrageous, the options are bad. */
if|if
condition|(
name|s
operator|+
name|len
operator|+
literal|2
operator|>
name|end
condition|)
block|{
name|warn
argument_list|(
literal|"Option %s length %d overflows input buffer."
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet
operator|->
name|options_valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If we haven't seen this option before, just make 		   space for it and copy it there. */
if|if
condition|(
operator|!
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|data
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|"parse_option_buffer"
argument_list|)
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Can't allocate storage for option %s."
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Copy and NUL-terminate the option (in case it's an 			   ASCII string. */
name|memcpy
argument_list|(
name|t
argument_list|,
operator|&
name|s
index|[
literal|2
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|data
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* If it's a repeat, concatenate it to whatever 			   we last saw.   This is really only required 			   for clients, but what the heck... */
name|t
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dmalloc
argument_list|(
name|len
operator|+
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
operator|+
literal|1
argument_list|,
literal|"parse_option_buffer"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|error
argument_list|(
literal|"Can't expand storage for option %s."
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|data
argument_list|,
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
operator|+
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
argument_list|,
operator|&
name|s
index|[
literal|2
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|t
index|[
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|dfree
argument_list|(
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|data
argument_list|,
literal|"parse_option_buffer"
argument_list|)
expr_stmt|;
name|packet
operator|->
name|options
index|[
name|code
index|]
operator|.
name|data
operator|=
name|t
expr_stmt|;
block|}
name|s
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
block|}
name|packet
operator|->
name|options_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cons options into a big buffer, and then split them out into the    three seperate buffers if needed.  This allows us to cons up a set    of vendor options using the same routine. */
end_comment

begin_function
name|int
name|cons_options
parameter_list|(
name|inpacket
parameter_list|,
name|outpacket
parameter_list|,
name|mms
parameter_list|,
name|options
parameter_list|,
name|overload
parameter_list|,
name|terminate
parameter_list|,
name|bootpp
parameter_list|,
name|prl
parameter_list|,
name|prl_len
parameter_list|)
name|struct
name|packet
modifier|*
name|inpacket
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|outpacket
decl_stmt|;
name|int
name|mms
decl_stmt|;
name|struct
name|tree_cache
modifier|*
modifier|*
name|options
decl_stmt|;
name|int
name|overload
decl_stmt|;
comment|/* Overload flags that may be set. */
name|int
name|terminate
decl_stmt|;
name|int
name|bootpp
decl_stmt|;
name|u_int8_t
modifier|*
name|prl
decl_stmt|;
name|int
name|prl_len
decl_stmt|;
block|{
name|unsigned
name|char
name|priority_list
index|[
literal|300
index|]
decl_stmt|;
name|int
name|priority_len
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Really big buffer... */
name|int
name|main_buffer_size
decl_stmt|;
name|int
name|mainbufix
decl_stmt|,
name|bufix
decl_stmt|;
name|int
name|option_size
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* If the client has provided a maximum DHCP message size, 	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise 	   use up to the minimum IP MTU size (576 bytes). */
comment|/* XXX if a BOOTP client specifies a max message size, we will 	   honor it. */
if|if
condition|(
operator|!
name|mms
operator|&&
name|inpacket
operator|&&
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_MAX_MESSAGE_SIZE
index|]
operator|.
name|data
operator|&&
operator|(
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_MAX_MESSAGE_SIZE
index|]
operator|.
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
condition|)
name|mms
operator|=
name|getUShort
argument_list|(
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_MAX_MESSAGE_SIZE
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* If the client has provided a maximum DHCP message size, 	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise 	   use up to the minimum IP MTU size (576 bytes). */
comment|/* XXX if a BOOTP client specifies a max message size, we will 	   honor it. */
if|if
condition|(
name|mms
condition|)
name|main_buffer_size
operator|=
name|mms
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|bootpp
condition|)
name|main_buffer_size
operator|=
literal|64
expr_stmt|;
else|else
name|main_buffer_size
operator|=
literal|576
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
if|if
condition|(
name|main_buffer_size
operator|>
sizeof|sizeof
name|buffer
condition|)
name|main_buffer_size
operator|=
sizeof|sizeof
name|buffer
expr_stmt|;
comment|/* Preload the option priority list with mandatory options. */
name|priority_len
operator|=
literal|0
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_LEASE_TIME
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_MESSAGE
expr_stmt|;
comment|/* If the client has provided a list of options that it wishes 	   returned, use it to prioritize.  Otherwise, prioritize 	   based on the default priority list. */
if|if
condition|(
name|inpacket
operator|&&
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_PARAMETER_REQUEST_LIST
index|]
operator|.
name|data
condition|)
block|{
name|int
name|prlen
init|=
operator|(
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_PARAMETER_REQUEST_LIST
index|]
operator|.
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|prlen
operator|+
name|priority_len
operator|>
sizeof|sizeof
name|priority_list
condition|)
name|prlen
operator|=
operator|(
sizeof|sizeof
name|priority_list
operator|)
operator|-
name|priority_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|priority_list
index|[
name|priority_len
index|]
argument_list|,
operator|(
name|inpacket
operator|->
name|options
index|[
name|DHO_DHCP_PARAMETER_REQUEST_LIST
index|]
operator|.
name|data
operator|)
argument_list|,
name|prlen
argument_list|)
expr_stmt|;
name|priority_len
operator|+=
name|prlen
expr_stmt|;
name|prl
operator|=
name|priority_list
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prl
condition|)
block|{
if|if
condition|(
name|prl_len
operator|+
name|priority_len
operator|>
sizeof|sizeof
name|priority_list
condition|)
name|prl_len
operator|=
operator|(
sizeof|sizeof
name|priority_list
operator|)
operator|-
name|priority_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|priority_list
index|[
name|priority_len
index|]
argument_list|,
name|prl
argument_list|,
name|prl_len
argument_list|)
expr_stmt|;
name|priority_len
operator|+=
name|prl_len
expr_stmt|;
name|prl
operator|=
name|priority_list
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|priority_list
index|[
name|priority_len
index|]
argument_list|,
name|dhcp_option_default_priority_list
argument_list|,
name|sizeof_dhcp_option_default_priority_list
argument_list|)
expr_stmt|;
name|priority_len
operator|+=
name|sizeof_dhcp_option_default_priority_list
expr_stmt|;
block|}
comment|/* Copy the options into the big buffer... */
name|option_size
operator|=
name|store_options
argument_list|(
name|buffer
argument_list|,
operator|(
name|main_buffer_size
operator|-
literal|7
operator|+
operator|(
operator|(
name|overload
operator|&
literal|1
operator|)
condition|?
name|DHCP_FILE_LEN
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|overload
operator|&
literal|2
operator|)
condition|?
name|DHCP_SNAME_LEN
else|:
literal|0
operator|)
operator|)
argument_list|,
name|options
argument_list|,
name|priority_list
argument_list|,
name|priority_len
argument_list|,
name|main_buffer_size
argument_list|,
operator|(
name|main_buffer_size
operator|+
operator|(
operator|(
name|overload
operator|&
literal|1
operator|)
condition|?
name|DHCP_FILE_LEN
else|:
literal|0
operator|)
operator|)
argument_list|,
name|terminate
argument_list|)
expr_stmt|;
comment|/* Put the cookie up front... */
name|memcpy
argument_list|(
name|outpacket
operator|->
name|options
argument_list|,
name|DHCP_OPTIONS_COOKIE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
literal|4
expr_stmt|;
comment|/* If we're going to have to overload, store the overload 	   option at the beginning.  If we can, though, just store the 	   whole thing in the packet's option buffer and leave it at 	   that. */
if|if
condition|(
name|option_size
operator|<=
name|main_buffer_size
operator|-
name|mainbufix
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|outpacket
operator|->
name|options
index|[
name|mainbufix
index|]
argument_list|,
name|buffer
argument_list|,
name|option_size
argument_list|)
expr_stmt|;
name|mainbufix
operator|+=
name|option_size
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|main_buffer_size
condition|)
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
name|length
operator|=
name|DHCP_FIXED_NON_UDP
operator|+
name|mainbufix
expr_stmt|;
block|}
else|else
block|{
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_DHCP_OPTION_OVERLOAD
expr_stmt|;
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|option_size
operator|>
name|main_buffer_size
operator|-
name|mainbufix
operator|+
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|3
expr_stmt|;
else|else
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outpacket
operator|->
name|options
index|[
name|mainbufix
index|]
argument_list|,
name|buffer
argument_list|,
name|main_buffer_size
operator|-
name|mainbufix
argument_list|)
expr_stmt|;
name|bufix
operator|=
name|main_buffer_size
operator|-
name|mainbufix
expr_stmt|;
name|length
operator|=
name|DHCP_FIXED_NON_UDP
operator|+
name|mainbufix
expr_stmt|;
if|if
condition|(
name|overload
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|option_size
operator|-
name|bufix
operator|<=
name|DHCP_FILE_LEN
condition|)
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|file
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|option_size
operator|-
name|bufix
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
name|option_size
operator|-
name|bufix
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
while|while
condition|(
name|mainbufix
operator|<
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_PAD
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|file
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|DHCP_FILE_LEN
argument_list|)
expr_stmt|;
name|bufix
operator|+=
name|DHCP_FILE_LEN
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|overload
operator|&
literal|2
operator|)
operator|&&
name|option_size
operator|<
name|bufix
condition|)
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|sname
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|option_size
operator|-
name|bufix
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
name|option_size
operator|-
name|bufix
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|DHCP_SNAME_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
while|while
condition|(
name|mainbufix
operator|<
name|DHCP_SNAME_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_PAD
expr_stmt|;
block|}
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Store all the requested options into the requested buffer. */
end_comment

begin_function
name|int
name|store_options
parameter_list|(
name|buffer
parameter_list|,
name|buflen
parameter_list|,
name|options
parameter_list|,
name|priority_list
parameter_list|,
name|priority_len
parameter_list|,
name|first_cutoff
parameter_list|,
name|second_cutoff
parameter_list|,
name|terminate
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|struct
name|tree_cache
modifier|*
modifier|*
name|options
decl_stmt|;
name|unsigned
name|char
modifier|*
name|priority_list
decl_stmt|;
name|int
name|priority_len
decl_stmt|;
name|int
name|first_cutoff
decl_stmt|,
name|second_cutoff
decl_stmt|;
name|int
name|terminate
decl_stmt|;
block|{
name|int
name|bufix
init|=
literal|0
decl_stmt|;
name|int
name|option_stored
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|tto
decl_stmt|;
comment|/* Zero out the stored-lengths array. */
name|memset
argument_list|(
name|option_stored
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|option_stored
argument_list|)
expr_stmt|;
comment|/* Copy out the options in the order that they appear in the 	   priority list... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priority_len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Code for next option to try to store. */
name|int
name|code
init|=
name|priority_list
index|[
name|i
index|]
decl_stmt|;
name|int
name|optstart
decl_stmt|;
comment|/* Number of bytes left to store (some may already 		   have been stored by a previous pass). */
name|int
name|length
decl_stmt|;
comment|/* If no data is available for this option, skip it. */
if|if
condition|(
operator|!
name|options
index|[
name|code
index|]
condition|)
block|{
continue|continue;
block|}
comment|/* The client could ask for things that are mandatory, 		   in which case we should avoid storing them twice... */
if|if
condition|(
name|option_stored
index|[
name|code
index|]
condition|)
continue|continue;
name|option_stored
index|[
name|code
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Find the value of the option... */
if|if
condition|(
operator|!
name|tree_evaluate
argument_list|(
name|options
index|[
name|code
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* We should now have a constant length for the option. */
name|length
operator|=
name|options
index|[
name|code
index|]
operator|->
name|len
expr_stmt|;
comment|/* Do we add a NUL? */
if|if
condition|(
name|terminate
operator|&&
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|tto
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tto
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to store the option. */
comment|/* If the option's length is more than 255, we must store it 		   in multiple hunks.   Store 255-byte hunks first.  However, 		   in any case, if the option data will cross a buffer 		   boundary, split it across that boundary. */
name|ix
operator|=
literal|0
expr_stmt|;
name|optstart
operator|=
name|bufix
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|incr
init|=
name|length
operator|>
literal|255
condition|?
literal|255
else|:
name|length
decl_stmt|;
comment|/* If this hunk of the buffer will cross a 			   boundary, only go up to the boundary in this 			   pass. */
if|if
condition|(
name|bufix
operator|<
name|first_cutoff
operator|&&
name|bufix
operator|+
name|incr
operator|>
name|first_cutoff
condition|)
name|incr
operator|=
name|first_cutoff
operator|-
name|bufix
expr_stmt|;
elseif|else
if|if
condition|(
name|bufix
operator|<
name|second_cutoff
operator|&&
name|bufix
operator|+
name|incr
operator|>
name|second_cutoff
condition|)
name|incr
operator|=
name|second_cutoff
operator|-
name|bufix
expr_stmt|;
comment|/* If this option is going to overflow the buffer, 			   skip it. */
if|if
condition|(
name|bufix
operator|+
literal|2
operator|+
name|incr
operator|>
name|buflen
condition|)
block|{
name|bufix
operator|=
name|optstart
expr_stmt|;
break|break;
block|}
comment|/* Everything looks good - copy it in! */
name|buffer
index|[
name|bufix
index|]
operator|=
name|code
expr_stmt|;
name|buffer
index|[
name|bufix
operator|+
literal|1
index|]
operator|=
name|incr
expr_stmt|;
if|if
condition|(
name|tto
operator|&&
name|incr
operator|==
name|length
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufix
operator|+
literal|2
argument_list|,
name|options
index|[
name|code
index|]
operator|->
name|value
operator|+
name|ix
argument_list|,
name|incr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bufix
operator|+
literal|2
operator|+
name|incr
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufix
operator|+
literal|2
argument_list|,
name|options
index|[
name|code
index|]
operator|->
name|value
operator|+
name|ix
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|incr
expr_stmt|;
name|ix
operator|+=
name|incr
expr_stmt|;
name|bufix
operator|+=
literal|2
operator|+
name|incr
expr_stmt|;
block|}
block|}
return|return
name|bufix
return|;
block|}
end_function

begin_comment
comment|/* Format the specified option so that a human can easily read it. */
end_comment

begin_function
name|char
modifier|*
name|pretty_print_option
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|,
name|emit_commas
parameter_list|,
name|emit_quotes
parameter_list|)
name|unsigned
name|int
name|code
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|emit_commas
decl_stmt|;
name|int
name|emit_quotes
decl_stmt|;
block|{
specifier|static
name|char
name|optbuf
index|[
literal|32768
index|]
decl_stmt|;
comment|/* XXX */
name|int
name|hunksize
init|=
literal|0
decl_stmt|;
name|int
name|numhunk
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numelem
init|=
literal|0
decl_stmt|;
name|char
name|fmtbuf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|optbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dp
init|=
name|data
decl_stmt|;
name|struct
name|in_addr
name|foo
decl_stmt|;
name|char
name|comma
decl_stmt|;
comment|/* Code should be between 0 and 255. */
if|if
condition|(
name|code
operator|>
literal|255
condition|)
name|error
argument_list|(
literal|"pretty_print_option: bad code %d\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|emit_commas
condition|)
name|comma
operator|=
literal|','
expr_stmt|;
else|else
name|comma
operator|=
literal|' '
expr_stmt|;
comment|/* Figure out the size of the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|numhunk
condition|)
block|{
name|warn
argument_list|(
literal|"%s: Excess information in format string: %s\n"
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
operator|&
operator|(
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|numelem
operator|++
expr_stmt|;
name|fmtbuf
index|[
name|i
index|]
operator|=
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'A'
case|:
operator|--
name|numelem
expr_stmt|;
name|fmtbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|numhunk
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|data
index|[
name|k
index|]
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|data
index|[
name|k
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|k
operator|==
name|len
condition|)
block|{
name|fmtbuf
index|[
name|i
index|]
operator|=
literal|'t'
expr_stmt|;
name|numhunk
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fmtbuf
index|[
name|i
index|]
operator|=
literal|'x'
expr_stmt|;
name|hunksize
operator|++
expr_stmt|;
name|comma
operator|=
literal|':'
expr_stmt|;
name|numhunk
operator|=
literal|0
expr_stmt|;
block|}
name|fmtbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fmtbuf
index|[
name|i
index|]
operator|=
literal|'t'
expr_stmt|;
name|fmtbuf
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|numhunk
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|hunksize
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|hunksize
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'f'
case|:
name|hunksize
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
break|break;
default|default:
name|warn
argument_list|(
literal|"%s: garbage in format string: %s\n"
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
operator|&
operator|(
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for too few bytes... */
if|if
condition|(
name|hunksize
operator|>
name|len
condition|)
block|{
name|warn
argument_list|(
literal|"%s: expecting at least %d bytes; got %d"
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|hunksize
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|"<error>"
return|;
block|}
comment|/* Check for too many bytes... */
if|if
condition|(
name|numhunk
operator|==
operator|-
literal|1
operator|&&
name|hunksize
operator|<
name|len
condition|)
name|warn
argument_list|(
literal|"%s: %d extra bytes"
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|len
operator|-
name|hunksize
argument_list|)
expr_stmt|;
comment|/* If this is an array, compute its size. */
if|if
condition|(
operator|!
name|numhunk
condition|)
name|numhunk
operator|=
name|len
operator|/
name|hunksize
expr_stmt|;
comment|/* See if we got an exact number of hunks. */
if|if
condition|(
name|numhunk
operator|>
literal|0
operator|&&
name|numhunk
operator|*
name|hunksize
operator|<
name|len
condition|)
name|warn
argument_list|(
literal|"%s: %d extra bytes at end of array\n"
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|len
operator|-
name|numhunk
operator|*
name|hunksize
argument_list|)
expr_stmt|;
comment|/* A one-hunk array prints the same as a single hunk. */
if|if
condition|(
name|numhunk
operator|<
literal|0
condition|)
name|numhunk
operator|=
literal|1
expr_stmt|;
comment|/* Cycle through the array (or hunk) printing the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhunk
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numelem
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|fmtbuf
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|emit_quotes
condition|)
operator|*
name|op
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
name|dp
operator|<
name|data
operator|+
name|len
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|dp
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dp
operator|==
literal|'"'
operator|||
operator|*
name|dp
operator|==
literal|'\''
operator|||
operator|*
name|dp
operator|==
literal|'$'
operator|||
operator|*
name|dp
operator|==
literal|'`'
operator|||
operator|*
name|dp
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|emit_quotes
condition|)
operator|*
name|op
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|foo
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|getULong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|op
argument_list|,
name|inet_ntoa
argument_list|(
name|foo
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getLong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|getULong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
name|getShort
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
name|getUShort
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%x"
argument_list|,
operator|*
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|strcpy
argument_list|(
name|op
argument_list|,
operator|*
name|dp
operator|++
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"Unexpected format code %c"
argument_list|,
name|fmtbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|numelem
operator|&&
name|comma
operator|!=
literal|':'
condition|)
operator|*
name|op
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|numhunk
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|comma
expr_stmt|;
block|}
block|}
return|return
name|optbuf
return|;
block|}
end_function

begin_function
name|void
name|do_packet
parameter_list|(
name|interface
parameter_list|,
name|packet
parameter_list|,
name|len
parameter_list|,
name|from_port
parameter_list|,
name|from
parameter_list|,
name|hfrom
parameter_list|)
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|packet
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|from_port
decl_stmt|;
name|struct
name|iaddr
name|from
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hfrom
decl_stmt|;
block|{
name|struct
name|packet
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|packet
operator|->
name|hlen
operator|>
sizeof|sizeof
name|packet
operator|->
name|chaddr
condition|)
block|{
name|note
argument_list|(
literal|"Discarding packet with invalid hlen."
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|tp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|.
name|raw
operator|=
name|packet
expr_stmt|;
name|tp
operator|.
name|packet_length
operator|=
name|len
expr_stmt|;
name|tp
operator|.
name|client_port
operator|=
name|from_port
expr_stmt|;
name|tp
operator|.
name|client_addr
operator|=
name|from
expr_stmt|;
name|tp
operator|.
name|interface
operator|=
name|interface
expr_stmt|;
name|tp
operator|.
name|haddr
operator|=
name|hfrom
expr_stmt|;
name|parse_options
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|.
name|options_valid
operator|&&
name|tp
operator|.
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|data
condition|)
name|tp
operator|.
name|packet_type
operator|=
name|tp
operator|.
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|.
name|packet_type
condition|)
name|dhcp
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
else|else
name|bootp
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* Free the data associated with the options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|.
name|options
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|tp
operator|.
name|options
index|[
name|i
index|]
operator|.
name|data
condition|)
name|dfree
argument_list|(
name|tp
operator|.
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
literal|"do_packet"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

